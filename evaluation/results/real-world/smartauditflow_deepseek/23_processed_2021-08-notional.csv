nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
nTokenAction.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../internal/nTokenHandler.sol"";
import ""../../internal/markets/AssetRate.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/balances/Incentives.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../global/StorageLayoutV1.sol"";
import ""interfaces/notional/nTokenERC20.sol"";
import ""@openzeppelin/contracts/utils/SafeCast.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract nTokenAction is StorageLayoutV1, nTokenERC20 {
    using BalanceHandler for BalanceState;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;
    using SafeInt256 for int256;
    using SafeMath for uint256;

    /// @notice Total number of tokens in circulation
    /// @param nTokenAddress The address of the nToken
    /// @return totalSupply number of tokens held
    function nTokenTotalSupply(address nTokenAddress)
        external
        view
        override
        returns (uint256 totalSupply)
    {
        // prettier-ignore
        (
            totalSupply,
            /* integralTotalSupply */,
            /* lastSupplyChangeTime */
        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);
    }

    /// @notice Get the number of tokens held by the `account`
    /// @param account The address of the account to get the balance of
    /// @return The number of tokens held
    function nTokenBalanceOf(uint16 currencyId, address account)
        external
        view
        override
        returns (uint256)
    {
        // prettier-ignore
        (
            /* int cashBalance */,
            int256 nTokenBalance,
            /* uint lastClaimTime */,
            /* uint lastClaimIntegralSupply */
        ) = BalanceHandler.getBalanceStorage(account, currencyId);

        require(nTokenBalance >= 0); // dev: negative nToken balance
        return uint256(nTokenBalance);
    }

    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
    /// @param owner The address of the account holding the funds
    /// @param spender The address of the account spending the funds
    /// @return The number of tokens approved
    function nTokenTransferAllowance(
        uint16 currencyId,
        address owner,
        address spender
    ) external view override returns (uint256) {
        // This whitelist allowance supersedes any specific allowances
        uint256 allowance = nTokenWhitelist[owner][spender];
        if (allowance > 0) return allowance;

        return nTokenAllowance[owner][spender][currencyId];
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev Can only be called via the nToken proxy
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function nTokenTransferApprove(
        uint16 currencyId,
        address owner,
        address spender,
        uint256 amount
    ) external override returns (bool) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        nTokenAllowance[owner][spender][currencyId] = amount;

        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @dev Can only be called via the nToken proxy
    /// @param from The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function nTokenTransfer(
        uint16 currencyId,
        address from,
        address to,
        uint256 amount
    ) external override returns (bool) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        return _transfer(currencyId, from, to, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @dev Can only be called via the nToken proxy
    /// @param currencyId Currency id of the nToken
    /// @param spender The address of the original caller
    /// @param from The address of the source account
    /// @param to The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function nTokenTransferFrom(
        uint16 currencyId,
        address spender,
        address from,
        address to,
        uint256 amount
    ) external override returns (bool, uint256) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        uint256 allowance = nTokenWhitelist[from][spender];

        if (allowance > 0) {
            // This whitelist allowance supersedes any specific allowances
            require(allowance >= amount, ""Insufficient allowance"");
            allowance = allowance.sub(amount);
            nTokenWhitelist[from][spender] = allowance;
        } else {
            // This is the specific allowance for the nToken.
            allowance = nTokenAllowance[from][spender][currencyId];
            require(allowance >= amount, ""Insufficient allowance"");
            allowance = allowance.sub(amount);
            nTokenAllowance[from][spender][currencyId] = allowance;
        }

        bool success = _transfer(currencyId, from, to, amount);
        return (success, allowance);
    }

    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve
    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly
    /// on the Notional contract, not available via the ERC20 proxy.
    /// @dev emit:Approval
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function nTokenTransferApproveAll(address spender, uint256 amount)
        external
        override
        returns (bool)
    {
        nTokenWhitelist[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender
    /// @dev auth:msg.sender
    /// @return Total amount of incentives claimed
    function nTokenClaimIncentives() external override returns (uint256) {
        address account = msg.sender;
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        uint256 totalIncentivesClaimed;
        BalanceState memory balanceState;

        if (accountContext.bitmapCurrencyId != 0) {
            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                totalIncentivesClaimed = totalIncentivesClaimed.add(
                    BalanceHandler.claimIncentivesManual(balanceState, account)
                );
            }
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));

            balanceState.loadBalanceState(account, currencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                totalIncentivesClaimed = totalIncentivesClaimed.add(
                    BalanceHandler.claimIncentivesManual(balanceState, account)
                );
            }

            currencies = currencies << 16;
        }

        // NOTE: no need to set account context after claiming incentives
        return totalIncentivesClaimed;
    }

    /// @notice Returns the present value of the nToken's assets denominated in asset tokens
    function nTokenPresentValueAssetDenominated(uint16 currencyId)
        external
        view
        override
        returns (int256)
    {
        // prettier-ignore
        (
            int256 totalAssetPV,
            /* portfolio */
        ) = _getNTokenPV(currencyId);

        return totalAssetPV;
    }

    /// @notice Returns the present value of the nToken's assets denominated in underlying
    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)
        external
        view
        override
        returns (int256)
    {
        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);

        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);
    }

    function _getNTokenPV(uint256 currencyId)
        private
        view
        returns (int256, nTokenPortfolio memory)
    {
        uint256 blockTime = block.timestamp;
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);

        // prettier-ignore
        (
            int256 totalAssetPV,
            /* ifCashMapping */
        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);

        return (totalAssetPV, nToken);
    }

    /// @notice Transferring tokens will also claim incentives at the same time
    function _transfer(
        uint256 currencyId,
        address sender,
        address recipient,
        uint256 amount
    ) internal returns (bool) {
        {
            // prettier-ignore
            (
                uint256 isNToken,
                /* incentiveAnnualEmissionRate */,
                /* lastInitializedTime */,
                /* parameters */
            ) = nTokenHandler.getNTokenContext(recipient);
            // nTokens cannot hold nToken balances
            require(isNToken == 0, ""Cannot transfer to nToken"");
        }

        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);
        BalanceState memory senderBalance;
        senderBalance.loadBalanceState(sender, currencyId, senderContext);

        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);
        BalanceState memory recipientBalance;
        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);

        int256 amountInt = SafeCast.toInt256(amount);
        senderBalance.netNTokenTransfer = amountInt.neg();
        recipientBalance.netNTokenTransfer = amountInt;

        senderBalance.finalize(sender, senderContext, false);
        recipientBalance.finalize(recipient, recipientContext, false);
        senderContext.setAccountContext(sender);
        recipientContext.setAccountContext(recipient);

        emit Transfer(sender, recipient, amount);

        return true;
    }
}

",2309,292,"[H-01] Self transfer can lead to unlimited mint function `_transfer`
The implementation of the transfer function in nTokenAction.sol is different from the usual erc20 token transfer function.
This happens because it counts the incentive that the user gets, but with a self-transfer, it can lead to unlimited mint. In L278, it makes the amount negative, but in L279, it returns the value to an amount that is not negative. So, in the L281-282, it finalizes a positive value, only because the negative value is changed to the positive value.
You can interact with this transfer function through nTokenERC20Proxy.sol.
Recommend adding (sender != recipient).
 [M-03] Allowance checks not correctly implemented

The nTokenAction implements two token approvals, the nTokenWhitelist which is always used first, and the nTokenAllowance which is checked second. If the nTokenWhitelist does not have enough allowance for the transfer, the transaction fails, even in the case where nTokenAllowance still has enough allowance.
Transfers that have sufficient allowance fail in certain cases.
",2,,"pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../internal/nTokenHandler.sol"";
import ""../../internal/markets/AssetRate.sol"";
import ""../../internal/balances/BalanceHandler.sol"";
import ""../../internal/balances/Incentives.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../global/StorageLayoutV1.sol"";
import ""interfaces/notional/nTokenERC20.sol"";
import ""@openzeppelin/contracts/utils/SafeCast.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

contract nTokenAction is StorageLayoutV1, nTokenERC20 {
    using BalanceHandler for BalanceState;
    using AssetRate for AssetRateParameters;
    using AccountContextHandler for AccountContext;
    using SafeInt256 for int256;
    using SafeMath for uint256;

    
    
    
    function nTokenTotalSupply(address nTokenAddress)
        external
        view
        override
        returns (uint256 totalSupply)
    {
        
        (
            totalSupply,
            ,
            
        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);
    }

    
    
    
    function nTokenBalanceOf(uint16 currencyId, address account)
        external
        view
        override
        returns (uint256)
    {
        
        (
            ,
            int256 nTokenBalance,
            ,
            
        ) = BalanceHandler.getBalanceStorage(account, currencyId);

        require(nTokenBalance >= 0); 
        return uint256(nTokenBalance);
    }

    
    
    
    
    function nTokenTransferAllowance(
        uint16 currencyId,
        address owner,
        address spender
    ) external view override returns (uint256) {
        
        uint256 allowance = nTokenWhitelist[owner][spender];
        if (allowance > 0) return allowance;

        return nTokenAllowance[owner][spender][currencyId];
    }

    
    
    
    
    
    function nTokenTransferApprove(
        uint16 currencyId,
        address owner,
        address spender,
        uint256 amount
    ) external override returns (bool) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        nTokenAllowance[owner][spender][currencyId] = amount;

        return true;
    }

    
    
    
    
    
    function nTokenTransfer(
        uint16 currencyId,
        address from,
        address to,
        uint256 amount
    ) external override returns (bool) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        return _transfer(currencyId, from, to, amount);
    }

    
    
    
    
    
    
    
    
    function nTokenTransferFrom(
        uint16 currencyId,
        address spender,
        address from,
        address to,
        uint256 amount
    ) external override returns (bool, uint256) {
        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);
        require(msg.sender == nTokenAddress, ""Unauthorized caller"");

        uint256 allowance = nTokenWhitelist[from][spender];

        if (allowance > 0) {
            
            require(allowance >= amount, ""Insufficient allowance"");
            allowance = allowance.sub(amount);
            nTokenWhitelist[from][spender] = allowance;
        } else {
            
            allowance = nTokenAllowance[from][spender][currencyId];
            require(allowance >= amount, ""Insufficient allowance"");
            allowance = allowance.sub(amount);
            nTokenAllowance[from][spender][currencyId] = allowance;
        }

        bool success = _transfer(currencyId, from, to, amount);
        return (success, allowance);
    }

    
    
    
    
    
    
    
    function nTokenTransferApproveAll(address spender, uint256 amount)
        external
        override
        returns (bool)
    {
        nTokenWhitelist[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    
    
    
    function nTokenClaimIncentives() external override returns (uint256) {
        address account = msg.sender;
        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);
        uint256 totalIncentivesClaimed;
        BalanceState memory balanceState;

        if (accountContext.bitmapCurrencyId != 0) {
            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                totalIncentivesClaimed = totalIncentivesClaimed.add(
                    BalanceHandler.claimIncentivesManual(balanceState, account)
                );
            }
        }

        bytes18 currencies = accountContext.activeCurrencies;
        while (currencies != 0) {
            uint256 currencyId = uint256(uint16(bytes2(currencies) & Constants.UNMASK_FLAGS));

            balanceState.loadBalanceState(account, currencyId, accountContext);
            if (balanceState.storedNTokenBalance > 0) {
                totalIncentivesClaimed = totalIncentivesClaimed.add(
                    BalanceHandler.claimIncentivesManual(balanceState, account)
                );
            }

            currencies = currencies << 16;
        }

        
        return totalIncentivesClaimed;
    }

    
    function nTokenPresentValueAssetDenominated(uint16 currencyId)
        external
        view
        override
        returns (int256)
    {
        
        (
            int256 totalAssetPV,
            
        ) = _getNTokenPV(currencyId);

        return totalAssetPV;
    }

    
    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)
        external
        view
        override
        returns (int256)
    {
        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);

        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);
    }

    function _getNTokenPV(uint256 currencyId)
        private
        view
        returns (int256, nTokenPortfolio memory)
    {
        uint256 blockTime = block.timestamp;
        nTokenPortfolio memory nToken;
        nTokenHandler.loadNTokenPortfolioView(currencyId, nToken);

        
        (
            int256 totalAssetPV,
            
        ) = nTokenHandler.getNTokenAssetPV(nToken, blockTime);

        return (totalAssetPV, nToken);
    }

    
    function _transfer(
        uint256 currencyId,
        address sender,
        address recipient,
        uint256 amount
    ) internal returns (bool) {
        {
            
            (
                uint256 isNToken,
                ,
                ,
                
            ) = nTokenHandler.getNTokenContext(recipient);
            
            require(isNToken == 0, ""Cannot transfer to nToken"");
        }

        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);
        BalanceState memory senderBalance;
        senderBalance.loadBalanceState(sender, currencyId, senderContext);

        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);
        BalanceState memory recipientBalance;
        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);

        int256 amountInt = SafeCast.toInt256(amount);
        senderBalance.netNTokenTransfer = amountInt.neg();
        recipientBalance.netNTokenTransfer = amountInt;

        senderBalance.finalize(sender, senderContext, false);
        recipientBalance.finalize(recipient, recipientContext, false);
        senderContext.setAccountContext(sender);
        recipientContext.setAccountContext(recipient);

        emit Transfer(sender, recipient, amount);

        return true;
    }
}",1574,1,1,,"{'ReviewingTheCode': 'The provided code snippet is a Solidity smart contract named `nTokenAction` that handles operations related to nTokens, including balance queries, transfers, allowances, and incentive claims. The contract interacts with various internal modules and external libraries to manage nToken states and perform arithmetic operations safely.', 'IdentifyingKeyComponents': {'ContractName': 'nTokenAction', 'Purpose': 'To manage nToken operations such as balance queries, transfers, allowances, and incentive claims within a decentralized finance (DeFi) ecosystem.', 'InheritanceAndImports': {'InheritsFrom': ['StorageLayoutV1', 'nTokenERC20'], 'Imports': ['internal/nTokenHandler.sol', 'internal/markets/AssetRate.sol', 'internal/balances/BalanceHandler.sol', 'internal/balances/Incentives.sol', 'math/SafeInt256.sol', 'global/StorageLayoutV1.sol', 'interfaces/notional/nTokenERC20.sol', '@openzeppelin/contracts/utils/SafeCast.sol', '@openzeppelin/contracts/math/SafeMath.sol']}, 'StateVariables': [{'Name': 'nTokenWhitelist', 'Type': 'mapping(address => mapping(address => uint256))', 'Purpose': 'Stores whitelist allowances for nToken transfers.'}, {'Name': 'nTokenAllowance', 'Type': 'mapping(address => mapping(address => mapping(uint16 => uint256)))', 'Purpose': 'Stores specific allowances for nToken transfers by currency ID.'}], 'FunctionsAndModifiers': [{'Name': 'nTokenTotalSupply', 'Visibility': 'external', 'Purpose': 'Returns the total supply of nTokens for a given address.', 'Parameters': ['address nTokenAddress'], 'Returns': ['uint256 totalSupply']}, {'Name': 'nTokenBalanceOf', 'Visibility': 'external', 'Purpose': 'Returns the nToken balance of a specified account for a given currency ID.', 'Parameters': ['uint16 currencyId', 'address account'], 'Returns': ['uint256']}, {'Name': 'nTokenTransferAllowance', 'Visibility': 'external', 'Purpose': 'Returns the allowance for nToken transfers between an owner and a spender.', 'Parameters': ['uint16 currencyId', 'address owner', 'address spender'], 'Returns': ['uint256']}, {'Name': 'nTokenTransferApprove', 'Visibility': 'external', 'Purpose': 'Approves a spender to transfer nTokens on behalf of an owner.', 'Parameters': ['uint16 currencyId', 'address owner', 'address spender', 'uint256 amount'], 'Returns': ['bool']}, {'Name': 'nTokenTransfer', 'Visibility': 'external', 'Purpose': 'Transfers nTokens from one address to another.', 'Parameters': ['uint16 currencyId', 'address from', 'address to', 'uint256 amount'], 'Returns': ['bool']}, {'Name': 'nTokenTransferFrom', 'Visibility': 'external', 'Purpose': 'Transfers nTokens from one address to another on behalf of a spender.', 'Parameters': ['uint16 currencyId', 'address spender', 'address from', 'address to', 'uint256 amount'], 'Returns': ['bool', 'uint256']}, {'Name': 'nTokenTransferApproveAll', 'Visibility': 'external', 'Purpose': 'Approves a spender to transfer all nTokens on behalf of the caller.', 'Parameters': ['address spender', 'uint256 amount'], 'Returns': ['bool']}, {'Name': 'nTokenClaimIncentives', 'Visibility': 'external', 'Purpose': ""Claims incentives for the caller's nToken balances."", 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'nTokenPresentValueAssetDenominated', 'Visibility': 'external', 'Purpose': 'Returns the present value of nTokens denominated in assets.', 'Parameters': ['uint16 currencyId'], 'Returns': ['int256']}, {'Name': 'nTokenPresentValueUnderlyingDenominated', 'Visibility': 'external', 'Purpose': 'Returns the present value of nTokens denominated in underlying assets.', 'Parameters': ['uint16 currencyId'], 'Returns': ['int256']}, {'Name': '_getNTokenPV', 'Visibility': 'private', 'Purpose': 'Calculates the present value of nTokens for a given currency ID.', 'Parameters': ['uint256 currencyId'], 'Returns': ['int256', 'nTokenPortfolio memory']}, {'Name': '_transfer', 'Visibility': 'internal', 'Purpose': 'Internal function to transfer nTokens between addresses.', 'Parameters': ['uint256 currencyId', 'address sender', 'address recipient', 'uint256 amount'], 'Returns': ['bool']}]}, 'ExternalInteractions': ['nTokenHandler.getStoredNTokenSupplyFactors', 'BalanceHandler.getBalanceStorage', 'nTokenHandler.nTokenAddress', 'AccountContextHandler.getAccountContext', 'BalanceHandler.claimIncentivesManual', 'nTokenHandler.loadNTokenPortfolioView', 'nTokenHandler.getNTokenAssetPV', 'SafeCast.toInt256', 'SafeMath.sub', 'SafeMath.add'], 'SpecialMechanisms': ['The contract uses SafeMath and SafeCast libraries to prevent arithmetic overflow and underflow.', 'It employs a whitelist mechanism for nToken transfer allowances.', 'The contract interacts with internal modules to manage nToken states and incentives.'], 'Questions': ['What is the purpose of the `nTokenPortfolio` struct and how is it used in `_getNTokenPV`?', 'How does the `nTokenWhitelist` differ from `nTokenAllowance` in terms of functionality?', 'What is the significance of the `bitmapCurrencyId` in the `nTokenClaimIncentives` function?', 'How are incentives calculated and distributed in the `nTokenClaimIncentives` function?']}","{'Findings': [{'Issue': 'Unauthorized Caller Vulnerability', 'Severity': 'High', 'Description': 'Functions `nTokenTransferApprove`, `nTokenTransfer`, and `nTokenTransferFrom` check if the caller is the nToken address, but this check can be bypassed if the nToken address is compromised or misconfigured, allowing unauthorized approvals or transfers.', 'Impact': 'Unauthorized users could approve or transfer tokens, leading to potential theft or manipulation of token balances.', 'Location': 'Functions: `nTokenTransferApprove`, `nTokenTransfer`, `nTokenTransferFrom`'}, {'Issue': 'Potential Reentrancy in Transfer Functions', 'Severity': 'High', 'Description': 'The `_transfer` function lacks reentrancy protection, and external calls or state changes within it could be exploited for reentrancy attacks, especially if the function is extended in the future.', 'Impact': 'An attacker could manipulate the state or perform unauthorized actions during the transfer process, potentially leading to loss of funds.', 'Location': 'Function: `_transfer`'}, {'Issue': 'Unrestricted Approval of All Tokens', 'Severity': 'High', 'Description': 'The `nTokenTransferApproveAll` function allows any user to approve a spender for an unlimited amount of tokens, posing a significant risk if the spender is compromised or malicious.', 'Impact': ""Potential loss of all tokens if the spender's account is compromised or acts maliciously."", 'Location': 'Function: `nTokenTransferApproveAll`'}, {'Issue': 'Integer Overflow/Underflow Risk', 'Severity': 'Medium', 'Description': 'The contract uses `SafeMath` for `uint256` operations but lacks similar protections for `int256` operations, particularly in functions like `nTokenTransferFrom` and `nTokenBalanceOf`, which could lead to incorrect calculations.', 'Impact': 'Integer overflow/underflow could result in incorrect balance calculations, potentially leading to loss of funds or incorrect token transfers.', 'Location': 'Functions: `nTokenTransferFrom`, `nTokenBalanceOf`, `_transfer`'}, {'Issue': 'Insufficient Input Validation', 'Severity': 'Medium', 'Description': 'Functions like `nTokenTransfer` and `nTokenTransferFrom` do not validate the `amount` parameter or ensure the `from` and `to` addresses are valid, which could lead to unintended behavior.', 'Impact': 'Potential loss of funds or unintended transfers if invalid or malicious addresses are provided.', 'Location': 'Functions: `nTokenTransfer`, `nTokenTransferFrom`'}, {'Issue': 'Lack of Event Emission in Approval Functions', 'Severity': 'Low', 'Description': 'The `nTokenTransferApprove` function does not emit an `Approval` event, making it difficult to track and audit allowance changes.', 'Impact': 'Reduced transparency and difficulty in tracking allowance changes, complicating auditing and monitoring.', 'Location': 'Function: `nTokenTransferApprove`'}, {'Issue': 'Potential Gas Limit Issues in Incentive Claiming', 'Severity': 'Low', 'Description': 'The `nTokenClaimIncentives` function iterates over all active currencies, which could exceed gas limits for accounts with many active currencies, causing transaction failures.', 'Impact': 'Users may be unable to claim incentives, leading to potential loss of rewards.', 'Location': 'Function: `nTokenClaimIncentives`'}], 'IssueNumber': 10, 'OutputList': 7}",660.5512709617615,"### **Output**

---

**[H-01] Self transfer can lead to unlimited mint**

**Report Description**:  
The `_transfer` function in `nTokenAction.sol` differs from the standard ERC20 transfer function by accounting for user incentives. However, during a self-transfer, the function incorrectly calculates the amount, leading to a potential unlimited mint vulnerability. Specifically, the function makes the amount negative in one line but reverts it to a positive value in the next, resulting in a positive final value. This can be exploited through the `nTokenERC20Proxy.sol` contract. The recommendation is to add a check `(sender != recipient)` to prevent self-transfers.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of self-transfers leading to unlimited mint. While the response list includes issues like ""Potential Reentrancy in Transfer Functions"" and ""Integer Overflow/Underflow Risk,"" none of these directly address the self-transfer vulnerability described in the issue report.

---

**[M-03] Allowance checks not correctly implemented**

**Report Description**:  
The `nTokenAction` contract implements two token approval mechanisms: `nTokenWhitelist` and `nTokenAllowance`. The `nTokenWhitelist` is always checked first, and if it does not have sufficient allowance, the transaction fails, even if `nTokenAllowance` has enough allowance. This design flaw causes transfers with sufficient allowance to fail in certain cases, leading to unintended transaction failures.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect allowance checks in the `nTokenAction` contract. While the response list includes issues like ""Unauthorized Caller Vulnerability"" and ""Unrestricted Approval of All Tokens,"" none of these directly address the specific problem of allowance checks failing due to the order of validation.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Self transfer can lead to unlimited mint**  
- **[M-03] Allowance checks not correctly implemented**

---

### **Analysis**  
The `response_list` does not adequately address the issues raised in the `issue` report. Specifically, the issues of self-transfers leading to unlimited mint and incorrect allowance checks are not covered. The response list focuses on other vulnerabilities, such as reentrancy, unauthorized callers, and integer overflow/underflow, but these do not align with the specific concerns highlighted in the issue report. As a result, the responses are **incorrect** for the provided issues.","```
None.
```",0.0
CompoundToNotionalV2.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/compound/CTokenInterface.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract CompoundToNotionalV2 {
    NotionalProxy public immutable NotionalV2;
    address public owner;

    constructor(NotionalProxy notionalV2_) {
        NotionalV2 = notionalV2_;
        owner = msg.sender;
    }

    function enableToken(address token, address spender) external {
        require(msg.sender == owner, ""Unauthorized"");
        CTokenInterface(token).approve(spender, type(uint256).max);
    }

    function migrateBorrowFromCompound(
        address cTokenBorrow,
        uint256 cTokenRepayAmount,
        uint16[] memory notionalV2CollateralIds,
        uint256[] memory notionalV2CollateralAmounts,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        // borrow on notional via special flash loan facility
        //  - borrow repayment amount
        //  - withdraw to wallet, redeem to underlying
        // receive callback (tokens transferred to borrowing account)
        //   -> inside callback
        //   -> repayBorrowBehalf(account, repayAmount)
        //   -> deposit cToken to notional (account needs to have set approvals)
        //   -> exit callback
        // inside original borrow, check FC
        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);
        if (cTokenRepayAmount == 0) {
            // Set the entire borrow balance if it is not set
            cTokenRepayAmount = borrowBalance;
        } else {
            // Check that the cToken repayment amount is not more than required
            require(cTokenRepayAmount <= borrowBalance, ""Invalid repayment amount"");
        }

        bytes memory encodedData = abi.encode(
            cTokenBorrow,
            cTokenRepayAmount,
            notionalV2CollateralIds,
            notionalV2CollateralAmounts
        );
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");

        (
            address cTokenBorrow,
            uint256 cTokenRepayAmount,
            uint16[] memory notionalV2CollateralIds,
            uint256[] memory notionalV2CollateralAmounts
        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));

        // Transfer in the underlying amount that was borrowed
        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();
        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);
        require(success, ""Transfer of repayment failed"");

        // Use the amount transferred to repay the borrow
        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);
        require(code == 0, ""Repay borrow behalf failed"");

        for (uint256 i; i < notionalV2CollateralIds.length; i++) {
            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);
            // Transfer the collateral to this contract so we can deposit it
            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);
            require(success, ""cToken transfer failed"");

            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here
            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);
        }

        // When this exits a free collateral check will be triggered
    }

    receive() external payable {
        // This contract cannot migrate ETH loans because there is no way
        // to do transferFrom on ETH
        revert(""Cannot transfer ETH"");
    }
}
",924,100,"[H-03] CompoundToNotionalV2.notionalCallback ERC20 return values not checked

Some tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/transferFrom functions return void, instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert. See CompoundToNotionalV2.notionalCallback's IERC20(underlyingToken).transferFrom call.
Tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value. The fact that there is a cToken with USDT as the underlying this issue directly applies to the protocol.
We recommend using OpenZeppelin’s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.
 [H-04] Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed

The CompoundToNotionalV2.notionalCallback is supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providing sender = this, as sender is a parameter of the function that can be chosen by the attacker.
 [M-04] CompoundToNotionalV2.enableToken ERC20 missing return value check

The enableToken function performs an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed, returning false instead.
The impact is that, tokens that don't actually perform the approve and return false are still counted as a correct approve.
",3,,"pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/compound/CTokenInterface.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract CompoundToNotionalV2 {
    NotionalProxy public immutable NotionalV2;
    address public owner;

    constructor(NotionalProxy notionalV2_) {
        NotionalV2 = notionalV2_;
        owner = msg.sender;
    }

    function enableToken(address token, address spender) external {
        require(msg.sender == owner, ""Unauthorized"");
        CTokenInterface(token).approve(spender, type(uint256).max);
    }

    function migrateBorrowFromCompound(
        address cTokenBorrow,
        uint256 cTokenRepayAmount,
        uint16[] memory notionalV2CollateralIds,
        uint256[] memory notionalV2CollateralAmounts,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        
        
        
        
        
        
        
        
        
        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);
        if (cTokenRepayAmount == 0) {
            
            cTokenRepayAmount = borrowBalance;
        } else {
            
            require(cTokenRepayAmount <= borrowBalance, ""Invalid repayment amount"");
        }

        bytes memory encodedData = abi.encode(
            cTokenBorrow,
            cTokenRepayAmount,
            notionalV2CollateralIds,
            notionalV2CollateralAmounts
        );
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");

        (
            address cTokenBorrow,
            uint256 cTokenRepayAmount,
            uint16[] memory notionalV2CollateralIds,
            uint256[] memory notionalV2CollateralAmounts
        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));

        
        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();
        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);
        require(success, ""Transfer of repayment failed"");

        
        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);
        require(code == 0, ""Repay borrow behalf failed"");

        for (uint256 i; i < notionalV2CollateralIds.length; i++) {
            (Token memory assetToken, ) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);
            
            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);
            require(success, ""cToken transfer failed"");

            
            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);
        }

        
    }

    receive() external payable {
        
        
        revert(""Cannot transfer ETH"");
    }
}",705,2,1,,"{'ReviewingTheCode': 'The provided Solidity smart contract facilitates the migration of borrow positions from Compound to Notional V2. It includes functions to enable tokens, migrate borrow positions, and handle callbacks from Notional V2. The contract is designed to be secure, with ownership and callback authorization checks.', 'IdentifyingKeyComponents': {'ContractName': 'CompoundToNotionalV2', 'Purpose': 'To migrate borrow positions from Compound to Notional V2, enabling users to transfer their debt and collateral seamlessly.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['interfaces/compound/CTokenInterface.sol', 'interfaces/compound/CErc20Interface.sol', 'interfaces/notional/NotionalProxy.sol', '@openzeppelin/contracts/token/ERC20/IERC20.sol']}, 'StateVariables': [{'Name': 'NotionalV2', 'Type': 'NotionalProxy', 'Purpose': 'Immutable instance of the Notional V2 proxy contract for interacting with Notional V2.'}, {'Name': 'owner', 'Type': 'address', 'Purpose': 'Address of the contract owner, authorized to enable tokens.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with the Notional V2 proxy and sets the owner.', 'Parameters': ['NotionalProxy notionalV2_'], 'Returns': []}, {'Name': 'enableToken', 'Visibility': 'external', 'Purpose': 'Allows the owner to enable a token for use by approving a spender with maximum allowance.', 'Parameters': ['address token', 'address spender'], 'Returns': []}, {'Name': 'migrateBorrowFromCompound', 'Visibility': 'external', 'Purpose': 'Migrates a borrow position from Compound to Notional V2, handling repayment and collateral transfer.', 'Parameters': ['address cTokenBorrow', 'uint256 cTokenRepayAmount', 'uint16[] memory notionalV2CollateralIds', 'uint256[] memory notionalV2CollateralAmounts', 'BalanceActionWithTrades[] calldata borrowAction'], 'Returns': []}, {'Name': 'notionalCallback', 'Visibility': 'external', 'Purpose': 'Callback function invoked by Notional V2 to handle the transfer of repayment and collateral.', 'Parameters': ['address sender', 'address account', 'bytes calldata callbackData'], 'Returns': ['uint256']}, {'Name': 'receive', 'Visibility': 'external', 'Purpose': 'Prevents the contract from receiving ETH directly.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['CTokenInterface: Interface for interacting with Compound cTokens.', 'CErc20Interface: Interface for interacting with Compound ERC20 cTokens.', 'NotionalProxy: Proxy contract for interacting with Notional V2.', 'IERC20: Interface for interacting with ERC20 tokens.'], 'SpecialMechanisms': ['Ownership Pattern: Uses an owner address to restrict certain functions to authorized users.', 'Callback Mechanism: Utilizes a callback function to handle post-transaction logic in Notional V2.', 'Immutable State: Uses immutable state variables for the Notional V2 proxy to ensure it cannot be changed after deployment.'], 'Questions': ['What is the structure of the `BalanceActionWithTrades` type used in `migrateBorrowFromCompound`?', 'How is the `Token` type defined in the `notionalCallback` function?', 'Are there any specific security considerations for the `transferFrom` calls in the `notionalCallback` function?', 'What are the potential risks associated with setting `type(uint256).max` as the allowance in `enableToken`?']}","{'Findings': [{'Issue': 'Unauthorized Callback Execution', 'Severity': 'High', 'Description': 'The `notionalCallback` function does not verify that the caller is the NotionalV2 contract, allowing any external contract or user to trigger the callback function. This could lead to unauthorized operations such as token transfers or repayments on behalf of the user.', 'Impact': 'Unauthorized token transfers or repayments could result in financial loss or manipulation of the contract state.', 'Location': 'notionalCallback function'}, {'Issue': 'Reentrancy Risk', 'Severity': 'High', 'Description': 'The `notionalCallback` function interacts with external contracts (e.g., `transferFrom`, `repayBorrowBehalf`, `depositAssetToken`) without implementing reentrancy guards. This could allow an attacker to re-enter the function and manipulate the contract state or drain funds.', 'Impact': 'Reentrancy attacks could lead to unexpected state changes, double-spending, or unauthorized transfers.', 'Location': 'notionalCallback function'}, {'Issue': 'Unrestricted Approval in `enableToken`', 'Severity': 'High', 'Description': 'The `enableToken` function grants unlimited approval to a specified spender for a given token. This could be risky if the spender is compromised or malicious, as it would allow them to transfer all tokens from the contract.', 'Impact': 'Potential loss of all tokens approved to a malicious or compromised spender.', 'Location': 'enableToken function'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'The `migrateBorrowFromCompound` function does not validate the lengths of `notionalV2CollateralIds` and `notionalV2CollateralAmounts` arrays. If these arrays are of different lengths, it could lead to unexpected behavior or runtime errors.', 'Impact': 'Mismatched array lengths could result in incorrect collateral handling or runtime errors.', 'Location': 'migrateBorrowFromCompound function'}, {'Issue': 'Unbounded Loop', 'Severity': 'Medium', 'Description': 'The `notionalCallback` function contains a loop that iterates over `notionalV2CollateralIds` and `notionalV2CollateralAmounts`. If these arrays are too large, the function could run out of gas, potentially leading to a denial of service.', 'Impact': ""High gas costs or transaction failures, potentially disrupting the contract's functionality."", 'Location': 'notionalCallback function'}, {'Issue': 'Missing Event Emissions', 'Severity': 'Low', 'Description': ""The contract does not emit events for critical state changes such as token approvals, borrow migrations, or deposits. This makes it difficult to track and audit the contract's activities."", 'Impact': 'Lack of transparency and auditability, making it harder to monitor and respond to issues.', 'Location': 'enableToken and migrateBorrowFromCompound functions'}, {'Issue': 'ETH Transfer Rejection', 'Severity': 'Low', 'Description': 'The `receive` function reverts any ETH transfers. While this prevents accidental ETH transfers, it also means that the contract cannot receive ETH, which might be a limitation in certain use cases.', 'Impact': ""Inability to receive ETH, which could be a limitation depending on the contract's intended functionality."", 'Location': 'receive function'}], 'IssueNumber': 10, 'OutputList': 7}",484.4328780174256,"### **[H-03] CompoundToNotionalV2.notionalCallback ERC20 return values not checked**

**Report Description**:
The `notionalCallback` function in `CompoundToNotionalV2` does not check the return value of the `transferFrom` call for ERC20 tokens. Some tokens, like USDT, do not correctly implement the EIP20 standard and return `void` instead of a success boolean. This causes the transaction to revert when interacting with such tokens, making them unusable in the protocol. The issue is particularly relevant as the protocol supports cTokens with USDT as the underlying asset. The recommended solution is to use OpenZeppelin’s `SafeERC20` library, which includes `safeTransfer` and `safeTransferFrom` functions that handle return value checks and non-standard-compliant tokens.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked ERC20 return values in the `notionalCallback` function. This is a critical oversight, as it directly impacts the protocol's ability to handle non-standard-compliant tokens like USDT.

---

### **[H-04] Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed**

**Report Description**:
The `notionalCallback` function in `CompoundToNotionalV2` is intended to be called only by the verified contract that triggers the callback. However, the access restrictions can be bypassed by providing `sender = this`, as the `sender` parameter is user-controlled. This allows an attacker to call the function and potentially manipulate the contract state or perform unauthorized operations.

**Match in Response List**:
Matches with the issue titled **""Unauthorized Callback Execution""**.

**Validation**:
**Correct**. The response accurately identifies the issue of unauthorized callback execution in the `notionalCallback` function. It correctly explains the risk of allowing external contracts or users to trigger the callback, which aligns with the reported vulnerability.

---

### **[M-04] CompoundToNotionalV2.enableToken ERC20 missing return value check**

**Report Description**:
The `enableToken` function in `CompoundToNotionalV2` performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do not revert on failed approvals and instead return `false`. This could lead to tokens being incorrectly counted as approved even if the approval failed, potentially causing issues in the protocol's token management.

**Match in Response List**:
Matches with the issue titled **""Unrestricted Approval in `enableToken`""**.

**Validation**:
**Partially Correct**. The response identifies the issue of unrestricted approval in the `enableToken` function but focuses on the risk of granting unlimited approval rather than the specific problem of missing return value checks. While related, the response does not fully address the reported vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[H-04] Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed**

**Partially Correct Matches**:
- **[M-04] CompoundToNotionalV2.enableToken ERC20 missing return value check**

**Missed Issues from Issue Report**:
- **[H-03] CompoundToNotionalV2.notionalCallback ERC20 return values not checked**

---

The response list effectively addresses some issues but misses critical vulnerabilities, particularly the unchecked ERC20 return values in the `notionalCallback` function. Additionally, the response to the `enableToken` issue could be improved by explicitly addressing the missing return value check.","```
1. Unauthorized Callback Execution
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unauthorized Callback Execution"".
   - In the ranked list of predictions, ""Unauthorized Callback Execution"" appears at rank 1.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
NotionalV1ToNotionalV2.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Types.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface WETH9 {
    function withdraw(uint256 wad) external;

    function transfer(address dst, uint256 wad) external returns (bool);
}

interface IEscrow {
    function getBalances(address account) external view returns (int256[] memory);
}

interface INotionalV1Erc1155 {
    /** Notional V1 Types */
    struct Deposit {
        // Currency Id to deposit
        uint16 currencyId;
        // Amount of tokens to deposit
        uint128 amount;
    }

    /**
     * Used to describe withdraws in ERC1155.batchOperationWithdraw
     */
    struct Withdraw {
        // Destination of the address to withdraw to
        address to;
        // Currency Id to withdraw
        uint16 currencyId;
        // Amount of tokens to withdraw
        uint128 amount;
    }

    enum TradeType {TakeCurrentCash, TakefCash, AddLiquidity, RemoveLiquidity}

    /**
     * Used to describe a trade in ERC1155.batchOperation
     */
    struct Trade {
        TradeType tradeType;
        uint8 cashGroup;
        uint32 maturity;
        uint128 amount;
        bytes slippageData;
    }

    function batchOperationWithdraw(
        address account,
        uint32 maxTime,
        Deposit[] memory deposits,
        Trade[] memory trades,
        Withdraw[] memory withdraws
    ) external payable;
}

contract NotionalV1ToNotionalV2 {
    IEscrow public immutable Escrow;
    NotionalProxy public immutable NotionalV2;
    INotionalV1Erc1155 public immutable NotionalV1Erc1155;
    WETH9 public immutable WETH;
    IERC20 public immutable WBTC;

    uint16 internal constant V1_ETH = 0;
    uint16 internal constant V1_DAI = 1;
    uint16 internal constant V1_USDC = 2;
    uint16 internal constant V1_WBTC = 3;

    uint16 public constant V2_ETH = 1;
    uint16 public immutable V2_DAI;
    uint16 public immutable V2_USDC;
    uint16 public immutable V2_WBTC;

    constructor(
        IEscrow escrow_,
        NotionalProxy notionalV2_,
        INotionalV1Erc1155 erc1155_,
        WETH9 weth_,
        IERC20 wbtc_,
        uint16 v2Dai_,
        uint16 v2USDC_,
        uint16 v2WBTC_
    ) {
        Escrow = escrow_;
        NotionalV2 = notionalV2_;
        NotionalV1Erc1155 = erc1155_;
        WETH = weth_;
        WBTC = wbtc_;
        V2_DAI = v2Dai_;
        V2_USDC = v2USDC_;
        V2_WBTC = v2WBTC_;
    }

    function enableWBTC() external {
        WBTC.approve(address(NotionalV2), type(uint256).max);
    }

    function migrateDaiEther(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        // borrow on notional via special flash loan facility
        //  - borrow repayment amount
        //  - withdraw to wallet
        // receive callback (tokens transferred to borrowing account)
        //   -> inside callback
        //   -> repay Notional V1
        //   -> deposit collateral to notional v2 (account needs to have set approvals)
        //   -> exit callback
        // inside original borrow, check FC
        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_ETH, V2_ETH);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateUSDCEther(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_ETH, V2_ETH);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateDaiWBTC(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_WBTC, V2_WBTC);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateUSDCWBTC(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_WBTC, V2_WBTC);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");
        (
            uint16 v1DebtCurrencyId,
            uint128 v1RepayAmount,
            uint16 v1CollateralId,
            uint16 v2CollateralId
        ) = abi.decode(callbackData, (uint16, uint128, uint16, uint16));

        int256[] memory balances = Escrow.getBalances(account);
        int256 collateralBalance =
            (v1CollateralId == V1_ETH ? balances[V1_ETH] : balances[V1_WBTC]);
        require(collateralBalance > 0);

        {
            INotionalV1Erc1155.Deposit[] memory deposits = new INotionalV1Erc1155.Deposit[](1);
            INotionalV1Erc1155.Trade[] memory trades = new INotionalV1Erc1155.Trade[](0);
            INotionalV1Erc1155.Withdraw[] memory withdraws = new INotionalV1Erc1155.Withdraw[](1);

            // This will deposit what was borrowed from the account's wallet
            deposits[0].currencyId = v1DebtCurrencyId;
            deposits[0].amount = v1RepayAmount;

            // This will withdraw to the current contract the collateral to repay the flash loan
            withdraws[0].currencyId = v1CollateralId;
            withdraws[0].to = address(this);
            withdraws[0].amount = uint128(collateralBalance);

            NotionalV1Erc1155.batchOperationWithdraw(
                account,
                uint32(block.timestamp),
                deposits,
                trades,
                withdraws
            );
        }

        // Overflow checked above, cannot be negative
        uint256 v2CollateralBalance = uint256(collateralBalance);
        if (v2CollateralId == V2_ETH) {
            // Notional V1 uses WETH, but V2 uses ETH
            WETH.withdraw(v2CollateralBalance);
            NotionalV2.depositUnderlyingToken{value: v2CollateralBalance}(
                account,
                v2CollateralId,
                v2CollateralBalance
            );
        } else {
            NotionalV2.depositUnderlyingToken(account, v2CollateralId, v2CollateralBalance);
        }

        // When this exits it will do a free collateral check
    }

    receive() external payable {}
}

",1658,205,"[H-05] Access restrictions on NotionalV1ToNotionalV2.notionalCallback can be bypassed

The NotionalV1ToNotionalV2.notionalCallback is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing sender = this as sender is a parameter of the function that can be chosen by the attacker.
 ",1,,"pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Types.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface WETH9 {
    function withdraw(uint256 wad) external;

    function transfer(address dst, uint256 wad) external returns (bool);
}

interface IEscrow {
    function getBalances(address account) external view returns (int256[] memory);
}

interface INotionalV1Erc1155 {
    
    struct Deposit {
        
        uint16 currencyId;
        
        uint128 amount;
    }

    
    struct Withdraw {
        
        address to;
        
        uint16 currencyId;
        
        uint128 amount;
    }

    enum TradeType {TakeCurrentCash, TakefCash, AddLiquidity, RemoveLiquidity}

    
    struct Trade {
        TradeType tradeType;
        uint8 cashGroup;
        uint32 maturity;
        uint128 amount;
        bytes slippageData;
    }

    function batchOperationWithdraw(
        address account,
        uint32 maxTime,
        Deposit[] memory deposits,
        Trade[] memory trades,
        Withdraw[] memory withdraws
    ) external payable;
}

contract NotionalV1ToNotionalV2 {
    IEscrow public immutable Escrow;
    NotionalProxy public immutable NotionalV2;
    INotionalV1Erc1155 public immutable NotionalV1Erc1155;
    WETH9 public immutable WETH;
    IERC20 public immutable WBTC;

    uint16 internal constant V1_ETH = 0;
    uint16 internal constant V1_DAI = 1;
    uint16 internal constant V1_USDC = 2;
    uint16 internal constant V1_WBTC = 3;

    uint16 public constant V2_ETH = 1;
    uint16 public immutable V2_DAI;
    uint16 public immutable V2_USDC;
    uint16 public immutable V2_WBTC;

    constructor(
        IEscrow escrow_,
        NotionalProxy notionalV2_,
        INotionalV1Erc1155 erc1155_,
        WETH9 weth_,
        IERC20 wbtc_,
        uint16 v2Dai_,
        uint16 v2USDC_,
        uint16 v2WBTC_
    ) {
        Escrow = escrow_;
        NotionalV2 = notionalV2_;
        NotionalV1Erc1155 = erc1155_;
        WETH = weth_;
        WBTC = wbtc_;
        V2_DAI = v2Dai_;
        V2_USDC = v2USDC_;
        V2_WBTC = v2WBTC_;
    }

    function enableWBTC() external {
        WBTC.approve(address(NotionalV2), type(uint256).max);
    }

    function migrateDaiEther(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        
        
        
        
        
        
        
        
        
        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_ETH, V2_ETH);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateUSDCEther(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_ETH, V2_ETH);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateDaiWBTC(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_WBTC, V2_WBTC);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function migrateUSDCWBTC(
        uint128 v1RepayAmount,
        BalanceActionWithTrades[] calldata borrowAction
    ) external {
        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_WBTC, V2_WBTC);
        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);
    }

    function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");
        (
            uint16 v1DebtCurrencyId,
            uint128 v1RepayAmount,
            uint16 v1CollateralId,
            uint16 v2CollateralId
        ) = abi.decode(callbackData, (uint16, uint128, uint16, uint16));

        int256[] memory balances = Escrow.getBalances(account);
        int256 collateralBalance =
            (v1CollateralId == V1_ETH ? balances[V1_ETH] : balances[V1_WBTC]);
        require(collateralBalance > 0);

        {
            INotionalV1Erc1155.Deposit[] memory deposits = new INotionalV1Erc1155.Deposit[](1);
            INotionalV1Erc1155.Trade[] memory trades = new INotionalV1Erc1155.Trade[](0);
            INotionalV1Erc1155.Withdraw[] memory withdraws = new INotionalV1Erc1155.Withdraw[](1);

            
            deposits[0].currencyId = v1DebtCurrencyId;
            deposits[0].amount = v1RepayAmount;

            
            withdraws[0].currencyId = v1CollateralId;
            withdraws[0].to = address(this);
            withdraws[0].amount = uint128(collateralBalance);

            NotionalV1Erc1155.batchOperationWithdraw(
                account,
                uint32(block.timestamp),
                deposits,
                trades,
                withdraws
            );
        }

        
        uint256 v2CollateralBalance = uint256(collateralBalance);
        if (v2CollateralId == V2_ETH) {
            
            WETH.withdraw(v2CollateralBalance);
            NotionalV2.depositUnderlyingToken{value: v2CollateralBalance}(
                account,
                v2CollateralId,
                v2CollateralBalance
            );
        } else {
            NotionalV2.depositUnderlyingToken(account, v2CollateralId, v2CollateralBalance);
        }

        
    }

    receive() external payable {}
}",1417,1,0,,"{'ReviewingTheCode': 'The contract appears to be a migration tool designed to facilitate the transfer of assets and liabilities from Notional V1 to Notional V2. It interacts with multiple external contracts, including Escrow, NotionalProxy, INotionalV1Erc1155, WETH9, and IERC20. The contract includes functions to enable WBTC, migrate various assets (DAI, USDC, ETH, WBTC) between versions, and handle callbacks from Notional V2.', 'IdentifyingKeyComponents': {'ContractName': 'NotionalV1ToNotionalV2', 'Purpose': 'Facilitate the migration of assets and liabilities from Notional V1 to Notional V2.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['../../global/Types.sol', 'interfaces/notional/NotionalProxy.sol', '@openzeppelin/contracts/token/ERC20/IERC20.sol']}, 'StateVariables': [{'Name': 'Escrow', 'Type': 'IEscrow', 'Purpose': 'Interface for interacting with the Escrow contract.'}, {'Name': 'NotionalV2', 'Type': 'NotionalProxy', 'Purpose': 'Interface for interacting with Notional V2.'}, {'Name': 'NotionalV1Erc1155', 'Type': 'INotionalV1Erc1155', 'Purpose': 'Interface for interacting with Notional V1 ERC1155 tokens.'}, {'Name': 'WETH', 'Type': 'WETH9', 'Purpose': 'Interface for interacting with WETH9 contract.'}, {'Name': 'WBTC', 'Type': 'IERC20', 'Purpose': 'Interface for interacting with WBTC token.'}, {'Name': 'V1_ETH', 'Type': 'uint16', 'Purpose': 'Currency ID for ETH in Notional V1.'}, {'Name': 'V1_DAI', 'Type': 'uint16', 'Purpose': 'Currency ID for DAI in Notional V1.'}, {'Name': 'V1_USDC', 'Type': 'uint16', 'Purpose': 'Currency ID for USDC in Notional V1.'}, {'Name': 'V1_WBTC', 'Type': 'uint16', 'Purpose': 'Currency ID for WBTC in Notional V1.'}, {'Name': 'V2_ETH', 'Type': 'uint16', 'Purpose': 'Currency ID for ETH in Notional V2.'}, {'Name': 'V2_DAI', 'Type': 'uint16', 'Purpose': 'Currency ID for DAI in Notional V2.'}, {'Name': 'V2_USDC', 'Type': 'uint16', 'Purpose': 'Currency ID for USDC in Notional V2.'}, {'Name': 'V2_WBTC', 'Type': 'uint16', 'Purpose': 'Currency ID for WBTC in Notional V2.'}], 'FunctionsAndModifiers': [{'Name': 'enableWBTC', 'Visibility': 'external', 'Purpose': 'Approve Notional V2 to spend WBTC on behalf of the contract.', 'Parameters': [], 'Returns': []}, {'Name': 'migrateDaiEther', 'Visibility': 'external', 'Purpose': 'Migrate DAI and Ether from Notional V1 to Notional V2.', 'Parameters': ['uint128 v1RepayAmount', 'BalanceActionWithTrades[] calldata borrowAction'], 'Returns': []}, {'Name': 'migrateUSDCEther', 'Visibility': 'external', 'Purpose': 'Migrate USDC and Ether from Notional V1 to Notional V2.', 'Parameters': ['uint128 v1RepayAmount', 'BalanceActionWithTrades[] calldata borrowAction'], 'Returns': []}, {'Name': 'migrateDaiWBTC', 'Visibility': 'external', 'Purpose': 'Migrate DAI and WBTC from Notional V1 to Notional V2.', 'Parameters': ['uint128 v1RepayAmount', 'BalanceActionWithTrades[] calldata borrowAction'], 'Returns': []}, {'Name': 'migrateUSDCWBTC', 'Visibility': 'external', 'Purpose': 'Migrate USDC and WBTC from Notional V1 to Notional V2.', 'Parameters': ['uint128 v1RepayAmount', 'BalanceActionWithTrades[] calldata borrowAction'], 'Returns': []}, {'Name': 'notionalCallback', 'Visibility': 'external', 'Purpose': 'Handle callback from Notional V2 during migration.', 'Parameters': ['address sender', 'address account', 'bytes calldata callbackData'], 'Returns': ['uint256']}, {'Name': 'receive', 'Visibility': 'external', 'Purpose': 'Receive Ether.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['Escrow', 'NotionalProxy (NotionalV2)', 'INotionalV1Erc1155', 'WETH9', 'IERC20 (WBTC)'], 'SpecialMechanisms': ['Batch operations for depositing, trading, and withdrawing assets.', 'Callback mechanism for handling responses from Notional V2.', 'Use of immutable state variables for contract dependencies.'], 'Questions': ['What is the exact purpose of the `BalanceActionWithTrades` struct and how is it used in the migration functions?', 'How is the `slippageData` parameter in the `Trade` struct utilized during trades?', 'Are there any specific security considerations or potential vulnerabilities in the callback handling mechanism?', 'What are the gas implications of the batch operations, especially when dealing with multiple assets and trades?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `notionalCallback`', 'Severity': 'High', 'Description': 'The `notionalCallback` function interacts with external contracts (e.g., `WETH.withdraw` and `NotionalV2.depositUnderlyingToken`) without following the checks-effects-interactions pattern, potentially allowing reentrancy attacks if the external contracts are malicious or compromised.', 'Impact': 'An attacker could exploit this vulnerability to re-enter the contract and manipulate its state, potentially leading to loss of funds or unauthorized actions.', 'Location': 'notionalCallback function, specifically around the WETH.withdraw and NotionalV2.depositUnderlyingToken calls.'}, {'Issue': 'Unrestricted Approval for WBTC', 'Severity': 'High', 'Description': 'The `enableWBTC` function grants unlimited approval to the `NotionalV2` contract for the `WBTC` token. This could lead to potential risks if the `NotionalV2` contract is compromised or behaves maliciously, as it could transfer all `WBTC` tokens from this contract.', 'Impact': 'Potential loss of all `WBTC` tokens held by the contract if the `NotionalV2` contract is exploited.', 'Location': 'enableWBTC function.'}, {'Issue': 'Unauthorized Callback Execution', 'Severity': 'High', 'Description': 'The `notionalCallback` function does not adequately verify the caller, allowing any contract to call it as long as the `sender` parameter matches `address(this)`. This could lead to unauthorized execution of the callback logic.', 'Impact': ""An attacker could exploit this to manipulate the contract's state or steal funds by crafting malicious callback data."", 'Location': 'notionalCallback function.'}, {'Issue': 'Lack of Input Validation in `migrate` Functions', 'Severity': 'Medium', 'Description': 'The `migrateDaiEther`, `migrateUSDCEther`, `migrateDaiWBTC`, and `migrateUSDCWBTC` functions do not validate the `v1RepayAmount` or `borrowAction` inputs. This could lead to unexpected behavior or exploitation if invalid or malicious inputs are provided.', 'Impact': 'Invalid inputs could cause the contract to behave unexpectedly, potentially leading to financial losses or other security issues.', 'Location': 'migrateDaiEther, migrateUSDCEther, migrateDaiWBTC, migrateUSDCWBTC functions.'}, {'Issue': 'Potential Front-Running in Migrate Functions', 'Severity': 'Medium', 'Description': 'The `migrateDaiEther`, `migrateUSDCEther`, `migrateDaiWBTC`, and `migrateUSDCWBTC` functions encode data and call `NotionalV2.batchBalanceAndTradeActionWithCallback` without protection against front-running. This could allow an attacker to manipulate the transaction order and exploit the migration process.', 'Impact': 'An attacker could front-run these transactions to gain an unfair advantage or cause financial losses to legitimate users.', 'Location': 'migrateDaiEther, migrateUSDCEther, migrateDaiWBTC, migrateUSDCWBTC functions.'}, {'Issue': 'Hardcoded Currency IDs', 'Severity': 'Low', 'Description': 'The contract uses hardcoded currency IDs (e.g., `V1_ETH`, `V1_DAI`, `V1_USDC`, `V1_WBTC`). This could lead to issues if the underlying system changes these IDs, requiring a contract upgrade or redeployment.', 'Impact': 'Potential for contract malfunction if the underlying system changes currency IDs.', 'Location': 'Global variables and constructor.'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical state changes, such as token approvals, migrations, or callback executions. Events are important for off-chain monitoring and auditing, and their absence makes it harder to track and verify contract activity.', 'Impact': 'Lack of event emission reduces transparency and makes it difficult to monitor and audit contract activity, potentially hiding malicious or erroneous behavior.', 'Location': 'Various functions performing state changes.'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Low', 'Description': 'The contract uses `uint128` and `uint256` types extensively without explicit checks for overflow/underflow. Although Solidity 0.8.x and above have built-in overflow checks, the pragma specifies `>0.7.0`, which could lead to vulnerabilities if the contract is compiled with a version that does not include these checks.', 'Impact': 'If the contract is compiled with a version of Solidity that does not include built-in overflow checks, it could be vulnerable to integer overflow/underflow attacks.', 'Location': 'Throughout the contract, particularly in functions handling arithmetic operations.'}], 'IssueNumber': 10, 'OutputList': 8}",620.2442870140076,"---

**[H-05] Access restrictions on NotionalV1ToNotionalV2.notionalCallback can be bypassed**

**Report Description**:
The `NotionalV1ToNotionalV2.notionalCallback` function is intended to be called only from a verified contract. However, the access restrictions can be bypassed by an attacker who sets the `sender` parameter to `address(this)`. This allows unauthorized execution of the callback logic, potentially leading to manipulation of the contract's state or theft of funds.

**Match in Response List**:
Matches with the issue titled **""Unauthorized Callback Execution""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `notionalCallback` function, specifically the lack of proper caller verification. It correctly explains the risk of unauthorized execution of the callback logic, which aligns with the reported issue. The response also highlights the potential impact of this vulnerability, which is consistent with the report's concerns.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-05] Access restrictions on NotionalV1ToNotionalV2.notionalCallback can be bypassed**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

---","```
1. Unauthorized Callback Execution
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unauthorized Callback Execution"".
   - In the ranked list of predictions, ""Unauthorized Callback Execution"" appears at rank 3.

2. **Calculate the precision at rank 3 (\( P@3 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 3, there is 1 true positive.
   - \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.333 \).

**Output**:
```
0.333
```"
TokenHandler.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../math/SafeInt256.sol"";
import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import ""interfaces/compound/CEtherInterface.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

/// @notice Handles all external token transfers and events
library TokenHandler {
    using SafeInt256 for int256;
    using SafeMath for uint256;

    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    currencyId,
                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))
                )
            );
    }

    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns
    /// the underlying token. (These may not always exist)
    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {
        bytes32 slot = _getSlot(currencyId, underlying);
        bytes32 data;

        assembly {
            data := sload(slot)
        }
        address tokenAddress = address(bytes20(data << 96));
        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;
        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));
        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));

        return
            Token({
                tokenAddress: tokenAddress,
                hasTransferFee: tokenHasTransferFee,
                decimals: int256(10**tokenDecimalPlaces),
                tokenType: tokenType
            });
    }

    /// @notice Sets a token for a currency id.
    function setToken(
        uint256 currencyId,
        bool underlying,
        TokenStorage memory tokenStorage
    ) internal {
        bytes32 slot = _getSlot(currencyId, underlying);

        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {
            // Specific storage for Ether token type
            bytes32 etherData =
                ((bytes32(bytes20(address(0))) >> 96) |
                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |
                    bytes32(uint256(18) << 168) |
                    bytes32(uint256(TokenType.Ether) << 176));

            assembly {
                sstore(slot, etherData)
            }

            return;
        }
        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once
        require(tokenStorage.tokenAddress != address(0), ""TH: address is zero"");

        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();
        require(decimalPlaces != 0, ""TH: decimals is zero"");

        // Once a token is set we cannot override it. In the case that we do need to do change a token address
        // then we should explicitly upgrade this method to allow for a token to be changed.
        Token memory token = getToken(currencyId, underlying);
        require(
            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),
            ""TH: token cannot be reset""
        );

        if (tokenStorage.tokenType == TokenType.cToken) {
            // Set the approval for the underlying so that we can mint cTokens
            Token memory underlyingToken = getToken(currencyId, true);
            ERC20(underlyingToken.tokenAddress).approve(
                tokenStorage.tokenAddress,
                type(uint256).max
            );
        }

        bytes1 transferFee =
            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;

        bytes32 data =
            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |
                (bytes32(bytes1(transferFee)) >> 88) |
                bytes32(uint256(decimalPlaces) << 168) |
                bytes32(uint256(tokenStorage.tokenType) << 176));

        assembly {
            sstore(slot, data)
        }
    }

    /// @notice This method only works with cTokens, it's unclear how we can make this more generic
    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {
        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

        uint256 success;
        if (token.tokenType == TokenType.cToken) {
            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);
        } else if (token.tokenType == TokenType.cETH) {
            // Reverts on error
            CEtherInterface(token.tokenAddress).mint{value: msg.value}();
        } else {
            revert(); // dev: non mintable token
        }

        require(success == 0, ""Mint fail"");
        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

        // This is the starting and ending balance in external precision
        return int256(endingBalance.sub(startingBalance));
    }

    function redeem(
        Token memory assetToken,
        Token memory underlyingToken,
        uint256 assetAmountExternal
    ) internal returns (int256) {
        uint256 startingBalance;
        if (assetToken.tokenType == TokenType.cETH) {
            startingBalance = address(this).balance;
        } else if (assetToken.tokenType == TokenType.cToken) {
            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));
        } else {
            revert(); // dev: non redeemable failure
        }

        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);
        require(success == 0, ""Redeem fail"");

        uint256 endingBalance;
        if (assetToken.tokenType == TokenType.cETH) {
            endingBalance = address(this).balance;
        } else {
            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));
        }

        // Underlying token external precision
        return int256(endingBalance.sub(startingBalance));
    }

    /// @notice Handles transfers into and out of the system denominated in the external token decimal
    /// precision.
    function transfer(
        Token memory token,
        address account,
        int256 netTransferExternal
    ) internal returns (int256) {
        if (netTransferExternal > 0) {
            // Deposits must account for transfer fees.
            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));
        } else if (token.tokenType == TokenType.Ether) {
            require(netTransferExternal < 0); // dev: cannot transfer ether
            address payable accountPayable = payable(account);
            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying
            // ETH they will have to withdraw the cETH token and then redeem it manually.
            accountPayable.transfer(uint256(netTransferExternal.neg()));
        } else {
            safeTransferOut(
                IERC20(token.tokenAddress),
                account,
                uint256(netTransferExternal.neg())
            );
        }

        return netTransferExternal;
    }

    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must
    /// calculate the net balance after transfer. Amounts are denominated in the destination token's
    /// precision.
    function _deposit(
        Token memory token,
        address account,
        uint256 amount
    ) private returns (int256) {
        if (token.hasTransferFee) {
            // Must deposit from the token and calculate the net transfer
            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));
            safeTransferIn(IERC20(token.tokenAddress), account, amount);
            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

            return int256(endingBalance.sub(startingBalance));
        }

        safeTransferIn(IERC20(token.tokenAddress), account, amount);
        return int256(amount);
    }

    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {
        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;
        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);
    }

    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {
        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;
        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);
    }

    function transferIncentive(address account, uint256 tokensToTransfer) internal {
        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);
    }

    function safeTransferOut(
        IERC20 token,
        address account,
        uint256 amount
    ) private {
        token.transfer(account, amount);
        checkReturnCode();
    }

    function safeTransferIn(
        IERC20 token,
        address account,
        uint256 amount
    ) private {
        token.transferFrom(account, address(this), amount);
        checkReturnCode();
    }

    function checkReturnCode() private pure {
        bool success;
        assembly {
            switch returndatasize()
                case 0 {
                    // This is a non-standard ERC-20
                    success := not(0) // set success to true
                }
                case 32 {
                    // This is a compliant ERC-20
                    returndatacopy(0, 0, 32)
                    success := mload(0) // Set `success = returndata` of external call
                }
                default {
                    // This is an excessively non-compliant ERC-20, revert.
                    revert(0, 0)
                }
        }

        require(success, ""Transfer Failed"");
    }
}

",2090,262,"[H-06] TokenHandler.safeTransferOut does not work on non-standard compliant tokens like USDT

The `TokenHandler.safeTransferOut` function uses the standard IERC20 function for the transfer call and proceeds with a checkReturnCode function to handle non-standard compliant tokens that don't return a return value. However, this does not work, as calling token.transfer(account, amount) already reverts if the token does not return a return value, as token's IERC20.transfer is defined to always return a boolean.
The impact is that, when using any non-standard compliant token like USDT, the function will revert. Deposits for these tokens are broken, which is bad as USDT is a valid underlying for the cUSDT cToken.
  [H-07] TokenHandler.safeTransferIn does not work on non-standard compliant tokens like USDT

The `TokenHandler.safeTransferIn` function uses the standard IERC20 function for the transfer call and proceeds with a checkReturnCode function to handle non-standard compliant tokens that don't return a return value. However, this does not work, as calling token.transferFrom(account, amount) already reverts if the token does not return a return value, as token's IERC20.transferFrom is defined to always return a boolean.
When using any non-standard compliant token like USDT, the function will revert. Withdrawals for these tokens are broken, which is bad as USDT is a valid underlying for the cUSDT cToken.
 [M-01] TokenHandler.sol, L174 - .transfer is bad practice

Submitted by JMukesh, also found by tensors
The use of .transfer in TokenHandler.sol L174 to send ether is now considered bad practice as gas costs can change which would break the code.
See stop using soliditys transfer now, and istanbul hardfork eips increasing gas costs and more.
Recommend using call instead, and make sure to check for reentrancy.
  [M-06] TokenHandler.setToken ERC20 missing return value check

The setToken function performs an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.
The impact is that tokens that don't actually perform the approve and return false are still counted as a correct approve.
",4,,"pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../math/SafeInt256.sol"";
import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import ""interfaces/compound/CEtherInterface.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";


library TokenHandler {
    using SafeInt256 for int256;
    using SafeMath for uint256;

    function _getSlot(uint256 currencyId, bool underlying) private pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    currencyId,
                    keccak256(abi.encode(underlying, Constants.TOKEN_STORAGE_OFFSET))
                )
            );
    }

    
    
    function getToken(uint256 currencyId, bool underlying) internal view returns (Token memory) {
        bytes32 slot = _getSlot(currencyId, underlying);
        bytes32 data;

        assembly {
            data := sload(slot)
        }
        address tokenAddress = address(bytes20(data << 96));
        bool tokenHasTransferFee = bytes1(data << 88) != Constants.BOOL_FALSE;
        uint8 tokenDecimalPlaces = uint8(bytes1(data << 80));
        TokenType tokenType = TokenType(uint8(bytes1(data << 72)));

        return
            Token({
                tokenAddress: tokenAddress,
                hasTransferFee: tokenHasTransferFee,
                decimals: int256(10**tokenDecimalPlaces),
                tokenType: tokenType
            });
    }

    
    function setToken(
        uint256 currencyId,
        bool underlying,
        TokenStorage memory tokenStorage
    ) internal {
        bytes32 slot = _getSlot(currencyId, underlying);

        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {
            
            bytes32 etherData =
                ((bytes32(bytes20(address(0))) >> 96) |
                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |
                    bytes32(uint256(18) << 168) |
                    bytes32(uint256(TokenType.Ether) << 176));

            assembly {
                sstore(slot, etherData)
            }

            return;
        }
        require(tokenStorage.tokenType != TokenType.Ether); 
        require(tokenStorage.tokenAddress != address(0), ""TH: address is zero"");

        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();
        require(decimalPlaces != 0, ""TH: decimals is zero"");

        
        
        Token memory token = getToken(currencyId, underlying);
        require(
            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),
            ""TH: token cannot be reset""
        );

        if (tokenStorage.tokenType == TokenType.cToken) {
            
            Token memory underlyingToken = getToken(currencyId, true);
            ERC20(underlyingToken.tokenAddress).approve(
                tokenStorage.tokenAddress,
                type(uint256).max
            );
        }

        bytes1 transferFee =
            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;

        bytes32 data =
            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |
                (bytes32(bytes1(transferFee)) >> 88) |
                bytes32(uint256(decimalPlaces) << 168) |
                bytes32(uint256(tokenStorage.tokenType) << 176));

        assembly {
            sstore(slot, data)
        }
    }

    
    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {
        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

        uint256 success;
        if (token.tokenType == TokenType.cToken) {
            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);
        } else if (token.tokenType == TokenType.cETH) {
            
            CEtherInterface(token.tokenAddress).mint{value: msg.value}();
        } else {
            revert(); 
        }

        require(success == 0, ""Mint fail"");
        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

        
        return int256(endingBalance.sub(startingBalance));
    }

    function redeem(
        Token memory assetToken,
        Token memory underlyingToken,
        uint256 assetAmountExternal
    ) internal returns (int256) {
        uint256 startingBalance;
        if (assetToken.tokenType == TokenType.cETH) {
            startingBalance = address(this).balance;
        } else if (assetToken.tokenType == TokenType.cToken) {
            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));
        } else {
            revert(); 
        }

        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);
        require(success == 0, ""Redeem fail"");

        uint256 endingBalance;
        if (assetToken.tokenType == TokenType.cETH) {
            endingBalance = address(this).balance;
        } else {
            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));
        }

        
        return int256(endingBalance.sub(startingBalance));
    }

    
    
    function transfer(
        Token memory token,
        address account,
        int256 netTransferExternal
    ) internal returns (int256) {
        if (netTransferExternal > 0) {
            
            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));
        } else if (token.tokenType == TokenType.Ether) {
            require(netTransferExternal < 0); 
            address payable accountPayable = payable(account);
            
            
            accountPayable.transfer(uint256(netTransferExternal.neg()));
        } else {
            safeTransferOut(
                IERC20(token.tokenAddress),
                account,
                uint256(netTransferExternal.neg())
            );
        }

        return netTransferExternal;
    }

    
    
    
    function _deposit(
        Token memory token,
        address account,
        uint256 amount
    ) private returns (int256) {
        if (token.hasTransferFee) {
            
            uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));
            safeTransferIn(IERC20(token.tokenAddress), account, amount);
            uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));

            return int256(endingBalance.sub(startingBalance));
        }

        safeTransferIn(IERC20(token.tokenAddress), account, amount);
        return int256(amount);
    }

    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {
        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;
        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);
    }

    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {
        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;
        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);
    }

    function transferIncentive(address account, uint256 tokensToTransfer) internal {
        safeTransferOut(IERC20(Constants.NOTE_TOKEN_ADDRESS), account, tokensToTransfer);
    }

    function safeTransferOut(
        IERC20 token,
        address account,
        uint256 amount
    ) private {
        token.transfer(account, amount);
        checkReturnCode();
    }

    function safeTransferIn(
        IERC20 token,
        address account,
        uint256 amount
    ) private {
        token.transferFrom(account, address(this), amount);
        checkReturnCode();
    }

    function checkReturnCode() private pure {
        bool success;
        assembly {
            switch returndatasize()
                case 0 {
                    
                    success := not(0) 
                }
                case 32 {
                    
                    returndatacopy(0, 0, 32)
                    success := mload(0) 
                }
                default {
                    
                    revert(0, 0)
                }
        }

        require(success, ""Transfer Failed"");
    }
}",1702,2,2,,"{'ReviewingTheCode': ""The provided code snippet is a Solidity library named 'TokenHandler' that manages token operations, including token storage, minting, redeeming, and transferring. It interacts with ERC20 tokens and Compound's cTokens. The library uses assembly for low-level storage operations and handles both Ether and ERC20 tokens. It also includes mechanisms for handling token decimals, transfer fees, and conversions between internal and external token representations."", 'IdentifyingKeyComponents': {'ContractName': 'TokenHandler', 'Purpose': ""To manage token operations, including storage, minting, redeeming, and transferring, for both ERC20 tokens and Compound's cTokens."", 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['SafeInt256', 'Types', 'Constants', 'CErc20Interface', 'CEtherInterface', 'SafeMath', 'ERC20']}, 'StateVariables': [], 'FunctionsAndModifiers': [{'Name': '_getSlot', 'Visibility': 'private', 'Purpose': 'Generates a storage slot key based on the currency ID and whether the token is underlying.', 'Parameters': ['uint256 currencyId', 'bool underlying'], 'Returns': ['bytes32']}, {'Name': 'getToken', 'Visibility': 'internal', 'Purpose': 'Retrieves token information from storage based on the currency ID and whether the token is underlying.', 'Parameters': ['uint256 currencyId', 'bool underlying'], 'Returns': ['Token memory']}, {'Name': 'setToken', 'Visibility': 'internal', 'Purpose': 'Stores token information in storage based on the currency ID and whether the token is underlying.', 'Parameters': ['uint256 currencyId', 'bool underlying', 'TokenStorage memory tokenStorage'], 'Returns': []}, {'Name': 'mint', 'Visibility': 'internal', 'Purpose': 'Mints tokens (either cToken or cETH) and returns the net amount minted.', 'Parameters': ['Token memory token', 'uint256 underlyingAmountExternal'], 'Returns': ['int256']}, {'Name': 'redeem', 'Visibility': 'internal', 'Purpose': 'Redeems tokens (either cToken or cETH) and returns the net amount redeemed.', 'Parameters': ['Token memory assetToken', 'Token memory underlyingToken', 'uint256 assetAmountExternal'], 'Returns': ['int256']}, {'Name': 'transfer', 'Visibility': 'internal', 'Purpose': 'Transfers tokens (either Ether or ERC20) to or from an account.', 'Parameters': ['Token memory token', 'address account', 'int256 netTransferExternal'], 'Returns': ['int256']}, {'Name': '_deposit', 'Visibility': 'private', 'Purpose': 'Handles token deposits, accounting for transfer fees if applicable.', 'Parameters': ['Token memory token', 'address account', 'uint256 amount'], 'Returns': ['int256']}, {'Name': 'convertToInternal', 'Visibility': 'internal', 'Purpose': 'Converts an external token amount to an internal representation.', 'Parameters': ['Token memory token', 'int256 amount'], 'Returns': ['int256']}, {'Name': 'convertToExternal', 'Visibility': 'internal', 'Purpose': 'Converts an internal token amount to an external representation.', 'Parameters': ['Token memory token', 'int256 amount'], 'Returns': ['int256']}, {'Name': 'transferIncentive', 'Visibility': 'internal', 'Purpose': 'Transfers an incentive token (NOTE) to an account.', 'Parameters': ['address account', 'uint256 tokensToTransfer'], 'Returns': []}, {'Name': 'safeTransferOut', 'Visibility': 'private', 'Purpose': 'Safely transfers tokens out of the contract, checking for success.', 'Parameters': ['IERC20 token', 'address account', 'uint256 amount'], 'Returns': []}, {'Name': 'safeTransferIn', 'Visibility': 'private', 'Purpose': 'Safely transfers tokens into the contract, checking for success.', 'Parameters': ['IERC20 token', 'address account', 'uint256 amount'], 'Returns': []}, {'Name': 'checkReturnCode', 'Visibility': 'private', 'Purpose': 'Checks the return code of a token transfer to ensure it was successful.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': [""Compound's cToken and cETH interfaces (CErc20Interface, CEtherInterface)"", 'ERC20 tokens', 'NOTE token (incentive token)'], 'SpecialMechanisms': ['Low-level assembly for storage operations', 'Handling of both Ether and ERC20 tokens', 'Conversion between internal and external token representations', 'Approval mechanism for cToken operations'], 'Questions': [""What is the purpose of the 'Constants.TOKEN_STORAGE_OFFSET' and how is it determined?"", ""How are transfer fees handled in the '_deposit' function?"", ""Is there a specific reason for using assembly in the 'checkReturnCode' function?"", ""What is the role of the 'NOTE_TOKEN_ADDRESS' and how is it used in the 'transferIncentive' function?""]}","{'Findings': [{'Issue': 'Unchecked Return Value for ERC20 Transfers', 'Severity': 'High', 'Description': 'Multiple functions (`safeTransferOut`, `safeTransferIn`, `mint`, `redeem`) do not properly check the return value of ERC20 transfer and transferFrom calls. Some tokens may not revert on failure but return false, leading to silent failures.', 'Impact': 'Potential loss of funds or incorrect state updates if transfers fail silently.', 'Location': 'TokenHandler.sol - `safeTransferOut`, `safeTransferIn`, `mint`, `redeem` functions'}, {'Issue': 'Reentrancy Risk in Ether Transfer', 'Severity': 'High', 'Description': 'The `transfer` function directly transfers Ether using `accountPayable.transfer` without following the checks-effects-interactions pattern, potentially allowing reentrancy attacks.', 'Impact': 'Potential loss of funds or state manipulation via reentrancy attacks.', 'Location': 'TokenHandler.sol - `transfer` function'}, {'Issue': 'Unsafe Assembly Usage', 'Severity': 'High', 'Description': 'Inline assembly is used for low-level operations like `sload` and `sstore` without proper safety checks, which can lead to data corruption or vulnerabilities.', 'Impact': 'Potential for unexpected behavior, data corruption, or security breaches.', 'Location': 'Functions `_getSlot`, `getToken`, `setToken`, `checkReturnCode`'}, {'Issue': 'Lack of Access Control', 'Severity': 'High', 'Description': 'Critical functions like `setToken`, `mint`, and `redeem` lack access control, allowing unauthorized users to manipulate token storage or funds.', 'Impact': 'Unauthorized modifications to token storage or fund manipulation, leading to financial losses.', 'Location': 'TokenHandler.sol - `setToken`, `mint`, `redeem` functions'}, {'Issue': 'Insufficient Input Validation', 'Severity': 'Medium', 'Description': 'The `setToken` function does not validate `tokenStorage.tokenAddress` for being a valid ERC20 token or check `tokenType` thoroughly, potentially allowing invalid configurations.', 'Impact': 'Potential misconfiguration of token storage or interaction with malicious contracts.', 'Location': 'TokenHandler.sol - `setToken` function'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': 'Arithmetic operations in `convertToInternal`, `convertToExternal`, `mint`, and `redeem` lack overflow/underflow checks, despite using `SafeMath` in some places.', 'Impact': 'Incorrect calculations leading to financial discrepancies or state errors.', 'Location': 'TokenHandler.sol - `convertToInternal`, `convertToExternal`, `mint`, `redeem` functions'}, {'Issue': 'Incorrect Handling of Ether in `mint` Function', 'Severity': 'Medium', 'Description': 'The `mint` function does not validate `msg.value` or `tokenType` for `TokenType.cETH`, leading to potential inconsistencies or loss of funds.', 'Impact': 'Incorrect Ether handling, potentially causing loss of funds or state errors.', 'Location': 'TokenHandler.sol - `mint` function'}, {'Issue': 'Unbounded Loops in Token Decimal Conversion', 'Severity': 'Low', 'Description': 'The `convertToInternal` and `convertToExternal` functions perform arithmetic operations that could lead to high gas consumption if token decimals are very large.', 'Impact': 'Potential inefficiency or high gas costs in token conversions.', 'Location': 'TokenHandler.sol - `convertToInternal`, `convertToExternal` functions'}, {'Issue': 'Lack of Event Logging', 'Severity': 'Low', 'Description': 'Critical state changes (e.g., token transfers, minting, redeeming) are not logged with events, reducing transparency and auditability.', 'Impact': 'Difficulty in tracking contract activity off-chain.', 'Location': 'TokenHandler.sol - Various functions'}, {'Issue': 'Use of Deprecated `pragma experimental ABIEncoderV2`', 'Severity': 'Low', 'Description': 'The contract uses a deprecated pragma, which may cause compatibility issues with future Solidity versions.', 'Impact': 'Potential compatibility issues with future Solidity versions.', 'Location': 'TokenHandler.sol - Pragma directive'}], 'IssueNumber': 10, 'OutputList': 10}",625.6473181247711,"### **[H-06] TokenHandler.safeTransferOut does not work on non-standard compliant tokens like USDT**

**Report Description**:  
The `TokenHandler.safeTransferOut` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work, as calling `token.transfer(account, amount)` already reverts if the token does not return a return value, as `token's IERC20.transfer` is defined to always return a boolean. The impact is that, when using any non-standard compliant token like USDT, the function will revert. Deposits for these tokens are broken, which is bad as USDT is a valid underlying for the `cUSDT` cToken.

**Match in Response List**:  
Matches with the issue titled **""Unchecked Return Value for ERC20 Transfers""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unchecked return values for ERC20 transfers, which is related to the problem described in the issue. However, the response does not specifically address the problem of non-standard compliant tokens like USDT, which revert instead of returning `false`. The response also does not mention the impact on deposits for such tokens. While the core issue of unchecked return values is covered, the specific nuances of non-standard compliant tokens are missed.

---

### **[H-07] TokenHandler.safeTransferIn does not work on non-standard compliant tokens like USDT**

**Report Description**:  
The `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value. However, this does not work, as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value, as `token's IERC20.transferFrom` is defined to always return a boolean. When using any non-standard compliant token like USDT, the function will revert. Withdrawals for these tokens are broken, which is bad as USDT is a valid underlying for the `cUSDT` cToken.

**Match in Response List**:  
Matches with the issue titled **""Unchecked Return Value for ERC20 Transfers""**.

**Validation**:  
**Partially Correct**. Similar to [H-06], the response identifies the issue of unchecked return values for ERC20 transfers, which is related to the problem described in the issue. However, the response does not specifically address the problem of non-standard compliant tokens like USDT, which revert instead of returning `false`. The response also does not mention the impact on withdrawals for such tokens. While the core issue of unchecked return values is covered, the specific nuances of non-standard compliant tokens are missed.

---

### **[M-01] TokenHandler.sol, L174 - .transfer is bad practice**

**Report Description**:  
The use of `.transfer` in `TokenHandler.sol` L174 to send ether is now considered bad practice as gas costs can change which would break the code. See [stop using solidity's transfer now](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/) and [Istanbul hardfork EIPs increasing gas costs](https://eips.ethereum.org/EIPS/eip-1884) and more. Recommend using `call` instead, and make sure to check for reentrancy.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Risk in Ether Transfer""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with using `.transfer` for Ether transfers, highlighting the reentrancy risk and the potential for gas cost changes to break the code. The recommendation to use `call` instead aligns with Solidity best practices, and the response correctly emphasizes the need to check for reentrancy.

---

### **[M-06] TokenHandler.setToken ERC20 missing return value check**

**Report Description**:  
The `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value. Some tokens do not revert if the approval failed but return `false` instead. The impact is that tokens that don't actually perform the approve and return `false` are still counted as a correct approve.

**Match in Response List**:  
Matches with the issue titled **""Unchecked Return Value for ERC20 Transfers""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of unchecked return values for ERC20 transfers, which includes the problem described in the issue. The response correctly explains the risks associated with not validating return values from external `approve` calls, which aligns with Solidity best practices for secure contract interactions.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] TokenHandler.sol, L174 - .transfer is bad practice**
- **[M-06] TokenHandler.setToken ERC20 missing return value check**

**Partially Correct Matches**:

- **[H-06] TokenHandler.safeTransferOut does not work on non-standard compliant tokens like USDT**
- **[H-07] TokenHandler.safeTransferIn does not work on non-standard compliant tokens like USDT**

**Missed Issues from Issue Report**:

- *None*

---

### **Overall Assessment**

The `response_list` covers most of the issues in the `issue` report, but there are some gaps in addressing the specific nuances of non-standard compliant tokens like USDT in [H-06] and [H-07]. While the core issues are identified, the responses could be improved by explicitly mentioning the behavior of non-standard compliant tokens and their impact on deposits and withdrawals. The responses for [M-01] and [M-06] are accurate and align with Solidity best practices.","```
1. Reentrancy Risk in Ether Transfer
2. Unchecked Return Value for ERC20 Transfers
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Reentrancy Risk in Ether Transfer** appears at rank 2.
   - **Unchecked Return Value for ERC20 Transfers** appears at rank 1.

2. **Calculate the precision at each rank**:
   - For **Unchecked Return Value for ERC20 Transfers** at rank 1:
     \[
     P@1 = \frac{1}{1} = 1.0
     \]
   - For **Reentrancy Risk in Ether Transfer** at rank 2:
     \[
     P@2 = \frac{2}{2} = 1.0
     \]

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 1.0}{2} = 1.0
   \]

**Output**:
```
1.0
```"
Router.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./actions/nTokenAction.sol"";
import ""./actions/nTokenMintAction.sol"";
import ""./actions/nTokenRedeemAction.sol"";
import ""../global/StorageLayoutV1.sol"";
import ""../global/Types.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""interfaces/notional/nERC1155Interface.sol"";
import ""interfaces/notional/NotionalGovernance.sol"";

/**
 * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage
 * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing
 * contracts.
 *
 * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also
 * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a
 * new Router with the new hardcoded addresses will then be deployed and upgraded into place.
 */
contract Router is StorageLayoutV1 {
    // These contract addresses cannot be changed once set by the constructor
    address public immutable GOVERNANCE;
    address public immutable VIEWS;
    address public immutable INITIALIZE_MARKET;
    address public immutable NTOKEN_ACTIONS;
    address public immutable NTOKEN_REDEEM;
    address public immutable BATCH_ACTION;
    address public immutable ACCOUNT_ACTION;
    address public immutable ERC1155;
    address public immutable LIQUIDATE_CURRENCY;
    address public immutable LIQUIDATE_FCASH;
    address public immutable cETH;

    constructor(
        address governance_,
        address views_,
        address initializeMarket_,
        address nTokenActions_,
        address nTokenRedeem_,
        address batchAction_,
        address accountAction_,
        address erc1155_,
        address liquidateCurrency_,
        address liquidatefCash_,
        address cETH_
    ) {
        GOVERNANCE = governance_;
        VIEWS = views_;
        INITIALIZE_MARKET = initializeMarket_;
        NTOKEN_ACTIONS = nTokenActions_;
        NTOKEN_REDEEM = nTokenRedeem_;
        BATCH_ACTION = batchAction_;
        ACCOUNT_ACTION = accountAction_;
        ERC1155 = erc1155_;
        LIQUIDATE_CURRENCY = liquidateCurrency_;
        LIQUIDATE_FCASH = liquidatefCash_;
        cETH = cETH_;
    }

    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {
        // Cannot re-initialize once the contract has been initialized, ownership transfer does not
        // allow address to be set back to zero
        require(owner == address(0), ""R: already initialized"");

        // Allow list currency to be called by this contract for the purposes of
        // initializing ETH as a currency
        owner = msg.sender;
        // List ETH as currency id == 1, NOTE: return value is ignored here
        (bool status, ) =
            address(GOVERNANCE).delegatecall(
                abi.encodeWithSelector(
                    NotionalGovernance.listCurrency.selector,
                    TokenStorage(cETH, false, TokenType.cETH),
                    // No underlying set for cETH
                    TokenStorage(address(0), false, TokenType.Ether),
                    address(0),
                    false,
                    130, // Initial settings of 130 buffer
                    70,  // 70% haircut
                    105  // 105 liquidation discount
                )
            );
        require(status);

        owner = owner_;
        // The pause guardian may downgrade the router to the pauseRouter
        pauseRouter = pauseRouter_;
        pauseGuardian = pauseGuardian_;
    }

    /// @notice Returns the implementation contract for the method signature
    /// @param sig method signature to call
    /// @return implementation address
    function getRouterImplementation(bytes4 sig) public view returns (address) {
        if (
            sig == NotionalProxy.batchBalanceAction.selector ||
            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||
            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector
        ) {
            return BATCH_ACTION;
        }

        if (
            sig == nTokenAction.nTokenTotalSupply.selector ||
            sig == nTokenAction.nTokenBalanceOf.selector ||
            sig == nTokenAction.nTokenTransferAllowance.selector ||
            sig == nTokenAction.nTokenTransferApprove.selector ||
            sig == nTokenAction.nTokenTransfer.selector ||
            sig == nTokenAction.nTokenTransferFrom.selector ||
            sig == nTokenAction.nTokenClaimIncentives.selector ||
            sig == nTokenAction.nTokenTransferApproveAll.selector ||
            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||
            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector
        ) {
            return NTOKEN_ACTIONS;
        }

        if (
            sig == NotionalProxy.depositUnderlyingToken.selector ||
            sig == NotionalProxy.depositAssetToken.selector ||
            sig == NotionalProxy.withdraw.selector ||
            sig == NotionalProxy.settleAccount.selector ||
            sig == NotionalProxy.enableBitmapCurrency.selector
        ) {
            return ACCOUNT_ACTION;
        }

        if (
            sig == nTokenRedeemAction.nTokenRedeem.selector ||
            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector
        ) {
            return NTOKEN_REDEEM;
        }

        if (
            sig == nERC1155Interface.supportsInterface.selector ||
            sig == nERC1155Interface.balanceOf.selector ||
            sig == nERC1155Interface.balanceOfBatch.selector ||
            sig == nERC1155Interface.safeTransferFrom.selector ||
            sig == nERC1155Interface.safeBatchTransferFrom.selector ||
            sig == nERC1155Interface.decodeToAssets.selector ||
            sig == nERC1155Interface.encodeToId.selector ||
            sig == nERC1155Interface.setApprovalForAll.selector ||
            sig == nERC1155Interface.isApprovedForAll.selector
        ) {
            return ERC1155;
        }

        if (
            sig == NotionalProxy.liquidateLocalCurrency.selector ||
            sig == NotionalProxy.liquidateCollateralCurrency.selector ||
            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||
            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector
        ) {
            return LIQUIDATE_CURRENCY;
        }

        if (
            sig == NotionalProxy.liquidatefCashLocal.selector ||
            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||
            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||
            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector
        ) {
            return LIQUIDATE_FCASH;
        }

        if (
            sig == NotionalProxy.initializeMarkets.selector ||
            sig == NotionalProxy.sweepCashIntoMarkets.selector
        ) {
            return INITIALIZE_MARKET;
        }

        if (
            sig == NotionalGovernance.listCurrency.selector ||
            sig == NotionalGovernance.enableCashGroup.selector ||
            sig == NotionalGovernance.updateCashGroup.selector ||
            sig == NotionalGovernance.updateAssetRate.selector ||
            sig == NotionalGovernance.updateETHRate.selector ||
            sig == NotionalGovernance.transferOwnership.selector ||
            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||
            sig == NotionalGovernance.updateDepositParameters.selector ||
            sig == NotionalGovernance.updateInitializationParameters.selector ||
            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||
            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||
            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||
            sig == NotionalProxy.upgradeTo.selector ||
            sig == NotionalProxy.upgradeToAndCall.selector
        ) {
            return GOVERNANCE;
        }

        // If not found then delegate to views. This will revert if there is no method on
        // the view contract
        return VIEWS;
    }

    /// @dev Delegates the current call to `implementation`.
    /// This function does not return to its internal call site, it will return directly to the external caller.
    function _delegate(address implementation) private {
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
                // delegatecall returns 0 on error.
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    fallback() external payable {
        _delegate(getRouterImplementation(msg.sig));
    }

    // NOTE: receive() is overridden in ""nProxy"" to allow for eth transfers to succeed
}

",1954,236,"[H-08] DOS by Frontrunning NoteERC20 initialize() Function

The scripts/ folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilize the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic.
When users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. NoteERC20.sol and Router.sol both implement an initialize() function which aims to replace the role of the constructor() when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious front-running.
",1,,"pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""./actions/nTokenAction.sol"";
import ""./actions/nTokenMintAction.sol"";
import ""./actions/nTokenRedeemAction.sol"";
import ""../global/StorageLayoutV1.sol"";
import ""../global/Types.sol"";
import ""interfaces/notional/NotionalProxy.sol"";
import ""interfaces/notional/nERC1155Interface.sol"";
import ""interfaces/notional/NotionalGovernance.sol"";


contract Router is StorageLayoutV1 {
    
    address public immutable GOVERNANCE;
    address public immutable VIEWS;
    address public immutable INITIALIZE_MARKET;
    address public immutable NTOKEN_ACTIONS;
    address public immutable NTOKEN_REDEEM;
    address public immutable BATCH_ACTION;
    address public immutable ACCOUNT_ACTION;
    address public immutable ERC1155;
    address public immutable LIQUIDATE_CURRENCY;
    address public immutable LIQUIDATE_FCASH;
    address public immutable cETH;

    constructor(
        address governance_,
        address views_,
        address initializeMarket_,
        address nTokenActions_,
        address nTokenRedeem_,
        address batchAction_,
        address accountAction_,
        address erc1155_,
        address liquidateCurrency_,
        address liquidatefCash_,
        address cETH_
    ) {
        GOVERNANCE = governance_;
        VIEWS = views_;
        INITIALIZE_MARKET = initializeMarket_;
        NTOKEN_ACTIONS = nTokenActions_;
        NTOKEN_REDEEM = nTokenRedeem_;
        BATCH_ACTION = batchAction_;
        ACCOUNT_ACTION = accountAction_;
        ERC1155 = erc1155_;
        LIQUIDATE_CURRENCY = liquidateCurrency_;
        LIQUIDATE_FCASH = liquidatefCash_;
        cETH = cETH_;
    }

    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {
        
        
        require(owner == address(0), ""R: already initialized"");

        
        
        owner = msg.sender;
        
        (bool status, ) =
            address(GOVERNANCE).delegatecall(
                abi.encodeWithSelector(
                    NotionalGovernance.listCurrency.selector,
                    TokenStorage(cETH, false, TokenType.cETH),
                    
                    TokenStorage(address(0), false, TokenType.Ether),
                    address(0),
                    false,
                    130, 
                    70,  
                    105  
                )
            );
        require(status);

        owner = owner_;
        
        pauseRouter = pauseRouter_;
        pauseGuardian = pauseGuardian_;
    }

    
    
    
    function getRouterImplementation(bytes4 sig) public view returns (address) {
        if (
            sig == NotionalProxy.batchBalanceAction.selector ||
            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||
            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector
        ) {
            return BATCH_ACTION;
        }

        if (
            sig == nTokenAction.nTokenTotalSupply.selector ||
            sig == nTokenAction.nTokenBalanceOf.selector ||
            sig == nTokenAction.nTokenTransferAllowance.selector ||
            sig == nTokenAction.nTokenTransferApprove.selector ||
            sig == nTokenAction.nTokenTransfer.selector ||
            sig == nTokenAction.nTokenTransferFrom.selector ||
            sig == nTokenAction.nTokenClaimIncentives.selector ||
            sig == nTokenAction.nTokenTransferApproveAll.selector ||
            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||
            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector
        ) {
            return NTOKEN_ACTIONS;
        }

        if (
            sig == NotionalProxy.depositUnderlyingToken.selector ||
            sig == NotionalProxy.depositAssetToken.selector ||
            sig == NotionalProxy.withdraw.selector ||
            sig == NotionalProxy.settleAccount.selector ||
            sig == NotionalProxy.enableBitmapCurrency.selector
        ) {
            return ACCOUNT_ACTION;
        }

        if (
            sig == nTokenRedeemAction.nTokenRedeem.selector ||
            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector
        ) {
            return NTOKEN_REDEEM;
        }

        if (
            sig == nERC1155Interface.supportsInterface.selector ||
            sig == nERC1155Interface.balanceOf.selector ||
            sig == nERC1155Interface.balanceOfBatch.selector ||
            sig == nERC1155Interface.safeTransferFrom.selector ||
            sig == nERC1155Interface.safeBatchTransferFrom.selector ||
            sig == nERC1155Interface.decodeToAssets.selector ||
            sig == nERC1155Interface.encodeToId.selector ||
            sig == nERC1155Interface.setApprovalForAll.selector ||
            sig == nERC1155Interface.isApprovedForAll.selector
        ) {
            return ERC1155;
        }

        if (
            sig == NotionalProxy.liquidateLocalCurrency.selector ||
            sig == NotionalProxy.liquidateCollateralCurrency.selector ||
            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||
            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector
        ) {
            return LIQUIDATE_CURRENCY;
        }

        if (
            sig == NotionalProxy.liquidatefCashLocal.selector ||
            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||
            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||
            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector
        ) {
            return LIQUIDATE_FCASH;
        }

        if (
            sig == NotionalProxy.initializeMarkets.selector ||
            sig == NotionalProxy.sweepCashIntoMarkets.selector
        ) {
            return INITIALIZE_MARKET;
        }

        if (
            sig == NotionalGovernance.listCurrency.selector ||
            sig == NotionalGovernance.enableCashGroup.selector ||
            sig == NotionalGovernance.updateCashGroup.selector ||
            sig == NotionalGovernance.updateAssetRate.selector ||
            sig == NotionalGovernance.updateETHRate.selector ||
            sig == NotionalGovernance.transferOwnership.selector ||
            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||
            sig == NotionalGovernance.updateDepositParameters.selector ||
            sig == NotionalGovernance.updateInitializationParameters.selector ||
            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||
            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||
            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||
            sig == NotionalProxy.upgradeTo.selector ||
            sig == NotionalProxy.upgradeToAndCall.selector
        ) {
            return GOVERNANCE;
        }

        
        
        return VIEWS;
    }

    
    
    function _delegate(address implementation) private {
        
        assembly {
            
            
            
            calldatacopy(0, 0, calldatasize())

            
            
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            
            returndatacopy(0, 0, returndatasize())

            switch result
                
                case 0 {
                    revert(0, returndatasize())
                }
                default {
                    return(0, returndatasize())
                }
        }
    }

    fallback() external payable {
        _delegate(getRouterImplementation(msg.sig));
    }

    
}",1508,1,0,,,,86.40225100517273,"### **Output**

---

**[H-08] DOS by Frontrunning NoteERC20 initialize() Function**

**Report Description**:  
The `initialize()` function in `NoteERC20.sol` and `Router.sol` is used to replace the role of the `constructor()` when deploying proxy contracts under the ERC1967 upgradeable proxy standard. However, if the proxy contracts are not deployed and initialized in the same transaction, malicious actors can front-run the initialization process. This could lead to a Denial of Service (DOS) attack, where the attacker initializes the contract with malicious parameters, rendering the contract unusable or compromised.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of front-running during the initialization of proxy contracts. This is a critical vulnerability in upgradeable proxy patterns, and the lack of any mention or solution in the response list indicates a significant gap in coverage. Solidity best practices for upgradeable contracts emphasize the importance of deploying and initializing proxy contracts in the same transaction to prevent such attacks.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-08] DOS by Frontrunning NoteERC20 initialize() Function**

--- 

This evaluation highlights a critical gap in the response list, as it fails to address the front-running vulnerability in the initialization of proxy contracts. This issue is particularly significant in the context of upgradeable proxy patterns and should be addressed to ensure the security of the deployed contracts.","```
None.
```",0.0
NoteERC20.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";
import ""@openzeppelin/contracts/cryptography/ECDSA.sol"";
import ""../../proxy/utils/UUPSUpgradeable.sol"";

/// @title Note ERC20 Token
/// Fork of Compound Comp token at commit hash
/// https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96
contract NoteERC20 is Initializable, UUPSUpgradeable {
    /// @notice EIP-20 token name for this token
    string public constant name = ""Notional"";

    /// @notice EIP-20 token symbol for this token
    string public constant symbol = ""NOTE"";

    /// @notice EIP-20 token decimals for this token
    uint8 public constant decimals = 8;

    /// @notice Total number of tokens in circulation (100 million NOTE)
    uint256 public constant totalSupply = 100000000e8;

    /// @notice Notional router address
    NotionalProxy public notionalProxy;

    // Allowance amounts on behalf of others
    mapping(address => mapping(address => uint96)) internal allowances;

    // Official record of token balances for each account
    mapping(address => uint96) internal balances;

    /// @notice A record of each accounts delegate
    mapping(address => address) public delegates;

    /// @notice A checkpoint for marking number of votes from a given block
    struct Checkpoint {
        uint32 fromBlock;
        uint96 votes;
    }

    /// @notice A record of votes checkpoints for each account, by index
    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping(address => uint32) public numCheckpoints;

    /// @notice The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    /// @notice The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    /// @notice A record of states for signing / validating signatures
    mapping(address => uint256) public nonces;

    /// @notice Owner address which can upgrade the tokens implementation
    address public owner;

    /// @notice Emitted when the ownership of the contract is transferred
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice An event thats emitted when an account changes its delegate
    event DelegateChanged(
        address indexed delegator,
        address indexed fromDelegate,
        address indexed toDelegate
    );

    /// @notice An event thats emitted when a delegate account's vote balance changes
    event DelegateVotesChanged(
        address indexed delegate,
        uint256 previousBalance,
        uint256 newBalance
    );

    /// @notice The standard EIP-20 transfer event
    event Transfer(address indexed from, address indexed to, uint256 amount);

    /// @notice The standard EIP-20 approval event
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /// @notice Initialize note token with initial grants
    /// @param initialAccounts initial address to grant tokens to
    /// @param initialGrantAmount amount to grant address initially
    function initialize(
        address[] calldata initialAccounts,
        uint96[] calldata initialGrantAmount,
        address owner_
    ) public initializer {
        require(initialGrantAmount.length == initialAccounts.length);

        uint96 totalGrants = 0;
        for (uint256 i = 0; i < initialGrantAmount.length; i++) {
            totalGrants = _add96(totalGrants, initialGrantAmount[i], """");
            require(balances[initialAccounts[i]] == 0, ""Duplicate account"");
            balances[initialAccounts[i]] = initialGrantAmount[i];

            emit Transfer(address(0), initialAccounts[i], initialGrantAmount[i]);
        }

        require(totalGrants == totalSupply);
        owner = owner_;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function activateNotional(NotionalProxy notionalProxy_) external onlyOwner {
        require(address(notionalProxy) == address(0), ""Notional Proxy already initialized"");
        Address.isContract(address(notionalProxy_));
        notionalProxy = notionalProxy_;
    }

    /// @dev Transfers ownership of the contract to a new account (`newOwner`).
    /// Can only be called by the current owner.
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    /// @dev Only the owner may upgrade the contract
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }

    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
    /// @param account The address of the account holding the funds
    /// @param spender The address of the account spending the funds
    /// @return The number of tokens approved
    function allowance(address account, address spender) external view returns (uint256) {
        return allowances[account][spender];
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    ///  emit:Approval
    /// @param spender The address of the account which may transfer tokens
    /// @param rawAmount The number of tokens that are approved (2^256-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 rawAmount) external returns (bool) {
        uint96 amount;
        if (rawAmount == uint256(-1)) {
            amount = uint96(-1);
        } else {
            amount = _safe96(rawAmount, ""Note::approve: amount exceeds 96 bits"");
        }

        allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Get the number of tokens held by the `account`
    /// @param account The address of the account to get the balance of
    /// @return The number of tokens held
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @dev emit:Transfer
    /// @param dst The address of the destination account
    /// @param rawAmount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 rawAmount) external returns (bool) {
        uint96 amount = _safe96(rawAmount, ""Note::transfer: amount exceeds 96 bits"");
        _transferTokens(msg.sender, dst, amount);
        return true;
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @dev emit:Transfer emit:Approval
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param rawAmount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(
        address src,
        address dst,
        uint256 rawAmount
    ) external returns (bool) {
        // Short circuit transfer execution and return true. It may be the case that external
        // logic tries to execute a zero transfer but don't emit events here.
        if (rawAmount == 0) {
            // Emit a zero transfer event for ERC20 token compatibility
            emit Transfer(src, dst, 0);
            return true;
        }

        address spender = msg.sender;
        uint96 spenderAllowance = allowances[src][spender];
        uint96 amount = _safe96(rawAmount, ""Note::approve: amount exceeds 96 bits"");

        if (spender != src && spenderAllowance != uint96(-1)) {
            uint96 newAllowance =
                _sub96(
                    spenderAllowance,
                    amount,
                    ""Note::transferFrom: transfer amount exceeds spender allowance""
                );
            allowances[src][spender] = newAllowance;

            emit Approval(src, spender, newAllowance);
        }

        _transferTokens(src, dst, amount);
        return true;
    }

    /// @notice Delegate votes from `msg.sender` to `delegatee`
    /// @param delegatee The address to delegate votes to
    /// @dev emit:DelegatesChanged
    function delegate(address delegatee) public {
        _delegate(msg.sender, delegatee);
    }

    /// @notice Delegates votes from signatory to `delegatee`
    /// @dev emit:DelegatesChanged
    /// @param delegatee The address to delegate votes to
    /// @param nonce The contract state required to match the signature
    /// @param expiry The time at which to expire the signature
    /// @param v The recovery byte of the signature
    /// @param r Half of the ECDSA signature pair
    /// @param s Half of the ECDSA signature pair
    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        bytes32 domainSeparator =
            keccak256(
                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))
            );
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
        // ECDSA will check if address is zero inside
        address signatory = ECDSA.recover(digest, v, r, s);
        require(nonce == nonces[signatory]++, ""Note::delegateBySig: invalid nonce"");
        require(block.timestamp <= expiry, ""Note::delegateBySig: signature expired"");
        _delegate(signatory, delegatee);
    }

    /// @notice Gets the current votes balance for `account`
    /// @param account The address to get votes balance
    /// @return The number of current votes for `account`
    function getCurrentVotes(address account) external view returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        uint96 currentVotes = nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
        return
            _add96(
                currentVotes,
                getUnclaimedVotes(account),
                ""Note::getCurrentVotes: uint96 overflow""
            );
    }

    /// @notice Determine the prior number of votes for an account as of a block number
    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
    /// @param account The address of the account to check
    /// @param blockNumber The block number to get the vote balance at
    /// @return The number of votes the account had as of the given block
    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {
        require(blockNumber < block.number, ""Note::getPriorVotes: not yet determined"");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return _add96(
                checkpoints[account][nCheckpoints - 1].votes,
                getUnclaimedVotes(account),
                ""Note::getPriorVotes: uint96 overflow""
            );
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return
                    _add96(
                        cp.votes,
                        getUnclaimedVotes(account),
                        ""Note::getPriorVotes: uint96 overflow""
                    );
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }

        return
            _add96(
                checkpoints[account][lower].votes,
                getUnclaimedVotes(account),
                ""Note::getPriorVotes: uint96 overflow""
            );
    }

    /// @notice Notional counts unclaimed incentives as part of a users' voting power. There is no
    /// need to checkpoint these values because they cannot be transferred or delegated.
    /// @param account the address of the Notional account to check
    /// @return Total number of unclaimed tokens accrued on the Notional account
    function getUnclaimedVotes(address account) public view returns (uint96) {
        // If the notional proxy is not set then there are no unclaimed votes
        if (address(notionalProxy) == address(0)) return 0;

        uint256 votes = notionalProxy.nTokenGetClaimableIncentives(account, block.timestamp);
        require(votes <= type(uint96).max);
        return uint96(votes);
    }

    /// @dev Changes delegates from one address to another
    function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = delegates[delegator];
        uint96 delegatorBalance = balances[delegator];
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    /// @dev Transfers tokens and inherits the delegate from the destination address
    function _transferTokens(
        address src,
        address dst,
        uint96 amount
    ) internal {
        require(src != address(0), ""Note::_transferTokens: cannot transfer from the zero address"");
        require(dst != address(0), ""Note::_transferTokens: cannot transfer to the zero address"");

        balances[src] = _sub96(
            balances[src],
            amount,
            ""Note::_transferTokens: transfer amount exceeds balance""
        );
        balances[dst] = _add96(
            balances[dst],
            amount,
            ""Note::_transferTokens: transfer amount overflows""
        );
        emit Transfer(src, dst, amount);

        _moveDelegates(delegates[src], delegates[dst], amount);
    }

    /// @dev Transfers delegates and writes a checkpoint for `getPriorVotes` to use
    function _moveDelegates(
        address srcRep,
        address dstRep,
        uint96 amount
    ) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
                uint96 srcRepNew =
                    _sub96(srcRepOld, amount, ""Note::_moveVotes: vote amount underflow"");
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
                uint96 dstRepNew =
                    _add96(dstRepOld, amount, ""Note::_moveVotes: vote amount overflows"");
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    /// @dev Writes checkpoints for `getPriorVotes`, this is somewhat inefficient as it uses
    /// 20000 gas per transfer of delegated tokens. The goal is prevent voters from borrowing
    /// a large number of votes for a short period to vote for or against a proposal. It's unclear
    /// if there is a better model than this one here. Using only a single checkpoint means that
    /// a delegate could be the victim of a denial of service attack where an attacker continually
    /// transfers tokens to them to prevent them from voting.
    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint96 oldVotes,
        uint96 newVotes
    ) internal {
        uint32 blockNumber =
            _safe32(block.number, ""Note::_writeCheckpoint: block number exceeds 32 bits"");

        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    function _safe32(uint256 n, string memory errorMessage) private pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function _safe96(uint256 n, string memory errorMessage) private pure returns (uint96) {
        require(n < 2**96, errorMessage);
        return uint96(n);
    }

    function _add96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) private pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function _sub96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) private pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
    }

    function _getChainId() private pure returns (uint256) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId;
    }
}

",4036,458,"[H-09] Potential DOS in Contracts Inheriting UUPSUpgradeable.sol

Function `initialize()`
There are a number of contracts which inherit UUPSUpgradeable.sol, namely; GovernanceAction.sol, PauseRouter.sol and NoteERC20.sol.
All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract.
However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the onlyOwner role in the implementation contract for NoteERC20.sol. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all NoteERC20.sol interactions until a new implementation contract is deployed.
",1,,"pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

import ""interfaces/notional/NotionalProxy.sol"";
import ""@openzeppelin/contracts/proxy/Initializable.sol"";
import ""@openzeppelin/contracts/cryptography/ECDSA.sol"";
import ""../../proxy/utils/UUPSUpgradeable.sol"";




contract NoteERC20 is Initializable, UUPSUpgradeable {
    
    string public constant name = ""Notional"";

    
    string public constant symbol = ""NOTE"";

    
    uint8 public constant decimals = 8;

    
    uint256 public constant totalSupply = 100000000e8;

    
    NotionalProxy public notionalProxy;

    
    mapping(address => mapping(address => uint96)) internal allowances;

    
    mapping(address => uint96) internal balances;

    
    mapping(address => address) public delegates;

    
    struct Checkpoint {
        uint32 fromBlock;
        uint96 votes;
    }

    
    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;

    
    mapping(address => uint32) public numCheckpoints;

    
    bytes32 public constant DOMAIN_TYPEHASH =
        keccak256(""EIP712Domain(string name,uint256 chainId,address verifyingContract)"");

    
    bytes32 public constant DELEGATION_TYPEHASH =
        keccak256(""Delegation(address delegatee,uint256 nonce,uint256 expiry)"");

    
    mapping(address => uint256) public nonces;

    
    address public owner;

    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    event DelegateChanged(
        address indexed delegator,
        address indexed fromDelegate,
        address indexed toDelegate
    );

    
    event DelegateVotesChanged(
        address indexed delegate,
        uint256 previousBalance,
        uint256 newBalance
    );

    
    event Transfer(address indexed from, address indexed to, uint256 amount);

    
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    
    
    
    function initialize(
        address[] calldata initialAccounts,
        uint96[] calldata initialGrantAmount,
        address owner_
    ) public initializer {
        require(initialGrantAmount.length == initialAccounts.length);

        uint96 totalGrants = 0;
        for (uint256 i = 0; i < initialGrantAmount.length; i++) {
            totalGrants = _add96(totalGrants, initialGrantAmount[i], """");
            require(balances[initialAccounts[i]] == 0, ""Duplicate account"");
            balances[initialAccounts[i]] = initialGrantAmount[i];

            emit Transfer(address(0), initialAccounts[i], initialGrantAmount[i]);
        }

        require(totalGrants == totalSupply);
        owner = owner_;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    function activateNotional(NotionalProxy notionalProxy_) external onlyOwner {
        require(address(notionalProxy) == address(0), ""Notional Proxy already initialized"");
        Address.isContract(address(notionalProxy_));
        notionalProxy = notionalProxy_;
    }

    
    
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner { }

    
    
    
    
    function allowance(address account, address spender) external view returns (uint256) {
        return allowances[account][spender];
    }

    
    
    
    
    
    
    
    function approve(address spender, uint256 rawAmount) external returns (bool) {
        uint96 amount;
        if (rawAmount == uint256(-1)) {
            amount = uint96(-1);
        } else {
            amount = _safe96(rawAmount, ""Note::approve: amount exceeds 96 bits"");
        }

        allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);
        return true;
    }

    
    
    
    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }

    
    
    
    
    
    function transfer(address dst, uint256 rawAmount) external returns (bool) {
        uint96 amount = _safe96(rawAmount, ""Note::transfer: amount exceeds 96 bits"");
        _transferTokens(msg.sender, dst, amount);
        return true;
    }

    
    
    
    
    
    
    function transferFrom(
        address src,
        address dst,
        uint256 rawAmount
    ) external returns (bool) {
        
        
        if (rawAmount == 0) {
            
            emit Transfer(src, dst, 0);
            return true;
        }

        address spender = msg.sender;
        uint96 spenderAllowance = allowances[src][spender];
        uint96 amount = _safe96(rawAmount, ""Note::approve: amount exceeds 96 bits"");

        if (spender != src && spenderAllowance != uint96(-1)) {
            uint96 newAllowance =
                _sub96(
                    spenderAllowance,
                    amount,
                    ""Note::transferFrom: transfer amount exceeds spender allowance""
                );
            allowances[src][spender] = newAllowance;

            emit Approval(src, spender, newAllowance);
        }

        _transferTokens(src, dst, amount);
        return true;
    }

    
    
    
    function delegate(address delegatee) public {
        _delegate(msg.sender, delegatee);
    }

    
    
    
    
    
    
    
    
    function delegateBySig(
        address delegatee,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public {
        bytes32 domainSeparator =
            keccak256(
                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))
            );
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked(""\x19\x01"", domainSeparator, structHash));
        
        address signatory = ECDSA.recover(digest, v, r, s);
        require(nonce == nonces[signatory]++, ""Note::delegateBySig: invalid nonce"");
        require(block.timestamp <= expiry, ""Note::delegateBySig: signature expired"");
        _delegate(signatory, delegatee);
    }

    
    
    
    function getCurrentVotes(address account) external view returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        uint96 currentVotes = nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
        return
            _add96(
                currentVotes,
                getUnclaimedVotes(account),
                ""Note::getCurrentVotes: uint96 overflow""
            );
    }

    
    
    
    
    
    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {
        require(blockNumber < block.number, ""Note::getPriorVotes: not yet determined"");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return _add96(
                checkpoints[account][nCheckpoints - 1].votes,
                getUnclaimedVotes(account),
                ""Note::getPriorVotes: uint96 overflow""
            );
        }

        
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; 
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return
                    _add96(
                        cp.votes,
                        getUnclaimedVotes(account),
                        ""Note::getPriorVotes: uint96 overflow""
                    );
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }

        return
            _add96(
                checkpoints[account][lower].votes,
                getUnclaimedVotes(account),
                ""Note::getPriorVotes: uint96 overflow""
            );
    }

    
    
    
    
    function getUnclaimedVotes(address account) public view returns (uint96) {
        
        if (address(notionalProxy) == address(0)) return 0;

        uint256 votes = notionalProxy.nTokenGetClaimableIncentives(account, block.timestamp);
        require(votes <= type(uint96).max);
        return uint96(votes);
    }

    
    function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = delegates[delegator];
        uint96 delegatorBalance = balances[delegator];
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    
    function _transferTokens(
        address src,
        address dst,
        uint96 amount
    ) internal {
        require(src != address(0), ""Note::_transferTokens: cannot transfer from the zero address"");
        require(dst != address(0), ""Note::_transferTokens: cannot transfer to the zero address"");

        balances[src] = _sub96(
            balances[src],
            amount,
            ""Note::_transferTokens: transfer amount exceeds balance""
        );
        balances[dst] = _add96(
            balances[dst],
            amount,
            ""Note::_transferTokens: transfer amount overflows""
        );
        emit Transfer(src, dst, amount);

        _moveDelegates(delegates[src], delegates[dst], amount);
    }

    
    function _moveDelegates(
        address srcRep,
        address dstRep,
        uint96 amount
    ) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
                uint96 srcRepNew =
                    _sub96(srcRepOld, amount, ""Note::_moveVotes: vote amount underflow"");
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
                uint96 dstRepNew =
                    _add96(dstRepOld, amount, ""Note::_moveVotes: vote amount overflows"");
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    
    
    
    
    
    
    function _writeCheckpoint(
        address delegatee,
        uint32 nCheckpoints,
        uint96 oldVotes,
        uint96 newVotes
    ) internal {
        uint32 blockNumber =
            _safe32(block.number, ""Note::_writeCheckpoint: block number exceeds 32 bits"");

        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[delegatee] = nCheckpoints + 1;
        }

        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    function _safe32(uint256 n, string memory errorMessage) private pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function _safe96(uint256 n, string memory errorMessage) private pure returns (uint96) {
        require(n < 2**96, errorMessage);
        return uint96(n);
    }

    function _add96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) private pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function _sub96(
        uint96 a,
        uint96 b,
        string memory errorMessage
    ) private pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
    }

    function _getChainId() private pure returns (uint256) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        return chainId;
    }
}",2703,1,0,,"{'ReviewingTheCode': ""The provided code is a Solidity smart contract named 'NoteERC20' that implements an ERC20 token with additional delegation and voting functionalities. It includes standard ERC20 methods like `transfer`, `approve`, and `balanceOf`, as well as custom delegation logic for voting. The contract is upgradeable using the UUPS proxy pattern and is initialized with a set of initial accounts and grant amounts. It also interacts with an external contract `NotionalProxy` to fetch unclaimed votes."", 'IdentifyingKeyComponents': {'ContractName': 'NoteERC20', 'Purpose': 'To implement an ERC20 token with delegation and voting capabilities, and to manage token transfers, approvals, and balances.', 'InheritanceAndImports': {'InheritsFrom': ['Initializable', 'UUPSUpgradeable'], 'Imports': ['interfaces/notional/NotionalProxy.sol', '@openzeppelin/contracts/proxy/Initializable.sol', '@openzeppelin/contracts/cryptography/ECDSA.sol', '../../proxy/utils/UUPSUpgradeable.sol']}, 'StateVariables': [{'Name': 'name', 'Type': 'string', 'Purpose': 'The name of the token.'}, {'Name': 'symbol', 'Type': 'string', 'Purpose': 'The symbol of the token.'}, {'Name': 'decimals', 'Type': 'uint8', 'Purpose': 'The number of decimals the token uses.'}, {'Name': 'totalSupply', 'Type': 'uint256', 'Purpose': 'The total supply of the token.'}, {'Name': 'notionalProxy', 'Type': 'NotionalProxy', 'Purpose': 'The external contract used to fetch unclaimed votes.'}, {'Name': 'allowances', 'Type': 'mapping(address => mapping(address => uint96))', 'Purpose': 'Stores the allowances granted by token holders to spenders.'}, {'Name': 'balances', 'Type': 'mapping(address => uint96)', 'Purpose': 'Stores the token balances of each account.'}, {'Name': 'delegates', 'Type': 'mapping(address => address)', 'Purpose': 'Stores the delegate addresses for each token holder.'}, {'Name': 'checkpoints', 'Type': 'mapping(address => mapping(uint32 => Checkpoint))', 'Purpose': 'Stores voting checkpoints for each delegate.'}, {'Name': 'numCheckpoints', 'Type': 'mapping(address => uint32)', 'Purpose': 'Stores the number of checkpoints for each delegate.'}, {'Name': 'DOMAIN_TYPEHASH', 'Type': 'bytes32', 'Purpose': 'The EIP712 domain type hash for delegation signatures.'}, {'Name': 'DELEGATION_TYPEHASH', 'Type': 'bytes32', 'Purpose': 'The EIP712 delegation type hash for delegation signatures.'}, {'Name': 'nonces', 'Type': 'mapping(address => uint256)', 'Purpose': 'Stores the nonces for each account to prevent replay attacks.'}, {'Name': 'owner', 'Type': 'address', 'Purpose': 'The owner of the contract, with special privileges.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the contract with initial accounts and grant amounts.', 'Parameters': ['address[] calldata initialAccounts', 'uint96[] calldata initialGrantAmount', 'address owner_'], 'Returns': []}, {'Name': 'onlyOwner', 'Visibility': 'modifier', 'Purpose': 'Restricts function access to the contract owner.', 'Parameters': [], 'Returns': []}, {'Name': 'activateNotional', 'Visibility': 'external', 'Purpose': 'Sets the `NotionalProxy` contract address.', 'Parameters': ['NotionalProxy notionalProxy_'], 'Returns': []}, {'Name': 'transferOwnership', 'Visibility': 'external', 'Purpose': 'Transfers ownership of the contract to a new address.', 'Parameters': ['address newOwner'], 'Returns': []}, {'Name': '_authorizeUpgrade', 'Visibility': 'internal', 'Purpose': 'Authorizes an upgrade to a new implementation.', 'Parameters': ['address newImplementation'], 'Returns': []}, {'Name': 'allowance', 'Visibility': 'external', 'Purpose': 'Returns the allowance of a spender for a given owner.', 'Parameters': ['address account', 'address spender'], 'Returns': ['uint256']}, {'Name': 'approve', 'Visibility': 'external', 'Purpose': 'Approves a spender to spend a specified amount of tokens.', 'Parameters': ['address spender', 'uint256 rawAmount'], 'Returns': ['bool']}, {'Name': 'balanceOf', 'Visibility': 'external', 'Purpose': 'Returns the balance of a given account.', 'Parameters': ['address account'], 'Returns': ['uint256']}, {'Name': 'transfer', 'Visibility': 'external', 'Purpose': 'Transfers tokens from the caller to a specified recipient.', 'Parameters': ['address dst', 'uint256 rawAmount'], 'Returns': ['bool']}, {'Name': 'transferFrom', 'Visibility': 'external', 'Purpose': 'Transfers tokens from a specified sender to a specified recipient.', 'Parameters': ['address src', 'address dst', 'uint256 rawAmount'], 'Returns': ['bool']}, {'Name': 'delegate', 'Visibility': 'public', 'Purpose': ""Delegates the caller's voting power to a specified delegatee."", 'Parameters': ['address delegatee'], 'Returns': []}, {'Name': 'delegateBySig', 'Visibility': 'public', 'Purpose': 'Delegates voting power using a signature.', 'Parameters': ['address delegatee', 'uint256 nonce', 'uint256 expiry', 'uint8 v', 'bytes32 r', 'bytes32 s'], 'Returns': []}, {'Name': 'getCurrentVotes', 'Visibility': 'external', 'Purpose': 'Returns the current voting power of a given account.', 'Parameters': ['address account'], 'Returns': ['uint96']}, {'Name': 'getPriorVotes', 'Visibility': 'public', 'Purpose': 'Returns the voting power of a given account at a specified block.', 'Parameters': ['address account', 'uint256 blockNumber'], 'Returns': ['uint96']}, {'Name': 'getUnclaimedVotes', 'Visibility': 'public', 'Purpose': 'Returns the unclaimed voting power of a given account.', 'Parameters': ['address account'], 'Returns': ['uint96']}, {'Name': '_delegate', 'Visibility': 'internal', 'Purpose': 'Internal function to handle delegation logic.', 'Parameters': ['address delegator', 'address delegatee'], 'Returns': []}, {'Name': '_transferTokens', 'Visibility': 'internal', 'Purpose': 'Internal function to handle token transfers.', 'Parameters': ['address src', 'address dst', 'uint96 amount'], 'Returns': []}, {'Name': '_moveDelegates', 'Visibility': 'internal', 'Purpose': 'Internal function to move delegates during token transfers.', 'Parameters': ['address srcRep', 'address dstRep', 'uint96 amount'], 'Returns': []}, {'Name': '_writeCheckpoint', 'Visibility': 'internal', 'Purpose': 'Internal function to write a checkpoint for a delegate.', 'Parameters': ['address delegatee', 'uint32 nCheckpoints', 'uint96 oldVotes', 'uint96 newVotes'], 'Returns': []}, {'Name': '_safe32', 'Visibility': 'private', 'Purpose': 'Internal function to safely cast a uint256 to uint32.', 'Parameters': ['uint256 n', 'string memory errorMessage'], 'Returns': ['uint32']}, {'Name': '_safe96', 'Visibility': 'private', 'Purpose': 'Internal function to safely cast a uint256 to uint96.', 'Parameters': ['uint256 n', 'string memory errorMessage'], 'Returns': ['uint96']}, {'Name': '_add96', 'Visibility': 'private', 'Purpose': 'Internal function to safely add two uint96 values.', 'Parameters': ['uint96 a', 'uint96 b', 'string memory errorMessage'], 'Returns': ['uint96']}, {'Name': '_sub96', 'Visibility': 'private', 'Purpose': 'Internal function to safely subtract two uint96 values.', 'Parameters': ['uint96 a', 'uint96 b', 'string memory errorMessage'], 'Returns': ['uint96']}, {'Name': '_getChainId', 'Visibility': 'private', 'Purpose': 'Internal function to get the current chain ID.', 'Parameters': [], 'Returns': ['uint256']}]}, 'ExternalInteractions': ['NotionalProxy'], 'SpecialMechanisms': ['UUPS Upgradeable Proxy Pattern', 'EIP712 Signature-Based Delegation', 'Checkpoint-Based Voting System'], 'Questions': ['What is the purpose of the `getUnclaimedVotes` function and how does it interact with `NotionalProxy`?', 'Is there a specific reason for using `uint96` for balances and allowances instead of `uint256`?', 'How does the `_writeCheckpoint` function ensure the integrity of the voting checkpoints?']}","{'Findings': [{'Issue': 'Potential Integer Overflow/Underflow in `_add96` and `_sub96` Functions', 'Severity': 'Medium', 'Description': 'The `_add96` and `_sub96` functions perform arithmetic operations on `uint96` values without fully checking for overflow or underflow. While some checks are in place, they do not cover all edge cases, potentially leading to incorrect calculations.', 'Impact': 'Incorrect calculations could affect token balances, voting weights, or other critical contract logic, leading to potential financial losses or manipulation of contract state.', 'Location': 'Functions `_add96` and `_sub96` in the contract.'}, {'Issue': 'Lack of Input Validation in `initialize` Function', 'Severity': 'High', 'Description': 'The `initialize` function does not validate the lengths of `initialAccounts` and `initialGrantAmount` arrays beyond checking if they are equal. It also lacks checks for empty arrays or invalid addresses, which could lead to incorrect initialization.', 'Impact': 'Incorrect initialization could result in improper token distribution, leading to potential exploits or loss of funds.', 'Location': 'Function `initialize` in the contract.'}, {'Issue': 'Potential Reentrancy in `transferFrom` Function', 'Severity': 'High', 'Description': 'The `transferFrom` function does not follow the checks-effects-interactions pattern, potentially allowing reentrancy attacks if external calls are introduced in the future. The function emits events before updating state, which could be exploited.', 'Impact': 'Reentrancy attacks could allow manipulation of token balances or allowances, leading to loss of funds.', 'Location': 'Function `transferFrom` in the contract.'}, {'Issue': 'Uninitialized `notionalProxy` Contract', 'Severity': 'Medium', 'Description': 'The `notionalProxy` contract is not initialized during deployment or in the constructor, and can only be set via the `activateNotional` function. If uninitialized, functions relying on it may fail or return incorrect results.', 'Impact': 'Functionality dependent on `notionalProxy` will be unavailable or incorrect until initialized, affecting contract operation.', 'Location': 'Variable `notionalProxy` and function `activateNotional` in the contract.'}, {'Issue': 'Potential Signature Replay in `delegateBySig` Function', 'Severity': 'Medium', 'Description': 'The `delegateBySig` function uses a nonce to prevent replay attacks but does not include chain ID validation or mechanisms to prevent front-running. This could allow signatures to be replayed across chains or intercepted.', 'Impact': 'Replay attacks could lead to unauthorized delegation of votes, affecting governance decisions.', 'Location': 'Function `delegateBySig` in the contract.'}, {'Issue': 'Unrestricted Upgradeability in `_authorizeUpgrade` Function', 'Severity': 'High', 'Description': 'The `_authorizeUpgrade` function is only protected by the `onlyOwner` modifier, allowing the owner to upgrade the contract without additional checks. This could introduce vulnerabilities if the new implementation is malicious or faulty.', 'Impact': 'Unauthorized or malicious upgrades could compromise the contract, leading to loss of funds or other security breaches.', 'Location': 'Function `_authorizeUpgrade` in the contract.'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Functions like `_authorizeUpgrade`, `_moveDelegates`, and `_transferTokens` do not emit events for critical state changes, reducing transparency and auditability.', 'Impact': 'Lack of event emission makes it difficult to track upgrades, delegation changes, or token transfers, potentially leading to trust issues.', 'Location': 'Functions `_authorizeUpgrade`, `_moveDelegates`, and `_transferTokens` in the contract.'}, {'Issue': 'Unrestricted Ownership Transfer', 'Severity': 'Medium', 'Description': 'The `transferOwnership` function does not include a two-step process or validation for the new owner, potentially allowing accidental or malicious transfers to invalid addresses.', 'Impact': 'Loss of contract control could result in unauthorized modifications or actions.', 'Location': 'Function `transferOwnership` in the contract.'}, {'Issue': 'Potential Front-Running in `delegateBySig` and Ownership Transfer', 'Severity': 'Medium', 'Description': 'The `delegateBySig` and `transferOwnership` functions are susceptible to front-running attacks due to lack of mechanisms to prevent transaction interception.', 'Impact': 'Front-running could lead to unauthorized delegation or ownership changes, affecting governance or contract control.', 'Location': 'Functions `delegateBySig` and `transferOwnership` in the contract.'}, {'Issue': 'Use of Deprecated Solidity Features', 'Severity': 'Low', 'Description': 'The contract uses deprecated functions like `Address.isContract` and Solidity version 0.7.0, which may expose it to known vulnerabilities or compatibility issues.', 'Impact': 'Deprecated features could lead to unexpected behavior or vulnerabilities in future Solidity versions.', 'Location': 'Function `activateNotional` and pragma statement in the contract.'}], 'IssueNumber': 60, 'OutputList': 10}",914.5801701545716,"---

**[H-09] Potential DOS in Contracts Inheriting UUPSUpgradeable.sol**

**Report Description**:
The issue highlights a potential Denial of Service (DOS) vulnerability in contracts inheriting `UUPSUpgradeable.sol`, specifically `GovernanceAction.sol`, `PauseRouter.sol`, and `NoteERC20.sol`. These contracts use a proxy pattern where the proxy contract delegates calls to the implementation contract. If the implementation contract is left uninitialized, any user can gain ownership of the `onlyOwner` role in `NoteERC20.sol`. Once ownership is obtained, the user can upgrade the implementation contract's logic and delegate calls to an arbitrary contract, potentially self-destructing the proxy's implementation contract. This would render all `NoteERC20.sol` interactions non-functional until a new implementation contract is deployed.

**Match in Response List**:
Matches with the issue titled **""Unrestricted Upgradeability in `_authorizeUpgrade` Function""**.

**Validation**:
**Partially Correct**. The response identifies the issue of unrestricted upgradeability in the `_authorizeUpgrade` function, which is related to the broader problem of uninitialized implementation contracts. However, the response does not explicitly address the specific risk of DOS due to uninitialized contracts or the potential for self-destruction of the implementation contract. While the response correctly highlights the lack of additional checks in the upgrade process, it misses the critical detail of how uninitialized contracts can lead to ownership hijacking and DOS, which is the core of the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-09] Potential DOS in Contracts Inheriting UUPSUpgradeable.sol**

**Missed Issues from Issue Report**:
- *None*

---","```
None.
```",0.0
AssetHandler.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""../markets/CashGroup.sol"";
import ""../markets/AssetRate.sol"";
import ""../portfolio/PortfolioHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../math/ABDKMath64x64.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library AssetHandler {
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using CashGroup for CashGroupParameters;
    using AssetRate for AssetRateParameters;

    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {
        return
            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&
            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;
    }

    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method
    /// calculates the settlement date for any PortfolioAsset.
    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {
        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type
        // 3 month tokens and fCash tokens settle at maturity
        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;

        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);
        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:
        // maturity = tRef + marketLength
        // Here we calculate:
        // tRef = maturity - marketLength + 90 days
        return asset.maturity.sub(marketLength).add(Constants.QUARTER);
    }

    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.
    /// The formula is: notional * e^(-rate * timeToMaturity).
    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)
        internal
        pure
        returns (int256)
    {
        int128 expValue =
            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));
        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);
        expValue = ABDKMath64x64.exp(expValue * -1);
        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);
        int256 discountFactor = ABDKMath64x64.toInt(expValue);

        return discountFactor;
    }

    /// @notice Present value of an fCash asset without any risk adjustments.
    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor
        return notional.mulInRatePrecision(discountFactor);
    }

    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more
    /// heavily than the oracle rate given and vice versa for negative fCash.
    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            // If the adjustment exceeds the oracle rate we floor the value of the fCash
            // at the notional value. We don't want to require the account to hold more than
            // absolutely required.
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor
        return notional.mulInRatePrecision(discountFactor);
    }

    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.
    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)
        internal
        pure
        returns (int256 assetCash, int256 fCash)
    {
        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims

        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);
        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);
    }

    /// @notice Returns the haircut claims on cash and fCash
    /// @return (assetCash, fCash)
    function getHaircutCashClaims(
        PortfolioAsset memory token,
        MarketParameters memory market,
        CashGroupParameters memory cashGroup
    ) internal pure returns (int256, int256) {
        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset get haircut cash claims

        require(token.currencyId == cashGroup.currencyId); // dev: haircut cash claims, currency id mismatch
        // This won't overflow, the liquidity token haircut is stored as an uint8
        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));

        int256 assetCash =
            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);

        int256 fCash =
            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);

        return (assetCash, fCash);
    }

    /// @dev This is here to clean up the stack in getHaircutCashClaims
    function _calcToken(
        int256 numerator,
        int256 tokens,
        int256 haircut,
        int256 liquidity
    ) private pure returns (int256) {
        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);
    }

    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)
    function getLiquidityTokenValue(
        uint256 index,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        PortfolioAsset[] memory assets,
        uint256 blockTime,
        bool riskAdjusted
    ) internal view returns (int256, int256) {
        PortfolioAsset memory liquidityToken = assets[index];
        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); // dev: get liquidity token value, not liquidity token

        {
            (uint256 marketIndex, bool idiosyncratic) =
                DateTime.getMarketIndex(
                    cashGroup.maxMarketIndex,
                    liquidityToken.maturity,
                    blockTime
                );
            // Liquidity tokens can never be idiosyncratic
            require(!idiosyncratic); // dev: idiosyncratic liquidity token

            // This market will always be initialized, if a liquidity token exists that means the market has some liquidity in it.
            cashGroup.loadMarket(market, marketIndex, true, blockTime);
        }

        int256 assetCashClaim;
        int256 fCashClaim;
        if (riskAdjusted) {
            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);
        } else {
            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);
        }

        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and
        // in that case we know the previous asset will be the matching fCash asset
        if (
            index > 0 &&
            assets[index - 1].currencyId == liquidityToken.currencyId &&
            assets[index - 1].maturity == liquidityToken.maturity &&
            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE
        ) {
            // Net off the fCashClaim here and we will discount it to present value in the second pass.
            // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!
            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);
            return (assetCashClaim, 0);
        }

        // If not matching fCash asset found then get the pv directly
        if (riskAdjusted) {
            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    fCashClaim,
                    liquidityToken.maturity,
                    blockTime,
                    market.oracleRate
                );

            return (assetCashClaim, pv);
        } else {
            int256 pv =
                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);

            return (assetCashClaim, pv);
        }
    }

    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)
    function getNetCashGroupValue(
        PortfolioAsset[] memory assets,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        uint256 blockTime,
        uint256 portfolioIndex
    ) internal view returns (int256, uint256) {
        int256 presentValueAsset;
        int256 presentValueUnderlying;

        // First calculate value of liquidity tokens because we need to net off fCash value
        // before discounting to present value
        for (uint256 i = portfolioIndex; i < assets.length; i++) {
            if (!isLiquidityToken(assets[i].assetType)) continue;
            if (assets[i].currencyId != cashGroup.currencyId) break;

            (int256 assetCashClaim, int256 pv) =
                getLiquidityTokenValue(
                    i,
                    cashGroup,
                    market,
                    assets,
                    blockTime,
                    true // risk adjusted
                );

            presentValueAsset = presentValueAsset.add(assetCashClaim);
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        uint256 j = portfolioIndex;
        for (; j < assets.length; j++) {
            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;
            // If we hit a different currency id then we've accounted for all assets in this currency
            if (assets[j].currencyId != cashGroup.currencyId) break;

            uint256 maturity = assets[j].maturity;
            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);

            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    assets[j].notional,
                    maturity,
                    blockTime,
                    oracleRate
                );
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        presentValueAsset = presentValueAsset.add(
            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)
        );

        return (presentValueAsset, j);
    }
}

",2500,277,"[H-10] Liquidity token value can be manipulated

The liquidity token value (AssetHandler.getLiquidityTokenValue) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash. The amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see `AssetHandler.getCashClaims` / `AssetHandler.getHaircutCashClaims`:
",1,,"pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../../global/Types.sol"";
import ""../../global/Constants.sol"";
import ""../markets/CashGroup.sol"";
import ""../markets/AssetRate.sol"";
import ""../portfolio/PortfolioHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""../../math/ABDKMath64x64.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";

library AssetHandler {
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using CashGroup for CashGroupParameters;
    using AssetRate for AssetRateParameters;

    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {
        return
            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&
            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;
    }

    
    
    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {
        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); 
        
        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;

        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);
        
        
        
        
        return asset.maturity.sub(marketLength).add(Constants.QUARTER);
    }

    
    
    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)
        internal
        pure
        returns (int256)
    {
        int128 expValue =
            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));
        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);
        expValue = ABDKMath64x64.exp(expValue * -1);
        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);
        int256 discountFactor = ABDKMath64x64.toInt(expValue);

        return discountFactor;
    }

    
    function getPresentValue(
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;

        uint256 timeToMaturity = maturity.sub(blockTime);
        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);

        require(discountFactor <= Constants.RATE_PRECISION); 
        return notional.mulInRatePrecision(discountFactor);
    }

    
    
    function getRiskAdjustedPresentValue(
        CashGroupParameters memory cashGroup,
        int256 notional,
        uint256 maturity,
        uint256 blockTime,
        uint256 oracleRate
    ) internal pure returns (int256) {
        if (notional == 0) return 0;
        uint256 timeToMaturity = maturity.sub(blockTime);

        int256 discountFactor;
        if (notional > 0) {
            discountFactor = getDiscountFactor(
                timeToMaturity,
                oracleRate.add(cashGroup.getfCashHaircut())
            );
        } else {
            uint256 debtBuffer = cashGroup.getDebtBuffer();
            
            
            
            if (debtBuffer >= oracleRate) return notional;

            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);
        }

        require(discountFactor <= Constants.RATE_PRECISION); 
        return notional.mulInRatePrecision(discountFactor);
    }

    
    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)
        internal
        pure
        returns (int256 assetCash, int256 fCash)
    {
        require(isLiquidityToken(token.assetType) && token.notional >= 0); 

        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);
        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);
    }

    
    
    function getHaircutCashClaims(
        PortfolioAsset memory token,
        MarketParameters memory market,
        CashGroupParameters memory cashGroup
    ) internal pure returns (int256, int256) {
        require(isLiquidityToken(token.assetType) && token.notional >= 0); 

        require(token.currencyId == cashGroup.currencyId); 
        
        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));

        int256 assetCash =
            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);

        int256 fCash =
            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);

        return (assetCash, fCash);
    }

    
    function _calcToken(
        int256 numerator,
        int256 tokens,
        int256 haircut,
        int256 liquidity
    ) private pure returns (int256) {
        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);
    }

    
    function getLiquidityTokenValue(
        uint256 index,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        PortfolioAsset[] memory assets,
        uint256 blockTime,
        bool riskAdjusted
    ) internal view returns (int256, int256) {
        PortfolioAsset memory liquidityToken = assets[index];
        require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); 

        {
            (uint256 marketIndex, bool idiosyncratic) =
                DateTime.getMarketIndex(
                    cashGroup.maxMarketIndex,
                    liquidityToken.maturity,
                    blockTime
                );
            
            require(!idiosyncratic); 

            
            cashGroup.loadMarket(market, marketIndex, true, blockTime);
        }

        int256 assetCashClaim;
        int256 fCashClaim;
        if (riskAdjusted) {
            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);
        } else {
            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);
        }

        
        
        if (
            index > 0 &&
            assets[index - 1].currencyId == liquidityToken.currencyId &&
            assets[index - 1].maturity == liquidityToken.maturity &&
            assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE
        ) {
            
            
            assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);
            return (assetCashClaim, 0);
        }

        
        if (riskAdjusted) {
            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    fCashClaim,
                    liquidityToken.maturity,
                    blockTime,
                    market.oracleRate
                );

            return (assetCashClaim, pv);
        } else {
            int256 pv =
                getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);

            return (assetCashClaim, pv);
        }
    }

    
    function getNetCashGroupValue(
        PortfolioAsset[] memory assets,
        CashGroupParameters memory cashGroup,
        MarketParameters memory market,
        uint256 blockTime,
        uint256 portfolioIndex
    ) internal view returns (int256, uint256) {
        int256 presentValueAsset;
        int256 presentValueUnderlying;

        
        
        for (uint256 i = portfolioIndex; i < assets.length; i++) {
            if (!isLiquidityToken(assets[i].assetType)) continue;
            if (assets[i].currencyId != cashGroup.currencyId) break;

            (int256 assetCashClaim, int256 pv) =
                getLiquidityTokenValue(
                    i,
                    cashGroup,
                    market,
                    assets,
                    blockTime,
                    true 
                );

            presentValueAsset = presentValueAsset.add(assetCashClaim);
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        uint256 j = portfolioIndex;
        for (; j < assets.length; j++) {
            if (assets[j].assetType != Constants.FCASH_ASSET_TYPE) continue;
            
            if (assets[j].currencyId != cashGroup.currencyId) break;

            uint256 maturity = assets[j].maturity;
            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);

            int256 pv =
                getRiskAdjustedPresentValue(
                    cashGroup,
                    assets[j].notional,
                    maturity,
                    blockTime,
                    oracleRate
                );
            presentValueUnderlying = presentValueUnderlying.add(pv);
        }

        presentValueAsset = presentValueAsset.add(
            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)
        );

        return (presentValueAsset, j);
    }
}",1883,1,0,,"{'ReviewingTheCode': ""The provided code snippet is a Solidity library named 'AssetHandler' that handles various asset-related operations such as liquidity token checks, settlement date calculations, discount factor computations, present value calculations, and cash claims. It leverages several imported libraries and contracts for mathematical operations, asset rate handling, and market parameter management."", 'IdentifyingKeyComponents': {'ContractName': 'AssetHandler', 'Purpose': 'To manage and perform calculations related to assets, particularly liquidity tokens, in a financial or trading context.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['../../global/Types.sol', '../../global/Constants.sol', '../markets/CashGroup.sol', '../markets/AssetRate.sol', '../portfolio/PortfolioHandler.sol', '../../math/SafeInt256.sol', '../../math/ABDKMath64x64.sol', '@openzeppelin/contracts/math/SafeMath.sol']}, 'StateVariables': [], 'FunctionsAndModifiers': [{'Name': 'isLiquidityToken', 'Visibility': 'internal', 'Purpose': 'Checks if a given asset type is a liquidity token.', 'Parameters': ['uint256 assetType'], 'Returns': ['bool']}, {'Name': 'getSettlementDate', 'Visibility': 'internal', 'Purpose': 'Calculates the settlement date for a given asset.', 'Parameters': ['PortfolioAsset memory asset'], 'Returns': ['uint256']}, {'Name': 'getDiscountFactor', 'Visibility': 'internal', 'Purpose': 'Computes the discount factor based on time to maturity and oracle rate.', 'Parameters': ['uint256 timeToMaturity', 'uint256 oracleRate'], 'Returns': ['int256']}, {'Name': 'getPresentValue', 'Visibility': 'internal', 'Purpose': 'Calculates the present value of a notional amount given maturity, block time, and oracle rate.', 'Parameters': ['int256 notional', 'uint256 maturity', 'uint256 blockTime', 'uint256 oracleRate'], 'Returns': ['int256']}, {'Name': 'getRiskAdjustedPresentValue', 'Visibility': 'internal', 'Purpose': 'Calculates the risk-adjusted present value of a notional amount.', 'Parameters': ['CashGroupParameters memory cashGroup', 'int256 notional', 'uint256 maturity', 'uint256 blockTime', 'uint256 oracleRate'], 'Returns': ['int256']}, {'Name': 'getCashClaims', 'Visibility': 'internal', 'Purpose': 'Calculates the asset cash and fCash claims for a given token and market.', 'Parameters': ['PortfolioAsset memory token', 'MarketParameters memory market'], 'Returns': ['int256 assetCash', 'int256 fCash']}, {'Name': 'getHaircutCashClaims', 'Visibility': 'internal', 'Purpose': 'Calculates the haircut-adjusted cash claims for a given token, market, and cash group.', 'Parameters': ['PortfolioAsset memory token', 'MarketParameters memory market', 'CashGroupParameters memory cashGroup'], 'Returns': ['int256', 'int256']}, {'Name': '_calcToken', 'Visibility': 'private', 'Purpose': 'Helper function to calculate token value with a haircut.', 'Parameters': ['int256 numerator', 'int256 tokens', 'int256 haircut', 'int256 liquidity'], 'Returns': ['int256']}, {'Name': 'getLiquidityTokenValue', 'Visibility': 'internal', 'Purpose': 'Calculates the value of a liquidity token, optionally adjusting for risk.', 'Parameters': ['uint256 index', 'CashGroupParameters memory cashGroup', 'MarketParameters memory market', 'PortfolioAsset[] memory assets', 'uint256 blockTime', 'bool riskAdjusted'], 'Returns': ['int256', 'int256']}, {'Name': 'getNetCashGroupValue', 'Visibility': 'internal', 'Purpose': 'Calculates the net value of a cash group based on the provided assets and market parameters.', 'Parameters': ['PortfolioAsset[] memory assets', 'CashGroupParameters memory cashGroup', 'MarketParameters memory market', 'uint256 blockTime', 'uint256 portfolioIndex'], 'Returns': ['int256', 'uint256']}]}, 'ExternalInteractions': ['DateTime.getTradedMarket', 'CashGroup.loadMarket', 'CashGroup.calculateOracleRate'], 'SpecialMechanisms': ['The library uses mathematical operations from ABDKMath64x64 for precise calculations.', 'It employs risk-adjusted calculations for present value and cash claims.', 'The library integrates with market and cash group parameters to fetch and use dynamic data.'], 'Questions': [""What is the purpose of the 'idiosyncratic' check in the 'getLiquidityTokenValue' function?"", ""How is the 'DateTime.getTradedMarket' function implemented and what does it return?"", ""Are there any specific assumptions or constraints on the 'CashGroupParameters' and 'MarketParameters' that need to be validated?"", ""What are the potential risks or edge cases in the 'getRiskAdjustedPresentValue' function when dealing with negative notional values?""]}","{'Findings': [{'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'High', 'Description': 'The code uses arithmetic operations without explicit checks for overflow/underflow, especially in functions involving `int256` and `uint256` operations. SafeMath is imported but not consistently used, leading to potential vulnerabilities.', 'Impact': 'Integer overflow/underflow can result in incorrect calculations, unexpected behavior, financial losses, or exploitation of the contract.', 'Location': 'Multiple functions including `getSettlementDate`, `getDiscountFactor`, `getPresentValue`, `getRiskAdjustedPresentValue`, `_calcToken`, and others where arithmetic operations are performed.'}, {'Issue': 'Potential Division by Zero', 'Severity': 'High', 'Description': 'Division operations are performed without checking if the denominator is zero, particularly in functions like `_calcToken`, `getCashClaims`, and `getDiscountFactor`.', 'Impact': 'Division by zero can cause the contract to revert, leading to transaction failures, denial of service, or financial losses.', 'Location': 'Functions: `_calcToken`, `getCashClaims`, `getDiscountFactor`, and others with division operations.'}, {'Issue': 'Potential Reentrancy', 'Severity': 'High', 'Description': 'Functions like `getLiquidityTokenValue` and `getNetCashGroupValue` interact with external contracts or iterate over arrays without reentrancy protection, which could be exploited if external calls are introduced.', 'Impact': 'Reentrancy attacks could lead to unauthorized state changes, financial losses, or manipulation of contract state.', 'Location': 'Functions: `getLiquidityTokenValue`, `getNetCashGroupValue`, and others with potential external calls.'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'Several functions do not adequately validate input parameters, such as `asset.maturity`, `asset.assetType`, `token.notional`, and `oracleRate`, leading to potential vulnerabilities or incorrect calculations.', 'Impact': 'Invalid inputs could cause unexpected behavior, incorrect calculations, or contract failures.', 'Location': 'Functions: `getSettlementDate`, `getCashClaims`, `getDiscountFactor`, `getHaircutCashClaims`, and others with input parameters.'}, {'Issue': 'Inconsistent Use of SafeMath/SafeInt256', 'Severity': 'Medium', 'Description': 'The code inconsistently uses SafeMath for `uint256` operations and lacks SafeInt256 for `int256` operations, leading to potential vulnerabilities in arithmetic operations.', 'Impact': 'Inconsistent use of safe arithmetic libraries can result in incorrect calculations or vulnerabilities.', 'Location': 'Functions involving `int256` and `uint256` arithmetic operations.'}, {'Issue': 'Insufficient Error Handling', 'Severity': 'Medium', 'Description': 'The code uses minimal `require` statements without detailed error messages, making debugging and incident response difficult.', 'Impact': 'Lack of detailed error messages can complicate debugging and prolong downtime or unresolved issues.', 'Location': 'Multiple functions with `require` statements.'}, {'Issue': 'Division Before Multiplication', 'Severity': 'Low', 'Description': ""Functions like `_calcToken` perform division before multiplication, leading to potential precision loss due to Solidity's integer division."", 'Impact': 'Precision loss could result in incorrect calculations, affecting financial accuracy.', 'Location': 'Functions: `_calcToken` and others with division before multiplication.'}, {'Issue': 'Unbounded Loops', 'Severity': 'Low', 'Description': 'Functions like `getNetCashGroupValue` contain loops iterating over arrays without bounds checking, potentially leading to high gas consumption or out-of-gas errors.', 'Impact': 'Excessive gas consumption could make functions prohibitively expensive or cause transaction failures.', 'Location': 'Functions: `getNetCashGroupValue` and others with unbounded loops.'}, {'Issue': 'Use of Deprecated SafeMath Library', 'Severity': 'Low', 'Description': 'The contract uses the deprecated SafeMath library from OpenZeppelin, which is unnecessary in Solidity 0.8.0 and above due to built-in overflow checks.', 'Impact': 'Potential for confusion or future compatibility issues.', 'Location': 'AssetHandler.sol, using SafeMath for uint256.'}], 'IssueNumber': 14, 'OutputList': 9}",662.8310317993164,"---

**[H-10] Liquidity token value can be manipulated**

**Report Description**:
The liquidity token value (`AssetHandler.getLiquidityTokenValue`) is calculated as the sum of the value of individual claims on cash (underlying or cTokens) and fCash. The amount to redeem for each claim is computed based on the LP token to redeem relative to the total LP tokens, as seen in `AssetHandler.getCashClaims` and `AssetHandler.getHaircutCashClaims`. This calculation could be manipulated if the underlying assumptions or inputs are not properly validated, leading to incorrect token valuations and potential financial losses.

**Match in Response List**:
No direct match found. However, the issue could be partially related to **""Lack of Input Validation""** and **""Potential Reentrancy""** in the response list.

**Validation**:
**Partially Correct**. The response list does not explicitly address the manipulation of liquidity token value. However, the **""Lack of Input Validation""** issue indirectly touches on the problem by highlighting the absence of proper input validation, which could lead to incorrect calculations. Additionally, the **""Potential Reentrancy""** issue mentions the risk of unauthorized state changes, which could also apply if external calls are introduced in the token value calculation process. While these responses do not fully cover the issue, they partially align with the underlying concerns.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-10] Liquidity token value can be manipulated** (related to ""Lack of Input Validation"" and ""Potential Reentrancy"")

**Missed Issues from Issue Report**:
- *None*

---","```
None.
```",0.0
ExchangeRate.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../balances/TokenHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""interfaces/chainlink/AggregatorV2V3Interface.sol"";

library ExchangeRate {
    using SafeInt256 for int256;

    uint256 private constant ETH_RATE_STORAGE_SLOT = 1;

    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are
    /// always applied in this method.
    /// @param er exchange rate object from base to ETH
    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION
    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {
        if (balance == 0) return 0;
        int256 multiplier = balance > 0 ? er.haircut : er.buffer;

        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals
        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)
        // Therefore the result is in ethDecimals
        int256 result =
            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(
                er.rateDecimals
            );

        return result;
    }

    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.
    /// Buffers and haircuts ARE NOT applied in this method.
    /// @param er exchange rate object from base to ETH
    /// @param balance amount (denominated in ETH) to convert
    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {
        if (balance == 0) return 0;

        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals
        // internalDecimals * rateDecimals / rateDecimals
        int256 result = balance.mul(er.rateDecimals).div(er.rate);

        return result;
    }

    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in
    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals
    /// @param baseER base exchange rate struct
    /// @param quoteER quote exchange rate struct
    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)
        internal
        pure
        returns (int256)
    {
        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);
    }

    /// @notice Returns an ETHRate object used to calculate free collateral
    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {
        bytes32 slot = keccak256(abi.encode(currencyId, ETH_RATE_STORAGE_SLOT));
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        int256 rateDecimals;
        int256 rate;
        if (currencyId == Constants.ETH_CURRENCY_ID) {
            // ETH rates will just be 1e18, but will still have buffers, haircuts,
            // and liquidation discounts
            rateDecimals = Constants.ETH_DECIMALS;
            rate = Constants.ETH_DECIMALS;
        } else {
            address rateOracle = address(bytes20(data << 96));
            // prettier-ignore
            (
                /* uint80 */,
                rate,
                /* uint256 */,
                /* uint256 */,
                /* uint80 */
            ) = AggregatorV2V3Interface(rateOracle).latestRoundData();
            require(rate > 0, ""ExchangeRate: invalid rate"");

            uint8 rateDecimalPlaces = uint8(bytes1(data << 88));
            rateDecimals = int256(10**rateDecimalPlaces);
            if (
                bytes1(data << 80) != Constants.BOOL_FALSE /* mustInvert */
            ) {
                rate = rateDecimals.mul(rateDecimals).div(rate);
            }
        }

        int256 buffer = int256(uint8(bytes1(data << 72)));
        int256 haircut = int256(uint8(bytes1(data << 64)));
        int256 liquidationDiscount = int256(uint8(bytes1(data << 56)));
        return
            ETHRate({
                rateDecimals: rateDecimals,
                rate: rate,
                buffer: buffer,
                haircut: haircut,
                liquidationDiscount: liquidationDiscount
            });
    }
}

",958,110,"[M-02] .latestRoundData() does not update the oracle - ExchangeRate.sol

The method .latestRoundData() on an oracle returns the latest updated price from the oracle, but this is not the current price of an asset. To get an accurate current price you need to query it by calling the oracle and waiting for a callback to fulfill the request.
Inaccurate price data could quickly lead to a large loss of funds. Suppose the price of an asset changes downward 5% but your oracle is not updated. A user could deposit funds (credited with an extra 5% since the oracle isn't updated), wait until .latestRoundData() updates (or update it himself) and becomes accurate. He then withdraws to the same asset he put in for an extra 5%. ExchangeRate.sol L84
",1,,"pragma solidity >0.7.0;
pragma experimental ABIEncoderV2;

import ""../balances/TokenHandler.sol"";
import ""../../math/SafeInt256.sol"";
import ""interfaces/chainlink/AggregatorV2V3Interface.sol"";

library ExchangeRate {
    using SafeInt256 for int256;

    uint256 private constant ETH_RATE_STORAGE_SLOT = 1;

    
    
    
    
    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {
        if (balance == 0) return 0;
        int256 multiplier = balance > 0 ? er.haircut : er.buffer;

        
        
        
        int256 result =
            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(
                er.rateDecimals
            );

        return result;
    }

    
    
    
    
    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {
        if (balance == 0) return 0;

        
        
        int256 result = balance.mul(er.rateDecimals).div(er.rate);

        return result;
    }

    
    
    
    
    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)
        internal
        pure
        returns (int256)
    {
        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);
    }

    
    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {
        bytes32 slot = keccak256(abi.encode(currencyId, ETH_RATE_STORAGE_SLOT));
        bytes32 data;

        assembly {
            data := sload(slot)
        }

        int256 rateDecimals;
        int256 rate;
        if (currencyId == Constants.ETH_CURRENCY_ID) {
            
            
            rateDecimals = Constants.ETH_DECIMALS;
            rate = Constants.ETH_DECIMALS;
        } else {
            address rateOracle = address(bytes20(data << 96));
            
            (
                ,
                rate,
                ,
                ,
                
            ) = AggregatorV2V3Interface(rateOracle).latestRoundData();
            require(rate > 0, ""ExchangeRate: invalid rate"");

            uint8 rateDecimalPlaces = uint8(bytes1(data << 88));
            rateDecimals = int256(10**rateDecimalPlaces);
            if (
                bytes1(data << 80) != Constants.BOOL_FALSE 
            ) {
                rate = rateDecimals.mul(rateDecimals).div(rate);
            }
        }

        int256 buffer = int256(uint8(bytes1(data << 72)));
        int256 haircut = int256(uint8(bytes1(data << 64)));
        int256 liquidationDiscount = int256(uint8(bytes1(data << 56)));
        return
            ETHRate({
                rateDecimals: rateDecimals,
                rate: rate,
                buffer: buffer,
                haircut: haircut,
                liquidationDiscount: liquidationDiscount
            });
    }
}",614,0,1,,"{'ReviewingTheCode': 'The provided code snippet is a Solidity library named `ExchangeRate` that facilitates the conversion of balances between different currencies using exchange rates. It leverages external oracles for rate data and applies haircuts or buffers based on the balance direction.', 'IdentifyingKeyComponents': {'ContractName': 'ExchangeRate', 'Purpose': 'To handle currency conversions using exchange rates, applying haircuts or buffers, and fetching rate data from external oracles.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['../balances/TokenHandler.sol', '../../math/SafeInt256.sol', 'interfaces/chainlink/AggregatorV2V3Interface.sol']}, 'StateVariables': [{'Name': 'ETH_RATE_STORAGE_SLOT', 'Type': 'uint256', 'Purpose': 'Storage slot identifier for ETH rate data.'}], 'FunctionsAndModifiers': [{'Name': 'convertToETH', 'Visibility': 'internal', 'Purpose': 'Converts a given balance to ETH using the provided exchange rate, applying a haircut or buffer.', 'Parameters': ['ETHRate memory er', 'int256 balance'], 'Returns': ['int256']}, {'Name': 'convertETHTo', 'Visibility': 'internal', 'Purpose': 'Converts a given ETH balance to another currency using the provided exchange rate.', 'Parameters': ['ETHRate memory er', 'int256 balance'], 'Returns': ['int256']}, {'Name': 'exchangeRate', 'Visibility': 'internal', 'Purpose': 'Calculates the exchange rate between two currencies.', 'Parameters': ['ETHRate memory baseER', 'ETHRate memory quoteER'], 'Returns': ['int256']}, {'Name': 'buildExchangeRate', 'Visibility': 'internal', 'Purpose': 'Constructs an ETHRate object by fetching rate data from an external oracle or using default values for ETH.', 'Parameters': ['uint256 currencyId'], 'Returns': ['ETHRate memory']}]}, 'ExternalInteractions': ['AggregatorV2V3Interface: Used to fetch latest round data from an external oracle for non-ETH currencies.'], 'SpecialMechanisms': ['Storage Slot Hashing: Uses `keccak256` to compute storage slots for rate data.', 'Rate Adjustment: Adjusts rates based on haircuts, buffers, and liquidation discounts.'], 'Questions': ['What are the specific values or ranges for `Constants.PERCENTAGE_DECIMALS`, `Constants.ETH_CURRENCY_ID`, and `Constants.ETH_DECIMALS`?', 'How is the `ETHRate` struct defined, and what are the expected values for its fields (e.g., `rateDecimals`, `rate`, `buffer`, `haircut`, `liquidationDiscount`)?', ""What are the implications of the `require(rate > 0, 'ExchangeRate: invalid rate')` check in `buildExchangeRate`?"", 'Is there any validation for the `rateOracle` address to ensure it points to a valid Chainlink oracle?', 'How are the haircut, buffer, and liquidation discount values determined and applied in the conversion logic?']}","{'Findings': [{'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'High', 'Description': 'The code uses arithmetic operations (multiplication, division) on `int256` values without explicit checks for overflow or underflow. This can lead to unexpected behavior or vulnerabilities, especially when dealing with large numbers or negative values. Although some instances use `SafeInt256`, the protection is not consistent across all operations.', 'Impact': 'Incorrect calculations due to overflow/underflow can result in financial losses or exploitation of the smart contract.', 'Location': 'Functions `convertToETH`, `convertETHTo`, and `exchangeRate` in the ExchangeRate library.'}, {'Issue': 'Unvalidated Oracle Data', 'Severity': 'High', 'Description': 'The `buildExchangeRate` function fetches data from an external oracle (`AggregatorV2V3Interface`) without comprehensive validation. It only checks if `rate > 0`, ignoring other critical fields like `updatedAt` and `answeredInRound`, which could indicate stale or manipulated data.', 'Impact': 'Incorrect or manipulated oracle data can lead to inaccurate exchange rate calculations, potentially causing financial losses or exploitation.', 'Location': 'Function `buildExchangeRate` in the ExchangeRate library.'}, {'Issue': 'Potential Division by Zero', 'Severity': 'High', 'Description': 'The `convertETHTo` and `exchangeRate` functions perform division operations without checking if the divisor (`er.rate` or `quoteER.rate`) is zero. This could cause the transaction to revert, leading to denial of service or other unexpected behavior.', 'Impact': 'Division by zero would cause the transaction to revert, potentially disrupting contract functionality or causing financial losses.', 'Location': 'Functions `convertETHTo` and `exchangeRate` in the ExchangeRate library.'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'The code does not validate inputs such as `currencyId` or oracle data in functions like `buildExchangeRate`, `convertToETH`, and `convertETHTo`. Invalid or malicious inputs could lead to incorrect calculations or runtime errors.', 'Impact': 'Invalid inputs can cause the contract to behave unexpectedly or revert, potentially disrupting intended functionality.', 'Location': 'Functions `buildExchangeRate`, `convertToETH`, and `convertETHTo` in the ExchangeRate library.'}, {'Issue': 'Insufficient Error Handling', 'Severity': 'Medium', 'Description': 'The code lacks comprehensive error handling, particularly in the `buildExchangeRate` function. For example, it does not handle cases where the oracle call fails or returns invalid data, nor does it validate the `rateOracle` address.', 'Impact': 'Poor error handling can lead to unexpected behavior, vulnerabilities, or difficulties in diagnosing issues.', 'Location': 'Function `buildExchangeRate` in the ExchangeRate library.'}, {'Issue': 'Unsafe Assembly Usage', 'Severity': 'Medium', 'Description': ""The `buildExchangeRate` function uses inline assembly (`sload`) to access storage directly. While efficient, this bypasses Solidity's safety checks and increases the risk of errors or unintended side effects."", 'Impact': 'Incorrect use of assembly can lead to storage corruption or unexpected behavior, compromising contract integrity.', 'Location': 'Function `buildExchangeRate` in the ExchangeRate library.'}, {'Issue': 'Potential Reentrancy Risk', 'Severity': 'Medium', 'Description': 'The `buildExchangeRate` function interacts with an external oracle contract. Although the function is `view` and does not modify state, there is a theoretical risk of reentrancy if the oracle behaves maliciously or is compromised.', 'Impact': ""Reentrancy could allow an attacker to manipulate the contract's state or steal funds, though the risk is minimal in this context."", 'Location': 'Function `buildExchangeRate` in the ExchangeRate library.'}, {'Issue': 'Hardcoded Constants and Magic Numbers', 'Severity': 'Low', 'Description': 'The code uses hardcoded values (e.g., `ETH_RATE_STORAGE_SLOT`, `Constants.PERCENTAGE_DECIMALS`) without clear documentation. This reduces code readability and maintainability, increasing the risk of errors during updates.', 'Impact': 'Reduced flexibility and maintainability, potentially leading to errors or inefficiencies in future updates.', 'Location': 'Throughout the ExchangeRate library, particularly in the `buildExchangeRate` function.'}, {'Issue': 'Inconsistent Handling of ETH Currency ID', 'Severity': 'Low', 'Description': 'The `buildExchangeRate` function has special logic for `currencyId == Constants.ETH_CURRENCY_ID`, setting `rateDecimals` and `rate` to `Constants.ETH_DECIMALS`. This inconsistency could lead to confusion or bugs if the logic changes.', 'Impact': 'Potential confusion or bugs in handling ETH-specific logic, though the impact is limited if the logic remains consistent.', 'Location': 'Function `buildExchangeRate` in the ExchangeRate library.'}, {'Issue': 'Use of Experimental Features', 'Severity': 'Low', 'Description': 'The code uses the experimental `ABIEncoderV2` feature, which is not recommended for production due to potential instability or unexpected behavior.', 'Impact': 'Potential instability or unexpected behavior in the contract.', 'Location': 'Pragma directive in the ExchangeRate library.'}], 'IssueNumber': 10, 'OutputList': 10}",476.049525976181,"---

**[M-02] .latestRoundData() does not update the oracle - ExchangeRate.sol**

**Report Description**:
The method `.latestRoundData()` on an oracle returns the latest updated price from the oracle, but this is not the current price of an asset. To get an accurate current price, you need to query the oracle and wait for a callback to fulfill the request. Inaccurate price data could quickly lead to a large loss of funds. For example, if the price of an asset changes downward by 5% but the oracle is not updated, a user could deposit funds (credited with an extra 5% due to the outdated oracle), wait until `.latestRoundData()` updates (or update it themselves), and then withdraw the same asset for an extra 5% profit. This issue is located in `ExchangeRate.sol` at line 84.

**Match in Response List**:
Matches with the issue titled **""Unvalidated Oracle Data""**.

**Validation**:
**Partially Correct**. The response identifies the issue of unvalidated oracle data and correctly highlights the risks of using stale or manipulated data. However, it does not specifically address the problem of `.latestRoundData()` not updating the oracle in real-time, which is the core issue described in the report. The response focuses on general validation of oracle data (e.g., checking `updatedAt` and `answeredInRound`) but misses the critical detail that `.latestRoundData()` does not inherently ensure the oracle is updated before returning a value. This oversight reduces the accuracy of the response in addressing the specific vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-02] .latestRoundData() does not update the oracle - ExchangeRate.sol**

**Missed Issues from Issue Report**:
- *None*

---","```
None.
```",0.0
