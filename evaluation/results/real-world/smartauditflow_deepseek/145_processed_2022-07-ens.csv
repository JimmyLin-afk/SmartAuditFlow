nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NameWrapper.sol,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",7024,963,"[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper
Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in onERC1155Received right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake ERC1155 NameWrapper token for domain, which is not owned by NameWrapper.
  [H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy
By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.
When a parent node tries to `setSubnodeOwner / setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.   [H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node
By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.
However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage ENSRegistry::setSubnodeOwner to re-set himself as the ENS owner of the subdomain, and thus re-invoking the function `wrap` can rewrite the fuses and wrapper owner of the given subdoamin.   [M-01] wrapETH2LD permissioning is over-extended
Current permissioning for the function `wrapETH2LD` allows `msg.senders` who are not owner to call it if they are EITHER approved for all on the ERC721 registrar or approved on the wrapper. Allowing users who are approved for the ERC721 registrar makes sense. By giving them approval, you are giving them approval to do what they wish with the token.   [M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry
There is a general incorrect logic of allowing to burn only `PARENT_CANNOT_CONTROL` fuse without burning `CANNOT_UNWRAP` fuse. If only `PARENT_CANNOT_CONTROL` fuse is burnt, then domain can be unwrapped by its owner and then wrapped again, which clears `PARENT_CANNOT_CONTROL` fuse, making it possible for parent to bypass the limitation of parent control before the expiry.


",5,,"pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    

    

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        
        registrar.transferFrom(registrant, address(this), tokenId);

        
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        
        
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        
        
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",4828,3,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities, especially in functions that interact with external contracts (e.g., `wrapETH2LD`, `unwrapETH2LD`)."",
        ""Verify that all external calls (e.g., to `ENS`, `registrar`, `metadataService`) are properly handled and checked for success."",
        ""Ensure that all arithmetic operations are safe from overflow/underflow, particularly in functions handling expiry times (e.g., `_normaliseExpiry`)."",
        ""Audit the `onERC721Received` function to ensure it correctly handles ERC721 tokens and prevents malicious data injection.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract complies with ERC1155 standards, especially in token wrapping and unwrapping mechanisms."",
        ""Verify that the contract adheres to ERC721 standards in the `onERC721Received` function."",
        ""Ensure that the contract follows OpenZeppelin's `Ownable` and `Controllable` patterns correctly.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the fuse mechanism implementation to ensure it correctly restricts operations based on fuses (e.g., `setFuses`, `operationAllowed`)."",
        ""Analyze the `_normaliseExpiry` function to ensure it correctly normalizes expiry times and prevents invalid states."",
        ""Examine the `_wrapETH2LD` and `_unwrap` functions for logical correctness in handling .eth 2nd level domains.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit all interactions with the `ENS` registry to ensure they are secure and properly authorized."",
        ""Review interactions with the `registrar` contract to ensure proper handling of token transfers and registrations."",
        ""Verify that the `metadataService` is correctly used and that its URIs are securely fetched.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that the `onlyTokenOwner` modifier correctly restricts access to token owners or approved addresses."",
        ""Verify that the `onlyOwner` modifier is used appropriately to restrict critical functions (e.g., `setMetadataService`, `setUpgradeContract`)."",
        ""Check that the `canCallSetSubnodeOwner` modifier correctly enforces permissions for subdomain creation.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, particularly in functions that handle multiple external calls (e.g., `wrapETH2LD`, `unwrapETH2LD`)."",
        ""Review the use of mappings and storage variables to minimize gas costs, especially in functions like `getFuses` and `setFuses`."",
        ""Optimize the `_normaliseExpiry` function to reduce computational overhead.""
      ]
    },
    {
      ""Area"": ""Upgrade Mechanism"",
      ""Tasks"": [
        ""Audit the `upgradeETH2LD` and `upgrade` functions to ensure they securely handle upgrades and prevent unauthorized access."",
        ""Verify that the `upgradeContract` is properly initialized and that its methods are securely called."",
        ""Ensure that the `_prepareUpgrade` function correctly prepares nodes for upgrading without leaving them in an invalid state.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract does not allow the owner to drain funds or tokens inappropriately."",
        ""Verify that all critical functions (e.g., `setMetadataService`, `setUpgradeContract`) have proper safeguards against malicious use.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract has mechanisms to halt operations in case of an emergency, especially in functions that handle token wrapping and unwrapping."",
        ""Verify that the contract can recover from unexpected states, particularly in functions that interact with external contracts.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code is a Solidity smart contract named `NameWrapper`. It is designed to wrap ENS (Ethereum Name Service) names into ERC1155 tokens, allowing for more granular control over subdomains and permissions. The contract interacts with the ENS registry, a registrar, and a metadata service, and it implements various features such as wrapping, unwrapping, setting fuses, and upgrading names."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NameWrapper"",
    ""Purpose"": ""To wrap ENS names into ERC1155 tokens, enabling fine-grained control over subdomains and permissions."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ERC1155Fuse"", ""INameWrapper"", ""Controllable"", ""IERC721Receiver""],
      ""Imports"": [
        ""./ERC1155Fuse.sol"",
        ""./Controllable.sol"",
        ""./INameWrapper.sol"",
        ""./INameWrapperUpgrade.sol"",
        ""./IMetadataService.sol"",
        ""../registry/ENS.sol"",
        ""../ethregistrar/IBaseRegistrar.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""./BytesUtil.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""ens"",
        ""Type"": ""ENS"",
        ""Purpose"": ""The ENS registry contract.""
      },
      {
        ""Name"": ""registrar"",
        ""Type"": ""IBaseRegistrar"",
        ""Purpose"": ""The registrar contract for ENS names.""
      },
      {
        ""Name"": ""metadataService"",
        ""Type"": ""IMetadataService"",
        ""Purpose"": ""The metadata service for token URIs.""
      },
      {
        ""Name"": ""names"",
        ""Type"": ""mapping(bytes32 => bytes)"",
        ""Purpose"": ""Mapping of node hashes to their corresponding names.""
      },
      {
        ""Name"": ""ETH_NODE"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""The node hash for the .eth TLD.""
      },
      {
        ""Name"": ""ROOT_NODE"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""The node hash for the root domain.""
      },
      {
        ""Name"": ""upgradeContract"",
        ""Type"": ""INameWrapperUpgrade"",
        ""Purpose"": ""The contract for upgrading wrapped names.""
      },
      {
        ""Name"": ""MAX_EXPIRY"",
        ""Type"": ""uint64"",
        ""Purpose"": ""The maximum expiry time for a name.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""supportsInterface"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if the contract supports a given interface."",
        ""Parameters"": [""bytes4 interfaceId""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""ownerOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the owner of a given token ID."",
        ""Parameters"": [""uint256 id""],
        ""Returns"": [""address owner""]
      },
      {
        ""Name"": ""setMetadataService"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the metadata service contract."",
        ""Parameters"": [""IMetadataService _newMetadataService""],
        ""Returns"": []
      },
      {
        ""Name"": ""uri"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the URI for a given token ID."",
        ""Parameters"": [""uint256 tokenId""],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""setUpgradeContract"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the upgrade contract for wrapped names."",
        ""Parameters"": [""INameWrapperUpgrade _upgradeAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyTokenOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the caller is the owner of the token."",
        ""Parameters"": [""bytes32 node""],
        ""Returns"": []
      },
      {
        ""Name"": ""isTokenOwnerOrApproved"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if the address is the owner or approved for a token."",
        ""Parameters"": [""bytes32 node"", ""address addr""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""getFuses"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the fuses and expiry for a given node."",
        ""Parameters"": [""bytes32 node""],
        ""Returns"": [""uint32 fuses"", ""uint64 expiry""]
      },
      {
        ""Name"": ""wrapETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Wraps a .eth 2nd level domain into an ERC1155 token."",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""uint32 fuses"", ""uint64 expiry"", ""address resolver""],
        ""Returns"": [""uint64""]
      },
      {
        ""Name"": ""registerAndWrapETH2LD"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Registers and wraps a .eth 2nd level domain."",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""uint256 duration"", ""address resolver"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": [""uint256 registrarExpiry""]
      },
      {
        ""Name"": ""renew"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Renews the registration of a .eth 2nd level domain."",
        ""Parameters"": [""uint256 tokenId"", ""uint256 duration"", ""uint64 expiry""],
        ""Returns"": [""uint256 expires""]
      },
      {
        ""Name"": ""wrap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Wraps an ENS name into an ERC1155 token."",
        ""Parameters"": [""bytes calldata name"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""unwrapETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Unwraps a .eth 2nd level domain."",
        ""Parameters"": [""bytes32 labelhash"", ""address newRegistrant"", ""address newController""],
        ""Returns"": []
      },
      {
        ""Name"": ""unwrap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Unwraps an ENS name."",
        ""Parameters"": [""bytes32 parentNode"", ""bytes32 labelhash"", ""address newController""],
        ""Returns"": []
      },
      {
        ""Name"": ""setFuses"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets fuses for a given node."",
        ""Parameters"": [""bytes32 node"", ""uint32 fuses""],
        ""Returns"": [""uint32""]
      },
      {
        ""Name"": ""upgradeETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Upgrades a .eth 2nd level domain."",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""upgrade"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Upgrades an ENS name."",
        ""Parameters"": [""bytes32 parentNode"", ""string calldata label"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""setChildFuses"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets fuses for a child node."",
        ""Parameters"": [""bytes32 parentNode"", ""bytes32 labelhash"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""setSubnodeOwner"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the owner of a subnode."",
        ""Parameters"": [""bytes32 parentNode"", ""string calldata label"", ""address newOwner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": [""bytes32 node""]
      },
      {
        ""Name"": ""setSubnodeRecord"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the record for a subnode."",
        ""Parameters"": [""bytes32 parentNode"", ""string memory label"", ""address newOwner"", ""address resolver"", ""uint64 ttl"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""setRecord"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the record for a node."",
        ""Parameters"": [""bytes32 node"", ""address owner"", ""address resolver"", ""uint64 ttl""],
        ""Returns"": []
      },
      {
        ""Name"": ""setResolver"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the resolver for a node."",
        ""Parameters"": [""bytes32 node"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTTL"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the TTL for a node."",
        ""Parameters"": [""bytes32 node"", ""uint64 ttl""],
        ""Returns"": []
      },
      {
        ""Name"": ""operationAllowed"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the operation is allowed based on fuses."",
        ""Parameters"": [""bytes32 node"", ""uint32 fuseMask""],
        ""Returns"": []
      },
      {
        ""Name"": ""canCallSetSubnodeOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the caller can set the owner of a subnode."",
        ""Parameters"": [""bytes32 node"", ""bytes32 labelhash""],
        ""Returns"": []
      },
      {
        ""Name"": ""allFusesBurned"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if all specified fuses are burned."",
        ""Parameters"": [""bytes32 node"", ""uint32 fuseMask""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""onERC721Received"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Handles the receipt of an ERC721 token."",
        ""Parameters"": [""address to"", ""address"", ""uint256 tokenId"", ""bytes calldata data""],
        ""Returns"": [""bytes4""]
      },
      {
        ""Name"": ""_canTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if a token can be transferred."",
        ""Parameters"": [""uint32 fuses""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_makeNode"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Creates a node hash from a parent node and labelhash."",
        ""Parameters"": [""bytes32 node"", ""bytes32 labelhash""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""_addLabel"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Adds a label to a name."",
        ""Parameters"": [""string memory label"", ""bytes memory name""],
        ""Returns"": [""bytes memory ret""]
      },
      {
        ""Name"": ""_mint"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Mints a new token."",
        ""Parameters"": [""bytes32 node"", ""address wrappedOwner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""_wrap"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Wraps a name into a token."",
        ""Parameters"": [""bytes32 node"", ""bytes memory name"", ""address wrappedOwner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""_addLabelAndWrap"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Adds a label and wraps the name into a token."",
        ""Parameters"": [""bytes32 parentNode"", ""bytes32 node"", ""string memory label"", ""address newOwner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""_prepareUpgrade"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Prepares a node for upgrading."",
        ""Parameters"": [""bytes32 node""],
        ""Returns"": [""uint32 fuses"", ""uint64 expiry""]
      },
      {
        ""Name"": ""_transferAndBurnFuses"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers a token and burns fuses."",
        ""Parameters"": [""bytes32 node"", ""address newOwner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""_getDataAndNormaliseExpiry"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Gets data and normalises the expiry."",
        ""Parameters"": [""bytes32 parentNode"", ""bytes32 node"", ""uint64 expiry""],
        ""Returns"": [""address owner"", ""uint32 fuses"", ""uint64""]
      },
      {
        ""Name"": ""_getETH2LDDataAndNormaliseExpiry"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Gets data and normalises the expiry for .eth 2nd level domains."",
        ""Parameters"": [""bytes32 node"", ""bytes32 labelhash"", ""uint64 expiry""],
        ""Returns"": [""address owner"", ""uint32 fuses"", ""uint64""]
      },
      {
        ""Name"": ""_normaliseExpiry"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Normalises the expiry time."",
        ""Parameters"": [""uint64 expiry"", ""uint64 oldExpiry"", ""uint64 maxExpiry""],
        ""Returns"": [""uint64""]
      },
      {
        ""Name"": ""_wrapETH2LD"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Wraps a .eth 2nd level domain into a token."",
        ""Parameters"": [""string memory label"", ""address wrappedOwner"", ""uint32 fuses"", ""uint64 expiry"", ""address resolver""],
        ""Returns"": [""uint64""]
      },
      {
        ""Name"": ""_unwrap"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Unwraps a token."",
        ""Parameters"": [""bytes32 node"", ""address newOwner""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setFuses"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sets fuses for a node."",
        ""Parameters"": [""bytes32 node"", ""address owner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setData"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sets data for a node."",
        ""Parameters"": [""bytes32 node"", ""address owner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""_canFusesBeBurned"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if fuses can be burned."",
        ""Parameters"": [""bytes32 node"", ""uint32 fuses""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ENS registry"",
    ""IBaseRegistrar"",
    ""IMetadataService"",
    ""INameWrapperUpgrade"",
    ""ERC721 tokens (via IERC721Receiver)""
  ],
  ""SpecialMechanisms"": [
    ""ERC1155 token wrapping for ENS names"",
    ""Fuse mechanism for controlling permissions"",
    ""Upgrade mechanism for wrapped names"",
    ""Subdomain control and record management""
  ],
  ""Questions"": [
    ""How are the fuses implemented and what are their specific roles?"",
    ""What is the purpose of the `_normaliseExpiry` function and how does it ensure correctness?"",
    ""How does the `onERC721Received` function handle ERC721 tokens and what are the implications?"",
    ""What are the specific conditions under which a name can be unwrapped?"",
    ""How does the upgrade mechanism work and what are the security implications?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in `wrapETH2LD` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `wrapETH2LD` function transfers ownership of a token from the registrant to the contract, potentially allowing reentrancy attacks if the `registrar` contract is malicious or compromised. This could lead to state manipulation or token theft."",
      ""Impact"": ""An attacker could manipulate the state of the contract or steal tokens by re-entering the function before the state is updated."",
      ""Location"": ""Function `wrapETH2LD`""
    },
    {
      ""Issue"": ""Unauthorized Token Transfer"",
      ""Severity"": ""High"",
      ""Description"": ""The `wrapETH2LD` function transfers a token from the registrant to the contract without ensuring that the registrant has approved the transfer, potentially allowing unauthorized transfers."",
      ""Impact"": ""Potential loss of tokens to unauthorized parties."",
      ""Location"": ""wrapETH2LD function""
    },
    {
      ""Issue"": ""Incorrect Token Type Check in `onERC721Received`"",
      ""Severity"": ""High"",
      ""Description"": ""The `onERC721Received` function checks if the sender is the `registrar` contract but does not verify the token type, potentially allowing malicious contracts to send arbitrary tokens."",
      ""Impact"": ""Potential for token loss or contract malfunction due to incorrect token handling."",
      ""Location"": ""Function: `onERC721Received`""
    },
    {
      ""Issue"": ""Unauthorized Access via `onlyTokenOwner` Modifier"",
      ""Severity"": ""High"",
      ""Description"": ""The `onlyTokenOwner` modifier can be bypassed if the caller is approved for all tokens of the owner, leading to unauthorized access to protected functions."",
      ""Impact"": ""An attacker could manipulate or transfer tokens they do not own, leading to loss of assets or unauthorized changes to the ENS records."",
      ""Location"": ""Modifier `onlyTokenOwner` and functions using it like `unwrapETH2LD`, `unwrap`, `setFuses`, etc.""
    },
    {
      ""Issue"": ""Unrestricted Token Burning"",
      ""Severity"": ""High"",
      ""Description"": ""The `_prepareUpgrade` function allows any token owner or approved address to burn tokens without additional checks, potentially leading to malicious burning."",
      ""Impact"": ""Potential loss of tokens due to malicious burning."",
      ""Location"": ""_prepareUpgrade function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `wrapETH2LD`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `wrapETH2LD` function does not validate the length or format of the `label` parameter, potentially leading to unexpected behavior or vulnerabilities."",
      ""Impact"": ""Invalid labels could be wrapped, leading to inconsistencies or vulnerabilities in the ENS system."",
      ""Location"": ""wrapETH2LD function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `_addLabel`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_addLabel` function does not validate the input label beyond checking its length, potentially leading to unexpected behavior if the label contains invalid characters."",
      ""Impact"": ""Invalid labels could cause issues when interacting with the ENS registry or other parts of the system."",
      ""Location"": ""_addLabel function""
    },
    {
      ""Issue"": ""Unrestricted Fuse Burning in `_setFuses`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_setFuses` function allows setting fuses without proper validation, potentially leading to unintended restrictions or permissions."",
      ""Impact"": ""Unauthorized fuse burning could disrupt the normal operation of the contract or lead to unexpected behavior."",
      ""Location"": ""_setFuses function""
    },
    {
      ""Issue"": ""Incorrect Expiry Handling in `_normaliseExpiry`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_normaliseExpiry` function does not handle cases where the `expiry` parameter is zero or invalid, potentially leading to incorrect expiry values."",
      ""Impact"": ""Incorrect expiry handling could lead to domains being active longer than intended or expiring prematurely."",
      ""Location"": ""_normaliseExpiry function""
    },
    {
      ""Issue"": ""Missing Access Control on `setMetadataService`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setMetadataService` function allows the owner to change the metadata service address without ensuring the new address is valid or secure."",
      ""Impact"": ""Potential exposure to malicious metadata services, leading to incorrect or harmful metadata being returned."",
      ""Location"": ""setMetadataService function""
    },
    {
      ""Issue"": ""Potential Denial of Service in `onERC721Received`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `onERC721Received` function could revert if the `data` parameter is malformed or too large, potentially leading to a denial of service."",
      ""Impact"": ""An attacker could cause the function to revert, preventing legitimate transactions from being processed."",
      ""Location"": ""Function `onERC721Received`""
    },
    {
      ""Issue"": ""Incorrect Fuse Handling in `_canFusesBeBurned`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_canFusesBeBurned` function does not account for all possible combinations of fuses, potentially leading to incorrect fuse settings."",
      ""Impact"": ""Tokens could be incorrectly configured, leading to unauthorized transfers or changes to the ENS records."",
      ""Location"": ""Function `_canFusesBeBurned`""
    },
    {
      ""Issue"": ""Lack of Event Emission in `_wrapETH2LD`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_wrapETH2LD` function does not emit an event when the resolver is set, reducing transparency and traceability."",
      ""Impact"": ""Reduced transparency and traceability of resolver address changes."",
      ""Location"": ""_wrapETH2LD function""
    },
    {
      ""Issue"": ""Unchecked Return Value in `registrar.transferFrom`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `registrar.transferFrom` function is called without checking the return value, potentially leading to inconsistent contract state if the transfer fails."",
      ""Impact"": ""If the transfer fails, the contract state may be inconsistent, potentially leading to incorrect behavior."",
      ""Location"": ""Functions `wrapETH2LD`, `unwrapETH2LD`""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `_normaliseExpiry`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_normaliseExpiry` function performs arithmetic operations on `uint64` values without checking for overflow, potentially leading to incorrect expiry values."",
      ""Impact"": ""Incorrect expiry values could lead to unexpected behavior in the contract."",
      ""Location"": ""Function `_normaliseExpiry`""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 15
}",492.53722286224365,127270.0,24.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**

**Report Description**:
The issue arises due to a reentrancy possibility in `NameWrapper._transferAndBurnFuses`, which is called from `setSubnodeOwner` and `setSubnodeRecord`. An attacker can exploit the `onERC1155Received` callback to perform actions right after the transfer but before the new owner and fuses are set. This allows the creation of a fake ERC1155 NameWrapper token for a subdomain that is not owned by NameWrapper, leading to potential misuse or unauthorized control of the subdomain.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific reentrancy vulnerability in `NameWrapper._transferAndBurnFuses` or the creation of fake ERC1155 tokens. This issue is entirely missed in the response list.

---

#### **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**

**Report Description**:
By design, the child node's expiry should only be extended up to the parent's current expiry. However, the current implementation does not enforce this restriction, allowing the child node's expiry to exceed the parent's expiry. This violates the guarantee policy and could lead to inconsistencies in the ENS system, as users may not be able to rely on the expiry hierarchy for domain guarantees.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect expiry handling in the parent-child node relationship. This issue is entirely missed in the response list.

---

#### **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**

**Report Description**:
The `PARENT_CANNOT_CONTROL` fuse is designed to prevent a parent node from controlling a subdomain. However, this constraint can be bypassed if the parent node is maliciously unwrapped. An attacker who becomes the ENS owner of the parent node can use `ENSRegistry::setSubnodeOwner` to reset themselves as the ENS owner of the subdomain, allowing them to re-invoke the `wrap` function and rewrite the fuses and wrapper owner of the subdomain, effectively bypassing the `PARENT_CANNOT_CONTROL` restriction.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the bypass of the `PARENT_CANNOT_CONTROL` fuse through malicious unwrapping of the parent node. This issue is entirely missed in the response list.

---

#### **[M-01] `wrapETH2LD` permissioning is over-extended**

**Report Description**:
The `wrapETH2LD` function allows `msg.senders` who are not the owner to call it if they are either approved for all on the ERC721 registrar or approved on the wrapper. While allowing users approved for the ERC721 registrar makes sense, extending this permission to users approved on the wrapper is over-extended and could lead to unauthorized actions.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the over-extended permissioning in the `wrapETH2LD` function. This issue is entirely missed in the response list.

---

#### **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry**

**Report Description**:
The logic of allowing only the `PARENT_CANNOT_CONTROL` fuse to be burnt without burning the `CANNOT_UNWRAP` fuse is incorrect. If only `PARENT_CANNOT_CONTROL` is burnt, the domain can be unwrapped by its owner and then wrapped again, which clears the `PARENT_CANNOT_CONTROL` fuse. This allows the parent to bypass the limitation of parent control before the expiry, leading to potential unauthorized control of the subdomain.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the incorrect logic of allowing only the `PARENT_CANNOT_CONTROL` fuse to be burnt without burning the `CANNOT_UNWRAP` fuse. This issue is entirely missed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**
- **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**
- **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**
- **[M-01] `wrapETH2LD` permissioning is over-extended**
- **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry**

---

### **Conclusion**
The response list does not adequately address the issues raised in the issue report. None of the issues are correctly or partially matched, and all are entirely missed. This indicates a significant gap in the coverage, accuracy, and sufficiency of the responses provided.","```
None.
```",0.0
ByteUtil.sol,"pragma solidity ^0.8.4;

library BytesUtils {
    /*
    * @dev Returns the keccak-256 hash of a byte range.
    * @param self The byte string to hash.
    * @param offset The position to start hashing at.
    * @param len The number of bytes to hash.
    * @return The hash of the byte range.
    */
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal.
    * @param self The first bytes to compare.
    * @param other The second bytes to compare.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal. Comparison is done per-rune,
    *      on unicode codepoints.
    * @param self The first bytes to compare.
    * @param offset The offset of self.
    * @param len    The length of self.
    * @param other The second bytes to compare.
    * @param otheroffset The offset of the other string.
    * @param otherlen    The length of the other string.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                // Mask out irrelevant bytes and check again
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @param len The number of bytes to compare
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    /*
    * @dev Returns true if the two byte ranges are equal with offsets.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    /*
    * @dev Compares a range of 'self' to all of 'other' and returns True iff
    *      they are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    /*
    * @dev Returns the 8-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 8 bits of the string, interpreted as an integer.
    */
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    /*
    * @dev Returns the 16-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 16 bits of the string, interpreted as an integer.
    */
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    /*
    * @dev Returns the 32-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bits of the string, interpreted as an integer.
    */
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    /*
    * @dev Returns the n byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes.
    * @param len The number of bytes.
    * @return The specified 32 bytes of the string.
    */
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        // Copy word-length chunks while possible
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        // Copy remaining bytes
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    /*
    * @dev Copies a substring into a new byte string.
    * @param self The byte string to copy from.
    * @param offset The offset to start copying at.
    * @param len The number of bytes to copy.
    */
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    // Maps characters from 0x30 to 0x7A to their base32 values.
    // 0xFF represents invalid characters in that range.
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    /**
     * @dev Decodes unpadded base32 data of up to one word in length.
     * @param self The data to decode.
     * @param off Offset into the string to start at.
     * @param len Number of characters to decode.
     * @return The decoded data, left aligned.
     */
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            // Multiple of 8 characters, no padding
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            // Two extra characters - 1 byte
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            // Four extra characters - 2 bytes
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            // Five extra characters - 3 bytes
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            // Seven extra characters - 4 bytes
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    /**
     * @dev Finds the first occurrence of the byte `needle` in `self`.
     * @param self The string to search
     * @param off The offset to start searching at 
     * @param len The number of bytes to search
     * @param needle The byte to search for
     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.
     */
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",2905,320,"[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters
Due to incorrect condition in `ByteUtil.compare` function, irrelevant characters are masked out only for strings shorter than 32 characters. However, they must be masked out for strings of all lengths in the last pass of the loop (when remainder of the string is 32 characters or less). This leads to incorrect comparision of strings longer than 32 characters where len or otherlen is smaller than string length (characters beyond provided length are still accounted for in the comparision in this case while they should be ignored).
  [M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths
Compare will return false answer without reverting when the inputs are not valid.
  [M-08] Wrong Equals Logic
The function `equals` with offset might return true when equals without offset returns false.
",3,,"pragma solidity ^0.8.4;

library BytesUtils {
    
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    
    
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",1636,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify that all require statements are correctly used to prevent out-of-bounds access and invalid inputs."",
        ""Check for potential integer overflows/underflows in functions like `compare`, `readUint16`, `readUint32`, and `base32HexDecodeWord`."",
        ""Ensure that the `memcpy` function does not allow for memory corruption or overwrite unintended memory areas."",
        ""Review the `base32HexDecodeWord` function for proper handling of invalid characters and edge cases.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Analyze the `compare` function to ensure it correctly handles cases where the shortest byte array is less than 32 bytes."",
        ""Review the `base32HexDecodeWord` function to confirm it correctly decodes base32 hex encoded data, especially for non-standard lengths."",
        ""Examine the `memcpy` function to ensure it handles partial word copies correctly and efficiently.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Evaluate the gas efficiency of the `keccak` function, especially for large byte arrays."",
        ""Optimize the `compare` function to reduce gas consumption by minimizing unnecessary operations."",
        ""Assess the gas usage of the `base32HexDecodeWord` function and identify potential optimizations.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Confirm that the library does not interact with external contracts or make external calls, as it is designed to be pure.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that all functions are marked as `internal` or `private` to prevent unauthorized access.""
      ]
    },
    {
      ""Area"": ""Special Mechanisms"",
      ""Tasks"": [
        ""Review the use of inline assembly in functions like `keccak`, `readUint16`, and `readUint32` to ensure they are safe and correct."",
        ""Verify that the `base32HexTable` lookup table is correctly used in the `base32HexDecodeWord` function.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Ensure that the library adheres to Solidity best practices and does not introduce any non-standard behavior.""
      ]
    },
    {
      ""Area"": ""Edge Cases"",
      ""Tasks"": [
        ""Test the `equals` function with various edge cases, including empty byte arrays and arrays of different lengths."",
        ""Verify that the `substring` function correctly handles cases where the offset and len parameters are at the boundaries of the byte array.""
      ]
    }
  ]
}

### Prioritization and Refinement:
- **Security Vulnerabilities** and **Complex Logic/Algorithms** should be prioritized as they directly impact the safety and correctness of the library.
- **Gas Optimization** is important for ensuring the library is efficient, especially when used in larger contracts or on-chain operations.
- **Special Mechanisms** and **Edge Cases** should be reviewed to ensure the library handles all scenarios correctly and safely.
- **Compliance**, **Access Control**, and **External Interactions** are less critical for this library but should still be reviewed to ensure best practices are followed.

This task list provides a comprehensive approach to auditing the `BytesUtils` library, ensuring that all potential issues are addressed systematically.","{
  ""ReviewingTheCode"": ""The provided code is a Solidity library named 'BytesUtils' that offers utility functions for manipulating and comparing byte arrays. It includes functions for hashing, comparing, reading, and extracting substrings from byte arrays, as well as decoding base32 hex encoded data. The library is designed to be pure, meaning it does not modify the state and relies solely on its input parameters."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BytesUtils"",
    ""Purpose"": ""To provide utility functions for manipulating and comparing byte arrays, including hashing, reading specific data types, and decoding base32 hex encoded data."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [],
      ""Imports"": []
    },
    ""StateVariables"": [
      {
        ""Name"": ""base32HexTable"",
        ""Type"": ""bytes"",
        ""Purpose"": ""A constant lookup table for base32 hex decoding.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""keccak"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Computes the Keccak-256 hash of a specified segment of a byte array."",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""uint len""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""compare"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Compares two byte arrays or segments of byte arrays."",
        ""Parameters"": [""bytes memory self"", ""bytes memory other""],
        ""Returns"": [""int""]
      },
      {
        ""Name"": ""equals"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if two byte arrays or segments of byte arrays are equal."",
        ""Parameters"": [""bytes memory self"", ""bytes memory other""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""readUint8"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint8 value from a byte array at a specified index."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint8 ret""]
      },
      {
        ""Name"": ""readUint16"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint16 value from a byte array at a specified index."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint16 ret""]
      },
      {
        ""Name"": ""readUint32"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint32 value from a byte array at a specified index."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint32 ret""]
      },
      {
        ""Name"": ""readBytes32"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a bytes32 value from a byte array at a specified index."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""readBytes20"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a bytes20 value from a byte array at a specified index."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""bytes20 ret""]
      },
      {
        ""Name"": ""readBytesN"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a bytesN value from a byte array at a specified index and length."",
        ""Parameters"": [""bytes memory self"", ""uint idx"", ""uint len""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""memcpy"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Copies memory from one location to another."",
        ""Parameters"": [""uint dest"", ""uint src"", ""uint len""],
        ""Returns"": []
      },
      {
        ""Name"": ""substring"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Extracts a substring from a byte array."",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""uint len""],
        ""Returns"": [""bytes memory""]
      },
      {
        ""Name"": ""base32HexDecodeWord"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Decodes a base32 hex encoded word into bytes32."",
        ""Parameters"": [""bytes memory self"", ""uint off"", ""uint len""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""find"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Finds the index of a specific byte in a byte array."",
        ""Parameters"": [""bytes memory self"", ""uint256 off"", ""uint256 len"", ""bytes1 needle""],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [],
  ""SpecialMechanisms"": [
    ""The library uses inline assembly for low-level memory operations, such as hashing and reading specific data types from byte arrays."",
    ""It includes a base32 hex decoding function that uses a lookup table for efficient decoding.""
  ],
  ""Questions"": [
    ""What is the intended use case for the base32HexDecodeWord function, and how does it handle invalid characters?"",
    ""Are there any specific performance considerations for the memcpy function, especially for large len values?"",
    ""How does the compare function handle cases where the shortest byte array is less than 32 bytes?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Buffer Overflow in `keccak` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `keccak` function lacks bounds checking on `offset` and `len` parameters, potentially leading to buffer overflow if `offset + len` exceeds the array length. This could result in reading out-of-bounds memory."",
      ""Impact"": ""Buffer overflow could lead to undefined behavior, data corruption, or arbitrary code execution."",
      ""Location"": ""BytesUtils library, `keccak` function""
    },
    {
      ""Issue"": ""Potential Buffer Overflow in `memcpy` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `memcpy` function does not check for overlapping memory regions or integer overflow when adjusting pointers, which could lead to buffer overflow or data corruption."",
      ""Impact"": ""Buffer overflow or data corruption could lead to undefined behavior or security vulnerabilities."",
      ""Location"": ""BytesUtils library, `memcpy` function""
    },
    {
      ""Issue"": ""Unchecked Array Bounds in `readUint8` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `readUint8` function does not validate if `idx` is within the bounds of the `self` array, potentially leading to out-of-bounds memory access."",
      ""Impact"": ""Out-of-bounds access could result in information disclosure or other security issues."",
      ""Location"": ""BytesUtils library, `readUint8` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow in Multiple Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `readUint16`, `readUint32`, `readBytesN`, `substring`, and `find` do not check for integer overflow when calculating memory offsets, which could lead to incorrect memory access."",
      ""Impact"": ""Incorrect memory access could result in undefined behavior or vulnerabilities."",
      ""Location"": ""Functions: `readUint16`, `readUint32`, `readBytesN`, `substring`, `find`""
    },
    {
      ""Issue"": ""Insufficient Input Validation in `base32HexDecodeWord` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `base32HexDecodeWord` function does not fully validate input characters, potentially allowing invalid base32 characters to cause decoding errors or unexpected behavior."",
      ""Impact"": ""Invalid input could lead to incorrect decoding or runtime errors."",
      ""Location"": ""BytesUtils library, `base32HexDecodeWord` function""
    },
    {
      ""Issue"": ""Incorrect Mask Calculation in `compare` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `compare` function incorrectly calculates masks for byte arrays of varying lengths, potentially leading to incorrect comparison results."",
      ""Impact"": ""Incorrect comparisons could cause logical errors in the contract."",
      ""Location"": ""BytesUtils library, `compare` function""
    },
    {
      ""Issue"": ""Potential Reentrancy in Multiple Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `memcpy`, `keccak`, and `find` use inline assembly or iterative patterns that could pose reentrancy risks if used in state-modifying contexts."",
      ""Impact"": ""Reentrancy could lead to unexpected behavior or vulnerabilities in certain contexts."",
      ""Location"": ""Functions: `memcpy`, `keccak`, `find`""
    },
    {
      ""Issue"": ""Inconsistent Error Handling in `find` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `find` function returns `type(uint256).max` when the `needle` is not found, which could be confusing or lead to issues if not properly checked by the caller."",
      ""Impact"": ""Improper handling of the return value could cause logical errors."",
      ""Location"": ""BytesUtils library, `find` function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `find` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `find` function does not validate `off` and `len` parameters, potentially leading to out-of-bounds access if not properly managed."",
      ""Impact"": ""Out-of-bounds access could result in undefined behavior."",
      ""Location"": ""BytesUtils library, `find` function""
    }
  ],
  ""IssueNumber"": 38,
  ""OutputList"": 9
}",369.1342601776123,52517.0,24.0,"### **Comparison of Issues and Responses**

---

#### **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**

**Report Description**:  
The `ByteUtil.compare` function incorrectly masks irrelevant characters only for strings shorter than 32 characters. For strings longer than 32 characters, characters beyond the provided length are still accounted for in the comparison, leading to incorrect results. This issue arises when `len` or `otherlen` is smaller than the string length.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Mask Calculation in `compare` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with incorrect mask calculation in the `compare` function. It correctly explains the potential for incorrect comparison results, which aligns with the reported issue.

---

#### **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**

**Report Description**:  
The `compare` function does not revert when the `offset` and `len` parameters exceed the length of the input bytes. Instead, it returns a false answer, which could lead to incorrect behavior if the inputs are not validated.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of invalid inputs (`offset` and `len`) in the `compare` function. This is a critical oversight, as it could lead to incorrect comparisons without proper error handling.

---

#### **[M-08] Wrong Equals Logic**

**Report Description**:  
The `equals` function with an offset might return `true` when the `equals` function without an offset returns `false`. This inconsistency in logic could lead to incorrect equality checks.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of inconsistent logic in the `equals` function. This is a significant oversight, as it could lead to incorrect equality checks and logical errors in the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**
- **[M-08] Wrong Equals Logic**

---

### **Conclusion**

The response list partially addresses the issues in the `BytesUtils` library, particularly the incorrect mask calculation in the `compare` function. However, it fails to address critical issues such as the lack of input validation in the `compare` function and the inconsistent logic in the `equals` function. These gaps highlight the need for more comprehensive coverage of vulnerabilities in the `BytesUtils` library.","```
1. Incorrect Mask Calculation in `compare` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Mask Calculation in `compare` Function"".
   - From the ranked predictions, this issue appears at rank 6.

2. **Calculate the precision at rank 6 (\( P@6 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 6, \( P@6 = \frac{1}{6} \approx 0.1667 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.1667 \).

**Output**:
```
0.1667
```"
