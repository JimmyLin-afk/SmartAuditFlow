nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
IdleYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; 
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./interfaces/idle/IIdleTokenHelper.sol"";
import ""./access/AssetManager.sol"";

/// @title An pooltogether yield source for Idle token
/// @author Sunny Radadiya
contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public totalUnderlyingAssets;

    /// @notice Emitted when the yield source is initialized
    event IdleYieldSourceInitialized(address indexed idleToken);

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    /// @notice Emitted when ERC20 tokens other than yield source's idleToken are withdrawn from the yield source
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    /// @notice Initializes the yield source with Idle Token
    /// @param _idleToken Idle Token address
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() external view override returns (address) {
        return (underlyingAsset);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Calculates the balance of Total idle Tokens Contract hasv
    /// @return balance of Idle Tokens
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    /// @notice Calculates the number of shares that should be mint or burned when a user deposit or withdraw
    /// @param tokens Amount of tokens
    /// return Number of shares
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(_totalShare() == 0) {
            shares = tokens;
        } else {
            shares = (tokens * _totalShare())  / totalUnderlyingAssets;
        }
    }

    /// @notice Calculates the number of tokens a user has in the yield source
    /// @param shares Amount of shares
    /// return Number of tokens
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        if(_totalShare() == 0) {
            tokens = shares;
        } else {
            tokens = (shares * totalUnderlyingAssets) / _totalShare();
        }
    }

    /// @notice Deposit asset tokens to Idle
    /// @param mintAmount The amount of asset tokens to be deposited
    /// @return 0 if successful 
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
        return mintedTokens;
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param mintAmount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {
        uint256 mintedTokenShares = _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    /// @notice Redeems tokens from the yield source from the msg.sender, it burn yield bearing tokens and return token to the sender.
    /// @param redeemAmount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {
        uint256 _idleShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, _idleShare);
        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;
        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);
        return redeemedUnderlyingAsset;
    }

    /// @notice Transfer ERC20 tokens other than the idleTokens held by this contract to the recipient address
    /// @dev This function is only callable by the owner or asset manager
    /// @param erc20Token The ERC20 token to transfer
    /// @param to The recipient of the tokens
    /// @param amount The amount of tokens to transfer
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(address(erc20Token) != address(idleToken), ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1555,160,"[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource
The `redeemToken` function in IdleYieldSource uses redeemedShare instead of redeemAmount as the input parameter when calling redeemIdleToken of the Idle yield source. As a result, users could get fewer underlying tokens than they should.
When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the tokenPriceWithFee() is greater than ONE_IDLE_TOKEN, and thus redeemedShare is less than redeemAmount, causing users to get fewer underlying tokens than expected.
 [H-05] IdleYieldSource doesn't use mantissa calculations
Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.
For example, say I deposit 1 token, expecting 1 share in return. On L95, if the totalUnderlyingAssets is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.
Recommend implementing mantissa calculations like in the contract for the AAVE yield.
  [M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits
Function `timelockDepositTo` The contract uses _msgSender() to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be.
While the code handles this separation of role in most cases, it misses doing so in timelockDepositTo() function where it accounts the _timelockBalances to the operator address instead of the user specified to address. It assumes they are the same. The corresponding usage in _mintTimelock() which is called from withdrawWithTimelockFrom() uses the user specified 'from' address and not the _msgSender(). Therefore the corresponding usage in timelockDepositTo() should be the same.
In the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operator’s address does not have the required amount of _timelockBalances.
",3,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; 
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./interfaces/idle/IIdleTokenHelper.sol"";
import ""./access/AssetManager.sol"";



contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public totalUnderlyingAssets;

    
    event IdleYieldSourceInitialized(address indexed idleToken);

    
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    
    
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    
    
    function depositToken() external view override returns (address) {
        return (underlyingAsset);
    }

    
    
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    
    
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    
    
    
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(_totalShare() == 0) {
            shares = tokens;
        } else {
            shares = (tokens * _totalShare())  / totalUnderlyingAssets;
        }
    }

    
    
    
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        if(_totalShare() == 0) {
            tokens = shares;
        } else {
            tokens = (shares * totalUnderlyingAssets) / _totalShare();
        }
    }

    
    
    
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
        return mintedTokens;
    }

    
    
    
    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {
        uint256 mintedTokenShares = _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    
    
    
    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {
        uint256 _idleShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, _idleShare);
        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;
        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);
        return redeemedUnderlyingAsset;
    }

    
    
    
    
    
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(address(erc20Token) != address(idleToken), ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    
    
    
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1010,2,1,,"{'ReviewingTheCode': ""The contract `IdleYieldSource` is a Solidity smart contract that interacts with the Idle Finance protocol to manage yield generation and token supply. It leverages OpenZeppelin's upgradeable contracts for ERC20 tokens, reentrancy protection, and initialization. The contract allows users to deposit, redeem, and sponsor tokens while managing underlying assets and shares."", 'IdentifyingKeyComponents': {'ContractName': 'IdleYieldSource', 'Purpose': ""To act as a yield source for the PoolTogether protocol by managing deposits, redemptions, and yield generation using Idle Finance's idle tokens."", 'InheritanceAndImports': {'InheritsFrom': ['IProtocolYieldSource', 'Initializable', 'ReentrancyGuardUpgradeable', 'ERC20Upgradeable', 'AssetManager'], 'Imports': ['@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol', './interfaces/pooltogether/IProtocolYieldSource.sol', './interfaces/idle/IIdleToken.sol', './interfaces/idle/IIdleTokenHelper.sol', './access/AssetManager.sol']}, 'StateVariables': [{'Name': 'idleToken', 'Type': 'address', 'Purpose': 'The address of the Idle Finance token contract.'}, {'Name': 'underlyingAsset', 'Type': 'address', 'Purpose': 'The address of the underlying asset (e.g., DAI) used in the Idle Finance protocol.'}, {'Name': 'totalUnderlyingAssets', 'Type': 'uint256', 'Purpose': 'The total amount of underlying assets managed by the contract.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the contract with the Idle Finance token address and sets up the underlying asset.', 'Parameters': ['address _idleToken'], 'Returns': []}, {'Name': 'depositToken', 'Visibility': 'external', 'Purpose': 'Returns the address of the underlying asset used for deposits.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balanceOfToken', 'Visibility': 'external', 'Purpose': 'Returns the balance of the underlying asset for a given address.', 'Parameters': ['address addr'], 'Returns': ['uint256']}, {'Name': '_totalShare', 'Visibility': 'internal', 'Purpose': 'Returns the total shares held by the contract in the Idle Finance protocol.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_tokenToShares', 'Visibility': 'internal', 'Purpose': 'Converts a given amount of tokens to shares based on the current total shares and underlying assets.', 'Parameters': ['uint256 tokens'], 'Returns': ['uint256 shares']}, {'Name': '_sharesToToken', 'Visibility': 'internal', 'Purpose': 'Converts a given amount of shares to tokens based on the current total shares and underlying assets.', 'Parameters': ['uint256 shares'], 'Returns': ['uint256 tokens']}, {'Name': '_depositToIdle', 'Visibility': 'internal', 'Purpose': 'Deposits a given amount of underlying assets into the Idle Finance protocol and returns the minted shares.', 'Parameters': ['uint256 mintAmount'], 'Returns': ['uint256']}, {'Name': 'supplyTokenTo', 'Visibility': 'public', 'Purpose': 'Supplies a given amount of underlying assets to the Idle Finance protocol and mints shares to a specified address.', 'Parameters': ['uint256 mintAmount', 'address to'], 'Returns': []}, {'Name': 'redeemToken', 'Visibility': 'public', 'Purpose': 'Redeems a given amount of underlying assets from the Idle Finance protocol and burns the corresponding shares.', 'Parameters': ['uint256 redeemAmount'], 'Returns': ['uint256']}, {'Name': 'transferERC20', 'Visibility': 'external', 'Purpose': 'Transfers a given amount of an ERC20 token (excluding the Idle token) to a specified address.', 'Parameters': ['address erc20Token', 'address to', 'uint256 amount'], 'Returns': []}, {'Name': 'sponsor', 'Visibility': 'external', 'Purpose': 'Sponsors the contract by depositing a given amount of underlying assets into the Idle Finance protocol.', 'Parameters': ['uint256 amount'], 'Returns': []}]}, 'ExternalInteractions': ['Interacts with the Idle Finance protocol via `IIdleToken` for minting and redeeming idle tokens.', ""Uses OpenZeppelin's `SafeERC20Upgradeable` for safe ERC20 token transfers.""], 'SpecialMechanisms': [""Uses OpenZeppelin's upgradeable contracts for initialization and reentrancy protection."", 'Implements a share-to-token conversion mechanism to manage deposits and redemptions.'], 'Questions': ['How is the `totalUnderlyingAssets` variable updated accurately in the presence of yield generation?', 'Is there a mechanism to handle potential rounding errors in the `_tokenToShares` and `_sharesToToken` functions?', 'What happens if the underlying asset balance changes unexpectedly (e.g., due to yield generation) during a deposit or redemption?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in `redeemToken` Function', 'Severity': 'High', 'Description': 'The `redeemToken` function transfers tokens to the user before updating the state variable `totalUnderlyingAssets`. Although it uses the `nonReentrant` modifier, the external call to `IIdleToken(idleToken).redeemIdleToken` or `safeTransfer` could still be exploited if the underlying asset is a malicious contract, potentially leading to reentrancy attacks.', 'Impact': 'An attacker could exploit this vulnerability to withdraw more tokens than they are entitled to, leading to financial loss for the contract.', 'Location': 'Function `redeemToken`'}, {'Issue': 'Uninitialized `totalUnderlyingAssets`', 'Severity': 'High', 'Description': 'The `totalUnderlyingAssets` variable is not initialized in the `initialize` function. This could lead to incorrect calculations in `_tokenToShares` and `_sharesToToken` functions, potentially causing financial discrepancies.', 'Impact': 'Financial losses due to incorrect token share calculations.', 'Location': '`initialize` function and `_tokenToShares`, `_sharesToToken` functions'}, {'Issue': 'Incorrect Calculation in `_tokenToShares` and `_sharesToToken` Functions', 'Severity': 'High', 'Description': 'The calculations in `_tokenToShares` and `_sharesToToken` functions do not account for the possibility of division by zero if `_totalShare()` or `totalUnderlyingAssets` is zero. This could lead to runtime errors or incorrect conversions.', 'Impact': 'Runtime errors leading to potential denial of service or incorrect token calculations.', 'Location': 'Functions `_tokenToShares` and `_sharesToToken`'}, {'Issue': 'Unrestricted Approval in `initialize` Function', 'Severity': 'High', 'Description': 'The `initialize` function sets an unlimited approval for the `idleToken` to spend the `underlyingAsset`. If the `idleToken` contract is compromised, it could lead to loss of all underlying assets.', 'Impact': 'Potential loss of all underlying assets if the `idleToken` is compromised.', 'Location': 'Function `initialize`'}, {'Issue': 'Lack of Input Validation in `initialize` Function', 'Severity': 'Medium', 'Description': 'The `initialize` function does not validate the input `_idleToken`. If an invalid or malicious address is provided, it could lead to unexpected behavior or vulnerabilities in the contract.', 'Impact': 'Invalid or malicious input could cause the contract to malfunction or become vulnerable to attacks.', 'Location': 'Function `initialize`'}, {'Issue': 'Lack of Input Validation in `supplyTokenTo` and `redeemToken`', 'Severity': 'Medium', 'Description': 'The functions `supplyTokenTo` and `redeemToken` do not validate the input parameters `mintAmount` and `redeemAmount`, respectively. This could lead to unexpected behavior or vulnerabilities if zero or invalid values are passed.', 'Impact': 'Potential for unexpected behavior or exploitation if invalid inputs are provided.', 'Location': 'Functions `supplyTokenTo` and `redeemToken`'}, {'Issue': 'Unrestricted `transferERC20` Function', 'Severity': 'Medium', 'Description': 'The `transferERC20` function allows the owner or asset manager to transfer any ERC20 token, except the `idleToken`. This could lead to unintended transfers of critical tokens if the owner or asset manager is compromised.', 'Impact': ""If the owner or asset manager's account is compromised, an attacker could drain the contract of valuable tokens."", 'Location': 'Function `transferERC20`'}, {'Issue': 'Missing Access Control in `sponsor` Function', 'Severity': 'Medium', 'Description': 'The `sponsor` function does not have any access control, allowing anyone to call it. This could lead to unintended token deposits and potentially dilute the value of existing shares.', 'Impact': 'Unauthorized users could deposit tokens, potentially diluting the value of existing shares and causing financial losses to existing shareholders.', 'Location': 'Function `sponsor`'}, {'Issue': 'Unchecked Return Value in `_depositToIdle` Function', 'Severity': 'Medium', 'Description': 'The `_depositToIdle` function does not check the return value of `mintIdleToken`. If the minting fails, the function will still proceed, potentially leading to incorrect state updates.', 'Impact': 'Incorrect state updates and potential loss of funds.', 'Location': 'Function `_depositToIdle`'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': ""The contract uses arithmetic operations in functions like `_tokenToShares`, `_sharesToToken`, `supplyTokenTo`, and `redeemToken` without explicit checks for overflow/underflow. Although Solidity 0.8.x has built-in overflow checks, it's good practice to handle these explicitly."", 'Impact': 'Potential for incorrect calculations if overflow/underflow occurs.', 'Location': 'Functions `_tokenToShares`, `_sharesToToken`, `supplyTokenTo`, and `redeemToken`'}, {'Issue': 'Inconsistent Use of `safeTransfer` and `safeTransferFrom`', 'Severity': 'Low', 'Description': 'The contract uses `safeTransfer` and `safeTransferFrom` inconsistently. While `safeTransferFrom` is used in `_depositToIdle`, `safeTransfer` is used in `redeemToken` and `transferERC20`. This inconsistency could lead to potential issues if the underlying token behaves differently in these contexts.', 'Impact': ""Potential for unexpected behavior if the token's transfer functions behave differently."", 'Location': 'Functions `_depositToIdle`, `redeemToken`, and `transferERC20`'}, {'Issue': 'Lack of Event Emission for Critical State Changes', 'Severity': 'Low', 'Description': ""The contract does not emit events for all critical state changes, such as updates to `totalUnderlyingAssets` or deposits in `_depositToIdle`. This could make it difficult to track and audit changes to the contract's state."", 'Impact': ""Lack of transparency and auditability could lead to disputes or difficulties in monitoring the contract's behavior."", 'Location': 'State variable `totalUnderlyingAssets` and function `_depositToIdle`'}, {'Issue': 'Incorrect Event Emission in `transferERC20`', 'Severity': 'Low', 'Description': 'The `transferERC20` function emits the `TransferredERC20` event with `msg.sender` as the `from` parameter, which is incorrect. It should be `address(this)` since the tokens are being transferred from the contract.', 'Impact': 'Misleading event logs.', 'Location': 'Function `transferERC20`'}], 'IssueNumber': 52, 'OutputList': 13}",901.8975911140442,"### **Output**

---

**[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource**

**Report Description**:
The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. This discrepancy causes users to receive fewer underlying tokens than they should. The issue arises because `tokenPriceWithFee()` is usually greater than `ONE_IDLE_TOKEN`, making `redeemedShare` less than `redeemAmount`. This misalignment in calculations leads to financial losses for users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this specific issue. While it mentions potential reentrancy vulnerabilities and incorrect calculations in other functions, it does not identify the misuse of `redeemedShare` instead of `redeemAmount` in the `redeemToken` function. This oversight fails to address the core vulnerability described in the issue.

---

**[H-05] IdleYieldSource doesn't use mantissa calculations**

**Report Description**:
The `IdleYieldSource` contract does not use mantissa calculations to account for decimals in arithmetic operations. This omission can lead to incorrect calculations, such as zeroing out the number of shares or tokens that should be given. For example, if `totalUnderlyingAssets` becomes larger than the number of total shares, the division could output zero, resulting in users receiving no shares despite depositing tokens. The recommendation is to implement mantissa calculations, similar to those in the AAVE yield contract.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the lack of mantissa calculations in the `IdleYieldSource` contract. While it mentions potential integer overflow/underflow and incorrect calculations in other functions, it does not identify the specific issue of missing mantissa calculations, which is critical for accurate arithmetic operations involving decimals.

---

**[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits**

**Report Description**:
The `timelockDepositTo` function assumes that the operator (`_msgSender()`) is the same as the user (`to`). This assumption may not hold in meta-transaction scenarios where the operator is a relayer facilitating gas-less transactions on behalf of the user. The function incorrectly accounts `_timelockBalances` to the operator address instead of the user-specified `to` address. This inconsistency can lead to failed timelock deposits when the operator and user addresses differ, as the operator’s address may not have the required `_timelockBalances`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. While it mentions access control and input validation in other functions, it does not identify the incorrect assumption in `timelockDepositTo` that the operator and user addresses are the same. This oversight fails to address the potential for failed timelock deposits in meta-transaction scenarios.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- *None*

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource**
- **[H-05] IdleYieldSource doesn't use mantissa calculations**
- **[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits**

---

### **Conclusion**

The `response_list` does not adequately address the issues raised in the `issue` report. None of the issues are correctly or partially matched, and critical vulnerabilities related to token redemption, mantissa calculations, and timelock deposits are entirely missed. This indicates a significant gap in the coverage and accuracy of the responses provided.","```
None.
```",0.0
YearnV2YieldSource.sol,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.6.12;

import ""../interfaces/IYieldSource.sol"";
import ""../external/yearn/IYVaultV2.sol"";

import ""@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";


/// @title Yield source for a PoolTogether prize pool that generates yield by depositing into Yearn Vaults.
/// @dev This contract inherits from the ERC20 implementation to keep track of users deposits
/// @dev This is a generic contract that will work with main Yearn Vaults. Vaults using v0.3.2 to v0.3.4 included
/// @dev are not compatible, as they had dips in shareValue due to a small miscalculation
/// @notice Yield Source Prize Pools subclasses need to implement this interface so that yield can be generated.
contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint;
    
    /// @notice Yearn Vault which manages `token` to generate yield
    IYVaultV2 public vault;
    /// @dev Deposit Token contract address
    IERC20Upgradeable internal token; 
    /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS
    uint256 public maxLosses = 0; // 100% would be 10_000

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed user,
        uint256 amount
    );
    
    /// @notice Emitted when the yield source is initialized
    event YieldSourceYearnV2Initialized(
        IYVaultV2 vault,
        IERC20Upgradeable token
    );

    /// @notice Emitted when the Max Losses accepted when withdrawing from yVault are changed
    event MaxLossesChanged(
        uint256 newMaxLosses
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Initializes the yield source with 
    /// @param _vault YearnV2 Vault in which the Yield Source will deposit `token` to generate Yield
    /// @param _token Underlying Token / Deposit Token
    function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        // NOTE: Vaults from 0.3.2 to 0.3.4 have dips in shareValue
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }

    function setMaxLosses(uint256 _maxLosses) external onlyOwner {
        require(_maxLosses <= 10_000, ""YearnV2YieldSource:: losses set too high"");

        maxLosses = _maxLosses;

        emit MaxLossesChanged(_maxLosses);
    }

    /// @notice Returns the ERC20 asset token used for deposits
    /// @return The ERC20 asset token address
    function depositToken() external view override returns (address) {
        return address(token);
    }

    /// @notice Returns user total balance (in asset tokens). This includes the deposits and interest.
    /// @param addr User address
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Supplies asset tokens to the yield source
    /// @dev Shares corresponding to the number of tokens supplied are mint to the user's balance
    /// @dev Asset tokens are supplied to the yield source, then deposited into Aave
    /// @param _amount The amount of asset tokens to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {
        uint256 shares = _tokenToShares(_amount);

        _mint(to, shares);

        // NOTE: we have to deposit after calculating shares to mint
        token.safeTransferFrom(msg.sender, address(this), _amount);

        _depositInVault();

        emit SuppliedTokenTo(msg.sender, shares, _amount, to);
    }

    /// @notice Redeems asset tokens from the yield source
    /// @dev Shares corresponding to the number of tokens withdrawn are burnt from the user's balance
    /// @dev Asset tokens are withdrawn from Yearn's Vault, then transferred from the yield source to the user's wallet
    /// @param amount The amount of asset tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed
    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
        uint256 shares = _tokenToShares(amount);

        uint256 withdrawnAmount = _withdrawFromVault(amount);

        _burn(msg.sender, shares);

        token.safeTransfer(msg.sender, withdrawnAmount);

        emit RedeemedToken(msg.sender, shares, amount);
        return withdrawnAmount;
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external nonReentrant {
        token.safeTransferFrom(msg.sender, address(this), amount);

        _depositInVault();

        emit Sponsored(msg.sender, amount);
    }

    // ************************ INTERNAL FUNCTIONS ************************

    /// @notice Deposits full balance (or max available deposit) into Yearn's Vault
    /// @dev if deposit limit is reached, tokens will remain in the Yield Source and
    /// @dev they will be queued for retries in subsequent deposits
    /// @return The actual amount of shares that were received for the deposited tokens
    function _depositInVault() internal returns (uint256) {
        IYVaultV2 v = vault; // NOTE: for gas usage
        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {
            token.safeApprove(address(v), type(uint256).max);
        }
        // this will deposit full balance (for cases like not enough room in Vault)
        return v.deposit();
    }

    /// @notice Withdraws requested amount from Vault
    /// @dev Vault withdrawal function required amount of shares to be redeemed
    /// @dev Losses are accepted by the Yield Source to avoid funds being locked in the Vault if something happened
    /// @param amount amount of asset tokens to be redeemed
    /// @return Tokens received from the Vault
    function _withdrawFromVault(uint amount) internal returns (uint256) {
        uint256 yShares = _tokenToYShares(amount);
        uint256 previousBalance = token.balanceOf(address(this));
        // we accept losses to avoid being locked in the Vault (if losses happened for some reason)
        if(maxLosses != 0) {
            vault.withdraw(yShares, address(this), maxLosses);
        } else {
            vault.withdraw(yShares);
        }
        uint256 currentBalance = token.balanceOf(address(this));

        return previousBalance.sub(currentBalance);
    }

    /// @notice Returns the amount of shares of yearn's vault that the Yield Source holds
    /// @return Balance of vault's shares holded by Yield Source
    function _balanceOfYShares() internal view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    /// @notice Ratio between yShares and underlying token
    /// @dev use this to convert from shares to deposit tokens and viceversa
    /// @dev (see _tokenToYShares & _ySharesToToken)
    /// @return Price per vault's share
    function _pricePerYShare() internal view returns (uint256) {
        return vault.pricePerShare();
    }

    /// @notice Balance of deposit token held in the Yield Source
    /// @return balance of deposit token
    function _balanceOfToken() internal view returns (uint256) {
        return token.balanceOf(address(this));
    }

    /// @notice Total Assets under Management by Yield Source, denominated in Deposit Token
    /// @dev amount of deposit token held in Yield Source + investment (amount held in Yearn's Vault)
    /// @return Total AUM denominated in deposit Token
    function _totalAssetsInToken() internal view returns (uint256) {
        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));
    }

    /// @notice Support function to retrieve used by Vault
    /// @dev used to correctly scale prices 
    /// @return decimals of vault's shares (and underlying token)
    function _vaultDecimals() internal view returns (uint256) {
        return vault.decimals();
    }

    // ************************ CALCS ************************

    /// @notice Converter from deposit token to yShares (yearn vault's shares)
    /// @param tokens Amount of tokens to be converted
    /// @return yShares to redeem to receive `tokens` deposit token
    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {
        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());
    }

    /// @notice Converter from deposit yShares (yearn vault's shares) to token 
    /// @param yShares Vault's shares to be converted
    /// @return tokens that will be received if yShares shares are redeemed
    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {
        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());
    }

    /// @notice Function to calculate the amount of Yield Source shares equivalent to a deposit tokens amount
    /// @param tokens amount of tokens to be converted
    /// @return shares number of shares equivalent to the amount of tokens
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(totalSupply() == 0) {
            shares = tokens;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            shares = tokens.mul(totalSupply()).div(_totalTokens);
        }
    }

    /// @notice Function to calculate the amount of Deposit Tokens equivalent to a Yield Source shares amount
    /// @param shares amount of Yield Source shares to be converted
    /// @dev used to calculate how many shares to mint / burn when depositing / withdrawing
    /// @return tokens number of tokens equivalent (in value) to the amount of Yield Source shares
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {
        if(totalSupply() == 0) {
            tokens = shares;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            tokens = shares.mul(_totalTokens).div(totalSupply());
        }
    }

    /// @notice Pure support function to compare strings
    /// @param a One string
    /// @param b Another string
    /// @return Whether or not the strings are the same or not
    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}
",2782,280,"[H-02] YearnV2YieldSource wrong subtraction in withdraw
When withdrawing function `_withdrawFromVault` from the vault, one redeems yTokens for tokens, thus the token balance of the contract should increase after withdrawal. But the contract subtracts the currentBalance from the previousBalance:
``` uint256 yShares = _tokenToYShares(amount);
uint256 previousBalance = token.balanceOf(address(this));
// we accept losses to avoid being locked in the Vault (if losses happened for some reason)
if(maxLosses != 0) {
    vault.withdraw(yShares, address(this), maxLosses);
} else {
    vault.withdraw(yShares);
}
uint256 currentBalance = token.balanceOf(address(this));
// @audit-issue this seems wrong
return previousBalance.sub(currentBalance);
```
All vault withdrawals fail due to the integer underflow as the previousBalance is less than currentBalance. Users won't be able to get back their investment.
  [M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS

The `_depositInVault()` function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract’s token balance.
However, the safeApprove function prevents changing an allowance between non-zero values to mitigate a possible front-running attack. It reverts if that is the case. Instead, the safeIncreaseAllowance and safeDecreaseAllowance functions should be used. Comment from the OZ library for this function:
“// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and ‘safeDecreaseAllowance'""
If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user’s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible. See similar Medium-severity finding M03.
",2,"pragma solidity 0.6.12;

import ""../interfaces/IYieldSource.sol"";
import ""../external/yearn/IYVaultV2.sol"";

import ""@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";







contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint;
    
    
    IYVaultV2 public vault;
    
    IERC20Upgradeable internal token; 
    
    uint256 public maxLosses = 0; 

    
    event Sponsored(
        address indexed user,
        uint256 amount
    );
    
    
    event YieldSourceYearnV2Initialized(
        IYVaultV2 vault,
        IERC20Upgradeable token
    );

    
    event MaxLossesChanged(
        uint256 newMaxLosses
    );

    
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    
    
    
    function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }

    function setMaxLosses(uint256 _maxLosses) external onlyOwner {
        require(_maxLosses <= 10_000, ""YearnV2YieldSource:: losses set too high"");

        maxLosses = _maxLosses;

        emit MaxLossesChanged(_maxLosses);
    }

    
    
    function depositToken() external view override returns (address) {
        return address(token);
    }

    
    
    
    function balanceOfToken(address addr) external override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    
    
    
    
    
    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {
        uint256 shares = _tokenToShares(_amount);

        _mint(to, shares);

        
        token.safeTransferFrom(msg.sender, address(this), _amount);

        _depositInVault();

        emit SuppliedTokenTo(msg.sender, shares, _amount, to);
    }

    
    
    
    
    
    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
        uint256 shares = _tokenToShares(amount);

        uint256 withdrawnAmount = _withdrawFromVault(amount);

        _burn(msg.sender, shares);

        token.safeTransfer(msg.sender, withdrawnAmount);

        emit RedeemedToken(msg.sender, shares, amount);
        return withdrawnAmount;
    }

    
    
    
    function sponsor(uint256 amount) external nonReentrant {
        token.safeTransferFrom(msg.sender, address(this), amount);

        _depositInVault();

        emit Sponsored(msg.sender, amount);
    }

    

    
    
    
    
    function _depositInVault() internal returns (uint256) {
        IYVaultV2 v = vault; 
        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {
            token.safeApprove(address(v), type(uint256).max);
        }
        
        return v.deposit();
    }

    
    
    
    
    
    function _withdrawFromVault(uint amount) internal returns (uint256) {
        uint256 yShares = _tokenToYShares(amount);
        uint256 previousBalance = token.balanceOf(address(this));
        
        if(maxLosses != 0) {
            vault.withdraw(yShares, address(this), maxLosses);
        } else {
            vault.withdraw(yShares);
        }
        uint256 currentBalance = token.balanceOf(address(this));

        return previousBalance.sub(currentBalance);
    }

    
    
    function _balanceOfYShares() internal view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    
    
    
    
    function _pricePerYShare() internal view returns (uint256) {
        return vault.pricePerShare();
    }

    
    
    function _balanceOfToken() internal view returns (uint256) {
        return token.balanceOf(address(this));
    }

    
    
    
    function _totalAssetsInToken() internal view returns (uint256) {
        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));
    }

    
    
    
    function _vaultDecimals() internal view returns (uint256) {
        return vault.decimals();
    }

    

    
    
    
    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {
        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());
    }

    
    
    
    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {
        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());
    }

    
    
    
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(totalSupply() == 0) {
            shares = tokens;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            shares = tokens.mul(totalSupply()).div(_totalTokens);
        }
    }

    
    
    
    
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {
        if(totalSupply() == 0) {
            tokens = shares;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            tokens = shares.mul(_totalTokens).div(totalSupply());
        }
    }

    
    
    
    
    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",1523,1,1,,"{'ReviewingTheCode': ""The contract is a yield source implementation for Yearn V2 vaults, allowing users to deposit and redeem tokens while interacting with a Yearn V2 vault. It uses OpenZeppelin's upgradeable contracts for ERC20, ownership, and reentrancy protection. The contract is designed to be initialized once with a specific Yearn V2 vault and token, and it includes mechanisms for managing deposits, withdrawals, and maximum losses."", 'IdentifyingKeyComponents': {'ContractName': 'YearnV2YieldSource', 'Purpose': 'To act as a yield source for Yearn V2 vaults, enabling users to deposit and redeem tokens while interacting with a Yearn V2 vault.', 'InheritanceAndImports': {'InheritsFrom': ['IYieldSource', 'ERC20Upgradeable', 'OwnableUpgradeable', 'ReentrancyGuardUpgradeable'], 'Imports': ['../interfaces/IYieldSource.sol', '../external/yearn/IYVaultV2.sol', '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol', '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol']}, 'StateVariables': [{'Name': 'vault', 'Type': 'IYVaultV2', 'Purpose': 'The Yearn V2 vault that the contract interacts with.'}, {'Name': 'token', 'Type': 'IERC20Upgradeable', 'Purpose': 'The token that is deposited into and withdrawn from the vault.'}, {'Name': 'maxLosses', 'Type': 'uint256', 'Purpose': 'The maximum allowed losses when withdrawing from the vault.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the contract with a specific Yearn V2 vault and token.', 'Parameters': ['IYVaultV2 _vault', 'IERC20Upgradeable _token'], 'Returns': []}, {'Name': 'setMaxLosses', 'Visibility': 'external', 'Purpose': 'Sets the maximum allowed losses when withdrawing from the vault.', 'Parameters': ['uint256 _maxLosses'], 'Returns': []}, {'Name': 'depositToken', 'Visibility': 'external', 'Purpose': 'Returns the address of the token that can be deposited.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balanceOfToken', 'Visibility': 'external', 'Purpose': 'Returns the balance of tokens for a given address.', 'Parameters': ['address addr'], 'Returns': ['uint256']}, {'Name': 'supplyTokenTo', 'Visibility': 'external', 'Purpose': 'Allows a user to supply tokens to the contract and receive shares in return.', 'Parameters': ['uint256 _amount', 'address to'], 'Returns': []}, {'Name': 'redeemToken', 'Visibility': 'external', 'Purpose': 'Allows a user to redeem tokens by burning their shares.', 'Parameters': ['uint256 amount'], 'Returns': ['uint256']}, {'Name': 'sponsor', 'Visibility': 'external', 'Purpose': 'Allows a user to sponsor the contract by depositing tokens without receiving shares.', 'Parameters': ['uint256 amount'], 'Returns': []}, {'Name': '_depositInVault', 'Visibility': 'internal', 'Purpose': 'Deposits tokens into the Yearn V2 vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_withdrawFromVault', 'Visibility': 'internal', 'Purpose': 'Withdraws tokens from the Yearn V2 vault.', 'Parameters': ['uint256 amount'], 'Returns': ['uint256']}, {'Name': '_balanceOfYShares', 'Visibility': 'internal', 'Purpose': 'Returns the balance of shares in the Yearn V2 vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_pricePerYShare', 'Visibility': 'internal', 'Purpose': 'Returns the price per share in the Yearn V2 vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_balanceOfToken', 'Visibility': 'internal', 'Purpose': 'Returns the balance of tokens in the contract.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_totalAssetsInToken', 'Visibility': 'internal', 'Purpose': 'Returns the total assets in tokens, including those in the vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_vaultDecimals', 'Visibility': 'internal', 'Purpose': 'Returns the number of decimals used by the vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_tokenToYShares', 'Visibility': 'internal', 'Purpose': 'Converts tokens to Yearn V2 shares.', 'Parameters': ['uint256 tokens'], 'Returns': ['uint256']}, {'Name': '_ySharesToToken', 'Visibility': 'internal', 'Purpose': 'Converts Yearn V2 shares to tokens.', 'Parameters': ['uint256 yShares'], 'Returns': ['uint256']}, {'Name': '_tokenToShares', 'Visibility': 'internal', 'Purpose': 'Converts tokens to shares in the contract.', 'Parameters': ['uint256 tokens'], 'Returns': ['uint256']}, {'Name': '_sharesToToken', 'Visibility': 'internal', 'Purpose': 'Converts shares in the contract to tokens.', 'Parameters': ['uint256 shares'], 'Returns': ['uint256']}, {'Name': 'areEqualStrings', 'Visibility': 'internal', 'Purpose': 'Compares two strings for equality.', 'Parameters': ['string memory a', 'string memory b'], 'Returns': ['bool']}]}, 'ExternalInteractions': ['IYVaultV2 (Yearn V2 vault)', 'IERC20Upgradeable (ERC20 token)'], 'SpecialMechanisms': ['The contract uses upgradeable contracts from OpenZeppelin, allowing for future upgrades.', ""It implements reentrancy protection using OpenZeppelin's ReentrancyGuardUpgradeable."", 'The contract uses SafeMathUpgradeable for arithmetic operations to prevent overflow and underflow.'], 'Questions': [""What is the purpose of the 'sponsor' function, and how does it differ from 'supplyTokenTo'?"", ""Why are certain functions marked as 'internal' and not accessible externally?"", ""What are the implications of setting 'maxLosses' to a high value, and how does it affect withdrawals?""]}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `_depositInVault` and `_withdrawFromVault`', 'Severity': 'High', 'Description': 'Multiple reports highlight potential reentrancy vulnerabilities in `_depositInVault` and `_withdrawFromVault` functions due to interactions with external contracts (Yearn Vault) without adequate reentrancy guards. Although some functions use the `nonReentrant` modifier, direct calls to these internal functions could still be exploited if the vault is malicious or compromised.', 'Impact': 'An attacker could manipulate contract state or drain funds by reentering during deposit or withdrawal operations.', 'Location': 'Functions: `_depositInVault`, `_withdrawFromVault`, `redeemToken`, `supplyTokenTo`'}, {'Issue': 'Unbounded Token Approval in `initialize`', 'Severity': 'High', 'Description': 'The `initialize` function grants unlimited token approval (`type(uint256).max`) to the Yearn Vault. This poses a significant risk if the vault is compromised, as it could drain all tokens from the contract.', 'Impact': 'Potential loss of all tokens if the vault is malicious or compromised.', 'Location': '`initialize` function, line: `_token.safeApprove(address(vault), type(uint256).max);`'}, {'Issue': 'Incorrect Vault API Version Check', 'Severity': 'Medium', 'Description': 'The `initialize` function checks for specific incompatible Yearn Vault API versions (0.3.2, 0.3.3, 0.3.4) using a negated string comparison. This logic may inadvertently allow incompatible or future versions, leading to potential vulnerabilities or unexpected behavior.', 'Impact': 'Potential incompatibility with vault versions, risking unexpected behavior or loss of funds.', 'Location': '`initialize` function, lines with `require(!areEqualStrings(...))`'}, {'Issue': 'Potential Integer Overflow/Underflow in Conversion Functions', 'Severity': 'Medium', 'Description': 'Functions like `_tokenToYShares`, `_ySharesToToken`, `_tokenToShares`, and `_sharesToToken` perform arithmetic operations without explicit checks for overflow/underflow, despite using `SafeMathUpgradeable`. Large inputs could lead to incorrect calculations.', 'Impact': 'Incorrect token or share calculations, potentially resulting in loss of funds or incorrect balances.', 'Location': 'Functions: `_tokenToYShares`, `_ySharesToToken`, `_tokenToShares`, `_sharesToToken`'}, {'Issue': 'Lack of Input Validation in `setMaxLosses`', 'Severity': 'Low', 'Description': 'The `setMaxLosses` function only checks that the input `_maxLosses` is ≤10,000 but does not validate reasonableness or minimum bounds. This could lead to unintended behavior if extreme values are set.', 'Impact': 'Unintended withdrawal behavior or excessive losses if `maxLosses` is misconfigured.', 'Location': '`setMaxLosses` function, line: `require(_maxLosses <= 10_000, ...)`'}, {'Issue': 'Potential Precision Loss in Conversion Functions', 'Severity': 'Low', 'Description': ""Division operations in `_tokenToShares` and `_sharesToToken` may result in precision loss, especially for small amounts, due to Solidity's integer division."", 'Impact': 'Users may receive fewer tokens or shares than expected due to rounding errors.', 'Location': 'Functions: `_tokenToShares`, `_sharesToToken`'}, {'Issue': 'Lack of Event Emission for Critical Operations', 'Severity': 'Low', 'Description': 'Critical state changes (e.g., deposits, withdrawals, `maxLosses` updates) lack event emissions, reducing transparency and auditability.', 'Impact': 'Difficulty in tracking contract state changes and debugging issues.', 'Location': 'Functions: `_depositInVault`, `_withdrawFromVault`, `setMaxLosses`'}], 'IssueNumber': 12, 'OutputList': 7}",527.2956931591034,"### **[H-02] YearnV2YieldSource wrong subtraction in withdraw**

**Report Description**:
The `_withdrawFromVault` function in the YearnV2YieldSource contract incorrectly subtracts the `currentBalance` from the `previousBalance` when calculating the amount of tokens withdrawn. This logic is flawed because the `currentBalance` should be greater than the `previousBalance` after a successful withdrawal, leading to an integer underflow. As a result, all withdrawals will fail, preventing users from retrieving their investments.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of incorrect subtraction logic in the `_withdrawFromVault` function. The issue is not related to reentrancy, unbounded token approval, or any other vulnerabilities listed in the response list. The core problem is a logical error in arithmetic operations, which is not covered in the provided responses.

---

### **[M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS**

**Report Description**:
The `_depositInVault` function uses `safeApprove()` from OpenZeppelin's SafeERC20 library to grant allowance to the Yearn Vault. However, `safeApprove()` reverts if the allowance is being changed from a non-zero value, which can occur if the previous allowance was not fully utilized. This behavior can lead to a denial-of-service (DoS) scenario where users are unable to deposit tokens into the vault. The recommended approach is to use `safeIncreaseAllowance` or `safeDecreaseAllowance` instead.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of `safeApprove()` reverting due to non-zero allowance changes. While the response list mentions unbounded token approval in the `initialize` function, it does not cover the DoS risk associated with `safeApprove()` in the `_depositInVault` function. The core issue is a misuse of the `safeApprove()` function, which is not discussed in the provided responses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-02] YearnV2YieldSource wrong subtraction in withdraw**
- **[M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS**

---

The response list fails to address the specific vulnerabilities identified in the issue report. Both issues involve logical errors and misuse of functions that are not covered by the responses, which focus on reentrancy, unbounded approvals, and other unrelated vulnerabilities.","```
None.
```",0.0
BagerYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";

/// @title A pooltogether yield source for badger sett
/// @author Steffel Fenix, 0xkarl
contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param amount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.
    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}
",830,83,"[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong
Function `balanceOfToken` When suppling to the BadgerYieldSource, some amount of badger is deposited to badgerSett and one receives badgerSett share tokens in return which are stored in the balances mapping of the user. So far this is correct.
The balanceOfToken function should then return the redeemable balance in badger for the user's badgerSett balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of badgerSett) on the badger in the vault:
balances[addr].mul(
  badger.balanceOf(address(badgerSett))
).div(
  badgerSett.totalSupply()
)

However, badger.balanceOf(address(badgerSett)) is only a small amount of badger that is deployed in the vault (""Sett"") due to most of the capital being deployed to the strategies. Therefore, it under-reports the actual balance:
Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. Badger Docs
Any contract or user calling the balanceOf function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.
 [M-02] Return values of ERC20 transfer and transferFrom are unchecked
In the contracts BadgerYieldSource and SushiYieldSource, the return values of ERC20 transfer and transferFrom are not checked to be true, which could be false if the transferred tokens are not ERC20-compliant (e.g., BADGER). In that case, the transfer fails without being noticed by the calling contract.
If warden's understanding of the BadgerYieldSource is correct, the badger variable should be the BADGER token at address 0x3472a5a71965499acd81997a54bba8d852c6e53d. However, this implementation of BADGER is not ERC20-compliant, which returns false when the sender does not have enough token to transfer (both for transfer and transferFrom). See the source code on Etherscan (at line 226) for more details.
 [M-03] SafeMath not completely used in yield source contracts (overflow) SafeMath is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: 	line 67 in BadgerYieldSource
(amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            )
",3,"pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";



contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    
    
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    
    
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    
    
    
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    
    
    
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}",624,1,2,,"{'ReviewingTheCode': 'The contract is a yield source implementation that interacts with Badger Sett and Badger tokens. It allows users to deposit, redeem, and check balances of tokens. The code uses SafeMath for arithmetic operations and imports several interfaces and libraries.', 'IdentifyingKeyComponents': {'ContractName': 'BadgerYieldSource', 'Purpose': 'To manage deposits, redemptions, and balance checks for Badger tokens through interactions with Badger Sett.', 'InheritanceAndImports': {'InheritsFrom': ['IYieldSource'], 'Imports': ['@pooltogether/yield-source-interface/contracts/IYieldSource.sol', '@openzeppelin/contracts/math/SafeMath.sol', './IBadgerSett.sol', './IBadger.sol', 'hardhat/console.sol']}, 'StateVariables': [{'Name': 'badgerSett', 'Type': 'IBadgerSett', 'Purpose': 'Interface for interacting with Badger Sett.'}, {'Name': 'badger', 'Type': 'IBadger', 'Purpose': 'Interface for interacting with Badger token.'}, {'Name': 'balances', 'Type': 'mapping(address => uint256)', 'Purpose': 'Stores the balance of tokens for each user.'}], 'FunctionsAndModifiers': [{'Name': 'depositToken', 'Visibility': 'public', 'Purpose': 'Returns the address of the Badger token.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balanceOfToken', 'Visibility': 'public', 'Purpose': 'Returns the balance of Badger tokens for a given address.', 'Parameters': ['address addr'], 'Returns': ['uint256']}, {'Name': 'supplyTokenTo', 'Visibility': 'public', 'Purpose': ""Deposits Badger tokens into the contract and updates the user's balance."", 'Parameters': ['uint256 amount', 'address to'], 'Returns': []}, {'Name': 'redeemToken', 'Visibility': 'public', 'Purpose': 'Redeems Badger tokens and transfers them to the user.', 'Parameters': ['uint256 amount'], 'Returns': ['uint256']}]}, 'ExternalInteractions': ['Interacts with Badger Sett (IBadgerSett) and Badger token (IBadger).'], 'SpecialMechanisms': ['Uses SafeMath for safe arithmetic operations.', 'Implements a yield source pattern for managing token deposits and redemptions.'], 'Questions': ['Why is the balanceOfToken function marked as public instead of view?', 'Is there a specific reason for using immutable for badgerSett and badger?', 'How is the redeemToken function handling edge cases, such as insufficient balance or zero total shares?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `redeemToken` Function', 'Severity': 'High', 'Description': 'The `redeemToken` function performs external calls (e.g., `badger.transfer`, `badgerSett.withdraw`) before updating internal state variables like `balances[msg.sender]`. This makes it susceptible to reentrancy attacks, where an attacker could recursively call the function to drain funds or manipulate state before updates are completed.', 'Impact': 'Potential loss of funds due to reentrancy attacks, allowing attackers to withdraw more tokens than entitled.', 'Location': '`redeemToken` function (multiple instances across reports)'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': 'Arithmetic operations in functions like `balanceOfToken`, `supplyTokenTo`, and `redeemToken` use `SafeMath`, but Solidity 0.6.12 lacks native overflow/underflow protection. Inconsistent application of `SafeMath` or extreme values could lead to incorrect calculations.', 'Impact': 'Incorrect token balances or redemptions, potentially causing financial loss or unfair distribution.', 'Location': 'Functions `balanceOfToken`, `supplyTokenTo`, `redeemToken`'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'Critical functions (`supplyTokenTo`, `redeemToken`, constructor) do not validate inputs (e.g., zero/negative amounts, invalid addresses). This could lead to failed transactions, wasted gas, or unintended behavior.', 'Impact': 'Unexpected contract behavior, potential fund loss, or deployment with invalid dependencies.', 'Location': '`supplyTokenTo`, `redeemToken`, constructor'}, {'Issue': 'Unchecked External Calls', 'Severity': 'Medium', 'Description': 'External calls (e.g., `badger.transferFrom`, `badgerSett.deposit`) lack return value checks. Silent failures could result in inconsistent state or fund loss.', 'Impact': 'Failed transactions may proceed without reverting, leading to incorrect state or lost funds.', 'Location': '`supplyTokenTo`, `redeemToken` functions'}, {'Issue': 'Incorrect Calculation in `redeemToken`', 'Severity': 'Medium', 'Description': 'The formula for `requiredShares` in `redeemToken` includes an unnecessary addition of `totalShares`, potentially causing rounding errors or incorrect redemptions.', 'Impact': 'Users may receive incorrect token amounts, leading to financial loss or unfair outcomes.', 'Location': '`redeemToken` function'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': 'No events are emitted for key actions (deposits, redemptions), reducing transparency and auditability.', 'Impact': 'Difficulty in tracking off-chain activity and debugging issues.', 'Location': '`supplyTokenTo`, `redeemToken` functions'}, {'Issue': 'Immutability of `badgerSett` and `badger` Addresses', 'Severity': 'Low', 'Description': 'Constructor sets `badgerSett` and `badger` as immutable, preventing upgrades or fixes if issues arise in these dependencies.', 'Impact': 'Requires redeployment for updates, increasing operational complexity.', 'Location': 'Constructor'}, {'Issue': 'Use of `console.sol` for Debugging', 'Severity': 'Low', 'Description': 'The contract imports `hardhat/console.sol`, which should be removed before production to avoid unnecessary gas costs and potential security risks.', 'Impact': 'Increased gas costs and potential exposure of sensitive debug information.', 'Location': 'Import statement'}], 'IssueNumber': 10, 'OutputList': 8}",391.39101910591125,"### **Output**

---

**[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong**

**Report Description**:
The `balanceOfToken` function in `BadgerYieldSource` calculates the redeemable balance of `badger` for a user's `badgerSett` balance incorrectly. It uses the formula `balances[addr].mul(badger.balanceOf(address(badgerSett))).div(badgerSett.totalSupply())`, which under-reports the actual balance because `badger.balanceOf(address(badgerSett))` only reflects a small reserve amount in the vault, not the total deployed capital in strategies. This leads to incorrect balance reporting, which can cause errors in integrations and computations.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect share calculation in `balanceOfToken`. The issue is specific to the miscalculation of redeemable balances due to the use of an incorrect formula, which is not covered in the response list.

---

**[M-02] Return values of ERC20 transfer and transferFrom are unchecked**

**Report Description**:
In `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked. This is particularly problematic for non-ERC20-compliant tokens like `BADGER`, which return `false` on failure instead of reverting. If the transfer fails silently, the contract will not notice, leading to potential inconsistencies or vulnerabilities.

**Match in Response List**:
Matches with the issue titled **""Unchecked External Calls""**.

**Validation**:
**Correct**. The response accurately identifies the issue of unchecked external calls, specifically mentioning the lack of return value checks for `transfer` and `transferFrom`. This aligns with the reported issue and Solidity best practices for secure contract interactions.

---

**[M-03] SafeMath not completely used in yield source contracts (overflow)**

**Report Description**:
The yield source contracts do not consistently use `SafeMath`, particularly in the calculation at line 67 of `BadgerYieldSource`: `(amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)`. This could lead to arithmetic underflow or overflow, resulting in incorrect calculations and potential financial loss.

**Match in Response List**:
Matches with the issue titled **""Potential Integer Overflow/Underflow""**.

**Validation**:
**Partially Correct**. The response identifies the general issue of potential integer overflow/underflow but does not specifically address the incorrect use of `SafeMath` in the formula at line 67 of `BadgerYieldSource`. The response is partially correct as it covers the broader issue but misses the specific instance.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] Return values of ERC20 transfer and transferFrom are unchecked**

**Partially Correct Matches**:

- **[M-03] SafeMath not completely used in yield source contracts (overflow)**

**Missed Issues from Issue Report**:

- **[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong**

---","```
1. Unchecked External Calls
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unchecked External Calls"".
   - In the ranked list of predictions, ""Unchecked External Calls"" appears at rank 4.

2. **Calculate the precision at that rank**:
   - Precision at rank 4 (\( P@4 \)) is the number of true positives up to rank 4 divided by 4.
   - Since there is only one true positive up to rank 4, \( P@4 = \frac{1}{4} = 0.25 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - Therefore, \( AP = 0.25 \).

**Output**:
```
0.25
```"
PrizePool.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";

/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.
/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.
/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens
abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  /// @dev Emitted when an instance is initialized
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  /// @dev Event emitted when controlled token is added
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  /// @dev Emitted when reserve is captured.
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  /// @dev Event emitted when assets are deposited
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  /// @dev Event emitted when timelocked funds are re-deposited
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when interest is awarded to a winner
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are awarded to a winner
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are transferred out
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC721s are awarded to a winner
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  /// @dev Event emitted when assets are withdrawn instantly
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  /// @dev Event emitted upon a withdrawal with timelock
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  /// @dev Event emitted when timelocked funds are swept back to a user
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  /// @dev Event emitted when the Liquidity Cap is set
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  /// @dev Event emitted when the Credit plan is set
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  /// @dev Event emitted when the Prize Strategy is set
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  /// @dev Emitted when credit is minted
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  /// @dev Emitted when credit is burned
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  /// @dev Reserve to which reserve fees are sent
  RegistryInterface public reserveRegistry;

  /// @dev A linked list of all the controlled tokens
  MappedSinglyLinkedList.Mapping internal _tokens;

  /// @dev The Prize Strategy that this Prize Pool is bound to.
  TokenListenerInterface public prizeStrategy;

  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.
  /// For example, if the maxExitFeeMantissa is ""0.1 ether"", then the maximum exit fee for a withdrawal of 100 Dai will be 10 Dai
  uint256 public maxExitFeeMantissa;

  /// @dev The maximum possible timelock duration for a timelocked withdrawal (in seconds).
  uint256 public maxTimelockDuration;

  /// @dev The total funds that are timelocked.
  uint256 public timelockTotalSupply;

  /// @dev The total funds that have been allocated to the reserve
  uint256 public reserveTotalSupply;

  /// @dev The total amount of funds that the prize pool can hold.
  uint256 public liquidityCap;

  /// @dev the The awardable balance
  uint256 internal _currentAwardBalance;

  /// @dev The timelocked balances for each user
  mapping(address => uint256) internal _timelockBalances;

  /// @dev The unlock timestamps for each user
  mapping(address => uint256) internal _unlockTimestamps;

  /// @dev Stores the credit plan for each token.
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  /// @dev Stores each users balance of credit per token.
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  /// @notice Initializes the Prize Pool
  /// @param _controlledTokens Array of ControlledTokens that are controlled by this Prize Pool.
  /// @param _maxExitFeeMantissa The maximum exit fee size
  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  /// @dev Returns the address of the underlying ERC20 asset
  /// @return The address of the asset
  function token() external override view returns (address) {
    return address(_token());
  }

  /// @dev Returns the total underlying balance of all assets. This includes both principal and interest.
  /// @return The underlying balance of assets
  function balance() external returns (uint256) {
    return _balance();
  }

  /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.
  /// @param to The address receiving the tokens
  /// @param amount The amount of timelocked assets to re-deposit
  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  /// @notice Deposit assets into the Prize Pool in exchange for tokens
  /// @param to The address receiving the newly minted tokens
  /// @param amount The amount of assets to deposit
  /// @param controlledToken The address of the type of token the user is minting
  /// @param referrer The referrer of the deposit
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.
  /// @param from The address to redeem tokens from.
  /// @param amount The amount of tokens to redeem for assets.
  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)
  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.
  /// @return The actual exit fee paid
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    // burn the credit
    _burnCredit(from, controlledToken, burnedCredit);

    // burn the tickets
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    // redeem the tickets less the fee
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  /// @notice Limits the exit fee to the maximum as hard-coded into the contract
  /// @param withdrawalAmount The amount that is attempting to be withdrawn
  /// @param exitFee The exit fee to check against the limit
  /// @return The passed exit fee if it is less than the maximum, otherwise the maximum fee is returned.
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.
  /// The timelock is used to ensure that the tickets have contributed their fair share of the prize.
  /// @dev Note that if the user has previously timelocked funds then this contract will try to sweep them.
  /// If the existing timelocked funds are still locked, then the incoming
  /// balance is added to their existing balance and the new timelock unlock timestamp will overwrite the old one.
  /// @param from The address to withdraw from
  /// @param amount The amount to withdraw
  /// @param controlledToken The type of token being withdrawn
  /// @return The timestamp from which the funds can be swept
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    // return the block at which the funds will be available
    return unlockTimestamp;
  }

  /// @notice Adds to a user's timelock balance.  It will attempt to sweep before updating the balance.
  /// Note that this will overwrite the previous unlock timestamp.
  /// @param user The user whose timelock balance should increase
  /// @param amount The amount to increase by
  /// @param timestamp The new unlock timestamp
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    // Sweep the old balance, if any
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    // if the funds should already be unlocked
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  /// @notice Updates the Prize Strategy when tokens are transferred between holders.
  /// @param from The address the tokens are being transferred from (0 if minting)
  /// @param to The address the tokens are being transferred to (0 if burning)
  /// @param amount The amount of tokens being trasferred
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      // first accrue credit for their old balance
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        // if they are sending funds to someone else, we need to limit their accrued credit to their new balance
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    // if we aren't minting
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  /// @notice Returns the balance that is available to award.
  /// @dev captureAwardBalance() should be called first
  /// @return The total amount of assets to be awarded for the current prize
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  /// @notice Captures any available interest as award balance.
  /// @dev This function also captures the reserve fees.
  /// @return The total amount of assets to be awarded for the current prize
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  /// @notice Called by the prize strategy to award prizes.
  /// @dev The amount awarded must be less than the awardBalance()
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of assets to be awarded
  /// @param controlledToken The address of the asset token being awarded
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens
  /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  /// @notice Called by the Prize-Strategy to award external ERC20 prizes
  /// @dev Used to award any arbitrary tokens held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.
  /// @param to The user who is receiving the tokens
  /// @param amount The amount of tokens they are receiving
  /// @param controlledToken The token that is going to be minted
  /// @param referrer The user who referred the minting
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  /// @notice Called by the prize strategy to award external ERC721 prizes
  /// @dev Used to award any arbitrary NFTs held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param externalToken The address of the external NFT token being awarded
  /// @param tokenIds An array of NFT Token IDs to be transferred
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  /// @notice Calculates the reserve portion of the given amount of funds.  If there is no reserve address, the portion will be zero.
  /// @param amount The prize amount
  /// @return The size of the reserve portion of the prize
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts
  /// @param users An array of account addresses to sweep balances for
  /// @return The total amount of assets swept from the Prize Pool
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  /// @notice Sweep available timelocked balances to their owners.  The full balances will be swept to the owners.
  /// @param users An array of owner addresses
  /// @return The total amount of assets swept from the Prize Pool
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    // if there is nothing to do, just quit
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  /// @notice Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  /// @dev Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  /// @return burnedCredit The credit that was burned
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  /// @notice Calculates the early exit fee for the given amount
  /// @param from The user who is withdrawing
  /// @param controlledToken The type of collateral being withdrawn
  /// @param amount The amount of collateral to be withdrawn
  /// @return exitFee The exit fee
  /// @return burnedCredit The user's credit that was burned
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  /// @dev Calculates the early exit fee for the given amount
  /// @param amount The amount of collateral to be withdrawn
  /// @return Exit fee
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    // interest = credit rate * principal * time
    // => time = interest / (credit rate * principal)
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  /// @notice Burns a users credit.
  /// @param user The user whose credit should be burned
  /// @param credit The amount of credit to burn
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  /// @notice Accrues ticket credit for a user assuming their current balance is the passed balance.  May burn credit if they exceed their limit.
  /// @param user The user for whom to accrue credit
  /// @param controlledToken The controlled token whose balance we are checking
  /// @param controlledTokenBalance The balance to use for the user
  /// @param extra Additional credit to be added
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  /// @notice Applies the credit limit to a credit balance.  The balance cannot exceed the credit limit.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The users ticket balance (used to calculate credit limit)
  /// @param creditBalance The new credit balance to be checked
  /// @return The users new credit balance.  Will not exceed the credit limit.
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  /// @notice Calculates the accrued interest for a user
  /// @param user The user whose credit should be calculated.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The user's current balance of the controlled tokens.
  /// @return The credit that has accrued since the last credit update.
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.
  /// @param user The user whose credit balance should be returned
  /// @return The balance of the users credit
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  /// @notice Sets the rate at which credit accrues per second.  The credit rate is a fixed point 18 number (like Ether).
  /// @param _controlledToken The controlled token for whom to set the credit plan
  /// @param _creditRateMantissa The credit rate to set.  Is a fixed point 18 decimal (like Ether).
  /// @param _creditLimitMantissa The credit limit to set.  Is a fixed point 18 decimal (like Ether).
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  /// @notice Returns the credit rate of a controlled token
  /// @param controlledToken The controlled token to retrieve the credit rates for
  /// @return creditLimitMantissa The credit limit fraction.  This number is used to calculate both the credit limit and early exit fee.
  /// @return creditRateMantissa The credit rate. This is the amount of tokens that accrue per second.
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  /// @notice Calculate the early exit for a user given a withdrawal amount.  The user's credit is taken into account.
  /// @param from The user who is withdrawing
  /// @param controlledToken The token they are withdrawing
  /// @param amount The amount of funds they are withdrawing
  /// @return earlyExitFee The additional exit fee that should be charged.
  /// @return creditBurned The amount of credit that will be burned
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    /*
    The credit is used *last*.  Always charge the fees up-front.

    How to calculate:

    Calculate their remaining exit fee.  I.e. full exit fee of their balance less their credit.

    If the exit fee on their withdrawal is greater than the remaining exit fee, then they'll have to pay the difference.
    */

    // Determine available usable credit based on withdraw amount
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    // Determine amount of credit to burn and amount of fees required
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  /// @notice Allows the Governor to set a cap on the amount of liquidity that he pool can hold
  /// @param _liquidityCap The new liquidity cap for the prize pool
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  /// @notice Adds a new controlled token
  /// @param _controlledToken The controlled token to add.  Cannot be a duplicate.
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  /// @notice An array of the Tokens controlled by the Prize Pool (ie. Tickets, Sponsorship)
  /// @return An array of controlled token addresses
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  /// @dev Gets the current time as represented by the current block
  /// @return The timestamp of the current block
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  /// @notice The timestamp at which an account's timelocked balance will be made available to sweep
  /// @param user The address of an account with timelocked assets
  /// @return The timestamp at which the locked assets will be made available
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  /// @notice The balance of timelocked assets for an account
  /// @param user The address of an account with timelocked assets
  /// @return The amount of assets that have been timelocked
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  /// @notice Delegate the votes for a Compound COMP-like token held by the prize pool
  /// @param compLike The COMP-like token held by the prize pool that should be delegated
  /// @param to The address to delegate to 
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  /// @dev Checks if the Prize Pool can receive liquidity based on the current cap
  /// @param _amount The amount of liquidity to be added to the Prize Pool
  /// @return True if the Prize Pool can receive the specified amount of liquidity
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  /// @dev Checks if a specific token is controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  /// @return True if the token is a controlled token, false otherwise
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  /// @notice Determines whether the passed token can be transferred out as an external award.
  /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
  /// prize strategy should not be allowed to move those tokens.
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return The ERC20 asset token
  function _token() internal virtual view returns (IERC20Upgradeable);

  /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
  /// @return The underlying balance of asset tokens
  function _balance() internal virtual returns (uint256);

  /// @notice Supplies asset tokens to the yield source.
  /// @param mintAmount The amount of asset tokens to be supplied
  function _supply(uint256 mintAmount) internal virtual;

  /// @notice Redeems asset tokens from the yield source.
  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed
  /// @return The actual amount of tokens that were redeemed.
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  /// @dev Function modifier to ensure usage of tokens controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  /// @dev Function modifier to ensure caller is the prize-strategy
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}

",10191,1131,"[H-04] withdraw timelock can be circumvented
One can withdraw the entire PrizePool deposit by circumventing the timelock. Assume the user has no credits for ease of computation:
user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This ""mints"" an equivalent amount of timelock and resets _unlockTimestamps[user] = timestamp = blockTime + lockDuration.
user calls withdrawWithTimelockFrom(user, amount=0) again but this time withdrawing 0 amount. This will return a lockDuration of 0 and thus unlockTimestamp = blockTime. The inner _mintTimelock now resets _unlockTimestamps[user] = unlockTimestamp
As if (timestamp <= _currentTime())  is true, the full users amount is now transferred out to the user in the _sweepTimelockBalances call.
Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.
 [M-07] Using transferFrom on ERC721 tokens
In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of safeTransferFrom. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.",2,"pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";




abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  
  RegistryInterface public reserveRegistry;

  
  MappedSinglyLinkedList.Mapping internal _tokens;

  
  TokenListenerInterface public prizeStrategy;

  
  
  uint256 public maxExitFeeMantissa;

  
  uint256 public maxTimelockDuration;

  
  uint256 public timelockTotalSupply;

  
  uint256 public reserveTotalSupply;

  
  uint256 public liquidityCap;

  
  uint256 internal _currentAwardBalance;

  
  mapping(address => uint256) internal _timelockBalances;

  
  mapping(address => uint256) internal _unlockTimestamps;

  
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  
  
  
  
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  
  
  function token() external override view returns (address) {
    return address(_token());
  }

  
  
  function balance() external returns (uint256) {
    return _balance();
  }

  
  
  
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  
  
  
  
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  
  
  
  
  
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  
  
  
  
  
  
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    
    _burnCredit(from, controlledToken, burnedCredit);

    
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  
  
  
  
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  
  
  
  
  
  
  
  
  
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    
    return unlockTimestamp;
  }

  
  
  
  
  
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  
  
  
  
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  
  
  
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  
  
  
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  
  
  
  
  
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  
  
  
  
  
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  
  
  
  
  
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  
  
  
  
  
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  
  
  
  
  
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  
  
  
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  
  
  
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  
  
  
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  
  
  
  
  
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  
  
  
  
  
  
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  
  
  
  
  
  
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  
  
  
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  
  
  
  
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  
  
  
  
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    
    
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  
  
  
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  
  
  
  
  
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  
  
  
  
  
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  
  
  
  
  
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  
  
  
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  
  
  
  
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  
  
  
  
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  
  
  
  
  
  
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    

    
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  
  
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  
  
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  
  
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  
  
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  
  
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  
  
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  
  
  
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  
  
  
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  
  
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  
  
  
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  
  
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  
  
  
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  
  
  
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  
  
  
  
  
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  
  
  function _token() internal virtual view returns (IERC20Upgradeable);

  
  
  function _balance() internal virtual returns (uint256);

  
  
  function _supply(uint256 mintAmount) internal virtual;

  
  
  
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  
  
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}",6300,1,1,,"{'ReviewingTheCode': ""The provided code is a Solidity smart contract named 'PrizePool'. It is an abstract contract that inherits from multiple upgradeable OpenZeppelin contracts and interfaces. The contract appears to manage a prize pool system, handling deposits, withdrawals, awards, and timelocked funds. It also interacts with external tokens and maintains a credit system for users."", 'IdentifyingKeyComponents': {'ContractName': 'PrizePool', 'Purpose': 'To manage a prize pool system that allows users to deposit, withdraw, and receive awards. It also handles timelocked funds and maintains a credit system for users.', 'InheritanceAndImports': {'InheritsFrom': ['PrizePoolInterface', 'OwnableUpgradeable', 'ReentrancyGuardUpgradeable', 'TokenControllerInterface'], 'Imports': ['@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol', '@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol', '@pooltogether/fixed-point/contracts/FixedPoint.sol', '../external/compound/ICompLike.sol', '../reserve/RegistryInterface.sol', '../reserve/ReserveInterface.sol', '../token/TokenListenerInterface.sol', '../token/TokenListenerLibrary.sol', '../token/ControlledToken.sol', '../token/TokenControllerInterface.sol', '../utils/MappedSinglyLinkedList.sol', './PrizePoolInterface.sol']}, 'StateVariables': [{'Name': 'reserveRegistry', 'Type': 'RegistryInterface', 'Purpose': 'Registry interface for reserve management.'}, {'Name': '_tokens', 'Type': 'MappedSinglyLinkedList.Mapping', 'Purpose': 'Mapping of controlled tokens.'}, {'Name': 'prizeStrategy', 'Type': 'TokenListenerInterface', 'Purpose': 'Strategy for handling prize awards.'}, {'Name': 'maxExitFeeMantissa', 'Type': 'uint256', 'Purpose': 'Maximum exit fee allowed.'}, {'Name': 'maxTimelockDuration', 'Type': 'uint256', 'Purpose': 'Maximum duration for timelocked funds.'}, {'Name': 'timelockTotalSupply', 'Type': 'uint256', 'Purpose': 'Total supply of timelocked funds.'}, {'Name': 'reserveTotalSupply', 'Type': 'uint256', 'Purpose': 'Total supply of reserve funds.'}, {'Name': 'liquidityCap', 'Type': 'uint256', 'Purpose': 'Cap on the total liquidity in the pool.'}, {'Name': '_currentAwardBalance', 'Type': 'uint256', 'Purpose': 'Current balance available for awards.'}, {'Name': '_timelockBalances', 'Type': 'mapping(address => uint256)', 'Purpose': 'Balances of timelocked funds per user.'}, {'Name': '_unlockTimestamps', 'Type': 'mapping(address => uint256)', 'Purpose': 'Timestamps when timelocked funds can be unlocked.'}, {'Name': '_tokenCreditPlans', 'Type': 'mapping(address => CreditPlan)', 'Purpose': 'Credit plans for each controlled token.'}, {'Name': '_tokenCreditBalances', 'Type': 'mapping(address => mapping(address => CreditBalance))', 'Purpose': 'Credit balances for each user and controlled token.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the PrizePool contract.', 'Parameters': ['RegistryInterface _reserveRegistry', 'ControlledTokenInterface[] memory _controlledTokens', 'uint256 _maxExitFeeMantissa', 'uint256 _maxTimelockDuration'], 'Returns': []}, {'Name': 'token', 'Visibility': 'external', 'Purpose': 'Returns the address of the underlying token.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balance', 'Visibility': 'external', 'Purpose': 'Returns the balance of the underlying token.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'canAwardExternal', 'Visibility': 'external', 'Purpose': 'Checks if an external token can be awarded.', 'Parameters': ['address _externalToken'], 'Returns': ['bool']}, {'Name': 'timelockDepositTo', 'Visibility': 'external', 'Purpose': 'Deposits funds into a timelock.', 'Parameters': ['address to', 'uint256 amount', 'address controlledToken'], 'Returns': []}, {'Name': 'depositTo', 'Visibility': 'external', 'Purpose': 'Deposits funds into the prize pool.', 'Parameters': ['address to', 'uint256 amount', 'address controlledToken', 'address referrer'], 'Returns': []}, {'Name': 'withdrawInstantlyFrom', 'Visibility': 'external', 'Purpose': 'Withdraws funds instantly from the prize pool.', 'Parameters': ['address from', 'uint256 amount', 'address controlledToken', 'uint256 maximumExitFee'], 'Returns': ['uint256']}, {'Name': '_limitExitFee', 'Visibility': 'internal', 'Purpose': 'Limits the exit fee to a maximum value.', 'Parameters': ['uint256 withdrawalAmount', 'uint256 exitFee'], 'Returns': ['uint256']}, {'Name': 'withdrawWithTimelockFrom', 'Visibility': 'external', 'Purpose': 'Withdraws funds with a timelock.', 'Parameters': ['address from', 'uint256 amount', 'address controlledToken'], 'Returns': ['uint256']}, {'Name': '_mintTimelock', 'Visibility': 'internal', 'Purpose': 'Mints timelocked funds for a user.', 'Parameters': ['address user', 'uint256 amount', 'uint256 timestamp'], 'Returns': []}, {'Name': 'beforeTokenTransfer', 'Visibility': 'external', 'Purpose': 'Handles actions before a token transfer.', 'Parameters': ['address from', 'address to', 'uint256 amount'], 'Returns': []}, {'Name': 'awardBalance', 'Visibility': 'external', 'Purpose': 'Returns the current award balance.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'captureAwardBalance', 'Visibility': 'external', 'Purpose': 'Captures the current award balance.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'withdrawReserve', 'Visibility': 'external', 'Purpose': 'Withdraws reserve funds.', 'Parameters': ['address to'], 'Returns': ['uint256']}, {'Name': 'award', 'Visibility': 'external', 'Purpose': 'Awards funds to a user.', 'Parameters': ['address to', 'uint256 amount', 'address controlledToken'], 'Returns': []}, {'Name': 'transferExternalERC20', 'Visibility': 'external', 'Purpose': 'Transfers external ERC20 tokens.', 'Parameters': ['address to', 'address externalToken', 'uint256 amount'], 'Returns': []}, {'Name': 'awardExternalERC20', 'Visibility': 'external', 'Purpose': 'Awards external ERC20 tokens.', 'Parameters': ['address to', 'address externalToken', 'uint256 amount'], 'Returns': []}, {'Name': '_transferOut', 'Visibility': 'internal', 'Purpose': 'Transfers out external tokens.', 'Parameters': ['address to', 'address externalToken', 'uint256 amount'], 'Returns': ['bool']}, {'Name': '_mint', 'Visibility': 'internal', 'Purpose': 'Mints tokens for a user.', 'Parameters': ['address to', 'uint256 amount', 'address controlledToken', 'address referrer'], 'Returns': []}, {'Name': 'awardExternalERC721', 'Visibility': 'external', 'Purpose': 'Awards external ERC721 tokens.', 'Parameters': ['address to', 'address externalToken', 'uint256[] calldata tokenIds'], 'Returns': []}, {'Name': 'calculateReserveFee', 'Visibility': 'public', 'Purpose': 'Calculates the reserve fee.', 'Parameters': ['uint256 amount'], 'Returns': ['uint256']}, {'Name': 'sweepTimelockBalances', 'Visibility': 'external', 'Purpose': 'Sweeps timelocked balances.', 'Parameters': ['address[] calldata users'], 'Returns': ['uint256']}, {'Name': '_sweepTimelockBalances', 'Visibility': 'internal', 'Purpose': 'Internal function to sweep timelocked balances.', 'Parameters': ['address[] memory users'], 'Returns': ['uint256']}, {'Name': 'calculateTimelockDuration', 'Visibility': 'external', 'Purpose': 'Calculates the duration for timelocked funds.', 'Parameters': ['address from', 'address controlledToken', 'uint256 amount'], 'Returns': ['uint256 durationSeconds', 'uint256 burnedCredit']}, {'Name': '_calculateTimelockDuration', 'Visibility': 'internal', 'Purpose': 'Internal function to calculate timelock duration.', 'Parameters': ['address from', 'address controlledToken', 'uint256 amount'], 'Returns': ['uint256 durationSeconds', 'uint256 burnedCredit']}, {'Name': 'calculateEarlyExitFee', 'Visibility': 'external', 'Purpose': 'Calculates the early exit fee.', 'Parameters': ['address from', 'address controlledToken', 'uint256 amount'], 'Returns': ['uint256 exitFee', 'uint256 burnedCredit']}, {'Name': '_calculateEarlyExitFeeNoCredit', 'Visibility': 'internal', 'Purpose': 'Calculates the early exit fee without considering credit.', 'Parameters': ['address controlledToken', 'uint256 amount'], 'Returns': ['uint256']}, {'Name': 'estimateCreditAccrualTime', 'Visibility': 'external', 'Purpose': 'Estimates the time required to accrue credit.', 'Parameters': ['address _controlledToken', 'uint256 _principal', 'uint256 _interest'], 'Returns': ['uint256 durationSeconds']}, {'Name': '_estimateCreditAccrualTime', 'Visibility': 'internal', 'Purpose': 'Internal function to estimate credit accrual time.', 'Parameters': ['address _controlledToken', 'uint256 _principal', 'uint256 _interest'], 'Returns': ['uint256 durationSeconds']}, {'Name': '_burnCredit', 'Visibility': 'internal', 'Purpose': 'Burns credit for a user.', 'Parameters': ['address user', 'address controlledToken', 'uint256 credit'], 'Returns': []}, {'Name': '_accrueCredit', 'Visibility': 'internal', 'Purpose': 'Accrues credit for a user.', 'Parameters': ['address user', 'address controlledToken', 'uint256 controlledTokenBalance', 'uint256 extra'], 'Returns': []}, {'Name': '_calculateCreditBalance', 'Visibility': 'internal', 'Purpose': 'Calculates the credit balance for a user.', 'Parameters': ['address user', 'address controlledToken', 'uint256 controlledTokenBalance', 'uint256 extra'], 'Returns': ['uint256']}, {'Name': '_updateCreditBalance', 'Visibility': 'internal', 'Purpose': 'Updates the credit balance for a user.', 'Parameters': ['address user', 'address controlledToken', 'uint256 newBalance'], 'Returns': []}, {'Name': '_applyCreditLimit', 'Visibility': 'internal', 'Purpose': ""Applies a credit limit to a user's balance."", 'Parameters': ['address controlledToken', 'uint256 controlledTokenBalance', 'uint256 creditBalance'], 'Returns': ['uint256']}, {'Name': '_calculateAccruedCredit', 'Visibility': 'internal', 'Purpose': 'Calculates the accrued credit for a user.', 'Parameters': ['address user', 'address controlledToken', 'uint256 controlledTokenBalance'], 'Returns': ['uint256']}, {'Name': 'balanceOfCredit', 'Visibility': 'external', 'Purpose': 'Returns the credit balance of a user.', 'Parameters': ['address user', 'address controlledToken'], 'Returns': ['uint256']}, {'Name': 'setCreditPlanOf', 'Visibility': 'external', 'Purpose': 'Sets the credit plan for a controlled token.', 'Parameters': ['address _controlledToken', 'uint128 _creditRateMantissa', 'uint128 _creditLimitMantissa'], 'Returns': []}, {'Name': 'creditPlanOf', 'Visibility': 'external', 'Purpose': 'Returns the credit plan for a controlled token.', 'Parameters': ['address controlledToken'], 'Returns': ['uint128 creditLimitMantissa', 'uint128 creditRateMantissa']}, {'Name': '_calculateEarlyExitFeeLessBurnedCredit', 'Visibility': 'internal', 'Purpose': 'Calculates the early exit fee considering burned credit.', 'Parameters': ['address from', 'address controlledToken', 'uint256 amount'], 'Returns': ['uint256 earlyExitFee', 'uint256 creditBurned']}, {'Name': 'setLiquidityCap', 'Visibility': 'external', 'Purpose': 'Sets the liquidity cap for the prize pool.', 'Parameters': ['uint256 _liquidityCap'], 'Returns': []}, {'Name': '_setLiquidityCap', 'Visibility': 'internal', 'Purpose': 'Internal function to set the liquidity cap.', 'Parameters': ['uint256 _liquidityCap'], 'Returns': []}, {'Name': '_addControlledToken', 'Visibility': 'internal', 'Purpose': 'Adds a controlled token to the prize pool.', 'Parameters': ['ControlledTokenInterface _controlledToken'], 'Returns': []}, {'Name': 'setPrizeStrategy', 'Visibility': 'external', 'Purpose': 'Sets the prize strategy for the prize pool.', 'Parameters': ['TokenListenerInterface _prizeStrategy'], 'Returns': []}, {'Name': '_setPrizeStrategy', 'Visibility': 'internal', 'Purpose': 'Internal function to set the prize strategy.', 'Parameters': ['TokenListenerInterface _prizeStrategy'], 'Returns': []}, {'Name': 'tokens', 'Visibility': 'external', 'Purpose': 'Returns the list of controlled tokens.', 'Parameters': [], 'Returns': ['address[] memory']}, {'Name': '_currentTime', 'Visibility': 'internal', 'Purpose': 'Returns the current block timestamp.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'timelockBalanceAvailableAt', 'Visibility': 'external', 'Purpose': ""Returns the unlock timestamp for a user's timelocked funds."", 'Parameters': ['address user'], 'Returns': ['uint256']}, {'Name': 'timelockBalanceOf', 'Visibility': 'external', 'Purpose': 'Returns the timelocked balance of a user.', 'Parameters': ['address user'], 'Returns': ['uint256']}, {'Name': 'accountedBalance', 'Visibility': 'external', 'Purpose': 'Returns the total accounted balance of the prize pool.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'compLikeDelegate', 'Visibility': 'external', 'Purpose': 'Delegates voting power for a COMP-like token.', 'Parameters': ['ICompLike compLike', 'address to'], 'Returns': []}, {'Name': '_tokenTotalSupply', 'Visibility': 'internal', 'Purpose': 'Returns the total supply of all controlled tokens.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_canAddLiquidity', 'Visibility': 'internal', 'Purpose': 'Checks if liquidity can be added without exceeding the cap.', 'Parameters': ['uint256 _amount'], 'Returns': ['bool']}, {'Name': '_isControlled', 'Visibility': 'internal', 'Purpose': 'Checks if a token is controlled by the prize pool.', 'Parameters': ['address controlledToken'], 'Returns': ['bool']}, {'Name': '_canAwardExternal', 'Visibility': 'internal', 'Purpose': 'Checks if an external token can be awarded.', 'Parameters': ['address _externalToken'], 'Returns': ['bool']}, {'Name': '_token', 'Visibility': 'internal', 'Purpose': 'Returns the underlying token.', 'Parameters': [], 'Returns': ['IERC20Upgradeable']}, {'Name': '_balance', 'Visibility': 'internal', 'Purpose': 'Returns the balance of the underlying token.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_supply', 'Visibility': 'internal', 'Purpose': 'Supplies tokens to the prize pool.', 'Parameters': ['uint256 mintAmount'], 'Returns': []}, {'Name': '_redeem', 'Visibility': 'internal', 'Purpose': 'Redeems tokens from the prize pool.', 'Parameters': ['uint256 redeemAmount'], 'Returns': ['uint256']}, {'Name': 'onlyControlledToken', 'Visibility': 'modifier', 'Purpose': 'Ensures the function is called with a controlled token.', 'Parameters': ['address controlledToken'], 'Returns': []}, {'Name': 'onlyPrizeStrategy', 'Visibility': 'modifier', 'Purpose': 'Ensures the function is called by the prize strategy.', 'Parameters': [], 'Returns': []}, {'Name': 'canAddLiquidity', 'Visibility': 'modifier', 'Purpose': 'Ensures liquidity can be added without exceeding the cap.', 'Parameters': ['uint256 _amount'], 'Returns': []}, {'Name': 'onlyReserve', 'Visibility': 'modifier', 'Purpose': 'Ensures the function is called by the reserve.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['RegistryInterface', 'ReserveInterface', 'TokenListenerInterface', 'ControlledToken', 'TokenControllerInterface', 'ICompLike', 'IERC20Upgradeable', 'IERC721Upgradeable'], 'SpecialMechanisms': ['The contract uses a credit system to manage user balances and limits.', 'It implements timelocked funds with specific unlock timestamps.', 'The contract uses a liquidity cap to control the total amount of funds in the pool.', 'It includes a prize strategy for handling awards and external token transfers.'], 'Questions': ['How is the credit rate and limit determined for each controlled token?', 'What is the exact mechanism for calculating the early exit fee?', 'How does the prize strategy interact with the prize pool?', 'Are there any specific security considerations for the timelocked funds?', 'How is the reserve fee calculated and distributed?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in `withdrawInstantlyFrom`', 'Severity': 'High', 'Description': 'The `withdrawInstantlyFrom` function transfers tokens to the user before updating the internal state, potentially allowing a reentrancy attack if the token contract is malicious. Although some instances use the `nonReentrant` modifier, the state update after the transfer remains a risk.', 'Impact': 'An attacker could exploit this to withdraw more funds than entitled, leading to financial loss.', 'Location': 'Function: `withdrawInstantlyFrom`'}, {'Issue': 'Lack of Input Validation in `initialize` Function', 'Severity': 'Medium', 'Description': 'The `initialize` function does not validate the `_controlledTokens` array, which could lead to the addition of invalid or malicious tokens. Some instances also lack validation for `_maxExitFeeMantissa` and `_maxTimelockDuration`.', 'Impact': 'Invalid or malicious tokens could be added, leading to unexpected behavior or vulnerabilities.', 'Location': 'Function: `initialize`'}, {'Issue': 'Unbounded Loops in `_tokenTotalSupply` and `_sweepTimelockBalances`', 'Severity': 'Medium', 'Description': 'Functions `_tokenTotalSupply` and `_sweepTimelockBalances` iterate over arrays without size limits, which could lead to gas exhaustion and denial of service if the arrays grow too large.', 'Impact': 'High gas costs or transaction failures, potentially disrupting contract operations.', 'Location': 'Functions: `_tokenTotalSupply`, `_sweepTimelockBalances`'}, {'Issue': 'Potential Integer Overflow in `_mintTimelock` and `_calculateAccruedCredit`', 'Severity': 'Medium', 'Description': 'Functions `_mintTimelock` and `_calculateAccruedCredit` perform arithmetic operations without explicit overflow checks, which could lead to incorrect calculations if values exceed `uint256` limits.', 'Impact': 'Incorrect calculations could result in loss of funds or unfair advantages.', 'Location': 'Functions: `_mintTimelock`, `_calculateAccruedCredit`'}, {'Issue': 'Unrestricted Access to `setPrizeStrategy` Function', 'Severity': 'Medium', 'Description': 'The `setPrizeStrategy` function allows the owner to set a new prize strategy without sufficient validation, potentially introducing a malicious or incompatible strategy.', 'Impact': 'A malicious or faulty strategy could disrupt contract functionality or lead to loss of funds.', 'Location': 'Function: `setPrizeStrategy`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Critical functions such as `_addControlledToken`, `_mintTimelock`, and `_setLiquidityCap` do not emit events, reducing transparency and auditability.', 'Impact': 'Difficulty in tracking state changes and auditing contract behavior.', 'Location': 'Functions: `_addControlledToken`, `_mintTimelock`, `_setLiquidityCap`'}, {'Issue': 'Potential Front-Running in `captureAwardBalance` and `setPrizeStrategy`', 'Severity': 'Low', 'Description': 'Functions `captureAwardBalance` and `setPrizeStrategy` are susceptible to front-running, where an attacker could manipulate inputs or outcomes before legitimate transactions are processed.', 'Impact': 'Unfair advantages or incorrect calculations in prize distributions.', 'Location': 'Functions: `captureAwardBalance`, `setPrizeStrategy`'}, {'Issue': 'Uninitialized Storage Variables', 'Severity': 'High', 'Description': 'Several storage variables are not explicitly initialized, which could lead to unpredictable behavior if the contract is upgraded or storage layout changes.', 'Impact': 'Data corruption or loss, leading to potential vulnerabilities.', 'Location': 'Throughout the contract, especially in structs like `CreditPlan` and `CreditBalance`.'}, {'Issue': 'Insufficient Access Control in `setCreditPlanOf` and `setLiquidityCap`', 'Severity': 'Medium', 'Description': 'Functions `setCreditPlanOf` and `setLiquidityCap` lack proper access control or validation, potentially allowing unauthorized or unsafe modifications.', 'Impact': 'Unauthorized changes could disrupt contract functionality or lead to loss of funds.', 'Location': 'Functions: `setCreditPlanOf`, `setLiquidityCap`'}, {'Issue': 'Potential Denial of Service in External Calls', 'Severity': 'Low', 'Description': 'External calls in functions like `depositTo` and `withdrawWithTimelockFrom` do not handle failures gracefully, which could lead to denial of service if the external call fails.', 'Impact': 'Transaction failures or loss of functionality.', 'Location': 'Functions: `depositTo`, `withdrawWithTimelockFrom`'}], 'IssueNumber': 60, 'OutputList': 10}",632.0667650699615,"### **Output**

---

**[H-04] Withdraw Timelock Can Be Circumvented**

**Report Description**:
The `withdrawWithTimelockFrom` function in the `PrizePool` contract allows users to circumvent the timelock mechanism. By first calling `withdrawWithTimelockFrom` with the full balance and then calling it again with an amount of `0`, the user can reset the `unlockTimestamp` to the current block time. This allows the user to withdraw their entire deposit immediately without waiting for the timelock period. This behavior undermines the purpose of the timelock, as users can withdraw funds immediately after contributing, leading to significant issues for the protocol, such as reduced investment in the strategy to earn interest.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of circumventing the timelock mechanism in the `withdrawWithTimelockFrom` function. While there is a mention of potential denial of service in external calls, it does not cover the critical vulnerability of bypassing the timelock, which is a significant security concern.

---

**[M-07] Using `transferFrom` on ERC721 Tokens**

**Report Description**:
In the `awardExternalERC721` function of the `PrizePool` contract, the `transferFrom` keyword is used instead of `safeTransferFrom` when awarding external ERC721 tokens to winners. If a winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be permanently locked, leading to loss of assets.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of using `transferFrom` instead of `safeTransferFrom` for ERC721 tokens. This oversight could lead to tokens being locked in contracts that do not implement the necessary logic to handle ERC721 tokens, which is a critical security concern.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-04] Withdraw Timelock Can Be Circumvented**
- **[M-07] Using `transferFrom` on ERC721 Tokens**

---

### **Conclusion**
The provided `response_list` does not adequately address the issues identified in the `issue` report. Specifically, the critical vulnerabilities related to circumventing the timelock mechanism and the improper use of `transferFrom` for ERC721 tokens are not covered. These gaps highlight the need for a more comprehensive review of the contract's security mechanisms to ensure all potential risks are mitigated.","```
None.
```",0.0
