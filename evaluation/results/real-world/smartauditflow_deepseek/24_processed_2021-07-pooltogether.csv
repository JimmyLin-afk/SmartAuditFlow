nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
SwappableYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";

/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.
/// @dev This contract adheres to the PoolTogether yield source interface.
/// @dev This contract inherits AssetManager which extends OwnableUpgradable.
/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.
contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /// @notice Emitted when the swappable yield source is initialized.
  /// @param yieldSource Address of yield source used to initialize this swappable yield source.
  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param owner Swappable yield source owner.
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  /// @notice Emitted when a yield source has been successfuly set.
  /// @param yieldSource Yield source address that was set.
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.
  /// @param yieldSource Yield source address that provided funds.
  /// @param amount Amount of funds transferred.
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.
  /// @param from Address that transferred funds.
  /// @param to Address that received funds.
  /// @param amount Amount of tokens transferred.
  /// @param token ERC20 token transferred.
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  /// @notice Yield source interface.
  IYieldSource public yieldSource;

  /// @notice Mock Initializer to initialize implementations used by minimal proxies.
  function freeze() public initializer {
    //no-op
  }

  /// @notice Hack to determine if address passed is an actual yield source.
  /// @dev If depositTokenAddressData.length is not superior to 0, then staticcall didn't return any data.
  /// @param _yieldSource Yield source address to check.
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  /// @notice Initializes the swappable yield source with the yieldSource address provided.
  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.
  /// @param _yieldSource Yield source address used to initialize this swappable yield source.
  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param _owner Swappable yield source owner.
  /// @return true if operation is successful.
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).
  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.
  /// @return true if operation is successful.
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.
  /// @param tokens Amount of tokens.
  /// @return Number of shares.
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      // rate = tokens / shares
      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  /// @notice Calculates the number of tokens a user has in the yield source.
  /// @param shares Amount of shares.
  /// @return Number of tokens.
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      // tokens = shares * (yieldSourceTotalSupply / totalShares)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  /// @notice Mint tokens to the user.
  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.
  /// @param mintAmount Amount of asset tokens to be minted.
  /// @param to User whose balance will receive the tokens.
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  /// @notice Burn shares from user's balance.
  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.
  /// @param burnAmount Amount of asset tokens to be burnt.
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).
  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).
  /// @dev Shares from the swappable yield source are minted to the `to` address.
  /// @param amount Amount of `depositToken()` to be supplied.
  /// @param to User whose balance will receive the tokens.
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return ERC20 asset token address.
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).
  /// @return Underlying balance of swappable tokens.
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  /// @notice Redeems tokens from the current yield source.
  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.
  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.
  /// @param amount Amount of `depositToken()` to withdraw.
  /// @return Actual amount of tokens that were redeemed.
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  /// @notice Determine if passed yield source is different from current yield source.
  /// @param _yieldSource Yield source address to check.
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  /// @notice Set new yield source.
  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).
  /// @param _newYieldSource New yield source address to set.
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  /// @notice Set new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param _newYieldSource New yield source address to set.
  /// @return true if operation is successful.
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amount` requested.
  /// @dev `currentBalance` can be superior to `amount` if yield has been accruing between redeeming and checking for a mathematical error.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param _amount Amount of funds to transfer from passed yield source to current yield source.
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We only verify it is a different yield source in the public function cause we already check for it in `_setYieldSource` function.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param amount Amount of funds to transfer from passed yield source to current yield source.
  /// @return true if operation is successful.
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  /// @notice Swap current yield source for new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.
  /// @param _newYieldSource New yield source address to set and transfer funds to.
  /// @return true if operation is successful.
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param erc20Token ERC20 token to transfer.
  /// @param to Recipient of the tokens.
  /// @param amount Amount of tokens to transfer.
  /// @return true if operation is successful.
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}

",3524,331,"[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source

The function `swapYieldSource` SwappableYieldSource.sol` L307
Can be called by the owner (deployer / initializer) or Asset Manager. The function will take all funds from the old Yield Source, and transfer them to the new Yield source. Any contract that implement the function function depositToken() external returns (address) will pass the check
However, if either the owner or the assetManager have malicious intent, this function allows them to instantly rug all funds
Create a contract that implements the function depositToken() external returns (address)
Be the Owner or AssetManager
Call setYieldSource while pointing at your malicious contract
Profit
 [H-02] redeemToken can fail for certain tokens
The `SwappableYieldSource.redeemToken` function transfers tokens from the contract back to the sender, however, it uses the ERC20.transferFrom(address(this), msg.sender, redeemableBalance) function for this. Some deposit token implementations might fail as transferFrom checks if the contract approved itself for the redeemableBalance instead of skipping the allowance check in case the sender is the from address.  [H-03] setYieldSource leads to temporary wrong results
 The use of `setYieldSource` leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.
The function balanceOfToken will show the wrong results, because it is based on _sharesToToken, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.
More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls _mintShares, which calls _tokenToShares, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).
  [H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()
 `transferFunds()` will transfer funds from a specified yield source _yieldSource to the current yield source set in the contract _currentYieldSource. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.  [M-01] Single-step process for critical ownership transfer/renounce is risky
 The `SwappableYieldSource` allows owners and asset managers to set/swap/transfer yield sources/funds. As such, the contract ownership plays a critical role in the protocol.
Given that AssetManager is derived from Ownable, the ownership management of this contract defaults to Ownable’s transferOwnership() and renounceOwnership() methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.  [M-02] Use of `safeApprove` will always cause `approveMax` to revert

Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as (1) Deprecated because of approve-like race condition and (2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.
The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0. See issue page for referenced code.

[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens

The supplyTokenTo function of SwappableYieldSource assumes that amount of _depositToken is transferred to itself after calling the safeTransferFrom function (and thus it supplies amount of token to the yield source). However, this may not be true if the _depositToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. SwappableYieldSource.sol L211-L212  [M-04] Old yield source still has infinite approval
 After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).

",8,,"pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";





contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  
  
  
  
  
  
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  
  
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  
  
  
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  
  
  
  
  
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  
  IYieldSource public yieldSource;

  
  function freeze() public initializer {
    
  }

  
  
  
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  
  
  
  
  
  
  
  
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  
  
  
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  
  
  
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  
  
  
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  
  
  
  
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  
  
  
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  
  
  
  
  
  
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  
  
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  
  
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  
  
  
  
  
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  
  
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  
  
  
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  
  
  
  
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  
  
  
  
  
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  
  
  
  
  
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  
  
  
  
  
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  
  
  
  
  
  
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",1938,4,4,,"{'ReviewingTheCode': ""The contract 'SwappableYieldSource' is an upgradeable ERC20 token that interacts with a yield source to manage and swap yield sources. It includes mechanisms for minting and burning shares, transferring funds between yield sources, and managing ERC20 tokens. The contract leverages OpenZeppelin's upgradeable contracts for ownership, ERC20 functionality, and reentrancy protection."", 'IdentifyingKeyComponents': {'ContractName': 'SwappableYieldSource', 'Purpose': 'To manage and swap yield sources while minting and burning ERC20 tokens representing shares in the yield source.', 'InheritanceAndImports': {'InheritsFrom': ['ERC20Upgradeable', 'IYieldSource', 'AssetManager', 'ReentrancyGuardUpgradeable'], 'Imports': ['@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol', '@pooltogether/fixed-point/contracts/FixedPoint.sol', '@pooltogether/yield-source-interface/contracts/IYieldSource.sol', './access/AssetManager.sol']}, 'StateVariables': [{'Name': 'yieldSource', 'Type': 'IYieldSource', 'Purpose': 'The current yield source that the contract interacts with.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the contract with a yield source, token details, and owner.', 'Parameters': ['IYieldSource _yieldSource', 'uint8 _decimals', 'string calldata _symbol', 'string calldata _name', 'address _owner'], 'Returns': ['bool']}, {'Name': 'approveMaxAmount', 'Visibility': 'external', 'Purpose': 'Approves the maximum amount of deposit tokens to the yield source.', 'Parameters': [], 'Returns': ['bool']}, {'Name': 'supplyTokenTo', 'Visibility': 'external', 'Purpose': 'Supplies tokens to the yield source and mints shares to the specified address.', 'Parameters': ['uint256 amount', 'address to'], 'Returns': []}, {'Name': 'redeemToken', 'Visibility': 'external', 'Purpose': 'Redeems tokens from the yield source and burns the corresponding shares.', 'Parameters': ['uint256 amount'], 'Returns': ['uint256']}, {'Name': 'setYieldSource', 'Visibility': 'external', 'Purpose': 'Sets a new yield source.', 'Parameters': ['IYieldSource _newYieldSource'], 'Returns': ['bool']}, {'Name': 'swapYieldSource', 'Visibility': 'external', 'Purpose': 'Swaps the current yield source with a new one and transfers funds.', 'Parameters': ['IYieldSource _newYieldSource'], 'Returns': ['bool']}, {'Name': 'transferERC20', 'Visibility': 'external', 'Purpose': 'Transfers ERC20 tokens from the contract to a specified address.', 'Parameters': ['IERC20Upgradeable erc20Token', 'address to', 'uint256 amount'], 'Returns': ['bool']}, {'Name': '_requireYieldSource', 'Visibility': 'internal', 'Purpose': 'Ensures that the provided yield source is valid.', 'Parameters': ['IYieldSource _yieldSource'], 'Returns': []}, {'Name': '_tokenToShares', 'Visibility': 'internal', 'Purpose': 'Converts tokens to shares based on the current exchange rate.', 'Parameters': ['uint256 tokens'], 'Returns': ['uint256']}, {'Name': '_sharesToToken', 'Visibility': 'internal', 'Purpose': 'Converts shares to tokens based on the current exchange rate.', 'Parameters': ['uint256 shares'], 'Returns': ['uint256']}, {'Name': '_mintShares', 'Visibility': 'internal', 'Purpose': 'Mints shares to a specified address.', 'Parameters': ['uint256 mintAmount', 'address to'], 'Returns': []}, {'Name': '_burnShares', 'Visibility': 'internal', 'Purpose': ""Burns shares from the caller's address."", 'Parameters': ['uint256 burnAmount'], 'Returns': []}, {'Name': '_transferFunds', 'Visibility': 'internal', 'Purpose': 'Transfers funds from the current yield source to a new one.', 'Parameters': ['IYieldSource _yieldSource', 'uint256 _amount'], 'Returns': []}]}, 'ExternalInteractions': ['IYieldSource: Interface for interacting with yield sources.', 'IERC20Upgradeable: Interface for interacting with ERC20 tokens.', 'FixedPoint: Library for fixed-point arithmetic.'], 'SpecialMechanisms': [""Upgradeable Contracts: The contract uses OpenZeppelin's upgradeable contracts for ERC20, ownership, and reentrancy protection."", 'FixedPoint Arithmetic: Uses fixed-point arithmetic for converting between tokens and shares.', 'ReentrancyGuard: Protects against reentrancy attacks in functions that interact with external contracts.'], 'Questions': ['How is the exchange rate between tokens and shares calculated in FixedPoint.calculateMantissa?', ""What is the purpose of the 'freeze' function, and why is it empty?"", 'Are there any specific security considerations when swapping yield sources?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability', 'Severity': 'High', 'Description': 'Multiple functions, including `redeemToken`, `supplyTokenTo`, and `transferERC20`, are vulnerable to reentrancy attacks due to insufficient use of the `nonReentrant` modifier or unsafe external calls before state updates. Malicious actors could exploit this to drain funds or manipulate contract state.', 'Impact': 'An attacker could drain funds from the contract or cause unexpected behavior by re-entering functions before state updates.', 'Location': 'Functions `redeemToken`, `supplyTokenTo`, `transferERC20`, `transferFunds`'}, {'Issue': 'Uninitialized Contract', 'Severity': 'High', 'Description': 'The `freeze` function is marked as an `initializer` but does not perform any initialization, leaving the contract in an uninitialized state. This could lead to unexpected behavior or vulnerabilities.', 'Impact': 'The contract may not function as intended, leading to potential security risks or loss of funds.', 'Location': 'Function `freeze()`'}, {'Issue': 'Unbounded Token Approval', 'Severity': 'Medium', 'Description': 'Functions like `initialize`, `_setYieldSource`, and `approveMaxAmount` grant unlimited approval to the yield source for the deposit token. This poses a risk if the yield source is compromised or behaves maliciously.', 'Impact': 'A compromised yield source could drain all approved tokens from the contract.', 'Location': 'Functions `initialize`, `_setYieldSource`, `approveMaxAmount`'}, {'Issue': 'Insufficient Validation of Yield Source', 'Severity': 'Medium', 'Description': 'The `_requireYieldSource` function checks only for non-zero deposit token addresses but does not validate the integrity, functionality, or security of the yield source contract. This could allow malicious or faulty yield sources to be integrated.', 'Impact': 'Integration of a malicious or faulty yield source could lead to loss of funds or other security issues.', 'Location': 'Function `_requireYieldSource(IYieldSource _yieldSource)`'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'Functions like `supplyTokenTo`, `redeemToken`, and `transferERC20` lack proper validation of input parameters (e.g., `amount`, `to` address), which could lead to unexpected behavior or exploitation.', 'Impact': 'Potential loss of funds or unintended behavior due to invalid inputs.', 'Location': 'Functions `supplyTokenTo`, `redeemToken`, `transferERC20`'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': 'Functions `_tokenToShares` and `_sharesToToken` perform arithmetic operations without explicit checks for overflow/underflow, despite using `SafeMathUpgradeable`. Edge cases (e.g., zero values) are not handled, which could lead to incorrect calculations.', 'Impact': 'Incorrect calculations could result in unfair token distribution or loss of funds.', 'Location': 'Functions `_tokenToShares`, `_sharesToToken`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Critical functions like `freeze`, `approveMaxAmount`, and `setYieldSource` do not emit events, reducing transparency and making it difficult to track state changes.', 'Impact': 'Reduced auditability and difficulty in monitoring contract activity.', 'Location': 'Functions `freeze`, `approveMaxAmount`, `setYieldSource`'}, {'Issue': 'Inconsistent Use of `nonReentrant` Modifier', 'Severity': 'Low', 'Description': 'The `nonReentrant` modifier is used inconsistently across functions (e.g., present in `supplyTokenTo` but missing in `transferFunds`), potentially leaving some functions vulnerable to reentrancy.', 'Impact': 'Potential reentrancy attacks in unprotected functions.', 'Location': 'Functions `supplyTokenTo`, `transferFunds`, `swapYieldSource`'}, {'Issue': 'Potential Front-Running in Yield Source Swap', 'Severity': 'Low', 'Description': 'Functions like `swapYieldSource` and `setYieldSource` lack protection against front-running, allowing attackers to manipulate transaction order for unfair advantage.', 'Impact': 'Potential loss of funds or unfair advantage to attackers.', 'Location': 'Functions `swapYieldSource`, `setYieldSource`'}], 'IssueNumber': 10, 'OutputList': 9}",667.2677290439606,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source**

**Report Description**:  
The `swapYieldSource` function in `SwappableYieldSource.sol` allows the owner or asset manager to swap the yield source at any time, transferring all funds from the old yield source to the new one. If either the owner or asset manager has malicious intent, they can exploit this function to rug-pull all funds by pointing to a malicious contract that implements the `depositToken` function.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of malicious owner or asset manager exploitation in `swapYieldSource`. This is a critical oversight, as the issue highlights a significant security risk that could lead to fund loss.

---

#### **[H-02] redeemToken can fail for certain tokens**

**Report Description**:  
The `redeemToken` function in `SwappableYieldSource` uses `ERC20.transferFrom` to transfer tokens back to the sender. However, some token implementations may fail because `transferFrom` checks if the contract approved itself for the `redeemableBalance`, even when the sender is the `from` address. This could lead to transaction failures for certain tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `transferFrom` failing for certain tokens due to allowance checks. This is a missed opportunity to highlight a potential compatibility issue with specific token implementations.

---

#### **[H-03] setYieldSource leads to temporary wrong results**

**Report Description**:  
The `setYieldSource` function changes the underlying yield source but does not immediately transfer the underlying balances, leaving the contract in a temporary inconsistent state. This causes `balanceOfToken` and `supplyTokenTo` to return incorrect results, potentially allowing users to drain funds later.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of temporary inconsistency in `setYieldSource`. This is a critical oversight, as the issue highlights a potential vulnerability that could lead to fund loss.

---

#### **[H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()**

**Report Description**:  
The `transferFunds` function transfers funds from one yield source to another but fails to check if the deposit tokens are the same. If the specified yield source's assets are of higher valuation, a malicious owner or asset manager could exploit this to pocket the difference.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing deposit token validation in `transferFunds`. This is a significant oversight, as the issue highlights a potential exploit that could lead to fund loss.

---

#### **[M-01] Single-step process for critical ownership transfer/renounce is risky**

**Report Description**:  
The `SwappableYieldSource` contract uses `Ownable`'s `transferOwnership` and `renounceOwnership` methods, which are single-step processes. This is risky because any mistake in transferring or renouncing ownership is irrecoverable, and ownership plays a critical role in the protocol.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of single-step ownership transfer/renouncement. This is a missed opportunity to highlight a critical security risk in the contract's ownership management.

---

#### **[M-02] Use of safeApprove will always cause approveMax to revert**

**Report Description**:  
The `mStableYieldSource` uses OpenZeppelin’s `safeApprove`, which is deprecated and reverts if the current allowance is not zero. This prevents `approveMax` from functioning as intended, as it cannot increase the allowance unless it is reset to zero.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `safeApprove` causing `approveMax` to revert. This is a missed opportunity to highlight a deprecated and problematic function usage.

---

#### **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**

**Report Description**:  
The `supplyTokenTo` function assumes that the full `amount` of `_depositToken` is transferred to itself after calling `safeTransferFrom`. However, if the token is transfer-on-fee or deflationary, the received amount may be less than the accounted amount, leading to inconsistent balances.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of inconsistent balances with transfer-on-fee or deflationary tokens. This is a missed opportunity to highlight a potential vulnerability in token handling.

---

#### **[M-04] Old yield source still has infinite approval**

**Report Description**:  
After swapping a yield source, the old yield source still has infinite approval. This poses a risk if the old yield source is compromised, as it could be used in large-scale attacks.

**Match in Response List**:  
Matches with the issue titled **""Unbounded Token Approval""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unbounded token approval but does not specifically address the risk of infinite approval remaining for old yield sources after swapping. This is a partial match, as the core issue is related but not fully covered.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-04] Old yield source still has infinite approval**

**Missed Issues from Issue Report**:  
- **[H-01] onlyOwnerOrAssetManager can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source**  
- **[H-02] redeemToken can fail for certain tokens**  
- **[H-03] setYieldSource leads to temporary wrong results**  
- **[H-04] SwappableYieldSource: Missing same deposit token check in transferFunds()**  
- **[M-01] Single-step process for critical ownership transfer/renounce is risky**  
- **[M-02] Use of safeApprove will always cause approveMax to revert**  
- **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**

---

### **Conclusion**  
The response list fails to address the majority of the issues in the issue report, particularly the high-severity vulnerabilities related to malicious owner/asset manager exploitation, temporary inconsistencies, and missing deposit token checks. The only partial match is for the issue of unbounded token approval, but even this does not fully cover the specific risk of infinite approval for old yield sources. Overall, the response list is insufficient in terms of coverage, accuracy, and sufficiency.","```
None.
```",0.0
