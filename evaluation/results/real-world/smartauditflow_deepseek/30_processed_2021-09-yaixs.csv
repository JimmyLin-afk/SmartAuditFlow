nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
Controller.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IHarvester.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IManager.sol"";

/**
 * @title Controller
 * @notice This controller allows multiple strategies to be used
 * for a single vault supporting multiple tokens.
 */
contract Controller is IController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IManager public immutable override manager;

    bool public globalInvestEnabled;
    uint256 public maxStrategies;

    struct VaultDetail {
        address converter;
        uint256 balance;
        address[] strategies;
        mapping(address => uint256) balances;
        mapping(address => uint256) index;
        mapping(address => uint256) caps;
    }

    // vault => Vault
    mapping(address => VaultDetail) internal _vaultDetails;
    // strategy => vault
    mapping(address => address) internal _vaultStrategies;

    /**
     * @notice Logged when harvest is called for a strategy
     */
    event Harvest(address indexed strategy);

    /**
     * @notice Logged when a strategy is added for a vault
     */
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);

    /**
     * @notice Logged when a strategy is removed for a vault
     */
    event StrategyRemoved(address indexed vault, address indexed strategy);

    /**
     * @notice Logged when strategies are reordered for a vault
     */
    event StrategiesReordered(
        address indexed vault,
        address indexed strategy1,
        address indexed strategy2
    );

    /**
     * @param _manager The address of the manager
     */
    constructor(
        address _manager
    )
        public
    {
        manager = IManager(_manager);
        globalInvestEnabled = true;
        maxStrategies = 10;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Adds a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The cap of the strategy
     * @param _timeout The timeout between harvests
     */
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _cap,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultDetails[_vault].converter != address(0), ""!converter"");
        // checking if strategy is already added
        require(_vaultStrategies[_strategy] == address(0), ""Strategy is already added""); 
        // get the index of the newly added strategy
        uint256 index = _vaultDetails[_vault].strategies.length;
        // ensure we haven't added too many strategies already
        require(index < maxStrategies, ""!maxStrategies"");
        // push the strategy to the array of strategies
        _vaultDetails[_vault].strategies.push(_strategy);
        // set the cap
        _vaultDetails[_vault].caps[_strategy] = _cap;
        // set the index
        _vaultDetails[_vault].index[_strategy] = index;
        // store the mapping of strategy to the vault
        _vaultStrategies[_strategy] = _vault;
        if (_timeout > 0) {
            // add it to the harvester
            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);
        }
        emit StrategyAdded(_vault, _strategy, _cap);
    }

    /**
     * @notice Withdraws token from a strategy to the treasury address as returned by the manager
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     */
    function inCaseStrategyGetStuck(
        address _strategy,
        address _token
    )
        external
        onlyStrategist
    {
        IStrategy(_strategy).withdraw(_token);
        IERC20(_token).safeTransfer(
            manager.treasury(),
            IERC20(_token).balanceOf(address(this))
        );
    }

    /**
     * @notice Withdraws token from the controller to the treasury
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function inCaseTokensGetStuck(
        address _token,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        IERC20(_token).safeTransfer(manager.treasury(), _amount);
    }

    /**
     * @notice Removes a strategy for a given token
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the index of the strategy to remove
        uint256 index = vaultDetail.index[_strategy];
        // get the index of the last strategy
        uint256 tail = vaultDetail.strategies.length.sub(1);
        // get the address of the last strategy
        address replace = vaultDetail.strategies[tail];
        // replace the removed strategy with the tail
        vaultDetail.strategies[index] = replace;
        // set the new index for the replaced strategy
        vaultDetail.index[replace] = index;
        // remove the duplicate replaced strategy
        vaultDetail.strategies.pop();
        // remove the strategy's index
        delete vaultDetail.index[_strategy];
        // remove the strategy's cap
        delete vaultDetail.caps[_strategy];
        // remove the strategy's balance
        delete vaultDetail.balances[_strategy];
        // remove the mapping of strategy to the vault
        delete _vaultStrategies[_strategy];
        // pull funds from the removed strategy to the vault
        IStrategy(_strategy).withdrawAll();
        // remove the strategy from the harvester
        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);
        emit StrategyRemoved(_vault, _strategy);
    }

    /**
     * @notice Reorders two strategies for a given vault
     * @param _vault The address of the vault
     * @param _strategy1 The address of the first strategy
     * @param _strategy2 The address of the second strategy
     */
    function reorderStrategies(
        address _vault,
        address _strategy1,
        address _strategy2
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultStrategies[_strategy1] == _vault, ""!_strategy1"");
        require(_vaultStrategies[_strategy2] == _vault, ""!_strategy2"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the indexes of the strategies
        uint256 index1 = vaultDetail.index[_strategy1];
        uint256 index2 = vaultDetail.index[_strategy2];
        // set the new addresses at their indexes
        vaultDetail.strategies[index1] = _strategy2;
        vaultDetail.strategies[index2] = _strategy1;
        // update indexes
        vaultDetail.index[_strategy1] = index2;
        vaultDetail.index[_strategy2] = index1;
        emit StrategiesReordered(_vault, _strategy1, _strategy2);
    }

    /**
     * @notice Sets/updates the cap of a strategy for a vault
     * @dev If the balance of the strategy is greater than the new cap (except if
     * the cap is 0), then withdraw the difference from the strategy to the vault.
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The new cap of the strategy
     */
    function setCap(
        address _vault,
        address _strategy,
        uint256 _cap,
        address _convert
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        _vaultDetails[_vault].caps[_strategy] = _cap;
        uint256 _balance = IStrategy(_strategy).balanceOf();
        // send excess funds (over cap) back to the vault
        if (_balance > _cap && _cap != 0) {
            uint256 _diff = _balance.sub(_cap);
            IStrategy(_strategy).withdraw(_diff);
            updateBalance(_vault, _strategy);
            _balance = IStrategy(_strategy).balanceOf();
            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);
            address _want = IStrategy(_strategy).want();
            _balance = IERC20(_want).balanceOf(address(this));
            if (_convert != address(0)) {
                IConverter _converter = IConverter(_vaultDetails[_vault].converter);
                IERC20(_want).safeTransfer(address(_converter), _balance);
                _balance = _converter.convert(_want, _convert, _balance, 1);
                IERC20(_convert).safeTransfer(_vault, _balance);
            } else {
                IERC20(_want).safeTransfer(_vault, _balance);
            }
        }
    }

    /**
     * @notice Sets/updates the converter for a given vault
     * @param _vault The address of the vault
     * @param _converter The address of the converter
     */
    function setConverter(
        address _vault,
        address _converter
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedConverters(_converter), ""!allowedConverters"");
        _vaultDetails[_vault].converter = _converter;
    }

    /**
     * @notice Sets/updates the global invest enabled flag
     * @param _investEnabled The new bool of the invest enabled flag
     */
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        notHalted
        onlyStrategist
    {
        globalInvestEnabled = _investEnabled;
    }

    /**
     * @notice Sets/updates the maximum number of strategies for a vault
     * @param _maxStrategies The new value of the maximum strategies
     */
    function setMaxStrategies(
        uint256 _maxStrategies
    )
        external
        notHalted
        onlyStrategist
    {
        maxStrategies = _maxStrategies;
    }

    function skim(
        address _strategy
    )
        external
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).skim();
        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));
    }

    /**
     * @notice Withdraws all funds from a strategy
     * @param _strategy The address of the strategy
     * @param _convert The token address to convert to
     */
    function withdrawAll(
        address _strategy,
        address _convert
    )
        external
        override
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).withdrawAll();
        uint256 _amount = IERC20(_want).balanceOf(address(this));
        address _vault = _vaultStrategies[_strategy];
        updateBalance(_vault, _strategy);
        if (_convert != address(0)) {
            IConverter _converter = IConverter(_vaultDetails[_vault].converter);
            IERC20(_want).safeTransfer(address(_converter), _amount);
            _amount = _converter.convert(_want, _convert, _amount, 1);
            IERC20(_convert).safeTransfer(_vault, _amount);
        } else {
            IERC20(_want).safeTransfer(_vault, _amount);
        }
        uint256 _balance = _vaultDetails[_vault].balance;
        if (_balance >= _amount) {
            _vaultDetails[_vault].balance = _balance.sub(_amount);
        } else {
            _vaultDetails[_vault].balance = 0;
        }
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Harvests the specified strategy
     * @param _strategy The address of the strategy
     */
    function harvestStrategy(
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        notHalted
        onlyHarvester
        onlyStrategy(_strategy)
    {
        uint256 _before = IStrategy(_strategy).balanceOf();
        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);
        uint256 _after = IStrategy(_strategy).balanceOf();
        address _vault = _vaultStrategies[_strategy];
        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));
        _vaultDetails[_vault].balances[_strategy] = _after;
        emit Harvest(_strategy);
    }

    /**
     * VAULT-ONLY FUNCTIONS
     */

    /**
     * @notice Invests funds into a strategy
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     * @param _amount The amount that will be invested
     */
    function earn(
        address _strategy,
        address _token,
        uint256 _amount
    )
        external
        override
        notHalted
        onlyStrategy(_strategy)
        onlyVault(_token)
    {
        // get the want token of the strategy
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);
            IERC20(_token).safeTransfer(address(_converter), _amount);
            // TODO: do estimation for received
            _amount = _converter.convert(_token, _want, _amount, 1);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);
        // call the strategy deposit function
        IStrategy(_strategy).deposit();
        updateBalance(msg.sender, _strategy);
    }

    /**
     * @notice Withdraws funds from a strategy
     * @dev If the withdraw amount is greater than the first strategy given
     * by getBestStrategyWithdraw, this function will loop over strategies
     * until the requested amount is met.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function withdraw(
        address _token,
        uint256 _amount
    )
        external
        override
        onlyVault(_token)
    {
        (
            address[] memory _strategies,
            uint256[] memory _amounts
        ) = getBestStrategyWithdraw(_token, _amount);
        for (uint i = 0; i < _strategies.length; i++) {
            // getBestStrategyWithdraw will return arrays larger than needed
            // if this happens, simply exit the loop
            if (_strategies[i] == address(0)) {
                break;
            }
            IStrategy(_strategies[i]).withdraw(_amounts[i]);
            updateBalance(msg.sender, _strategies[i]);
            address _want = IStrategy(_strategies[i]).want();
            if (_want != _token) {
                address _converter = _vaultDetails[msg.sender].converter;
                IERC20(_want).safeTransfer(_converter, _amounts[i]);
                // TODO: do estimation for received
                IConverter(_converter).convert(_want, _token, _amounts[i], 1);
            }
        }
        _amount = IERC20(_token).balanceOf(address(this));
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the rough balance of the sum of all strategies for a given vault
     * @dev This function is optimized to prevent looping over all strategy balances,
     * and instead the controller tracks the earn, withdraw, and harvest amounts.
     */
    function balanceOf()
        external
        view
        override
        returns (uint256 _balance)
    {
        return _vaultDetails[msg.sender].balance;
    }

    /**
     * @notice Returns the converter assigned for the given vault
     * @param _vault Address of the vault
     */
    function converter(
        address _vault
    )
        external
        view
        override
        returns (address)
    {
        return _vaultDetails[_vault].converter;
    }

    /**
     * @notice Returns the cap of a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function getCap(
        address _vault,
        address _strategy
    )
        external
        view
        returns (uint256)
    {
        return _vaultDetails[_vault].caps[_strategy];
    }

    /**
     * @notice Returns whether investing is enabled for the calling vault
     * @dev Should be called by the vault
     */
    function investEnabled()
        external
        view
        override
        returns (bool)
    {
        if (globalInvestEnabled) {
            return _vaultDetails[msg.sender].strategies.length > 0;
        }
        return false;
    }

    /**
     * @notice Returns all the strategies for a given vault
     * @param _vault The address of the vault
     */
    function strategies(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return _vaultDetails[_vault].strategies;
    }

    /**
     * @notice Returns the length of the strategies of the calling vault
     * @dev This function is expected to be called by a vault
     */
    function strategies()
        external
        view
        override
        returns (uint256)
    {
        return _vaultDetails[msg.sender].strategies.length;
    }

    /**
     * INTERNAL FUNCTIONS
     */

    /**
     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from
     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays
     * from this function will always be the same length as the amount of strategies for
     * a token. Check that _strategies[i] != address(0) when consuming to know when to
     * break out of the loop.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function getBestStrategyWithdraw(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (
            address[] memory _strategies,
            uint256[] memory _amounts
        )
    {
        // get the length of strategies for a single token
        address _vault = manager.vaults(_token);
        uint256 k = _vaultDetails[_vault].strategies.length;
        // initialize fixed-length memory arrays
        _strategies = new address[](k);
        _amounts = new uint256[](k);
        address _strategy;
        uint256 _balance;
        // scan forward from the the beginning of strategies
        for (uint i = 0; i < k; i++) {
            _strategy = _vaultDetails[_vault].strategies[i];
            _strategies[i] = _strategy;
            // get the balance of the strategy
            _balance = _vaultDetails[_vault].balances[_strategy];
            // if the strategy doesn't have the balance to cover the withdraw
            if (_balance < _amount) {
                // withdraw what we can and add to the _amounts
                _amounts[i] = _balance;
                _amount = _amount.sub(_balance);
            } else {
                // stop scanning if the balance is more than the withdraw amount
                _amounts[i] = _amount;
                break;
            }
        }
    }

    /**
     * @notice Updates the stored balance of a given strategy for a vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function updateBalance(
        address _vault,
        address _strategy
    )
        internal
    {
        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();
    }

    /**
     * MODIFIERS
     */

    /**
     * @notice Reverts if the protocol is halted
     */
    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    /**
     * @notice Reverts if the caller is not governance
     */
    modifier onlyGovernance() {
        require(msg.sender == manager.governance(), ""!governance"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the strategist
     */
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    /**
     * @notice Reverts if the strategy is not allowed in the manager
     */
    modifier onlyStrategy(address _strategy) {
        require(manager.allowedStrategies(_strategy), ""!allowedStrategy"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the harvester
     */
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the vault for the given token
     */
    modifier onlyVault(address _token) {
        require(msg.sender == manager.vaults(_token), ""!vault"");
        _;
    }
}

",4847,684,"[H-01] Controller.setCap sets wrong vault balance

Submitted by cmichel
The `Controller.setCap` function sets a cap for a strategy and withdraws any excess amounts (_diff). The vault balance is decreased by the entire strategy balance instead of by this _diff: ```
// @audit why not sub _diff?
_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);
```  [H-02] set cap breaks vault's Balance

In controller.sol's function setCap, the contract wrongly handles _vaultDetails[_vault].balance. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. See Controller.sol L262-L278. `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);`
This would result in vaultDetails[_vault].balance being far smaller than the strategy's value. A user would trigger the assertion at Controller.sol#475 and the fund would be locked in the strategy.
Though setCap is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.
  [H-04] Controller does not raise an error when there's insufficient liquidity

MEV, TOD attack

When a user tries to withdraw the token from the vault, the vault would withdraw the token from the controller if there's insufficient liquidity in the vault. However, the controller does not raise an error when there's insufficient liquidity in the controller/ strategies. The user would lose his shares while getting nothing.
An MEV searcher could apply this attack on any withdrawal. When an attacker found an unconfirmed tx that tries to withdraw 1M dai, he can do such sandwich attack.
Deposits USDC into the vault.
Withdraw all dai left in the vault/controller/strategy.
Place the vitims tx here. The victim would get zero dai while burning 1 M share. This would pump the share price.
Withdraw all liquidity.
All users would be vulnerable to MEV attackers. I consider this is a high-risk issue.  [H-09] `removeToken` would break the vault/protocol.

There's no safety check in Manager.sol's removeToken. `Manager.sol#L454-L487`
The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost.
Controller's balanceOf would no longer reflects the real value. Controller.sol#L488-L495 While _vaultDetails[msg.sender].balance; remains the same, user can nolonger withdraw those amount.
Share price in the vault would decrease drastically. The share price is calculated as totalValue / totalSupply Vault.sol#L217. While the totalSupply of the share remains the same, the total balance has drastically decreased.
Calling removeToken way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.

[M-08] Controller.inCaseStrategyGetStuck does not update balance

The `Controller.inCaseStrategyGetStuck` withdraws from a strategy but does not call updateBalance(_vault, _strategy) afterwards.

The _vaultDetails[_vault].balances[_strategy] variable does not correctly track the actual strategy balance anymore. I'm not sure what exactly this field is used for besides getting the withdraw amounts per strategy in getBestStrategyWithdraw. As the strategy contains a lower amount than stored in the field, Controller.withdraw will attempt to withdraw too much.
",5,,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IHarvester.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IManager.sol"";


contract Controller is IController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IManager public immutable override manager;

    bool public globalInvestEnabled;
    uint256 public maxStrategies;

    struct VaultDetail {
        address converter;
        uint256 balance;
        address[] strategies;
        mapping(address => uint256) balances;
        mapping(address => uint256) index;
        mapping(address => uint256) caps;
    }

    
    mapping(address => VaultDetail) internal _vaultDetails;
    
    mapping(address => address) internal _vaultStrategies;

    
    event Harvest(address indexed strategy);

    
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);

    
    event StrategyRemoved(address indexed vault, address indexed strategy);

    
    event StrategiesReordered(
        address indexed vault,
        address indexed strategy1,
        address indexed strategy2
    );

    
    constructor(
        address _manager
    )
        public
    {
        manager = IManager(_manager);
        globalInvestEnabled = true;
        maxStrategies = 10;
    }

    

    
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _cap,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultDetails[_vault].converter != address(0), ""!converter"");
        
        require(_vaultStrategies[_strategy] == address(0), ""Strategy is already added""); 
        
        uint256 index = _vaultDetails[_vault].strategies.length;
        
        require(index < maxStrategies, ""!maxStrategies"");
        
        _vaultDetails[_vault].strategies.push(_strategy);
        
        _vaultDetails[_vault].caps[_strategy] = _cap;
        
        _vaultDetails[_vault].index[_strategy] = index;
        
        _vaultStrategies[_strategy] = _vault;
        if (_timeout > 0) {
            
            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);
        }
        emit StrategyAdded(_vault, _strategy, _cap);
    }

    
    function inCaseStrategyGetStuck(
        address _strategy,
        address _token
    )
        external
        onlyStrategist
    {
        IStrategy(_strategy).withdraw(_token);
        IERC20(_token).safeTransfer(
            manager.treasury(),
            IERC20(_token).balanceOf(address(this))
        );
    }

    
    function inCaseTokensGetStuck(
        address _token,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        IERC20(_token).safeTransfer(manager.treasury(), _amount);
    }

    
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        
        uint256 index = vaultDetail.index[_strategy];
        
        uint256 tail = vaultDetail.strategies.length.sub(1);
        
        address replace = vaultDetail.strategies[tail];
        
        vaultDetail.strategies[index] = replace;
        
        vaultDetail.index[replace] = index;
        
        vaultDetail.strategies.pop();
        
        delete vaultDetail.index[_strategy];
        
        delete vaultDetail.caps[_strategy];
        
        delete vaultDetail.balances[_strategy];
        
        delete _vaultStrategies[_strategy];
        
        IStrategy(_strategy).withdrawAll();
        
        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);
        emit StrategyRemoved(_vault, _strategy);
    }

    
    function reorderStrategies(
        address _vault,
        address _strategy1,
        address _strategy2
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultStrategies[_strategy1] == _vault, ""!_strategy1"");
        require(_vaultStrategies[_strategy2] == _vault, ""!_strategy2"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        
        uint256 index1 = vaultDetail.index[_strategy1];
        uint256 index2 = vaultDetail.index[_strategy2];
        
        vaultDetail.strategies[index1] = _strategy2;
        vaultDetail.strategies[index2] = _strategy1;
        
        vaultDetail.index[_strategy1] = index2;
        vaultDetail.index[_strategy2] = index1;
        emit StrategiesReordered(_vault, _strategy1, _strategy2);
    }

    
    function setCap(
        address _vault,
        address _strategy,
        uint256 _cap,
        address _convert
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        _vaultDetails[_vault].caps[_strategy] = _cap;
        uint256 _balance = IStrategy(_strategy).balanceOf();
        
        if (_balance > _cap && _cap != 0) {
            uint256 _diff = _balance.sub(_cap);
            IStrategy(_strategy).withdraw(_diff);
            updateBalance(_vault, _strategy);
            _balance = IStrategy(_strategy).balanceOf();
            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);
            address _want = IStrategy(_strategy).want();
            _balance = IERC20(_want).balanceOf(address(this));
            if (_convert != address(0)) {
                IConverter _converter = IConverter(_vaultDetails[_vault].converter);
                IERC20(_want).safeTransfer(address(_converter), _balance);
                _balance = _converter.convert(_want, _convert, _balance, 1);
                IERC20(_convert).safeTransfer(_vault, _balance);
            } else {
                IERC20(_want).safeTransfer(_vault, _balance);
            }
        }
    }

    
    function setConverter(
        address _vault,
        address _converter
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedConverters(_converter), ""!allowedConverters"");
        _vaultDetails[_vault].converter = _converter;
    }

    
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        notHalted
        onlyStrategist
    {
        globalInvestEnabled = _investEnabled;
    }

    
    function setMaxStrategies(
        uint256 _maxStrategies
    )
        external
        notHalted
        onlyStrategist
    {
        maxStrategies = _maxStrategies;
    }

    function skim(
        address _strategy
    )
        external
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).skim();
        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));
    }

    
    function withdrawAll(
        address _strategy,
        address _convert
    )
        external
        override
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).withdrawAll();
        uint256 _amount = IERC20(_want).balanceOf(address(this));
        address _vault = _vaultStrategies[_strategy];
        updateBalance(_vault, _strategy);
        if (_convert != address(0)) {
            IConverter _converter = IConverter(_vaultDetails[_vault].converter);
            IERC20(_want).safeTransfer(address(_converter), _amount);
            _amount = _converter.convert(_want, _convert, _amount, 1);
            IERC20(_convert).safeTransfer(_vault, _amount);
        } else {
            IERC20(_want).safeTransfer(_vault, _amount);
        }
        uint256 _balance = _vaultDetails[_vault].balance;
        if (_balance >= _amount) {
            _vaultDetails[_vault].balance = _balance.sub(_amount);
        } else {
            _vaultDetails[_vault].balance = 0;
        }
    }

    

    
    function harvestStrategy(
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        notHalted
        onlyHarvester
        onlyStrategy(_strategy)
    {
        uint256 _before = IStrategy(_strategy).balanceOf();
        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);
        uint256 _after = IStrategy(_strategy).balanceOf();
        address _vault = _vaultStrategies[_strategy];
        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));
        _vaultDetails[_vault].balances[_strategy] = _after;
        emit Harvest(_strategy);
    }

    

    
    function earn(
        address _strategy,
        address _token,
        uint256 _amount
    )
        external
        override
        notHalted
        onlyStrategy(_strategy)
        onlyVault(_token)
    {
        
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);
            IERC20(_token).safeTransfer(address(_converter), _amount);
            
            _amount = _converter.convert(_token, _want, _amount, 1);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);
        
        IStrategy(_strategy).deposit();
        updateBalance(msg.sender, _strategy);
    }

    
    function withdraw(
        address _token,
        uint256 _amount
    )
        external
        override
        onlyVault(_token)
    {
        (
            address[] memory _strategies,
            uint256[] memory _amounts
        ) = getBestStrategyWithdraw(_token, _amount);
        for (uint i = 0; i < _strategies.length; i++) {
            
            
            if (_strategies[i] == address(0)) {
                break;
            }
            IStrategy(_strategies[i]).withdraw(_amounts[i]);
            updateBalance(msg.sender, _strategies[i]);
            address _want = IStrategy(_strategies[i]).want();
            if (_want != _token) {
                address _converter = _vaultDetails[msg.sender].converter;
                IERC20(_want).safeTransfer(_converter, _amounts[i]);
                
                IConverter(_converter).convert(_want, _token, _amounts[i], 1);
            }
        }
        _amount = IERC20(_token).balanceOf(address(this));
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    

    
    function balanceOf()
        external
        view
        override
        returns (uint256 _balance)
    {
        return _vaultDetails[msg.sender].balance;
    }

    
    function converter(
        address _vault
    )
        external
        view
        override
        returns (address)
    {
        return _vaultDetails[_vault].converter;
    }

    
    function getCap(
        address _vault,
        address _strategy
    )
        external
        view
        returns (uint256)
    {
        return _vaultDetails[_vault].caps[_strategy];
    }

    
    function investEnabled()
        external
        view
        override
        returns (bool)
    {
        if (globalInvestEnabled) {
            return _vaultDetails[msg.sender].strategies.length > 0;
        }
        return false;
    }

    
    function strategies(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return _vaultDetails[_vault].strategies;
    }

    
    function strategies()
        external
        view
        override
        returns (uint256)
    {
        return _vaultDetails[msg.sender].strategies.length;
    }

    

    
    function getBestStrategyWithdraw(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (
            address[] memory _strategies,
            uint256[] memory _amounts
        )
    {
        
        address _vault = manager.vaults(_token);
        uint256 k = _vaultDetails[_vault].strategies.length;
        
        _strategies = new address[](k);
        _amounts = new uint256[](k);
        address _strategy;
        uint256 _balance;
        
        for (uint i = 0; i < k; i++) {
            _strategy = _vaultDetails[_vault].strategies[i];
            _strategies[i] = _strategy;
            
            _balance = _vaultDetails[_vault].balances[_strategy];
            
            if (_balance < _amount) {
                
                _amounts[i] = _balance;
                _amount = _amount.sub(_balance);
            } else {
                
                _amounts[i] = _amount;
                break;
            }
        }
    }

    
    function updateBalance(
        address _vault,
        address _strategy
    )
        internal
    {
        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();
    }

    

    
    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    
    modifier onlyGovernance() {
        require(msg.sender == manager.governance(), ""!governance"");
        _;
    }

    
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    
    modifier onlyStrategy(address _strategy) {
        require(manager.allowedStrategies(_strategy), ""!allowedStrategy"");
        _;
    }

    
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    
    modifier onlyVault(address _token) {
        require(msg.sender == manager.vaults(_token), ""!vault"");
        _;
    }
}",3187,4,1,,"{'ReviewingTheCode': 'The provided Solidity code defines a `Controller` contract that manages strategies for vaults, handles token conversions, and interacts with various external contracts. It includes functionalities for adding, removing, and reordering strategies, setting caps, and managing withdrawals and deposits. The contract uses OpenZeppelin libraries for safe math and ERC20 token operations and interacts with several interfaces for vaults, strategies, converters, and harvesters.', 'IdentifyingKeyComponents': {'ContractName': 'Controller', 'Purpose': 'The `Controller` contract manages strategies for vaults, handles token conversions, and ensures proper interaction between vaults, strategies, and harvesters. It allows strategists to add, remove, and reorder strategies, set caps on strategies, and manage withdrawals and deposits.', 'InheritanceAndImports': {'InheritsFrom': ['IController'], 'Imports': ['@openzeppelin/contracts/math/SafeMath.sol', '@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/token/ERC20/SafeERC20.sol', '../interfaces/IController.sol', '../interfaces/IConverter.sol', '../interfaces/IVault.sol', '../interfaces/IHarvester.sol', '../interfaces/IStrategy.sol', '../interfaces/IManager.sol']}, 'StateVariables': [{'Name': 'manager', 'Type': 'IManager', 'Purpose': 'Immutable reference to the manager contract that handles governance and permissions.'}, {'Name': 'globalInvestEnabled', 'Type': 'bool', 'Purpose': 'Flag to enable or disable global investment.'}, {'Name': 'maxStrategies', 'Type': 'uint256', 'Purpose': 'Maximum number of strategies allowed per vault.'}, {'Name': '_vaultDetails', 'Type': 'mapping(address => VaultDetail)', 'Purpose': 'Mapping to store details of each vault, including strategies, balances, and caps.'}, {'Name': '_vaultStrategies', 'Type': 'mapping(address => address)', 'Purpose': 'Mapping to store the vault associated with each strategy.'}], 'FunctionsAndModifiers': [{'Name': 'addStrategy', 'Visibility': 'external', 'Purpose': 'Adds a new strategy to a vault with a specified cap and timeout.', 'Parameters': ['address _vault', 'address _strategy', 'uint256 _cap', 'uint256 _timeout'], 'Returns': []}, {'Name': 'removeStrategy', 'Visibility': 'external', 'Purpose': 'Removes a strategy from a vault and handles cleanup.', 'Parameters': ['address _vault', 'address _strategy', 'uint256 _timeout'], 'Returns': []}, {'Name': 'reorderStrategies', 'Visibility': 'external', 'Purpose': 'Reorders the strategies in a vault.', 'Parameters': ['address _vault', 'address _strategy1', 'address _strategy2'], 'Returns': []}, {'Name': 'setCap', 'Visibility': 'external', 'Purpose': 'Sets a cap on the amount a strategy can handle and adjusts balances accordingly.', 'Parameters': ['address _vault', 'address _strategy', 'uint256 _cap', 'address _convert'], 'Returns': []}, {'Name': 'withdrawAll', 'Visibility': 'external', 'Purpose': 'Withdraws all funds from a strategy and optionally converts them to another token.', 'Parameters': ['address _strategy', 'address _convert'], 'Returns': []}, {'Name': 'harvestStrategy', 'Visibility': 'external', 'Purpose': ""Harvests rewards from a strategy and updates the vault's balance."", 'Parameters': ['address _strategy', 'uint256 _estimatedWETH', 'uint256 _estimatedYAXIS'], 'Returns': []}, {'Name': 'notHalted', 'Visibility': 'modifier', 'Purpose': 'Ensures the contract is not halted before executing a function.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyStrategist', 'Visibility': 'modifier', 'Purpose': 'Restricts access to the strategist.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['IManager: Handles governance, permissions, and allowed contracts.', 'IConverter: Converts tokens between different types.', 'IStrategy: Manages strategy-specific operations like deposits, withdrawals, and harvesting.', 'IHarvester: Manages strategy timeouts and harvesting schedules.', 'IERC20: Standard ERC20 token interface for token transfers.'], 'SpecialMechanisms': ['Strategy Management: The contract allows adding, removing, and reordering strategies, which is a common pattern in DeFi for managing yield farming strategies.', 'Token Conversion: The contract uses a converter to handle token conversions when necessary, which is useful for strategies that involve multiple tokens.', 'Cap Management: The contract allows setting caps on strategies to limit the amount of funds they can handle, which is useful for risk management.'], 'Questions': ['How is the `manager` contract initialized and what are its exact responsibilities?', 'What is the purpose of the `_timeout` parameter in `addStrategy` and `removeStrategy`?', 'How does the `getBestStrategyWithdraw` function determine the best strategy for withdrawal?', ""What are the specific conditions under which `globalInvestEnabled` is toggled and how does it affect the contract's behavior?""]}","{'Findings': [{'Issue': 'Potential Reentrancy in `withdraw` and `withdrawAll` Functions', 'Severity': 'High', 'Description': 'The `withdraw` and `withdrawAll` functions interact with external contracts (strategies and converters) before updating the internal state, making them vulnerable to reentrancy attacks if the external contracts are malicious or compromised.', 'Impact': 'An attacker could exploit reentrancy to drain funds from the contract or manipulate its state, leading to financial loss.', 'Location': 'Functions: `withdraw`, `withdrawAll`'}, {'Issue': 'Unrestricted Access to Critical Functions', 'Severity': 'High', 'Description': 'Critical functions such as `addStrategy`, `removeStrategy`, `setCap`, `setConverter`, `setInvestEnabled`, and `setMaxStrategies` are only protected by the `onlyStrategist` modifier. If the strategist account is compromised, an attacker can manipulate these settings, potentially leading to fund loss or operational disruption.', 'Impact': 'Compromise of the strategist account could result in unauthorized changes, financial loss, or disruption of the protocol.', 'Location': 'Functions: `addStrategy`, `removeStrategy`, `setCap`, `setConverter`, `setInvestEnabled`, `setMaxStrategies`'}, {'Issue': 'Lack of Input Validation in `setCap` and `addStrategy` Functions', 'Severity': 'Medium', 'Description': 'The `setCap` and `addStrategy` functions do not validate input parameters (e.g., `_cap`, `_strategy`, `_convert`), which could lead to unexpected behavior or vulnerabilities if invalid or malicious values are provided.', 'Impact': 'Invalid inputs could cause financial risks, inefficiencies, or loss of funds.', 'Location': 'Functions: `setCap`, `addStrategy`'}, {'Issue': 'Unbounded Loops in `getBestStrategyWithdraw` Function', 'Severity': 'Medium', 'Description': 'The `getBestStrategyWithdraw` function iterates over all strategies associated with a vault, which could lead to high gas consumption or out-of-gas errors if the number of strategies is large.', 'Impact': 'High gas costs or out-of-gas errors could render the function unusable, potentially blocking withdrawals.', 'Location': 'Function: `getBestStrategyWithdraw`'}, {'Issue': 'Insufficient Access Control in `skim` Function', 'Severity': 'Medium', 'Description': ""The `skim` function allows any strategist to skim funds from any strategy without validating the strategy's association with a vault, potentially leading to unauthorized fund skimming."", 'Impact': 'Unauthorized skimming of funds could result in financial loss or mismanagement.', 'Location': 'Function: `skim`'}, {'Issue': 'Lack of Event Emission in Critical State-Changing Functions', 'Severity': 'Low', 'Description': 'Critical state-changing functions such as `setConverter`, `setInvestEnabled`, and `setMaxStrategies` do not emit events, reducing transparency and auditability.', 'Impact': 'Lack of event emission makes it difficult to track and audit changes to the contract state.', 'Location': 'Functions: `setConverter`, `setInvestEnabled`, `setMaxStrategies`'}, {'Issue': 'Potential Front-Running in `reorderStrategies` Function', 'Severity': 'Low', 'Description': 'The `reorderStrategies` function is susceptible to front-running attacks, where an attacker could manipulate the order of strategies before the intended transaction is processed.', 'Impact': ""Front-running could lead to unintended strategy reordering, affecting the contract's performance."", 'Location': 'Function: `reorderStrategies`'}, {'Issue': 'Potential Integer Overflow in Arithmetic Operations', 'Severity': 'Medium', 'Description': 'Some functions (e.g., `setCap`) perform arithmetic operations without explicit overflow checks, which could lead to incorrect calculations if values are large.', 'Impact': 'Integer overflow could result in incorrect state updates or financial loss.', 'Location': 'Functions: `setCap` and other arithmetic operations'}, {'Issue': 'Unchecked External Calls in `earn` and `inCaseStrategyGetStuck` Functions', 'Severity': 'High', 'Description': 'The `earn` and `inCaseStrategyGetStuck` functions make external calls without handling potential failures, which could lead to inconsistent states or loss of funds if the calls fail.', 'Impact': 'Failed external calls could disrupt operations or result in financial loss.', 'Location': 'Functions: `earn`, `inCaseStrategyGetStuck`'}], 'IssueNumber': 60, 'OutputList': 9}",655.6848750114441,"### **Output**

---

**[H-01] Controller.setCap sets wrong vault balance**

**Report Description**:  
The `Controller.setCap` function sets a cap for a strategy and withdraws any excess amounts (`_diff`). However, the vault balance is decreased by the entire strategy balance instead of by `_diff`. This results in `vaultDetails[_vault].balance` being far smaller than the strategy's value, potentially locking funds in the strategy. Although `setCap` is a permissioned function, it is likely to be called, leading to a high-severity issue.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation in `setCap` and `addStrategy` Functions""**.

**Validation**:  
**Partially Correct**. The response identifies the `setCap` function as having a lack of input validation, which is related to the issue. However, it does not specifically address the incorrect handling of the vault balance, which is the core vulnerability. The response misses critical details about the impact of this error on the vault's balance and the potential for funds to be locked.

---

**[H-02] setCap breaks vault's Balance**

**Report Description**:  
The `setCap` function in `Controller.sol` incorrectly handles `_vaultDetails[_vault].balance`. Instead of decreasing the balance by the difference in the strategy's balance (`_diff`), it subtracts the entire strategy balance. This results in `vaultDetails[_vault].balance` being far smaller than the strategy's value, potentially locking funds in the strategy. This is a high-severity issue.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation in `setCap` and `addStrategy` Functions""**.

**Validation**:  
**Partially Correct**. The response identifies the `setCap` function as having a lack of input validation, which is related to the issue. However, it does not specifically address the incorrect handling of the vault balance, which is the core vulnerability. The response misses critical details about the impact of this error on the vault's balance and the potential for funds to be locked.

---

**[H-04] Controller does not raise an error when there's insufficient liquidity**

**Report Description**:  
When a user withdraws tokens from the vault, the vault withdraws from the controller if there's insufficient liquidity. However, the controller does not raise an error when there's insufficient liquidity in the controller/strategies. This allows MEV searchers to perform sandwich attacks, causing users to lose their shares while receiving nothing. This is a high-severity issue.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue at all. The vulnerability related to insufficient liquidity and MEV attacks is entirely missed.

---

**[H-09] `removeToken` would break the vault/protocol**

**Report Description**:  
The `removeToken` function in `Manager.sol` lacks safety checks. Removing a token would lock it in the original vault, and the `Controller.balanceOf` would no longer reflect the real value. This would drastically decrease the share price in the vault and could break the entire protocol if the vault has already started. This is a high-severity issue.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue at all. The vulnerability related to `removeToken` and its potential to break the protocol is entirely missed.

---

**[M-08] Controller.inCaseStrategyGetStuck does not update balance**

**Report Description**:  
The `Controller.inCaseStrategyGetStuck` function withdraws from a strategy but does not call `updateBalance(_vault, _strategy)` afterward. This causes `_vaultDetails[_vault].balances[_strategy]` to incorrectly track the actual strategy balance, potentially leading to incorrect withdrawal amounts in `Controller.withdraw`.

**Match in Response List**:  
Matches with the issue titled **""Unchecked External Calls in `earn` and `inCaseStrategyGetStuck` Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unchecked external calls in the `inCaseStrategyGetStuck` function. It correctly explains the risks associated with not updating the internal state after external calls, which aligns with Solidity best practices for secure contract interactions.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-08] Controller.inCaseStrategyGetStuck does not update balance**

**Partially Correct Matches**:

- **[H-01] Controller.setCap sets wrong vault balance**  
- **[H-02] setCap breaks vault's Balance**

**Missed Issues from Issue Report**:

- **[H-04] Controller does not raise an error when there's insufficient liquidity**  
- **[H-09] `removeToken` would break the vault/protocol**

---","```
1. Unchecked External Calls in `earn` and `inCaseStrategyGetStuck` Functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is: `Unchecked External Calls in `earn` and `inCaseStrategyGetStuck` Functions`.
   - This issue appears at rank 9 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - At rank 9, there is 1 true positive.
   - \( P@9 = \frac{1}{9} \approx 0.1111 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the AP is simply the precision at rank 9.

**Average Precision (AP)**: 0.1111"
Vault.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./VaultToken.sol"";

import ""./interfaces/IManager.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/ExtendedIERC20.sol"";

/**
 * @title Vault
 * @notice The vault is where users deposit and withdraw
 * like-kind assets that have been added by governance.
 */
contract Vault is VaultToken, IVault {
    using Address for address;
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MAX = 10000;

    IManager public immutable override manager;

    // Strategist-updated variables
    address public override gauge;
    uint256 public min;
    uint256 public totalDepositCap;

    event Deposit(address indexed account, uint256 amount);
    event Withdraw(address indexed account, uint256 amount);
    event Earn(address indexed token, uint256 amount);

    /**
     * @param _name The name of the vault token for depositors
     * @param _symbol The symbol of the vault token for depositors
     * @param _manager The address of the vault manager contract
     */
    constructor(
        string memory _name,
        string memory _symbol,
        address _manager
    )
        public
        VaultToken(_name, _symbol)
    {
        manager = IManager(_manager);
        min = 9500;
        totalDepositCap = 10000000 ether;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the value of this vault's gauge
     * @dev Allow to be unset with the zero address
     * @param _gauge The address of the gauge
     */
    function setGauge(
        address _gauge
    )
        external
        notHalted
        onlyStrategist
    {
        gauge = _gauge;
    }

    /**
     * @notice Sets the value for min
     * @dev min is the minimum percent of funds to keep small withdrawals cheap
     * @param _min The new min value
     */
    function setMin(
        uint256 _min
    )
        external
        notHalted
        onlyStrategist
    {
        require(_min <= MAX, ""!_min"");
        min = _min;
    }

    /**
     * @notice Sets the value for the totalDepositCap
     * @dev totalDepositCap is the maximum amount of value that can be deposited
     * to the metavault at a time
     * @param _totalDepositCap The new totalDepositCap value
     */
    function setTotalDepositCap(
        uint256 _totalDepositCap
    )
        external
        notHalted
        onlyStrategist
    {
        totalDepositCap = _totalDepositCap;
    }

    /**
     * @notice Swaps tokens held within the vault
     * @param _token0 The token address to swap out
     * @param _token1 The token address to to
     * @param _expectedAmount The expected amount of _token1 to receive
     */
    function swap(
        address _token0,
        address _token1,
        uint256 _expectedAmount
    )
        external
        override
        notHalted
        onlyStrategist
        returns (uint256 _balance)
    {
        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));
        _balance = IERC20(_token0).balanceOf(address(this));
        IERC20(_token0).safeTransfer(address(_converter), _balance);
        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies
     */
    function earn(
        address _token,
        address _strategy
    )
        external
        override
        checkToken(_token)
        notHalted
        onlyHarvester
    {
        require(manager.allowedStrategies(_strategy), ""!_strategy"");
        IController _controller = IController(manager.controllers(address(this)));
        if (_controller.investEnabled()) {
            uint256 _balance = available(_token);
            IERC20(_token).safeTransfer(address(_controller), _balance);
            _controller.earn(_strategy, _token, _balance);
            emit Earn(_token, _balance);
        }
    }

    /**
     * USER-FACING FUNCTIONS
     */

    /**
     * @notice Deposits the given token into the vault
     * @param _token The address of the token
     * @param _amount The amount of tokens to deposit
     */
     function deposit(
        address _token,
        uint256 _amount
     )
        public
        override
        checkToken(_token)
        notHalted
        returns (uint256 _shares)
    {
        require(_amount > 0, ""!_amount"");

        uint256 _balance = balance();

        uint256 _before = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);

        if (_amount > 0) {
            _amount = _normalizeDecimals(_token, _amount);

            if (totalSupply() > 0) {
                _amount = (_amount.mul(totalSupply())).div(_balance);
            }

            _shares = _amount;
        }

        if (_shares > 0) {
            _mint(msg.sender, _shares);
            require(totalSupply() <= totalDepositCap, "">totalDepositCap"");
            emit Deposit(msg.sender, _shares);
        }
    }

    /**
     * @notice Deposits multiple tokens simultaneously to the vault
     * @dev Users must approve the vault to spend their stablecoin
     * @param _tokens The addresses of each token being deposited
     * @param _amounts The amounts of each token being deposited
     */
    function depositMultiple(
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
        override
        returns (uint256 _shares)
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i; i < _amounts.length; i++) {
            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));
        }
    }

    /**
     * @notice Withdraws an amount of shares to a given output token
     * @param _shares The amount of shares to withdraw
     * @param _output The address of the token to receive
     */
    function withdraw(
        uint256 _shares,
        address _output
    )
        public
        override
        checkToken(_output)
    {
        uint256 _amount = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();
        if (_withdrawalProtectionFee > 0) {
            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);
            _amount = _amount.sub(_withdrawalProtection);
        }

        uint256 _balance = IERC20(_output).balanceOf(address(this));
        if (_balance < _amount) {
            IController _controller = IController(manager.controllers(address(this)));
            uint256 _toWithdraw = _amount.sub(_balance);
            if (_controller.strategies() > 0) {
                _controller.withdraw(_output, _toWithdraw);
            }
            uint256 _after = IERC20(_output).balanceOf(address(this));
            uint256 _diff = _after.sub(_balance);
            if (_diff < _toWithdraw) {
                _amount = _after;
            }
        }

        IERC20(_output).safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /**
     * @notice Withdraw the entire balance for an account
     * @param _output The address of the desired token to receive
     */
    function withdrawAll(
        address _output
    )
        external
        override
    {
        withdraw(balanceOf(msg.sender), _output);
    }

    /**
     * VIEWS
     */

    /**
     * @notice Returns the amount of tokens available to be sent to strategies
     * @dev Custom logic in here for how much the vault allows to be borrowed
     * @dev Sets minimum required on-hand to keep small withdrawals cheap
     * @param _token The address of the token
     */
    function available(
        address _token
    )
        public
        view
        override
        returns (uint256)
    {
        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);
    }

    /**
     * @notice Returns the total balance of the vault, including strategies
     */
    function balance()
        public
        view
        override
        returns (uint256 _balance)
    {
        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());
    }

    /**
     * @notice Returns the balance of allowed tokens present on the vault only
     */
    function balanceOfThis()
        public
        view
        returns (uint256 _balance)
    {
        address[] memory _tokens = manager.getTokens(address(this));
        for (uint8 i; i < _tokens.length; i++) {
            address _token = _tokens[i];
            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
        }
    }

    /**
     * @notice Returns the rate of vault shares
     */
    function getPricePerFullShare()
        external
        view
        override
        returns (uint256)
    {
        if (totalSupply() > 0) {
            return balance().mul(1e18).div(totalSupply());
        } else {
            return balance();
        }
    }

    /**
     * @notice Returns an array of the tokens for this vault
     */
    function getTokens()
        external
        view
        override
        returns (address[] memory)
    {
        return manager.getTokens(address(this));
    }

    /**
     * @notice Returns the fee for withdrawing the given amount
     * @param _amount The amount to withdraw
     */
    function withdrawFee(
        uint256 _amount
    )
        external
        view
        override
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    function _normalizeDecimals(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (uint256)
    {
        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());
        if (_decimals < 18) {
            _amount = _amount.mul(10**(18-_decimals));
        }
        return _amount;
    }

    /**
     * MODIFIERS
     */

    modifier checkToken(address _token) {
        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), ""!_token"");
        _;
    }

    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",2561,408,"[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.


Impact

The v3 vault treats all valid tokens exactly the same. Depositing 1M DAI would get the same share as depositing 1M USDT. User can withdraw their share in another token. Though there's withdrawalProtectionFee (0.1 percent), the vault is still a no slippage stable coin exchange.
Also, I notice that 3crv_token is added to the vault in the test. Treating 3crv_token and all other stable coins the same would make the vault vulnerable to flashloan attack. 3crv_token is an lp token and at the point of writing, the price of it is 1.01. The arbitrage space is about 0.8 percent and makes the vault vulnerable to flashloan attacks.
Though the team may not add crv_token and dai to the same vault, its design makes the vault vulnerable. Strategies need to be designed with super caution or the vault would be vulnerable to attackers.
Given the possibility of a flashloan attack, I consider this a high-risk issue.
  [H-06] earn results in decreasing share price

Impact

For a dai vault that pairs with NativeStrategyCurve3Crv, every time earn() is called, shareholders would lose money. (about 2%)
There are two issues involved. The Vault contract and the controller contract doesn't handle the price difference between the want token and other tokens.
At Vault.sol L293, when a vault calculates its value, it sums up all tokens balance. However, when the controller calculates vaults' value (at Controller.sol L410-L436), it only adds the amount of strategy.want it received. (in this case, it's t3crv).
Under the current design, users who deposit dai to the vault would not get yield. Instead, they would keep losing money. I consider this a high-risk issue
 [H-07] Vault.balance() mixes normalized and standard amounts
Loops
Submitted by cmichel
The Vault.balance function uses the balanceOfThis function which scales (""normalizes"") all balances to 18 decimals.
for (uint8 i; i < _tokens.length; i++) {
    address _token = _tokens[i];
    // everything is padded to 18 decimals
    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
}

Note that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized. The code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).
 [H-08] Vault.withdraw mixes normalized and standard amounts
 The `Vault.balance` function uses the balanceOfThis function which scales (""normalizes"") all balances to 18 decimals.
for (uint8 i; i < _tokens.length; i++) {
    address _token = _tokens[i];
    // everything is padded to 18 decimals
    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
}

Note that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized, but it must be.
This leads to many issues through the contracts that use balance but don't treat these values as normalized values. For example, in Vault.withdraw, the computed _amount value is normalized (in 18 decimals). But the uint256 _balance = IERC20(_output).balanceOf(address(this)); value is not normalized but compared to the normalized _amount and even subtracted:
// @audit compares unnormalzied output to normalized output
if (_balance < _amount) {
    IController _controller = IController(manager.controllers(address(this)));
    // @audit cannot directly subtract unnormalized
    uint256 _toWithdraw = _amount.sub(_balance);
    if (_controller.strategies() > 0) {
        _controller.withdraw(_output, _toWithdraw);
    }
    uint256 _after = IERC20(_output).balanceOf(address(this));
    uint256 _diff = _after.sub(_balance);
    if (_diff < _toWithdraw) {
        _amount = _balance.add(_diff);
    }
}
 [M-03] Vault.withdraw sometimes burns too many shares

The Vault.withdraw function attempts to withdraw funds from the controller if there are not enough in the vault already. In the case the controller could not withdraw enough, i.e., where _diff < _toWithdraw, the user will receive less output tokens than their fair share would entitle them to (the initial _amount).
if (_diff < _toWithdraw) {
    // @audit burns too many shares for a below fair-share amount
    _amount = _balance.add(_diff);
}

Impact

The withdrawer receives fewer output tokens than they were entitled to.
",5,,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./VaultToken.sol"";

import ""./interfaces/IManager.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/ExtendedIERC20.sol"";


contract Vault is VaultToken, IVault {
    using Address for address;
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MAX = 10000;

    IManager public immutable override manager;

    
    address public override gauge;
    uint256 public min;
    uint256 public totalDepositCap;

    event Deposit(address indexed account, uint256 amount);
    event Withdraw(address indexed account, uint256 amount);
    event Earn(address indexed token, uint256 amount);

    
    constructor(
        string memory _name,
        string memory _symbol,
        address _manager
    )
        public
        VaultToken(_name, _symbol)
    {
        manager = IManager(_manager);
        min = 9500;
        totalDepositCap = 10000000 ether;
    }

    

    
    function setGauge(
        address _gauge
    )
        external
        notHalted
        onlyStrategist
    {
        gauge = _gauge;
    }

    
    function setMin(
        uint256 _min
    )
        external
        notHalted
        onlyStrategist
    {
        require(_min <= MAX, ""!_min"");
        min = _min;
    }

    
    function setTotalDepositCap(
        uint256 _totalDepositCap
    )
        external
        notHalted
        onlyStrategist
    {
        totalDepositCap = _totalDepositCap;
    }

    
    function swap(
        address _token0,
        address _token1,
        uint256 _expectedAmount
    )
        external
        override
        notHalted
        onlyStrategist
        returns (uint256 _balance)
    {
        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));
        _balance = IERC20(_token0).balanceOf(address(this));
        IERC20(_token0).safeTransfer(address(_converter), _balance);
        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);
    }

    

    
    function earn(
        address _token,
        address _strategy
    )
        external
        override
        checkToken(_token)
        notHalted
        onlyHarvester
    {
        require(manager.allowedStrategies(_strategy), ""!_strategy"");
        IController _controller = IController(manager.controllers(address(this)));
        if (_controller.investEnabled()) {
            uint256 _balance = available(_token);
            IERC20(_token).safeTransfer(address(_controller), _balance);
            _controller.earn(_strategy, _token, _balance);
            emit Earn(_token, _balance);
        }
    }

    

    
     function deposit(
        address _token,
        uint256 _amount
     )
        public
        override
        checkToken(_token)
        notHalted
        returns (uint256 _shares)
    {
        require(_amount > 0, ""!_amount"");

        uint256 _balance = balance();

        uint256 _before = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);

        if (_amount > 0) {
            _amount = _normalizeDecimals(_token, _amount);

            if (totalSupply() > 0) {
                _amount = (_amount.mul(totalSupply())).div(_balance);
            }

            _shares = _amount;
        }

        if (_shares > 0) {
            _mint(msg.sender, _shares);
            require(totalSupply() <= totalDepositCap, "">totalDepositCap"");
            emit Deposit(msg.sender, _shares);
        }
    }

    
    function depositMultiple(
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
        override
        returns (uint256 _shares)
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i; i < _amounts.length; i++) {
            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));
        }
    }

    
    function withdraw(
        uint256 _shares,
        address _output
    )
        public
        override
        checkToken(_output)
    {
        uint256 _amount = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();
        if (_withdrawalProtectionFee > 0) {
            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);
            _amount = _amount.sub(_withdrawalProtection);
        }

        uint256 _balance = IERC20(_output).balanceOf(address(this));
        if (_balance < _amount) {
            IController _controller = IController(manager.controllers(address(this)));
            uint256 _toWithdraw = _amount.sub(_balance);
            if (_controller.strategies() > 0) {
                _controller.withdraw(_output, _toWithdraw);
            }
            uint256 _after = IERC20(_output).balanceOf(address(this));
            uint256 _diff = _after.sub(_balance);
            if (_diff < _toWithdraw) {
                _amount = _after;
            }
        }

        IERC20(_output).safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }

    
    function withdrawAll(
        address _output
    )
        external
        override
    {
        withdraw(balanceOf(msg.sender), _output);
    }

    

    
    function available(
        address _token
    )
        public
        view
        override
        returns (uint256)
    {
        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);
    }

    
    function balance()
        public
        view
        override
        returns (uint256 _balance)
    {
        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());
    }

    
    function balanceOfThis()
        public
        view
        returns (uint256 _balance)
    {
        address[] memory _tokens = manager.getTokens(address(this));
        for (uint8 i; i < _tokens.length; i++) {
            address _token = _tokens[i];
            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
        }
    }

    
    function getPricePerFullShare()
        external
        view
        override
        returns (uint256)
    {
        if (totalSupply() > 0) {
            return balance().mul(1e18).div(totalSupply());
        } else {
            return balance();
        }
    }

    
    function getTokens()
        external
        view
        override
        returns (address[] memory)
    {
        return manager.getTokens(address(this));
    }

    
    function withdrawFee(
        uint256 _amount
    )
        external
        view
        override
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    function _normalizeDecimals(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (uint256)
    {
        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());
        if (_decimals < 18) {
            _amount = _amount.mul(10**(18-_decimals));
        }
        return _amount;
    }

    

    modifier checkToken(address _token) {
        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), ""!_token"");
        _;
    }

    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",1853,4,1,,"{'ReviewingTheCode': 'The provided smart contract is a Vault contract designed to manage deposits, withdrawals, and earnings of ERC20 tokens. It integrates with a Manager contract to enforce permissions and strategies, and it uses various OpenZeppelin libraries for safe math, address utilities, and ERC20 token interactions. The contract also interacts with external controllers, converters, and strategies to manage token conversions and investments.', 'IdentifyingKeyComponents': {'ContractName': 'Vault', 'Purpose': 'To manage the deposit, withdrawal, and investment of ERC20 tokens in a secure and controlled manner, integrating with external strategies and controllers.', 'InheritanceAndImports': {'InheritsFrom': ['VaultToken', 'IVault'], 'Imports': ['@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/math/SafeMath.sol', '@openzeppelin/contracts/utils/Address.sol', '@openzeppelin/contracts/token/ERC20/SafeERC20.sol', '@openzeppelin/contracts/GSN/Context.sol', './VaultToken.sol', './interfaces/IManager.sol', './interfaces/IController.sol', './interfaces/IConverter.sol', './interfaces/IVault.sol', './interfaces/ExtendedIERC20.sol']}, 'StateVariables': [{'Name': 'MAX', 'Type': 'uint256', 'Purpose': 'A constant representing the maximum value for certain calculations, set to 10000.'}, {'Name': 'manager', 'Type': 'IManager', 'Purpose': 'An immutable instance of the Manager contract to manage permissions and strategies.'}, {'Name': 'gauge', 'Type': 'address', 'Purpose': 'Address of the gauge contract used for staking.'}, {'Name': 'min', 'Type': 'uint256', 'Purpose': 'Minimum value used in calculations, initialized to 9500.'}, {'Name': 'totalDepositCap', 'Type': 'uint256', 'Purpose': 'Maximum total deposit cap, initialized to 10000000 ether.'}], 'FunctionsAndModifiers': [{'Name': 'setGauge', 'Visibility': 'external', 'Purpose': 'Sets the gauge address, restricted to the strategist and only when not halted.', 'Parameters': ['address _gauge'], 'Returns': []}, {'Name': 'setMin', 'Visibility': 'external', 'Purpose': 'Sets the minimum value, restricted to the strategist and only when not halted.', 'Parameters': ['uint256 _min'], 'Returns': []}, {'Name': 'setTotalDepositCap', 'Visibility': 'external', 'Purpose': 'Sets the total deposit cap, restricted to the strategist and only when not halted.', 'Parameters': ['uint256 _totalDepositCap'], 'Returns': []}, {'Name': 'swap', 'Visibility': 'external', 'Purpose': 'Swaps one token for another using a converter, restricted to the strategist and only when not halted.', 'Parameters': ['address _token0', 'address _token1', 'uint256 _expectedAmount'], 'Returns': ['uint256 _balance']}, {'Name': 'earn', 'Visibility': 'external', 'Purpose': 'Transfers tokens to a strategy for investment, restricted to the harvester and only when not halted.', 'Parameters': ['address _token', 'address _strategy'], 'Returns': []}, {'Name': 'deposit', 'Visibility': 'public', 'Purpose': 'Deposits tokens into the vault and mints shares to the depositor.', 'Parameters': ['address _token', 'uint256 _amount'], 'Returns': ['uint256 _shares']}, {'Name': 'depositMultiple', 'Visibility': 'external', 'Purpose': 'Deposits multiple tokens into the vault.', 'Parameters': ['address[] calldata _tokens', 'uint256[] calldata _amounts'], 'Returns': ['uint256 _shares']}, {'Name': 'withdraw', 'Visibility': 'public', 'Purpose': 'Withdraws tokens from the vault and burns the corresponding shares.', 'Parameters': ['uint256 _shares', 'address _output'], 'Returns': []}, {'Name': 'withdrawAll', 'Visibility': 'external', 'Purpose': 'Withdraws all tokens from the vault for the caller.', 'Parameters': ['address _output'], 'Returns': []}, {'Name': 'available', 'Visibility': 'public', 'Purpose': 'Returns the available balance of a token in the vault.', 'Parameters': ['address _token'], 'Returns': ['uint256']}, {'Name': 'balance', 'Visibility': 'public', 'Purpose': 'Returns the total balance of tokens in the vault and its controller.', 'Parameters': [], 'Returns': ['uint256 _balance']}, {'Name': 'balanceOfThis', 'Visibility': 'public', 'Purpose': 'Returns the balance of tokens held directly by the vault.', 'Parameters': [], 'Returns': ['uint256 _balance']}, {'Name': 'getPricePerFullShare', 'Visibility': 'external', 'Purpose': 'Returns the price per full share of the vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'getTokens', 'Visibility': 'external', 'Purpose': 'Returns the list of tokens managed by the vault.', 'Parameters': [], 'Returns': ['address[] memory']}, {'Name': 'withdrawFee', 'Visibility': 'external', 'Purpose': 'Calculates the withdrawal fee for a given amount.', 'Parameters': ['uint256 _amount'], 'Returns': ['uint256']}, {'Name': '_normalizeDecimals', 'Visibility': 'internal', 'Purpose': 'Normalizes the decimals of a token amount to 18 decimal places.', 'Parameters': ['address _token', 'uint256 _amount'], 'Returns': ['uint256']}, {'Name': 'checkToken', 'Visibility': 'modifier', 'Purpose': 'Ensures the token is allowed and managed by this vault.', 'Parameters': ['address _token'], 'Returns': []}, {'Name': 'notHalted', 'Visibility': 'modifier', 'Purpose': 'Ensures the contract is not halted.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyHarvester', 'Visibility': 'modifier', 'Purpose': 'Restricts access to the harvester.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyStrategist', 'Visibility': 'modifier', 'Purpose': 'Restricts access to the strategist.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['IManager', 'IController', 'IConverter', 'IERC20', 'ExtendedIERC20'], 'SpecialMechanisms': ['The contract uses the OpenZeppelin SafeMath library to prevent overflow/underflow issues.', 'It uses the SafeERC20 library for safe token transfers.', 'The contract implements a deposit cap and withdrawal fee mechanism.', 'It interacts with external strategies and controllers to manage investments and token conversions.'], 'Questions': ['What is the specific role of the gauge address in this contract?', 'How does the contract handle token decimals normalization in detail?', 'Are there any potential reentrancy risks in the deposit or withdraw functions?', 'What are the specific conditions under which the contract can be halted?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `withdraw` Function', 'Severity': 'High', 'Description': 'The `withdraw` function transfers tokens to the user before updating the internal state, potentially allowing a malicious contract to re-enter the function and drain funds before the state is updated.', 'Impact': 'Loss of funds due to reentrancy attacks.', 'Location': 'Function: `withdraw`'}, {'Issue': 'Potential Reentrancy in `deposit` Function', 'Severity': 'High', 'Description': 'The `deposit` function transfers tokens from the user to the contract before minting shares, which could allow a malicious token contract to re-enter the function and manipulate the share issuance.', 'Impact': 'Potential unauthorized minting of shares or loss of funds.', 'Location': 'Function: `deposit`'}, {'Issue': 'Unrestricted Access to `setGauge`, `setMin`, and `setTotalDepositCap` Functions', 'Severity': 'Medium', 'Description': 'These functions are only restricted by the `onlyStrategist` modifier without additional validation, allowing a compromised strategist to set arbitrary or malicious values for critical parameters.', 'Impact': ""Potential misuse or manipulation of the vault's configuration, leading to financial losses or operational disruptions."", 'Location': 'Functions: `setGauge`, `setMin`, `setTotalDepositCap`'}, {'Issue': 'Lack of Input Validation in `setMin` Function', 'Severity': 'Medium', 'Description': 'The `setMin` function does not validate that `_min` is greater than zero or within reasonable bounds, potentially leading to incorrect calculations in dependent functions.', 'Impact': 'Potential malfunction or incorrect calculations in functions that rely on the `min` value.', 'Location': 'Function: `setMin`'}, {'Issue': 'Potential Integer Overflow in `deposit` Function', 'Severity': 'Medium', 'Description': 'The `deposit` function performs arithmetic operations without checking for potential integer overflow, which could lead to incorrect share calculations.', 'Impact': 'Incorrect share issuance, leading to unfair distribution of vault tokens.', 'Location': 'Function: `deposit`'}, {'Issue': 'Potential Integer Overflow in `_normalizeDecimals` Function', 'Severity': 'Medium', 'Description': 'The `_normalizeDecimals` function multiplies `_amount` by `10^(18 - _decimals)`, which could result in an integer overflow if `_decimals` is small and `_amount` is large.', 'Impact': 'Incorrect token amount calculations, potentially leading to financial losses or contract malfunction.', 'Location': 'Function: `_normalizeDecimals`'}, {'Issue': 'Unbounded Loop in `balanceOfThis` Function', 'Severity': 'Medium', 'Description': 'The `balanceOfThis` function iterates over an array of tokens without checking its length, which could lead to excessive gas consumption or out-of-gas errors if the array is too large.', 'Impact': 'Denial of service or high gas costs.', 'Location': 'Function: `balanceOfThis`'}, {'Issue': 'Insufficient Validation in `swap` Function', 'Severity': 'Medium', 'Description': 'The `swap` function does not validate the input tokens (`_token0` and `_token1`) or the `_expectedAmount`, potentially leading to unexpected behavior or loss of funds.', 'Impact': ""Potential loss of funds or disruption of the vault's operations."", 'Location': 'Function: `swap`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Functions like `setGauge`, `setMin`, and `setTotalDepositCap` do not emit events when their values are changed, reducing transparency and auditability.', 'Impact': 'Reduced transparency and difficulty in tracking state changes.', 'Location': 'Functions: `setGauge`, `setMin`, `setTotalDepositCap`'}, {'Issue': 'Potential Front-Running in `deposit` and `withdraw` Functions', 'Severity': 'Low', 'Description': 'The `deposit` and `withdraw` functions calculate shares and amounts based on current balances, which could be manipulated by front-running transactions.', 'Impact': 'Unfair advantage to attackers, leading to potential loss of funds for legitimate users.', 'Location': 'Functions: `deposit`, `withdraw`'}], 'IssueNumber': 14, 'OutputList': 10}",625.5471441745758,"### **Summary of Matches and Gaps**

---

#### **[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities**

**Report Description**:
The v3 vault treats all valid tokens exactly the same, allowing users to deposit one token and withdraw another without accounting for price differences. This creates arbitrage opportunities, especially when LP tokens like 3crv_token are involved. The design makes the vault vulnerable to flashloan attacks, as attackers can exploit price discrepancies between tokens. The issue is considered high-risk due to the potential for significant financial losses.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of token arbitrage or the vulnerability to flashloan attacks. This is a critical oversight, as the issue highlights a high-risk scenario that could lead to substantial financial losses.

---

#### **[H-06] earn results in decreasing share price**

**Report Description**:
The `earn()` function in a DAI vault paired with `NativeStrategyCurve3Crv` causes shareholders to lose money (approximately 2%) each time it is called. This occurs because the `Vault` contract and the `Controller` contract do not handle the price difference between the `want` token and other tokens correctly. The issue is considered high-risk as it results in financial losses for users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of decreasing share prices or the mismanagement of token price differences between the `Vault` and `Controller` contracts. This is a significant oversight, as the issue directly impacts user funds.

---

#### **[H-07] Vault.balance() mixes normalized and standard amounts**

**Report Description**:
The `Vault.balance` function uses the `balanceOfThis` function, which normalizes all balances to 18 decimals. However, the second term in the `balance` function, `IController(manager.controllers(address(this))).balanceOf()`, is not normalized. This leads to incorrect calculations when normalized and non-normalized amounts are added together, causing issues throughout the contract.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of mixing normalized and non-normalized amounts in the `Vault.balance` function. This is a critical oversight, as it can lead to incorrect calculations and financial discrepancies.

---

#### **[H-08] Vault.withdraw mixes normalized and standard amounts**

**Report Description**:
The `Vault.withdraw` function compares and subtracts normalized and non-normalized amounts, leading to incorrect calculations. Specifically, the `_amount` value is normalized (18 decimals), but the `_balance` value is not normalized. This can result in users receiving fewer tokens than they are entitled to, leading to financial losses.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of mixing normalized and non-normalized amounts in the `Vault.withdraw` function. This is a significant oversight, as it directly impacts user funds.

---

#### **[M-03] Vault.withdraw sometimes burns too many shares**

**Report Description**:
The `Vault.withdraw` function burns too many shares when the controller cannot withdraw enough tokens. This results in users receiving fewer output tokens than they are entitled to, leading to financial losses.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of burning too many shares in the `Vault.withdraw` function. This is a critical oversight, as it directly impacts user funds.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities**
- **[H-06] earn results in decreasing share price**
- **[H-07] Vault.balance() mixes normalized and standard amounts**
- **[H-08] Vault.withdraw mixes normalized and standard amounts**
- **[M-03] Vault.withdraw sometimes burns too many shares**

---

### **Conclusion**
The `response_list` does not address any of the issues in the `issue` report. This is a significant gap, as the issues highlighted in the report are high-risk and directly impact the security and functionality of the smart contracts. The response list should be updated to include these critical vulnerabilities to ensure comprehensive coverage and mitigation of risks.","```
None.
```",0.0
VaultHelper.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./interfaces/ILiquidityGaugeV2.sol"";
import ""./interfaces/IVault.sol"";

/**
 * @title VaultHelper
 * @notice The VaultHelper acts as a single contract that users may set
 * token approvals on for any token of any vault.
 * @dev This contract has no state and could be deployed by anyone if
 * they didn't trust the original deployer.
 */
contract VaultHelper {
    using SafeERC20 for IERC20;

    /**
     * @notice Deposits the given token into the specified vault
     * @dev Users must approve the vault helper to spend their token
     * @param _vault The address of the vault
     * @param _token The address of the token
     * @param _amount The amount of tokens to deposit
     */
    function depositVault(
        address _vault,
        address _token,
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_token).safeApprove(_vault, 0);
        IERC20(_token).safeApprove(_vault, _amount);
        uint256 _shares = IVault(_vault).deposit(_token, _amount);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    /**
     * @notice Deposits multiple tokens simultaneously to the specified vault
     * @dev Users must approve the vault helper to spend their tokens
     * @param _vault The address of the vault
     * @param _tokens The addresses of each token being deposited
     * @param _amounts The amounts of each token being deposited
     */
    function depositMultipleVault(
        address _vault,
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i = 0; i < _amounts.length; i++) {
            require(_amounts[i] > 0, ""!_amounts"");
            IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);
            IERC20(_tokens[i]).safeApprove(_vault, 0);
            IERC20(_tokens[i]).safeApprove(_vault, _amounts[i]);
        }
        uint256 _shares = IVault(_vault).depositMultiple(_tokens, _amounts);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    function withdrawVault(
        address _vault,
        address _toToken,
        uint256 _amount
    )
        external
    {
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);
            ILiquidityGaugeV2(_gauge).withdraw(_amount);
            IVault(_vault).withdraw(IERC20(_vault).balanceOf(address(this)), _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        } else {
            IERC20(_vault).safeTransferFrom(msg.sender, address(this), _amount);
            IVault(_vault).withdraw(_amount, _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        }
    }
}

",997,106,"[M-01] VaultHelper deposits don't work with fee-on transfer tokens

Submitted by cmichel, also found by 0xsanson
There are ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom(). Others are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).
Impact

The VaultHelper's depositVault() and depositMultipleVault functions transfer _amount to this contract using IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);. This could have a fee, and less than _amount ends up in the contract. The next actual vault deposit using IVault(_vault).deposit(_token, _amount); will then try to transfer more than the this contract actually has and will revert the transaction.
",1,,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./interfaces/ILiquidityGaugeV2.sol"";
import ""./interfaces/IVault.sol"";


contract VaultHelper {
    using SafeERC20 for IERC20;

    
    function depositVault(
        address _vault,
        address _token,
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_token).safeApprove(_vault, 0);
        IERC20(_token).safeApprove(_vault, _amount);
        uint256 _shares = IVault(_vault).deposit(_token, _amount);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    
    function depositMultipleVault(
        address _vault,
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i = 0; i < _amounts.length; i++) {
            require(_amounts[i] > 0, ""!_amounts"");
            IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);
            IERC20(_tokens[i]).safeApprove(_vault, 0);
            IERC20(_tokens[i]).safeApprove(_vault, _amounts[i]);
        }
        uint256 _shares = IVault(_vault).depositMultiple(_tokens, _amounts);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    function withdrawVault(
        address _vault,
        address _toToken,
        uint256 _amount
    )
        external
    {
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);
            ILiquidityGaugeV2(_gauge).withdraw(_amount);
            IVault(_vault).withdraw(IERC20(_vault).balanceOf(address(this)), _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        } else {
            IERC20(_vault).safeTransferFrom(msg.sender, address(this), _amount);
            IVault(_vault).withdraw(_amount, _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        }
    }
}",787,0,1,,"{'ReviewingTheCode': ""The provided Solidity code snippet is a helper contract named 'VaultHelper' that facilitates interactions with a Vault and a Liquidity Gauge. It allows users to deposit and withdraw tokens from a Vault, and optionally interact with a Liquidity Gauge if it exists. The code uses OpenZeppelin's SafeERC20 library for safe token transfers and approvals."", 'IdentifyingKeyComponents': {'ContractName': 'VaultHelper', 'Purpose': 'To simplify the process of depositing and withdrawing tokens from a Vault and interacting with a Liquidity Gauge.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/token/ERC20/SafeERC20.sol', './interfaces/ILiquidityGaugeV2.sol', './interfaces/IVault.sol']}, 'StateVariables': [], 'FunctionsAndModifiers': [{'Name': 'depositVault', 'Visibility': 'external', 'Purpose': 'Deposits a specified amount of a token into a Vault and optionally into a Liquidity Gauge.', 'Parameters': ['address _vault', 'address _token', 'uint256 _amount'], 'Returns': []}, {'Name': 'depositMultipleVault', 'Visibility': 'external', 'Purpose': 'Deposits multiple tokens with specified amounts into a Vault and optionally into a Liquidity Gauge.', 'Parameters': ['address _vault', 'address[] calldata _tokens', 'uint256[] calldata _amounts'], 'Returns': []}, {'Name': 'withdrawVault', 'Visibility': 'external', 'Purpose': 'Withdraws a specified amount from a Vault and optionally from a Liquidity Gauge, converting it to a specified token.', 'Parameters': ['address _vault', 'address _toToken', 'uint256 _amount'], 'Returns': []}]}, 'ExternalInteractions': ['IVault: Interface for interacting with the Vault contract.', 'ILiquidityGaugeV2: Interface for interacting with the Liquidity Gauge contract.', 'IERC20: Interface for interacting with ERC20 tokens.'], 'SpecialMechanisms': ['SafeERC20: Used for safe token transfers and approvals.', 'Approval Reset: Before approving a new amount, the contract resets the approval to 0 to prevent potential front-running attacks.'], 'Questions': ['What is the purpose of resetting the approval to 0 before setting a new approval?', 'How does the contract handle cases where the Liquidity Gauge is not set (i.e., _gauge == address(0))?', 'Are there any potential reentrancy risks in the deposit and withdraw functions?', 'What happens if the deposit or withdraw operations fail in the Vault or Liquidity Gauge contracts?']}","{'Findings': [{'Issue': 'Reentrancy Risk in Deposit and Withdraw Functions', 'Severity': 'High', 'Description': 'Multiple functions (`depositVault`, `depositMultipleVault`, `withdrawVault`) interact with external contracts (e.g., `IVault`, `ILiquidityGaugeV2`) without reentrancy protection. This could allow attackers to reenter the functions and manipulate the state, potentially leading to loss of funds or other unintended behavior.', 'Impact': 'Potential loss of funds or state manipulation due to reentrancy attacks.', 'Location': 'Functions `depositVault`, `depositMultipleVault`, `withdrawVault`'}, {'Issue': 'Lack of Flash Loan Protection in Deposit and Withdraw Functions', 'Severity': 'High', 'Description': 'The `depositVault`, `depositMultipleVault`, and `withdrawVault` functions do not implement any protection against flash loan attacks. Flash loans can be used to manipulate the state of the contract or the underlying assets during these operations, potentially leading to unfair advantages or financial losses.', 'Impact': ""Attackers could exploit flash loans to manipulate the contract's state or the value of the assets, leading to financial losses or unfair advantages."", 'Location': 'Functions `depositVault`, `depositMultipleVault`, `withdrawVault`'}, {'Issue': 'Lack of Access Control on External Functions', 'Severity': 'High', 'Description': 'The contract has three external functions (`depositVault`, `depositMultipleVault`, and `withdrawVault`) that are publicly accessible without any access control mechanisms. This means any user can call these functions, potentially leading to unauthorized operations or exploitation.', 'Impact': 'Unauthorized users could manipulate the vault operations, leading to loss of funds or other unintended consequences.', 'Location': 'Functions `depositVault`, `depositMultipleVault`, `withdrawVault`'}, {'Issue': 'Incorrect Handling of Multiple Tokens in `depositMultipleVault`', 'Severity': 'High', 'Description': 'The `depositMultipleVault` function does not correctly handle the approval and transfer of multiple tokens. It assumes the `depositMultiple` function in the `IVault` interface will handle all tokens correctly, which may not be the case if the vault does not support multiple tokens or if the tokens have different decimals.', 'Impact': 'This could lead to loss of funds or incorrect token transfers, especially if the vault or tokens behave unexpectedly.', 'Location': 'Function `depositMultipleVault`'}, {'Issue': 'Unchecked External Calls to IVault and ILiquidityGaugeV2', 'Severity': 'Medium', 'Description': 'The contract makes external calls to `IVault` and `ILiquidityGaugeV2` without checking the return values or handling potential failures. This could lead to unexpected behavior if the call fails or if the vault or gauge contract behaves unexpectedly.', 'Impact': 'Potential loss of funds or unexpected state changes if the external contract calls fail or behave unexpectedly.', 'Location': 'Functions `depositVault`, `depositMultipleVault`, `withdrawVault`'}, {'Issue': 'Lack of Input Validation for Vault and Gauge Addresses', 'Severity': 'Medium', 'Description': 'The contract does not validate the input parameters (e.g., `_vault`, `_gauge`, `_token`, `_amount`) for zero addresses or invalid values. This could lead to unexpected behavior or vulnerabilities if invalid inputs are provided.', 'Impact': 'Potential loss of funds or unexpected state changes due to invalid inputs.', 'Location': 'Functions `depositVault`, `depositMultipleVault`, `withdrawVault`'}, {'Issue': 'Insufficient Handling of Token Approvals', 'Severity': 'Medium', 'Description': 'The functions in the contract do not handle token approvals efficiently. They reset the approval to zero before setting it to the desired amount, which is a common practice to prevent certain types of attacks. However, this approach can fail if the token does not support setting the approval to zero before setting it to a new value.', 'Impact': 'This could lead to failed transactions or incorrect token approvals, especially with non-standard tokens.', 'Location': 'Functions `depositVault`, `depositMultipleVault`, `withdrawVault`'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': 'The contract uses arithmetic operations (e.g., transferring tokens, calculating shares) without explicit checks for integer overflow/underflow. Although Solidity 0.8.0 and later versions have built-in overflow/underflow protection, the contract uses Solidity 0.6.12, which does not have this feature. This could lead to unexpected behavior or vulnerabilities.', 'Impact': 'Potential unexpected behavior or vulnerabilities due to integer overflow/underflow.', 'Location': 'All functions with arithmetic operations'}, {'Issue': 'No Ownership or Admin Controls', 'Severity': 'Medium', 'Description': 'The contract does not implement any ownership or administrative controls, such as the use of `Ownable` or `AccessControl` from OpenZeppelin. This absence means there is no way to restrict critical functions to authorized addresses only.', 'Impact': 'Without ownership or admin controls, the contract cannot enforce restrictions on who can perform sensitive operations, increasing the risk of misuse.', 'Location': 'Entire contract'}, {'Issue': 'Insufficient Handling of Impermanent Loss', 'Severity': 'Medium', 'Description': 'The contract does not explicitly handle or mitigate impermanent loss risks. While the contract interacts with a vault and liquidity gauge, it does not provide mechanisms to monitor or manage the price fluctuations of the underlying assets in the liquidity pool, which could lead to significant losses for users.', 'Impact': 'Users may experience unexpected losses due to impermanent loss.', 'Location': 'Entire contract'}, {'Issue': 'Unnecessary Zero Approval in SafeERC20', 'Severity': 'Low', 'Description': 'The code uses `safeApprove(_vault, 0)` before setting the actual approval. This is a common practice to reset the allowance, but it is unnecessary if the allowance is already zero. This results in an extra external call, increasing gas costs.', 'Impact': 'Increased gas costs due to redundant external calls.', 'Location': 'Functions `depositVault`, `depositMultipleVault`, `withdrawVault`'}, {'Issue': 'Loop Gas Optimization in depositMultipleVault', 'Severity': 'Low', 'Description': 'The `depositMultipleVault` function iterates over the `_amounts` array, performing multiple external calls within the loop. Each iteration involves two `safeTransferFrom` and two `safeApprove` calls, which are gas-intensive. The loop could be optimized by reducing the number of external calls or batching operations.', 'Impact': 'Significant gas consumption, especially with large arrays.', 'Location': 'Function `depositMultipleVault`'}, {'Issue': 'No Event Logging for Critical Operations', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical operations such as deposits and withdrawals. This makes it difficult to track and audit these operations, which could be important for monitoring and responding to potential issues.', 'Impact': 'Reduced transparency and auditability of the contract.', 'Location': 'Functions `depositVault`, `depositMultipleVault`, `withdrawVault`'}], 'IssueNumber': 35, 'OutputList': 13}",336.33743381500244,"---

**[M-01] VaultHelper deposits don't work with fee-on transfer tokens**

**Report Description**:
The `VaultHelper` contract's `depositVault()` and `depositMultipleVault` functions transfer `_amount` to the contract using `IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);`. However, some ERC20 tokens, such as fee-on-transfer tokens or rebasing tokens, may result in less than `_amount` being deposited into the contract. When the subsequent vault deposit is attempted using `IVault(_vault).deposit(_token, _amount);`, the contract may try to transfer more tokens than it actually holds, causing the transaction to revert. This issue can lead to failed transactions and user frustration, especially when dealing with non-standard tokens.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens or rebasing tokens in the `VaultHelper` contract. None of the findings in the response list mention the specific problem of handling tokens that deduct fees or change balances during transfers. This is a critical oversight, as the issue directly impacts the functionality of the contract when interacting with non-standard tokens. The response list focuses on other vulnerabilities (e.g., reentrancy, flash loan protection, access control) but misses this specific issue entirely.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-01] VaultHelper deposits don't work with fee-on transfer tokens**

--- 

The response list fails to address the specific issue of fee-on-transfer tokens, which is a significant oversight. This gap highlights the need for a more comprehensive review of the contract's handling of non-standard ERC20 tokens.","```
None.
```",0.0
Manger.sol,"// SPDX-License-Identifier: MIT
// solhint-disable max-states-count
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IHarvester.sol"";
import ""./interfaces/IManager.sol"";
import ""./interfaces/IStrategy.sol"";
import ""./interfaces/IVault.sol"";

/**
 * @title Manager
 * @notice This contract serves as the central point for governance-voted
 * variables. Fees and permissioned addresses are stored and referenced in
 * this contract only.
 */
contract Manager is IManager {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;
    uint256 public constant MAX_TOKENS = 256;

    address public immutable override yaxis;

    bool public override halted;

    address public override governance;
    address public override harvester;
    address public override insurancePool;
    address public override stakingPool;
    address public override strategist;
    address public override pendingStrategist;
    address public override treasury;

    // The following fees are all mutable.
    // They are updated by governance (community vote).
    uint256 public override insuranceFee;
    uint256 public override insurancePoolFee;
    uint256 public override stakingPoolShareFee;
    uint256 public override treasuryFee;
    uint256 public override withdrawalProtectionFee;


    uint256 private setPendingStrategistTime;

    // Governance must first allow the following properties before
    // the strategist can make use of them
    mapping(address => bool) public override allowedControllers;
    mapping(address => bool) public override allowedConverters;
    mapping(address => bool) public override allowedStrategies;
    mapping(address => bool) public override allowedTokens;
    mapping(address => bool) public override allowedVaults;

    // vault => controller
    mapping(address => address) public override controllers;
    // vault => tokens[]
    mapping(address => address[]) public override tokens;
    // token => vault
    mapping(address => address) public override vaults;

    event AllowedController(
        address indexed _controller,
        bool _allowed
    );
    event AllowedConverter(
        address indexed _converter,
        bool _allowed
    );
    event AllowedStrategy(
        address indexed _strategy,
        bool _allowed
    );
    event AllowedToken(
        address indexed _token,
        bool _allowed
    );
    event AllowedVault(
        address indexed _vault,
        bool _allowed
    );
    event Halted();
    event SetController(
        address indexed _vault,
        address indexed _controller
    );
    event SetGovernance(
        address indexed _governance
    );
    event SetPendingStrategist(
        address indexed _strategist
    );
    event SetStrategist(
        address indexed _strategist
    );
    event TokenAdded(
        address indexed _vault,
        address indexed _token
    );
    event TokenRemoved(
        address indexed _vault,
        address indexed _token
    );

    /**
     * @param _yaxis The address of the YAX token
     */
    constructor(
        address _yaxis
    )
        public
    {
        require(_yaxis != address(0), ""!_yaxis"");
        yaxis = _yaxis;
        governance = msg.sender;
        strategist = msg.sender;
        harvester = msg.sender;
        treasury = msg.sender;
        stakingPoolShareFee = 2000;
        treasuryFee = 500;
        withdrawalProtectionFee = 10;
    }

    /**
     * GOVERNANCE-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the permission for the given controller
     * @param _controller The address of the controller
     * @param _allowed The status of if it is allowed
     */
    function setAllowedController(
        address _controller,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IController(_controller).manager()) == address(this), ""!manager"");
        allowedControllers[_controller] = _allowed;
        emit AllowedController(_controller, _allowed);
    }

    /**
     * @notice Sets the permission for the given converter
     * @param _converter The address of the converter
     * @param _allowed The status of if it is allowed
     */
    function setAllowedConverter(
        address _converter,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IConverter(_converter).manager()) == address(this), ""!manager"");
        allowedConverters[_converter] = _allowed;
        emit AllowedConverter(_converter, _allowed);
    }

    /**
     * @notice Sets the permission for the given strategy
     * @param _strategy The address of the strategy
     * @param _allowed The status of if it is allowed
     */
    function setAllowedStrategy(
        address _strategy,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IStrategy(_strategy).manager()) == address(this), ""!manager"");
        allowedStrategies[_strategy] = _allowed;
        emit AllowedStrategy(_strategy, _allowed);
    }

    /**
     * @notice Sets the permission for the given token
     * @param _token The address of the token
     * @param _allowed The status of if it is allowed
     */
    function setAllowedToken(
        address _token,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        allowedTokens[_token] = _allowed;
        emit AllowedToken(_token, _allowed);
    }

    /**
     * @notice Sets the permission for the given vault
     * @param _vault The address of the vault
     * @param _allowed The status of if it is allowed
     */
    function setAllowedVault(
        address _vault,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IVault(_vault).manager()) == address(this), ""!manager"");
        allowedVaults[_vault] = _allowed;
        emit AllowedVault(_vault, _allowed);
    }

    /**
     * @notice Sets the governance address
     * @param _governance The address of the governance
     */
    function setGovernance(
        address _governance
    )
        external
        notHalted
        onlyGovernance
    {
        governance = _governance;
        emit SetGovernance(_governance);
    }

    /**
     * @notice Sets the harvester address
     * @param _harvester The address of the harvester
     */
    function setHarvester(
        address _harvester
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IHarvester(_harvester).manager()) == address(this), ""!manager"");
        harvester = _harvester;
    }

    /**
     * @notice Sets the insurance fee
     * @dev Throws if setting fee over 1%
     * @param _insuranceFee The value for the insurance fee
     */
    function setInsuranceFee(
        uint256 _insuranceFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insuranceFee <= 100, ""_insuranceFee over 1%"");
        insuranceFee = _insuranceFee;
    }

    /**
     * @notice Sets the insurance pool address
     * @param _insurancePool The address of the insurance pool
     */
    function setInsurancePool(
        address _insurancePool
    )
        external
        notHalted
        onlyGovernance
    {
        insurancePool = _insurancePool;
    }

    /**
     * @notice Sets the insurance pool fee
     * @dev Throws if setting fee over 20%
     * @param _insurancePoolFee The value for the insurance pool fee
     */
    function setInsurancePoolFee(
        uint256 _insurancePoolFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insurancePoolFee <= 2000, ""_insurancePoolFee over 20%"");
        insurancePoolFee = _insurancePoolFee;
    }

    /**
     * @notice Sets the staking pool address
     * @param _stakingPool The address of the staking pool
     */
    function setStakingPool(
        address _stakingPool
    )
        external
        notHalted
        onlyGovernance
    {
        stakingPool = _stakingPool;
    }

    /**
     * @notice Sets the staking pool share fee
     * @dev Throws if setting fee over 50%
     * @param _stakingPoolShareFee The value for the staking pool fee
     */
    function setStakingPoolShareFee(
        uint256 _stakingPoolShareFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_stakingPoolShareFee <= 5000, ""_stakingPoolShareFee over 50%"");
        stakingPoolShareFee = _stakingPoolShareFee;
    }

    /**
     * @notice Sets the pending strategist and the timestamp
     * @param _strategist The address of the strategist
     */
    function setStrategist(
        address _strategist
    )
        external
        notHalted
        onlyGovernance
    {
        require(_strategist != address(0), ""!_strategist"");
        pendingStrategist = _strategist;
        // solhint-disable-next-line not-rely-on-time
        setPendingStrategistTime = block.timestamp;
        emit SetPendingStrategist(_strategist);
    }

    /**
     * @notice Sets the treasury address
     * @param _treasury The address of the treasury
     */
    function setTreasury(
        address _treasury
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasury != address(0), ""!_treasury"");
        treasury = _treasury;
    }

    /**
     * @notice Sets the treasury fee
     * @dev Throws if setting fee over 20%
     * @param _treasuryFee The value for the treasury fee
     */
    function setTreasuryFee(
        uint256 _treasuryFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasuryFee <= 2000, ""_treasuryFee over 20%"");
        treasuryFee = _treasuryFee;
    }

    /**
     * @notice Sets the withdrawal protection fee
     * @dev Throws if setting fee over 1%
     * @param _withdrawalProtectionFee The value for the withdrawal protection fee
     */
    function setWithdrawalProtectionFee(
        uint256 _withdrawalProtectionFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_withdrawalProtectionFee <= 100, ""_withdrawalProtectionFee over 1%"");
        withdrawalProtectionFee = _withdrawalProtectionFee;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Updates the strategist to the pending strategist
     * @dev This can only be called after the pending strategist timelock (7 days)
     */
    function acceptStrategist()
        external
        notHalted
    {
        require(msg.sender == pendingStrategist, ""!pendingStrategist"");
        // solhint-disable-next-line not-rely-on-time
        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), ""PENDING_STRATEGIST_TIMELOCK"");
        delete pendingStrategist;
        delete setPendingStrategistTime;
        strategist = msg.sender;
        emit SetStrategist(msg.sender);
    }

    /**
     * @notice Adds a token to be able to be deposited for a given vault
     * @param _vault The address of the vault
     * @param _token The address of the token
     */
    function addToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        require(allowedTokens[_token], ""!allowedTokens"");
        require(allowedVaults[_vault], ""!allowedVaults"");
        require(tokens[_vault].length < MAX_TOKENS, "">tokens"");
        require(vaults[_token] == address(0), ""!_token"");
        vaults[_token] = _vault;
        tokens[_vault].push(_token);
        emit TokenAdded(_vault, _token);
    }

    /**
     * @notice Allows the strategist to pull tokens out of this contract
     * @dev This contract should never hold tokens
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to send to
     */
    function recoverToken(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        notHalted
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * @notice Removes a token from being able to be deposited for a given vault
     * @param _vault The address of the vault
     * @param _token The address of the token
     */
    function removeToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        uint256 k = tokens[_vault].length;
        uint256 index;
        bool found;

        for (uint i = 0; i < k; i++) {
            if (tokens[_vault][i] == _token) {
                index = i;
                found = true;
                break;
            }
        }

        // TODO: Verify added check
        if (found) {
            tokens[_vault][index] = tokens[_vault][k-1];
            tokens[_vault].pop();
            delete vaults[_token];
            emit TokenRemoved(_vault, _token);
        }
    }

    /**
     * @notice Sets the vault address for a controller
     * @param _vault The address of the vault
     * @param _controller The address of the controller
     */
    function setController(
        address _vault,
        address _controller
    )
        external
        notHalted
        onlyStrategist
    {
        require(allowedVaults[_vault], ""!_vault"");
        require(allowedControllers[_controller], ""!_controller"");
        controllers[_vault] = _controller;
        emit SetController(_vault, _controller);
    }

    /**
     * @notice Sets the protocol as halted, disallowing all deposits forever
     * @dev Withdraws will still work, allowing users to exit the protocol
     */
    function setHalted()
        external
        notHalted
        onlyStrategist
    {
        halted = true;
        emit Halted();
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns an array of token addresses for a given vault
     * @param _vault The address of the vault
     */
    function getTokens(
        address _vault
    )
        external
        view
        override
        returns (address[] memory)
    {
        return tokens[_vault];
    }

    /**
     * @notice Returns a tuple of:
     *     YAXIS token address,
     *     Treasury address,
     *     Treasury fee
     */
    function getHarvestFeeInfo()
        external
        view
        override
        returns (
            address,
            address,
            uint256
        )
    {
        return (
            yaxis,
            treasury,
            treasuryFee
        );
    }

    modifier notHalted() {
        require(!halted, ""halted"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""!governance"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == strategist, ""!strategist"");
        _;
    }
}

",3492,583,"[M-02] ERC20 return values not checked

Submitted by cmichel, also found by defsec and jonah1005
The ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do not revert if the transfer failed but return false instead.
The `Manager.recoverToken` function does not check the return value of this function.
Impact

Tokens that don't actually perform the transfer and return false are still counted as a correct transfer. Furthermore, tokens that do not correctly implement the EIP20 standard, like USDT which does not return a success boolean, will revert.
 [M-09] token -> vault mapping can be overwritten

One vault can have many tokens, but each token should only be assigned to a single vault. The Manager contract keeps a mapping of tokens to vaults in the vaults[_token] => _vault map, and a mapping of vault to tokens in tokens[vault] => token[]. 
The `addToken` function can assign any token to a single vault and allows overwriting an existing vaults[_token] map entry with a different vault. This indirectly disassociates the previous vault for the token. Note that the previous vault's tokens[_previousVault] map still contains the token.
 [M-13] manager.allowedVaults check missing for add/remove strategy

Submitted by 0xRajeev
Impact

The manager.allowedVaults check is missing for add/remove strategy like how it is used in reorderStrategies(). This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.
Given the critical access control that is missing on vaults here, this is classified as medium severity.
",3,,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IHarvester.sol"";
import ""./interfaces/IManager.sol"";
import ""./interfaces/IStrategy.sol"";
import ""./interfaces/IVault.sol"";


contract Manager is IManager {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;
    uint256 public constant MAX_TOKENS = 256;

    address public immutable override yaxis;

    bool public override halted;

    address public override governance;
    address public override harvester;
    address public override insurancePool;
    address public override stakingPool;
    address public override strategist;
    address public override pendingStrategist;
    address public override treasury;

    
    
    uint256 public override insuranceFee;
    uint256 public override insurancePoolFee;
    uint256 public override stakingPoolShareFee;
    uint256 public override treasuryFee;
    uint256 public override withdrawalProtectionFee;


    uint256 private setPendingStrategistTime;

    
    
    mapping(address => bool) public override allowedControllers;
    mapping(address => bool) public override allowedConverters;
    mapping(address => bool) public override allowedStrategies;
    mapping(address => bool) public override allowedTokens;
    mapping(address => bool) public override allowedVaults;

    
    mapping(address => address) public override controllers;
    
    mapping(address => address[]) public override tokens;
    
    mapping(address => address) public override vaults;

    event AllowedController(
        address indexed _controller,
        bool _allowed
    );
    event AllowedConverter(
        address indexed _converter,
        bool _allowed
    );
    event AllowedStrategy(
        address indexed _strategy,
        bool _allowed
    );
    event AllowedToken(
        address indexed _token,
        bool _allowed
    );
    event AllowedVault(
        address indexed _vault,
        bool _allowed
    );
    event Halted();
    event SetController(
        address indexed _vault,
        address indexed _controller
    );
    event SetGovernance(
        address indexed _governance
    );
    event SetPendingStrategist(
        address indexed _strategist
    );
    event SetStrategist(
        address indexed _strategist
    );
    event TokenAdded(
        address indexed _vault,
        address indexed _token
    );
    event TokenRemoved(
        address indexed _vault,
        address indexed _token
    );

    
    constructor(
        address _yaxis
    )
        public
    {
        require(_yaxis != address(0), ""!_yaxis"");
        yaxis = _yaxis;
        governance = msg.sender;
        strategist = msg.sender;
        harvester = msg.sender;
        treasury = msg.sender;
        stakingPoolShareFee = 2000;
        treasuryFee = 500;
        withdrawalProtectionFee = 10;
    }

    

    
    function setAllowedController(
        address _controller,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IController(_controller).manager()) == address(this), ""!manager"");
        allowedControllers[_controller] = _allowed;
        emit AllowedController(_controller, _allowed);
    }

    
    function setAllowedConverter(
        address _converter,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IConverter(_converter).manager()) == address(this), ""!manager"");
        allowedConverters[_converter] = _allowed;
        emit AllowedConverter(_converter, _allowed);
    }

    
    function setAllowedStrategy(
        address _strategy,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IStrategy(_strategy).manager()) == address(this), ""!manager"");
        allowedStrategies[_strategy] = _allowed;
        emit AllowedStrategy(_strategy, _allowed);
    }

    
    function setAllowedToken(
        address _token,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        allowedTokens[_token] = _allowed;
        emit AllowedToken(_token, _allowed);
    }

    
    function setAllowedVault(
        address _vault,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IVault(_vault).manager()) == address(this), ""!manager"");
        allowedVaults[_vault] = _allowed;
        emit AllowedVault(_vault, _allowed);
    }

    
    function setGovernance(
        address _governance
    )
        external
        notHalted
        onlyGovernance
    {
        governance = _governance;
        emit SetGovernance(_governance);
    }

    
    function setHarvester(
        address _harvester
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IHarvester(_harvester).manager()) == address(this), ""!manager"");
        harvester = _harvester;
    }

    
    function setInsuranceFee(
        uint256 _insuranceFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insuranceFee <= 100, ""_insuranceFee over 1%"");
        insuranceFee = _insuranceFee;
    }

    
    function setInsurancePool(
        address _insurancePool
    )
        external
        notHalted
        onlyGovernance
    {
        insurancePool = _insurancePool;
    }

    
    function setInsurancePoolFee(
        uint256 _insurancePoolFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insurancePoolFee <= 2000, ""_insurancePoolFee over 20%"");
        insurancePoolFee = _insurancePoolFee;
    }

    
    function setStakingPool(
        address _stakingPool
    )
        external
        notHalted
        onlyGovernance
    {
        stakingPool = _stakingPool;
    }

    
    function setStakingPoolShareFee(
        uint256 _stakingPoolShareFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_stakingPoolShareFee <= 5000, ""_stakingPoolShareFee over 50%"");
        stakingPoolShareFee = _stakingPoolShareFee;
    }

    
    function setStrategist(
        address _strategist
    )
        external
        notHalted
        onlyGovernance
    {
        require(_strategist != address(0), ""!_strategist"");
        pendingStrategist = _strategist;
        
        setPendingStrategistTime = block.timestamp;
        emit SetPendingStrategist(_strategist);
    }

    
    function setTreasury(
        address _treasury
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasury != address(0), ""!_treasury"");
        treasury = _treasury;
    }

    
    function setTreasuryFee(
        uint256 _treasuryFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasuryFee <= 2000, ""_treasuryFee over 20%"");
        treasuryFee = _treasuryFee;
    }

    
    function setWithdrawalProtectionFee(
        uint256 _withdrawalProtectionFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_withdrawalProtectionFee <= 100, ""_withdrawalProtectionFee over 1%"");
        withdrawalProtectionFee = _withdrawalProtectionFee;
    }

    

    
    function acceptStrategist()
        external
        notHalted
    {
        require(msg.sender == pendingStrategist, ""!pendingStrategist"");
        
        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), ""PENDING_STRATEGIST_TIMELOCK"");
        delete pendingStrategist;
        delete setPendingStrategistTime;
        strategist = msg.sender;
        emit SetStrategist(msg.sender);
    }

    
    function addToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        require(allowedTokens[_token], ""!allowedTokens"");
        require(allowedVaults[_vault], ""!allowedVaults"");
        require(tokens[_vault].length < MAX_TOKENS, "">tokens"");
        require(vaults[_token] == address(0), ""!_token"");
        vaults[_token] = _vault;
        tokens[_vault].push(_token);
        emit TokenAdded(_vault, _token);
    }

    
    function recoverToken(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        notHalted
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }

    
    function removeToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        uint256 k = tokens[_vault].length;
        uint256 index;
        bool found;

        for (uint i = 0; i < k; i++) {
            if (tokens[_vault][i] == _token) {
                index = i;
                found = true;
                break;
            }
        }

        
        if (found) {
            tokens[_vault][index] = tokens[_vault][k-1];
            tokens[_vault].pop();
            delete vaults[_token];
            emit TokenRemoved(_vault, _token);
        }
    }

    
    function setController(
        address _vault,
        address _controller
    )
        external
        notHalted
        onlyStrategist
    {
        require(allowedVaults[_vault], ""!_vault"");
        require(allowedControllers[_controller], ""!_controller"");
        controllers[_vault] = _controller;
        emit SetController(_vault, _controller);
    }

    
    function setHalted()
        external
        notHalted
        onlyStrategist
    {
        halted = true;
        emit Halted();
    }

    

    
    function getTokens(
        address _vault
    )
        external
        view
        override
        returns (address[] memory)
    {
        return tokens[_vault];
    }

    
    function getHarvestFeeInfo()
        external
        view
        override
        returns (
            address,
            address,
            uint256
        )
    {
        return (
            yaxis,
            treasury,
            treasuryFee
        );
    }

    modifier notHalted() {
        require(!halted, ""halted"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""!governance"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == strategist, ""!strategist"");
        _;
    }
}",2388,0,3,,"{'ReviewingTheCode': ""The contract 'Manager' is a governance and management contract that handles various roles, permissions, and configurations for a DeFi protocol. It interacts with multiple external contracts and interfaces to manage controllers, converters, strategies, tokens, and vaults. The contract uses OpenZeppelin libraries for safe math and ERC20 operations."", 'IdentifyingKeyComponents': {'ContractName': 'Manager', 'Purpose': 'To manage roles, permissions, and configurations for a DeFi protocol, including governance, strategist, harvester, and fee settings.', 'InheritanceAndImports': {'InheritsFrom': ['IManager'], 'Imports': ['@openzeppelin/contracts/math/SafeMath.sol', '@openzeppelin/contracts/token/ERC20/SafeERC20.sol', '@openzeppelin/contracts/token/ERC20/IERC20.sol', './interfaces/IController.sol', './interfaces/IConverter.sol', './interfaces/IHarvester.sol', './interfaces/IManager.sol', './interfaces/IStrategy.sol', './interfaces/IVault.sol']}, 'StateVariables': [{'Name': 'PENDING_STRATEGIST_TIMELOCK', 'Type': 'uint256', 'Purpose': 'Time delay before a pending strategist can be accepted.'}, {'Name': 'MAX_TOKENS', 'Type': 'uint256', 'Purpose': 'Maximum number of tokens that can be added to a vault.'}, {'Name': 'yaxis', 'Type': 'address', 'Purpose': 'Immutable address of the YAXIS token.'}, {'Name': 'halted', 'Type': 'bool', 'Purpose': 'Indicates if the contract is halted.'}, {'Name': 'governance', 'Type': 'address', 'Purpose': 'Address of the governance role.'}, {'Name': 'harvester', 'Type': 'address', 'Purpose': 'Address of the harvester role.'}, {'Name': 'insurancePool', 'Type': 'address', 'Purpose': 'Address of the insurance pool.'}, {'Name': 'stakingPool', 'Type': 'address', 'Purpose': 'Address of the staking pool.'}, {'Name': 'strategist', 'Type': 'address', 'Purpose': 'Address of the strategist role.'}, {'Name': 'pendingStrategist', 'Type': 'address', 'Purpose': 'Address of the pending strategist.'}, {'Name': 'treasury', 'Type': 'address', 'Purpose': 'Address of the treasury.'}, {'Name': 'insuranceFee', 'Type': 'uint256', 'Purpose': 'Fee for insurance.'}, {'Name': 'insurancePoolFee', 'Type': 'uint256', 'Purpose': 'Fee for the insurance pool.'}, {'Name': 'stakingPoolShareFee', 'Type': 'uint256', 'Purpose': 'Fee for the staking pool share.'}, {'Name': 'treasuryFee', 'Type': 'uint256', 'Purpose': 'Fee for the treasury.'}, {'Name': 'withdrawalProtectionFee', 'Type': 'uint256', 'Purpose': 'Fee for withdrawal protection.'}, {'Name': 'setPendingStrategistTime', 'Type': 'uint256', 'Purpose': 'Timestamp when the pending strategist was set.'}, {'Name': 'allowedControllers', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping of allowed controllers.'}, {'Name': 'allowedConverters', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping of allowed converters.'}, {'Name': 'allowedStrategies', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping of allowed strategies.'}, {'Name': 'allowedTokens', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping of allowed tokens.'}, {'Name': 'allowedVaults', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping of allowed vaults.'}, {'Name': 'controllers', 'Type': 'mapping(address => address)', 'Purpose': 'Mapping of vaults to their controllers.'}, {'Name': 'tokens', 'Type': 'mapping(address => address[])', 'Purpose': 'Mapping of vaults to their tokens.'}, {'Name': 'vaults', 'Type': 'mapping(address => address)', 'Purpose': 'Mapping of tokens to their vaults.'}], 'FunctionsAndModifiers': [{'Name': 'setAllowedController', 'Visibility': 'external', 'Purpose': 'Allows or disallows a controller.', 'Parameters': ['address _controller', 'bool _allowed'], 'Returns': []}, {'Name': 'setAllowedConverter', 'Visibility': 'external', 'Purpose': 'Allows or disallows a converter.', 'Parameters': ['address _converter', 'bool _allowed'], 'Returns': []}, {'Name': 'setAllowedStrategy', 'Visibility': 'external', 'Purpose': 'Allows or disallows a strategy.', 'Parameters': ['address _strategy', 'bool _allowed'], 'Returns': []}, {'Name': 'setAllowedToken', 'Visibility': 'external', 'Purpose': 'Allows or disallows a token.', 'Parameters': ['address _token', 'bool _allowed'], 'Returns': []}, {'Name': 'setAllowedVault', 'Visibility': 'external', 'Purpose': 'Allows or disallows a vault.', 'Parameters': ['address _vault', 'bool _allowed'], 'Returns': []}, {'Name': 'setGovernance', 'Visibility': 'external', 'Purpose': 'Sets the governance address.', 'Parameters': ['address _governance'], 'Returns': []}, {'Name': 'setHarvester', 'Visibility': 'external', 'Purpose': 'Sets the harvester address.', 'Parameters': ['address _harvester'], 'Returns': []}, {'Name': 'setInsuranceFee', 'Visibility': 'external', 'Purpose': 'Sets the insurance fee.', 'Parameters': ['uint256 _insuranceFee'], 'Returns': []}, {'Name': 'setInsurancePool', 'Visibility': 'external', 'Purpose': 'Sets the insurance pool address.', 'Parameters': ['address _insurancePool'], 'Returns': []}, {'Name': 'setInsurancePoolFee', 'Visibility': 'external', 'Purpose': 'Sets the insurance pool fee.', 'Parameters': ['uint256 _insurancePoolFee'], 'Returns': []}, {'Name': 'setStakingPool', 'Visibility': 'external', 'Purpose': 'Sets the staking pool address.', 'Parameters': ['address _stakingPool'], 'Returns': []}, {'Name': 'setStakingPoolShareFee', 'Visibility': 'external', 'Purpose': 'Sets the staking pool share fee.', 'Parameters': ['uint256 _stakingPoolShareFee'], 'Returns': []}, {'Name': 'setStrategist', 'Visibility': 'external', 'Purpose': 'Sets the pending strategist address.', 'Parameters': ['address _strategist'], 'Returns': []}, {'Name': 'setTreasury', 'Visibility': 'external', 'Purpose': 'Sets the treasury address.', 'Parameters': ['address _treasury'], 'Returns': []}, {'Name': 'setTreasuryFee', 'Visibility': 'external', 'Purpose': 'Sets the treasury fee.', 'Parameters': ['uint256 _treasuryFee'], 'Returns': []}, {'Name': 'setWithdrawalProtectionFee', 'Visibility': 'external', 'Purpose': 'Sets the withdrawal protection fee.', 'Parameters': ['uint256 _withdrawalProtectionFee'], 'Returns': []}, {'Name': 'acceptStrategist', 'Visibility': 'external', 'Purpose': 'Allows the pending strategist to accept the role.', 'Parameters': [], 'Returns': []}, {'Name': 'addToken', 'Visibility': 'external', 'Purpose': 'Adds a token to a vault.', 'Parameters': ['address _vault', 'address _token'], 'Returns': []}, {'Name': 'recoverToken', 'Visibility': 'external', 'Purpose': 'Recovers tokens sent to the contract.', 'Parameters': ['IERC20 _token', 'uint256 _amount', 'address _to'], 'Returns': []}, {'Name': 'removeToken', 'Visibility': 'external', 'Purpose': 'Removes a token from a vault.', 'Parameters': ['address _vault', 'address _token'], 'Returns': []}, {'Name': 'setController', 'Visibility': 'external', 'Purpose': 'Sets the controller for a vault.', 'Parameters': ['address _vault', 'address _controller'], 'Returns': []}, {'Name': 'setHalted', 'Visibility': 'external', 'Purpose': 'Halts the contract.', 'Parameters': [], 'Returns': []}, {'Name': 'getTokens', 'Visibility': 'external', 'Purpose': 'Gets the tokens associated with a vault.', 'Parameters': ['address _vault'], 'Returns': ['address[] memory']}, {'Name': 'getHarvestFeeInfo', 'Visibility': 'external', 'Purpose': 'Gets the harvest fee information.', 'Parameters': [], 'Returns': ['address', 'address', 'uint256']}, {'Name': 'notHalted', 'Visibility': 'modifier', 'Purpose': 'Ensures the contract is not halted.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyGovernance', 'Visibility': 'modifier', 'Purpose': 'Restricts access to the governance role.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyStrategist', 'Visibility': 'modifier', 'Purpose': 'Restricts access to the strategist role.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['IController', 'IConverter', 'IHarvester', 'IStrategy', 'IVault', 'IERC20'], 'SpecialMechanisms': ['Role-based access control using modifiers (onlyGovernance, onlyStrategist).', 'Pending strategist mechanism with a timelock.', 'Mapping structures to manage permissions and associations between vaults, tokens, controllers, and strategies.'], 'Questions': ['Is there a mechanism to update the MAX_TOKENS limit if needed?', 'How is the halted state intended to be used in practice?', 'Are there any additional safety checks or fallback mechanisms for critical operations like setting the governance address?']}","{'Findings': [{'Issue': 'Potential Reentrancy in `recoverToken` Function', 'Severity': 'High', 'Description': 'The `recoverToken` function uses `safeTransfer` to transfer tokens to an external address without a reentrancy guard. If the recipient is a malicious contract, it could re-enter the function before state changes are finalized, leading to reentrancy attacks.', 'Impact': 'Reentrancy could allow an attacker to drain funds from the contract or manipulate the contract state in unexpected ways.', 'Location': 'Function `recoverToken`'}, {'Issue': 'Unrestricted Access to Critical Functions', 'Severity': 'High', 'Description': 'Functions such as `setGovernance`, `setHarvester`, `setInsurancePool`, `setStakingPool`, and `setStrategist` are only protected by the `onlyGovernance` modifier. If the governance address is compromised, an attacker can change critical system parameters, leading to potential loss of funds or control over the contract.', 'Impact': 'Loss of control over the contract, potential fund loss, and unauthorized changes to system parameters.', 'Location': 'Functions: `setGovernance`, `setHarvester`, `setInsurancePool`, `setStakingPool`, `setStrategist`'}, {'Issue': 'Missing Access Control in `acceptStrategist` Function', 'Severity': 'High', 'Description': 'The `acceptStrategist` function allows any address to become the strategist after a timelock period, but it does not verify if the caller is the pending strategist. This could allow an unauthorized address to become the strategist.', 'Impact': ""An attacker could gain control of the strategist role, potentially manipulating the contract's behavior."", 'Location': 'Function `acceptStrategist`'}, {'Issue': 'Potential Front-Running in `acceptStrategist` Function', 'Severity': 'Medium', 'Description': 'The `acceptStrategist` function allows the pending strategist to accept the role after a timelock. However, there is no protection against front-running, where a malicious actor could replace the pending strategist before the legitimate one accepts the role.', 'Impact': 'Unauthorized changes to the strategist role, leading to potential misuse of privileges.', 'Location': 'Function `acceptStrategist`'}, {'Issue': 'Lack of Input Validation in `setPendingStrategist` Function', 'Severity': 'Medium', 'Description': 'The `setPendingStrategist` function does not validate the input address `_strategist` beyond checking it is not the zero address. This could lead to setting a malicious or incorrect address as the pending strategist.', 'Impact': 'A malicious actor could set an incorrect or harmful address as the pending strategist, potentially leading to unauthorized actions or loss of funds.', 'Location': 'Function `setPendingStrategist`'}, {'Issue': 'Unbounded Array in `tokens` Mapping', 'Severity': 'Medium', 'Description': 'The `tokens` mapping allows for an unbounded array of tokens to be associated with a vault. This could lead to high gas costs or even out-of-gas errors when the array becomes too large.', 'Impact': 'High gas costs could make the contract inefficient or even unusable if the number of tokens associated with a vault grows too large.', 'Location': 'Mapping `tokens` and related functions (`addToken`, `removeToken`)'}, {'Issue': 'No Event Emission in `setHarvester` Function', 'Severity': 'Low', 'Description': 'The `setHarvester` function changes the harvester address but does not emit an event to log this change. This makes it difficult to track changes to the harvester address off-chain.', 'Impact': 'Reduced transparency and difficulty in tracking changes to the harvester address.', 'Location': 'Function `setHarvester`'}, {'Issue': 'No Check for Duplicate Tokens in `addToken` Function', 'Severity': 'Low', 'Description': 'The `addToken` function does not check if the token being added is already associated with the vault. This could lead to duplicate entries in the `tokens` mapping, potentially causing issues in token management.', 'Impact': 'Duplicate token entries in the `tokens` mapping, leading to potential confusion or errors in token management.', 'Location': 'Function `addToken`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Several critical functions, such as `setHarvester`, `setInsurancePool`, `setStakingPool`, and `setTreasury`, do not emit events when their respective state variables are changed. This lack of transparency makes it difficult to track changes to these important addresses.', 'Impact': 'Lack of event emission reduces transparency and makes it harder for off-chain systems or users to monitor and respond to changes in the contract state.', 'Location': 'Functions `setHarvester`, `setInsurancePool`, `setStakingPool`, `setTreasury`'}], 'IssueNumber': 10, 'OutputList': 9}",729.7907741069794,"### **[M-02] ERC20 return values not checked**

**Report Description**:  
The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do not revert if the transfer fails but return `false` instead. The `Manager.recoverToken` function does not check the return value of this function. Tokets that don't actually perform the transfer and return `false` are still counted as a correct transfer. Furthermore, tokens that do not correctly implement the EIP20 standard, like USDT, which does not return a success boolean, will revert.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unchecked ERC20 return values in the `recoverToken` function. The issue is entirely missed, and no corresponding response is provided.

---

### **[M-09] token -> vault mapping can be overwritten**

**Report Description**:  
One vault can have many tokens, but each token should only be assigned to a single vault. The `Manager` contract keeps a mapping of tokens to vaults in the `vaults[_token] => _vault` map and a mapping of vault to tokens in `tokens[vault] => token[]`. The `addToken` function can assign any token to a single vault and allows overwriting an existing `vaults[_token]` map entry with a different vault. This indirectly disassociates the previous vault for the token. Note that the previous vault's `tokens[_previousVault]` map still contains the token.

**Match in Response List**:  
Matches with the issue titled **""No Check for Duplicate Tokens in `addToken` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of duplicate tokens in the `addToken` function but misses the critical detail that the `vaults[_token]` mapping can be overwritten, disassociating a token from its previous vault. The response focuses on duplicate entries in the `tokens` mapping rather than the overwriting of the `vaults` mapping.

---

### **[M-13] manager.allowedVaults check missing for add/remove strategy**

**Report Description**:  
The `manager.allowedVaults` check is missing for `add/remove` strategy, unlike how it is used in `reorderStrategies()`. This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults. Given the critical access control that is missing on vaults here, this is classified as medium severity.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the missing `allowedVaults` check for the `add/remove` strategy functions. The issue is entirely missed, and no corresponding response is provided.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-09] token -> vault mapping can be overwritten**

**Missed Issues from Issue Report**:  
- **[M-02] ERC20 return values not checked**  
- **[M-13] manager.allowedVaults check missing for add/remove strategy**

---

### **Overall Assessment**  
The response list fails to address two out of three issues in the issue report. The only partially matched issue ([M-09]) is not fully covered, as the response misses the critical aspect of overwriting the `vaults` mapping. The response list focuses on other vulnerabilities but does not adequately address the specific issues raised in the report.","```
None.
```",0.0
