nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTLoanFacilitator.sol,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    // ==== constants ====

    /** 
     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     
     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%
     */
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    /// See {INFTLoanFacilitator-SCALAR}.
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    // ==== state variables ====

    /// See {INFTLoanFacilitator-originationFeeRate}.
    /// @dev starts at 1%
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    /// See {INFTLoanFacilitator-requiredImprovementRate}.
    /// @dev starts at 10%
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    /// See {INFTLoanFacilitator-lendTicketContract}.
    address public override lendTicketContract;

    /// See {INFTLoanFacilitator-borrowTicketContract}.
    address public override borrowTicketContract;

    /// See {INFTLoanFacilitator-loanInfo}.
    mapping(uint256 => Loan) public loanInfo;

    /// @dev tracks loan count
    uint256 private _nonce = 1;

    
    // ==== modifiers ====

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    // ==== constructor ====

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    // ==== state changing external functions ====

    /// See {INFTLoanFacilitator-createLoan}.
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    /// See {INFTLoanFacilitator-closeLoan}.
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-lend}.
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            // will underflow if amount < previousAmount
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    /// See {INFTLoanFacilitator-repayAndCloseLoan}.
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-seizeCollateral}.
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    // === owner state changing ===

    /**
     * @notice Sets lendTicketContract to _contract
     * @dev cannot be set if lendTicketContract is already set
     */
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    /**
     * @notice Sets borrowTicketContract to _contract
     * @dev cannot be set if borrowTicketContract is already set
     */
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    /**
     * @notice Updates originationFeeRate the faciliator keeps of each loan amount
     * @dev Cannot be set higher than 5%
     */
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    /**
     * @notice updates the percent improvement required of at least one loan term when buying out lender 
     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount
     * must be 10% higher or interest rate must be 10% lower. 
     * @dev Cannot be 0.
     */
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    // ==== external view ====

    /// See {INFTLoanFacilitator-loanInfoStruct}.
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    /// See {INFTLoanFacilitator-totalOwed}.
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-interestOwed}.
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-loanEndSeconds}.
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    // === private ===

    /// @dev Returns the total interest owed on loan
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 // SCALAR * 1e18
            + accumulatedInterest;
    }
}",3357,388,"[H-01] Can force borrower to pay huge interest
In the function `lend()`, the loan amount is used as a min loan amount. It can be matched as high as possible (realistically up to the collateral NFT's worth to remain in profit) and the borrower has to pay interest on the entire amount instead of just on the desired loan amount when the loan was created.
  [H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout
If an attacker already calls `lend()` to lend to a loan, the attacker can manipulate `loanInfo` by reentrancy attack when any lenders try to buyout. The attacker can set bad values of lendInfo (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.

[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy
If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.  [M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it
If an attacker (lender) lends to a loan, the attacker can always revert transactions when any lenders try to buyout, making anyone can not buyout the loan of the attacker.   [M-02] Protocol doesn't handle fee on transfer tokens
Since the borrower is able to specify any asset token, it is possible that loans will be created with tokens that support fee on transfer. If a fee on transfer asset token is chosen, the protocol will contain a point of failure on the original `lend()` call.

[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen
The `sendCollateralTo` will receive the collateral NFT when `closeLoan()` is called. However, if `sendCollateralTo` is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract.   [M-04] `requiredImprovementRate` can not work as expected when `previousInterestRate` less than 10 due to precision loss   [M-05] Borrowers lose funds if they call `repayAndCloseLoan` instead of `closeLoan`
The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan (matched with `lend`). Users should use closeLoan in this case but the contract should disallow calling `repayAndCloseLoan` because users can lose funds.
It performs a `ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount)` call where interest will be a high value accumulated from timestamp 0 and the loan.loanAmount is the initially desired min loan amount `minLoanAmount` set in `createLoan`. The user will lose these funds if they ever approved the contract (for example, for another loan).

[M-06] Might not get desired min loan amount if _originationFeeRate changes
Admins can update the origination fee by calling `updateOriginationFeeRate`. Note that a borrower does not receive their `minLoanAmount` set in createLoan, they only receive `(1 - originationFee) * minLoanAmount`, see lend. Therefore, they need to precalculate the `minLoanAmount` using the `current` origination fee to arrive at the post-fee amount that they actually receive. If admins then increase the fee, the borrower receives fewer funds than required to cover their rent and might become homeless.
  [M-07] `mintBorrowTicketTo` can be a contract with no `onERC721Received` method, which may cause the `BorrowTicket NFT` to be frozen and put users' funds at risk
“IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);”",10,,"pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    

    
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    

    
    
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    
    
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    
    address public override lendTicketContract;

    
    address public override borrowTicketContract;

    
    mapping(uint256 => Loan) public loanInfo;

    
    uint256 private _nonce = 1;

    
    

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    

    
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    

    
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    

    
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    

    
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 
            + accumulatedInterest;
    }
}",2789,3,7,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions that transfer tokens (e.g., `createLoan`, `closeLoan`, `lend`, `repayAndCloseLoan`, `seizeCollateral`)."",
        ""Verify that all arithmetic operations are protected against overflow/underflow, especially in `_interestOwed` and other interest rate calculations."",
        ""Ensure that external calls (e.g., `transferFrom`, `safeTransferFrom`) are handled safely and do not lead to unexpected behavior."",
        ""Review the use of `unchecked` blocks to ensure they do not introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-721 and ERC-20 standards, especially in token transfers and interactions."",
        ""Ensure that the `Ownable` contract is used correctly and that only the owner can perform critical operations.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the `_interestOwed` function to ensure it correctly calculates interest over time and handles edge cases."",
        ""Review the logic in the `lend` function, especially the conditions for updating loan terms and the enforcement of the required improvement rate."",
        ""Check the loan lifecycle management (creation, lending, repayment, collateral seizure) for logical consistency and edge cases.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that the lend and borrow ticket contracts are initialized correctly and securely."",
        ""Ensure that all external contract calls (e.g., `IERC721Mintable`, `ILendTicket`) are safe and that the contract addresses are validated."",
        ""Review the interaction with ERC-20 tokens, especially in the `lend` and `repayAndCloseLoan` functions, to ensure proper handling of transfers and fees.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that only the owner can set the lend and borrow ticket contracts (`setLendTicketContract`, `setBorrowTicketContract`)."",
        ""Verify that only the lender can seize collateral in the `seizeCollateral` function and that the borrower can close the loan in `closeLoan`."",
        ""Check that the `notClosed` modifier is correctly applied to prevent actions on closed loans.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify opportunities to reduce gas costs, especially in functions with complex logic like `lend` and `_interestOwed`."",
        ""Review the use of state variables and mappings to ensure efficient storage and access.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Ensure that the contract is protected against flash loan attacks, especially in functions that handle large amounts of tokens (e.g., `lend`, `repayAndCloseLoan`).""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities, especially in the `lend` function where loan terms can be updated."",
        ""Consider implementing commit-reveal schemes or other mechanisms to prevent front-running.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that there are mechanisms in place to halt the contract in case of emergencies, such as a pause function controlled by the owner.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract is an NFT loan facilitator that allows users to create loans using NFTs as collateral, lend funds to these loans, and manage the lifecycle of the loans including repayment and collateral seizure. The contract is designed to be secure, with checks for loan conditions, interest rates, and durations. It also includes mechanisms for origination fees and improvements in loan terms."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTLoanFacilitator"",
    ""Purpose"": ""Facilitates loans using NFTs as collateral, allowing users to lend and borrow funds with defined interest rates and durations."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""INFTLoanFacilitator""],
      ""Imports"": [
        ""IERC721"",
        ""SafeTransferLib"",
        ""ERC20"",
        ""Ownable"",
        ""INFTLoanFacilitator"",
        ""IERC721Mintable"",
        ""ILendTicket""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""INTEREST_RATE_DECIMALS"",
        ""Type"": ""uint8"",
        ""Purpose"": ""Defines the decimal precision for interest rates.""
      },
      {
        ""Name"": ""SCALAR"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Used for scaling interest rate calculations.""
      },
      {
        ""Name"": ""originationFeeRate"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Rate at which origination fees are charged on loans.""
      },
      {
        ""Name"": ""requiredImprovementRate"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum improvement required for loan terms to be updated.""
      },
      {
        ""Name"": ""lendTicketContract"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the lend ticket contract.""
      },
      {
        ""Name"": ""borrowTicketContract"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the borrow ticket contract.""
      },
      {
        ""Name"": ""loanInfo"",
        ""Type"": ""mapping(uint256 => Loan)"",
        ""Purpose"": ""Stores information about each loan.""
      },
      {
        ""Name"": ""_nonce"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Counter for generating unique loan IDs.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""createLoan"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new loan using an NFT as collateral."",
        ""Parameters"": [
          ""uint256 collateralTokenId"",
          ""address collateralContractAddress"",
          ""uint16 maxPerAnumInterest"",
          ""uint128 minLoanAmount"",
          ""address loanAssetContractAddress"",
          ""uint32 minDurationSeconds"",
          ""address mintBorrowTicketTo""
        ],
        ""Returns"": [""uint256 id""]
      },
      {
        ""Name"": ""closeLoan"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Closes a loan and returns the collateral to the borrower."",
        ""Parameters"": [""uint256 loanId"", ""address sendCollateralTo""],
        ""Returns"": []
      },
      {
        ""Name"": ""lend"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Lends funds to an existing loan, updating its terms if necessary."",
        ""Parameters"": [
          ""uint256 loanId"",
          ""uint16 interestRate"",
          ""uint128 amount"",
          ""uint32 durationSeconds"",
          ""address sendLendTicketTo""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""repayAndCloseLoan"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Repays a loan and closes it, transferring the collateral back to the borrower."",
        ""Parameters"": [""uint256 loanId""],
        ""Returns"": []
      },
      {
        ""Name"": ""seizeCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Seizes the collateral if the loan is not repaid on time."",
        ""Parameters"": [""uint256 loanId"", ""address sendCollateralTo""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLendTicketContract"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the address of the lend ticket contract."",
        ""Parameters"": [""address _contract""],
        ""Returns"": []
      },
      {
        ""Name"": ""setBorrowTicketContract"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the address of the borrow ticket contract."",
        ""Parameters"": [""address _contract""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawOriginationFees"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws accumulated origination fees."",
        ""Parameters"": [""address asset"", ""uint256 amount"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateOriginationFeeRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the origination fee rate."",
        ""Parameters"": [""uint32 _originationFeeRate""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateRequiredImprovementRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the required improvement rate for loan terms."",
        ""Parameters"": [""uint256 _improvementRate""],
        ""Returns"": []
      },
      {
        ""Name"": ""loanInfoStruct"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the loan information struct for a given loan ID."",
        ""Parameters"": [""uint256 loanId""],
        ""Returns"": [""Loan memory""]
      },
      {
        ""Name"": ""totalOwed"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total amount owed for a given loan ID."",
        ""Parameters"": [""uint256 loanId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""interestOwed"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the interest owed for a given loan ID."",
        ""Parameters"": [""uint256 loanId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""loanEndSeconds"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the end time in seconds for a given loan ID."",
        ""Parameters"": [""uint256 loanId""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_interestOwed"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the interest owed for a loan."",
        ""Parameters"": [
          ""uint256 loanAmount"",
          ""uint256 lastAccumulatedTimestamp"",
          ""uint256 perAnumInterestRate"",
          ""uint256 accumulatedInterest""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""notClosed"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the loan is not closed before performing certain actions."",
        ""Parameters"": [""uint256 loanId""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC721 for NFT transfers"",
    ""SafeTransferLib for ERC20 token transfers"",
    ""IERC721Mintable for minting lend and borrow tickets"",
    ""ILendTicket for loan facilitator transfers""
  ],
  ""SpecialMechanisms"": [
    ""Loan lifecycle management with creation, lending, repayment, and collateral seizure."",
    ""Interest rate calculations with precision handling."",
    ""Origination fee and required improvement rate mechanisms.""
  ],
  ""Questions"": [
    ""How are the lend and borrow ticket contracts initialized and secured?"",
    ""What are the potential risks associated with the interest rate calculations?"",
    ""How is the required improvement rate enforced and what are its implications on loan terms?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in `closeLoan` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `closeLoan` function transfers the collateral NFT back to the borrower before marking the loan as closed, potentially allowing a reentrancy attack if the collateral contract is malicious and calls back into the `NFTLoanFacilitator` contract before the state is updated."",
      ""Impact"": ""An attacker could exploit this to manipulate the loan state, leading to unauthorized actions or loss of funds."",
      ""Location"": ""closeLoan function""
    },
    {
      ""Issue"": ""Reentrancy Risk in `seizeCollateral` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `seizeCollateral` function transfers the collateral NFT to the specified address before marking the loan as closed, similar to `closeLoan`, potentially allowing a reentrancy attack if the recipient is a malicious contract."",
      ""Impact"": ""An attacker could exploit this to manipulate the loan state or perform unauthorized actions."",
      ""Location"": ""seizeCollateral function""
    },
    {
      ""Issue"": ""Uninitialized Loan Asset Contract Address"",
      ""Severity"": ""High"",
      ""Description"": ""The `createLoan` function does not validate that the `loanAssetContractAddress` is a valid ERC20 contract address, potentially leading to loans with invalid or malicious contract addresses."",
      ""Impact"": ""Loss of funds due to loans being created with invalid or malicious ERC20 contract addresses."",
      ""Location"": ""createLoan function""
    },
    {
      ""Issue"": ""Uninitialized Loan Ticket Contracts"",
      ""Severity"": ""High"",
      ""Description"": ""The `lendTicketContract` and `borrowTicketContract` addresses are not initialized in the constructor, which could lead to unexpected behavior or vulnerabilities if functions relying on these addresses are called before they are set."",
      ""Impact"": ""Functions that depend on these contracts may fail or behave unexpectedly, potentially leading to loss of funds or unauthorized access."",
      ""Location"": ""Constructor and `setLendTicketContract`, `setBorrowTicketContract` functions""
    },
    {
      ""Issue"": ""Lack of Input Validation in `createLoan` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createLoan` function does not validate the `collateralContractAddress`, `loanAssetContractAddress`, or `mintBorrowTicketTo` address, potentially leading to unexpected behavior or vulnerabilities if invalid addresses are provided."",
      ""Impact"": ""Invalid contract addresses could cause the function to fail or interact with unintended contracts, leading to potential security risks or loss of tokens."",
      ""Location"": ""createLoan function""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `_interestOwed` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_interestOwed` function performs arithmetic operations that could potentially overflow if the loan amount, interest rate, or duration are very large, leading to incorrect interest calculations."",
      ""Impact"": ""Incorrect interest calculations could lead to financial discrepancies or disputes between lenders and borrowers."",
      ""Location"": ""_interestOwed function""
    },
    {
      ""Issue"": ""Lack of Access Control in `seizeCollateral` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `seizeCollateral` function allows the lender to seize the collateral if the loan is overdue without additional checks, potentially allowing misuse if the lender's private key is compromised."",
      ""Impact"": ""An unauthorized party could seize the collateral if they gain access to the lender's private key, leading to loss of assets."",
      ""Location"": ""seizeCollateral function""
    },
    {
      ""Issue"": ""Incorrect Fee Calculation in `lend` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `lend` function calculates the facilitator's take using the formula `amount * originationFeeRate / SCALAR`, which could result in a fee larger than the loan amount if `originationFeeRate` is set too high."",
      ""Impact"": ""Incorrect fee distribution could lead to financial loss for either the facilitator or the borrower."",
      ""Location"": ""lend function""
    },
    {
      ""Issue"": ""Potential Front-Running in `lend` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `lend` function allows a lender to propose new terms for a loan without protection against front-running, where a malicious actor could monitor pending transactions and submit a better offer just before the original transaction is confirmed."",
      ""Impact"": ""Legitimate lenders may lose out on opportunities due to front-running attacks."",
      ""Location"": ""lend function""
    },
    {
      ""Issue"": ""Lack of Event Emission in Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Some critical state-changing functions, such as `updateOriginationFeeRate` and `updateRequiredImprovementRate`, do not emit events, making it difficult to track changes and leading to transparency issues."",
      ""Impact"": ""Lack of transparency in state changes could make it difficult to audit or monitor the contract, potentially leading to trust issues."",
      ""Location"": ""updateOriginationFeeRate and updateRequiredImprovementRate functions""
    },
    {
      ""Issue"": ""Unbounded Loop in `lend` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `lend` function contains complex logic that could lead to high gas consumption, especially if loan terms are updated frequently, potentially deterring users from interacting with the contract."",
      ""Impact"": ""High gas costs could deter users from interacting with the contract, leading to reduced usability and potential loss of users."",
      ""Location"": ""lend function""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 11
}",398.195198059082,77662.0,24.0,"### **[H-01] Can force borrower to pay huge interest**

**Report Description**:  
In the `lend()` function, the loan amount is used as a minimum loan amount. It can be matched as high as possible (up to the collateral NFT's worth), forcing the borrower to pay interest on the entire amount instead of just the desired loan amount when the loan was created.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves the manipulation of loan amounts and interest calculations, which is not covered in the response list.

---

### **[H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout**

**Report Description**:  
If an attacker calls `lend()` to lend to a loan, they can manipulate `loanInfo` via a reentrancy attack when lenders attempt to buyout. The attacker can set unfavorable terms (e.g., very long duration, 0 interest rate) that the lender does not expect.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific reentrancy risk in the context of loan buyouts.

---

### **[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy**

**Report Description**:  
If a borrower lends to their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT, loan amount, and accrued interest.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific reentrancy risk involving borrowers acting as their own lenders.

---

### **[M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it**

**Report Description**:  
If an attacker (lender) lends to a loan, they can always revert transactions when lenders attempt to buyout, preventing anyone from buying out the loan.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this denial-of-service (DoS) vulnerability.

---

### **[M-02] Protocol doesn't handle fee on transfer tokens**

**Report Description**:  
Since the borrower can specify any asset token, loans can be created with tokens that support fee on transfer. If such a token is chosen, the protocol will fail on the original `lend()` call.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the handling of fee-on-transfer tokens.

---

### **[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen**

**Report Description**:  
The `sendCollateralTo` address receives the collateral NFT when `closeLoan()` is called. If `sendCollateralTo` is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the risk of NFTs being frozen due to invalid recipient contracts.

---

### **[M-04] requiredImprovementRate can not work as expected when previousInterestRate less than 10 due to precision loss**

**Report Description**:  
The `requiredImprovementRate` may not function as expected when `previousInterestRate` is less than 10 due to precision loss in calculations.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this precision loss issue.

---

### **[M-05] Borrowers lose funds if they call repayAndCloseLoan instead of closeLoan**

**Report Description**:  
The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan. Users should use `closeLoan` in this case, but the contract does not disallow calling `repayAndCloseLoan`, leading to potential loss of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue of incorrect function usage leading to fund loss.

---

### **[M-06] Might not get desired min loan amount if _originationFeeRate changes**

**Report Description**:  
Admins can update the origination fee by calling `updateOriginationFeeRate`. Borrowers may receive fewer funds than required if the fee is increased after they calculate their `minLoanAmount`, potentially leaving them unable to cover their expenses.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue of fee changes affecting loan amounts.

---

### **[M-07] mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk**

**Report Description**:  
The `mintBorrowTicketTo` address may be a contract that does not support ERC721, causing the BorrowTicket NFT to be frozen and putting users' funds at risk.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the risk of NFTs being frozen due to invalid recipient contracts.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Can force borrower to pay huge interest**  
- **[H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout**  
- **[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy**  
- **[M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it**  
- **[M-02] Protocol doesn't handle fee on transfer tokens**  
- **[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen**  
- **[M-04] requiredImprovementRate can not work as expected when previousInterestRate less than 10 due to precision loss**  
- **[M-05] Borrowers lose funds if they call repayAndCloseLoan instead of closeLoan**  
- **[M-06] Might not get desired min loan amount if _originationFeeRate changes**  
- **[M-07] mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk**  

--- 

The response list does not adequately address the issues in the provided issue report. Most vulnerabilities, including reentrancy risks, precision loss, and improper handling of ERC721 tokens, are entirely missed. The response list focuses on unrelated issues, leaving critical vulnerabilities unaddressed.","```
None.
```",0.0
