nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,audit_plan,initial_analysis,execution_time,Comparison,matchList,MAP
Pools.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iFACTORY.sol"";

contract Pools {

    // Parameters
    bool private inited;
    uint public pooledVADER;
    uint public pooledUSDV;
    
    address public VADER;
    address public USDV;
    address public ROUTER;
    address public FACTORY;

    mapping(address => bool) _isMember;
    mapping(address => bool) _isAsset;
    mapping(address => bool) _isAnchor;

    mapping(address => uint) public mapToken_Units;
    mapping(address => mapping(address => uint)) public mapTokenMember_Units;
    mapping(address => uint) public mapToken_baseAmount;
    mapping(address => uint) public mapToken_tokenAmount;

    // Events
    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);
    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);
    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);
    event Sync(address indexed token, address indexed pool, uint addedAmount);
    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {}

    // Init
    function init(address _vader, address _usdv, address _router, address _factory) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
    }

    //====================================LIQUIDITY=========================================//

    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {
        require(token != USDV && token != VADER); // Prohibited
        uint _actualInputBase;
        if(base == VADER){
            if(!isAnchor(token)){               // If new Anchor
                _isAnchor[token] = true;
            }
            _actualInputBase = getAddedAmount(VADER, token);
        } else if (base == USDV) {
            if(!isAsset(token)){               // If new Asset
                _isAsset[token] = true;
            }
            _actualInputBase = getAddedAmount(USDV, token);
        }
        uint _actualInputToken = getAddedAmount(token, token);
        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);
        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member
        mapToken_Units[token] += liquidityUnits;                // Add in total
        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE
        mapToken_tokenAmount[token] += _actualInputToken;       // Add token
        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router
    }
    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly
    }
    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {
        require(base == USDV || base == VADER);
        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);
        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);
        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);
        mapToken_Units[token] -=_units;
        mapTokenMember_Units[token][member] -= _units;
        mapToken_baseAmount[token] -= outputBase;
        mapToken_tokenAmount[token] -= outputToken;
        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);
        transferOut(base, outputBase, member);
        transferOut(token, outputToken, member);
        return (outputBase, outputToken);
    }
    
    //=======================================SWAP===========================================//
    
    // Designed to be called by a router, but can be called directly
    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {
        if(toBase){
            uint _actualInput = getAddedAmount(token, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            mapToken_tokenAmount[token] += _actualInput;
            mapToken_baseAmount[token] -= outputAmount;
            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);
            transferOut(base, outputAmount, member);
        } else {
            uint _actualInput = getAddedAmount(base, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            mapToken_baseAmount[token] += _actualInput;
            mapToken_tokenAmount[token] -= outputAmount;
            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);
            transferOut(token, outputAmount, member);
        }
    }

    // Add to balances directly (must send first)
    function sync(address token, address pool) external {
        uint _actualInput = getAddedAmount(token, pool);
        if (token == VADER || token == USDV){
            mapToken_baseAmount[pool] += _actualInput;
        } else {
            mapToken_tokenAmount[pool] += _actualInput;
        // } else if(isSynth()){
        //     //burnSynth && deleteUnits
        }
        emit Sync(token, pool, _actualInput);
    }

    //======================================SYNTH=========================================//

    // Should be done with intention, is gas-intensive
    function deploySynth(address token) external {
        require(token != VADER || token != USDV);
        iFACTORY(FACTORY).deploySynth(token);
    }

    // Mint a Synth against its own pool
    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {
        require(iFACTORY(FACTORY).isSynth(getSynth(token)), ""!synth"");
        uint _actualInputBase = getAddedAmount(base, token);                    // Get input
        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units
        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output
        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self
        mapToken_Units[token] += _synthUnits;                                       // Add supply
        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE 
        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event
        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member
    }
    // Burn a Synth to get out BASE
    function burnSynth(address base, address token, address member) external returns (uint outputBase) {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata
        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self
        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units
        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output
        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE
        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event
        transferOut(base, outputBase, member);                                      // Send BASE to member
    }
    // Remove a synth, make other LPs richer
    function syncSynth(address token) external {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata
        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self
        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units
        emit SynthSync(token, _actualInputSynth, _unitsToDelete);
    }

    //======================================LENDING=========================================//
    
    // Assign units to callee (ie, a LendingRouter)
    function lockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][member] -= units;
        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol
    }
    // Assign units to callee (ie, a LendingRouter)
    function unlockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][msg.sender] -= units;      
        mapTokenMember_Units[token][member] += units;
    }

    //======================================HELPERS=========================================//

    // Safe adds
    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(_token == VADER && _pool != VADER){  // Want to know added VADER
            addedAmount = _balance - pooledVADER;
            pooledVADER = pooledVADER + addedAmount;
        } else if(_token == USDV) {             // Want to know added USDV
            addedAmount = _balance - pooledUSDV;
            pooledUSDV = pooledUSDV + addedAmount;
        } else {                                // Want to know added Asset/Anchor
            addedAmount = _balance - mapToken_tokenAmount[_pool];
        }
    }
    function transferOut(address _token, uint _amount, address _recipient) internal {
        if(_token == VADER){
            pooledVADER = pooledVADER - _amount; // Accounting
        } else if(_token == USDV) {
            pooledUSDV = pooledUSDV - _amount;  // Accounting
        }
        if(_recipient != address(this)){
            iERC20(_token).transfer(_recipient, _amount);
        }
    }

    function isMember(address member) public view returns(bool) {
        return _isMember[member];
    }
    function isAsset(address token) public view returns(bool) {
        return _isAsset[token];
    }
    function isAnchor(address token) public view returns(bool) {
        return _isAnchor[token];
    }
    function getPoolAmounts(address token) external view returns(uint, uint) {
        return (getBaseAmount(token), getTokenAmount(token));
    }
    function getBaseAmount(address token) public view returns(uint) {
        return mapToken_baseAmount[token];
    }
    function getTokenAmount(address token) public view returns(uint) {
        return mapToken_tokenAmount[token];
    }
    function getUnits(address token) external view returns(uint) {
        return mapToken_Units[token];
    }
    function getMemberUnits(address token, address member) external view returns(uint) {
        return mapTokenMember_Units[token][member];
    }
    function getSynth(address token) public view returns (address) {
        return iFACTORY(FACTORY).getSynth(token);
    }
    function isSynth(address token) public view returns (bool) {
        return iFACTORY(FACTORY).isSynth(token);
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
}",2964,248,"[H-01] Unhandled return value of transfer in transferOut() of Pools.sol
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements to handle these failures.
The transfer call on L211 of transferOut() could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.
 [H-11] Swap token can be traded as fake base token
The Pools.swap function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call swap(token, token, member, toBase=false)
The _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result.
It breaks the accounting for the pool as tokens are transferred in, but the base balance is increased (and token balance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.
Another example scenario is that the token pool amount can be stolen. Send tokenIn=baseAmount of tokens to the pool and call swap(base=token, token, member, toBase=false). Depending on the price of token relative to base this could be cheaper than trading with the base tokens.  [H-12] getAddedAmount can return wrong results
The getAddedAmount function only works correctly when called with (VADER/USDV, pool) or (pool, pool). However, when called with (token, pool) where token is neither VADER/USDV/pool, it returns the wrong results:
It gets the token balance
And subtracts it from the stored mapToken_tokenAmount[_pool] amount which can be that of a completely different token
Anyone can break individual pairs by calling sync(token1, token2) where the token1 balance is less than mapToken_tokenAmount[token2]. This will add the difference to mapToken_tokenAmount[token2] and break the accounting and result in a wrong swap logic.
 [H-13] 4 Synths can be minted with fake base token
The Pools.mintSynth function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call mintSynth(token, token, member).
The _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result.
It breaks the accounting for the pool as tokens are transferred in, but the base balance is increased.

[H-14] Missing access restriction on lockUnits/unlockUnits
The Pool.lockUnits allows anyone to steal pool tokens from a member and assign them to msg.sender. Anyone can steal pool tokens from any other user.
Recommend adding access control and require that msg.sender is the router or another authorized party.  [H-22] Users may unintentionally remove liquidity under a phishing attack.
The removeLiquidity function in Pools.sol uses tx.origin to determine the person who wants to remove liquidity. However, such a design is dangerous since the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack, and he could unintentionally remove liquidity.
 [M-01] User may not get IL protection if certain functions are called directly in Pools.sol
Functions removeLiquidity() and removeLiquidityDirectly() when called directly, do not provide the the user with IL protection unlike when calling the corresponding removeLiquidity() function in Router.sol. This should be prevented, at least for removeLiquidity() or highlighted in the specification and user documentation.  Recommend adding access control (e.g. via a modifier onlyRouter) so removeLiquidity() function of Pools contract can be called only from corresponding Router contract’s removeLiquidity() function which provides IL protection. Alternatively, highlight in the specification and user documentation about which contract interfaces provide IL protection to users.  [M-10] Incorrect operator used in deploySynth() of Pools.sol
The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s deploySynth() function.
However, the require() incorrectly uses the ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.
 [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()  [M-14] Pool functions can be called before initialization in _init_() of Pools.sol
All the external/public functions of Pools.sol can be called by other contracts even before Pools.solcontract is initialized. This can lead to exceptions, state corruption or incorrect accounting in other contracts, which may require redeployment of said contract.",10,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iFACTORY.sol"";

contract Pools {

    
    bool private inited;
    uint public pooledVADER;
    uint public pooledUSDV;
    
    address public VADER;
    address public USDV;
    address public ROUTER;
    address public FACTORY;

    mapping(address => bool) _isMember;
    mapping(address => bool) _isAsset;
    mapping(address => bool) _isAnchor;

    mapping(address => uint) public mapToken_Units;
    mapping(address => mapping(address => uint)) public mapTokenMember_Units;
    mapping(address => uint) public mapToken_baseAmount;
    mapping(address => uint) public mapToken_tokenAmount;

    
    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);
    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);
    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);
    event Sync(address indexed token, address indexed pool, uint addedAmount);
    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);

    
    
    constructor() {}

    
    function init(address _vader, address _usdv, address _router, address _factory) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
    }

    

    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {
        require(token != USDV && token != VADER); 
        uint _actualInputBase;
        if(base == VADER){
            if(!isAnchor(token)){               
                _isAnchor[token] = true;
            }
            _actualInputBase = getAddedAmount(VADER, token);
        } else if (base == USDV) {
            if(!isAsset(token)){               
                _isAsset[token] = true;
            }
            _actualInputBase = getAddedAmount(USDV, token);
        }
        uint _actualInputToken = getAddedAmount(token, token);
        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);
        mapTokenMember_Units[token][member] += liquidityUnits;  
        mapToken_Units[token] += liquidityUnits;                
        mapToken_baseAmount[token] += _actualInputBase;         
        mapToken_tokenAmount[token] += _actualInputToken;       
        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, tx.origin); 
    }
    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, msg.sender); 
    }
    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {
        require(base == USDV || base == VADER);
        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);
        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);
        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);
        mapToken_Units[token] -=_units;
        mapTokenMember_Units[token][member] -= _units;
        mapToken_baseAmount[token] -= outputBase;
        mapToken_tokenAmount[token] -= outputToken;
        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);
        transferOut(base, outputBase, member);
        transferOut(token, outputToken, member);
        return (outputBase, outputToken);
    }
    
    
    
    
    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {
        if(toBase){
            uint _actualInput = getAddedAmount(token, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            mapToken_tokenAmount[token] += _actualInput;
            mapToken_baseAmount[token] -= outputAmount;
            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);
            transferOut(base, outputAmount, member);
        } else {
            uint _actualInput = getAddedAmount(base, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            mapToken_baseAmount[token] += _actualInput;
            mapToken_tokenAmount[token] -= outputAmount;
            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);
            transferOut(token, outputAmount, member);
        }
    }

    
    function sync(address token, address pool) external {
        uint _actualInput = getAddedAmount(token, pool);
        if (token == VADER || token == USDV){
            mapToken_baseAmount[pool] += _actualInput;
        } else {
            mapToken_tokenAmount[pool] += _actualInput;
        
        
        }
        emit Sync(token, pool, _actualInput);
    }

    

    
    function deploySynth(address token) external {
        require(token != VADER || token != USDV);
        iFACTORY(FACTORY).deploySynth(token);
    }

    
    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {
        require(iFACTORY(FACTORY).isSynth(getSynth(token)), ""!synth"");
        uint _actualInputBase = getAddedAmount(base, token);                    
        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     
        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   
        mapTokenMember_Units[token][address(this)] += _synthUnits;                  
        mapToken_Units[token] += _synthUnits;                                       
        mapToken_baseAmount[token] += _actualInputBase;                             
        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   
        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         
    }
    
    function burnSynth(address base, address token, address member) external returns (uint outputBase) {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); 
        iERC20(getSynth(token)).burn(_actualInputSynth);                            
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               
        mapToken_Units[token] -= _unitsToDelete;                                    
        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    
        mapToken_baseAmount[token] -= outputBase;                                   
        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        
        transferOut(base, outputBase, member);                                      
    }
    
    function syncSynth(address token) external {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); 
        iERC20(getSynth(token)).burn(_actualInputSynth);                            
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               
        mapToken_Units[token] -= _unitsToDelete;                                    
        emit SynthSync(token, _actualInputSynth, _unitsToDelete);
    }

    
    
    
    function lockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][member] -= units;
        mapTokenMember_Units[token][msg.sender] += units;       
    }
    
    function unlockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][msg.sender] -= units;      
        mapTokenMember_Units[token][member] += units;
    }

    

    
    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(_token == VADER && _pool != VADER){  
            addedAmount = _balance - pooledVADER;
            pooledVADER = pooledVADER + addedAmount;
        } else if(_token == USDV) {             
            addedAmount = _balance - pooledUSDV;
            pooledUSDV = pooledUSDV + addedAmount;
        } else {                                
            addedAmount = _balance - mapToken_tokenAmount[_pool];
        }
    }
    function transferOut(address _token, uint _amount, address _recipient) internal {
        if(_token == VADER){
            pooledVADER = pooledVADER - _amount; 
        } else if(_token == USDV) {
            pooledUSDV = pooledUSDV - _amount;  
        }
        if(_recipient != address(this)){
            iERC20(_token).transfer(_recipient, _amount);
        }
    }

    function isMember(address member) public view returns(bool) {
        return _isMember[member];
    }
    function isAsset(address token) public view returns(bool) {
        return _isAsset[token];
    }
    function isAnchor(address token) public view returns(bool) {
        return _isAnchor[token];
    }
    function getPoolAmounts(address token) external view returns(uint, uint) {
        return (getBaseAmount(token), getTokenAmount(token));
    }
    function getBaseAmount(address token) public view returns(uint) {
        return mapToken_baseAmount[token];
    }
    function getTokenAmount(address token) public view returns(uint) {
        return mapToken_tokenAmount[token];
    }
    function getUnits(address token) external view returns(uint) {
        return mapToken_Units[token];
    }
    function getMemberUnits(address token, address member) external view returns(uint) {
        return mapTokenMember_Units[token][member];
    }
    function getSynth(address token) public view returns (address) {
        return iFACTORY(FACTORY).getSynth(token);
    }
    function isSynth(address token) public view returns (bool) {
        return iFACTORY(FACTORY).isSynth(token);
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
}",2584,6,4,"{'Findings': [{'Issue': 'Reentrancy Vulnerability in `transferOut` Function', 'Severity': 'High', 'Description': 'The `transferOut` function performs an external call to transfer tokens before updating the state. This can lead to reentrancy attacks where an attacker can recursively call the function to drain funds or manipulate the contract state.', 'Impact': 'Potential loss of funds or manipulation of contract state through reentrancy attacks.', 'Location': '`transferOut` function'}, {'Issue': 'Lack of Access Control in `init` Function', 'Severity': 'High', 'Description': 'The `init` function does not implement any access control mechanisms, allowing any user to initialize the contract and set critical addresses (VADER, USDV, ROUTER, FACTORY). This could lead to unauthorized initialization or re-initialization of the contract.', 'Impact': 'Unauthorized initialization could lead to manipulation of critical contract variables, potentially compromising the entire system.', 'Location': '`init` function'}, {'Issue': 'Incorrect Condition in `deploySynth` Function', 'Severity': 'Medium', 'Description': 'The `deploySynth` function uses an incorrect condition `require(token != VADER || token != USDV)`, which always evaluates to true. This could allow the deployment of synths for VADER or USDV tokens, which may not be intended.', 'Impact': 'Unintended deployment of synths for VADER or USDV tokens, potentially leading to unexpected behavior or vulnerabilities.', 'Location': '`deploySynth` function'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': 'The contract uses arithmetic operations without explicit checks for overflow/underflow. Although Solidity 0.8.x has built-in overflow/underflow protection, it is still good practice to handle these cases explicitly, especially in critical financial operations.', 'Impact': 'Incorrect calculations due to overflow/underflow could lead to unexpected behavior, such as incorrect liquidity calculations or token transfers.', 'Location': 'Multiple functions, including `addLiquidity`, `removeLiquidity`, and `swap`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': ""Some critical state-changing functions, such as `lockUnits`, `unlockUnits`, `deploySynth`, and `syncSynth`, do not emit events. This makes it difficult to track changes in the contract's state and could hinder debugging and auditing efforts."", 'Impact': 'Reduced transparency and traceability in state changes, which could complicate monitoring and auditing of the contract.', 'Location': '`lockUnits`, `unlockUnits`, `deploySynth`, and `syncSynth` functions'}, {'Issue': 'Inconsistent State Updates in `sync` Function', 'Severity': 'Low', 'Description': 'The `sync` function updates `mapToken_baseAmount` or `mapToken_tokenAmount` based on the token type but does not handle the case where the token is neither VADER nor USDV. This could lead to inconsistent state updates.', 'Impact': 'Inconsistent state updates could result in incorrect pool balances, affecting the accuracy of liquidity calculations.', 'Location': '`sync` function'}, {'Issue': 'Unrestricted Access to `lockUnits` and `unlockUnits` Functions', 'Severity': 'Medium', 'Description': 'The `lockUnits` and `unlockUnits` functions allow any user to lock or unlock units for any member without any restrictions. This could be exploited to manipulate liquidity units in unintended ways.', 'Impact': 'An attacker could manipulate liquidity units, potentially affecting the fairness and integrity of the pool.', 'Location': '`lockUnits` and `unlockUnits` functions'}], 'IssueNumber': 14, 'OutputList': 7}",,"{'ReviewingTheCode': ""The provided Solidity smart contract, named 'Pools', appears to be a decentralized finance (DeFi) protocol component that manages liquidity pools. It handles adding and removing liquidity, swapping tokens, and managing synthetic assets. The contract interacts with several external interfaces and utilizes utility functions for calculations."", 'IdentifyingKeyComponents': {'ContractName': 'Pools', 'Purpose': 'Manages liquidity pools, token swaps, and synthetic assets within a DeFi protocol.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['./interfaces/iERC20.sol', './interfaces/iUTILS.sol', './interfaces/iVADER.sol', './interfaces/iFACTORY.sol']}, 'StateVariables': [{'Name': 'inited', 'Type': 'bool', 'Purpose': 'Indicates whether the contract has been initialized.'}, {'Name': 'pooledVADER', 'Type': 'uint', 'Purpose': 'Tracks the total amount of VADER tokens pooled.'}, {'Name': 'pooledUSDV', 'Type': 'uint', 'Purpose': 'Tracks the total amount of USDV tokens pooled.'}, {'Name': 'VADER', 'Type': 'address', 'Purpose': 'Address of the VADER token contract.'}, {'Name': 'USDV', 'Type': 'address', 'Purpose': 'Address of the USDV token contract.'}, {'Name': 'ROUTER', 'Type': 'address', 'Purpose': 'Address of the router contract.'}, {'Name': 'FACTORY', 'Type': 'address', 'Purpose': 'Address of the factory contract.'}, {'Name': '_isMember', 'Type': 'mapping(address => bool)', 'Purpose': 'Tracks whether an address is a member.'}, {'Name': '_isAsset', 'Type': 'mapping(address => bool)', 'Purpose': 'Tracks whether a token is an asset.'}, {'Name': '_isAnchor', 'Type': 'mapping(address => bool)', 'Purpose': 'Tracks whether a token is an anchor.'}, {'Name': 'mapToken_Units', 'Type': 'mapping(address => uint)', 'Purpose': 'Tracks the total units of a token in the pool.'}, {'Name': 'mapTokenMember_Units', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Tracks the units of a token held by a member.'}, {'Name': 'mapToken_baseAmount', 'Type': 'mapping(address => uint)', 'Purpose': 'Tracks the base amount of a token in the pool.'}, {'Name': 'mapToken_tokenAmount', 'Type': 'mapping(address => uint)', 'Purpose': 'Tracks the token amount in the pool.'}], 'FunctionsAndModifiers': [{'Name': 'init', 'Visibility': 'public', 'Purpose': 'Initializes the contract with necessary addresses.', 'Parameters': ['address _vader', 'address _usdv', 'address _router', 'address _factory'], 'Returns': []}, {'Name': 'addLiquidity', 'Visibility': 'external', 'Purpose': 'Adds liquidity to the pool.', 'Parameters': ['address base', 'address token', 'address member'], 'Returns': ['uint liquidityUnits']}, {'Name': 'removeLiquidity', 'Visibility': 'external', 'Purpose': 'Removes liquidity from the pool.', 'Parameters': ['address base', 'address token', 'uint basisPoints'], 'Returns': ['uint outputBase', 'uint outputToken']}, {'Name': 'removeLiquidityDirectly', 'Visibility': 'external', 'Purpose': 'Removes liquidity directly from the pool.', 'Parameters': ['address base', 'address token', 'uint basisPoints'], 'Returns': ['uint outputBase', 'uint outputToken']}, {'Name': '_removeLiquidity', 'Visibility': 'internal', 'Purpose': 'Internal function to remove liquidity.', 'Parameters': ['address base', 'address token', 'uint basisPoints', 'address member'], 'Returns': ['uint outputBase', 'uint outputToken']}, {'Name': 'swap', 'Visibility': 'external', 'Purpose': 'Swaps tokens within the pool.', 'Parameters': ['address base', 'address token', 'address member', 'bool toBase'], 'Returns': ['uint outputAmount']}, {'Name': 'sync', 'Visibility': 'external', 'Purpose': 'Syncs the pool with the current token balances.', 'Parameters': ['address token', 'address pool'], 'Returns': []}, {'Name': 'deploySynth', 'Visibility': 'external', 'Purpose': 'Deploys a synthetic asset.', 'Parameters': ['address token'], 'Returns': []}, {'Name': 'mintSynth', 'Visibility': 'external', 'Purpose': 'Mints a synthetic asset.', 'Parameters': ['address base', 'address token', 'address member'], 'Returns': ['uint outputAmount']}, {'Name': 'burnSynth', 'Visibility': 'external', 'Purpose': 'Burns a synthetic asset.', 'Parameters': ['address base', 'address token', 'address member'], 'Returns': ['uint outputBase']}, {'Name': 'syncSynth', 'Visibility': 'external', 'Purpose': 'Syncs the synthetic asset with the pool.', 'Parameters': ['address token'], 'Returns': []}, {'Name': 'lockUnits', 'Visibility': 'external', 'Purpose': 'Locks units of a token for a member.', 'Parameters': ['uint units', 'address token', 'address member'], 'Returns': []}, {'Name': 'unlockUnits', 'Visibility': 'external', 'Purpose': 'Unlocks units of a token for a member.', 'Parameters': ['uint units', 'address token', 'address member'], 'Returns': []}, {'Name': 'getAddedAmount', 'Visibility': 'internal', 'Purpose': 'Calculates the added amount of a token.', 'Parameters': ['address _token', 'address _pool'], 'Returns': ['uint addedAmount']}, {'Name': 'transferOut', 'Visibility': 'internal', 'Purpose': 'Transfers tokens out of the pool.', 'Parameters': ['address _token', 'uint _amount', 'address _recipient'], 'Returns': []}, {'Name': 'isMember', 'Visibility': 'public', 'Purpose': 'Checks if an address is a member.', 'Parameters': ['address member'], 'Returns': ['bool']}, {'Name': 'isAsset', 'Visibility': 'public', 'Purpose': 'Checks if a token is an asset.', 'Parameters': ['address token'], 'Returns': ['bool']}, {'Name': 'isAnchor', 'Visibility': 'public', 'Purpose': 'Checks if a token is an anchor.', 'Parameters': ['address token'], 'Returns': ['bool']}, {'Name': 'getPoolAmounts', 'Visibility': 'external', 'Purpose': 'Retrieves the base and token amounts in the pool.', 'Parameters': ['address token'], 'Returns': ['uint', 'uint']}, {'Name': 'getBaseAmount', 'Visibility': 'public', 'Purpose': 'Retrieves the base amount of a token in the pool.', 'Parameters': ['address token'], 'Returns': ['uint']}, {'Name': 'getTokenAmount', 'Visibility': 'public', 'Purpose': 'Retrieves the token amount in the pool.', 'Parameters': ['address token'], 'Returns': ['uint']}, {'Name': 'getUnits', 'Visibility': 'external', 'Purpose': 'Retrieves the total units of a token in the pool.', 'Parameters': ['address token'], 'Returns': ['uint']}, {'Name': 'getMemberUnits', 'Visibility': 'external', 'Purpose': 'Retrieves the units of a token held by a member.', 'Parameters': ['address token', 'address member'], 'Returns': ['uint']}, {'Name': 'getSynth', 'Visibility': 'public', 'Purpose': 'Retrieves the synthetic asset address for a token.', 'Parameters': ['address token'], 'Returns': ['address']}, {'Name': 'isSynth', 'Visibility': 'public', 'Purpose': 'Checks if a token is a synthetic asset.', 'Parameters': ['address token'], 'Returns': ['bool']}, {'Name': 'UTILS', 'Visibility': 'public', 'Purpose': 'Retrieves the utility contract address.', 'Parameters': [], 'Returns': ['address']}]}, 'ExternalInteractions': ['iERC20', 'iUTILS', 'iVADER', 'iFACTORY'], 'SpecialMechanisms': ['Liquidity pool management', 'Token swapping', 'Synthetic asset minting and burning', 'Utility functions for calculations'], 'Questions': [""How is the 'getAddedAmount' function ensuring accurate calculations?"", 'What are the specific roles of the ROUTER and FACTORY contracts?', 'Are there any safeguards against reentrancy attacks?', 'How are the synthetic assets integrated and managed within the pool?']}",660.9776899814606,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Unhandled return value of transfer in transferOut() of Pools.sol**

**Report Description**:  
The `transferOut()` function in `Pools.sol` does not handle the return value of the `transfer` call. Some ERC20 tokens may return `false` on failure instead of reverting. Not checking the return value could allow token transfers to silently fail, especially when dealing with untrusted tokens supplied by users. This oversight may lead to discrepancies in token balances and potential security vulnerabilities if malicious tokens are used.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unhandled return values in the `transferOut` function. The closest match is the ""Reentrancy Vulnerability in `transferOut` Function,"" which focuses on reentrancy rather than the return value issue. This is a critical oversight, as the unhandled return value could lead to silent failures and vulnerabilities when interacting with non-standard ERC20 tokens.

---

#### **[H-11] Swap token can be traded as fake base token**

**Report Description**:  
The `Pools.swap` function does not check if `base` is one of the base tokens. This allows an attacker to set `base=token` and call `swap(token, token, member, toBase=false)`, leading to incorrect swap results and broken accounting. This could result in liquidity providers (LPs) being unable to withdraw funds correctly and others being unable to swap correctly. Additionally, it could allow attackers to steal token pool amounts by exploiting the incorrect swap logic.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of fake base tokens in the `swap` function. This is a significant vulnerability that could lead to incorrect accounting and potential theft of funds, but it is entirely missed in the response list.

---

#### **[H-12] getAddedAmount can return wrong results**

**Report Description**:  
The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. When called with `(token, pool)` where `token` is neither `VADER/USDV/pool`, it returns incorrect results. This could break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`, leading to incorrect accounting and swap logic.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect results from the `getAddedAmount` function. This is a critical vulnerability that could lead to broken accounting and incorrect swap logic, but it is entirely missed in the response list.

---

#### **[H-13] Synths can be minted with fake base token**

**Report Description**:  
The `Pools.mintSynth` function does not check if `base` is one of the base tokens. This allows an attacker to set `base=token` and call `mintSynth(token, token, member)`, leading to incorrect accounting and broken swap logic. This could result in tokens being transferred in, but the `base` balance being increased, leading to incorrect accounting.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of fake base tokens in the `mintSynth` function. This is a significant vulnerability that could lead to incorrect accounting and broken swap logic, but it is entirely missed in the response list.

---

#### **[H-14] Missing access restriction on lockUnits/unlockUnits**

**Report Description**:  
The `Pool.lockUnits` function allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`. This could be exploited to manipulate liquidity units in unintended ways. The recommendation is to add access control and require that `msg.sender` is the router or another authorized party.

**Match in Response List**:  
Matches with the issue titled **""Unrestricted Access to `lockUnits` and `unlockUnits` Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of unrestricted access to the `lockUnits` and `unlockUnits` functions. It correctly explains the risks associated with allowing any user to manipulate liquidity units, which aligns with the issue report.

---

#### **[H-22] Users may unintentionally remove liquidity under a phishing attack**

**Report Description**:  
The `removeLiquidity` function in `Pools.sol` uses `tx.origin` to determine the person who wants to remove liquidity. This design is dangerous because the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack. This could lead to users unintentionally removing liquidity.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of using `tx.origin` in the `removeLiquidity` function. This is a critical vulnerability that could lead to users unintentionally removing liquidity under a phishing attack, but it is entirely missed in the response list.

---

#### **[M-01] User may not get IL protection if certain functions are called directly in Pools.sol**

**Report Description**:  
Functions `removeLiquidity()` and `removeLiquidityDirectly()` when called directly do not provide the user with IL protection, unlike when calling the corresponding `removeLiquidity()` function in `Router.sol`. This should be prevented or highlighted in the specification and user documentation.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing IL protection when calling `removeLiquidity()` and `removeLiquidityDirectly()` directly. This is a significant oversight that could lead to users not receiving IL protection, but it is entirely missed in the response list.

---

#### **[M-10] Incorrect operator used in deploySynth() of Pools.sol**

**Report Description**:  
The `deploySynth()` function in `Pools.sol` incorrectly uses the `||` operator instead of `&&` in the `require` statement. This allows both VADER and USDV to be supplied as the token parameters, which could allow an attacker to deploy either VADER or USDV as a Synth. This will break assumptions throughout the entire protocol, potentially leading to protocol failure and loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Condition in `deploySynth` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of the incorrect condition in the `deploySynth` function. It correctly explains the risks associated with allowing VADER or USDV to be deployed as Synths, which aligns with the issue report.

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:  
The `init` function in most Solidity contracts can be called by everyone, allowing any user to initialize the contract and set critical addresses (VADER, USDV, ROUTER, FACTORY). This could lead to unauthorized initialization or re-initialization of the contract.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control in `init` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of missing access control in the `init` function. It correctly explains the risks associated with unauthorized initialization, which aligns with the issue report.

---

#### **[M-14] Pool functions can be called before initialization in _init_() of Pools.sol**

**Report Description**:  
All the external/public functions of `Pools.sol` can be called by other contracts even before `Pools.sol` is initialized. This can lead to exceptions, state corruption, or incorrect accounting in other contracts, which may require redeployment of said contract.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of calling pool functions before initialization. This is a significant vulnerability that could lead to state corruption or incorrect accounting, but it is entirely missed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-14] Missing access restriction on lockUnits/unlockUnits**
- **[M-10] Incorrect operator used in deploySynth() of Pools.sol**
- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:  
*None*

**Missed Issues from Issue Report**:

- **[H-01] Unhandled return value of transfer in transferOut() of Pools.sol**
- **[H-11] Swap token can be traded as fake base token**
- **[H-12] getAddedAmount can return wrong results**
- **[H-13] Synths can be minted with fake base token**
- **[H-22] Users may unintentionally remove liquidity under a phishing attack**
- **[M-01] User may not get IL protection if certain functions are called directly in Pools.sol**
- **[M-14] Pool functions can be called before initialization in _init_() of Pools.sol**

--- 

The response list covers only 3 out of 10 issues, leaving significant vulnerabilities unaddressed. The missed issues include critical vulnerabilities such as unhandled return values, fake base tokens, incorrect accounting, and phishing attacks. These gaps highlight the need for a more comprehensive review of the contract's security.","```
1. Missing access restriction on lockUnits/unlockUnits
2. Incorrect operator used in deploySynth() of Pools.sol
3. Init function can be called by everyone
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - **True Positive 1**: ""Missing access restriction on lockUnits/unlockUnits"" corresponds to the issue: ""Unrestricted Access to `lockUnits` and `unlockUnits` Functions"" at rank 7.
   - **True Positive 2**: ""Incorrect operator used in deploySynth() of Pools.sol"" corresponds to the issue: ""Incorrect Condition in `deploySynth` Function"" at rank 3.
   - **True Positive 3**: ""Init function can be called by everyone"" corresponds to the issue: ""Lack of Access Control in `init` Function"" at rank 2.

2. **Calculate the precision at each rank**:
   - **Precision at rank 2 (P@2)**: 1/2 = 0.5
   - **Precision at rank 3 (P@3)**: 2/3 ≈ 0.6667
   - **Precision at rank 7 (P@7)**: 3/7 ≈ 0.4286

3. **Average the precision values**:
   - **AP** = (0.5 + 0.6667 + 0.4286) / 3 ≈ 0.5318

**Output**:
0.5318"
USDV.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";

contract USDV is iERC20 {

    // ERC-20 Parameters
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Parameters
    bool private inited;
    uint public nextEraTime;
    uint public blockDelay;

    address public VADER;
    address public VAULT;
    address public ROUTER;

    mapping(address => uint) public lastBlock;

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }
    // Stop flash attacks
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool isMatured){
        if(lastBlock[tx.origin] + blockDelay <= block.number){ // Stops an EOA doing a flash attack in same block
            return true;
        }
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
        name = 'VADER STABLE DOLLAR';
        symbol = 'USDV';
        decimals = 18;
        totalSupply = 0;
    }
    function init(address _vader, address _vault, address _router) external {
        require(inited == false);
        inited = true;
        VADER = _vader;
        VAULT = _vault;
        ROUTER = _router;
        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();
    }

    //========================================iERC20=========================================//
    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    // TransferTo function
    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. 
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(sender != address(0), ""sender"");
            _balances[sender] -= amount;
            _balances[recipient] += amount;
            emit Transfer(sender, recipient, amount);
            _checkIncentives();
        }
    }
    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(account != address(0), ""recipient"");
            totalSupply += amount;
            _balances[account] += amount;
            emit Transfer(address(0), account, amount);
        }
    }
    // Burn supply
    function burn(uint amount) external virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender)- amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(account != address(0), ""address err"");
            _balances[account] -= amount;
            totalSupply -= amount;
            emit Transfer(account, address(0), amount);
        }
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newDelay) external onlyDAO {
        blockDelay = newDelay;
    }

   //======================================INCENTIVES========================================//
    // Internal - Update incentives function
    function _checkIncentives() private {
        if (block.timestamp >= nextEraTime && emitting()) {                 // If new Era
            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _balance = iERC20(VADER).balanceOf(address(this));         // Get spare VADER
            if(_balance > 4){
                uint _USDVShare = _balance/2;                                   // Get 50%
                _convert(address(this), _USDVShare);                            // Convert it
                if(balanceOf(address(this)) > 2){
                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              // Send half USDV to ROUTER
                    _transfer(address(this), VAULT, balanceOf(address(this)));                   // Send rest to VAULT
                }
                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   // Send half VADER to ROUTER
                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      // Send rest to VAULT
            }
        }
    }
    
    //======================================ASSET MINTING========================================//
    // Convert to USDV
    function convert(uint amount) external returns(uint) {
        return convertForMember(msg.sender, amount);
    }
    // Convert for members
    function convertForMember(address member, uint amount) public returns(uint) {
        getFunds(VADER, amount);
        return _convert(member, amount);
    }
    // Internal convert
    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){
        if(minting()){
            lastBlock[tx.origin] = block.number;                    // Record first
            iERC20(VADER).burn(amount);
            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); // Critical pricing functionality
            _mint(_member, _convertAmount);
        }
    }
    // Redeem to VADER
    function redeem(uint amount) external returns(uint) {
        return redeemForMember(msg.sender, amount);
    }
    // Contracts to redeem for members
    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {
        _transfer(msg.sender, VADER, amount);                   // Move funds
        redeemAmount = iVADER(VADER).redeemToMember(member);    // Ask VADER to redeem
        lastBlock[tx.origin] = block.number;                    // Must record block AFTER the tx
    }

    //============================== ASSETS ================================//

    function getFunds(address token, uint amount) internal {
        if(token == address(this)){
            _transfer(msg.sender, address(this), amount);
        } else {
            if(tx.origin==msg.sender){
                require(iERC20(token).transferTo(address(this), amount));
            }else{
                require(iERC20(token).transferFrom(msg.sender, address(this), amount));
            }
        }
    }

    //============================== HELPERS ================================//

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function minting() public view returns(bool){
        return iVADER(VADER).minting();
    }

}",1842,219,"[H-02] Flash attack mitigation does not work as intended in USDV.sol
One of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number
However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0, which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: ""// Stops an EOA from doing a flash attack in the same block""  [H-16] Tokens can be stolen through transferTo
 I know that it's stated that:
VADER, USDV, SYNTHS all employ the transferTo() function, which interrogates for tx.origin and skips approvals. The author does not subscribe to the belief that this is dangerous  [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()

",3,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";

contract USDV is iERC20 {

    
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    
    bool private inited;
    uint public nextEraTime;
    uint public blockDelay;

    address public VADER;
    address public VAULT;
    address public ROUTER;

    mapping(address => uint) public lastBlock;

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }
    
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool isMatured){
        if(lastBlock[tx.origin] + blockDelay <= block.number){ 
            return true;
        }
    }

    
    
    constructor() {
        name = 'VADER STABLE DOLLAR';
        symbol = 'USDV';
        decimals = 18;
        totalSupply = 0;
    }
    function init(address _vader, address _vault, address _router) external {
        require(inited == false);
        inited = true;
        VADER = _vader;
        VAULT = _vault;
        ROUTER = _router;
        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();
    }

    
    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    
    
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        if(amount > 0){                                     
            require(sender != address(0), ""sender"");
            _balances[sender] -= amount;
            _balances[recipient] += amount;
            emit Transfer(sender, recipient, amount);
            _checkIncentives();
        }
    }
    
    function _mint(address account, uint amount) internal virtual {
        if(amount > 0){                                     
            require(account != address(0), ""recipient"");
            totalSupply += amount;
            _balances[account] += amount;
            emit Transfer(address(0), account, amount);
        }
    }
    
    function burn(uint amount) external virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender)- amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        if(amount > 0){                                     
            require(account != address(0), ""address err"");
            _balances[account] -= amount;
            totalSupply -= amount;
            emit Transfer(account, address(0), amount);
        }
    }

    
    
    function setParams(uint newDelay) external onlyDAO {
        blockDelay = newDelay;
    }

   
    
    function _checkIncentives() private {
        if (block.timestamp >= nextEraTime && emitting()) {                 
            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _balance = iERC20(VADER).balanceOf(address(this));         
            if(_balance > 4){
                uint _USDVShare = _balance/2;                                   
                _convert(address(this), _USDVShare);                            
                if(balanceOf(address(this)) > 2){
                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              
                    _transfer(address(this), VAULT, balanceOf(address(this)));                   
                }
                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   
                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      
            }
        }
    }
    
    
    
    function convert(uint amount) external returns(uint) {
        return convertForMember(msg.sender, amount);
    }
    
    function convertForMember(address member, uint amount) public returns(uint) {
        getFunds(VADER, amount);
        return _convert(member, amount);
    }
    
    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){
        if(minting()){
            lastBlock[tx.origin] = block.number;                    
            iERC20(VADER).burn(amount);
            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); 
            _mint(_member, _convertAmount);
        }
    }
    
    function redeem(uint amount) external returns(uint) {
        return redeemForMember(msg.sender, amount);
    }
    
    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {
        _transfer(msg.sender, VADER, amount);                   
        redeemAmount = iVADER(VADER).redeemToMember(member);    
        lastBlock[tx.origin] = block.number;                    
    }

    

    function getFunds(address token, uint amount) internal {
        if(token == address(this)){
            _transfer(msg.sender, address(this), amount);
        } else {
            if(tx.origin==msg.sender){
                require(iERC20(token).transferTo(address(this), amount));
            }else{
                require(iERC20(token).transferFrom(msg.sender, address(this), amount));
            }
        }
    }

    

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function minting() public view returns(bool){
        return iVADER(VADER).minting();
    }

}",1487,2,1,"{'Findings': [{'Issue': 'Reentrancy Vulnerability in `_transfer` Function', 'Severity': 'High', 'Description': 'The `_transfer` function does not follow the checks-effects-interactions pattern, making it susceptible to reentrancy attacks. The function updates the state after emitting the `Transfer` event or calling `_checkIncentives`, which could be exploited by a malicious contract to re-enter the function before the state is updated.', 'Impact': 'An attacker could potentially drain funds from the contract by repeatedly calling the `_transfer` function before the balances are updated, leading to loss of funds or manipulation of contract state.', 'Location': 'Function: `_transfer`'}, {'Issue': 'Uninitialized State Variable `inited`', 'Severity': 'Medium', 'Description': 'The state variable `inited` is not initialized in the constructor, which could lead to unintended behavior if the `init` function is not called before other functions that depend on it. This could potentially allow the contract to be used in an uninitialized state.', 'Impact': 'The contract could be used before it is properly initialized, leading to unexpected behavior or vulnerabilities.', 'Location': 'State Variable: `inited`'}, {'Issue': 'Lack of Input Validation in `init` Function', 'Severity': 'Medium', 'Description': 'The `init` function does not validate the addresses passed as parameters (`_vader`, `_vault`, `_router`). If these addresses are set to invalid or malicious contracts, it could lead to unexpected behavior or vulnerabilities.', 'Impact': 'Invalid or malicious addresses could compromise the functionality of the contract, leading to potential loss of funds or other security risks.', 'Location': 'Function: `init`'}, {'Issue': 'Potential Front-Running in `convert` and `redeem` Functions', 'Severity': 'Medium', 'Description': 'The `convert` and `redeem` functions update the `lastBlock` mapping after the main logic is executed. This could potentially allow an attacker to front-run these transactions by observing the state changes and submitting their own transactions before the `lastBlock` is updated.', 'Impact': 'Front-running could lead to unfair advantages for attackers, potentially resulting in loss of funds or other unintended consequences.', 'Location': 'Functions: `convert`, `redeem`'}, {'Issue': 'Unrestricted Access to `setParams` Function', 'Severity': 'Medium', 'Description': 'The `setParams` function is protected by the `onlyDAO` modifier, but there is no mechanism to ensure that the `DAO` address is secure or trustworthy. If the `DAO` address is compromised, an attacker could change critical parameters.', 'Impact': 'Compromised `DAO` address could allow an attacker to modify contract parameters, potentially leading to security vulnerabilities or loss of funds.', 'Location': 'Function: `setParams`'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': ""The contract uses arithmetic operations without explicit checks for overflow/underflow, especially in functions like `_transfer`, `_mint`, and `_burn`. Although Solidity 0.8.x has built-in overflow/underflow protection, it's good practice to ensure that these operations are safe."", 'Impact': 'If not handled correctly, integer overflow/underflow could lead to unexpected behavior, such as incorrect token balances or unauthorized actions.', 'Location': 'Functions: `_transfer`, `_mint`, `_burn`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Some critical functions, such as `setParams`, do not emit events when important state changes occur. Events are crucial for off-chain monitoring and auditing of contract activities.', 'Impact': 'Lack of event emission makes it difficult to track changes in the contract state, which could hinder debugging, auditing, and transparency.', 'Location': 'Function: `setParams`'}, {'Issue': 'Potential Flash Loan Vulnerability in `_convert` Function', 'Severity': 'High', 'Description': 'The `_convert` function uses the `flashProof` modifier to prevent flash loans, but the implementation of `isMature` is not robust. An attacker could potentially manipulate the block number to bypass this check.', 'Impact': 'An attacker could exploit this to perform unauthorized conversions, leading to loss of funds or manipulation of the token supply.', 'Location': 'Function: `_convert`'}], 'IssueNumber': 11, 'OutputList': 8}",,"{'ReviewingTheCode': 'The provided smart contract, USDV, is an ERC20 token implementation with additional functionalities for interacting with VADER and ROUTER contracts. It includes features for token transfers, approvals, minting, burning, and conversions between VADER and USDV tokens. The contract also implements a mechanism to prevent flash loan attacks and includes incentives for token holders.', 'IdentifyingKeyComponents': {'ContractName': 'USDV', 'Purpose': 'To implement an ERC20 token with additional functionalities for interacting with VADER and ROUTER contracts, including token conversions, incentives, and flash loan attack prevention.', 'InheritanceAndImports': {'InheritsFrom': ['iERC20'], 'Imports': ['./interfaces/iERC20.sol', './interfaces/iVADER.sol', './interfaces/iROUTER.sol']}, 'StateVariables': [{'Name': 'name', 'Type': 'string', 'Purpose': 'Name of the token'}, {'Name': 'symbol', 'Type': 'string', 'Purpose': 'Symbol of the token'}, {'Name': 'decimals', 'Type': 'uint', 'Purpose': 'Number of decimals the token uses'}, {'Name': 'totalSupply', 'Type': 'uint', 'Purpose': 'Total supply of the token'}, {'Name': '_balances', 'Type': 'mapping(address => uint)', 'Purpose': 'Mapping of addresses to their token balances'}, {'Name': '_allowances', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping of addresses to their allowances granted to other addresses'}, {'Name': 'inited', 'Type': 'bool', 'Purpose': 'Flag to indicate if the contract has been initialized'}, {'Name': 'nextEraTime', 'Type': 'uint', 'Purpose': 'Timestamp for the next era in the incentive mechanism'}, {'Name': 'blockDelay', 'Type': 'uint', 'Purpose': 'Block delay to prevent flash loan attacks'}, {'Name': 'VADER', 'Type': 'address', 'Purpose': 'Address of the VADER token contract'}, {'Name': 'VAULT', 'Type': 'address', 'Purpose': 'Address of the VAULT contract'}, {'Name': 'ROUTER', 'Type': 'address', 'Purpose': 'Address of the ROUTER contract'}, {'Name': 'lastBlock', 'Type': 'mapping(address => uint)', 'Purpose': 'Mapping of addresses to the last block they interacted with the contract'}], 'FunctionsAndModifiers': [{'Name': 'onlyDAO', 'Visibility': 'modifier', 'Purpose': 'Restricts function access to the DAO', 'Parameters': [], 'Returns': []}, {'Name': 'flashProof', 'Visibility': 'modifier', 'Purpose': 'Ensures the transaction is mature to prevent flash loan attacks', 'Parameters': [], 'Returns': []}, {'Name': 'isMature', 'Visibility': 'public', 'Purpose': 'Checks if the transaction is mature', 'Parameters': [], 'Returns': ['bool']}, {'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the token with a name, symbol, and decimals', 'Parameters': [], 'Returns': []}, {'Name': 'init', 'Visibility': 'external', 'Purpose': 'Initializes the contract with VADER, VAULT, and ROUTER addresses', 'Parameters': ['address _vader', 'address _vault', 'address _router'], 'Returns': []}, {'Name': 'balanceOf', 'Visibility': 'public', 'Purpose': 'Returns the balance of a given account', 'Parameters': ['address account'], 'Returns': ['uint']}, {'Name': 'allowance', 'Visibility': 'public', 'Purpose': 'Returns the remaining number of tokens that spender is allowed to spend on behalf of owner', 'Parameters': ['address owner', 'address spender'], 'Returns': ['uint']}, {'Name': 'transfer', 'Visibility': 'external', 'Purpose': 'Transfers tokens from the caller to a recipient', 'Parameters': ['address recipient', 'uint amount'], 'Returns': ['bool']}, {'Name': 'approve', 'Visibility': 'external', 'Purpose': 'Allows spender to spend up to a certain amount of tokens on behalf of the caller', 'Parameters': ['address spender', 'uint amount'], 'Returns': ['bool']}, {'Name': '_approve', 'Visibility': 'internal', 'Purpose': 'Internal function to set allowances', 'Parameters': ['address owner', 'address spender', 'uint amount'], 'Returns': []}, {'Name': 'transferFrom', 'Visibility': 'external', 'Purpose': 'Transfers tokens from a sender to a recipient on behalf of the owner', 'Parameters': ['address sender', 'address recipient', 'uint amount'], 'Returns': ['bool']}, {'Name': 'transferTo', 'Visibility': 'external', 'Purpose': 'Transfers tokens from the transaction origin to a recipient', 'Parameters': ['address recipient', 'uint amount'], 'Returns': ['bool']}, {'Name': '_transfer', 'Visibility': 'internal', 'Purpose': 'Internal function to handle token transfers', 'Parameters': ['address sender', 'address recipient', 'uint amount'], 'Returns': []}, {'Name': '_mint', 'Visibility': 'internal', 'Purpose': 'Internal function to mint new tokens', 'Parameters': ['address account', 'uint amount'], 'Returns': []}, {'Name': 'burn', 'Visibility': 'external', 'Purpose': ""Burns tokens from the caller's balance"", 'Parameters': ['uint amount'], 'Returns': []}, {'Name': 'burnFrom', 'Visibility': 'external', 'Purpose': 'Burns tokens from a specified account on behalf of the caller', 'Parameters': ['address account', 'uint amount'], 'Returns': []}, {'Name': '_burn', 'Visibility': 'internal', 'Purpose': 'Internal function to handle token burning', 'Parameters': ['address account', 'uint amount'], 'Returns': []}, {'Name': 'setParams', 'Visibility': 'external', 'Purpose': 'Sets the block delay parameter', 'Parameters': ['uint newDelay'], 'Returns': []}, {'Name': '_checkIncentives', 'Visibility': 'private', 'Purpose': 'Checks and distributes incentives if the next era has started', 'Parameters': [], 'Returns': []}, {'Name': 'convert', 'Visibility': 'external', 'Purpose': 'Converts VADER tokens to USDV tokens', 'Parameters': ['uint amount'], 'Returns': ['uint']}, {'Name': 'convertForMember', 'Visibility': 'public', 'Purpose': 'Converts VADER tokens to USDV tokens for a specified member', 'Parameters': ['address member', 'uint amount'], 'Returns': ['uint']}, {'Name': '_convert', 'Visibility': 'internal', 'Purpose': 'Internal function to handle token conversion', 'Parameters': ['address _member', 'uint amount'], 'Returns': ['uint']}, {'Name': 'redeem', 'Visibility': 'external', 'Purpose': 'Redeems USDV tokens for VADER tokens', 'Parameters': ['uint amount'], 'Returns': ['uint']}, {'Name': 'redeemForMember', 'Visibility': 'public', 'Purpose': 'Redeems USDV tokens for VADER tokens for a specified member', 'Parameters': ['address member', 'uint amount'], 'Returns': ['uint']}, {'Name': 'getFunds', 'Visibility': 'internal', 'Purpose': 'Internal function to transfer funds to the contract', 'Parameters': ['address token', 'uint amount'], 'Returns': []}, {'Name': 'DAO', 'Visibility': 'public', 'Purpose': 'Returns the address of the DAO', 'Parameters': [], 'Returns': ['address']}, {'Name': 'emitting', 'Visibility': 'public', 'Purpose': 'Checks if the VADER contract is emitting tokens', 'Parameters': [], 'Returns': ['bool']}, {'Name': 'minting', 'Visibility': 'public', 'Purpose': 'Checks if the VADER contract is minting tokens', 'Parameters': [], 'Returns': ['bool']}]}, 'ExternalInteractions': ['VADER', 'VAULT', 'ROUTER'], 'SpecialMechanisms': ['Flash loan attack prevention using block delay', 'Incentive distribution mechanism based on era timestamps'], 'Questions': ['What is the exact purpose of the `_checkIncentives` function and how is it triggered?', 'How does the `convert` function interact with the ROUTER contract to get the USDV amount?', 'What is the role of the `emitting` and `minting` functions from the VADER contract in this context?']}",623.7067129611969,"### **[H-02] Flash attack mitigation does not work as intended in USDV.sol**

**Report Description**:
The `flashProof()` modifier in `USDV.sol` is intended to prevent flash attacks by ensuring that the current block number is at least `blockDelay` ahead of the previous block number (`lastBlock[tx.origin] + blockDelay <= block.number`). However, `blockDelay` is not initialized, defaulting to 0. This allows multiple calls to be executed in the same block, enabling flash attacks instead of preventing them. The DAO, which is supposed to set `blockDelay` via `setParams()`, currently lacks the capability to do so.

**Match in Response List**:
Matches with the issue titled **""Potential Flash Loan Vulnerability in `_convert` Function""**.

**Validation**:
**Partially Correct**. The response identifies the issue with the `flashProof` modifier and the potential for bypassing flash loan protections. However, it does not explicitly mention the uninitialized `blockDelay` state variable, which is the root cause of the vulnerability. The response correctly highlights the risk of flash loan exploitation but misses the critical detail about `blockDelay` being uninitialized.

---

### **[H-16] Tokens can be stolen through `transferTo`**

**Report Description**:
The `transferTo()` function in the VADER, USDV, and SYNTHS contracts skips approvals by interrogating `tx.origin`. This design choice is considered dangerous as it allows tokens to be transferred without proper authorization, potentially enabling token theft.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address the issue of `transferTo()` skipping approvals or the associated risks of token theft. This is a significant oversight, as the vulnerability directly impacts the security of token transfers.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init` function in the contract is callable by anyone, which could lead to unintended behavior if the contract is used before proper initialization. This lack of access control poses a risk of misuse or exploitation.

**Match in Response List**:
Matches with the issue titled **""Uninitialized State Variable `inited`""**.

**Validation**:
**Partially Correct**. The response identifies the issue of the `inited` state variable not being initialized, which is related to the `init` function. However, it does not explicitly mention the lack of access control on the `init` function itself, which is the core issue in the report. The response partially addresses the problem but misses the critical detail about unrestricted access to the `init` function.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-02] Flash attack mitigation does not work as intended in USDV.sol**
- **[M-13] Init function can be called by everyone**

**Missed Issues from Issue Report**:
- **[H-16] Tokens can be stolen through `transferTo`**

---

### **Overall Evaluation**
The response list partially addresses some of the issues in the report but misses critical details in most cases. The most significant gap is the complete omission of the `transferTo` vulnerability, which is a high-severity issue. Additionally, the responses often fail to fully capture the root causes of the vulnerabilities, such as the uninitialized `blockDelay` and the unrestricted `init` function. Improvements are needed to ensure comprehensive coverage of all reported issues and their underlying causes.","```
None.
```",0.0
Vader.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iUSDV.sol"";
import ""./interfaces/iROUTER.sol"";

contract Vader is iERC20 {

    // ERC-20 Parameters
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Parameters
    bool private inited;
    bool public emitting;
    bool public minting;
    uint _1m;
    uint public baseline;
    uint public emissionCurve;
    uint public maxSupply;
    uint public secondsPerEra;
    uint public currentEra;
    uint public nextEraTime;
    uint public feeOnTransfer;

    address public VETHER;
    address public USDV;
    address public UTILS;
    address public burnAddress;
    address public rewardAddress;
    address public DAO;

    event NewEra(uint currentEra, uint nextEraTime, uint emission);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO, ""Not DAO"");
        _;
    }
    // Stop flash attacks
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool){
        return iUSDV(USDV).isMature();
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
        name = 'VADER PROTOCOL TOKEN';
        symbol = 'VADER';
        decimals = 18;
        _1m = 10**6 * 10 ** decimals; //1m
        baseline = _1m;
        totalSupply = 0;
        maxSupply = 2 * _1m;
        currentEra = 1;
        secondsPerEra = 1; //86400;
        nextEraTime = block.timestamp + secondsPerEra;
        emissionCurve = 900;
        DAO = msg.sender;
        burnAddress = 0x0111011001100001011011000111010101100101;
    }
    // Can only be called once
    function init(address _vether, address _USDV, address _utils) external {
        require(inited == false);
        inited = true;
        VETHER = _vether;
        USDV = _USDV;
        UTILS = _utils;
        rewardAddress = _USDV;
    }

    //========================================iERC20=========================================//
    function balanceOf(address account) external view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    // TransferTo function
    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. 
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        require(sender != address(0), ""sender"");
        require(recipient != address(this), ""recipient"");
        _balances[sender] -= amount;
        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  // Critical functionality
        if(_fee >= 0 && _fee <= amount){                            // Stops reverts if UTILS corrupted
            amount -= _fee;
            _burn(msg.sender, _fee);
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        _checkEmission();
    }
    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint amount) internal virtual {
        require(account != address(0), ""recipient"");
        if((totalSupply + amount) >= maxSupply){
            amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply
        }
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    // Burn supply
    function burn(uint amount) public virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender) - amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        require(account != address(0), ""address err"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //=========================================DAO=========================================//
    // Can start
    function flipEmissions() external onlyDAO {
        if(emitting){
            emitting = false;
        } else {
            emitting = true;
        }
    }
    // Can stop
    function flipMinting() external onlyDAO {
        if(minting){
            minting = false;
        } else {
            minting = true;
        }
    }
    // Can set params
    function setParams(uint newEra, uint newCurve) external onlyDAO {
        secondsPerEra = newEra;
        emissionCurve = newCurve;
    }
    // Can set reward address
    function setRewardAddress(address newAddress) external onlyDAO {
        rewardAddress = newAddress;
    }
    // Can change UTILS
    function changeUTILS(address newUTILS) external onlyDAO {
        require(newUTILS != address(0), ""address err"");
        UTILS = newUTILS;
    }
    // Can change DAO
    function changeDAO(address newDAO) external onlyDAO {
        require(newDAO != address(0), ""address err"");
        DAO = newDAO;
    }
    // Can purge DAO
    function purgeDAO() external onlyDAO{
        DAO = address(0);
    }

   //======================================EMISSION========================================//
    // Internal - Update emission function
    function _checkEmission() private {
        if ((block.timestamp >= nextEraTime) && emitting) {                                // If new Era and allowed to emit
            currentEra += 1;                                                               // Increment Era
            nextEraTime = block.timestamp + secondsPerEra;                                 // Set next Era time
            uint _emission = getDailyEmission();                                           // Get Daily Dmission
            _mint(rewardAddress, _emission);                                               // Mint to the Rewad Address
            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        // UpdateFeeOnTransfer
            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                // Max 10% if UTILS corrupted
            emit NewEra(currentEra, nextEraTime, _emission);                               // Emit Event
        }
    }
    // Calculate Daily Emission
    function getDailyEmission() public view returns (uint) {
        uint _adjustedMax;
        if(totalSupply <= baseline){ // If less than 1m, then adjust cap down
            _adjustedMax = (maxSupply * totalSupply) / baseline; // 2m * 0.5m / 1m = 2m * 50% = 1.5m
        } else {
            _adjustedMax = maxSupply;  // 2m
        }
        return (_adjustedMax - totalSupply) / (emissionCurve); // outstanding / curve 
    }

    //======================================ASSET MINTING========================================//
    // VETHER Owners to Upgrade
    function upgrade(uint amount) external {
        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));
        _mint(msg.sender, amount);
    }
    // Directly redeem back to VADER (must have sent USDV first)
    function redeem() external returns (uint redeemAmount){
        return redeemToMember(msg.sender);
    }
    // Redeem on behalf of member (must have sent USDV first)
    function redeemToMember(address member) public flashProof returns (uint redeemAmount){
        if(minting){
            uint _amount = iERC20(USDV).balanceOf(address(this)); 
            iERC20(USDV).burn(_amount);
            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); // Critical pricing functionality
            _mint(member, redeemAmount);
        }
    }
}",2091,245,"[H-03] Missing DAO functionality to call changeDAO() function in Vader.sol
changeDAO() is authorized to be called only from the DAO (per modifier) but DAO contract has no corresponding functionality to call changeDAO() function. As a result, DAO address cannot be changed (L192-L196).
Recommend adding functionality to DAO to be able to call changeDAO() of Vader.sol.
 [H-06] Incorrect burn address in Vader.sol
The internal _transfer() function is called from external facing transfer(), transferFrom(), and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo().
These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.
This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.  [H-16] Tokens can be stolen through transferTo
VADER, USDV, SYNTHS all employ the transferTo() function, which interrogates for tx.origin and skips approvals. The author does not subscribe to the belief that this is dangerous  [H-17] Transfer fee is burned on wrong accounts
The Vader._transfer function burns the transfer fee on msg.sender but this address might not be involved in the transfer at all due to transferFrom.
Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.
 [H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol
Incorrect initialization (perhaps testing parameterization mistakenly carried over to deployment) of secondsPerEra to 1 sec instead of 86400 secs (1 day) causes what should be the daily emission rate to be a secondly emission rate.
This causes inflation of VADER token and likely breaks VADER<>USDV peg and other protocol invariants. Protocol will break and funds will be lost.
Recommend Initializing secondsPerEra to 86400 on L67.
 [M-04] flashProof is not flash-proof
The flashProof modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.
However, it performs this check on tx.origin and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.
 [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()  [M-15] changeDAO should be a two-step process in Vader.sol
changeDAO() updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires msg.sender to be the incorrectly used DAO address (for which private keys may not be available to sign transactions). See finding #6 from Trail of Bits audit of Hermez Network.  [M-17] Vader.redeemToMember() vulnerable to front running
The USDV balance of the Vader contract is vulnerable to theft through the Vader.redeemToMember() function. A particular case is through USDV redemption front-running. Users can redeem USDV for Vader through the USDV.redeemForMember() function or the Vader.redeemToMember() function. In the case of Vader.redeemToMember(), a user would need to send their USDV to the contract before redemption. However, as this process does not happen in a single call, the victim's call is vulnerable to front running and could have their redeemed USDV stolen by an attacker.",9,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iUSDV.sol"";
import ""./interfaces/iROUTER.sol"";

contract Vader is iERC20 {

    
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    
    bool private inited;
    bool public emitting;
    bool public minting;
    uint _1m;
    uint public baseline;
    uint public emissionCurve;
    uint public maxSupply;
    uint public secondsPerEra;
    uint public currentEra;
    uint public nextEraTime;
    uint public feeOnTransfer;

    address public VETHER;
    address public USDV;
    address public UTILS;
    address public burnAddress;
    address public rewardAddress;
    address public DAO;

    event NewEra(uint currentEra, uint nextEraTime, uint emission);

    
    modifier onlyDAO() {
        require(msg.sender == DAO, ""Not DAO"");
        _;
    }
    
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool){
        return iUSDV(USDV).isMature();
    }

    
    
    constructor() {
        name = 'VADER PROTOCOL TOKEN';
        symbol = 'VADER';
        decimals = 18;
        _1m = 10**6 * 10 ** decimals; 
        baseline = _1m;
        totalSupply = 0;
        maxSupply = 2 * _1m;
        currentEra = 1;
        secondsPerEra = 1; 
        nextEraTime = block.timestamp + secondsPerEra;
        emissionCurve = 900;
        DAO = msg.sender;
        burnAddress = 0x0111011001100001011011000111010101100101;
    }
    
    function init(address _vether, address _USDV, address _utils) external {
        require(inited == false);
        inited = true;
        VETHER = _vether;
        USDV = _USDV;
        UTILS = _utils;
        rewardAddress = _USDV;
    }

    
    function balanceOf(address account) external view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    
    
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        require(sender != address(0), ""sender"");
        require(recipient != address(this), ""recipient"");
        _balances[sender] -= amount;
        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  
        if(_fee >= 0 && _fee <= amount){                            
            amount -= _fee;
            _burn(msg.sender, _fee);
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        _checkEmission();
    }
    
    function _mint(address account, uint amount) internal virtual {
        require(account != address(0), ""recipient"");
        if((totalSupply + amount) >= maxSupply){
            amount = maxSupply - totalSupply;       
        }
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    
    function burn(uint amount) public virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender) - amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        require(account != address(0), ""address err"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    
    
    function flipEmissions() external onlyDAO {
        if(emitting){
            emitting = false;
        } else {
            emitting = true;
        }
    }
    
    function flipMinting() external onlyDAO {
        if(minting){
            minting = false;
        } else {
            minting = true;
        }
    }
    
    function setParams(uint newEra, uint newCurve) external onlyDAO {
        secondsPerEra = newEra;
        emissionCurve = newCurve;
    }
    
    function setRewardAddress(address newAddress) external onlyDAO {
        rewardAddress = newAddress;
    }
    
    function changeUTILS(address newUTILS) external onlyDAO {
        require(newUTILS != address(0), ""address err"");
        UTILS = newUTILS;
    }
    
    function changeDAO(address newDAO) external onlyDAO {
        require(newDAO != address(0), ""address err"");
        DAO = newDAO;
    }
    
    function purgeDAO() external onlyDAO{
        DAO = address(0);
    }

   
    
    function _checkEmission() private {
        if ((block.timestamp >= nextEraTime) && emitting) {                                
            currentEra += 1;                                                               
            nextEraTime = block.timestamp + secondsPerEra;                                 
            uint _emission = getDailyEmission();                                           
            _mint(rewardAddress, _emission);                                               
            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        
            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                
            emit NewEra(currentEra, nextEraTime, _emission);                               
        }
    }
    
    function getDailyEmission() public view returns (uint) {
        uint _adjustedMax;
        if(totalSupply <= baseline){ 
            _adjustedMax = (maxSupply * totalSupply) / baseline; 
        } else {
            _adjustedMax = maxSupply;  
        }
        return (_adjustedMax - totalSupply) / (emissionCurve); 
    }

    
    
    function upgrade(uint amount) external {
        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));
        _mint(msg.sender, amount);
    }
    
    function redeem() external returns (uint redeemAmount){
        return redeemToMember(msg.sender);
    }
    
    function redeemToMember(address member) public flashProof returns (uint redeemAmount){
        if(minting){
            uint _amount = iERC20(USDV).balanceOf(address(this)); 
            iERC20(USDV).burn(_amount);
            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); 
            _mint(member, redeemAmount);
        }
    }
}",1699,5,4,"{'Findings': [{'Issue': 'Reentrancy Vulnerability in `_transfer` Function', 'Severity': 'High', 'Description': 'The `_transfer` function does not follow the checks-effects-interactions pattern, which could lead to reentrancy attacks. Specifically, the function calls an external contract (iUTILS) before updating the state, which could be exploited if the UTILS contract is malicious or compromised.', 'Impact': 'An attacker could potentially re-enter the `_transfer` function multiple times before the state is updated, leading to loss of funds or other unintended behavior.', 'Location': 'Function `_transfer`'}, {'Issue': 'DAO Privilege Escalation', 'Severity': 'High', 'Description': ""The `changeDAO` and `purgeDAO` functions allow the current DAO to change or remove the DAO address without any additional checks or delays. This could lead to privilege escalation if the DAO's private key is compromised."", 'Impact': ""A compromised DAO could lead to unauthorized changes in the contract's governance, potentially resulting in loss of control over the contract."", 'Location': 'Functions `changeDAO` and `purgeDAO`'}, {'Issue': 'Lack of Input Validation in `init` Function', 'Severity': 'High', 'Description': 'The `init` function does not validate the input addresses (`_vether`, `_USDV`, `_utils`). If these addresses are set to malicious contracts, it could lead to unexpected behavior or vulnerabilities.', 'Impact': 'Malicious contracts could be set, leading to potential exploits or loss of funds.', 'Location': 'Function `init`'}, {'Issue': 'Unrestricted Minting in `_mint` Function', 'Severity': 'High', 'Description': 'The `_mint` function does not have any access control, allowing any contract or user to call it directly. This could lead to unauthorized minting of tokens if the function is exposed or called inappropriately.', 'Impact': 'Unauthorized minting could lead to inflation of the token supply and devaluation of the token.', 'Location': 'Function `_mint`'}, {'Issue': 'Unrestricted `changeUTILS` Function', 'Severity': 'High', 'Description': 'The `changeUTILS` function allows the DAO to change the `UTILS` contract address without any validation or timelock. If the DAO is compromised, an attacker could replace the `UTILS` contract with a malicious one, leading to potential exploits.', 'Impact': 'A compromised DAO could introduce malicious logic into the contract, leading to loss of funds or other vulnerabilities.', 'Location': 'Function `changeUTILS`'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': ""The contract uses arithmetic operations in several places (e.g., `_transfer`, `_mint`, `_burn`) without checking for potential overflow/underflow. Although Solidity 0.8.x has built-in overflow checks, it's still good practice to explicitly handle such cases."", 'Impact': 'If an overflow or underflow occurs, it could lead to unexpected behavior, such as incorrect token balances or other state inconsistencies.', 'Location': 'Functions `_transfer`, `_mint`, `_burn`'}, {'Issue': 'Unrestricted Access to `flipEmissions` and `flipMinting` Functions', 'Severity': 'Medium', 'Description': ""The `flipEmissions` and `flipMinting` functions are only restricted by the `onlyDAO` modifier. If the DAO account is compromised, an attacker could toggle these states, potentially disrupting the token's emission or minting mechanisms."", 'Impact': ""Compromised DAO account could lead to unauthorized changes in the contract's emission or minting behavior, affecting the token's economy."", 'Location': 'Functions `flipEmissions` and `flipMinting`'}, {'Issue': 'Potential Front-Running in `upgrade` Function', 'Severity': 'Medium', 'Description': 'The `upgrade` function allows users to upgrade their tokens by burning VETHER tokens. This could be susceptible to front-running attacks where an attacker could observe the transaction and submit a higher gas price to execute their transaction first.', 'Impact': 'Potential loss of funds or unfair advantage to attackers.', 'Location': 'Function `upgrade`'}, {'Issue': 'Inconsistent Fee Handling in `_transfer` Function', 'Severity': 'Medium', 'Description': ""The `_transfer` function calculates a fee using `iUTILS(UTILS).calcPart` but does not ensure that the fee is properly deducted from the sender's balance before transferring the remaining amount. This could lead to inconsistencies in the fee handling process."", 'Impact': 'Incorrect fee handling could lead to loss of funds or incorrect token balances.', 'Location': 'Function `_transfer`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': ""Several critical functions such as `flipEmissions`, `flipMinting`, and `setParams` do not emit events when their state is changed. This makes it difficult to track changes in the contract's state and could lead to a lack of transparency."", 'Impact': ""Lack of transparency could lead to mistrust among users and make it difficult to audit the contract's behavior."", 'Location': 'Functions `flipEmissions`, `flipMinting`, `setParams`'}, {'Issue': 'Hardcoded Burn Address', 'Severity': 'Low', 'Description': 'The burn address is hardcoded as `0x0111011001100001011011000111010101100101`. While this is not a security issue per se, it is a best practice to use the well-known `address(0)` for burn addresses to avoid confusion and ensure compatibility with other contracts and tools.', 'Impact': 'Hardcoding a specific address for burning tokens could lead to confusion or incompatibility with other systems that expect the burn address to be `address(0)`.', 'Location': 'Constructor'}], 'IssueNumber': 70, 'OutputList': 11}",,"{'ReviewingTheCode': ""The provided Solidity smart contract is named 'Vader' and implements the iERC20 interface. It appears to be a token contract with additional functionalities such as emission control, minting, burning, and redemption mechanisms. The contract is designed to manage token supply, handle transfers, and interact with external contracts for utilities and governance."", 'IdentifyingKeyComponents': {'ContractName': 'Vader', 'Purpose': 'To manage the VADER token, including its supply, transfers, emissions, and interactions with other contracts in the VADER protocol ecosystem.', 'InheritanceAndImports': {'InheritsFrom': ['iERC20'], 'Imports': ['./interfaces/iERC20.sol', './interfaces/iUTILS.sol', './interfaces/iUSDV.sol', './interfaces/iROUTER.sol']}, 'StateVariables': [{'Name': 'name', 'Type': 'string', 'Purpose': 'Name of the token'}, {'Name': 'symbol', 'Type': 'string', 'Purpose': 'Symbol of the token'}, {'Name': 'decimals', 'Type': 'uint', 'Purpose': 'Number of decimal places for the token'}, {'Name': 'totalSupply', 'Type': 'uint', 'Purpose': 'Total supply of the token'}, {'Name': '_balances', 'Type': 'mapping(address => uint)', 'Purpose': 'Mapping of account balances'}, {'Name': '_allowances', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping of allowances for spender accounts'}, {'Name': 'inited', 'Type': 'bool', 'Purpose': 'Flag to check if the contract has been initialized'}, {'Name': 'emitting', 'Type': 'bool', 'Purpose': 'Flag to control token emissions'}, {'Name': 'minting', 'Type': 'bool', 'Purpose': 'Flag to control token minting'}, {'Name': '_1m', 'Type': 'uint', 'Purpose': 'Constant representing 1 million tokens'}, {'Name': 'baseline', 'Type': 'uint', 'Purpose': 'Baseline supply for emission calculations'}, {'Name': 'emissionCurve', 'Type': 'uint', 'Purpose': 'Curve parameter for emission calculations'}, {'Name': 'maxSupply', 'Type': 'uint', 'Purpose': 'Maximum supply of the token'}, {'Name': 'secondsPerEra', 'Type': 'uint', 'Purpose': 'Duration of each emission era in seconds'}, {'Name': 'currentEra', 'Type': 'uint', 'Purpose': 'Current emission era'}, {'Name': 'nextEraTime', 'Type': 'uint', 'Purpose': 'Timestamp for the next era'}, {'Name': 'feeOnTransfer', 'Type': 'uint', 'Purpose': 'Fee applied on token transfers'}, {'Name': 'VETHER', 'Type': 'address', 'Purpose': 'Address of the VETHER token contract'}, {'Name': 'USDV', 'Type': 'address', 'Purpose': 'Address of the USDV token contract'}, {'Name': 'UTILS', 'Type': 'address', 'Purpose': 'Address of the UTILS contract'}, {'Name': 'burnAddress', 'Type': 'address', 'Purpose': 'Address for burning tokens'}, {'Name': 'rewardAddress', 'Type': 'address', 'Purpose': 'Address for receiving emission rewards'}, {'Name': 'DAO', 'Type': 'address', 'Purpose': 'Address of the DAO (Decentralized Autonomous Organization)'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with default values', 'Parameters': [], 'Returns': []}, {'Name': 'init', 'Visibility': 'external', 'Purpose': 'Initializes the contract with external addresses', 'Parameters': ['address _vether', 'address _USDV', 'address _utils'], 'Returns': []}, {'Name': 'balanceOf', 'Visibility': 'external', 'Purpose': 'Returns the balance of a specified account', 'Parameters': ['address account'], 'Returns': ['uint']}, {'Name': 'allowance', 'Visibility': 'public', 'Purpose': 'Returns the remaining number of tokens that spender is allowed to spend on behalf of owner', 'Parameters': ['address owner', 'address spender'], 'Returns': ['uint']}, {'Name': 'transfer', 'Visibility': 'external', 'Purpose': 'Transfers tokens from the caller to a recipient', 'Parameters': ['address recipient', 'uint amount'], 'Returns': ['bool']}, {'Name': 'approve', 'Visibility': 'external', 'Purpose': 'Allows a spender to spend up to a certain amount of tokens on behalf of the caller', 'Parameters': ['address spender', 'uint amount'], 'Returns': ['bool']}, {'Name': '_approve', 'Visibility': 'internal', 'Purpose': 'Internal function to handle approvals', 'Parameters': ['address owner', 'address spender', 'uint amount'], 'Returns': []}, {'Name': 'transferFrom', 'Visibility': 'external', 'Purpose': 'Transfers tokens from a sender to a recipient using an allowance', 'Parameters': ['address sender', 'address recipient', 'uint amount'], 'Returns': ['bool']}, {'Name': 'transferTo', 'Visibility': 'external', 'Purpose': 'Transfers tokens from the transaction origin to a recipient', 'Parameters': ['address recipient', 'uint amount'], 'Returns': ['bool']}, {'Name': '_transfer', 'Visibility': 'internal', 'Purpose': 'Internal function to handle token transfers', 'Parameters': ['address sender', 'address recipient', 'uint amount'], 'Returns': []}, {'Name': '_mint', 'Visibility': 'internal', 'Purpose': 'Internal function to mint new tokens', 'Parameters': ['address account', 'uint amount'], 'Returns': []}, {'Name': 'burn', 'Visibility': 'public', 'Purpose': ""Burns tokens from the caller's account"", 'Parameters': ['uint amount'], 'Returns': []}, {'Name': 'burnFrom', 'Visibility': 'external', 'Purpose': 'Burns tokens from a specified account using an allowance', 'Parameters': ['address account', 'uint amount'], 'Returns': []}, {'Name': '_burn', 'Visibility': 'internal', 'Purpose': 'Internal function to handle token burning', 'Parameters': ['address account', 'uint amount'], 'Returns': []}, {'Name': 'flipEmissions', 'Visibility': 'external', 'Purpose': 'Toggles the emission flag', 'Parameters': [], 'Returns': []}, {'Name': 'flipMinting', 'Visibility': 'external', 'Purpose': 'Toggles the minting flag', 'Parameters': [], 'Returns': []}, {'Name': 'setParams', 'Visibility': 'external', 'Purpose': 'Sets the era duration and emission curve parameters', 'Parameters': ['uint newEra', 'uint newCurve'], 'Returns': []}, {'Name': 'setRewardAddress', 'Visibility': 'external', 'Purpose': 'Sets the address for receiving emission rewards', 'Parameters': ['address newAddress'], 'Returns': []}, {'Name': 'changeUTILS', 'Visibility': 'external', 'Purpose': 'Changes the address of the UTILS contract', 'Parameters': ['address newUTILS'], 'Returns': []}, {'Name': 'changeDAO', 'Visibility': 'external', 'Purpose': 'Changes the address of the DAO', 'Parameters': ['address newDAO'], 'Returns': []}, {'Name': 'purgeDAO', 'Visibility': 'external', 'Purpose': 'Removes the DAO address', 'Parameters': [], 'Returns': []}, {'Name': '_checkEmission', 'Visibility': 'private', 'Purpose': 'Checks and handles token emissions based on the current era', 'Parameters': [], 'Returns': []}, {'Name': 'getDailyEmission', 'Visibility': 'public', 'Purpose': 'Calculates the daily emission of tokens', 'Parameters': [], 'Returns': ['uint']}, {'Name': 'upgrade', 'Visibility': 'external', 'Purpose': 'Upgrades VETHER tokens to VADER tokens', 'Parameters': ['uint amount'], 'Returns': []}, {'Name': 'redeem', 'Visibility': 'external', 'Purpose': 'Redeems USDV tokens for VADER tokens', 'Parameters': [], 'Returns': ['uint redeemAmount']}, {'Name': 'redeemToMember', 'Visibility': 'public', 'Purpose': 'Redeems USDV tokens for VADER tokens and sends them to a specified member', 'Parameters': ['address member'], 'Returns': ['uint redeemAmount']}, {'Name': 'onlyDAO', 'Visibility': 'modifier', 'Purpose': 'Restricts access to the DAO', 'Parameters': [], 'Returns': []}, {'Name': 'flashProof', 'Visibility': 'modifier', 'Purpose': 'Ensures the contract is mature before allowing certain actions', 'Parameters': [], 'Returns': []}, {'Name': 'isMature', 'Visibility': 'public', 'Purpose': 'Checks if the contract is mature', 'Parameters': [], 'Returns': ['bool']}]}, 'ExternalInteractions': ['iERC20(VETHER).transferFrom', 'iUSDV(USDV).isMature', 'iUTILS(UTILS).calcPart', 'iUTILS(UTILS).getFeeOnTransfer', 'iERC20(USDV).balanceOf', 'iERC20(USDV).burn', 'iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount'], 'SpecialMechanisms': ['Emission control mechanism to manage token supply over time', 'Minting and burning mechanisms to adjust token supply', 'Redemption mechanism to convert USDV tokens to VADER tokens', 'DAO governance to control critical functions'], 'Questions': [""What is the exact purpose of the 'baseline' variable in emission calculations?"", ""How is the 'emissionCurve' parameter determined and what impact does it have on emissions?"", ""What is the significance of the 'feeOnTransfer' variable and how is it calculated?"", ""How does the 'flashProof' modifier ensure contract maturity and what are the implications of this check?"", 'What are the specific roles of the VETHER, USDV, and UTILS contracts in the VADER ecosystem?']}",682.9921958446503,"### **[H-03] Missing DAO functionality to call `changeDAO()` function in Vader.sol**

**Report Description**:  
The `changeDAO()` function in `Vader.sol` is authorized to be called only from the DAO (via the `onlyDAO` modifier). However, the DAO contract lacks the corresponding functionality to call `changeDAO()`. As a result, the DAO address cannot be changed, rendering the function unusable. This oversight prevents the DAO from updating its address, which could be critical for governance or recovery purposes.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing DAO functionality to call `changeDAO()`. This is a critical oversight in the governance mechanism, and the response list fails to identify or propose a solution for it.

---

### **[H-06] Incorrect burn address in Vader.sol**

**Report Description**:  
The `_transfer()` function in `Vader.sol` is called from external functions (`transfer()`, `transferFrom()`, and `transferTo()`), each with different sender addresses. While the sender parameter is correctly used for token transfers, the call to `_burn()` on line 129 incorrectly uses `msg.sender` as the burn address. This is only correct for the `transfer()` caller's context but incorrect for `transferFrom()` and `transferTo()`. This leads to incorrect fee burning from intermediate contract accounts, causing accounting discrepancies and potential fund loss.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect burn address usage in the `_transfer()` function. This is a critical vulnerability that could lead to fund loss, and the response list fails to identify or propose a solution for it.

---

### **[H-16] Tokens can be stolen through `transferTo`**

**Report Description**:  
The `transferTo()` function in `Vader.sol`, `USDV.sol`, and `SYNTHS.sol` uses `tx.origin` and skips approvals. This design is inherently dangerous as it allows tokens to be stolen if an attacker manipulates `tx.origin`. The author dismisses this risk, but it remains a significant vulnerability.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of token theft through `transferTo()`. This is a critical vulnerability, and the response list fails to identify or propose a solution for it.

---

### **[H-17] Transfer fee is burned on wrong accounts**

**Report Description**:  
The `_transfer()` function in `Vader.sol` burns the transfer fee on `msg.sender`, which might not be involved in the transfer at all (e.g., in the case of `transferFrom()`). This leads to incorrect fee burning from intermediate contract accounts, breaking functionality for smart contracts like aggregators and causing fund loss.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect fee burning in the `_transfer()` function. This is a critical vulnerability that could lead to fund loss, and the response list fails to identify or propose a solution for it.

---

### **[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol**

**Report Description**:  
The `secondsPerEra` parameter in `Vader.sol` is incorrectly initialized to 1 second instead of 86400 seconds (1 day). This causes the daily emission rate to become a secondly emission rate, leading to VADER token inflation, breaking the VADER<>USDV peg, and causing fund loss.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect initialization of `secondsPerEra`. This is a critical vulnerability that could lead to fund loss, and the response list fails to identify or propose a solution for it.

---

### **[M-04] `flashProof` is not flash-proof**

**Report Description**:  
The `flashProof` modifier is intended to prevent flash-loan attacks by disallowing sensitive functions from being called in the same block. However, it checks `tx.origin` instead of individual user addresses, which only prevents flash-loan attacks within a single transaction. This design flaw leaves the contract vulnerable to flash-loan attacks across multiple transactions.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of the `flashProof` modifier's ineffectiveness against flash-loan attacks. This is a significant vulnerability, and the response list fails to identify or propose a solution for it.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:  
The `init()` function in several contracts can be called by anyone, allowing unauthorized initialization of critical contract parameters. This could lead to unexpected behavior or vulnerabilities if malicious actors exploit this oversight.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation in `init` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unrestricted access to the `init()` function but focuses on input validation rather than the broader problem of unauthorized initialization. While related, the response misses the critical detail that the function can be called by anyone, not just the DAO or authorized parties.

---

### **[M-15] `changeDAO` should be a two-step process in Vader.sol**

**Report Description**:  
The `changeDAO()` function updates the DAO address in a single step. If an incorrect address is mistakenly used (and voted upon), recovering from this mistake is impossible because the `onlyDAO` modifier requires the incorrect DAO address to sign future transactions. This design flaw could permanently lock the DAO out of governance.

**Match in Response List**:  
Matches with the issue titled **""DAO Privilege Escalation""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of privilege escalation in the `changeDAO()` function but does not address the need for a two-step process to prevent irreversible mistakes. While related, the response misses the critical detail of implementing a recovery mechanism.

---

### **[M-17] `Vader.redeemToMember()` vulnerable to front running**

**Report Description**:  
The `Vader.redeemToMember()` function is vulnerable to front-running attacks. Users must send their USDV to the contract before redemption, but this process does not happen in a single call. An attacker can front-run the victim's transaction, stealing their redeemed USDV.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of front-running vulnerability in the `Vader.redeemToMember()` function. This is a significant vulnerability, and the response list fails to identify or propose a solution for it.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-13] Init function can be called by everyone**  
- **[M-15] `changeDAO` should be a two-step process in Vader.sol**

**Missed Issues from Issue Report**:  
- **[H-03] Missing DAO functionality to call `changeDAO()` function in Vader.sol**  
- **[H-06] Incorrect burn address in Vader.sol**  
- **[H-16] Tokens can be stolen through `transferTo`**  
- **[H-17] Transfer fee is burned on wrong accounts**  
- **[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol**  
- **[M-04] `flashProof` is not flash-proof**  
- **[M-17] `Vader.redeemToMember()` vulnerable to front running**  

--- 

The response list fails to address the majority of the critical and medium-severity issues in the issue report, leaving significant vulnerabilities unaddressed.","```
None.
```",0.0
DAO.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)
    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised
    uint256 public proposalCount;   // Count of proposals
    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3
    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives
    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially
    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially
    uint256 public currentProposal; // The most recent proposal; should be === proposalCount
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets
    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    //==================================== PROTOCOL CONTRACTs SETTER =================================//

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    // Can purge deployer once DAO is stable and final
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    // Can change vesting period for bonders
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    //============================== USER - DEPOSIT/WITHDRAW ================================//

    // User deposits LP tokens in the DAOVault
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    // Contract deposits LP tokens for member
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); // Pool must be Curated
        require(amount > 0, ""!amount""); // Deposit amount must be valid
        if (isMember[member] != true) {
            arrayMembers.push(member); // If not a member; add user to member array
            isMember[member] = true; // If not a member; register the user as member
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); // Send user's deposit to the DAOVault
        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight
        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time
        emit MemberDeposits(member, pool, amount);
    }
    
    // User withdraws all of their selected asset from the DAOVault
    function withdraw(address pool) external {
        removeVote(); // Users weight is removed from the current open DAO proposal
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); // User receives their withdrawal
    }

    //============================== REWARDS ================================//
    
    // User claims their DAOVault incentives
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); // Reserve must have emissions turned on
        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE
        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)
        if(reward > daoReward){
            reward = daoReward; // User cannot claim more than the daoReward limit
        }
        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user
    }

    // Calculate the user's current incentive-claim per era
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim
        uint share = calcReward(member); // Get share of rewards for user
        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed
        return reward;
    }

    // Calculate the user's current total claimable incentive
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days
        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that
        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)
    }

    //================================ BOND Feature ==================================//

    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    // List an asset to be enabled for Bonding
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; // Register as a currently enabled asset
            listedBondAssets.push(asset); // Add to historical record of past Bond assets
        }
        emit ListedAsset(msg.sender, asset);
    }

    // Delist an asset from the Bond program
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; // Unregister as a currently enabled asset
        emit DelistedAsset(msg.sender, asset);
    }

    // User deposits assets to be Bonded
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); // Amount must be valid
        require(isListed[asset], '!listed'); // Asset must be listed for Bond
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array
            isMember[msg.sender] = true; // Register user as a member
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    // Add Bonded assets as liquidity and calculate LP units
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens
        } 
    }

    // User claims all of their unlocked Bonded LPs
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; // Get array of bond assets
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked
            }
        }
        return true;
    }

    // User claims unlocked Bond units of a selected asset
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked
        }
        return true;
    }
    
    // Calculate user's unlocked Bond units of a selected asset
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs
        return claimAmount;
    }

    //============================== CREATE PROPOSALS ================================//

    // New ID, but specify type, one type for each function call
    // Votes counted to IDs
    // IDs are finalised
    // IDs are executed, but type specifies unique logic

    // New DAO proposal: Simple action
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: uint parameter
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_param[currentProposal] = param; // Set the proposed parameter
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Address parameter
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Grant SPARTA to wallet
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient
        mapPID_param[currentProposal] = amount; // Set the proposed grant amount
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // If no existing open DAO proposal; register a new one
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal
        proposalCount += 1; // Increase proposal count
        currentProposal = proposalCount; // Set current proposal to the new count
        mapPID_open[currentProposal] = true; // Set new proposal as open status
        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now
    }
    
    // Pay the fee for a new DAO proposal
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee
        return true;
    } 

    //============================== VOTE && FINALISE ================================//

    // Vote for a proposal
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); // Proposal must be open status
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeight = countVotes(); // Vote for proposal and recount
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase
                }
            } else {
                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    // Remove vote from a proposal
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    // Push the proposal into 'finalising' status
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        mapPID_finalising[currentProposal] = true; // Set finalising status to true
        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    // Attempt to cancel the open proposal
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); // Proposal must not be new
        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal
        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)
        emit CancelProposal(msg.sender, currentProposal);
    }

    // A finalising-stage proposal can be finalised after the cool off period
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); // Must be past cooloff period
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); // Must be in finalising stage
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    // Change the DAO to a new contract address
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        DAO = _proposedAddress; // Change the DAO to point to the new DAO address
        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address
        daoHasMoved = true; // Set status of this old DAO
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the ROUTER to a new contract address
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the UTILS to a new contract address
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the RESERVE to a new contract address
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Flip the BASE emissions on/off
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change cool off period (Period of time until a finalising proposal can be finalised)
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        coolOffPeriod = _proposedParam; // Change coolOffPeriod
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change erasToEarn (Used to regulate the incentives flow)
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        erasToEarn = _proposedParam; // Change erasToEarn
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Grant SPARTA to the proposed recipient
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient
        require(_proposedAmount != 0, ""!param""); // Proposed grant amount must be valid
        require(_proposedAddress != address(0), ""!address""); // Proposed recipient must be valid
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Mint a 2.5M SPARTA allocation for the Bond program
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold
        completeProposal(_proposalID); // Finalise the proposal
    }

    // List an asset to be enabled for Bonding
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; // Register asset as listed for Bond
            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets
        }
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Delist an asset from being allowed to Bond
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Add a pool as 'Curated' to enable synths, weight and incentives
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Remove a pool from Curated status
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal
        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }
    
    // After completing the proposal's action; close it
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0
        mapPID_finalised[_proposalID] = true; // Finalise the proposal
        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage
        mapPID_open[_proposalID] = false; // Close the proposal
    }

    //============================== CONSENSUS ================================//
    
    // Add user's total weight to proposal and recount
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights
        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)
        return voteWeight;
    }

    // Check if a proposal has Majority consensus
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Quorum consensus
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 2; // Quorum > 50%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Minority consensus
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 6; // Minority > 16.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    //======================================PROTOCOL CONTRACTs GETTER=================================//
    
    // Get the ROUTER address that the DAO currently points to
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    // Get the UTILS address that the DAO currently points to
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    // Get the BONDVAULT address that the DAO currently points to
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    // Get the DAOVAULT address that the DAO currently points to
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    // Get the POOLFACTORY address that the DAO currently points to
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    // Get the SYNTHFACTORY address that the DAO currently points to
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    // Get the RESERVE address that the DAO currently points to
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    // Get the SYNTHVAULT address that the DAO currently points to
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    //============================== HELPERS ================================//
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }
   ",8037,720,"[H-04] Proposals can be cancelled
Anyone can cancel any proposals by calling DAO.cancelProposal(id, id) with oldProposalID == newProposalID. This always passes the minority check as the proposal was approved.
An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.
Recommend checking that oldProposalID == newProposalID  [H-05] Flash loans can affect governance voting in DAO.sol Flash loans can significantly increase a single voter's weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which, they also deterministically influence the voting outcome to their choice.
This has already happened in the case of MakerDAO governance where a flash loan was used to affect voting outcome and noted by the Maker team as: “a practical example for the community that flash loans can and may impact system governance”
Given that flash loans are a noted concern, the impact of it to DAO governance which can control all critical protocol parameters should be mitigated as in other places.
Recommend accounting for flash loans in countMemberVotes() by using weight from previous blocks or consider capping the weight of individual voters. (L158-L163)
 [M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol
Given that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if 'DAO' type checked in voteProposal() is a typographical error and should really be 'GRANT'. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%).
Recommend changing ‘DAO’ on L83 to ‘GRANT’ or if not, specify what DAO proposals are and how GRANT proposals should be handled with quorum or majority.
 [M-06] Canceled proposals can still be executed
Proposals that passed the threshold (""finalized"") can be cancelled by a minority again using the cancelProposal functions. It only sets mapPID_votes to zero but mapPID_timeStart and mapPID_finalising stay the same and pass the checks in finaliseProposal which queues them for execution.
Proposals cannot be cancelled.
Recommend setting a cancel flag and check for it in finaliseProposal and in execution.
 [M-07] Completed proposals can be voted on and executed again
A proposal that is completed has its state reset, including the votes. Users can just vote on it again and it can be executed again.
Completed proposals should most likely not be allowed to be voted on / executed again. This could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the FinalisedProposal event has fired.
Recommend adding an executed flag to the proposals and disallow voting/finalising on already executed proposals.
 [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()",6,"pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   
    uint256 public coolOffPeriod;   
    uint256 public proposalCount;   
    uint256 public majorityFactor;  
    uint256 public erasToEarn;      
    uint256 public daoClaim;        
    uint256 public daoFee;          
    uint256 public currentProposal; 
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; 
    uint256 public bondingPeriodSeconds = 15552000; 
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; 
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    

    
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); 
        require(amount > 0, ""!amount""); 
        if (isMember[member] != true) {
            arrayMembers.push(member); 
            isMember[member] = true; 
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); 
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); 
        _DAOVAULT.depositLP(pool, amount, member); 
        mapMember_lastTime[member] = block.timestamp; 
        emit MemberDeposits(member, pool, amount);
    }
    
    
    function withdraw(address pool) external {
        removeVote(); 
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); 
    }

    
    
    
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); 
        uint reward = calcCurrentReward(msg.sender); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); 
        uint daoReward = (reserve * daoClaim) / 10000; 
        if(reward > daoReward){
            reward = daoReward; 
        }
        _RESERVE.grantFunds(reward, msg.sender); 
    }

    
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; 
        uint share = calcReward(member); 
        uint reward = (share * secondsSinceClaim) / secondsPerEra; 
        return reward;
    }

    
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; 
        uint daoReward = (reserve * daoClaim) / 10000; 
        return _UTILS.calcShare(weight, _totalWeight, daoReward); 
    }

    

    
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; 
            listedBondAssets.push(asset); 
        }
        emit ListedAsset(msg.sender, asset);
    }

    
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; 
        emit DelistedAsset(msg.sender, asset);
    }

    
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); 
        require(isListed[asset], '!listed'); 
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); 
            isMember[msg.sender] = true; 
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); 
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); 
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); 
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); 
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); 
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); 
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } 
    }

    
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; 
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); 
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); 
            }
        }
        return true;
    }

    
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); 
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); 
        }
        return true;
    }
    
    
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); 
        return claimAmount;
    }

    

    
    
    
    

    
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_param[currentProposal] = param; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_address[currentProposal] = proposedAddress; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); 
        payFee(); 
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; 
        mapPID_address[currentProposal] = recipient; 
        mapPID_param[currentProposal] = amount; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); 
        proposalCount += 1; 
        currentProposal = proposalCount; 
        mapPID_open[currentProposal] = true; 
        mapPID_startTime[currentProposal] = block.timestamp; 
    }
    
    
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); 
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); 
        return true;
    } 

    

    
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); 
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeight = countVotes(); 
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); 
                }
            } else {
                _finalise(); 
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; 
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; 
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; 
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        mapPID_finalising[currentProposal] = true; 
        mapPID_coolOffTime[currentProposal] = block.timestamp; 
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); 
        mapPID_votes[currentProposal] = 0; 
        mapPID_open[currentProposal] = false; 
        emit CancelProposal(msg.sender, currentProposal);
    }

    
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); 
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); 
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; 
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); 
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        DAO = _proposedAddress; 
        iBASE(BASE).changeDAO(_proposedAddress); 
        daoHasMoved = true; 
        completeProposal(_proposalID); 
    }

    
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _ROUTER = iROUTER(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _UTILS = iUTILS(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE = iRESERVE(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); 
        completeProposal(_proposalID); 
    }

    
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        coolOffPeriod = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        erasToEarn = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; 
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAmount != 0, ""!param""); 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; 
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); 
        completeProposal(_proposalID); 
    }

    
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; 
            listedBondAssets.push(_proposedAddress); 
        }
        completeProposal(_proposalID); 
    }

    
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        isListed[_proposedAddress] = false; 
        completeProposal(_proposalID); 
    }

    
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.addCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.removeCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }
    
    
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; 
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; 
        mapPID_finalised[_proposalID] = true; 
        mapPID_finalising[_proposalID] = false; 
        mapPID_open[_proposalID] = false; 
    }

    
    
    
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; 
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); 
        mapPID_votes[currentProposal] += voteWeight; 
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; 
        return voteWeight;
    }

    
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight * majorityFactor / 10000; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 2; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 6; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }",5820,2,4,"{'Findings': [{'Issue': 'Unrestricted Access to Critical Functions', 'Severity': 'High', 'Description': 'The `onlyDAO` modifier is used to restrict access to critical functions such as `setGenesisAddresses`, `setVaultAddresses`, `setFactoryAddresses`, and `purgeDeployer`. However, the `onlyDAO` modifier only checks if the caller is the `DEPLOYER`. If the `DEPLOYER` is compromised or purged, unauthorized users could gain access to these functions.', 'Impact': 'An attacker could change critical contract addresses, leading to potential loss of funds or control over the contract.', 'Location': 'Functions: `setGenesisAddresses`, `setVaultAddresses`, `setFactoryAddresses`, `purgeDeployer`, and others using the `onlyDAO` modifier.'}, {'Issue': 'Reentrancy Risk in `depositLPForMember`', 'Severity': 'High', 'Description': 'The `depositLPForMember` function performs external calls before updating the state, which could lead to reentrancy attacks if the external contract is malicious or compromised.', 'Impact': ""An attacker could exploit this to manipulate the contract's state, potentially leading to loss of funds or other unintended behavior."", 'Location': 'Function: `depositLPForMember`'}, {'Issue': 'Reentrancy Vulnerability in `withdraw` Function', 'Severity': 'High', 'Description': 'The `withdraw` function does not follow the checks-effects-interactions pattern, which could lead to reentrancy attacks. The function calls `_DAOVAULT.withdraw` before updating the state.', 'Impact': ""An attacker could exploit this vulnerability to drain funds or manipulate the contract's state."", 'Location': 'Function: `withdraw`'}, {'Issue': 'Uninitialized Storage Pointers', 'Severity': 'High', 'Description': 'The contract uses several storage pointers (e.g., `_ROUTER`, `_UTILS`, `_BONDVAULT`) that are not initialized in the constructor. If these pointers are accessed before being set, it could lead to unexpected behavior or vulnerabilities.', 'Impact': 'Unexpected behavior or vulnerabilities due to uninitialized storage pointers.', 'Location': 'Variables: `_ROUTER`, `_UTILS`, `_BONDVAULT`, `_DAOVAULT`, `_POOLFACTORY`, `_SYNTHFACTORY`, `_RESERVE`, `_SYNTHVAULT`'}, {'Issue': 'Lack of Input Validation in `setGenesisAddresses` and Similar Functions', 'Severity': 'Medium', 'Description': 'Functions like `setGenesisAddresses`, `setVaultAddresses`, and `setFactoryAddresses` do not validate the input addresses. Passing a zero address or an invalid contract address could lead to runtime errors or unexpected behavior.', 'Impact': 'Potential runtime errors or unexpected behavior when interacting with invalid or zero addresses, leading to contract malfunction.', 'Location': 'Functions: `setGenesisAddresses`, `setVaultAddresses`, `setFactoryAddresses`'}, {'Issue': 'Lack of Input Validation in `newParamProposal` and Similar Functions', 'Severity': 'Medium', 'Description': 'Functions like `newParamProposal`, `newAddressProposal`, and `newGrantProposal` do not validate the input parameters. This could lead to proposals with invalid or malicious parameters being created.', 'Impact': 'Invalid or malicious proposals could be created, leading to potential security risks or loss of funds.', 'Location': 'Functions: `newParamProposal`, `newAddressProposal`, `newGrantProposal`'}, {'Issue': 'Potential Front-Running in `newActionProposal`', 'Severity': 'Medium', 'Description': 'The `newActionProposal` function allows users to create new proposals without any mechanism to prevent front-running. An attacker could monitor the mempool and front-run a legitimate proposal to manipulate the outcome.', 'Impact': 'Front-running could lead to governance manipulation, affecting the outcome of proposals.', 'Location': 'Function: `newActionProposal`'}, {'Issue': 'Insufficient Quorum and Majority Checks', 'Severity': 'Medium', 'Description': 'The `hasQuorum` and `hasMajority` functions check if a proposal has enough votes to pass. However, these checks are based on the total weight of all members, which could be manipulated if a large number of members are added or removed before a vote.', 'Impact': 'Manipulation of the quorum or majority thresholds could lead to unfair governance outcomes.', 'Location': 'Functions: `hasQuorum`, `hasMajority`'}, {'Issue': 'Unbounded Loops in `claimAllForMember`', 'Severity': 'Medium', 'Description': 'The `claimAllForMember` function iterates over all listed bond assets to claim rewards for a member. If the number of listed assets is large, this function could exceed the gas limit, making it impossible to claim all rewards in a single transaction.', 'Impact': 'Users may be unable to claim all their rewards in a single transaction, leading to inconvenience or loss of rewards.', 'Location': 'Function: `claimAllForMember`'}, {'Issue': 'Potential Integer Overflow in `calcCurrentReward`', 'Severity': 'Low', 'Description': 'The `calcCurrentReward` function calculates the reward based on the difference between the current block timestamp and the last claim time. If the `secondsSinceClaim` is extremely large, it could lead to an integer overflow when multiplied by `share`.', 'Impact': 'Integer overflow could lead to incorrect reward calculations, potentially affecting the distribution of rewards.', 'Location': 'Function: `calcCurrentReward`'}, {'Issue': 'Lack of Event Emission in Critical State Changes', 'Severity': 'Low', 'Description': 'Several critical state changes, such as changing the `bondingPeriodSeconds` or updating the `listedBondAssets`, do not emit events. This makes it difficult to track these changes off-chain and could lead to transparency issues.', 'Impact': 'Lack of transparency in state changes could lead to distrust or difficulties in auditing the contract.', 'Location': 'Functions: `setGenesisAddresses`, `setVaultAddresses`, `setFactoryAddresses`, `setGenesisFactors`, `changeBondingPeriod`, `listBondAsset`, `delistBondAsset`'}], 'IssueNumber': 10, 'OutputList': 11}",,"{'ReviewingTheCode': 'The contract is a DAO (Decentralized Autonomous Organization) implementation that manages proposals, voting, and fund allocation. It includes mechanisms for bonding assets, depositing/withdrawing liquidity, and handling rewards. The contract interacts with multiple external contracts for various functionalities.', 'IdentifyingKeyComponents': {'ContractName': 'Dao', 'Purpose': 'To manage a decentralized organization by handling proposals, voting, fund allocation, and asset management.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['./interfaces/iUTILS.sol', './interfaces/iRESERVE.sol', './interfaces/iDAOVAULT.sol', './interfaces/iROUTER.sol', './interfaces/iBONDVAULT.sol', './interfaces/iBASE.sol', './interfaces/iBEP20.sol', './interfaces/iPOOLFACTORY.sol', './interfaces/iSYNTHFACTORY.sol', './interfaces/iSYNTHVAULT.sol']}, 'StateVariables': [{'Name': 'DEPLOYER', 'Type': 'address', 'Purpose': 'Address of the deployer of the contract.'}, {'Name': 'BASE', 'Type': 'address', 'Purpose': 'Address of the base token.'}, {'Name': 'secondsPerEra', 'Type': 'uint256', 'Purpose': 'Number of seconds per era.'}, {'Name': 'coolOffPeriod', 'Type': 'uint256', 'Purpose': 'Cool off period for proposals.'}, {'Name': 'proposalCount', 'Type': 'uint256', 'Purpose': 'Total number of proposals.'}, {'Name': 'majorityFactor', 'Type': 'uint256', 'Purpose': 'Factor required for majority in voting.'}, {'Name': 'erasToEarn', 'Type': 'uint256', 'Purpose': 'Number of eras to earn rewards.'}, {'Name': 'daoClaim', 'Type': 'uint256', 'Purpose': 'DAO claim percentage.'}, {'Name': 'daoFee', 'Type': 'uint256', 'Purpose': 'Fee required for submitting proposals.'}, {'Name': 'currentProposal', 'Type': 'uint256', 'Purpose': 'ID of the current proposal.'}, {'Name': 'daoHasMoved', 'Type': 'bool', 'Purpose': 'Flag indicating if the DAO has moved.'}, {'Name': 'DAO', 'Type': 'address', 'Purpose': 'Address of the DAO.'}, {'Name': '_ROUTER', 'Type': 'iROUTER', 'Purpose': 'Interface for the router contract.'}, {'Name': '_UTILS', 'Type': 'iUTILS', 'Purpose': 'Interface for the utilities contract.'}, {'Name': '_BONDVAULT', 'Type': 'iBONDVAULT', 'Purpose': 'Interface for the bond vault contract.'}, {'Name': '_DAOVAULT', 'Type': 'iDAOVAULT', 'Purpose': 'Interface for the DAO vault contract.'}, {'Name': '_POOLFACTORY', 'Type': 'iPOOLFACTORY', 'Purpose': 'Interface for the pool factory contract.'}, {'Name': '_SYNTHFACTORY', 'Type': 'iSYNTHFACTORY', 'Purpose': 'Interface for the synth factory contract.'}, {'Name': '_RESERVE', 'Type': 'iRESERVE', 'Purpose': 'Interface for the reserve contract.'}, {'Name': '_SYNTHVAULT', 'Type': 'iSYNTHVAULT', 'Purpose': 'Interface for the synth vault contract.'}, {'Name': 'arrayMembers', 'Type': 'address[]', 'Purpose': 'Array of member addresses.'}, {'Name': 'listedBondAssets', 'Type': 'address[]', 'Purpose': 'Array of listed bond assets.'}, {'Name': 'bondingPeriodSeconds', 'Type': 'uint256', 'Purpose': 'Bonding period in seconds.'}, {'Name': 'isMember', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping to check if an address is a member.'}, {'Name': 'isListed', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping to check if an asset is listed.'}, {'Name': 'mapMember_lastTime', 'Type': 'mapping(address => uint256)', 'Purpose': 'Mapping to store the last time a member interacted.'}, {'Name': 'mapPID_param', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Mapping to store proposal parameters.'}, {'Name': 'mapPID_address', 'Type': 'mapping(uint256 => address)', 'Purpose': 'Mapping to store proposal addresses.'}, {'Name': 'mapPID_type', 'Type': 'mapping(uint256 => string)', 'Purpose': 'Mapping to store proposal types.'}, {'Name': 'mapPID_votes', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Mapping to store proposal votes.'}, {'Name': 'mapPID_coolOffTime', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Mapping to store proposal cool off times.'}, {'Name': 'mapPID_finalising', 'Type': 'mapping(uint256 => bool)', 'Purpose': 'Mapping to check if a proposal is finalising.'}, {'Name': 'mapPID_finalised', 'Type': 'mapping(uint256 => bool)', 'Purpose': 'Mapping to check if a proposal is finalised.'}, {'Name': 'mapPID_open', 'Type': 'mapping(uint256 => bool)', 'Purpose': 'Mapping to check if a proposal is open.'}, {'Name': 'mapPID_startTime', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Mapping to store proposal start times.'}, {'Name': 'mapPIDMember_votes', 'Type': 'mapping(uint256 => mapping(address => uint256))', 'Purpose': 'Mapping to store member votes for proposals.'}], 'FunctionsAndModifiers': [{'Name': 'onlyDAO', 'Visibility': 'modifier', 'Purpose': 'Restricts access to the DAO deployer.', 'Parameters': [], 'Returns': []}, {'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with the base token address and sets initial parameters.', 'Parameters': ['address _base'], 'Returns': []}, {'Name': 'setGenesisAddresses', 'Visibility': 'external', 'Purpose': 'Sets the addresses for the router, utils, and reserve contracts.', 'Parameters': ['address _router', 'address _utils', 'address _reserve'], 'Returns': []}, {'Name': 'setVaultAddresses', 'Visibility': 'external', 'Purpose': 'Sets the addresses for the DAO vault, bond vault, and synth vault contracts.', 'Parameters': ['address _daovault', 'address _bondvault', 'address _synthVault'], 'Returns': []}, {'Name': 'setFactoryAddresses', 'Visibility': 'external', 'Purpose': 'Sets the addresses for the pool factory and synth factory contracts.', 'Parameters': ['address _poolFactory', 'address _synthFactory'], 'Returns': []}, {'Name': 'setGenesisFactors', 'Visibility': 'external', 'Purpose': 'Sets various factors such as cool off period, days to earn, majority factor, DAO claim, and DAO fee.', 'Parameters': ['uint32 _coolOff', 'uint32 _daysToEarn', 'uint32 _majorityFactor', 'uint32 _daoClaim', 'uint32 _daoFee'], 'Returns': []}, {'Name': 'purgeDeployer', 'Visibility': 'external', 'Purpose': 'Removes the deployer address.', 'Parameters': [], 'Returns': []}, {'Name': 'changeBondingPeriod', 'Visibility': 'external', 'Purpose': 'Changes the bonding period in seconds.', 'Parameters': ['uint256 bondingSeconds'], 'Returns': []}, {'Name': 'deposit', 'Visibility': 'external', 'Purpose': 'Deposits liquidity for a member.', 'Parameters': ['address pool', 'uint256 amount'], 'Returns': []}, {'Name': 'depositLPForMember', 'Visibility': 'public', 'Purpose': 'Deposits liquidity for a specified member.', 'Parameters': ['address pool', 'uint256 amount', 'address member'], 'Returns': []}, {'Name': 'withdraw', 'Visibility': 'external', 'Purpose': 'Withdraws liquidity for a member.', 'Parameters': ['address pool'], 'Returns': []}, {'Name': 'harvest', 'Visibility': 'public', 'Purpose': 'Harvests rewards for the caller.', 'Parameters': [], 'Returns': []}, {'Name': 'calcCurrentReward', 'Visibility': 'public', 'Purpose': 'Calculates the current reward for a member.', 'Parameters': ['address member'], 'Returns': ['uint']}, {'Name': 'calcReward', 'Visibility': 'public', 'Purpose': 'Calculates the reward for a member.', 'Parameters': ['address member'], 'Returns': ['uint']}, {'Name': 'burnBalance', 'Visibility': 'external', 'Purpose': 'Burns the base token balance of the contract.', 'Parameters': [], 'Returns': ['bool']}, {'Name': 'moveBASEBalance', 'Visibility': 'external', 'Purpose': 'Moves the base token balance to a new DAO.', 'Parameters': ['address newDAO'], 'Returns': []}, {'Name': 'listBondAsset', 'Visibility': 'external', 'Purpose': 'Lists a bond asset.', 'Parameters': ['address asset'], 'Returns': []}, {'Name': 'delistBondAsset', 'Visibility': 'external', 'Purpose': 'Delists a bond asset.', 'Parameters': ['address asset'], 'Returns': []}, {'Name': 'bond', 'Visibility': 'external', 'Purpose': 'Bonds an asset for the caller.', 'Parameters': ['address asset', 'uint256 amount'], 'Returns': ['bool success']}, {'Name': 'handleTransferIn', 'Visibility': 'internal', 'Purpose': 'Handles the transfer of tokens and adds liquidity.', 'Parameters': ['address _token', 'uint _amount'], 'Returns': ['uint LPunits']}, {'Name': 'claimAllForMember', 'Visibility': 'external', 'Purpose': 'Claims all bonded LP for a member.', 'Parameters': ['address member'], 'Returns': ['bool']}, {'Name': 'claimForMember', 'Visibility': 'external', 'Purpose': 'Claims bonded LP for a member for a specific asset.', 'Parameters': ['address asset'], 'Returns': ['bool']}, {'Name': 'calcClaimBondedLP', 'Visibility': 'public', 'Purpose': 'Calculates the claimable bonded LP for a member.', 'Parameters': ['address bondedMember', 'address asset'], 'Returns': ['uint']}, {'Name': 'newActionProposal', 'Visibility': 'external', 'Purpose': 'Creates a new action proposal.', 'Parameters': ['string memory typeStr'], 'Returns': ['uint']}, {'Name': 'newParamProposal', 'Visibility': 'external', 'Purpose': 'Creates a new parameter proposal.', 'Parameters': ['uint32 param', 'string memory typeStr'], 'Returns': ['uint']}, {'Name': 'newAddressProposal', 'Visibility': 'external', 'Purpose': 'Creates a new address proposal.', 'Parameters': ['address proposedAddress', 'string memory typeStr'], 'Returns': ['uint']}, {'Name': 'newGrantProposal', 'Visibility': 'external', 'Purpose': 'Creates a new grant proposal.', 'Parameters': ['address recipient', 'uint amount'], 'Returns': ['uint']}, {'Name': 'checkProposal', 'Visibility': 'internal', 'Purpose': 'Checks and initializes a new proposal.', 'Parameters': [], 'Returns': []}, {'Name': 'payFee', 'Visibility': 'internal', 'Purpose': 'Pays the fee for submitting a proposal.', 'Parameters': [], 'Returns': ['bool']}, {'Name': 'voteProposal', 'Visibility': 'external', 'Purpose': 'Votes on the current proposal.', 'Parameters': [], 'Returns': ['uint voteWeight']}, {'Name': 'removeVote', 'Visibility': 'public', 'Purpose': 'Removes a vote from the current proposal.', 'Parameters': [], 'Returns': ['uint voteWeightRemoved']}, {'Name': '_finalise', 'Visibility': 'internal', 'Purpose': 'Finalises a proposal.', 'Parameters': [], 'Returns': []}, {'Name': 'cancelProposal', 'Visibility': 'external', 'Purpose': 'Cancels a proposal.', 'Parameters': [], 'Returns': []}, {'Name': 'finaliseProposal', 'Visibility': 'external', 'Purpose': 'Finalises a proposal after the cool off period.', 'Parameters': [], 'Returns': []}, {'Name': 'moveDao', 'Visibility': 'internal', 'Purpose': 'Moves the DAO to a new address.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'moveRouter', 'Visibility': 'internal', 'Purpose': 'Moves the router to a new address.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'moveUtils', 'Visibility': 'internal', 'Purpose': 'Moves the utils to a new address.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'moveReserve', 'Visibility': 'internal', 'Purpose': 'Moves the reserve to a new address.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'flipEmissions', 'Visibility': 'internal', 'Purpose': 'Flips the emissions state.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'changeCooloff', 'Visibility': 'internal', 'Purpose': 'Changes the cool off period.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'changeEras', 'Visibility': 'internal', 'Purpose': 'Changes the number of eras to earn.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'grantFunds', 'Visibility': 'internal', 'Purpose': 'Grants funds to a recipient.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': '_increaseSpartaAllocation', 'Visibility': 'internal', 'Purpose': 'Increases the SPARTA allocation.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': '_listBondingAsset', 'Visibility': 'internal', 'Purpose': 'Lists a bonding asset.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': '_delistBondingAsset', 'Visibility': 'internal', 'Purpose': 'Delists a bonding asset.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': '_addCuratedPool', 'Visibility': 'internal', 'Purpose': 'Adds a curated pool.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': '_removeCuratedPool', 'Visibility': 'internal', 'Purpose': 'Removes a curated pool.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'completeProposal', 'Visibility': 'internal', 'Purpose': 'Completes a proposal.', 'Parameters': ['uint _proposalID'], 'Returns': []}, {'Name': 'countVotes', 'Visibility': 'internal', 'Purpose': 'Counts votes for the current proposal.', 'Parameters': [], 'Returns': ['uint voteWeight']}, {'Name': 'hasMajority', 'Visibility': 'public', 'Purpose': 'Checks if a proposal has a majority.', 'Parameters': ['uint _proposalID'], 'Returns': ['bool']}, {'Name': 'hasQuorum', 'Visibility': 'public', 'Purpose': 'Checks if a proposal has a quorum.', 'Parameters': ['uint _proposalID'], 'Returns': ['bool']}, {'Name': 'hasMinority', 'Visibility': 'public', 'Purpose': 'Checks if a proposal has a minority.', 'Parameters': ['uint _proposalID'], 'Returns': ['bool']}, {'Name': 'ROUTER', 'Visibility': 'public', 'Purpose': 'Returns the router contract.', 'Parameters': [], 'Returns': ['iROUTER']}, {'Name': 'UTILS', 'Visibility': 'public', 'Purpose': 'Returns the utils contract.', 'Parameters': [], 'Returns': ['iUTILS']}, {'Name': 'BONDVAULT', 'Visibility': 'public', 'Purpose': 'Returns the bond vault contract.', 'Parameters': [], 'Returns': ['iBONDVAULT']}, {'Name': 'DAOVAULT', 'Visibility': 'public', 'Purpose': 'Returns the DAO vault contract.', 'Parameters': [], 'Returns': ['iDAOVAULT']}, {'Name': 'POOLFACTORY', 'Visibility': 'public', 'Purpose': 'Returns the pool factory contract.', 'Parameters': [], 'Returns': ['iPOOLFACTORY']}, {'Name': 'SYNTHFACTORY', 'Visibility': 'public', 'Purpose': 'Returns the synth factory contract.', 'Parameters': [], 'Returns': ['iSYNTHFACTORY']}, {'Name': 'RESERVE', 'Visibility': 'public', 'Purpose': 'Returns the reserve contract.', 'Parameters': [], 'Returns': ['iRESERVE']}, {'Name': 'SYNTHVAULT', 'Visibility': 'public', 'Purpose': 'Returns the synth vault contract.', 'Parameters': [], 'Returns': ['iSYNTHVAULT']}, {'Name': 'memberCount', 'Visibility': 'external', 'Purpose': 'Returns the number of members.', 'Parameters': [], 'Returns': ['uint']}, {'Name': 'getProposalDetails', 'Visibility': 'external', 'Purpose': 'Returns the details of a proposal.', 'Parameters': ['uint proposalID'], 'Returns': ['ProposalDetails memory proposalDetails']}, {'Name': 'assetListedCount', 'Visibility': 'external', 'Purpose': 'Returns the number of listed bond assets.', 'Parameters': [], 'Returns': ['uint256 count']}, {'Name': 'allListedAssets', 'Visibility': 'external', 'Purpose': 'Returns all listed bond assets.', 'Parameters': [], 'Returns': ['address[] memory _allListedAssets']}, {'Name': 'isEqual', 'Visibility': 'private', 'Purpose': 'Checks if two byte arrays are equal.', 'Parameters': ['bytes memory part1', 'bytes memory part2'], 'Returns': ['bool']}]}, 'ExternalInteractions': ['iROUTER', 'iUTILS', 'iBONDVAULT', 'iDAOVAULT', 'iPOOLFACTORY', 'iSYNTHFACTORY', 'iRESERVE', 'iSYNTHVAULT', 'iBASE', 'iBEP20'], 'SpecialMechanisms': ['DAO management and voting system', 'Bonding and liquidity management', 'Proposal creation and finalisation', 'Reward calculation and distribution', 'External contract interactions'], 'Questions': ['How are the rewards calculated and distributed in detail?', 'What is the exact process for finalising a proposal?', 'Are there any potential security risks with the external contract interactions?', 'How is the majority factor determined and applied in voting?', 'What are the specific conditions for a proposal to be considered finalised?']}",864.5605959892273,"### **[H-04] Proposals can be cancelled**

**Report Description**:
Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved. An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed. The recommendation is to check that `oldProposalID` != `newProposalID`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of proposal cancellation or the associated denial of service risk. This is a critical governance vulnerability that is entirely missed in the response list.

---

### **[H-05] Flash loans can affect governance voting in DAO.sol**

**Report Description**:
Flash loans can significantly increase a single voter's weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which they also deterministically influence the voting outcome to their choice. This has already happened in the case of MakerDAO governance. The recommendation is to account for flash loans in `countMemberVotes()` by using weight from previous blocks or consider capping the weight of individual voters.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of flash loans affecting governance voting. This is a significant risk to the integrity of the DAO's governance process and is entirely overlooked.

---

### **[M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol**

**Report Description**:
Given that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if 'DAO' type checked in `voteProposal()` is a typographical error and should really be 'GRANT'. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%). The recommendation is to change ‘DAO’ on L83 to ‘GRANT’ or specify what DAO proposals are and how GRANT proposals should be handled with quorum or majority.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the undefined behavior for DAO and GRANT vote proposals. This is a medium-severity issue that could lead to governance inconsistencies and is entirely missed.

---

### **[M-06] Canceled proposals can still be executed**

**Report Description**:
Proposals that passed the threshold (""finalized"") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal`, which queues them for execution. The recommendation is to set a cancel flag and check for it in `finaliseProposal` and in execution.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of canceled proposals still being executed. This is a medium-severity issue that could lead to unintended proposal execution and is entirely missed.

---

### **[M-07] Completed proposals can be voted on and executed again**

**Report Description**:
A proposal that is completed has its state reset, including the votes. Users can just vote on it again and it can be executed again. Completed proposals should most likely not be allowed to be voted on / executed again. This could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the `FinalisedProposal` event has fired. The recommendation is to add an `executed` flag to the proposals and disallow voting/finalising on already executed proposals.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of completed proposals being voted on and executed again. This is a medium-severity issue that could lead to governance inconsistencies and is entirely missed.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
Most of the Solidity contracts have an init function that everyone can call. The `init()` function is not restricted, allowing anyone to initialize the contract, which could lead to unintended behavior or vulnerabilities.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unrestricted access to the `init()` function. This is a medium-severity issue that could lead to unintended contract initialization and is entirely missed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-04] Proposals can be cancelled**
- **[H-05] Flash loans can affect governance voting in DAO.sol**
- **[M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol**
- **[M-06] Canceled proposals can still be executed**
- **[M-07] Completed proposals can be voted on and executed again**
- **[M-13] Init function can be called by everyone**

---

### **Conclusion**
The response list fails to address any of the issues reported in the `issue` list. This indicates a significant gap in the coverage of vulnerabilities, risks, and impacts specific to the Solidity smart contracts in question. The response list should be revised to include these critical and medium-severity issues to ensure comprehensive security coverage.","```
None.
```",0.0
utils.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Utils {

    uint private one = 10**18;
    uint private _10k = 10000;
    uint private _year = 31536000; // One Year (in seconds)

    bool private inited;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    constructor () {}

    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        POOLS = _pools;
        FACTORY = _factory;
    }
    //====================================SYSTEM FUNCTIONS====================================//
    // VADER FeeOnTransfer
    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){
        return calcShare(totalSupply, maxSupply, 100); // 0->100BP
    }

    function assetChecks(address collateralAsset, address debtAsset) external {
        if(collateralAsset == VADER){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        } else if(collateralAsset == USDV){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); // Can borrow Asset with VADER/ASSET-SYNTH
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        }
    }

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    //====================================PRICING====================================//

    function calcValueInBase(address token, uint amount) public view returns (uint value){
       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
       if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _baseAmt) / _tokenAmt;
       }
    }

    function calcValueInToken(address token, uint amount) public view returns (uint value){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _tokenAmt) / _baseAmt;
       }
    }
    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){
            return calcValueInToken(token2, calcValueInBase(token1, amount));
    }

    function calcSwapValueInBase(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _tokenAmt, _baseAmt);
    }
    function calcSwapValueInToken(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _baseAmt, _tokenAmt);
    }

    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {
        uint _testingPrice = calcValueInBase(token, one);
        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price
        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price
        if(inside){
            require((_testingPrice >= _lower && _testingPrice <= _upper), ""Not inside"");
        } else {
            require((_testingPrice <= _lower || _testingPrice >= _upper), ""Not outside"");
        }
    }

    //====================================INCENTIVES========================================//

    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {
        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){
            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);
            if (iPOOLS(POOLS).isAsset(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            } else if(iPOOLS(POOLS).isAnchor(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            }
        }
    }

    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {
        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast
    }

    //=================================IMPERMANENT LOSS=====================================//

    // Actual protection with 100 day rule and Reserve balance
    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {
        uint _coverage = getCoverage(member, token);
        if(iROUTER(ROUTER).isCurated(token)){
            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);
            if(_duration <= timeForFullProtection) {
                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule
            } else {
                protection = _coverage;
            }
        }
        return calcPart(basisPoints, protection);
    }
    // Theoretical coverage based on deposit/redemption values
    function getCoverage(address member, address token) public view returns (uint) {
        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);
        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);
        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));
        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));
        return calcCoverage(_B0, _T0, _B1, _T1);
    }

    //==================================== LENDING ====================================//

    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {
        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio
        if(isBase(collateralAsset)){
            baseValue = _collateralAdjusted;
        }else if(isPool(collateralAsset)){
            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE
        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){
            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value
        }
        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output
        return (debt, baseValue);
    }

    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {
        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt
        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral
        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);
        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);
        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral
        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); 
        return (_collateralUnlocked, _memberInterestShare);
    }

    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {
        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year
        if(isBase(collateralAsset)){
            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base
        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {
            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)
        }
    }
    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);
        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; 
    }
    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);
        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);
        return (_debtIssued * 10000) / _debtDepth; 
    }

    //====================================CORE-MATH====================================//

    function calcPart(uint bp, uint total) public pure returns (uint){
        // 10,000 basis points = 100.00%
        require((bp <= 10000) && (bp >= 0), ""Must be correct BP"");
        return calcShare(bp, 10000, total);
    }

    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){
        // share = amount * part/total
        if(part > total){
            part = total;
        }
        if(total > 0){
            share = (amount * part) / total;
        }
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){
        // y = (x * X * Y )/(x + X)^2
        uint numerator = (x * X * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){
        // fee = (x * x * Y) / (x + X)^2
        uint numerator = (x * x * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }
    function calcSwapSlip(uint x, uint X) external pure returns (uint){
        // slip = (x) / (x + X)
        return (x*10000) / (x + X);
    }

    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){
        if(P == 0){
            return b;
        } else {
            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment
            // P * (part1 + part2) / (part3) * slipAdjustment
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = (t * B);
            uint part2 = (T * b);
            uint part3 = (T * B) * 2;
            uint _units = (((P * part1) + part2) / part3);
            return (_units * slipAdjustment) / one;  // Divide by 10**18
        }
    }

    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){
        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))
        // 1 - ABS(part1 - part2)/(part3 * part4))
        uint part1 = B * t;
        uint part2 = b * T;
        uint part3 = (b * 2) + B;
        uint part4 = t + T;
        uint numerator;
        if(part1 > part2){
            numerator = (part1 - part2);
        } else {
            numerator = (part2 - part1);
        }
        uint denominator = (part3 * part4);
        return one - (numerator * one) / denominator; // Multiply by 10**18
    }

    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){
        // (P * b)/(2*(b + B))
        return (P * b) / (2 * (b + B));
    }

    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){
        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3
        // (part1 * (part2 - part3 + part4)) / part5
        uint part1 = (u * A);
        uint part2 = ((U * U) * 2);
        uint part3 = ((U * u) * 2);
        uint part4 = (u * u);
        uint numerator = ((part1 * part2) - part3) + part4;
        uint part5 = ((U * U) * U);
        return (numerator / part5);
    }
    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){
        if(B0 > 0 && T1 > 0){
            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)
            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)
            if(_redemptionValue <= _depositValue){
                coverage = (_depositValue - _redemptionValue);
            }
        }
    }

    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)
    function sortArray(uint[] memory array) external pure returns (uint[] memory) {
        uint l = array.length;
        for(uint i = 0; i < l; i++){
            for(uint j = i+1; j < l; j++){
                if(array[i] > array[j]){
                    uint temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
        }
        return array;
    }

}",3621,302,"[H-07] Wrong calcAsymmetricShare calculation
The inline-comment defines the number of asymmetric shares as (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3 but the Utils.calcAsymmetricShare function computes (uA * 2U^2 - 2uU + u^2) / U^3 which is not equivalent as can be seen from the A^2 term in the first term which does not occur in the second one.
The associativity on P * part1 is wrong, and part2 is not multiplied by P.
The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up.
 [H-08] Wrong liquidity units calculation
The spec defines the number of LP units to be minted as units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments but the Utils.calcLiquidityUnits function computes ((P * part1) + part2) / part3 * slipAdjustments.
The associativity on P * part1 is wrong, and part2 is not multiplied by P.
The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.
 [M-05] Interest debt is capped after a year
The Utils.getInterestOwed function computes the _interestPayment as: ``` uint256 _interestPayment =
  calcShare(
      timeElapsed,
      _year,
      getInterestPayment(collateralAsset, debtAsset)
  ); // Share of the payment over 1 year ``` However, calcShare caps timeElpased to _year and therefore the owed interest does not grow after a year has elapsed. The impact is probably small because the only call so far computes the elapsed time as block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset]; which most likely will never go beyond a year.  [M-09] Divide before multiply
Can't quite understand the assertion that a division is made before a multiply in the code outlined ```uint _units = (((P * part1) + part2) / part3);
    return (_units * slipAdjustment) / one;  // Divide by 10**18 ```  [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()",5,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Utils {

    uint private one = 10**18;
    uint private _10k = 10000;
    uint private _year = 31536000; 

    bool private inited;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    constructor () {}

    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        POOLS = _pools;
        FACTORY = _factory;
    }
    
    
    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){
        return calcShare(totalSupply, maxSupply, 100); 
    }

    function assetChecks(address collateralAsset, address debtAsset) external {
        if(collateralAsset == VADER){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); 
        } else if(collateralAsset == USDV){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); 
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); 
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); 
        }
    }

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    

    function calcValueInBase(address token, uint amount) public view returns (uint value){
       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
       if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _baseAmt) / _tokenAmt;
       }
    }

    function calcValueInToken(address token, uint amount) public view returns (uint value){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _tokenAmt) / _baseAmt;
       }
    }
    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){
            return calcValueInToken(token2, calcValueInBase(token1, amount));
    }

    function calcSwapValueInBase(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _tokenAmt, _baseAmt);
    }
    function calcSwapValueInToken(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _baseAmt, _tokenAmt);
    }

    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {
        uint _testingPrice = calcValueInBase(token, one);
        uint _lower = calcPart((_10k - bound), targetPrice);                
        uint _upper = (targetPrice * (_10k + bound)) / _10k;                
        if(inside){
            require((_testingPrice >= _lower && _testingPrice <= _upper), ""Not inside"");
        } else {
            require((_testingPrice <= _lower || _testingPrice >= _upper), ""Not outside"");
        }
    }

    

    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {
        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){
            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);
            if (iPOOLS(POOLS).isAsset(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            } else if(iPOOLS(POOLS).isAnchor(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            }
        }
    }

    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {
        return calcShare(1, rewardReductionFactor, amount); 
    }

    

    
    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {
        uint _coverage = getCoverage(member, token);
        if(iROUTER(ROUTER).isCurated(token)){
            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);
            if(_duration <= timeForFullProtection) {
                protection = calcShare(_duration, timeForFullProtection, _coverage); 
            } else {
                protection = _coverage;
            }
        }
        return calcPart(basisPoints, protection);
    }
    
    function getCoverage(address member, address token) public view returns (uint) {
        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);
        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);
        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));
        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));
        return calcCoverage(_B0, _T0, _B1, _T1);
    }

    

    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {
        uint _collateralAdjusted = (collateral * 6666) / 10000; 
        if(isBase(collateralAsset)){
            baseValue = _collateralAdjusted;
        }else if(isPool(collateralAsset)){
            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); 
        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){
            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); 
        }
        debt = calcSwapValueInToken(debtAsset, baseValue);        
        return (debt, baseValue);
    }

    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {
        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); 
        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); 
        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);
        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);
        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); 
        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); 
        return (_collateralUnlocked, _memberInterestShare);
    }

    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {
        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); 
        if(isBase(collateralAsset)){
            interestOwed = calcValueInBase(debtAsset, _interestPayment); 
        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {
            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); 
        }
    }
    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);
        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; 
    }
    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);
        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);
        return (_debtIssued * 10000) / _debtDepth; 
    }

    

    function calcPart(uint bp, uint total) public pure returns (uint){
        
        require((bp <= 10000) && (bp >= 0), ""Must be correct BP"");
        return calcShare(bp, 10000, total);
    }

    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){
        
        if(part > total){
            part = total;
        }
        if(total > 0){
            share = (amount * part) / total;
        }
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){
        
        uint numerator = (x * X * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){
        
        uint numerator = (x * x * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }
    function calcSwapSlip(uint x, uint X) external pure returns (uint){
        
        return (x*10000) / (x + X);
    }

    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){
        if(P == 0){
            return b;
        } else {
            
            
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = (t * B);
            uint part2 = (T * b);
            uint part3 = (T * B) * 2;
            uint _units = (((P * part1) + part2) / part3);
            return (_units * slipAdjustment) / one;  
        }
    }

    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){
        
        
        uint part1 = B * t;
        uint part2 = b * T;
        uint part3 = (b * 2) + B;
        uint part4 = t + T;
        uint numerator;
        if(part1 > part2){
            numerator = (part1 - part2);
        } else {
            numerator = (part2 - part1);
        }
        uint denominator = (part3 * part4);
        return one - (numerator * one) / denominator; 
    }

    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){
        
        return (P * b) / (2 * (b + B));
    }

    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){
        
        
        uint part1 = (u * A);
        uint part2 = ((U * U) * 2);
        uint part3 = ((U * u) * 2);
        uint part4 = (u * u);
        uint numerator = ((part1 * part2) - part3) + part4;
        uint part5 = ((U * U) * U);
        return (numerator / part5);
    }
    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){
        if(B0 > 0 && T1 > 0){
            uint _depositValue = B0 + (T0 * B1) / T1; 
            uint _redemptionValue = B1 + (T1 * B1) / T1; 
            if(_redemptionValue <= _depositValue){
                coverage = (_depositValue - _redemptionValue);
            }
        }
    }

    
    function sortArray(uint[] memory array) external pure returns (uint[] memory) {
        uint l = array.length;
        for(uint i = 0; i < l; i++){
            for(uint j = i+1; j < l; j++){
                if(array[i] > array[j]){
                    uint temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
        }
        return array;
    }

}",3097,2,3,"{'Findings': [{'Issue': 'Uninitialized State Variables', 'Severity': 'High', 'Description': 'The contract has state variables (e.g., `inited`, `VADER`, `USDV`, `ROUTER`, `POOLS`, `FACTORY`) that are not initialized in the constructor. These variables are only set in the `init` function, which can be called only once. If `init` is not called, these variables remain uninitialized, leading to potential undefined behavior or vulnerabilities.', 'Impact': 'Uninitialized state variables can cause the contract to behave unexpectedly, leading to potential security risks or loss of funds.', 'Location': 'State variables and `init` function'}, {'Issue': 'Lack of Access Control on `init` Function', 'Severity': 'High', 'Description': 'The `init` function is publicly accessible and lacks any access control mechanisms. This allows any external actor to call this function and set critical state variables, potentially leading to malicious actions such as unauthorized initialization or reinitialization of the contract.', 'Impact': 'An attacker could initialize the contract with malicious addresses, leading to potential loss of funds or control over the contract.', 'Location': '`init` function'}, {'Issue': 'Potential Division by Zero', 'Severity': 'Medium', 'Description': 'Several functions (e.g., `calcValueInBase`, `calcValueInToken`, `calcSwapOutput`, `calcShare`) perform division operations without checking if the denominator is zero. This could lead to runtime errors and potential exploits.', 'Impact': 'Division by zero will cause the transaction to revert, potentially disrupting contract functionality and user experience.', 'Location': 'Functions `calcValueInBase`, `calcValueInToken`, `calcSwapOutput`, `calcShare`'}, {'Issue': 'Incomplete Function Implementation', 'Severity': 'Medium', 'Description': 'The `isBase` and `isPool` functions do not return a value in all code paths. Specifically, if the token is neither `VADER` nor `USDV` (for `isBase`) or neither an anchor nor an asset (for `isPool`), the functions do not return a value, which could lead to unexpected behavior.', 'Impact': 'Potential undefined behavior or runtime errors when the functions are called with unsupported tokens.', 'Location': '`isBase` and `isPool` functions'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': 'The contract performs several arithmetic operations (e.g., in `calcShare`, `calcSwapOutput`, `calcLiquidityUnits`) without explicit checks for potential overflow or underflow. Although Solidity 0.8.x has built-in overflow/underflow protection, it is still good practice to handle these cases explicitly.', 'Impact': 'Integer overflow/underflow can lead to incorrect calculations, potentially causing financial losses or unexpected behavior.', 'Location': 'Various arithmetic operations throughout the contract'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'Several functions (e.g., `calcPart`, `calcShare`, `calcSwapOutput`) do not validate input parameters. For example, `calcPart` does not check if `bp` is within the valid range (0-10000) before performing calculations.', 'Impact': 'Invalid input parameters can lead to incorrect calculations or unexpected behavior.', 'Location': '`calcPart`, `calcShare`, `calcSwapOutput` functions'}, {'Issue': 'Potential Reentrancy in External Calls', 'Severity': 'Medium', 'Description': 'The contract makes multiple external calls (e.g., to `iPOOLS`, `iROUTER`, `iFACTORY`) without using the `checks-effects-interactions` pattern. This could potentially lead to reentrancy attacks if the called contracts are malicious or have vulnerabilities.', 'Impact': ""Reentrancy attacks could allow an attacker to manipulate the contract's state or steal funds."", 'Location': 'Various functions making external calls'}, {'Issue': 'Incorrect Calculation in `calcSwapOutput` Function', 'Severity': 'Medium', 'Description': 'The `calcSwapOutput` function calculates the output of a swap using a formula that may not correctly represent the intended behavior. The formula used could lead to incorrect swap values being returned.', 'Impact': 'Incorrect swap values could lead to financial losses or inefficiencies in the system.', 'Location': '`calcSwapOutput` function'}, {'Issue': 'Unused Variables', 'Severity': 'Low', 'Description': 'The contract declares several private variables (e.g., `one`, `_10k`, `_year`) that are not used in the code. This could indicate incomplete or outdated code.', 'Impact': ""Unused variables can increase the contract's size and complexity without providing any benefit."", 'Location': 'Private variables `one`, `_10k`, `_year`'}, {'Issue': 'Inconsistent Naming Conventions', 'Severity': 'Low', 'Description': 'The contract uses inconsistent naming conventions for variables and functions, such as `one`, `_10k`, and `_year`. This can reduce code readability and maintainability.', 'Impact': 'Reduced code clarity, making it harder for developers to understand and maintain the contract.', 'Location': 'State variables `one`, `_10k`, `_year`'}, {'Issue': 'Unused Import', 'Severity': 'Low', 'Description': 'The contract imports `hardhat/console.sol`, but there is no usage of the `console` library in the code. This is unnecessary and could lead to increased deployment costs.', 'Impact': 'Increased deployment costs due to unnecessary code.', 'Location': 'Import statement for `hardhat/console.sol`'}], 'IssueNumber': 12, 'OutputList': 11}",,"{'ReviewingTheCode': ""The provided Solidity contract, named 'Utils', appears to be a utility contract designed to provide various helper functions for interacting with a DeFi ecosystem. The contract includes functions for calculating fees, validating asset combinations, computing swap values, and managing rewards and protections. It also interacts with multiple external contracts through imported interfaces."", 'IdentifyingKeyComponents': {'ContractName': 'Utils', 'Purpose': 'To provide utility functions for a DeFi ecosystem, including fee calculations, asset validation, swap computations, and reward management.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['./interfaces/iERC20.sol', './interfaces/iVADER.sol', './interfaces/iROUTER.sol', './interfaces/iPOOLS.sol', './interfaces/iFACTORY.sol', './interfaces/iSYNTH.sol', 'hardhat/console.sol']}, 'StateVariables': [{'Name': 'one', 'Type': 'uint', 'Purpose': 'Represents 10^18, likely used for precision in calculations.'}, {'Name': '_10k', 'Type': 'uint', 'Purpose': 'Represents 10000, likely used for basis points calculations.'}, {'Name': '_year', 'Type': 'uint', 'Purpose': 'Represents the number of seconds in a year, used for time-based calculations.'}, {'Name': 'inited', 'Type': 'bool', 'Purpose': 'Flag to ensure the contract is initialized only once.'}, {'Name': 'VADER', 'Type': 'address', 'Purpose': 'Address of the VADER token contract.'}, {'Name': 'USDV', 'Type': 'address', 'Purpose': 'Address of the USDV token contract.'}, {'Name': 'ROUTER', 'Type': 'address', 'Purpose': 'Address of the ROUTER contract.'}, {'Name': 'POOLS', 'Type': 'address', 'Purpose': 'Address of the POOLS contract.'}, {'Name': 'FACTORY', 'Type': 'address', 'Purpose': 'Address of the FACTORY contract.'}], 'FunctionsAndModifiers': [{'Name': 'init', 'Visibility': 'public', 'Purpose': 'Initializes the contract with addresses of key contracts.', 'Parameters': ['_vader', '_usdv', '_router', '_pools', '_factory'], 'Returns': []}, {'Name': 'getFeeOnTransfer', 'Visibility': 'external', 'Purpose': 'Calculates the fee on transfer based on total and max supply.', 'Parameters': ['totalSupply', 'maxSupply'], 'Returns': ['uint']}, {'Name': 'assetChecks', 'Visibility': 'external', 'Purpose': 'Validates combinations of collateral and debt assets.', 'Parameters': ['collateralAsset', 'debtAsset'], 'Returns': []}, {'Name': 'isBase', 'Visibility': 'public', 'Purpose': 'Checks if a token is a base token (VADER or USDV).', 'Parameters': ['token'], 'Returns': ['bool']}, {'Name': 'isPool', 'Visibility': 'public', 'Purpose': 'Checks if a token is a pool token.', 'Parameters': ['token'], 'Returns': ['bool']}, {'Name': 'calcValueInBase', 'Visibility': 'public', 'Purpose': 'Calculates the value of a token in base terms.', 'Parameters': ['token', 'amount'], 'Returns': ['uint']}, {'Name': 'calcValueInToken', 'Visibility': 'public', 'Purpose': 'Calculates the value of a base amount in token terms.', 'Parameters': ['token', 'amount'], 'Returns': ['uint']}, {'Name': 'calcValueOfTokenInToken', 'Visibility': 'public', 'Purpose': 'Calculates the value of one token in terms of another token.', 'Parameters': ['token1', 'amount', 'token2'], 'Returns': ['uint']}, {'Name': 'calcSwapValueInBase', 'Visibility': 'public', 'Purpose': 'Calculates the swap value in base terms.', 'Parameters': ['token', 'amount'], 'Returns': ['uint']}, {'Name': 'calcSwapValueInToken', 'Visibility': 'public', 'Purpose': 'Calculates the swap value in token terms.', 'Parameters': ['token', 'amount'], 'Returns': ['uint']}, {'Name': 'requirePriceBounds', 'Visibility': 'external', 'Purpose': 'Ensures the price of a token is within specified bounds.', 'Parameters': ['token', 'bound', 'inside', 'targetPrice'], 'Returns': []}, {'Name': 'getRewardShare', 'Visibility': 'external', 'Purpose': 'Calculates the reward share for a token.', 'Parameters': ['token', 'rewardReductionFactor'], 'Returns': ['uint']}, {'Name': 'getReducedShare', 'Visibility': 'public', 'Purpose': 'Calculates a reduced share based on a reduction factor.', 'Parameters': ['amount', 'rewardReductionFactor'], 'Returns': ['uint']}, {'Name': 'getProtection', 'Visibility': 'public', 'Purpose': 'Calculates the protection for a member based on their coverage.', 'Parameters': ['member', 'token', 'basisPoints', 'timeForFullProtection'], 'Returns': ['uint']}, {'Name': 'getCoverage', 'Visibility': 'public', 'Purpose': 'Calculates the coverage for a member.', 'Parameters': ['member', 'token'], 'Returns': ['uint']}, {'Name': 'getCollateralValueInBase', 'Visibility': 'external', 'Purpose': 'Calculates the collateral value in base terms.', 'Parameters': ['member', 'collateral', 'collateralAsset', 'debtAsset'], 'Returns': ['uint', 'uint']}, {'Name': 'getDebtValueInCollateral', 'Visibility': 'external', 'Purpose': 'Calculates the debt value in collateral terms.', 'Parameters': ['member', 'debt', 'collateralAsset', 'debtAsset'], 'Returns': ['uint', 'uint']}, {'Name': 'getInterestOwed', 'Visibility': 'external', 'Purpose': 'Calculates the interest owed for a given time period.', 'Parameters': ['collateralAsset', 'debtAsset', 'timeElapsed'], 'Returns': ['uint']}, {'Name': 'getInterestPayment', 'Visibility': 'public', 'Purpose': 'Calculates the interest payment based on debt loading.', 'Parameters': ['collateralAsset', 'debtAsset'], 'Returns': ['uint']}, {'Name': 'getDebtLoading', 'Visibility': 'public', 'Purpose': 'Calculates the debt loading for a given asset pair.', 'Parameters': ['collateralAsset', 'debtAsset'], 'Returns': ['uint']}, {'Name': 'calcPart', 'Visibility': 'public', 'Purpose': 'Calculates a part of a total based on basis points.', 'Parameters': ['bp', 'total'], 'Returns': ['uint']}, {'Name': 'calcShare', 'Visibility': 'public', 'Purpose': 'Calculates a share of an amount based on a part and total.', 'Parameters': ['part', 'total', 'amount'], 'Returns': ['uint']}, {'Name': 'calcSwapOutput', 'Visibility': 'public', 'Purpose': 'Calculates the output of a swap.', 'Parameters': ['x', 'X', 'Y'], 'Returns': ['uint']}, {'Name': 'calcSwapFee', 'Visibility': 'external', 'Purpose': 'Calculates the fee for a swap.', 'Parameters': ['x', 'X', 'Y'], 'Returns': ['uint']}, {'Name': 'calcSwapSlip', 'Visibility': 'external', 'Purpose': 'Calculates the slippage for a swap.', 'Parameters': ['x', 'X'], 'Returns': ['uint']}, {'Name': 'calcLiquidityUnits', 'Visibility': 'external', 'Purpose': 'Calculates the liquidity units for a pool.', 'Parameters': ['b', 'B', 't', 'T', 'P'], 'Returns': ['uint']}, {'Name': 'getSlipAdustment', 'Visibility': 'public', 'Purpose': 'Calculates the slippage adjustment for liquidity units.', 'Parameters': ['b', 'B', 't', 'T'], 'Returns': ['uint']}, {'Name': 'calcSynthUnits', 'Visibility': 'external', 'Purpose': 'Calculates the synth units for a pool.', 'Parameters': ['b', 'B', 'P'], 'Returns': ['uint']}, {'Name': 'calcAsymmetricShare', 'Visibility': 'public', 'Purpose': 'Calculates an asymmetric share for a pool.', 'Parameters': ['u', 'U', 'A'], 'Returns': ['uint']}, {'Name': 'calcCoverage', 'Visibility': 'public', 'Purpose': 'Calculates the coverage for a pool.', 'Parameters': ['B0', 'T0', 'B1', 'T1'], 'Returns': ['uint']}, {'Name': 'sortArray', 'Visibility': 'external', 'Purpose': 'Sorts an array of unsigned integers.', 'Parameters': ['array'], 'Returns': ['uint[]']}]}, 'ExternalInteractions': ['iERC20', 'iVADER', 'iROUTER', 'iPOOLS', 'iFACTORY', 'iSYNTH'], 'SpecialMechanisms': ['The contract uses a variety of mathematical formulas to calculate swap outputs, fees, slippage, and liquidity units. It also implements checks and validations for asset combinations and price bounds.'], 'Questions': [""What is the exact purpose of the 'getSlipAdustment' function, and how is it used in the context of liquidity units?"", ""How are the 'calcAsymmetricShare' and 'calcCoverage' functions utilized in the broader DeFi ecosystem?"", ""Are there any specific security considerations for the 'init' function to prevent reinitialization attacks?""]}",841.4286661148071,"### **Comparison and Evaluation**

---

#### **[H-07] Wrong calcAsymmetricShare Calculation**

**Report Description**:  
The `calcAsymmetricShare` function in `Utils.sol` incorrectly implements the mathematical formula specified in the inline comment. The formula in the comment is `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3`, but the function computes `(uA * 2U^2 - 2uU + u^2) / U^3`, which is not equivalent. This discrepancy could lead to incorrect collateral value calculations, potentially allowing users to borrow more than their collateral value, leading to economic exploitation of the protocol.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The incorrect implementation of the mathematical formula in `calcAsymmetricShare` is a critical vulnerability that could lead to economic exploitation, but it is not covered in the response list.

---

#### **[H-08] Wrong Liquidity Units Calculation**

**Report Description**:  
The `calcLiquidityUnits` function in `Utils.sol` incorrectly implements the mathematical formula specified in the spec. The spec defines the formula as `units = (P (a B + A b))/(2 A B) * slipAdjustment`, but the function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity of `P * part1` is wrong, and `part2` is not multiplied by `P`. This could lead to incorrect LP token minting and redemption, potentially allowing economic exploitation of the protocol.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The incorrect implementation of the mathematical formula in `calcLiquidityUnits` is a critical vulnerability that could lead to economic exploitation, but it is not covered in the response list.

---

#### **[M-05] Interest Debt is Capped After a Year**

**Report Description**:  
The `getInterestOwed` function in `Utils.sol` caps the `timeElapsed` to `_year` when calculating interest owed. This means that the interest owed does not grow after a year has elapsed. While the impact is likely small because the elapsed time is unlikely to exceed a year, this could still lead to incorrect interest calculations in edge cases.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The capping of interest debt after a year is a potential vulnerability that could lead to incorrect interest calculations, but it is not covered in the response list.

---

#### **[M-09] Divide Before Multiply**

**Report Description**:  
The code snippet provided in the issue report shows a potential division before multiplication in the calculation of `_units`. The assertion is that this could lead to incorrect calculations due to the order of operations, but the issue is not fully explained or understood.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The potential division before multiplication is a vulnerability that could lead to incorrect calculations, but it is not covered in the response list.

---

#### **[M-13] Init Function Can Be Called by Everyone**

**Report Description**:  
The `init` function in most of the Solidity contracts can be called by anyone, as it lacks access control. This could allow unauthorized initialization or reinitialization of the contract, potentially leading to malicious actions such as setting critical state variables with malicious addresses.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on `init` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `init` function lacking access control. It correctly explains the risks associated with unauthorized initialization, which aligns with Solidity best practices for secure contract design.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init Function Can Be Called by Everyone**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-07] Wrong calcAsymmetricShare Calculation**
- **[H-08] Wrong Liquidity Units Calculation**
- **[M-05] Interest Debt is Capped After a Year**
- **[M-09] Divide Before Multiply**

---

### **Conclusion**

The response list covers only one of the five issues in the issue report, specifically the lack of access control on the `init` function. The remaining issues, which involve incorrect mathematical calculations, interest debt capping, and potential division before multiplication, are not addressed in the response list. This indicates significant gaps in the coverage of vulnerabilities and risks in the provided response list.","```
1. Lack of Access Control on `init` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - The true positive is `Lack of Access Control on init Function`.
   - In the ranked predictions, this issue appears at rank 2.

2. **Calculate the precision at that rank**:
   - Precision at rank 2 (\( P@2 \)) is calculated as the number of true positives up to rank 2 divided by 2.
   - Since there is only one true positive up to rank 2, \( P@2 = \frac{1}{2} = 0.5 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.5 \).

**Output**:
```
0.5
```"
Router.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Router {

    // Parameters
    bool private inited;
    uint one = 10**18;
    uint public rewardReductionFactor;
    uint public timeForFullProtection;

    uint public curatedPoolLimit;
    uint public curatedPoolCount;
    mapping(address => bool) private _isCurated;
    
    address public VADER;
    address public USDV;
    address public POOLS;

    uint public anchorLimit;
    uint public insidePriceLimit;
    uint public outsidePriceLimit;
    address[] public arrayAnchors;
    uint[] public arrayPrices;

    uint public repayDelay = 3600;

    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;
    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;
    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;

    mapping(address => CollateralDetails) private mapMember_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; 
    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;

    struct CollateralDetails {
        uint ID;
        mapping(address => DebtDetails) mapCollateral_Debt;
    }
    struct DebtDetails{
        uint ID;
        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt
        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol
        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol
        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time
        // mapping(address =>uint) currentDay; // assetC > AssetD > time
    }

    event PoolReward(address indexed base, address indexed token, uint amount);
    event Protection(address indexed member, uint amount);
    event Curated(address indexed curator, address indexed token);

    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);
    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {}
    // Init
    function init(address _vader, address _usdv, address _pool) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        POOLS = _pool;
        rewardReductionFactor = 1;
        timeForFullProtection = 1;//8640000; //100 days
        curatedPoolLimit = 1;
        anchorLimit = 5;
        insidePriceLimit = 200;
        outsidePriceLimit = 500;
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {
        rewardReductionFactor = newFactor;
        timeForFullProtection = newTime;
        curatedPoolLimit = newLimit;
    }
    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {
        anchorLimit = newLimit;
        insidePriceLimit = newInside;
        outsidePriceLimit = newOutside;
    }

    //====================================LIQUIDITY=========================================//

    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){
        uint _actualInputBase = moveTokenToPools(base, inputBase);
        uint _actualInputToken = moveTokenToPools(token, inputToken);
        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); 
        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {
        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);
        uint _protection = getILProtection(msg.sender, base, token, basisPoints);
        removeDepositData(msg.sender, token, basisPoints, _protection); 
        iERC20(base).transfer(msg.sender, _protection);
    }

      //=======================================SWAP===========================================//
    
    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);
    }
    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);
    }

    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);
    }

    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {
        address _member = msg.sender;
        if(!inSynth){
            moveTokenToPools(inputToken, inputAmount);
        } else {
            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);
        }
        address _base;
        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {
            _base = VADER;
        } else {
            _base = USDV;
        }
        if (isBase(outputToken)) {
            // Token||Synth -> BASE
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);
            } else {
                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);
            }
        } else if (isBase(inputToken)) {
            // BASE -> Token||Synth
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        } else if (!isBase(inputToken) && !isBase(outputToken)) {
            // Token||Synth -> Token||Synth
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);
            } else {
                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);
            }
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        }
        _handlePoolReward(_base, inputToken);
        _handlePoolReward(_base, outputToken);
        _handleAnchorPriceUpdate(inputToken);
        _handleAnchorPriceUpdate(outputToken); 
    }

    //====================================INCENTIVES========================================//

    function _handlePoolReward(address _base, address _token) internal{
        if(!isBase(_token)){                        // USDV or VADER is never a pool
            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);
            iERC20(_base).transfer(POOLS, _reward);
            iPOOLS(POOLS).sync(_base, _token);
            emit PoolReward(_base, _token, _reward);
        }
    }

    //=================================IMPERMANENT LOSS=====================================//
    
    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {
        mapMemberToken_depositBase[member][token] += amountBase;
        mapMemberToken_depositToken[member][token] += amountToken;
        mapMemberToken_lastDeposited[member][token] = block.timestamp;
    }
    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {
        mapMemberToken_depositBase[member][token] += protection;
        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);
        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);
        mapMemberToken_depositBase[member][token] -= _baseToRemove;
        mapMemberToken_depositToken[member][token] -= _tokenToRemove;
    }

    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {
        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);
        if(base == VADER){
            if(protection >= reserveVADER()){
                protection = reserveVADER(); // In case reserve is running out
            }
        } else {
            if(protection >= reserveUSDV()){
                protection = reserveUSDV(); // In case reserve is running out
            }
        }
    }
    
    //=====================================CURATION==========================================//

    function curatePool(address token) external {
        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));
        if(!isCurated(token)){
            if(curatedPoolCount < curatedPoolLimit){ // Limit
                _isCurated[token] = true;
                curatedPoolCount += 1;
            }
        }
        emit Curated(msg.sender, token);
    }
    function replacePool(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAsset(newToken));
        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper
            _isCurated[oldToken] = false;
            _isCurated[newToken] = true;
            emit Curated(msg.sender, newToken);
        }
    }

    //=====================================ANCHORS==========================================//

    function listAnchor(address token) external {
        require(arrayAnchors.length < anchorLimit); // Limit
        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor
        arrayAnchors.push(token);                   // Add
        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));
        _isCurated[token] = true; 
        updateAnchorPrice(token);
    }

    function replaceAnchor(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAnchor(newToken), ""Not anchor"");
        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), ""Not deeper"");
        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%
        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%
        _isCurated[oldToken] = false; 
        _isCurated[newToken] = true; 
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == oldToken){
                arrayAnchors[i] = newToken;
            }
        }
        updateAnchorPrice(newToken);
    }

    // Anyone to update prices
    function updateAnchorPrice(address token) public {
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == token){
                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);
            }
        }
    }

    function _handleAnchorPriceUpdate(address _token) internal{
        if(iPOOLS(POOLS).isAnchor(_token)){
            updateAnchorPrice(_token);
        }
    }

    // Price of 1 VADER in USD
    function getAnchorPrice() public view returns (uint anchorPrice) {
        if(arrayPrices.length > 0){
            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage
            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle
        } else {
            anchorPrice = one;          // Edge case for first USDV mint
        }
    }

    // The correct amount of Vader for an input of USDV
    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){
        uint _price = getAnchorPrice();
        return (_price * USDVAmount) / one;
    }

    // The correct amount of USDV for an input of VADER
    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){
        uint _price = getAnchorPrice();
        return (vaderAmount * one) / _price;
    }
    
    
    //======================================LENDING=========================================//

    // Draw debt for self
    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {
        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);
    }

    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {
        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);
        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral 
        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral 
        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt
        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools
            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools
            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member
        }
        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event
        payInterest(collateralAsset, debtAsset);
        return _debtIssued;
    }

    // Repay for self
    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){
        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);
    }
     // Repay for member
    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){
        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));
        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here
        }
        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral 
        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt 
        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;
        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove
        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);
        _handleTransferOut(member, collateralAsset, _collateralUnlocked);
        payInterest(collateralAsset, debtAsset);
        return _collateralUnlocked;
    }

    // Called once a day to pay interest
    function payInterest(address collateralAsset, address debtAsset) internal {
        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era
            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];
            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);
            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;
            _removeCollateral(_interestOwed, collateralAsset, debtAsset);
            if(isBase(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).sync(collateralAsset, debtAsset);
            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());
            }
        }
    }

    function checkLiquidate() public {
        // get member remaining Collateral: originalDeposit - shareOfInterestPayments
        // if remainingCollateral <= 101% * debtValueInCollateral
        // purge, send remaining collateral to liquidator
    }

    // function purgeMember() public {

    // }

    // Get Collateral
    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds
        }else if(isPool(_collateralAsset)){
             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol
             _inputAmount = _amount;
        }
    }
    // Send Collateral
    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _sendFunds(_collateralAsset, _member, _amount); // Send Base
        }else if(isPool(_collateralAsset)){
            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member
        }
    }

    function _getFunds(address _token, uint _amount) internal returns(uint) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(tx.origin==msg.sender){
            require(iERC20(_token).transferTo(address(this), _amount));
        }else{
            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));
        }
        return iERC20(_token).balanceOf(address(this)) - _balance;
    }

    function _sendFunds(address _token, address _member, uint _amount) internal {
        require(iERC20(_token).transfer(_member, _amount));
    }

    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;
    }
    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;
    }
    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {
        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral 
    }



    //======================================HELPERS=========================================//

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }

    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this));
    }
    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this));
    }

    // Optionality
    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {
        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){
            safeAmount = _amount;
            if(tx.origin==msg.sender){
                iERC20(_token).transferTo(POOLS, _amount);
            }else{
                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            }
        } else {
            uint _startBal = iERC20(_token).balanceOf(POOLS);
            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;
        }
    }

    

    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function isCurated(address token) public view returns(bool curated) {
        if(_isCurated[token]){
            curated = true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    function getMemberBaseDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositBase[member][token];
    }
    function getMemberTokenDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositToken[member][token];
    }
    function getMemberLastDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_lastDeposited[member][token];
    }
    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];
    }
    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];
    }
    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];
    }
    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Debt[collateralAsset][debtAsset];
    }
    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];
    }
    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];
    }
}",5851,511,"[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol
Incorrect initialization of timeForFullProtection to 1 sec instead of 8640000 secs (100 days) as indicated in code comments, appears to be a test setting mistakenly carried over for deployment. Therefore, unless timeForFullProtection is reset to 100 days by setParams() (calling this function is a missing functionality in the DAO currently), the Impermanent Loss (IL) protection ""rule"" of 100 days will not apply in Utils.getProtection().
This breaks a key value proposition of the Vader protocol which is IL protection as indicated in the specification:
“Impermanent Loss Protection: The deposit value for each member is recorded when they deposit. When they go to withdraw, the redemption value is computed. If it is less than the deposit value, the member is paid the deficit from the reserve. The protection issued increases from 0 to 100% linearly for 100 days.”
Recommend changing to “timeForFullProtection = 8640000; //100 days”  on L84
 [H-10] Anyone can list anchors / curate tokens
The Router.listAnchor function can be called by anyone and tokens can be added. The only check is that require(iPOOLS(POOLS).isAnchor(token)); but this can easily be set by calling Pools.addLiquidity(VADER, token, _) once even without actually sending any tokens to the contract. This makes it an essentially useless check. 
This only works initially as long as the anchorLimit has not been reached yet. However, the replaceAnchor can be used in the same way and flash loans can be used to get around the liquidity restrictions and push another anchor token out of the price range as these checks use the current reserves. 
Anchored pools are automatically curated pools and determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.  [H-15] Wrong slippage protection on Token -> Token trades
The Router.swapWithSynthsWithLimit allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:
token to base
base to token
require(iUTILS(UTILS()).calcSwapSlip(
    inputAmount, // should use outToken here from prev trade
    iPOOLS(POOLS).getBaseAmount(outputToken)
  ) <= slipLimit
)  [H-23] Anyone can curate pools and steal rewards
The Router.curatePool and replacePool don't have any access restriction. An attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools.
 [M-03] Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol
There is no input validation in replacePool() function to check if oldToken exists and is curated. Using a non-existing oldToken (even 0 address) passes the check on L236 (because Pools.getBaseAmount() will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the curatedPoolLimit enforced only in curatePool() function.  [M-11] Allowing duplicated anchors could cause bias on anchor price.
In Router.sol, the setup of the five anchors can be interrupted by anyone adding a new anchor due to the lack of access control of the listAnchor function. Also, duplicate anchors are allowed. If the same anchor is added three times, then this anchor biases the result of getAnchorPrice. Referenced code: Router.sol#L245-L252  [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()",7,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Router {

    
    bool private inited;
    uint one = 10**18;
    uint public rewardReductionFactor;
    uint public timeForFullProtection;

    uint public curatedPoolLimit;
    uint public curatedPoolCount;
    mapping(address => bool) private _isCurated;
    
    address public VADER;
    address public USDV;
    address public POOLS;

    uint public anchorLimit;
    uint public insidePriceLimit;
    uint public outsidePriceLimit;
    address[] public arrayAnchors;
    uint[] public arrayPrices;

    uint public repayDelay = 3600;

    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;
    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;
    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;

    mapping(address => CollateralDetails) private mapMember_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; 
    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;

    struct CollateralDetails {
        uint ID;
        mapping(address => DebtDetails) mapCollateral_Debt;
    }
    struct DebtDetails{
        uint ID;
        mapping(address =>uint) debt; 
        mapping(address =>uint) collateral; 
        
        
        
    }

    event PoolReward(address indexed base, address indexed token, uint amount);
    event Protection(address indexed member, uint amount);
    event Curated(address indexed curator, address indexed token);

    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);
    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    
    
    constructor() {}
    
    function init(address _vader, address _usdv, address _pool) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        POOLS = _pool;
        rewardReductionFactor = 1;
        timeForFullProtection = 1;
        curatedPoolLimit = 1;
        anchorLimit = 5;
        insidePriceLimit = 200;
        outsidePriceLimit = 500;
    }

    
    
    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {
        rewardReductionFactor = newFactor;
        timeForFullProtection = newTime;
        curatedPoolLimit = newLimit;
    }
    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {
        anchorLimit = newLimit;
        insidePriceLimit = newInside;
        outsidePriceLimit = newOutside;
    }

    

    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){
        uint _actualInputBase = moveTokenToPools(base, inputBase);
        uint _actualInputToken = moveTokenToPools(token, inputToken);
        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); 
        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {
        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);
        uint _protection = getILProtection(msg.sender, base, token, basisPoints);
        removeDepositData(msg.sender, token, basisPoints, _protection); 
        iERC20(base).transfer(msg.sender, _protection);
    }

      
    
    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);
    }
    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);
    }

    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);
    }

    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {
        address _member = msg.sender;
        if(!inSynth){
            moveTokenToPools(inputToken, inputAmount);
        } else {
            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);
        }
        address _base;
        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {
            _base = VADER;
        } else {
            _base = USDV;
        }
        if (isBase(outputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);
            } else {
                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);
            }
        } else if (isBase(inputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        } else if (!isBase(inputToken) && !isBase(outputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);
            } else {
                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);
            }
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        }
        _handlePoolReward(_base, inputToken);
        _handlePoolReward(_base, outputToken);
        _handleAnchorPriceUpdate(inputToken);
        _handleAnchorPriceUpdate(outputToken); 
    }

    

    function _handlePoolReward(address _base, address _token) internal{
        if(!isBase(_token)){                        
            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);
            iERC20(_base).transfer(POOLS, _reward);
            iPOOLS(POOLS).sync(_base, _token);
            emit PoolReward(_base, _token, _reward);
        }
    }

    
    
    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {
        mapMemberToken_depositBase[member][token] += amountBase;
        mapMemberToken_depositToken[member][token] += amountToken;
        mapMemberToken_lastDeposited[member][token] = block.timestamp;
    }
    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {
        mapMemberToken_depositBase[member][token] += protection;
        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);
        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);
        mapMemberToken_depositBase[member][token] -= _baseToRemove;
        mapMemberToken_depositToken[member][token] -= _tokenToRemove;
    }

    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {
        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);
        if(base == VADER){
            if(protection >= reserveVADER()){
                protection = reserveVADER(); 
            }
        } else {
            if(protection >= reserveUSDV()){
                protection = reserveUSDV(); 
            }
        }
    }
    
    

    function curatePool(address token) external {
        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));
        if(!isCurated(token)){
            if(curatedPoolCount < curatedPoolLimit){ 
                _isCurated[token] = true;
                curatedPoolCount += 1;
            }
        }
        emit Curated(msg.sender, token);
    }
    function replacePool(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAsset(newToken));
        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ 
            _isCurated[oldToken] = false;
            _isCurated[newToken] = true;
            emit Curated(msg.sender, newToken);
        }
    }

    

    function listAnchor(address token) external {
        require(arrayAnchors.length < anchorLimit); 
        require(iPOOLS(POOLS).isAnchor(token));     
        arrayAnchors.push(token);                   
        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));
        _isCurated[token] = true; 
        updateAnchorPrice(token);
    }

    function replaceAnchor(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAnchor(newToken), ""Not anchor"");
        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), ""Not deeper"");
        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             
        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               
        _isCurated[oldToken] = false; 
        _isCurated[newToken] = true; 
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == oldToken){
                arrayAnchors[i] = newToken;
            }
        }
        updateAnchorPrice(newToken);
    }

    
    function updateAnchorPrice(address token) public {
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == token){
                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);
            }
        }
    }

    function _handleAnchorPriceUpdate(address _token) internal{
        if(iPOOLS(POOLS).isAnchor(_token)){
            updateAnchorPrice(_token);
        }
    }

    
    function getAnchorPrice() public view returns (uint anchorPrice) {
        if(arrayPrices.length > 0){
            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  
            anchorPrice = _sortedAnchorFeed[2];                         
        } else {
            anchorPrice = one;          
        }
    }

    
    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){
        uint _price = getAnchorPrice();
        return (_price * USDVAmount) / one;
    }

    
    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){
        uint _price = getAnchorPrice();
        return (vaderAmount * one) / _price;
    }
    
    
    

    
    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {
        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);
    }

    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {
        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);
        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  
        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               
        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            
        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  
            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  
            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         
        }
        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               
        payInterest(collateralAsset, debtAsset);
        return _debtIssued;
    }

    
    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){
        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);
    }
     
    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){
        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));
        uint _debt = moveTokenToPools(debtAsset, _amount);    
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           
        }
        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); 
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               
        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   
        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;
        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  
        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);
        _handleTransferOut(member, collateralAsset, _collateralUnlocked);
        payInterest(collateralAsset, debtAsset);
        return _collateralUnlocked;
    }

    
    function payInterest(address collateralAsset, address debtAsset) internal {
        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              
            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];
            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);
            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;
            _removeCollateral(_interestOwed, collateralAsset, debtAsset);
            if(isBase(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).sync(collateralAsset, debtAsset);
            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());
            }
        }
    }

    function checkLiquidate() public {
        
        
        
    }

    

    

    
    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _inputAmount = _getFunds(_collateralAsset, _amount); 
        }else if(isPool(_collateralAsset)){
             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); 
             _inputAmount = _amount;
        }
    }
    
    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _sendFunds(_collateralAsset, _member, _amount); 
        }else if(isPool(_collateralAsset)){
            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); 
        }
    }

    function _getFunds(address _token, uint _amount) internal returns(uint) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(tx.origin==msg.sender){
            require(iERC20(_token).transferTo(address(this), _amount));
        }else{
            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));
        }
        return iERC20(_token).balanceOf(address(this)) - _balance;
    }

    function _sendFunds(address _token, address _member, uint _amount) internal {
        require(iERC20(_token).transfer(_member, _amount));
    }

    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;
    }
    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;
    }
    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {
        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               
    }



    

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }

    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this));
    }
    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this));
    }

    
    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {
        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){
            safeAmount = _amount;
            if(tx.origin==msg.sender){
                iERC20(_token).transferTo(POOLS, _amount);
            }else{
                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            }
        } else {
            uint _startBal = iERC20(_token).balanceOf(POOLS);
            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;
        }
    }

    

    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function isCurated(address token) public view returns(bool curated) {
        if(_isCurated[token]){
            curated = true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    function getMemberBaseDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositBase[member][token];
    }
    function getMemberTokenDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositToken[member][token];
    }
    function getMemberLastDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_lastDeposited[member][token];
    }
    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];
    }
    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];
    }
    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];
    }
    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Debt[collateralAsset][debtAsset];
    }
    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];
    }
    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];
    }
}",5281,4,3,"{'Findings': [{'Issue': 'Reentrancy Vulnerability in `removeLiquidity` Function', 'Severity': 'High', 'Description': 'The `removeLiquidity` function transfers tokens to the user before updating the internal state, making it vulnerable to reentrancy attacks. This could allow a malicious user to repeatedly call the function and drain funds.', 'Impact': 'Potential loss of funds due to reentrancy attacks.', 'Location': 'Function `removeLiquidity` (mentioned in multiple reports)'}, {'Issue': 'Lack of Input Validation in `swapWithSynthsWithLimit` Function', 'Severity': 'Medium', 'Description': 'The `swapWithSynthsWithLimit` function does not validate input parameters such as `inputAmount` and `slipLimit`, nor does it check if input and output tokens are valid or distinct. This could lead to unexpected behavior or exploitation.', 'Impact': 'Potential loss of funds or unintended behavior due to invalid input parameters.', 'Location': 'Function `swapWithSynthsWithLimit` (mentioned in multiple reports)'}, {'Issue': 'Unrestricted Access to `setParams` and `setAnchorParams` Functions', 'Severity': 'Medium', 'Description': 'The `setParams` and `setAnchorParams` functions are only protected by the `onlyDAO` modifier, but there is no mechanism to ensure the DAO address is secure. If compromised, critical parameters could be altered.', 'Impact': 'Potential unauthorized changes to critical contract parameters.', 'Location': 'Functions `setParams` and `setAnchorParams` (mentioned in multiple reports)'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': 'Multiple functions (`getVADERAmount`, `getUSDVAmount`, `_getFunds`, `addLiquidity`, `removeLiquidity`, `borrow`) perform arithmetic operations without explicit overflow/underflow checks, which could lead to incorrect calculations.', 'Impact': 'Incorrect calculations leading to potential loss of funds or unintended behavior.', 'Location': 'Functions `getVADERAmount`, `getUSDVAmount`, `_getFunds`, `addLiquidity`, `removeLiquidity`, `borrow` (mentioned in multiple reports)'}, {'Issue': 'Uninitialized Contract State or `inited` Variable', 'Severity': 'Medium', 'Description': 'The contract relies on an `init` function to set critical state variables, but it does not enforce initialization before use. The `inited` variable is also uninitialized, leading to potential misuse before proper setup.', 'Impact': 'Unpredictable behavior or exploitation if the contract is used before initialization.', 'Location': 'Function `init` and variable `inited` (mentioned in multiple reports)'}, {'Issue': 'Lack of Input Validation in `borrowForMember` Function', 'Severity': 'Medium', 'Description': 'The `borrowForMember` function does not validate the `amount` parameter or sufficiently check collateral adequacy, which could lead to undercollateralized loans or unexpected behavior.', 'Impact': 'Potential risk of undercollateralized loans or exploitation due to invalid inputs.', 'Location': 'Function `borrowForMember` (mentioned in multiple reports)'}, {'Issue': 'Lack of Access Control in `curatePool` and `replacePool` Functions', 'Severity': 'Low', 'Description': 'The `curatePool` and `replacePool` functions lack access control, allowing any user to manipulate the curated pool list, which could lead to misuse or spamming.', 'Impact': 'Potential manipulation of the curated pool list, leading to unfair advantages or exploitation.', 'Location': 'Functions `curatePool` and `replacePool` (mentioned in multiple reports)'}, {'Issue': 'Inconsistent State Updates in `payInterest` Function', 'Severity': 'Low', 'Description': 'The `payInterest` function updates the `mapCollateralAsset_NextEra` state variable before calculating interest, which could lead to inconsistencies if called multiple times in a short period.', 'Impact': 'Potential incorrect interest calculations and state inconsistencies.', 'Location': 'Function `payInterest` (mentioned in multiple reports)'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Critical functions such as `addLiquidity`, `removeLiquidity`, `swap`, `payInterest`, and `_handleTransferOut` do not emit events, reducing transparency and auditability.', 'Impact': 'Reduced ability to track and audit contract operations.', 'Location': 'Functions `addLiquidity`, `removeLiquidity`, `swap`, `payInterest`, `_handleTransferOut` (mentioned in multiple reports)'}, {'Issue': 'Incomplete Implementation of `checkLiquidate` Function', 'Severity': 'Low', 'Description': 'The `checkLiquidate` function is empty, missing logic to liquidate undercollateralized positions, which could lead to financial instability.', 'Impact': 'Potential accumulation of undercollateralized positions.', 'Location': 'Function `checkLiquidate` (mentioned in multiple reports)'}], 'IssueNumber': 24, 'OutputList': 10}",,"{'ReviewingTheCode': ""The provided Solidity code is a complex smart contract named 'Router' that interacts with multiple external contracts and interfaces to manage liquidity, swaps, collateral, and debt. It includes mechanisms for adding and removing liquidity, swapping tokens, handling collateral and debt, and managing curated pools and anchors. The contract also includes event logging and various utility functions."", 'IdentifyingKeyComponents': {'ContractName': 'Router', 'Purpose': 'To manage liquidity, swaps, collateral, and debt in a decentralized finance (DeFi) system, interacting with pools, anchors, and other DeFi components.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['./interfaces/iERC20.sol', './interfaces/iUTILS.sol', './interfaces/iVADER.sol', './interfaces/iPOOLS.sol', './interfaces/iSYNTH.sol', 'hardhat/console.sol']}, 'StateVariables': [{'Name': 'inited', 'Type': 'bool', 'Purpose': 'To ensure the contract is initialized only once.'}, {'Name': 'one', 'Type': 'uint', 'Purpose': 'A constant representing 10^18, used for precision in calculations.'}, {'Name': 'rewardReductionFactor', 'Type': 'uint', 'Purpose': 'Factor to reduce rewards in the system.'}, {'Name': 'timeForFullProtection', 'Type': 'uint', 'Purpose': 'Time required for full protection against impermanent loss.'}, {'Name': 'curatedPoolLimit', 'Type': 'uint', 'Purpose': 'Maximum number of curated pools allowed.'}, {'Name': 'curatedPoolCount', 'Type': 'uint', 'Purpose': 'Current count of curated pools.'}, {'Name': '_isCurated', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping to track if a token is curated.'}, {'Name': 'VADER', 'Type': 'address', 'Purpose': 'Address of the VADER token contract.'}, {'Name': 'USDV', 'Type': 'address', 'Purpose': 'Address of the USDV token contract.'}, {'Name': 'POOLS', 'Type': 'address', 'Purpose': 'Address of the POOLS contract.'}, {'Name': 'anchorLimit', 'Type': 'uint', 'Purpose': 'Maximum number of anchors allowed.'}, {'Name': 'insidePriceLimit', 'Type': 'uint', 'Purpose': 'Price limit for inside anchors.'}, {'Name': 'outsidePriceLimit', 'Type': 'uint', 'Purpose': 'Price limit for outside anchors.'}, {'Name': 'arrayAnchors', 'Type': 'address[]', 'Purpose': 'Array of anchor tokens.'}, {'Name': 'arrayPrices', 'Type': 'uint[]', 'Purpose': 'Array of anchor prices.'}, {'Name': 'repayDelay', 'Type': 'uint', 'Purpose': 'Delay for repay operations.'}, {'Name': 'mapMemberToken_depositBase', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping to track base deposits by members for specific tokens.'}, {'Name': 'mapMemberToken_depositToken', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping to track token deposits by members for specific tokens.'}, {'Name': 'mapMemberToken_lastDeposited', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping to track the last deposit time by members for specific tokens.'}, {'Name': 'mapMember_Collateral', 'Type': 'mapping(address => CollateralDetails)', 'Purpose': 'Mapping to track collateral details by members.'}, {'Name': 'mapCollateralDebt_Collateral', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping to track collateral in the system for specific collateral and debt assets.'}, {'Name': 'mapCollateralDebt_Debt', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping to track debt in the system for specific collateral and debt assets.'}, {'Name': 'mapCollateralDebt_interestPaid', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping to track interest paid in the system for specific collateral and debt assets.'}, {'Name': 'mapCollateralAsset_NextEra', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping to track the next era time for specific collateral and debt assets.'}], 'FunctionsAndModifiers': [{'Name': 'init', 'Visibility': 'public', 'Purpose': 'Initialize the contract with VADER, USDV, and POOLS addresses.', 'Parameters': ['address _vader', 'address _usdv', 'address _pool'], 'Returns': []}, {'Name': 'setParams', 'Visibility': 'external', 'Purpose': 'Set parameters for reward reduction factor, time for full protection, and curated pool limit.', 'Parameters': ['uint newFactor', 'uint newTime', 'uint newLimit'], 'Returns': []}, {'Name': 'setAnchorParams', 'Visibility': 'external', 'Purpose': 'Set parameters for anchor limit, inside price limit, and outside price limit.', 'Parameters': ['uint newLimit', 'uint newInside', 'uint newOutside'], 'Returns': []}, {'Name': 'addLiquidity', 'Visibility': 'external', 'Purpose': 'Add liquidity to a pool with specified base and token amounts.', 'Parameters': ['address base', 'uint inputBase', 'address token', 'uint inputToken'], 'Returns': ['uint']}, {'Name': 'removeLiquidity', 'Visibility': 'external', 'Purpose': 'Remove liquidity from a pool and handle impermanent loss protection.', 'Parameters': ['address base', 'address token', 'uint basisPoints'], 'Returns': ['uint amountBase', 'uint amountToken']}, {'Name': 'swap', 'Visibility': 'external', 'Purpose': 'Swap tokens with a default slip limit.', 'Parameters': ['uint inputAmount', 'address inputToken', 'address outputToken'], 'Returns': ['uint outputAmount']}, {'Name': 'swapWithLimit', 'Visibility': 'external', 'Purpose': 'Swap tokens with a specified slip limit.', 'Parameters': ['uint inputAmount', 'address inputToken', 'address outputToken', 'uint slipLimit'], 'Returns': ['uint outputAmount']}, {'Name': 'swapWithSynths', 'Visibility': 'external', 'Purpose': 'Swap tokens with synthetic assets and a default slip limit.', 'Parameters': ['uint inputAmount', 'address inputToken', 'bool inSynth', 'address outputToken', 'bool outSynth'], 'Returns': ['uint outputAmount']}, {'Name': 'swapWithSynthsWithLimit', 'Visibility': 'public', 'Purpose': 'Swap tokens with synthetic assets and a specified slip limit.', 'Parameters': ['uint inputAmount', 'address inputToken', 'bool inSynth', 'address outputToken', 'bool outSynth', 'uint slipLimit'], 'Returns': ['uint outputAmount']}, {'Name': '_handlePoolReward', 'Visibility': 'internal', 'Purpose': 'Handle pool rewards based on the token and base.', 'Parameters': ['address _base', 'address _token'], 'Returns': []}, {'Name': 'addDepositData', 'Visibility': 'internal', 'Purpose': 'Add deposit data for a member and token.', 'Parameters': ['address member', 'address token', 'uint amountBase', 'uint amountToken'], 'Returns': []}, {'Name': 'removeDepositData', 'Visibility': 'internal', 'Purpose': 'Remove deposit data for a member and token.', 'Parameters': ['address member', 'address token', 'uint basisPoints', 'uint protection'], 'Returns': []}, {'Name': 'getILProtection', 'Visibility': 'public', 'Purpose': 'Get impermanent loss protection for a member.', 'Parameters': ['address member', 'address base', 'address token', 'uint basisPoints'], 'Returns': ['uint protection']}, {'Name': 'curatePool', 'Visibility': 'external', 'Purpose': 'Curate a pool with a specified token.', 'Parameters': ['address token'], 'Returns': []}, {'Name': 'replacePool', 'Visibility': 'external', 'Purpose': 'Replace an old token with a new token in the curated pool.', 'Parameters': ['address oldToken', 'address newToken'], 'Returns': []}, {'Name': 'listAnchor', 'Visibility': 'external', 'Purpose': 'List an anchor token.', 'Parameters': ['address token'], 'Returns': []}, {'Name': 'replaceAnchor', 'Visibility': 'external', 'Purpose': 'Replace an old anchor token with a new anchor token.', 'Parameters': ['address oldToken', 'address newToken'], 'Returns': []}, {'Name': 'updateAnchorPrice', 'Visibility': 'public', 'Purpose': 'Update the price of an anchor token.', 'Parameters': ['address token'], 'Returns': []}, {'Name': '_handleAnchorPriceUpdate', 'Visibility': 'internal', 'Purpose': 'Handle anchor price updates.', 'Parameters': ['address _token'], 'Returns': []}, {'Name': 'getAnchorPrice', 'Visibility': 'public', 'Purpose': 'Get the current anchor price.', 'Parameters': [], 'Returns': ['uint anchorPrice']}, {'Name': 'getVADERAmount', 'Visibility': 'public', 'Purpose': 'Get the equivalent VADER amount for a given USDV amount.', 'Parameters': ['uint USDVAmount'], 'Returns': ['uint vaderAmount']}, {'Name': 'getUSDVAmount', 'Visibility': 'public', 'Purpose': 'Get the equivalent USDV amount for a given VADER amount.', 'Parameters': ['uint vaderAmount'], 'Returns': ['uint USDVAmount']}, {'Name': 'borrow', 'Visibility': 'public', 'Purpose': 'Borrow tokens using collateral.', 'Parameters': ['uint amount', 'address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'borrowForMember', 'Visibility': 'public', 'Purpose': 'Borrow tokens for a specified member using collateral.', 'Parameters': ['address member', 'uint amount', 'address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'repay', 'Visibility': 'public', 'Purpose': 'Repay debt using collateral.', 'Parameters': ['uint amount', 'address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'repayForMember', 'Visibility': 'public', 'Purpose': 'Repay debt for a specified member using collateral.', 'Parameters': ['address member', 'uint basisPoints', 'address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'payInterest', 'Visibility': 'internal', 'Purpose': 'Pay interest on debt.', 'Parameters': ['address collateralAsset', 'address debtAsset'], 'Returns': []}, {'Name': 'checkLiquidate', 'Visibility': 'public', 'Purpose': 'Check if liquidation is needed.', 'Parameters': [], 'Returns': []}, {'Name': '_handleTransferIn', 'Visibility': 'internal', 'Purpose': 'Handle the transfer of collateral into the contract.', 'Parameters': ['address _member', 'address _collateralAsset', 'uint _amount'], 'Returns': ['uint _inputAmount']}, {'Name': '_handleTransferOut', 'Visibility': 'internal', 'Purpose': 'Handle the transfer of collateral out of the contract.', 'Parameters': ['address _member', 'address _collateralAsset', 'uint _amount'], 'Returns': []}, {'Name': '_getFunds', 'Visibility': 'internal', 'Purpose': 'Get funds from a token contract.', 'Parameters': ['address _token', 'uint _amount'], 'Returns': ['uint']}, {'Name': '_sendFunds', 'Visibility': 'internal', 'Purpose': 'Send funds to a specified address.', 'Parameters': ['address _token', 'address _member', 'uint _amount'], 'Returns': []}, {'Name': '_addDebtToMember', 'Visibility': 'internal', 'Purpose': ""Add debt to a member's collateral details."", 'Parameters': ['address _member', 'uint _collateral', 'address _collateralAsset', 'uint _debt', 'address _debtAsset'], 'Returns': []}, {'Name': '_removeDebtFromMember', 'Visibility': 'internal', 'Purpose': ""Remove debt from a member's collateral details."", 'Parameters': ['address _member', 'uint _collateral', 'address _collateralAsset', 'uint _debt', 'address _debtAsset'], 'Returns': []}, {'Name': '_removeCollateral', 'Visibility': 'internal', 'Purpose': 'Remove collateral from the system.', 'Parameters': ['uint _collateral', 'address _collateralAsset', 'address _debtAsset'], 'Returns': []}, {'Name': 'isBase', 'Visibility': 'public', 'Purpose': 'Check if a token is a base token (VADER or USDV).', 'Parameters': ['address token'], 'Returns': ['bool base']}, {'Name': 'reserveVADER', 'Visibility': 'public', 'Purpose': 'Get the VADER reserve balance.', 'Parameters': [], 'Returns': ['uint']}, {'Name': 'reserveUSDV', 'Visibility': 'public', 'Purpose': 'Get the USDV reserve balance.', 'Parameters': [], 'Returns': ['uint']}, {'Name': 'moveTokenToPools', 'Visibility': 'internal', 'Purpose': 'Move tokens to the POOLS contract.', 'Parameters': ['address _token', 'uint _amount'], 'Returns': ['uint safeAmount']}, {'Name': 'UTILS', 'Visibility': 'public', 'Purpose': 'Get the UTILS contract address.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'DAO', 'Visibility': 'public', 'Purpose': 'Get the DAO contract address.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'emitting', 'Visibility': 'public', 'Purpose': 'Check if the system is emitting rewards.', 'Parameters': [], 'Returns': ['bool']}, {'Name': 'isCurated', 'Visibility': 'public', 'Purpose': 'Check if a token is curated.', 'Parameters': ['address token'], 'Returns': ['bool curated']}, {'Name': 'isPool', 'Visibility': 'public', 'Purpose': 'Check if a token is a pool.', 'Parameters': ['address token'], 'Returns': ['bool pool']}, {'Name': 'getMemberBaseDeposit', 'Visibility': 'external', 'Purpose': 'Get the base deposit amount for a member and token.', 'Parameters': ['address member', 'address token'], 'Returns': ['uint']}, {'Name': 'getMemberTokenDeposit', 'Visibility': 'external', 'Purpose': 'Get the token deposit amount for a member and token.', 'Parameters': ['address member', 'address token'], 'Returns': ['uint']}, {'Name': 'getMemberLastDeposit', 'Visibility': 'external', 'Purpose': 'Get the last deposit time for a member and token.', 'Parameters': ['address member', 'address token'], 'Returns': ['uint']}, {'Name': 'getMemberCollateral', 'Visibility': 'external', 'Purpose': 'Get the collateral amount for a member, collateral asset, and debt asset.', 'Parameters': ['address member', 'address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'getMemberDebt', 'Visibility': 'public', 'Purpose': 'Get the debt amount for a member, collateral asset, and debt asset.', 'Parameters': ['address member', 'address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'getSystemCollateral', 'Visibility': 'public', 'Purpose': 'Get the system collateral amount for a collateral asset and debt asset.', 'Parameters': ['address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'getSystemDebt', 'Visibility': 'public', 'Purpose': 'Get the system debt amount for a collateral asset and debt asset.', 'Parameters': ['address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'getSystemInterestPaid', 'Visibility': 'public', 'Purpose': 'Get the system interest paid amount for a collateral asset and debt asset.', 'Parameters': ['address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}, {'Name': 'getNextEraTime', 'Visibility': 'public', 'Purpose': 'Get the next era time for a collateral asset and debt asset.', 'Parameters': ['address collateralAsset', 'address debtAsset'], 'Returns': ['uint']}]}, 'ExternalInteractions': ['iERC20', 'iUTILS', 'iVADER', 'iPOOLS', 'iSYNTH'], 'SpecialMechanisms': ['Impermanent Loss Protection', 'Curated Pools', 'Anchor Price Management', 'Collateral and Debt Management', 'Interest Payment Mechanism'], 'Questions': ['How is the impermanent loss protection calculated in detail?', 'What is the exact mechanism for updating anchor prices?', 'How are the rewards distributed among the pools?', 'What are the specific conditions for liquidation?', 'How is the interest rate determined and applied?']}",407.8775112628937,"### **Output**

---

**[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol**

**Report Description**:
The `timeForFullProtection` variable in `Router.sol` is incorrectly initialized to 1 second instead of 8640000 seconds (100 days), as indicated in the code comments. This appears to be a test setting mistakenly carried over for deployment. Unless `timeForFullProtection` is reset to 100 days by calling `setParams()` (which is currently missing in the DAO), the Impermanent Loss (IL) protection rule of 100 days will not apply in `Utils.getProtection()`. This breaks a key value proposition of the Vader protocol, which is IL protection as specified in the documentation.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect initialization of `timeForFullProtection` or the missing functionality in the DAO to reset it. This is a critical oversight as it directly impacts the core functionality of the protocol.

---

**[H-10] Anyone can list anchors / curate tokens**

**Report Description**:
The `Router.listAnchor` function can be called by anyone to add tokens as anchors. The only check is `require(iPOOLS(POOLS).isAnchor(token));`, which can be bypassed by calling `Pools.addLiquidity(VADER, token, _)` once without actually sending tokens. This makes the check essentially useless. Additionally, the `replaceAnchor` function can be exploited using flash loans to bypass liquidity restrictions and push out existing anchor tokens. Anchored pools are automatically curated and determine reward distribution, allowing attackers to manipulate rewards by removing them from existing pools and adding them to their own.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control in `curatePool` and `replacePool` Functions""**.

**Validation**:
**Partially Correct**. The response identifies the lack of access control in `curatePool` and `replacePool`, which is related to the issue. However, it does not address the specific vulnerabilities in `listAnchor` and `replaceAnchor`, nor does it mention the potential for reward manipulation using flash loans. The response is incomplete in addressing the full scope of the issue.

---

**[H-15] Wrong slippage protection on Token -> Token trades**

**Report Description**:
The `Router.swapWithSynthsWithLimit` function allows token-to-token trades with slippage protection. However, the slippage calculation is incorrect because it uses `inputAmount` instead of `outToken` from the previous trade. This could lead to incorrect slippage protection and potential loss of funds.

**Match in Response List**:
Matches with the issue titled **""Lack of Input Validation in `swapWithSynthsWithLimit` Function""**.

**Validation**:
**Partially Correct**. The response identifies the lack of input validation in `swapWithSynthsWithLimit`, which is related to the issue. However, it does not specifically address the incorrect slippage calculation or the potential loss of funds due to this oversight. The response is incomplete in addressing the full scope of the issue.

---

**[H-23] Anyone can curate pools and steal rewards**

**Report Description**:
The `Router.curatePool` and `replacePool` functions lack access control, allowing anyone to manipulate the curated pool list. An attacker can use a flash loan of base tokens to replace existing curated pools with their own, thereby stealing rewards.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control in `curatePool` and `replacePool` Functions""**.

**Validation**:
**Correct**. The response accurately identifies the lack of access control in `curatePool` and `replacePool`, which is the core issue. It correctly explains the risks associated with unrestricted access to these functions, aligning with the reported vulnerability.

---

**[M-03] Lack of input validation in `replacePool()` allows curated pool limit bypass in Router.sol**

**Report Description**:
The `replacePool()` function lacks input validation to check if `oldToken` exists and is curated. Using a non-existing `oldToken` (even the 0 address) bypasses the check on L236 (since `Pools.getBaseAmount()` returns 0 for non-existing tokens), allowing `newToken` to be curated. This can be used to bypass the `curatedPoolLimit` enforced only in `curatePool()`.

**Match in Response List**:
Matches with the issue titled **""Lack of Input Validation in `borrowForMember` Function""**.

**Validation**:
**Incorrect**. The response does not address the specific issue of input validation in `replacePool()` or the bypass of the `curatedPoolLimit`. The response is unrelated to the reported vulnerability.

---

**[M-11] Allowing duplicated anchors could cause bias on anchor price.**

**Report Description**:
The `Router.listAnchor` function lacks access control, allowing anyone to add new anchors, including duplicates. If the same anchor is added multiple times, it biases the result of `getAnchorPrice`. This could lead to incorrect price calculations and potential exploitation.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of duplicated anchors or the potential bias in `getAnchorPrice`. This is a significant oversight as it could lead to incorrect price calculations and exploitation.

---

**[M-13] Init function can be called by everyone**

**Report Description**:
The `init` function in most Solidity contracts can be called by anyone, allowing unauthorized users to initialize or reinitialize critical state variables. This could lead to unpredictable behavior or exploitation if the contract is used before proper setup.

**Match in Response List**:
Matches with the issue titled **""Uninitialized Contract State or `inited` Variable""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `init` function and the uninitialized `inited` variable. It correctly explains the risks associated with unauthorized initialization, aligning with the reported vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-23] Anyone can curate pools and steal rewards**
- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- **[H-10] Anyone can list anchors / curate tokens**
- **[H-15] Wrong slippage protection on Token -> Token trades**

**Missed Issues from Issue Report**:

- **[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol**
- **[M-03] Lack of input validation in `replacePool()` allows curated pool limit bypass in Router.sol**
- **[M-11] Allowing duplicated anchors could cause bias on anchor price.**

---","```
1. Lack of Access Control in `curatePool` and `replacePool` Functions
2. Uninitialized Contract State or `inited` Variable
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **True Positive 1**: ""Lack of Access Control in `curatePool` and `replacePool` Functions"" appears at rank 7.
   - **True Positive 2**: ""Uninitialized Contract State or `inited` Variable"" appears at rank 5.

2. **Calculate the precision at each rank**:
   - **Precision at rank 5 (P@5)**: Number of true positives up to rank 5 is 1 (only ""Uninitialized Contract State or `inited` Variable""). So, \( P@5 = \frac{1}{5} = 0.2 \).
   - **Precision at rank 7 (P@7)**: Number of true positives up to rank 7 is 2 (both true positives). So, \( P@7 = \frac{2}{7} \approx 0.2857 \).

3. **Average the precision values**:
   - \( AP = \frac{P@5 + P@7}{2} = \frac{0.2 + 0.2857}{2} \approx 0.24285 \).

**Output**:
```
0.24285
```"
Vault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.3;

import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

contract Vault {

    bool private inited;
    uint public erasToEarn;
    uint public minGrantTime;
    uint public lastGranted;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    uint public minimumDepositTime;
    uint public totalWeight;

    mapping(address => uint) private mapMember_weight;
    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;
    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;

    // Events
    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    constructor(){}

    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {
        require(inited == false);
        inited = true;
        POOLS = _pool;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
        POOLS = _pool;
        erasToEarn = 100;
        minimumDepositTime = 1;
        minGrantTime = 2592000;     // 30 days
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {
        erasToEarn = newEra;
        minimumDepositTime = newDepositTime;
        minGrantTime = newGrantTime;
    }

    // Can issue grants
    function grant(address recipient, uint amount) public onlyDAO {
        require((block.timestamp - lastGranted) >= minGrantTime, ""not too fast"");
        lastGranted = block.timestamp;
        iERC20(USDV).transfer(recipient, amount); 
    }

    //======================================DEPOSITS========================================//

    // Deposit USDV or SYNTHS
    function deposit(address synth, uint amount) external {
        depositForMember(synth, msg.sender, amount);
    }
    // Wrapper for contracts
    function depositForMember(address synth, address member, uint amount) public {
        require((iFACTORY(FACTORY).isSynth(synth)), ""Not Synth""); // Only Synths
        getFunds(synth, amount);
        _deposit(synth, member, amount);
    }
    function _deposit(address _synth, address _member, uint _amount) internal {
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         // Time of deposit
        mapMemberSynth_deposit[_member][_synth] += _amount;                 // Record deposit
        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);
        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){
            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               // Price in USDV
        }
        mapMember_weight[_member] += _weight;                               // Total member weight 
        totalWeight += _weight;                                             // Total weight 
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    //====================================== HARVEST ========================================//

    // Harvest, get payment, allocate, increase weight
    function harvest(address synth) external returns(uint reward) {
        address _member = msg.sender;
        uint _weight;
        address _token = iSYNTH(synth).TOKEN();
        reward = calcCurrentReward(synth, _member);                     // In USDV
        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      // Reset time
        if(iPOOLS(POOLS).isAsset(_token)){
            iERC20(USDV).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));
            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);
        } else {
            iERC20(VADER).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));
            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));
        }
        mapMemberSynth_deposit[_member][synth] += reward; 
        mapMember_weight[_member] += _weight;
        totalWeight += _weight;
        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);
    }

    // Get the payment owed for a member
    function calcCurrentReward(address synth, address member) public view returns(uint reward) {
        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        // Get time since last claim
        uint _share = calcReward(synth, member);                                               // Get share of rewards for member
        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         // Get owed amount, based on per-day rates
        uint _reserve;
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            _reserve = reserveUSDV();
        } else {
            _reserve = reserveVADER();
        }
        if(reward >= _reserve) {
            reward = _reserve;                                                          // Send full reserve if the last
        }
    }

    function calcReward(address synth, address member) public view returns(uint reward) {
        uint _weight = mapMember_weight[member];  
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      // Aggregrate reserves
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   // Get member's share of that
        } else{
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          
        }
    }

    //====================================== WITHDRAW ========================================//

    // Members to withdraw
    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          // Get amount to withdraw
        sendFunds(synth, msg.sender, redeemedAmount);
    }
    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {
        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, ""DepositTime"");    // stops attacks
        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Share of deposits
        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  // Reduce for member                             
        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   // Find recorded weight to reduce
        mapMember_weight[_member] -= _weight;                                   // Reduce for member 
        totalWeight -= _weight;                                                 // Reduce for total
        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   // Event
    }

    //============================== ASSETS ================================//

    function getFunds(address synth, uint amount) internal {
        if(tx.origin==msg.sender){
            require(iERC20(synth).transferTo(address(this), amount));
        }else{
            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));
        }
    }
    function sendFunds(address synth, address member, uint amount) internal {
        require(iERC20(synth).transfer(member, amount));
    }

    //============================== HELPERS ================================//

    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this)); // Balance
    }
    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this)); // Balance
    }

    function getMemberDeposit(address synth, address member) external view returns(uint){
        return mapMemberSynth_deposit[member][synth];
    }
    function getMemberWeight(address member) external view returns(uint){
        return mapMember_weight[member];
    }
    function getMemberLastTime(address synth, address member) external view returns(uint){
        return mapMemberSynth_lastTime[member][synth];
    }

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }

}
",2105,206,"[H-18] Vault rewards can be gamed
The _deposit function increases the member's weight by _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount); which is the swap output amount when trading the deposited underlying synth amount.
Notice that anyone can create synths of custom tokens by calling Pools.deploySynth(customToken).
Therefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:
Create a custom token and issue lots of tokens to the attacker
Create synth of this token
Add liquidity for the TOKEN <> BASE pair by providing a single wei of TOKEN and 10^18 BASE tokens. This makes the TOKEN price very expensive.
Mint some synths by paying BASE to the pool
Deposit the fake synth, _weight will be very high because the token pool price is so high.
Call harvest(realSynth) with a synth with actual value. This will increase the synth balance and it can be withdrawn later.
  [H-19] Vault rewards last claim time not always initialized
The harvest calls calcCurrentReward which computes _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];. As one can claim different synths than the synths that they deposited, mapMemberSynth_lastTime[member][synth] might still be uninitialized and the _secondsSinceClaim becomes the current block timestamp.
The larger the _secondsSinceClaim the larger the rewards. This bug allows claiming a huge chunk of the rewards.
Recommend letting users only harvest synths that they deposited.
 [H-20] Vault Weight accounting is wrong for withdrawals
When depositing two different synths, their weight is added to the same mapMember_weight[_member] storage variable. When withdrawing the full amount of one synth with _processWithdraw(synth, member, basisPoints=10000 the full weight is decreased.
The second deposited synth is now essentially weightless.
Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.
Recommed that the weight should be indexed by the synth as well.
 [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()",4,"pragma solidity ^0.8.3;

import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

contract Vault {

    bool private inited;
    uint public erasToEarn;
    uint public minGrantTime;
    uint public lastGranted;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    uint public minimumDepositTime;
    uint public totalWeight;

    mapping(address => uint) private mapMember_weight;
    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;
    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;

    
    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    constructor(){}

    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {
        require(inited == false);
        inited = true;
        POOLS = _pool;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
        POOLS = _pool;
        erasToEarn = 100;
        minimumDepositTime = 1;
        minGrantTime = 2592000;     
    }

    
    
    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {
        erasToEarn = newEra;
        minimumDepositTime = newDepositTime;
        minGrantTime = newGrantTime;
    }

    
    function grant(address recipient, uint amount) public onlyDAO {
        require((block.timestamp - lastGranted) >= minGrantTime, ""not too fast"");
        lastGranted = block.timestamp;
        iERC20(USDV).transfer(recipient, amount); 
    }

    

    
    function deposit(address synth, uint amount) external {
        depositForMember(synth, msg.sender, amount);
    }
    
    function depositForMember(address synth, address member, uint amount) public {
        require((iFACTORY(FACTORY).isSynth(synth)), ""Not Synth""); 
        getFunds(synth, amount);
        _deposit(synth, member, amount);
    }
    function _deposit(address _synth, address _member, uint _amount) internal {
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         
        mapMemberSynth_deposit[_member][_synth] += _amount;                 
        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);
        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){
            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               
        }
        mapMember_weight[_member] += _weight;                               
        totalWeight += _weight;                                             
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    

    
    function harvest(address synth) external returns(uint reward) {
        address _member = msg.sender;
        uint _weight;
        address _token = iSYNTH(synth).TOKEN();
        reward = calcCurrentReward(synth, _member);                     
        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      
        if(iPOOLS(POOLS).isAsset(_token)){
            iERC20(USDV).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));
            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);
        } else {
            iERC20(VADER).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));
            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));
        }
        mapMemberSynth_deposit[_member][synth] += reward; 
        mapMember_weight[_member] += _weight;
        totalWeight += _weight;
        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);
    }

    
    function calcCurrentReward(address synth, address member) public view returns(uint reward) {
        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        
        uint _share = calcReward(synth, member);                                               
        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         
        uint _reserve;
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            _reserve = reserveUSDV();
        } else {
            _reserve = reserveVADER();
        }
        if(reward >= _reserve) {
            reward = _reserve;                                                          
        }
    }

    function calcReward(address synth, address member) public view returns(uint reward) {
        uint _weight = mapMember_weight[member];  
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   
        } else{
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          
        }
    }

    

    
    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          
        sendFunds(synth, msg.sender, redeemedAmount);
    }
    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {
        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, ""DepositTime"");    
        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); 
        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  
        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   
        mapMember_weight[_member] -= _weight;                                   
        totalWeight -= _weight;                                                 
        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   
    }

    

    function getFunds(address synth, uint amount) internal {
        if(tx.origin==msg.sender){
            require(iERC20(synth).transferTo(address(this), amount));
        }else{
            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));
        }
    }
    function sendFunds(address synth, address member, uint amount) internal {
        require(iERC20(synth).transfer(member, amount));
    }

    

    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this)); 
    }
    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this)); 
    }

    function getMemberDeposit(address synth, address member) external view returns(uint){
        return mapMemberSynth_deposit[member][synth];
    }
    function getMemberWeight(address member) external view returns(uint){
        return mapMember_weight[member];
    }
    function getMemberLastTime(address synth, address member) external view returns(uint){
        return mapMemberSynth_lastTime[member][synth];
    }

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }

}",1860,3,1,"{'Findings': [{'Issue': 'Reentrancy Vulnerability in `depositForMember` and `withdraw` Functions', 'Severity': 'High', 'Description': ""The `depositForMember` and `withdraw` functions interact with external contracts via `getFunds` and `sendFunds` without following the checks-effects-interactions pattern. This could potentially allow a reentrancy attack where an attacker could recursively call these functions to manipulate the contract's state."", 'Impact': 'An attacker could drain funds from the contract or manipulate the state in unintended ways.', 'Location': 'Functions: `depositForMember`, `withdraw`'}, {'Issue': 'Uninitialized `UTILS` and `DAO` Functions', 'Severity': 'High', 'Description': 'The `UTILS` and `DAO` functions return addresses by calling `iVADER(VADER).UTILS()` and `iVADER(VADER).DAO()` respectively. However, there is no check to ensure that `VADER` is initialized before these calls, which could lead to unexpected behavior or errors if `VADER` is not set.', 'Impact': 'If `VADER` is not initialized, calls to `UTILS` or `DAO` could fail, potentially causing the contract to malfunction.', 'Location': 'Functions: `UTILS`, `DAO`'}, {'Issue': 'Potential Integer Overflow in `calcCurrentReward` Function', 'Severity': 'Medium', 'Description': 'The `calcCurrentReward` function calculates rewards based on the difference between `block.timestamp` and `mapMemberSynth_lastTime[member][synth]`. If `mapMemberSynth_lastTime[member][synth]` is not properly initialized or is set to a very old timestamp, this could lead to an integer overflow when calculating `_secondsSinceClaim`.', 'Impact': 'An integer overflow could lead to incorrect reward calculations, potentially allowing users to claim more rewards than they are entitled to.', 'Location': 'Function: `calcCurrentReward`'}, {'Issue': 'Lack of Access Control in `init` Function', 'Severity': 'Medium', 'Description': 'The `init` function is responsible for initializing critical contract parameters and addresses. However, it lacks access control, meaning anyone can call this function and potentially reinitialize the contract, leading to unexpected behavior or state corruption.', 'Impact': ""An attacker could reinitialize the contract, changing critical parameters and potentially disrupting the contract's operation."", 'Location': 'Function: `init`'}, {'Issue': 'Potential Front-Running in `grant` Function', 'Severity': 'Low', 'Description': 'The `grant` function allows the DAO to grant tokens to a recipient, but it includes a time-based check to prevent frequent grants. However, this does not prevent front-running, where an attacker could monitor the blockchain and execute a transaction immediately after the grant to take advantage of the newly granted tokens.', 'Impact': 'Front-running could allow an attacker to benefit from the granted tokens before the intended recipient.', 'Location': 'Function: `grant`'}, {'Issue': 'Unchecked External Calls in `harvest` Function', 'Severity': 'Medium', 'Description': 'The `harvest` function makes external calls to `iERC20(USDV).transfer`, `iPOOLS(POOLS).mintSynth`, and `iERC20(VADER).transfer` without checking the return values. If these calls fail, the function will continue execution, potentially leading to an inconsistent state.', 'Impact': 'Failed external calls could lead to loss of funds or an inconsistent contract state.', 'Location': 'Function: `harvest`'}, {'Issue': 'Lack of Input Validation in `setParams` Function', 'Severity': 'Medium', 'Description': ""The `setParams` function does not validate the input parameters `newEra`, `newDepositTime`, and `newGrantTime`. This could lead to setting invalid or harmful values that could disrupt the contract's functionality."", 'Impact': 'Invalid parameters could cause the contract to behave unexpectedly, potentially leading to financial losses or other issues.', 'Location': 'Function: `setParams`'}, {'Issue': 'Uninitialized Contract State in Constructor', 'Severity': 'Low', 'Description': 'The constructor does not initialize the contract state, relying on the `init` function to do so. If the `init` function is not called, the contract could be left in an uninitialized state, leading to undefined behavior.', 'Impact': 'The contract may not function as intended if the `init` function is not called, potentially leading to operational issues.', 'Location': 'Constructor'}, {'Issue': 'Insufficient Validation in `getFunds` and `sendFunds` Functions', 'Severity': 'Medium', 'Description': 'The `getFunds` and `sendFunds` functions do not validate the `synth` address, which could lead to interactions with malicious or non-existent contracts.', 'Impact': 'Interacting with a malicious contract could result in loss of funds or other security issues.', 'Location': 'Functions: `getFunds`, `sendFunds`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Some critical functions like `init` and `setParams` do not emit events, making it difficult to track changes or detect malicious activities.', 'Impact': 'Reduced transparency and auditability.', 'Location': 'Functions: `init`, `setParams`'}], 'IssueNumber': 10, 'OutputList': 10}",,"{'ReviewingTheCode': ""The provided code is a Solidity smart contract named 'Vault' that manages deposits, withdrawals, and rewards for members interacting with synthetic assets (synths). It integrates with several external contracts to handle token transfers, calculations, and other functionalities."", 'IdentifyingKeyComponents': {'ContractName': 'Vault', 'Purpose': 'To manage deposits, withdrawals, and rewards for members interacting with synthetic assets (synths) in a decentralized finance (DeFi) ecosystem.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['./interfaces/iERC20.sol', './interfaces/iUTILS.sol', './interfaces/iVADER.sol', './interfaces/iROUTER.sol', './interfaces/iPOOLS.sol', './interfaces/iFACTORY.sol', './interfaces/iSYNTH.sol']}, 'StateVariables': [{'Name': 'inited', 'Type': 'bool', 'Purpose': 'Flag to check if the contract has been initialized.'}, {'Name': 'erasToEarn', 'Type': 'uint', 'Purpose': 'Number of eras required to earn rewards.'}, {'Name': 'minGrantTime', 'Type': 'uint', 'Purpose': 'Minimum time between grants.'}, {'Name': 'lastGranted', 'Type': 'uint', 'Purpose': 'Timestamp of the last grant.'}, {'Name': 'VADER', 'Type': 'address', 'Purpose': 'Address of the VADER token contract.'}, {'Name': 'USDV', 'Type': 'address', 'Purpose': 'Address of the USDV token contract.'}, {'Name': 'ROUTER', 'Type': 'address', 'Purpose': 'Address of the ROUTER contract.'}, {'Name': 'POOLS', 'Type': 'address', 'Purpose': 'Address of the POOLS contract.'}, {'Name': 'FACTORY', 'Type': 'address', 'Purpose': 'Address of the FACTORY contract.'}, {'Name': 'minimumDepositTime', 'Type': 'uint', 'Purpose': 'Minimum time required for a deposit to be eligible for withdrawal.'}, {'Name': 'totalWeight', 'Type': 'uint', 'Purpose': 'Total weight of all deposits.'}, {'Name': 'mapMember_weight', 'Type': 'mapping(address => uint)', 'Purpose': 'Mapping of member addresses to their deposit weights.'}, {'Name': 'mapMemberSynth_deposit', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping of member addresses and synth addresses to their deposit amounts.'}, {'Name': 'mapMemberSynth_lastTime', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping of member addresses and synth addresses to the last deposit time.'}], 'FunctionsAndModifiers': [{'Name': 'onlyDAO', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions to the DAO.', 'Parameters': [], 'Returns': []}, {'Name': 'init', 'Visibility': 'public', 'Purpose': 'Initializes the contract with necessary addresses and parameters.', 'Parameters': ['address _vader', 'address _usdv', 'address _router', 'address _factory', 'address _pool'], 'Returns': []}, {'Name': 'setParams', 'Visibility': 'external', 'Purpose': 'Sets parameters for eras to earn, minimum deposit time, and minimum grant time.', 'Parameters': ['uint newEra', 'uint newDepositTime', 'uint newGrantTime'], 'Returns': []}, {'Name': 'grant', 'Visibility': 'public', 'Purpose': 'Grants a specified amount of USDV to a recipient.', 'Parameters': ['address recipient', 'uint amount'], 'Returns': []}, {'Name': 'deposit', 'Visibility': 'external', 'Purpose': 'Deposits a specified amount of synth for the sender.', 'Parameters': ['address synth', 'uint amount'], 'Returns': []}, {'Name': 'depositForMember', 'Visibility': 'public', 'Purpose': 'Deposits a specified amount of synth for a specified member.', 'Parameters': ['address synth', 'address member', 'uint amount'], 'Returns': []}, {'Name': '_deposit', 'Visibility': 'internal', 'Purpose': 'Internal function to handle the deposit logic.', 'Parameters': ['address _synth', 'address _member', 'uint _amount'], 'Returns': []}, {'Name': 'harvest', 'Visibility': 'external', 'Purpose': 'Harvests rewards for the sender.', 'Parameters': ['address synth'], 'Returns': ['uint reward']}, {'Name': 'calcCurrentReward', 'Visibility': 'public', 'Purpose': 'Calculates the current reward for a member.', 'Parameters': ['address synth', 'address member'], 'Returns': ['uint reward']}, {'Name': 'calcReward', 'Visibility': 'public', 'Purpose': 'Calculates the reward for a member based on their weight.', 'Parameters': ['address synth', 'address member'], 'Returns': ['uint reward']}, {'Name': 'withdraw', 'Visibility': 'external', 'Purpose': 'Withdraws a specified amount of synth for the sender.', 'Parameters': ['address synth', 'uint basisPoints'], 'Returns': ['uint redeemedAmount']}, {'Name': '_processWithdraw', 'Visibility': 'internal', 'Purpose': 'Internal function to handle the withdrawal logic.', 'Parameters': ['address _synth', 'address _member', 'uint _basisPoints'], 'Returns': ['uint redeemedAmount']}, {'Name': 'getFunds', 'Visibility': 'internal', 'Purpose': 'Internal function to transfer funds to the contract.', 'Parameters': ['address synth', 'uint amount'], 'Returns': []}, {'Name': 'sendFunds', 'Visibility': 'internal', 'Purpose': 'Internal function to transfer funds from the contract.', 'Parameters': ['address synth', 'address member', 'uint amount'], 'Returns': []}, {'Name': 'reserveUSDV', 'Visibility': 'public', 'Purpose': 'Returns the balance of USDV in the contract.', 'Parameters': [], 'Returns': ['uint']}, {'Name': 'reserveVADER', 'Visibility': 'public', 'Purpose': 'Returns the balance of VADER in the contract.', 'Parameters': [], 'Returns': ['uint']}, {'Name': 'getMemberDeposit', 'Visibility': 'external', 'Purpose': 'Returns the deposit amount of a member for a specified synth.', 'Parameters': ['address synth', 'address member'], 'Returns': ['uint']}, {'Name': 'getMemberWeight', 'Visibility': 'external', 'Purpose': 'Returns the weight of a member.', 'Parameters': ['address member'], 'Returns': ['uint']}, {'Name': 'getMemberLastTime', 'Visibility': 'external', 'Purpose': 'Returns the last deposit time of a member for a specified synth.', 'Parameters': ['address synth', 'address member'], 'Returns': ['uint']}, {'Name': 'DAO', 'Visibility': 'public', 'Purpose': 'Returns the address of the DAO.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'UTILS', 'Visibility': 'public', 'Purpose': 'Returns the address of the UTILS contract.', 'Parameters': [], 'Returns': ['address']}]}, 'ExternalInteractions': ['iERC20', 'iUTILS', 'iVADER', 'iROUTER', 'iPOOLS', 'iFACTORY', 'iSYNTH'], 'SpecialMechanisms': ['The contract uses a weight-based reward calculation mechanism.', 'It integrates with external contracts for token transfers, calculations, and other functionalities.'], 'Questions': ['What is the exact role of the UTILS contract in the reward calculations?', 'How are the weights for deposits calculated and what is their significance in the reward distribution?', ""What is the purpose of the 'erasToEarn' parameter and how is it used in the reward calculations?"", 'Are there any safeguards in place to prevent reentrancy attacks during token transfers?']}",569.8633768558502,"### **[H-18] Vault rewards can be gamed**

**Report Description**:
The `_deposit` function increases the member's weight by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);`, which is the swap output amount when trading the deposited underlying synth amount. An attacker can exploit this by creating valueless custom tokens, deploying a synth for these tokens, and manipulating the token pool price to inflate their member weight. This allows the attacker to deposit fake synths with high weight and later harvest rewards from real synths, effectively gaming the vault rewards system.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of vault rewards being gamed through the manipulation of custom tokens and synth weights. This is a critical vulnerability that is entirely missed in the response list.

---

### **[H-19] Vault rewards last claim time not always initialized**

**Report Description**:
The `harvest` function calls `calcCurrentReward`, which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. If `mapMemberSynth_lastTime[member][synth]` is uninitialized, `_secondsSinceClaim` becomes the current block timestamp, leading to inflated rewards. This bug allows users to claim a disproportionately large chunk of rewards by harvesting synths they did not deposit.

**Match in Response List**:
Matches with the issue titled **""Potential Integer Overflow in `calcCurrentReward` Function""**.

**Validation**:
**Partially Correct**. The response identifies the issue with `calcCurrentReward` and mentions the risk of integer overflow due to uninitialized timestamps. However, it does not fully capture the specific vulnerability where users can claim rewards for synths they did not deposit, which is a critical aspect of the issue.

---

### **[H-20] Vault Weight accounting is wrong for withdrawals**

**Report Description**:
When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth using `_processWithdraw(synth, member, basisPoints=10000)`, the full weight is decreased, leaving the second deposited synth essentially weightless. This prevents users who deposited more than one synth from claiming their fair share of rewards after a withdrawal.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect weight accounting during withdrawals, which is a significant vulnerability affecting reward distribution fairness.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init` function in most Solidity contracts lacks access control, allowing anyone to call it. This could lead to reinitialization of critical contract parameters, potentially disrupting the contract's operation or corrupting its state.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control in `init` Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `init` function lacking access control and explains the potential impact of unauthorized reinitialization. This aligns with the reported issue and Solidity best practices.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- **[H-19] Vault rewards last claim time not always initialized**

**Missed Issues from Issue Report**:

- **[H-18] Vault rewards can be gamed**
- **[H-20] Vault Weight accounting is wrong for withdrawals**

---

### **Conclusion**

The response list covers some issues but misses critical vulnerabilities related to vault rewards manipulation and weight accounting. The partially correct match for [H-19] indicates that while the response identifies a related issue, it does not fully address the specific vulnerability. The lack of matches for [H-18] and [H-20] highlights significant gaps in the response list's coverage of high-severity issues.","```
1. Lack of Access Control in `init` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Lack of Access Control in `init` Function"".
   - From the ranked list of predictions, this issue appears at rank 4.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Here, \( k = 4 \), and there is 1 true positive up to rank 4.
   - \( P@4 = \frac{1}{4} = 0.25 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.25 \).

**Output**:
```
0.25
```"
Vether.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iVETHER.sol"";

// Token Contract
contract Vether is iVETHER {

    // Coin Defaults
    string public override name;                                         // Name of Coin
    string public override symbol;                                       // Symbol of Coin
    uint public override decimals  = 18;                              // Decimals
    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   // 1,000,000 Total

    uint public totalFees;
    mapping(address=>bool) public mapAddress_Excluded;  

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    
    // Minting event
    constructor() {
        name = ""Vether"";
        symbol  = ""VETH"";
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""iERC20: approve from the zero address"");
        require(spender != address(0), ""iERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

       // Internal transfer function which includes the Fee
    function _transfer(address _from, address _to, uint _value) private {
        require(_balances[_from] >= _value, 'Must not send more than balance');
        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');
        _balances[_from] -= _value;
        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount
        _balances[_to] += (_value - _fee);                                               // Add to receiver
        _balances[address(this)] += _fee;                                                   // Add fee to self
        totalFees += _fee;                                                                  // Track fees collected
        emit Transfer(_from, _to, (_value - _fee));                                      // Transfer event
        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {
            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event
        }
    }
    
    // Calculate Fee amount
    function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }

    function addExcluded(address excluded) public {
        mapAddress_Excluded[excluded] = true;
    }
}",921,96,"[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List.
Vether.sol implements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses (mapAddress_Excluded). However, the addExcluded() function in Vether.sol has no restrictions on who can call it. So any user can call addExcluded with their own address as the argument, and bypass all transfer fees.",1,"pragma solidity 0.8.3;


import ""./interfaces/iVETHER.sol"";


contract Vether is iVETHER {

    
    string public override name;                                         
    string public override symbol;                                       
    uint public override decimals  = 18;                              
    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   

    uint public totalFees;
    mapping(address=>bool) public mapAddress_Excluded;  

    
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    
    
    constructor() {
        name = ""Vether"";
        symbol  = ""VETH"";
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""iERC20: approve from the zero address"");
        require(spender != address(0), ""iERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

       
    function _transfer(address _from, address _to, uint _value) private {
        require(_balances[_from] >= _value, 'Must not send more than balance');
        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');
        _balances[_from] -= _value;
        uint _fee = _getFee(_from, _to, _value);                                            
        _balances[_to] += (_value - _fee);                                               
        _balances[address(this)] += _fee;                                                   
        totalFees += _fee;                                                                  
        emit Transfer(_from, _to, (_value - _fee));                                      
        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {
            emit Transfer(_from, address(this), _fee);                                      
        }
    }
    
    
    function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        
        } else {
            return (_value / 1000);                                                         
        }
    }

    function addExcluded(address excluded) public {
        mapAddress_Excluded[excluded] = true;
    }
}",787,1,0,"{'Findings': [{'Issue': 'Lack of Access Control in `addExcluded` Function', 'Severity': 'High', 'Description': 'The `addExcluded` function allows any user to add an address to the `mapAddress_Excluded` mapping, which can exempt addresses from fees. This function lacks access control, making it susceptible to misuse.', 'Impact': 'Unauthorized users can manipulate the fee exemption list, potentially leading to loss of revenue or unfair advantages.', 'Location': 'Function `addExcluded`'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': ""The contract uses arithmetic operations without explicit checks for overflow/underflow, especially in functions like `decreaseAllowance` and `transferFrom`. Although Solidity 0.8.x has built-in overflow checks, it's good practice to explicitly handle these cases."", 'Impact': 'Could lead to unexpected behavior or vulnerabilities if the contract is used in a way that triggers overflow/underflow.', 'Location': 'Functions `decreaseAllowance`, `transferFrom`, `_transfer`'}, {'Issue': 'Potential Reentrancy in `_transfer` Function', 'Severity': 'Medium', 'Description': ""The `_transfer` function updates balances and emits events before transferring tokens. While there are no external calls in this function, it's a good practice to follow the checks-effects-interactions pattern to prevent potential reentrancy attacks in more complex contracts."", 'Impact': 'Future modifications or extensions to the function could introduce reentrancy vulnerabilities if the order of operations is not carefully managed.', 'Location': 'Function `_transfer`'}, {'Issue': 'Fixed Fee Calculation in `_getFee` Function', 'Severity': 'Low', 'Description': 'The `_getFee` function calculates a fixed fee of 0.1% for all transactions. This lacks flexibility and could be problematic if the fee structure needs to be adjusted in the future.', 'Impact': 'Limited flexibility in fee calculation, which might not suit all use cases or business requirements.', 'Location': 'Function `_getFee`'}, {'Issue': 'Lack of Event Emission for `addExcluded` Function', 'Severity': 'Low', 'Description': 'The `addExcluded` function modifies the `mapAddress_Excluded` mapping but does not emit an event to log this change. This lack of transparency makes it difficult to track changes to the excluded list.', 'Impact': 'Reduced transparency and auditability of changes to the excluded addresses, making it harder to track and verify state changes.', 'Location': 'Function `addExcluded`'}, {'Issue': 'Lack of Event Emission for Fee Collection', 'Severity': 'Low', 'Description': ""When fees are collected and added to the contract's balance, no specific event is emitted to log this action. This could make it difficult to track fee collection and audit the contract."", 'Impact': 'Reduced transparency and auditability of fee collection.', 'Location': 'Function `_transfer`'}], 'IssueNumber': 14, 'OutputList': 6}",,"{'ReviewingTheCode': 'The contract is a basic ERC-20 token implementation with additional fee mechanisms. It includes standard ERC-20 functions and introduces a fee system for transactions. The contract is well-structured and follows common practices in Solidity development.', 'IdentifyingKeyComponents': {'ContractName': 'Vether', 'Purpose': 'The contract implements a token with a built-in transaction fee mechanism. It allows for excluding certain addresses from fees and tracks total fees collected.', 'InheritanceAndImports': {'InheritsFrom': ['iVETHER'], 'Imports': ['./interfaces/iVETHER.sol']}, 'StateVariables': [{'Name': 'name', 'Type': 'string', 'Purpose': 'The name of the token.'}, {'Name': 'symbol', 'Type': 'string', 'Purpose': 'The symbol of the token.'}, {'Name': 'decimals', 'Type': 'uint', 'Purpose': 'The number of decimal places for the token.'}, {'Name': 'totalSupply', 'Type': 'uint', 'Purpose': 'The total supply of the token.'}, {'Name': 'totalFees', 'Type': 'uint', 'Purpose': 'The total amount of fees collected.'}, {'Name': 'mapAddress_Excluded', 'Type': 'mapping(address=>bool)', 'Purpose': 'Mapping to track addresses excluded from fees.'}, {'Name': '_balances', 'Type': 'mapping(address => uint)', 'Purpose': 'Mapping to track token balances of addresses.'}, {'Name': '_allowances', 'Type': 'mapping(address => mapping(address => uint))', 'Purpose': 'Mapping to track allowances for spending tokens.'}], 'FunctionsAndModifiers': [{'Name': 'balanceOf', 'Visibility': 'public', 'Purpose': 'Returns the balance of a specified address.', 'Parameters': ['address account'], 'Returns': ['uint']}, {'Name': 'allowance', 'Visibility': 'public', 'Purpose': 'Returns the remaining number of tokens that spender is allowed to spend on behalf of owner.', 'Parameters': ['address owner', 'address spender'], 'Returns': ['uint']}, {'Name': 'transfer', 'Visibility': 'public', 'Purpose': 'Transfers tokens from the caller to a specified recipient.', 'Parameters': ['address recipient', 'uint amount'], 'Returns': ['bool']}, {'Name': 'approve', 'Visibility': 'public', 'Purpose': ""Sets the allowance for a spender to spend the caller's tokens."", 'Parameters': ['address spender', 'uint amount'], 'Returns': ['bool']}, {'Name': 'increaseAllowance', 'Visibility': 'public', 'Purpose': 'Increases the allowance of a spender.', 'Parameters': ['address spender', 'uint addedValue'], 'Returns': ['bool']}, {'Name': 'decreaseAllowance', 'Visibility': 'public', 'Purpose': 'Decreases the allowance of a spender.', 'Parameters': ['address spender', 'uint subtractedValue'], 'Returns': ['bool']}, {'Name': '_approve', 'Visibility': 'internal', 'Purpose': 'Internal function to set allowances.', 'Parameters': ['address owner', 'address spender', 'uint amount'], 'Returns': []}, {'Name': 'transferFrom', 'Visibility': 'public', 'Purpose': 'Transfers tokens from a specified sender to a recipient using an allowance.', 'Parameters': ['address sender', 'address recipient', 'uint amount'], 'Returns': ['bool']}, {'Name': '_transfer', 'Visibility': 'private', 'Purpose': 'Internal function to handle token transfers, including fee calculation.', 'Parameters': ['address _from', 'address _to', 'uint _value'], 'Returns': []}, {'Name': '_getFee', 'Visibility': 'private', 'Purpose': 'Internal function to calculate the fee for a transaction.', 'Parameters': ['address _from', 'address _to', 'uint _value'], 'Returns': ['uint']}, {'Name': 'addExcluded', 'Visibility': 'public', 'Purpose': 'Adds an address to the list of excluded addresses from fees.', 'Parameters': ['address excluded'], 'Returns': []}]}, 'ExternalInteractions': ['The contract imports and implements the iVETHER interface, but no direct external contract calls are made within the provided code.'], 'SpecialMechanisms': ['The contract implements a fee mechanism where a 0.1% fee is deducted from each transaction, unless the sender or recipient is excluded. The fee is collected in the contract itself.'], 'Questions': ['What is the purpose of the iVETHER interface? Are there any additional functions or requirements not shown in the provided code?', 'Is there a mechanism to withdraw the collected fees from the contract?', 'Are there any restrictions or access controls on the addExcluded function? Currently, it is public and can be called by anyone.']}",505.9084801673889,"---

**[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List**

**Report Description**:
The `Vether.sol` contract implements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses (`mapAddress_Excluded`). However, the `addExcluded()` function in `Vether.sol` has no restrictions on who can call it. As a result, any user can call `addExcluded` with their own address as the argument, bypassing all transfer fees. This lack of access control allows unauthorized users to manipulate the fee exemption list, leading to potential loss of revenue or unfair advantages.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control in `addExcluded` Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `addExcluded` function, which lacks access control and allows any user to add their address to the `mapAddress_Excluded` mapping. The response correctly explains the risks associated with this vulnerability, including the potential for unauthorized users to bypass transfer fees, which aligns with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

---","```
1. Lack of Access Control in `addExcluded` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is: `Lack of Access Control in addExcluded Function`.
   - This issue appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - \( P@1 = \frac{1}{1} = 1.0 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the **Average Precision (AP)** is simply the precision at rank 1.
   - \( AP = 1.0 \).

**Output**:
```
1.0
```"
