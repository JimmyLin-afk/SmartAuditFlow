nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
SingleTokenJoinV2.sol,"//SPDX-License-Identifier: Unlicense
pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {IPangolinRouter} from ""@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol"";

import ""../interfaces/IBasketFacet.sol"";

contract SingleTokenJoinV2 {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    // Can be any IPangolinRouter or IUniRouter ...
    IPangolinRouter public immutable uniSwapLikeRouter;
    // WETH or WAVAX ...
    IERC20 public immutable INTERMEDIATE_TOKEN;

    struct UnderlyingTrade {
        UniswapV2SwapStruct[] swaps;
        uint256 quantity; //Quantity to buy
    }

    struct UniswapV2SwapStruct {
        address exchange;
        address[] path;
    }
    struct JoinTokenStructV2 {
        address inputToken;
        address outputBasket;
        uint256 inputAmount;
        uint256 outputAmount;
        UnderlyingTrade[] trades;
        uint256 deadline;
        uint16 referral;
    }

    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {
        require(_INTERMEDIATE_TOKEN != address(0), ""INTERMEDIATE_ZERO"");
        require(_uniSwapLikeRouter != address(0), ""UNI_ROUTER_ZERO"");

        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);
        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);
    }

    function _maxApprove(IERC20 token, address spender) internal {
        if (
            token.allowance(address(this), spender) <
            token.balanceOf(address(this))
        ) {
            token.approve(spender, uint256(-1));
        }
    }

    function joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)
        external
    {
        // ######## INIT TOKEN #########
        IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);

        inputToken.safeTransferFrom(
            msg.sender,
            address(this),
            _joinTokenStruct.inputAmount
        );

        _joinTokenSingle(_joinTokenStruct);

        // ######## SEND TOKEN #########
        uint256 remainingIntermediateBalance = inputToken.balanceOf(
            address(this)
        );
        if (remainingIntermediateBalance > 0) {
            inputToken.safeTransfer(msg.sender, remainingIntermediateBalance);
        }
    }

    function _joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)
        internal
    {
        // ######## INIT TOKEN #########
        IERC20 outputToken = IERC20(_joinTokenStruct.outputBasket);

        for (uint256 i; i < _joinTokenStruct.trades.length; i++) {
            UnderlyingTrade calldata trade = _joinTokenStruct.trades[i];
            uint256[] memory inputs = new uint256[](trade.swaps.length + 1);
            inputs[0] = trade.quantity;
            //Get inputs to
            for (uint256 j; j < trade.swaps.length; j++) {
                UniswapV2SwapStruct calldata swap = trade.swaps[
                    trade.swaps.length - j - 1
                ];
                uint256[] memory amounts = IPangolinRouter(swap.exchange)
                    .getAmountsIn(inputs[j], swap.path);
                inputs[j + 1] = amounts[0];
            }

            for (uint256 j; j < trade.swaps.length; j++) {
                UniswapV2SwapStruct calldata swap = trade.swaps[j];
                uint256 amountIn = inputs[trade.swaps.length - j];
                _maxApprove(IERC20(swap.path[0]), address(swap.exchange));
                IPangolinRouter(swap.exchange).swapExactTokensForTokens(
                    amountIn,
                    0,
                    swap.path,
                    address(this),
                    block.timestamp
                );
            }
        }

        address[] memory tokens = IBasketFacet(_joinTokenStruct.outputBasket)
            .getTokens();

        for (uint256 i; i < tokens.length; i++) {
            _maxApprove(IERC20(tokens[i]), _joinTokenStruct.outputBasket);
        }

        IBasketFacet(_joinTokenStruct.outputBasket).joinPool(
            _joinTokenStruct.outputAmount,
            _joinTokenStruct.referral
        );

        // ######## SEND TOKEN #########

        uint256 outputAmount = outputToken.balanceOf(address(this));
        require(
            outputAmount == _joinTokenStruct.outputAmount,
            ""FAILED_OUTPUT_AMOUNT""
        );
        outputToken.safeTransfer(msg.sender, outputAmount);
    }
}",1019,135,"[H-01] Unused ERC20 tokens are not refunded, and can be stolen by attacker

Submitted by WatchPug
Under certain circumstances, e.g. annualizedFee being minted to feeBeneficiary between the time user sent the transaction and the transaction being packed into the block and causing amounts of underlying tokens for each basketToken to decrease. It’s possible or even most certainly that there will be some leftover basket underlying tokens, as BasketFacet.sol#joinPool() will only transfer required amounts of basket tokens from Join contracts.
However, in the current implementation, only the leftover inputToken is returned.
As a result, the leftover underlying tokens won’t be returned to the user, which constitutes users’ fund loss.
SingleTokenJoinV2.sol L57-L78
 Furthermore, the leftover tokens in the SingleTokenJoinV2 contract can be stolen by calling `joinTokenSingle()` with fake outputBasket contract and swap.exchange contract.   [M-01] Function joinTokenSingle in SingleTokenJoin.sol and SingleTokenJoinV2.sol can be made to fail

Submitted by pmerkleplant, also found by certora, hyh, p4st13r4, pauliax, robee, and WatchPug
Impact

There’s a griefing attack vulnerability in the function joinTokenSingle in SingleTokenJoin.sol as well as SingleTokenJoinV2.sol which makes any user transaction fail with “FAILEDOUTPUTAMOUNT”.
Proof of Concept

The JoinTokenStruct argument for joinTokenSingle includes a field outputAmount to indicate the amount of tokens the user should receive after joining a basket (see line 135 and 130).
However, this amount is compared to the contract’s balance of the token and reverts if the amount is unequal.
If an attacker sends some amount of a basket’s token to the contract, every call to this function will fail as long as the output token equals the attacker’s token send.

 [M-02] Unchecked return value from low-level call()

Submitted by JMukesh, also found by certora
Impact

The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.
",3,,"pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import {IPangolinRouter} from ""@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol"";

import ""../interfaces/IBasketFacet.sol"";

contract SingleTokenJoinV2 {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    IPangolinRouter public immutable uniSwapLikeRouter;
    
    IERC20 public immutable INTERMEDIATE_TOKEN;

    struct UnderlyingTrade {
        UniswapV2SwapStruct[] swaps;
        uint256 quantity; 
    }

    struct UniswapV2SwapStruct {
        address exchange;
        address[] path;
    }
    struct JoinTokenStructV2 {
        address inputToken;
        address outputBasket;
        uint256 inputAmount;
        uint256 outputAmount;
        UnderlyingTrade[] trades;
        uint256 deadline;
        uint16 referral;
    }

    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {
        require(_INTERMEDIATE_TOKEN != address(0), ""INTERMEDIATE_ZERO"");
        require(_uniSwapLikeRouter != address(0), ""UNI_ROUTER_ZERO"");

        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);
        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);
    }

    function _maxApprove(IERC20 token, address spender) internal {
        if (
            token.allowance(address(this), spender) <
            token.balanceOf(address(this))
        ) {
            token.approve(spender, uint256(-1));
        }
    }

    function joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)
        external
    {
        
        IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);

        inputToken.safeTransferFrom(
            msg.sender,
            address(this),
            _joinTokenStruct.inputAmount
        );

        _joinTokenSingle(_joinTokenStruct);

        
        uint256 remainingIntermediateBalance = inputToken.balanceOf(
            address(this)
        );
        if (remainingIntermediateBalance > 0) {
            inputToken.safeTransfer(msg.sender, remainingIntermediateBalance);
        }
    }

    function _joinTokenSingle(JoinTokenStructV2 calldata _joinTokenStruct)
        internal
    {
        
        IERC20 outputToken = IERC20(_joinTokenStruct.outputBasket);

        for (uint256 i; i < _joinTokenStruct.trades.length; i++) {
            UnderlyingTrade calldata trade = _joinTokenStruct.trades[i];
            uint256[] memory inputs = new uint256[](trade.swaps.length + 1);
            inputs[0] = trade.quantity;
            
            for (uint256 j; j < trade.swaps.length; j++) {
                UniswapV2SwapStruct calldata swap = trade.swaps[
                    trade.swaps.length - j - 1
                ];
                uint256[] memory amounts = IPangolinRouter(swap.exchange)
                    .getAmountsIn(inputs[j], swap.path);
                inputs[j + 1] = amounts[0];
            }

            for (uint256 j; j < trade.swaps.length; j++) {
                UniswapV2SwapStruct calldata swap = trade.swaps[j];
                uint256 amountIn = inputs[trade.swaps.length - j];
                _maxApprove(IERC20(swap.path[0]), address(swap.exchange));
                IPangolinRouter(swap.exchange).swapExactTokensForTokens(
                    amountIn,
                    0,
                    swap.path,
                    address(this),
                    block.timestamp
                );
            }
        }

        address[] memory tokens = IBasketFacet(_joinTokenStruct.outputBasket)
            .getTokens();

        for (uint256 i; i < tokens.length; i++) {
            _maxApprove(IERC20(tokens[i]), _joinTokenStruct.outputBasket);
        }

        IBasketFacet(_joinTokenStruct.outputBasket).joinPool(
            _joinTokenStruct.outputAmount,
            _joinTokenStruct.referral
        );

        

        uint256 outputAmount = outputToken.balanceOf(address(this));
        require(
            outputAmount == _joinTokenStruct.outputAmount,
            ""FAILED_OUTPUT_AMOUNT""
        );
        outputToken.safeTransfer(msg.sender, outputAmount);
    }
}",957,1,2,,"{'ReviewingTheCode': ""The provided code is a Solidity smart contract named 'SingleTokenJoinV2'. It facilitates the joining of a single token into a basket of tokens by performing a series of swaps using a Uniswap-like router (Pangolin Router). The contract uses OpenZeppelin libraries for safe math operations and ERC20 token interactions."", 'IdentifyingKeyComponents': {'ContractName': 'SingleTokenJoinV2', 'Purpose': 'To allow users to join a single token into a basket of tokens by performing a series of swaps and then joining the resulting tokens into the basket.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/math/SafeMath.sol', '@openzeppelin/contracts/token/ERC20/SafeERC20.sol', '@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol', '../interfaces/IBasketFacet.sol']}, 'StateVariables': [{'Name': 'uniSwapLikeRouter', 'Type': 'IPangolinRouter', 'Purpose': 'The router used for performing token swaps, specifically the Pangolin Router.'}, {'Name': 'INTERMEDIATE_TOKEN', 'Type': 'IERC20', 'Purpose': 'The intermediate token used in the swap process.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with the intermediate token and the Uniswap-like router.', 'Parameters': ['address _INTERMEDIATE_TOKEN', 'address _uniSwapLikeRouter'], 'Returns': []}, {'Name': '_maxApprove', 'Visibility': 'internal', 'Purpose': 'Approves the maximum allowance for a token to be spent by a spender.', 'Parameters': ['IERC20 token', 'address spender'], 'Returns': []}, {'Name': 'joinTokenSingle', 'Visibility': 'external', 'Purpose': 'Handles the transfer of the input token from the user and initiates the joining process.', 'Parameters': ['JoinTokenStructV2 calldata _joinTokenStruct'], 'Returns': []}, {'Name': '_joinTokenSingle', 'Visibility': 'internal', 'Purpose': 'Performs the actual joining process, including swaps and joining the basket.', 'Parameters': ['JoinTokenStructV2 calldata _joinTokenStruct'], 'Returns': []}]}, 'ExternalInteractions': ['IPangolinRouter: Used for performing token swaps.', 'IERC20: Used for interacting with ERC20 tokens.', 'IBasketFacet: Used for interacting with the basket of tokens.'], 'SpecialMechanisms': ['The contract uses a series of swaps to convert the input token into the required tokens for the basket.', 'The contract uses the Pangolin Router for decentralized exchange operations.', ""The contract employs the 'joinPool' function from the IBasketFacet to join the tokens into the basket.""], 'Questions': [""What is the purpose of the 'INTERMEDIATE_TOKEN' and how is it used in the swap process?"", 'How does the contract handle slippage during the swaps?', 'Is there any mechanism to handle failed transactions or revert conditions during the swap process?', ""What is the significance of the 'referral' parameter in the 'joinPool' function?""]}","{'Findings': [{'Issue': 'Unrestricted Token Approval', 'Severity': 'High', 'Description': ""The `_maxApprove` function grants unlimited approval (`uint256(-1)`) to the spender for the token. This can be dangerous if the spender is compromised or behaves maliciously, as it could lead to the draining of the contract's token balance."", 'Impact': 'Potential loss of all tokens held by the contract if the spender is malicious or compromised.', 'Location': 'Function `_maxApprove`'}, {'Issue': 'Potential Reentrancy Risk', 'Severity': 'High', 'Description': 'The contract interacts with external contracts (e.g., `IPangolinRouter` and `IBasketFacet`) without using the checks-effects-interactions pattern. This could potentially lead to reentrancy attacks if the external contracts are malicious or have callback mechanisms.', 'Impact': 'Potential loss of funds or manipulation of contract state due to reentrancy attacks.', 'Location': 'Functions `_joinTokenSingle` and `joinTokenSingle`'}, {'Issue': 'Unbounded Loops', 'Severity': 'High', 'Description': 'The contract contains loops that iterate over arrays of arbitrary length (e.g., `_joinTokenStruct.trades` and `trade.swaps`). This can lead to excessive gas consumption or out-of-gas errors, especially if the arrays are large.', 'Impact': 'Potential denial of service (DoS) due to out-of-gas errors, leading to failed transactions and loss of funds.', 'Location': 'Function `_joinTokenSingle`'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'The contract does not validate input parameters such as `_joinTokenStruct.inputAmount`, `_joinTokenStruct.outputAmount`, `_joinTokenStruct.inputToken`, and `_joinTokenStruct.outputBasket`. This could lead to unexpected behavior or vulnerabilities if invalid or malicious values are provided.', 'Impact': 'Potential for unexpected behavior, loss of funds, or exploitation due to invalid inputs.', 'Location': 'Functions `joinTokenSingle` and `_joinTokenSingle`'}, {'Issue': 'Lack of Deadline Enforcement', 'Severity': 'Medium', 'Description': 'The contract does not enforce the `deadline` parameter in the `JoinTokenStructV2` struct. This could lead to transactions being executed at unfavorable times, potentially resulting in financial losses.', 'Impact': 'Transactions may be executed at unfavorable times, leading to potential financial losses.', 'Location': 'Functions `joinTokenSingle` and `_joinTokenSingle`'}, {'Issue': 'Insufficient Output Amount Check', 'Severity': 'Medium', 'Description': 'The contract checks the output amount against the expected amount but does not account for slippage or provide a mechanism to handle it. This could lead to unfavorable trades or receiving fewer tokens than expected.', 'Impact': 'Potential for unfavorable trades due to slippage or receiving less than expected.', 'Location': 'Function `_joinTokenSingle`'}, {'Issue': 'Use of `uint256(-1)` for Approval', 'Severity': 'Low', 'Description': 'The contract uses `uint256(-1)` to set unlimited approval for tokens. While this is a common practice, it could lead to issues if the token contract does not handle such large values correctly.', 'Impact': 'Potential issues with token contracts that do not handle large allowance values correctly.', 'Location': 'Function `_maxApprove`'}, {'Issue': 'Use of Deprecated Solidity Version', 'Severity': 'Low', 'Description': 'The contract uses Solidity version `^0.7.5`, which is not the latest. While this is not a direct security issue, it may miss important security patches and improvements available in newer versions.', 'Impact': 'Potential missed security patches and improvements from newer Solidity versions.', 'Location': 'Pragma directive `pragma solidity ^0.7.5`'}, {'Issue': 'Insufficient Event Logging', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical operations such as token transfers, swaps, or pool joins. Event logging is important for transparency and off-chain monitoring.', 'Impact': 'Reduced transparency and difficulty in off-chain monitoring and auditing.', 'Location': 'Entire contract'}], 'IssueNumber': 15, 'OutputList': 9}",559.580139875412,"### **[H-01] Unused ERC20 tokens are not refunded, and can be stolen by attacker**

**Report Description**:
Under certain circumstances, such as when `annualizedFee` is minted to `feeBeneficiary` between the time a user sends a transaction and the transaction is packed into a block, the amounts of underlying tokens for each `basketToken` may decrease. This can result in leftover basket underlying tokens, as `BasketFacet.sol#joinPool()` only transfers the required amounts of basket tokens from Join contracts. However, the current implementation only returns the leftover `inputToken`, leaving the leftover underlying tokens unrefunded, which constitutes a loss of user funds. Additionally, the leftover tokens in the `SingleTokenJoinV2` contract can be stolen by calling `joinTokenSingle()` with a fake `outputBasket` contract and `swap.exchange` contract.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of leftover tokens not being refunded or the potential theft of these tokens. This is a significant oversight, as it directly impacts user funds and contract security.

---

### **[M-01] Function `joinTokenSingle` in `SingleTokenJoin.sol` and `SingleTokenJoinV2.sol` can be made to fail**

**Report Description**:
There is a griefing attack vulnerability in the function `joinTokenSingle` in both `SingleTokenJoin.sol` and `SingleTokenJoinV2.sol`. The `JoinTokenStruct` argument includes a field `outputAmount`, which is compared to the contract’s balance of the token. If an attacker sends some amount of a basket’s token to the contract, every call to this function will fail as long as the output token equals the attacker’s token send. This can cause user transactions to fail with the error “FAILEDOUTPUTAMOUNT”.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the griefing attack vulnerability in `joinTokenSingle`. This is a critical issue that can disrupt contract functionality and user transactions.

---

### **[M-02] Unchecked return value from low-level call()**

**Report Description**:
The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low-level call is used to prevent blocking operations, consider logging failed calls.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked return values from low-level calls. This is a significant security concern, as it can lead to Ether being locked in the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] Unused ERC20 tokens are not refunded, and can be stolen by attacker**
- **[M-01] Function `joinTokenSingle` in `SingleTokenJoin.sol` and `SingleTokenJoinV2.sol` can be made to fail**
- **[M-02] Unchecked return value from low-level call()**

---

### **Conclusion**
The `response_list` does not adequately address the issues raised in the `issue` report. Key vulnerabilities such as the theft of leftover tokens, griefing attacks, and unchecked return values from low-level calls are entirely missed. This indicates significant gaps in the coverage, accuracy, and sufficiency of the responses provided.","```
None.
```",0.0
BasketFact.sol,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../../interfaces/IBasketFacet.sol"";
import ""../ERC20/LibERC20Storage.sol"";
import ""../ERC20/LibERC20.sol"";
import ""../shared/Reentry/ReentryProtection.sol"";
import ""../shared/Access/CallProtection.sol"";
import ""./LibBasketStorage.sol"";

contract BasketFacet is ReentryProtection, CallProtection, IBasketFacet {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MIN_AMOUNT = 10**6;
    uint256 public constant MAX_ENTRY_FEE = 10**17; // 10%
    uint256 public constant MAX_EXIT_FEE = 10**17; // 10%
    uint256 public constant MAX_ANNUAL_FEE = 10**17; // 10%
    uint256 public constant HUNDRED_PERCENT = 10**18;

    // Assuming a block gas limit of 12M this allows for a gas consumption per token of roughly 333k allowing 2M of overhead for addtional operations
    uint256 public constant MAX_TOKENS = 30;

    function addToken(address _token) external override protectedCall {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        require(!bs.inPool[_token], ""TOKEN_ALREADY_IN_POOL"");
        require(bs.tokens.length < MAX_TOKENS, ""TOKEN_LIMIT_REACHED"");
        // Enforce minimum to avoid rounding errors; (Minimum value is the same as in Balancer)
        require(balance(_token) >= MIN_AMOUNT, ""BALANCE_TOO_SMALL"");

        bs.inPool[_token] = true;
        bs.tokens.push(IERC20(_token));

        emit TokenAdded(_token);
    }

    function removeToken(address _token) external override protectedCall {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();

        require(bs.inPool[_token], ""TOKEN_NOT_IN_POOL"");

        bs.inPool[_token] = false;

        // remove token from array
        for (uint256 i; i < bs.tokens.length; i++) {
            if (address(bs.tokens[i]) == _token) {
                bs.tokens[i] = bs.tokens[bs.tokens.length - 1];
                bs.tokens.pop();
                emit TokenRemoved(_token);
                break;
            }
        }
    }

    function setEntryFee(uint256 _fee) external override protectedCall {
        require(_fee <= MAX_ENTRY_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().entryFee = _fee;
        emit EntryFeeSet(_fee);
    }

    function getEntryFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().entryFee;
    }

    function setExitFee(uint256 _fee) external override protectedCall {
        require(_fee <= MAX_EXIT_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().exitFee = _fee;
        emit ExitFeeSet(_fee);
    }

    function getExitFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().exitFee;
    }

    function setAnnualizedFee(uint256 _fee) external override protectedCall {
        chargeOutstandingAnnualizedFee();
        require(_fee <= MAX_ANNUAL_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().annualizedFee = _fee;
        emit AnnualizedFeeSet(_fee);
    }

    function getAnnualizedFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().annualizedFee;
    }

    function setFeeBeneficiary(address _beneficiary)
        external
        override
        protectedCall
    {
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.basketStorage().feeBeneficiary = _beneficiary;
        emit FeeBeneficiarySet(_beneficiary);
    }

    function getFeeBeneficiary() external view override returns (address) {
        return LibBasketStorage.basketStorage().feeBeneficiary;
    }

    function setEntryFeeBeneficiaryShare(uint256 _share)
        external
        override
        protectedCall
    {
        require(_share <= HUNDRED_PERCENT, ""FEE_SHARE_TOO_BIG"");
        LibBasketStorage.basketStorage().entryFeeBeneficiaryShare = _share;
        emit EntryFeeBeneficiaryShareSet(_share);
    }

    function getEntryFeeBeneficiaryShare()
        external
        view
        override
        returns (uint256)
    {
        return LibBasketStorage.basketStorage().entryFeeBeneficiaryShare;
    }

    function setExitFeeBeneficiaryShare(uint256 _share)
        external
        override
        protectedCall
    {
        require(_share <= HUNDRED_PERCENT, ""FEE_SHARE_TOO_BIG"");
        LibBasketStorage.basketStorage().exitFeeBeneficiaryShare = _share;
        emit ExitFeeBeneficiaryShareSet(_share);
    }

    function getExitFeeBeneficiaryShare()
        external
        view
        override
        returns (uint256)
    {
        return LibBasketStorage.basketStorage().exitFeeBeneficiaryShare;
    }

    function joinPool(uint256 _amount, uint16 _referral)
        external
        override
        noReentry
    {
        require(!this.getLock(), ""POOL_LOCKED"");
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;
        require(
            totalSupply.add(_amount) <= this.getCap(),
            ""MAX_POOL_CAP_REACHED""
        );

        uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenAmount =
                balance(address(token)).mul(_amount.add(feeAmount)).div(
                    totalSupply
                );
            require(tokenAmount != 0, ""AMOUNT_TOO_SMALL"");
            token.safeTransferFrom(msg.sender, address(this), tokenAmount);
        }

        // If there is any fee that should go to the beneficiary mint it
        if (
            feeAmount != 0 &&
            bs.entryFeeBeneficiaryShare != 0 &&
            bs.feeBeneficiary != address(0)
        ) {
            uint256 feeBeneficiaryShare =
                feeAmount.mul(bs.entryFeeBeneficiaryShare).div(10**18);
            if (feeBeneficiaryShare != 0) {
                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);
            }
        }

        LibERC20.mint(msg.sender, _amount);
        emit PoolJoined(msg.sender, _amount, _referral);
    }

    // Must be overwritten to withdraw from strategies
    function exitPool(uint256 _amount, uint16 _referral)
        external
        virtual
        override
        noReentry
    {
        require(!this.getLock(), ""POOL_LOCKED"");
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;

        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            // redeem less tokens if there is an exit fee
            uint256 tokenAmount =
                tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);
            require(
                tokenBalance.sub(tokenAmount) >= MIN_AMOUNT,
                ""TOKEN_BALANCE_TOO_LOW""
            );
            token.safeTransfer(msg.sender, tokenAmount);
        }

        // If there is any fee that should go to the beneficiary mint it
        if (
            feeAmount != 0 &&
            bs.exitFeeBeneficiaryShare != 0 &&
            bs.feeBeneficiary != address(0)
        ) {
            uint256 feeBeneficiaryShare =
                feeAmount.mul(bs.exitFeeBeneficiaryShare).div(10**18);
            if (feeBeneficiaryShare != 0) {
                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);
            }
        }

        require(
            totalSupply.sub(_amount) >= MIN_AMOUNT,
            ""POOL_TOKEN_BALANCE_TOO_LOW""
        );
        LibERC20.burn(msg.sender, _amount);
        emit PoolExited(msg.sender, _amount, _referral);
    }

    function calcOutStandingAnnualizedFee()
        public
        view
        override
        returns (uint256)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;

        uint256 lastFeeClaimed = bs.lastAnnualizedFeeClaimed;
        uint256 annualizedFee = bs.annualizedFee;

        if (
            annualizedFee == 0 ||
            bs.feeBeneficiary == address(0) ||
            lastFeeClaimed == 0
        ) {
            return 0;
        }

        uint256 timePassed = block.timestamp.sub(lastFeeClaimed);

        return
            totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(
                365 days
            );
    }

    function chargeOutstandingAnnualizedFee() public override {
        uint256 outStandingFee = calcOutStandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();

        bs.lastAnnualizedFeeClaimed = block.timestamp;

        // if there is any fee to mint and the beneficiary is set
        // note: feeBeneficiary is already checked in calc function
        if (outStandingFee != 0) {
            LibERC20.mint(bs.feeBeneficiary, outStandingFee);
        }

        emit FeeCharged(outStandingFee);
    }

    // returns true when locked
    function getLock() external view override returns (bool) {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        return bs.lockBlock == 0 || bs.lockBlock >= block.number;
    }

    function getTokenInPool(address _token)
        external
        view
        override
        returns (bool)
    {
        return LibBasketStorage.basketStorage().inPool[_token];
    }

    function getLockBlock() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().lockBlock;
    }

    // lock up to and including _lock blocknumber
    function setLock(uint256 _lock) external override protectedCall {
        LibBasketStorage.basketStorage().lockBlock = _lock;
        emit LockSet(_lock);
    }

    function setCap(uint256 _maxCap) external override protectedCall {
        LibBasketStorage.basketStorage().maxCap = _maxCap;
        emit CapSet(_maxCap);
    }

    // Seperated balance function to allow yearn like strategies to be hooked up by inheriting from this contract and overriding
    function balance(address _token) public view override returns (uint256) {
        return IERC20(_token).balanceOf(address(this));
    }

    function getTokens() external view override returns (address[] memory) {
        IERC20[] memory tokens = LibBasketStorage.basketStorage().tokens;
        address[] memory result = new address[](tokens.length);

        for (uint256 i = 0; i < tokens.length; i++) {
            result[i] = address(tokens[i]);
        }

        return (result);
    }

    function getCap() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().maxCap;
    }

    function calcTokensForAmount(uint256 _amount)
        external
        view
        override
        returns (address[] memory tokens, uint256[] memory amounts)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply =
            LibERC20Storage.erc20Storage().totalSupply.add(
                calcOutStandingAnnualizedFee()
            );

        tokens = new address[](bs.tokens.length);
        amounts = new uint256[](bs.tokens.length);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            uint256 tokenAmount = tokenBalance.mul(_amount).div(totalSupply);
            // Add entry fee
            tokenAmount = tokenAmount.add(
                tokenAmount.mul(bs.entryFee).div(10**18)
            );

            tokens[i] = address(token);
            amounts[i] = tokenAmount;
        }

        return (tokens, amounts);
    }

    function calcTokensForAmountExit(uint256 _amount)
        external
        view
        override
        returns (address[] memory tokens, uint256[] memory amounts)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);
        uint256 totalSupply =
            LibERC20Storage.erc20Storage().totalSupply.add(
                calcOutStandingAnnualizedFee()
            );

        tokens = new address[](bs.tokens.length);
        amounts = new uint256[](bs.tokens.length);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            uint256 tokenAmount =
                tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);

            tokens[i] = address(token);
            amounts[i] = tokenAmount;
        }

        return (tokens, amounts);
    }
}",2966,393,"[H-02] It might not be possible to withdraw tokens from the basket

Submitted by Czar102, also found by csanuragjain
Impact

When enough basket token owners exit, it will be impossible to exit pool with the last `MIN_AMOUNT` tokens because of this check. This will result in locking some tokens forever.
  [M-04] Annualized fee APY dependence on the frequency of executing a function

Submitted by Czar102
Impact

The APY of the annualized fee is dependent on the frequency of the execution of the BasketFacet::chargeOutstandingAnnualizedFee(). If it is called more frequently, the compounding is more frequent and the APY is higher. For less used baskets, the APY might be lower, because the compounding will happen at lower rate.
  [M-05] totalSupply may exceed `LibBasketStorage.basketStorage().maxCap`

Submitted by Czar102, also found by gpersoon, gzeon, kenzo, and WatchPug
Impact

Total supply of the token may exceed the maxCap introduced. This can happen when a user wants to join the pool. The check in BasketFacet::joinPool(...) includes only the base amount, without fee. Thus, if fee is on and someone will want to create as many tokens as possible, the totalSupply + _amount will be set to maxCap. The call will succeed, but new tokens were also minted as the fee for bs.feeBeneficiary if bs.entryFee and bs.entryFeeBeneficiaryShare are nonzero. Thus, the number of tokens may exceed maxCap.
  [M-10] fees calculations are not accurate

Function `calcOutStandingAnnualizedFee`
after that fee is calculated, it is minted to the feeBeneficiary. simply minting the exact amount results lower fee than it should be.
Impact

feeBeneficiary will get less fees than it should.
Proof of Concept

let’s assume that the basket assets are worth 1M dollars, and totalSupply = 1M. the result of calcOutStandingAnnualizedFee is 100,00 so the feeBeneficiary should get 100,00 dollars. however, when minting 100,00 the totalSupply will increase to 1,100,000 so they will own 100000/1100000 * (1M dollars) = 90909.09 dollars instead of 100k
",4,,"pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../../interfaces/IBasketFacet.sol"";
import ""../ERC20/LibERC20Storage.sol"";
import ""../ERC20/LibERC20.sol"";
import ""../shared/Reentry/ReentryProtection.sol"";
import ""../shared/Access/CallProtection.sol"";
import ""./LibBasketStorage.sol"";

contract BasketFacet is ReentryProtection, CallProtection, IBasketFacet {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MIN_AMOUNT = 10**6;
    uint256 public constant MAX_ENTRY_FEE = 10**17; 
    uint256 public constant MAX_EXIT_FEE = 10**17; 
    uint256 public constant MAX_ANNUAL_FEE = 10**17; 
    uint256 public constant HUNDRED_PERCENT = 10**18;

    
    uint256 public constant MAX_TOKENS = 30;

    function addToken(address _token) external override protectedCall {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        require(!bs.inPool[_token], ""TOKEN_ALREADY_IN_POOL"");
        require(bs.tokens.length < MAX_TOKENS, ""TOKEN_LIMIT_REACHED"");
        
        require(balance(_token) >= MIN_AMOUNT, ""BALANCE_TOO_SMALL"");

        bs.inPool[_token] = true;
        bs.tokens.push(IERC20(_token));

        emit TokenAdded(_token);
    }

    function removeToken(address _token) external override protectedCall {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();

        require(bs.inPool[_token], ""TOKEN_NOT_IN_POOL"");

        bs.inPool[_token] = false;

        
        for (uint256 i; i < bs.tokens.length; i++) {
            if (address(bs.tokens[i]) == _token) {
                bs.tokens[i] = bs.tokens[bs.tokens.length - 1];
                bs.tokens.pop();
                emit TokenRemoved(_token);
                break;
            }
        }
    }

    function setEntryFee(uint256 _fee) external override protectedCall {
        require(_fee <= MAX_ENTRY_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().entryFee = _fee;
        emit EntryFeeSet(_fee);
    }

    function getEntryFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().entryFee;
    }

    function setExitFee(uint256 _fee) external override protectedCall {
        require(_fee <= MAX_EXIT_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().exitFee = _fee;
        emit ExitFeeSet(_fee);
    }

    function getExitFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().exitFee;
    }

    function setAnnualizedFee(uint256 _fee) external override protectedCall {
        chargeOutstandingAnnualizedFee();
        require(_fee <= MAX_ANNUAL_FEE, ""FEE_TOO_BIG"");
        LibBasketStorage.basketStorage().annualizedFee = _fee;
        emit AnnualizedFeeSet(_fee);
    }

    function getAnnualizedFee() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().annualizedFee;
    }

    function setFeeBeneficiary(address _beneficiary)
        external
        override
        protectedCall
    {
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.basketStorage().feeBeneficiary = _beneficiary;
        emit FeeBeneficiarySet(_beneficiary);
    }

    function getFeeBeneficiary() external view override returns (address) {
        return LibBasketStorage.basketStorage().feeBeneficiary;
    }

    function setEntryFeeBeneficiaryShare(uint256 _share)
        external
        override
        protectedCall
    {
        require(_share <= HUNDRED_PERCENT, ""FEE_SHARE_TOO_BIG"");
        LibBasketStorage.basketStorage().entryFeeBeneficiaryShare = _share;
        emit EntryFeeBeneficiaryShareSet(_share);
    }

    function getEntryFeeBeneficiaryShare()
        external
        view
        override
        returns (uint256)
    {
        return LibBasketStorage.basketStorage().entryFeeBeneficiaryShare;
    }

    function setExitFeeBeneficiaryShare(uint256 _share)
        external
        override
        protectedCall
    {
        require(_share <= HUNDRED_PERCENT, ""FEE_SHARE_TOO_BIG"");
        LibBasketStorage.basketStorage().exitFeeBeneficiaryShare = _share;
        emit ExitFeeBeneficiaryShareSet(_share);
    }

    function getExitFeeBeneficiaryShare()
        external
        view
        override
        returns (uint256)
    {
        return LibBasketStorage.basketStorage().exitFeeBeneficiaryShare;
    }

    function joinPool(uint256 _amount, uint16 _referral)
        external
        override
        noReentry
    {
        require(!this.getLock(), ""POOL_LOCKED"");
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;
        require(
            totalSupply.add(_amount) <= this.getCap(),
            ""MAX_POOL_CAP_REACHED""
        );

        uint256 feeAmount = _amount.mul(bs.entryFee).div(10**18);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenAmount =
                balance(address(token)).mul(_amount.add(feeAmount)).div(
                    totalSupply
                );
            require(tokenAmount != 0, ""AMOUNT_TOO_SMALL"");
            token.safeTransferFrom(msg.sender, address(this), tokenAmount);
        }

        
        if (
            feeAmount != 0 &&
            bs.entryFeeBeneficiaryShare != 0 &&
            bs.feeBeneficiary != address(0)
        ) {
            uint256 feeBeneficiaryShare =
                feeAmount.mul(bs.entryFeeBeneficiaryShare).div(10**18);
            if (feeBeneficiaryShare != 0) {
                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);
            }
        }

        LibERC20.mint(msg.sender, _amount);
        emit PoolJoined(msg.sender, _amount, _referral);
    }

    
    function exitPool(uint256 _amount, uint16 _referral)
        external
        virtual
        override
        noReentry
    {
        require(!this.getLock(), ""POOL_LOCKED"");
        chargeOutstandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;

        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            
            uint256 tokenAmount =
                tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);
            require(
                tokenBalance.sub(tokenAmount) >= MIN_AMOUNT,
                ""TOKEN_BALANCE_TOO_LOW""
            );
            token.safeTransfer(msg.sender, tokenAmount);
        }

        
        if (
            feeAmount != 0 &&
            bs.exitFeeBeneficiaryShare != 0 &&
            bs.feeBeneficiary != address(0)
        ) {
            uint256 feeBeneficiaryShare =
                feeAmount.mul(bs.exitFeeBeneficiaryShare).div(10**18);
            if (feeBeneficiaryShare != 0) {
                LibERC20.mint(bs.feeBeneficiary, feeBeneficiaryShare);
            }
        }

        require(
            totalSupply.sub(_amount) >= MIN_AMOUNT,
            ""POOL_TOKEN_BALANCE_TOO_LOW""
        );
        LibERC20.burn(msg.sender, _amount);
        emit PoolExited(msg.sender, _amount, _referral);
    }

    function calcOutStandingAnnualizedFee()
        public
        view
        override
        returns (uint256)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply = LibERC20Storage.erc20Storage().totalSupply;

        uint256 lastFeeClaimed = bs.lastAnnualizedFeeClaimed;
        uint256 annualizedFee = bs.annualizedFee;

        if (
            annualizedFee == 0 ||
            bs.feeBeneficiary == address(0) ||
            lastFeeClaimed == 0
        ) {
            return 0;
        }

        uint256 timePassed = block.timestamp.sub(lastFeeClaimed);

        return
            totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(
                365 days
            );
    }

    function chargeOutstandingAnnualizedFee() public override {
        uint256 outStandingFee = calcOutStandingAnnualizedFee();
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();

        bs.lastAnnualizedFeeClaimed = block.timestamp;

        
        
        if (outStandingFee != 0) {
            LibERC20.mint(bs.feeBeneficiary, outStandingFee);
        }

        emit FeeCharged(outStandingFee);
    }

    
    function getLock() external view override returns (bool) {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        return bs.lockBlock == 0 || bs.lockBlock >= block.number;
    }

    function getTokenInPool(address _token)
        external
        view
        override
        returns (bool)
    {
        return LibBasketStorage.basketStorage().inPool[_token];
    }

    function getLockBlock() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().lockBlock;
    }

    
    function setLock(uint256 _lock) external override protectedCall {
        LibBasketStorage.basketStorage().lockBlock = _lock;
        emit LockSet(_lock);
    }

    function setCap(uint256 _maxCap) external override protectedCall {
        LibBasketStorage.basketStorage().maxCap = _maxCap;
        emit CapSet(_maxCap);
    }

    
    function balance(address _token) public view override returns (uint256) {
        return IERC20(_token).balanceOf(address(this));
    }

    function getTokens() external view override returns (address[] memory) {
        IERC20[] memory tokens = LibBasketStorage.basketStorage().tokens;
        address[] memory result = new address[](tokens.length);

        for (uint256 i = 0; i < tokens.length; i++) {
            result[i] = address(tokens[i]);
        }

        return (result);
    }

    function getCap() external view override returns (uint256) {
        return LibBasketStorage.basketStorage().maxCap;
    }

    function calcTokensForAmount(uint256 _amount)
        external
        view
        override
        returns (address[] memory tokens, uint256[] memory amounts)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 totalSupply =
            LibERC20Storage.erc20Storage().totalSupply.add(
                calcOutStandingAnnualizedFee()
            );

        tokens = new address[](bs.tokens.length);
        amounts = new uint256[](bs.tokens.length);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            uint256 tokenAmount = tokenBalance.mul(_amount).div(totalSupply);
            
            tokenAmount = tokenAmount.add(
                tokenAmount.mul(bs.entryFee).div(10**18)
            );

            tokens[i] = address(token);
            amounts[i] = tokenAmount;
        }

        return (tokens, amounts);
    }

    function calcTokensForAmountExit(uint256 _amount)
        external
        view
        override
        returns (address[] memory tokens, uint256[] memory amounts)
    {
        LibBasketStorage.BasketStorage storage bs =
            LibBasketStorage.basketStorage();
        uint256 feeAmount = _amount.mul(bs.exitFee).div(10**18);
        uint256 totalSupply =
            LibERC20Storage.erc20Storage().totalSupply.add(
                calcOutStandingAnnualizedFee()
            );

        tokens = new address[](bs.tokens.length);
        amounts = new uint256[](bs.tokens.length);

        for (uint256 i; i < bs.tokens.length; i++) {
            IERC20 token = bs.tokens[i];
            uint256 tokenBalance = balance(address(token));
            uint256 tokenAmount =
                tokenBalance.mul(_amount.sub(feeAmount)).div(totalSupply);

            tokens[i] = address(token);
            amounts[i] = tokenAmount;
        }

        return (tokens, amounts);
    }
}",2764,1,3,,"{'ReviewingTheCode': ""The provided code snippet is a Solidity smart contract named 'BasketFacet' that manages a basket of ERC20 tokens. It includes functionalities for adding/removing tokens, setting fees, and handling pool joins/exits. The contract uses OpenZeppelin libraries for safe math and ERC20 operations, and it implements reentrancy protection and call protection mechanisms."", 'IdentifyingKeyComponents': {'ContractName': 'BasketFacet', 'Purpose': 'To manage a basket of ERC20 tokens, allowing users to join/exit the pool, set fees, and manage token compositions.', 'InheritanceAndImports': {'InheritsFrom': ['ReentryProtection', 'CallProtection', 'IBasketFacet'], 'Imports': ['@openzeppelin/contracts/math/SafeMath.sol', '@openzeppelin/contracts/token/ERC20/SafeERC20.sol', '../../interfaces/IBasketFacet.sol', '../ERC20/LibERC20Storage.sol', '../ERC20/LibERC20.sol', '../shared/Reentry/ReentryProtection.sol', '../shared/Access/CallProtection.sol', './LibBasketStorage.sol']}, 'StateVariables': [{'Name': 'MIN_AMOUNT', 'Type': 'uint256', 'Purpose': 'Minimum amount required for token operations.'}, {'Name': 'MAX_ENTRY_FEE', 'Type': 'uint256', 'Purpose': 'Maximum allowable entry fee.'}, {'Name': 'MAX_EXIT_FEE', 'Type': 'uint256', 'Purpose': 'Maximum allowable exit fee.'}, {'Name': 'MAX_ANNUAL_FEE', 'Type': 'uint256', 'Purpose': 'Maximum allowable annualized fee.'}, {'Name': 'HUNDRED_PERCENT', 'Type': 'uint256', 'Purpose': 'Represents 100% in fee calculations.'}, {'Name': 'MAX_TOKENS', 'Type': 'uint256', 'Purpose': 'Maximum number of tokens allowed in the basket.'}], 'FunctionsAndModifiers': [{'Name': 'addToken', 'Visibility': 'external', 'Purpose': 'Adds a token to the basket.', 'Parameters': ['address _token'], 'Returns': []}, {'Name': 'removeToken', 'Visibility': 'external', 'Purpose': 'Removes a token from the basket.', 'Parameters': ['address _token'], 'Returns': []}, {'Name': 'setEntryFee', 'Visibility': 'external', 'Purpose': 'Sets the entry fee for the pool.', 'Parameters': ['uint256 _fee'], 'Returns': []}, {'Name': 'getEntryFee', 'Visibility': 'external', 'Purpose': 'Returns the current entry fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'setExitFee', 'Visibility': 'external', 'Purpose': 'Sets the exit fee for the pool.', 'Parameters': ['uint256 _fee'], 'Returns': []}, {'Name': 'getExitFee', 'Visibility': 'external', 'Purpose': 'Returns the current exit fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'setAnnualizedFee', 'Visibility': 'external', 'Purpose': 'Sets the annualized fee for the pool.', 'Parameters': ['uint256 _fee'], 'Returns': []}, {'Name': 'getAnnualizedFee', 'Visibility': 'external', 'Purpose': 'Returns the current annualized fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'setFeeBeneficiary', 'Visibility': 'external', 'Purpose': 'Sets the beneficiary address for fees.', 'Parameters': ['address _beneficiary'], 'Returns': []}, {'Name': 'getFeeBeneficiary', 'Visibility': 'external', 'Purpose': 'Returns the current fee beneficiary address.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'setEntryFeeBeneficiaryShare', 'Visibility': 'external', 'Purpose': 'Sets the beneficiary share for entry fees.', 'Parameters': ['uint256 _share'], 'Returns': []}, {'Name': 'getEntryFeeBeneficiaryShare', 'Visibility': 'external', 'Purpose': 'Returns the current entry fee beneficiary share.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'setExitFeeBeneficiaryShare', 'Visibility': 'external', 'Purpose': 'Sets the beneficiary share for exit fees.', 'Parameters': ['uint256 _share'], 'Returns': []}, {'Name': 'getExitFeeBeneficiaryShare', 'Visibility': 'external', 'Purpose': 'Returns the current exit fee beneficiary share.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'joinPool', 'Visibility': 'external', 'Purpose': 'Allows a user to join the pool by depositing tokens.', 'Parameters': ['uint256 _amount', 'uint16 _referral'], 'Returns': []}, {'Name': 'exitPool', 'Visibility': 'external', 'Purpose': 'Allows a user to exit the pool by withdrawing tokens.', 'Parameters': ['uint256 _amount', 'uint16 _referral'], 'Returns': []}, {'Name': 'calcOutStandingAnnualizedFee', 'Visibility': 'public', 'Purpose': 'Calculates the outstanding annualized fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'chargeOutstandingAnnualizedFee', 'Visibility': 'public', 'Purpose': 'Charges the outstanding annualized fee.', 'Parameters': [], 'Returns': []}, {'Name': 'getLock', 'Visibility': 'external', 'Purpose': 'Returns whether the pool is locked.', 'Parameters': [], 'Returns': ['bool']}, {'Name': 'getTokenInPool', 'Visibility': 'external', 'Purpose': 'Checks if a token is in the pool.', 'Parameters': ['address _token'], 'Returns': ['bool']}, {'Name': 'getLockBlock', 'Visibility': 'external', 'Purpose': 'Returns the lock block number.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'setLock', 'Visibility': 'external', 'Purpose': 'Sets the lock block number.', 'Parameters': ['uint256 _lock'], 'Returns': []}, {'Name': 'setCap', 'Visibility': 'external', 'Purpose': 'Sets the maximum cap for the pool.', 'Parameters': ['uint256 _maxCap'], 'Returns': []}, {'Name': 'balance', 'Visibility': 'public', 'Purpose': 'Returns the balance of a token in the contract.', 'Parameters': ['address _token'], 'Returns': ['uint256']}, {'Name': 'getTokens', 'Visibility': 'external', 'Purpose': 'Returns the list of tokens in the basket.', 'Parameters': [], 'Returns': ['address[] memory']}, {'Name': 'getCap', 'Visibility': 'external', 'Purpose': 'Returns the maximum cap for the pool.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'calcTokensForAmount', 'Visibility': 'external', 'Purpose': 'Calculates the token amounts required for a given pool amount.', 'Parameters': ['uint256 _amount'], 'Returns': ['address[] memory tokens', 'uint256[] memory amounts']}, {'Name': 'calcTokensForAmountExit', 'Visibility': 'external', 'Purpose': 'Calculates the token amounts returned for a given pool exit amount.', 'Parameters': ['uint256 _amount'], 'Returns': ['address[] memory tokens', 'uint256[] memory amounts']}]}, 'ExternalInteractions': [""OpenZeppelin's SafeMath and SafeERC20 libraries"", 'IBasketFacet interface', 'LibERC20Storage and LibERC20 libraries', 'ReentryProtection and CallProtection contracts', 'LibBasketStorage library'], 'SpecialMechanisms': ['Reentrancy protection to prevent multiple calls during a single transaction.', 'Call protection to restrict certain functions to specific callers.', 'Fee calculation and distribution mechanisms for entry, exit, and annualized fees.', 'Token basket management with a cap on the number of tokens.'], 'Questions': [""How is the 'protectedCall' modifier implemented and what are its restrictions?"", ""What is the purpose of the 'noReentry' modifier and how does it differ from 'protectedCall'?"", 'Are there any potential vulnerabilities in the fee calculation and distribution mechanisms?', ""How is the 'chargeOutstandingAnnualizedFee' function triggered and what are its implications?"", 'What are the gas implications of the token basket management functions, especially with a large number of tokens?']}","{'Findings': [{'Issue': 'Potential Reentrancy in `joinPool` and `exitPool` Functions', 'Severity': 'High', 'Description': 'The `joinPool` and `exitPool` functions involve external calls to `safeTransferFrom` and `safeTransfer`, respectively. Although the `noReentry` modifier is used, its effectiveness is unclear, and it may not fully protect against reentrancy attacks during these external calls. An attacker could potentially exploit this by calling back into the contract before the state is fully updated.', 'Impact': 'An attacker could reenter the contract and manipulate the state, leading to loss of funds or other unexpected behavior.', 'Location': '`joinPool` and `exitPool` functions'}, {'Issue': 'Unsafe External Token Transfers', 'Severity': 'High', 'Description': 'The `joinPool` and `exitPool` functions use `safeTransferFrom` and `safeTransfer` methods from the `SafeERC20` library. The contract does not verify the return value of these calls, which could lead to silent failures if the ERC20 token does not revert on failure but instead returns `false`.', 'Impact': 'Silent failures in token transfers could result in users losing funds or the contract state becoming inconsistent.', 'Location': '`joinPool` and `exitPool` functions'}, {'Issue': 'Missing ERC-20 Compliance Check in `LibERC20` Functions', 'Severity': 'High', 'Description': 'The contract uses `LibERC20` for minting and burning tokens, but it does not explicitly verify that these functions adhere to the ERC-20 standard. This could lead to non-compliance with ERC-20, potentially causing issues with interoperability and integration with other contracts or platforms.', 'Impact': 'Non-compliance with ERC-20 standards could result in failed transactions, loss of funds, or incompatibility with wallets and exchanges.', 'Location': '`LibERC20.mint` and `LibERC20.burn` functions'}, {'Issue': 'Incorrect Token Removal Logic', 'Severity': 'High', 'Description': 'The `removeToken` function attempts to remove a token by replacing it with the last token in the array and then popping the last element. However, if the token to be removed is the last element, it will still be replaced with itself, leading to an incorrect state. Additionally, the function does not check if the token exists in the array before attempting to remove it.', 'Impact': 'This could lead to incorrect token management, potentially causing tokens to be lost or the contract to enter an inconsistent state.', 'Location': '`removeToken` function'}, {'Issue': 'Incorrect Token Amount Calculation on Exit', 'Severity': 'High', 'Description': 'The `calcTokensForAmountExit` function calculates the token amounts to be transferred out of the pool after deducting the exit fee. However, it does not account for the possibility of the exit fee being zero or the fee beneficiary share being unset, which could lead to incorrect token amount calculations.', 'Impact': 'Incorrect token amount calculations could result in users receiving fewer tokens than they should, leading to financial losses or unfair distribution of tokens.', 'Location': '`calcTokensForAmountExit` function'}, {'Issue': 'Potential Division by Zero', 'Severity': 'High', 'Description': 'The `calcTokensForAmount` and `calcTokensForAmountExit` functions perform division operations without checking if the divisor is zero. This could lead to division by zero errors if the total supply of tokens is zero or if the fee calculations result in a zero value.', 'Impact': 'Division by zero errors could cause the contract to revert, leading to denial of service or incorrect token amount calculations.', 'Location': '`calcTokensForAmount` and `calcTokensForAmountExit` functions'}, {'Issue': 'Incorrect Token Amount Calculation on Entry', 'Severity': 'High', 'Description': 'The `calcTokensForAmount` function calculates the token amounts to be transferred into the pool after adding the entry fee. However, it does not account for the possibility of the entry fee being zero or the fee beneficiary share being unset, which could lead to incorrect token amount calculations.', 'Impact': 'Incorrect token amount calculations could result in users transferring more tokens than they should, leading to financial losses or unfair distribution of tokens.', 'Location': '`calcTokensForAmount` function'}, {'Issue': 'High Gas Consumption in `joinPool` and `exitPool` Functions', 'Severity': 'High', 'Description': 'The `joinPool` and `exitPool` functions iterate over all tokens in the pool to transfer the required amounts, involving external calls to `safeTransferFrom` and `safeTransfer`. This can result in high gas consumption, especially when the number of tokens is large (up to `MAX_TOKENS` which is 30).', 'Impact': 'Users may face high transaction costs, making the functions economically unfeasible for large token sets.', 'Location': '`joinPool` and `exitPool` functions'}, {'Issue': 'Unverified `protectedCall` Modifier Implementation', 'Severity': 'High', 'Description': 'The `protectedCall` modifier is used extensively throughout the contract to restrict access to sensitive functions such as `setEntryFee`, `setCap`, and others. However, the implementation of the `protectedCall` modifier is not provided, making it impossible to verify that it correctly restricts access to authorized callers only.', 'Impact': 'If the `protectedCall` modifier is not implemented correctly, unauthorized users could potentially call sensitive functions, leading to manipulation of contract state, unauthorized fee changes, or other malicious actions.', 'Location': 'Functions: `setEntryFee`, `setCap`, `setExitFee`, `setAnnualizedFee`, `setFeeBeneficiary`, `setEntryFeeBeneficiaryShare`, `setExitFeeBeneficiaryShare`, `setLock`, etc.'}, {'Issue': 'Arithmetic Operations Without SafeMath', 'Severity': 'Medium', 'Description': 'The code uses `SafeMath` for arithmetic operations, but there are instances where arithmetic operations are performed without explicit checks for overflow/underflow. For example, in `calcOutStandingAnnualizedFee`, the calculation `totalSupply.mul(annualizedFee).div(10**18).mul(timePassed).div(365 days)` could potentially lead to overflow if not handled correctly.', 'Impact': 'Arithmetic overflow/underflow could lead to incorrect calculations, potentially causing financial losses or other unintended behavior.', 'Location': '`calcOutStandingAnnualizedFee` function'}, {'Issue': 'Improper Handling of External Calls', 'Severity': 'Medium', 'Description': 'The `safeTransferFrom` and `safeTransfer` calls in `joinPool` and `exitPool` are not followed by state updates that could prevent reentrancy. Additionally, there is no check for the success of these external calls, which could lead to unexpected behavior if the transfer fails.', 'Impact': 'Failure to properly handle external calls could result in loss of funds or other unintended consequences.', 'Location': '`joinPool` and `exitPool` functions'}, {'Issue': 'Fee Calculation Vulnerability in `chargeOutstandingAnnualizedFee`', 'Severity': 'Medium', 'Description': 'The `chargeOutstandingAnnualizedFee` function calculates the outstanding fee based on the time passed since the last fee claim. However, there is no check to ensure that the `lastAnnualizedFeeClaimed` timestamp is not in the future, which could lead to incorrect fee calculations.', 'Impact': 'Incorrect fee calculations could result in overcharging or undercharging fees, leading to financial discrepancies.', 'Location': '`chargeOutstandingAnnualizedFee` function'}, {'Issue': 'Fee Limit Enforcement in `setEntryFee` and `setExitFee`', 'Severity': 'Medium', 'Description': 'The `setEntryFee` and `setExitFee` functions enforce maximum fee limits (`MAX_ENTRY_FEE` and `MAX_EXIT_FEE`), but there is no mechanism to ensure that these limits are not bypassed or manipulated during runtime. This could lead to unexpected fee structures.', 'Impact': 'Potential for setting fees higher than intended, leading to unfair charges or exploitation.', 'Location': '`setEntryFee` and `setExitFee` functions'}, {'Issue': 'Potential Reentrancy in Fee Charging', 'Severity': 'Medium', 'Description': 'The `chargeOutstandingAnnualizedFee` function mints tokens to the fee beneficiary without any reentrancy protection. This could potentially allow a malicious fee beneficiary to reenter the contract and manipulate the fee calculation or token minting process.', 'Impact': 'Reentrancy attacks could lead to incorrect fee calculations or token minting, potentially causing financial losses or unfair distribution of fees.', 'Location': '`chargeOutstandingAnnualizedFee` function'}, {'Issue': 'Potential Token Limit Overflow', 'Severity': 'Medium', 'Description': 'The `addToken` function allows adding tokens up to a maximum limit (`MAX_TOKENS`). However, there is no check to ensure that the token array does not exceed the maximum limit before adding a new token. This could lead to an overflow if the array size exceeds the maximum limit.', 'Impact': 'Exceeding the token limit could cause unexpected behavior or errors in the contract, potentially leading to denial of service or incorrect token management.', 'Location': '`addToken` function'}, {'Issue': 'Inaccurate Fee Calculation', 'Severity': 'Medium', 'Description': 'The `calcOutStandingAnnualizedFee` function calculates the outstanding annualized fee based on the time passed since the last fee claim. However, it does not account for the possibility of the fee being set to zero or the fee beneficiary being unset, which could lead to incorrect fee calculations.', 'Impact': 'Incorrect fee calculations could result in overcharging or undercharging of fees, leading to financial losses or unfair distribution of fees.', 'Location': '`calcOutStandingAnnualizedFee` function'}, {'Issue': 'Potential Out-of-Gas Errors', 'Severity': 'Medium', 'Description': 'Both `joinPool` and `exitPool` functions involve loops that iterate over all tokens in the pool. If the number of tokens is large, these loops could potentially run out of gas, causing the transaction to fail.', 'Impact': 'Transactions could fail due to out-of-gas errors, leading to a poor user experience and potential loss of funds if not handled correctly.', 'Location': '`joinPool` and `exitPool` functions'}, {'Issue': 'Sensitive Functions Protected Only by `protectedCall` Modifier', 'Severity': 'Medium', 'Description': 'Sensitive functions such as `setEntryFee`, `setCap`, and others are protected only by the `protectedCall` modifier. While this is a good practice, relying solely on a single modifier for access control may not be sufficient. Additional access control mechanisms, such as role-based access control (RBAC) or ownership checks, should be considered to provide multiple layers of security.', 'Impact': 'If the `protectedCall` modifier is compromised or incorrectly implemented, sensitive functions could be accessed by unauthorized users, leading to potential manipulation of contract state.', 'Location': 'Functions: `setEntryFee`, `setCap`, `setExitFee`, `setAnnualizedFee`, `setFeeBeneficiary`, `setEntryFeeBeneficiaryShare`, `setExitFeeBeneficiaryShare`, `setLock`, etc.'}, {'Issue': 'Token Balance Check in `addToken`', 'Severity': 'Medium', 'Description': 'The `addToken` function checks if the balance of the token is greater than `MIN_AMOUNT` before adding it to the pool. However, this check does not account for potential fluctuations in token balance after the check, which could lead to tokens being added with insufficient balance.', 'Impact': 'Potential for tokens to be added to the pool with insufficient balance, leading to operational issues.', 'Location': '`addToken` function'}, {'Issue': 'Fee Beneficiary Share Validation', 'Severity': 'Medium', 'Description': 'The `setEntryFeeBeneficiaryShare` and `setExitFeeBeneficiaryShare` functions validate that the share does not exceed `HUNDRED_PERCENT`. However, there is no validation to ensure that the share is not set to zero, which could lead to no fees being distributed to the beneficiary.', 'Impact': 'Potential for no fees to be distributed to the beneficiary, leading to loss of revenue.', 'Location': '`setEntryFeeBeneficiaryShare` and `setExitFeeBeneficiaryShare` functions'}, {'Issue': 'Unprotected External Calls in `chargeOutstandingAnnualizedFee`', 'Severity': 'Medium', 'Description': 'The `chargeOutstandingAnnualizedFee` function calls `LibERC20.mint`, which is an external call. While the function is not directly exposed to external users, it is called within other functions like `joinPool` and `exitPool`. If `LibERC20.mint` is not properly secured, it could introduce vulnerabilities.', 'Impact': 'If `LibERC20.mint` is vulnerable, it could be exploited to manipulate the contract state or mint unauthorized tokens.', 'Location': '`chargeOutstandingAnnualizedFee` function'}, {'Issue': 'Front-Running Opportunities in `joinPool` and `exitPool`', 'Severity': 'Low', 'Description': 'The `joinPool` and `exitPool` functions are susceptible to front-running attacks. An attacker could monitor the blockchain for pending transactions and submit their own transactions with higher gas fees to manipulate the order of execution, potentially leading to unfair advantages.', 'Impact': 'Front-running could lead to unfair advantages for attackers, such as gaining better prices or causing others to receive less favorable terms.', 'Location': '`joinPool` and `exitPool` functions'}, {'Issue': 'Annualized Fee Calculation Precision', 'Severity': 'Low', 'Description': 'The `calcOutStandingAnnualizedFee` function calculates the annualized fee based on the time passed since the last fee claim. However, the calculation uses integer division, which could lead to precision loss, especially for small fee amounts or short time intervals.', 'Impact': 'Minor inaccuracies in fee calculations, potentially leading to small discrepancies in fee charges.', 'Location': '`calcOutStandingAnnualizedFee` function'}, {'Issue': 'Lack of Validation in `addToken` and `removeToken`', 'Severity': 'Low', 'Description': 'The `addToken` and `removeToken` functions do not validate the `_token` address beyond checking if it is already in the pool. This could lead to issues if a malicious or non-compliant ERC20 token is added to the pool.', 'Impact': ""Adding a malicious or non-compliant token could disrupt the pool's functionality or lead to unexpected behavior."", 'Location': '`addToken` and `removeToken` functions'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Low', 'Description': 'The contract uses `SafeMath` for arithmetic operations, which prevents overflow and underflow. However, the `calcOutStandingAnnualizedFee` function performs complex calculations involving `block.timestamp` and `totalSupply`. If these values are manipulated, it could lead to unexpected results.', 'Impact': ""Manipulation of timestamp or total supply could lead to incorrect fee calculations, potentially affecting the contract's financial logic."", 'Location': '`calcOutStandingAnnualizedFee` function'}, {'Issue': 'Insufficient Validation in `setEntryFee`, `setExitFee`, and `setAnnualizedFee`', 'Severity': 'Low', 'Description': ""The `setEntryFee`, `setExitFee`, and `setAnnualizedFee` functions validate that the fee does not exceed a maximum value but do not check if the fee is set to a reasonable minimum. This could lead to setting fees that are too low, potentially impacting the contract's revenue model."", 'Impact': 'Setting fees too low could result in insufficient revenue generation for the contract.', 'Location': '`setEntryFee`, `setExitFee`, and `setAnnualizedFee` functions'}, {'Issue': 'Lack of Event Emission for Sensitive State Changes', 'Severity': 'Low', 'Description': 'While the contract emits events for some state changes (e.g., `EntryFeeSet`, `CapSet`), it is important to ensure that all sensitive state changes emit events. This allows for better transparency and monitoring of contract activity. For example, the `setLock` function does not emit an event, making it harder to track when the lock state is changed.', 'Impact': 'Lack of event emission for sensitive state changes can reduce transparency and make it harder to monitor and audit contract activity.', 'Location': 'Function: `setLock`'}, {'Issue': 'Lack of Input Validation for Address Parameters', 'Severity': 'Low', 'Description': 'Functions such as `setFeeBeneficiary` and `addToken` accept address parameters without performing any validation to ensure that the address is not zero or invalid. While this is not a critical issue, it is a good practice to validate address inputs to prevent accidental errors or misuse.', 'Impact': 'Invalid or zero addresses could lead to unintended behavior, such as fees being sent to the wrong address or tokens being added incorrectly.', 'Location': 'Functions: `setFeeBeneficiary`, `addToken`'}, {'Issue': 'Redundant Calculations in `joinPool` and `exitPool`', 'Severity': 'Low', 'Description': 'The `joinPool` and `exitPool` functions perform redundant calculations for `feeAmount` and `tokenAmount` within the loop. These calculations could be optimized by precomputing values outside the loop to reduce gas consumption.', 'Impact': 'Slightly higher gas consumption than necessary, which could be optimized for better efficiency.', 'Location': '`joinPool` and `exitPool` functions'}, {'Issue': 'Lack of Batch Processing', 'Severity': 'Medium', 'Description': 'The `joinPool` and `exitPool` functions process tokens one at a time, which is inefficient for large token sets. Implementing batch processing or allowing users to specify a subset of tokens to join/exit could significantly reduce gas costs.', 'Impact': 'Higher gas costs and less flexibility for users managing large token sets.', 'Location': '`joinPool` and `exitPool` functions'}], 'IssueNumber': 33, 'OutputList': 26}",510.9352829456329,"### **[H-02] It might not be possible to withdraw tokens from the basket**

**Report Description**:
When enough basket token owners exit, it will be impossible to exit the pool with the last `MIN_AMOUNT` tokens because of a specific check. This will result in locking some tokens forever.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue describes a scenario where tokens could be permanently locked due to a specific check, but this is not addressed in the `response_list`. The response list does not cover this specific vulnerability or its implications.

---

### **[M-04] Annualized fee APY dependence on the frequency of executing a function**

**Report Description**:
The APY of the annualized fee is dependent on the frequency of the execution of the `BasketFacet::chargeOutstandingAnnualizedFee()`. If it is called more frequently, the compounding is more frequent and the APY is higher. For less used baskets, the APY might be lower because the compounding will happen at a lower rate.

**Match in Response List**:
Matches with the issue titled **""Fee Calculation Vulnerability in `chargeOutstandingAnnualizedFee`""**.

**Validation**:
**Partially Correct**. The response identifies the issue with fee calculations in `chargeOutstandingAnnualizedFee`, but it does not specifically address the dependency of APY on the frequency of function execution. The response focuses on the potential for incorrect fee calculations due to timestamp manipulation but misses the core issue of APY variability based on function call frequency.

---

### **[M-05] `totalSupply` may exceed `LibBasketStorage.basketStorage().maxCap`**

**Report Description**:
The total supply of the token may exceed the `maxCap` introduced. This can happen when a user wants to join the pool. The check in `BasketFacet::joinPool(...)` includes only the base amount, without the fee. Thus, if the fee is on and someone wants to create as many tokens as possible, the `totalSupply + _amount` will be set to `maxCap`. The call will succeed, but new tokens are also minted as the fee for `bs.feeBeneficiary` if `bs.entryFee` and `bs.entryFeeBeneficiaryShare` are nonzero. Thus, the number of tokens may exceed `maxCap`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue describes a scenario where the `totalSupply` can exceed `maxCap` due to fee minting, but this is not addressed in the `response_list`. The response list does not cover this specific vulnerability or its implications.

---

### **[M-10] Fees calculations are not accurate**

**Report Description**:
The function `calcOutStandingAnnualizedFee` calculates fees, but simply minting the exact amount results in a lower fee than it should be. For example, if the basket assets are worth 1M dollars and `totalSupply = 1M`, the result of `calcOutStandingAnnualizedFee` is 100,000, so the `feeBeneficiary` should get 100,000 dollars. However, when minting 100,000, the `totalSupply` will increase to 1,100,000, so they will own 100,000/1,100,000 * (1M dollars) = 90,909.09 dollars instead of 100,000.

**Match in Response List**:
Matches with the issue titled **""Inaccurate Fee Calculation""**.

**Validation**:
**Correct**. The response accurately identifies the issue with inaccurate fee calculations in `calcOutStandingAnnualizedFee`. It correctly explains the discrepancy between the expected and actual fees due to the increase in `totalSupply`, which aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-10] Fees calculations are not accurate**

**Partially Correct Matches**:

- **[M-04] Annualized fee APY dependence on the frequency of executing a function**

**Missed Issues from Issue Report**:

- **[H-02] It might not be possible to withdraw tokens from the basket**
- **[M-05] `totalSupply` may exceed `LibBasketStorage.basketStorage().maxCap`**

---

This analysis highlights that while some issues in the `issue` report are partially or fully addressed in the `response_list`, others are entirely missed. The `response_list` could be improved by including responses for the missed issues, particularly those related to token locking and `maxCap` enforcement.","```
1. Inaccurate Fee Calculation
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Inaccurate Fee Calculation"".
   - From the ranked list of predictions, ""Inaccurate Fee Calculation"" appears at rank **17**.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 17, \( P@17 = \frac{1}{17} \approx 0.0588 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.0588 \).

**Output**:
```
0.0588
```"
RebalanceManagerV3.sol,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";

import ""../interfaces/IExperiPie.sol"";
import ""../interfaces/IRebalanceManagerV3.sol"";

contract RebalanceManagerV3 is IRebalanceManagerV3 {
    IExperiPie public immutable basket;
    uint256 public immutable lockTime;
    mapping(address => bool) public exchanges;

    address public rebalanceManager;

    event Rebalanced(address indexed basket);
    event Swaped(
        address indexed basket,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 quantity,
        uint256 returnedQuantity
    );
    event RebalanceManagerSet(address indexed rebalanceManager);

    constructor(
        address _basket,
        address _uniswapV2Like,
        uint256 _lockTime
    ) {
        require(_basket != address(0), ""INVALID_BASKET"");
        require(_uniswapV2Like != address(0), ""INVALID_UNISWAP_V2"");

        basket = IExperiPie(_basket);
        rebalanceManager = msg.sender;
        exchanges[_uniswapV2Like] = true;
        lockTime = _lockTime;
    }

    modifier onlyRebalanceManager() {
        require(msg.sender == rebalanceManager, ""NOT_REBALANCE_MANAGER"");
        _;
    }

    function setRebalanceManager(address _rebalanceManager)
        external
        onlyRebalanceManager
    {
        rebalanceManager = _rebalanceManager;
        emit RebalanceManagerSet(_rebalanceManager);
    }

    function setExchange(address _exchange, bool _activated)
        external
        onlyRebalanceManager
    {
        exchanges[_exchange] = _activated;
    }

    function _swapUniswapV2(
        address exchange,
        uint256 quantity,
        uint256 minReturn,
        address[] calldata path,
        address recipient,
        uint256 deadline
    ) internal {
        if (IERC20(path[0]).allowance(address(basket), exchange) < quantity) {
            basket.singleCall(
                path[0],
                abi.encodeWithSelector(
                    IERC20(path[0]).approve.selector,
                    address(exchange),
                    uint256(-1)
                ),
                0
            );
        }

        // Swap on exchange
        basket.singleCall(
            exchange,
            abi.encodeWithSelector(
                IUniswapV2Router02(exchange).swapExactTokensForTokens.selector,
                quantity,
                minReturn,
                path,
                recipient,
                deadline
            ),
            0
        );

        emit Swaped(
            address(basket),
            path[0],
            path[path.length - 1],
            quantity,
            minReturn
        );
    }

    function removeToken(address _token) internal {
        uint256 balance = basket.balance(_token);
        bool inPool = basket.getTokenInPool(_token);
        //if there is a token balance of the token is not in the pool, skip
        if (balance != 0 || !inPool) {
            return;
        }

        // remove token
        basket.singleCall(
            address(basket),
            abi.encodeWithSelector(basket.removeToken.selector, _token),
            0
        );
    }

    function addToken(address _token) internal {
        uint256 balance = basket.balance(_token);
        bool inPool = basket.getTokenInPool(_token);
        // If token has no balance or is already in the pool, skip
        if (balance == 0 || inPool) {
            return;
        }

        // add token
        basket.singleCall(
            address(basket),
            abi.encodeWithSelector(basket.addToken.selector, _token),
            0
        );
    }

    function lockBasketData(uint256 _block) internal {
        basket.singleCall(
            address(basket),
            abi.encodeWithSelector(basket.setLock.selector, _block),
            0
        );
    }

    /**
        @notice Lock before Rebalance
    */
    function lock() external onlyRebalanceManager {
        lockBasketData(block.number + lockTime);
    }

    /**
        @notice Rebalance underling token
        @param _swapsV2 Swaps to perform
        @param _deadline Unix timestamp after which the transaction will revert.
    */
    function rebalance(UnderlyingTrade[] calldata _swapsV2, uint256 _deadline)
        external
        override
        onlyRebalanceManager
    {
        require(basket.getLock(), ""REQUIRE_LOCK"");
        lockBasketData(block.number + 30);

        for (uint256 i; i < _swapsV2.length; i++) {
            UnderlyingTrade calldata trade = _swapsV2[i];
            uint256 input = trade.quantity;
            address targetToken = trade.swaps[0].path[0];
            //internal trades
            for (uint256 j; j < trade.swaps.length; j++) {
                UniswapV2SwapStruct calldata swap = trade.swaps[j];
                require(exchanges[swap.exchange], ""INVALID_EXCHANGE"");
                require(targetToken == swap.path[0], ""INVALID_INPUT_TOKEN"");
                targetToken = swap.path[swap.path.length - 1];

                uint256 oldBalance = IERC20(targetToken).balanceOf(
                    address(basket)
                );
                //swap token
                _swapUniswapV2(
                    swap.exchange,
                    input,
                    0,
                    swap.path,
                    address(basket),
                    _deadline
                );
                //The output of this trade is the input for the next trade
                input =
                    IERC20(targetToken).balanceOf(address(basket)) -
                    oldBalance;
            }
            require(trade.minimumReturn <= input, ""INSUFFICIENT_OUTPUT_AMOUNT"");
            //add to token if missing
            UniswapV2SwapStruct calldata toAdd = trade.swaps[
                trade.swaps.length - 1
            ];
            addToken(toAdd.path[toAdd.path.length - 1]);

            //remove from token if resulting quantity is 0
            removeToken(trade.swaps[0].path[0]);
        }

        emit Rebalanced(address(basket));
    }
}",1340,207,"[M-06] block.timestamp or deadline

Submitted by gpersoon, also found by kenzo and robee
Impact

Some functions, like rebalance() in RebalanceManagerV3 use _deadline as a time limit for swapExactTokensForTokens() Other functions, like _joinTokenSingle() of SingleTokenJoinV2.sol and _exit() of SingleNativeTokenExitV2() use block.timestamp, although a deadline field is present in the struct.
Possibly the deadline fields should have been used.

",1,,"pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";

import ""../interfaces/IExperiPie.sol"";
import ""../interfaces/IRebalanceManagerV3.sol"";

contract RebalanceManagerV3 is IRebalanceManagerV3 {
    IExperiPie public immutable basket;
    uint256 public immutable lockTime;
    mapping(address => bool) public exchanges;

    address public rebalanceManager;

    event Rebalanced(address indexed basket);
    event Swaped(
        address indexed basket,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 quantity,
        uint256 returnedQuantity
    );
    event RebalanceManagerSet(address indexed rebalanceManager);

    constructor(
        address _basket,
        address _uniswapV2Like,
        uint256 _lockTime
    ) {
        require(_basket != address(0), ""INVALID_BASKET"");
        require(_uniswapV2Like != address(0), ""INVALID_UNISWAP_V2"");

        basket = IExperiPie(_basket);
        rebalanceManager = msg.sender;
        exchanges[_uniswapV2Like] = true;
        lockTime = _lockTime;
    }

    modifier onlyRebalanceManager() {
        require(msg.sender == rebalanceManager, ""NOT_REBALANCE_MANAGER"");
        _;
    }

    function setRebalanceManager(address _rebalanceManager)
        external
        onlyRebalanceManager
    {
        rebalanceManager = _rebalanceManager;
        emit RebalanceManagerSet(_rebalanceManager);
    }

    function setExchange(address _exchange, bool _activated)
        external
        onlyRebalanceManager
    {
        exchanges[_exchange] = _activated;
    }

    function _swapUniswapV2(
        address exchange,
        uint256 quantity,
        uint256 minReturn,
        address[] calldata path,
        address recipient,
        uint256 deadline
    ) internal {
        if (IERC20(path[0]).allowance(address(basket), exchange) < quantity) {
            basket.singleCall(
                path[0],
                abi.encodeWithSelector(
                    IERC20(path[0]).approve.selector,
                    address(exchange),
                    uint256(-1)
                ),
                0
            );
        }

        
        basket.singleCall(
            exchange,
            abi.encodeWithSelector(
                IUniswapV2Router02(exchange).swapExactTokensForTokens.selector,
                quantity,
                minReturn,
                path,
                recipient,
                deadline
            ),
            0
        );

        emit Swaped(
            address(basket),
            path[0],
            path[path.length - 1],
            quantity,
            minReturn
        );
    }

    function removeToken(address _token) internal {
        uint256 balance = basket.balance(_token);
        bool inPool = basket.getTokenInPool(_token);
        
        if (balance != 0 || !inPool) {
            return;
        }

        
        basket.singleCall(
            address(basket),
            abi.encodeWithSelector(basket.removeToken.selector, _token),
            0
        );
    }

    function addToken(address _token) internal {
        uint256 balance = basket.balance(_token);
        bool inPool = basket.getTokenInPool(_token);
        
        if (balance == 0 || inPool) {
            return;
        }

        
        basket.singleCall(
            address(basket),
            abi.encodeWithSelector(basket.addToken.selector, _token),
            0
        );
    }

    function lockBasketData(uint256 _block) internal {
        basket.singleCall(
            address(basket),
            abi.encodeWithSelector(basket.setLock.selector, _block),
            0
        );
    }

    
    function lock() external onlyRebalanceManager {
        lockBasketData(block.number + lockTime);
    }

    
    function rebalance(UnderlyingTrade[] calldata _swapsV2, uint256 _deadline)
        external
        override
        onlyRebalanceManager
    {
        require(basket.getLock(), ""REQUIRE_LOCK"");
        lockBasketData(block.number + 30);

        for (uint256 i; i < _swapsV2.length; i++) {
            UnderlyingTrade calldata trade = _swapsV2[i];
            uint256 input = trade.quantity;
            address targetToken = trade.swaps[0].path[0];
            
            for (uint256 j; j < trade.swaps.length; j++) {
                UniswapV2SwapStruct calldata swap = trade.swaps[j];
                require(exchanges[swap.exchange], ""INVALID_EXCHANGE"");
                require(targetToken == swap.path[0], ""INVALID_INPUT_TOKEN"");
                targetToken = swap.path[swap.path.length - 1];

                uint256 oldBalance = IERC20(targetToken).balanceOf(
                    address(basket)
                );
                
                _swapUniswapV2(
                    swap.exchange,
                    input,
                    0,
                    swap.path,
                    address(basket),
                    _deadline
                );
                
                input =
                    IERC20(targetToken).balanceOf(address(basket)) -
                    oldBalance;
            }
            require(trade.minimumReturn <= input, ""INSUFFICIENT_OUTPUT_AMOUNT"");
            
            UniswapV2SwapStruct calldata toAdd = trade.swaps[
                trade.swaps.length - 1
            ];
            addToken(toAdd.path[toAdd.path.length - 1]);

            
            removeToken(trade.swaps[0].path[0]);
        }

        emit Rebalanced(address(basket));
    }
}",1197,0,1,,"{'ReviewingTheCode': 'The contract is a rebalance manager for a basket of tokens, allowing for the rebalancing of token holdings via swaps on Uniswap V2-like exchanges. It includes mechanisms for locking the basket, managing rebalance operations, and interacting with external contracts.', 'IdentifyingKeyComponents': {'ContractName': 'RebalanceManagerV3', 'Purpose': ""To manage the rebalancing of token holdings in a basket by executing swaps on Uniswap V2-like exchanges and updating the basket's composition."", 'InheritanceAndImports': {'InheritsFrom': ['IRebalanceManagerV3'], 'Imports': ['@openzeppelin/contracts/token/ERC20/IERC20.sol', '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol', '../interfaces/IExperiPie.sol', '../interfaces/IRebalanceManagerV3.sol']}, 'StateVariables': [{'Name': 'basket', 'Type': 'IExperiPie', 'Purpose': 'The basket of tokens being managed.'}, {'Name': 'lockTime', 'Type': 'uint256', 'Purpose': 'The duration for which the basket is locked during rebalancing.'}, {'Name': 'exchanges', 'Type': 'mapping(address => bool)', 'Purpose': 'Mapping of approved exchanges for swapping tokens.'}, {'Name': 'rebalanceManager', 'Type': 'address', 'Purpose': 'The address authorized to perform rebalance operations.'}], 'FunctionsAndModifiers': [{'Name': 'onlyRebalanceManager', 'Visibility': 'modifier', 'Purpose': 'Restricts function access to the rebalance manager.', 'Parameters': [], 'Returns': []}, {'Name': 'setRebalanceManager', 'Visibility': 'external', 'Purpose': 'Updates the rebalance manager address.', 'Parameters': ['address _rebalanceManager'], 'Returns': []}, {'Name': 'setExchange', 'Visibility': 'external', 'Purpose': 'Approves or disapproves an exchange for swapping.', 'Parameters': ['address _exchange', 'bool _activated'], 'Returns': []}, {'Name': '_swapUniswapV2', 'Visibility': 'internal', 'Purpose': 'Executes a token swap on a Uniswap V2-like exchange.', 'Parameters': ['address exchange', 'uint256 quantity', 'uint256 minReturn', 'address[] calldata path', 'address recipient', 'uint256 deadline'], 'Returns': []}, {'Name': 'removeToken', 'Visibility': 'internal', 'Purpose': 'Removes a token from the basket if conditions are met.', 'Parameters': ['address _token'], 'Returns': []}, {'Name': 'addToken', 'Visibility': 'internal', 'Purpose': 'Adds a token to the basket if conditions are met.', 'Parameters': ['address _token'], 'Returns': []}, {'Name': 'lockBasketData', 'Visibility': 'internal', 'Purpose': 'Locks the basket for a specified block number.', 'Parameters': ['uint256 _block'], 'Returns': []}, {'Name': 'lock', 'Visibility': 'external', 'Purpose': 'Locks the basket for the duration of lockTime.', 'Parameters': [], 'Returns': []}, {'Name': 'rebalance', 'Visibility': 'external', 'Purpose': 'Executes a series of swaps to rebalance the basket.', 'Parameters': ['UnderlyingTrade[] calldata _swapsV2', 'uint256 _deadline'], 'Returns': []}]}, 'ExternalInteractions': ['IERC20: Used for token allowance and balance checks.', 'IUniswapV2Router02: Used for executing token swaps on Uniswap V2-like exchanges.', 'IExperiPie: Represents the basket of tokens being managed.'], 'SpecialMechanisms': ['Locking Mechanism: The basket is locked during rebalancing to prevent concurrent modifications.', 'Rebalance Execution: The contract executes a series of swaps to achieve the desired token composition in the basket.'], 'Questions': ['What is the purpose of the `UnderlyingTrade` and `UniswapV2SwapStruct` structs, and how are they defined?', 'How is the `lockTime` determined, and what is the rationale behind its value?', 'Are there any safeguards in place to prevent front-running or other forms of manipulation during rebalancing?', 'How does the contract handle potential failures in external calls, such as revert conditions in Uniswap swaps?']}","{'Findings': [{'Issue': 'Unrestricted Approval for ERC20 Tokens', 'Severity': 'High', 'Description': 'The function `_swapUniswapV2` grants unlimited approval to the exchange for the token being swapped. This can lead to potential risks if the exchange is compromised or behaves maliciously, as it could transfer an unlimited amount of tokens from the basket.', 'Impact': 'An attacker could potentially drain the basket of all tokens approved for the exchange.', 'Location': 'Function `_swapUniswapV2`, line where `basket.singleCall` is used to approve the exchange.'}, {'Issue': 'Unbounded Loop in Rebalance Function', 'Severity': 'High', 'Description': 'The `rebalance` function contains a loop that iterates over the `_swapsV2` array without any limit on its size. This can lead to a denial of service (DoS) attack if the array is too large, causing the transaction to run out of gas and fail.', 'Impact': 'Potential for DoS attacks, leading to failed transactions and disruption of the rebalancing process.', 'Location': 'rebalance function, line numbers 130-183'}, {'Issue': 'Potential Reentrancy in `_swapUniswapV2` and `rebalance` Functions', 'Severity': 'High', 'Description': 'The `_swapUniswapV2` and `rebalance` functions interact with external contracts without using reentrancy guards. This could potentially allow a malicious contract to re-enter the function and manipulate the state of the contract.', 'Impact': 'Reentrancy attacks could lead to unexpected behavior or loss of funds.', 'Location': 'Functions `_swapUniswapV2` and `rebalance`'}, {'Issue': 'Lack of Input Validation in `rebalance` Function', 'Severity': 'Medium', 'Description': 'The `rebalance` function does not validate the `_deadline` parameter or the `_swapsV2` array length. This could lead to expired transactions being executed or unexpected behavior if the array is empty or contains invalid data.', 'Impact': 'Transactions could be executed at unintended times or with invalid data, leading to financial losses.', 'Location': 'Function `rebalance`'}, {'Issue': 'Insufficient Minimum Return Check', 'Severity': 'Medium', 'Description': 'The `rebalance` function checks if the `minimumReturn` is less than or equal to the `input` after the swap, but it does not enforce a minimum return value during the swap itself. This could lead to slippage and unfavorable trades.', 'Impact': 'The basket could receive fewer tokens than expected, leading to financial losses.', 'Location': 'Function `rebalance`, where `require(trade.minimumReturn <= input, ""INSUFFICIENT_OUTPUT_AMOUNT"");` is used.'}, {'Issue': 'Lack of Input Validation in `setExchange` Function', 'Severity': 'Medium', 'Description': 'The `setExchange` function does not validate the `_exchange` address. If a malicious or invalid address is provided, it could lead to unauthorized or unintended interactions with the contract.', 'Impact': 'An attacker could set a malicious exchange address, leading to potential loss of funds or unauthorized swaps.', 'Location': 'Function `setExchange`'}, {'Issue': 'Hardcoded Lock Time', 'Severity': 'Low', 'Description': 'The `lockBasketData` function uses a hardcoded value of 30 blocks for the lock time. This could lead to inflexibility and potential issues if the network conditions change.', 'Impact': 'The hardcoded lock time might not be suitable for all network conditions, leading to either too short or too long lock periods.', 'Location': 'Function `lockBasketData`'}, {'Issue': 'Lack of Event Emission for Critical Actions', 'Severity': 'Low', 'Description': 'Critical actions such as adding or removing tokens from the basket or setting exchange addresses do not emit events. This makes it difficult to track and audit these actions.', 'Impact': 'Lack of transparency and auditability for critical actions.', 'Location': 'Functions `addToken`, `removeToken`, and `setExchange`'}], 'IssueNumber': 18, 'OutputList': 8}",609.4892780780792,"---

**[M-06] block.timestamp or deadline**

**Report Description**:
The issue highlights inconsistencies in the use of `block.timestamp` and `_deadline` across different functions. Specifically, the `rebalance()` function in `RebalanceManagerV3` uses `_deadline` as a time limit for `swapExactTokensForTokens()`, while other functions like `_joinTokenSingle()` in `SingleTokenJoinV2.sol` and `_exit()` in `SingleNativeTokenExitV2.sol` use `block.timestamp`, even though a `deadline` field is present in the struct. This inconsistency could lead to unintended behavior, such as expired transactions being executed or missed deadlines, potentially causing financial losses or operational inefficiencies.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. None of the responses in the `response_list` address the issue of inconsistent use of `block.timestamp` and `_deadline`. The closest match is the ""Lack of Input Validation in `rebalance` Function,"" which mentions the `_deadline` parameter but does not address the broader issue of inconsistent time management across functions. This oversight fails to recognize the potential risks associated with improper time handling in smart contracts, which is a critical aspect of Solidity security best practices.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-06] block.timestamp or deadline**

---","```
None.
```",0.0
SingleNativeTokenExitV2,"//SPDX-License-Identifier: Unlicense
pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IWrappedNativeToken.sol"";

import {IPangolinRouter} from ""@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol"";

import ""../interfaces/IBasketFacet.sol"";

contract SingleNativeTokenExitV2 {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    // Can be any IPangolinRouter or IUniRouter ...
    IPangolinRouter public immutable uniSwapLikeRouter;
    // WETH or WAVAX ...
    IERC20 public immutable INTERMEDIATE_TOKEN;

    struct ExitUnderlyingTrade {
        ExitUniswapV2SwapStruct[] swaps;
    }

    struct ExitUniswapV2SwapStruct {
        address exchange;
        address[] path;
    }
    struct ExitTokenStructV2 {
        address inputBasket;
        uint256 inputAmount;
        uint256 minAmount;
        uint256 deadline;
        uint16 referral;
        ExitUnderlyingTrade[] trades;
    }

    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {
        require(_INTERMEDIATE_TOKEN != address(0), ""INTERMEDIATE_ZERO"");
        require(_uniSwapLikeRouter != address(0), ""UNI_ROUTER_ZERO"");

        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);
        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);
    }

    receive() external payable {}

    function _maxApprove(IERC20 token, address spender) internal {
        if (
            token.allowance(address(this), spender) <
            token.balanceOf(address(this))
        ) {
            token.approve(spender, uint256(-1));
        }
    }

    function _exit(ExitTokenStructV2 calldata _exitTokenStruct) internal {
        // ######## INIT TOKEN #########
        IERC20 inputBasket = IERC20(_exitTokenStruct.inputBasket);

        inputBasket.safeTransferFrom(
            msg.sender,
            address(this),
            _exitTokenStruct.inputAmount
        );

        IBasketFacet(address(inputBasket)).exitPool(
            _exitTokenStruct.inputAmount,
            _exitTokenStruct.referral
        );

        for (uint256 i; i < _exitTokenStruct.trades.length; i++) {
            ExitUnderlyingTrade calldata trade = _exitTokenStruct.trades[i];
            for (uint256 j; j < trade.swaps.length; j++) {
                ExitUniswapV2SwapStruct calldata swap = trade.swaps[j];
                _maxApprove(IERC20(swap.path[0]), address(swap.exchange));
                IPangolinRouter(swap.exchange).swapExactTokensForTokens(
                    IERC20(swap.path[0]).balanceOf(address(this)),
                    0,
                    swap.path,
                    address(this),
                    block.timestamp
                );
            }
        }
    }

    function exit(ExitTokenStructV2 calldata _exitTokenStruct) external {
        _exit(_exitTokenStruct);
        address[] calldata path = _exitTokenStruct
            .trades[0]
            .swaps[_exitTokenStruct.trades[0].swaps.length - 1]
            .path;
        IERC20 outputToken = IERC20(path[path.length - 1]); //this could be not the target token

        uint256 outputTokenBalance = outputToken.balanceOf(address(this));
        require(
            outputTokenBalance >= _exitTokenStruct.minAmount,
            ""Insufficient output""
        );

        outputToken.transfer(msg.sender, outputTokenBalance);
    }

    function exitEth(ExitTokenStructV2 calldata _exitTokenStruct) external {
        _exit(_exitTokenStruct);

        uint256 intermediateTokenBalance = INTERMEDIATE_TOKEN.balanceOf(
            address(this)
        );
        require(
            intermediateTokenBalance >= _exitTokenStruct.minAmount,
            ""Insufficient output""
        );

        IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(
            intermediateTokenBalance
        );
        msg.sender.transfer(intermediateTokenBalance);
    }
}",921,123,"[M-07] ERC20 return values not checked

Submitted by cmichel, also found by defsec, JMukesh, p4st13r4, and WatchPug
The ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do not revert if the transfer failed but return false instead.
See:
SingleNativeTokenExitV2.exit’s outputToken.transfer(msg.sender, outputTokenBalance);
PieFactoryContract.bakePie’s pie.transfer(msg.sender, _initialSupply);
Impact

Tokens that don’t actually perform the transfer and return false are still counted as a correct transfer and the tokens remain in the SingleNativeTokenExitV2 contract and could potentially be stolen by someone else.
 [M-08] SingleNativeTokenExitV2 assumes first exchange holds the outputToken

Submitted by kenzo, also found by cmichel and hyh
SingleNativeTokenExitV2 allows the user to exit and execute trades via multiple exchanges. When finishing the trades and sending a single output token back to the user, the contract takes that token from the last swap in the first exchange’s trades. There is nothing in the struct that signifies this will be the output token, and this also impairs the exit functionality.

",2,,"pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IWrappedNativeToken.sol"";

import {IPangolinRouter} from ""@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol"";

import ""../interfaces/IBasketFacet.sol"";

contract SingleNativeTokenExitV2 {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    
    IPangolinRouter public immutable uniSwapLikeRouter;
    
    IERC20 public immutable INTERMEDIATE_TOKEN;

    struct ExitUnderlyingTrade {
        ExitUniswapV2SwapStruct[] swaps;
    }

    struct ExitUniswapV2SwapStruct {
        address exchange;
        address[] path;
    }
    struct ExitTokenStructV2 {
        address inputBasket;
        uint256 inputAmount;
        uint256 minAmount;
        uint256 deadline;
        uint16 referral;
        ExitUnderlyingTrade[] trades;
    }

    constructor(address _INTERMEDIATE_TOKEN, address _uniSwapLikeRouter) {
        require(_INTERMEDIATE_TOKEN != address(0), ""INTERMEDIATE_ZERO"");
        require(_uniSwapLikeRouter != address(0), ""UNI_ROUTER_ZERO"");

        INTERMEDIATE_TOKEN = IERC20(_INTERMEDIATE_TOKEN);
        uniSwapLikeRouter = IPangolinRouter(_uniSwapLikeRouter);
    }

    receive() external payable {}

    function _maxApprove(IERC20 token, address spender) internal {
        if (
            token.allowance(address(this), spender) <
            token.balanceOf(address(this))
        ) {
            token.approve(spender, uint256(-1));
        }
    }

    function _exit(ExitTokenStructV2 calldata _exitTokenStruct) internal {
        
        IERC20 inputBasket = IERC20(_exitTokenStruct.inputBasket);

        inputBasket.safeTransferFrom(
            msg.sender,
            address(this),
            _exitTokenStruct.inputAmount
        );

        IBasketFacet(address(inputBasket)).exitPool(
            _exitTokenStruct.inputAmount,
            _exitTokenStruct.referral
        );

        for (uint256 i; i < _exitTokenStruct.trades.length; i++) {
            ExitUnderlyingTrade calldata trade = _exitTokenStruct.trades[i];
            for (uint256 j; j < trade.swaps.length; j++) {
                ExitUniswapV2SwapStruct calldata swap = trade.swaps[j];
                _maxApprove(IERC20(swap.path[0]), address(swap.exchange));
                IPangolinRouter(swap.exchange).swapExactTokensForTokens(
                    IERC20(swap.path[0]).balanceOf(address(this)),
                    0,
                    swap.path,
                    address(this),
                    block.timestamp
                );
            }
        }
    }

    function exit(ExitTokenStructV2 calldata _exitTokenStruct) external {
        _exit(_exitTokenStruct);
        address[] calldata path = _exitTokenStruct
            .trades[0]
            .swaps[_exitTokenStruct.trades[0].swaps.length - 1]
            .path;
        IERC20 outputToken = IERC20(path[path.length - 1]); 

        uint256 outputTokenBalance = outputToken.balanceOf(address(this));
        require(
            outputTokenBalance >= _exitTokenStruct.minAmount,
            ""Insufficient output""
        );

        outputToken.transfer(msg.sender, outputTokenBalance);
    }

    function exitEth(ExitTokenStructV2 calldata _exitTokenStruct) external {
        _exit(_exitTokenStruct);

        uint256 intermediateTokenBalance = INTERMEDIATE_TOKEN.balanceOf(
            address(this)
        );
        require(
            intermediateTokenBalance >= _exitTokenStruct.minAmount,
            ""Insufficient output""
        );

        IWrappedNativeToken(address(INTERMEDIATE_TOKEN)).withdraw(
            intermediateTokenBalance
        );
        msg.sender.transfer(intermediateTokenBalance);
    }
}",878,0,2,,"{'ReviewingTheCode': ""The contract 'SingleNativeTokenExitV2' is designed to facilitate the exit of tokens from a basket by swapping them through a series of trades on a Uniswap-like exchange (PangolinRouter). The contract allows users to exit their tokens either as ERC20 tokens or as ETH, depending on the function called. The contract uses OpenZeppelin libraries for safe math operations and ERC20 token interactions."", 'IdentifyingKeyComponents': {'ContractName': 'SingleNativeTokenExitV2', 'Purpose': 'To enable users to exit their tokens from a basket by swapping them through a series of trades on a Uniswap-like exchange, either as ERC20 tokens or as ETH.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/math/SafeMath.sol', '@openzeppelin/contracts/token/ERC20/SafeERC20.sol', '../interfaces/IWrappedNativeToken.sol', '@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol', '../interfaces/IBasketFacet.sol']}, 'StateVariables': [{'Name': 'uniSwapLikeRouter', 'Type': 'IPangolinRouter', 'Purpose': 'The router for the Uniswap-like exchange (Pangolin) used for swapping tokens.'}, {'Name': 'INTERMEDIATE_TOKEN', 'Type': 'IERC20', 'Purpose': 'The intermediate token used in the swap process, typically a wrapped native token (e.g., WETH).'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with the intermediate token and the Uniswap-like router.', 'Parameters': ['address _INTERMEDIATE_TOKEN', 'address _uniSwapLikeRouter'], 'Returns': []}, {'Name': 'receive', 'Visibility': 'external', 'Purpose': 'Allows the contract to receive ETH.', 'Parameters': [], 'Returns': []}, {'Name': '_maxApprove', 'Visibility': 'internal', 'Purpose': 'Approves the maximum allowance for a token to be spent by a spender.', 'Parameters': ['IERC20 token', 'address spender'], 'Returns': []}, {'Name': '_exit', 'Visibility': 'internal', 'Purpose': 'Handles the core logic of exiting the basket by performing a series of swaps.', 'Parameters': ['ExitTokenStructV2 calldata _exitTokenStruct'], 'Returns': []}, {'Name': 'exit', 'Visibility': 'external', 'Purpose': 'Exits the basket and transfers the resulting ERC20 tokens to the caller.', 'Parameters': ['ExitTokenStructV2 calldata _exitTokenStruct'], 'Returns': []}, {'Name': 'exitEth', 'Visibility': 'external', 'Purpose': 'Exits the basket and transfers the resulting ETH to the caller.', 'Parameters': ['ExitTokenStructV2 calldata _exitTokenStruct'], 'Returns': []}]}, 'ExternalInteractions': ['IPangolinRouter (Pangolin exchange router)', 'IERC20 (ERC20 token interactions)', 'IBasketFacet (Basket token interactions)', 'IWrappedNativeToken (Wrapped native token interactions)'], 'SpecialMechanisms': ['The contract uses a series of swaps on a Uniswap-like exchange to exit tokens from a basket.', 'The contract supports both ERC20 and ETH exits, with the latter involving unwrapping the intermediate token.'], 'Questions': [""What is the purpose of the 'referral' parameter in the ExitTokenStructV2 struct?"", 'How does the contract handle slippage in the swap process?', 'Is there any mechanism to prevent front-running attacks during the swap process?', 'What happens if the swap fails or the output amount is less than the minimum specified?']}","{'Findings': [{'Issue': 'Unrestricted Approval for Token Spending', 'Severity': 'High', 'Description': 'The `_maxApprove` function grants unlimited approval to the spender for the token. This can lead to potential risks if the spender is compromised or behaves maliciously, as it allows the spender to transfer any amount of tokens from the contract.', 'Impact': ""If the spender is malicious or compromised, it could drain the contract's token balance."", 'Location': 'Function `_maxApprove`'}, {'Issue': 'Unbounded Loop Gas Consumption', 'Severity': 'High', 'Description': 'The `_exit` function contains nested loops that iterate over user-provided arrays (`_exitTokenStruct.trades` and `trade.swaps`). If these arrays are large, the gas consumption could exceed the block gas limit, causing the transaction to fail and potentially leading to a denial of service.', 'Impact': 'High gas consumption could lead to transaction failures, loss of funds, or denial of service.', 'Location': '`_exit` function, nested loops over `_exitTokenStruct.trades` and `trade.swaps`'}, {'Issue': 'Potential Reentrancy in `exitEth` Function', 'Severity': 'High', 'Description': 'The `exitEth` function interacts with an external contract (`IWrappedNativeToken`) to withdraw Ether. This interaction could potentially be exploited in a reentrancy attack if the external contract is malicious or compromised.', 'Impact': 'Potential for reentrancy attacks leading to loss of funds.', 'Location': '`exitEth` function, call to `IWrappedNativeToken.withdraw`'}, {'Issue': 'Lack of Reentrancy Protection', 'Severity': 'High', 'Description': ""The contract does not implement any reentrancy guards, particularly in the `exit` and `exitEth` functions. This could allow an attacker to perform reentrant calls and potentially manipulate the contract's state or funds."", 'Impact': ""An attacker could exploit reentrancy to manipulate the contract's state or steal funds."", 'Location': 'Functions `exit` and `exitEth`'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'The `exit` and `exitEth` functions do not validate the `_exitTokenStruct` input parameters thoroughly. Specifically, there is no validation of the `path` array in `ExitUniswapV2SwapStruct`, which could lead to unexpected behavior or vulnerabilities if malicious paths are provided.', 'Impact': 'Potential for unexpected behavior, vulnerabilities, or loss of funds if malicious inputs are provided.', 'Location': '`exit` and `exitEth` functions, input parameter `_exitTokenStruct`'}, {'Issue': 'Potential Front-Running in Swap Operations', 'Severity': 'Medium', 'Description': 'The swap operations in the `_exit` function are vulnerable to front-running attacks. An attacker could observe the transaction in the mempool and execute a similar transaction with a higher gas price to manipulate the swap outcome.', 'Impact': 'Front-running could lead to unfavorable swap rates or loss of funds.', 'Location': 'Function `_exit`, specifically in the swap operations'}, {'Issue': 'Deadline Not Enforced in Swap Operations', 'Severity': 'Low', 'Description': 'The swap operations use `block.timestamp` as the deadline, which means the transaction could be included in a block at any time, potentially leading to unfavorable swap conditions if the transaction is delayed.', 'Impact': 'Delayed transactions could result in unfavorable swap rates.', 'Location': 'Function `_exit`, specifically in the swap operations'}, {'Issue': 'Use of Deprecated SafeMath Library', 'Severity': 'Low', 'Description': 'The contract uses the `SafeMath` library, which is deprecated in Solidity 0.8.0 and later versions. While this does not pose an immediate security risk, it is recommended to use the built-in overflow checks in Solidity 0.8.0 and later.', 'Impact': 'No immediate security risk, but potential for future compatibility issues.', 'Location': 'Import statement and usage of `SafeMath` library'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical actions such as token transfers or approvals. Events are useful for off-chain monitoring and auditing, and their absence makes it harder to track contract activity.', 'Impact': ""Reduced transparency and auditability of the contract's operations."", 'Location': 'Throughout the contract'}], 'IssueNumber': 9, 'OutputList': 9}",609.6706981658936,"### **Output**

---

**[M-07] ERC20 return values not checked**

**Report Description**:
The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do not revert if the transfer fails but return `false` instead. Examples include `SingleNativeTokenExitV2.exit`’s `outputToken.transfer(msg.sender, outputTokenBalance)` and `PieFactoryContract.bakePie`’s `pie.transfer(msg.sender, _initialSupply)`. If the return value is not checked, tokens that don’t actually perform the transfer and return `false` are still counted as a correct transfer. This could leave tokens in the `SingleNativeTokenExitV2` contract, potentially allowing them to be stolen by someone else.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked ERC20 return values. This is a critical vulnerability that could lead to loss of funds, and it is not covered in the provided responses.

---

**[M-08] SingleNativeTokenExitV2 assumes first exchange holds the outputToken**

**Report Description**:
`SingleNativeTokenExitV2` allows users to exit and execute trades via multiple exchanges. When finishing the trades and sending a single output token back to the user, the contract takes that token from the last swap in the first exchange’s trades. There is nothing in the struct that signifies this will be the output token, and this impairs the exit functionality. This assumption could lead to incorrect token transfers or failed exits, potentially causing loss of funds or user dissatisfaction.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect assumptions about the output token in `SingleNativeTokenExitV2`. This is a functional flaw that could lead to incorrect behavior, and it is not covered in the provided responses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-07] ERC20 return values not checked**
- **[M-08] SingleNativeTokenExitV2 assumes first exchange holds the outputToken**

---

### **Conclusion**
The `response_list` does not address the two issues reported in the `issue` list. Both **[M-07]** and **[M-08]** are critical vulnerabilities that could lead to loss of funds or incorrect contract behavior. The responses provided in the `response_list` focus on other issues, such as reentrancy, gas consumption, and input validation, but fail to cover the specific vulnerabilities related to ERC20 return value checks and incorrect assumptions about token transfers. This indicates a significant gap in the coverage of the response list.","```
None.
```",0.0
CallFact.sol,"// SPDX-License-Identifier: MIT
pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@pie-dao/diamond/contracts/libraries/LibDiamond.sol"";
import ""../../interfaces/ICallFacet.sol"";
import ""../shared/Reentry/ReentryProtection.sol"";
import ""../shared/Access/CallProtection.sol"";
import ""./LibCallStorage.sol"";

contract CallFacet is ReentryProtection, ICallFacet {
    uint256 public constant MAX_CALLERS = 50;

    // uses modified call protection modifier to also allow whitelisted addresses to call
    modifier protectedCall() {
        require(
            msg.sender == LibDiamond.diamondStorage().contractOwner ||
                LibCallStorage.callStorage().canCall[msg.sender] ||
                msg.sender == address(this),
            ""NOT_ALLOWED""
        );
        _;
    }

    modifier onlyOwner() {
        require(
            msg.sender == LibDiamond.diamondStorage().contractOwner,
            ""NOT_ALLOWED""
        );
        _;
    }

    function addCaller(address _caller) external override onlyOwner {
        LibCallStorage.CallStorage storage callStorage =
            LibCallStorage.callStorage();

        require(callStorage.callers.length < MAX_CALLERS, ""TOO_MANY_CALLERS"");
        require(!callStorage.canCall[_caller], ""IS_ALREADY_CALLER"");
        require(_caller != address(0), ""INVALID_CALLER"");

        callStorage.callers.push(_caller);
        callStorage.canCall[_caller] = true;

        emit CallerAdded(_caller);
    }

    function removeCaller(address _caller) external override onlyOwner {
        LibCallStorage.CallStorage storage callStorage =
            LibCallStorage.callStorage();

        require(callStorage.canCall[_caller], ""IS_NOT_CALLER"");

        callStorage.canCall[_caller] = false;

        for (uint256 i = 0; i < callStorage.callers.length; i++) {
            address currentCaller = callStorage.callers[i];

            // if found remove it
            if (currentCaller == _caller) {
                callStorage.callers[i] = callStorage.callers[
                    callStorage.callers.length - 1
                ];
                callStorage.callers.pop();
                break;
            }
        }

        emit CallerRemoved(_caller);
    }

    function call(
        address[] memory _targets,
        bytes[] memory _calldata,
        uint256[] memory _values
    ) public override noReentry protectedCall {
        require(
            _targets.length == _calldata.length &&
                _values.length == _calldata.length,
            ""ARRAY_LENGTH_MISMATCH""
        );

        for (uint256 i = 0; i < _targets.length; i++) {
            _call(_targets[i], _calldata[i], _values[i]);
        }
    }

    function callNoValue(address[] memory _targets, bytes[] memory _calldata)
        public
        override
        noReentry
        protectedCall
    {
        require(_targets.length == _calldata.length, ""ARRAY_LENGTH_MISMATCH"");

        for (uint256 i = 0; i < _targets.length; i++) {
            _call(_targets[i], _calldata[i], 0);
        }
    }

    function singleCall(
        address _target,
        bytes calldata _calldata,
        uint256 _value
    ) external override noReentry protectedCall {
        _call(_target, _calldata, _value);
    }

    function _call(
        address _target,
        bytes memory _calldata,
        uint256 _value
    ) internal {
        require(address(this).balance >= _value, ""ETH_BALANCE_TOO_LOW"");
        (bool success, ) = _target.call{value: _value}(_calldata);
        require(success, ""CALL_FAILED"");
        emit Call(msg.sender, _target, _calldata, _value);
    }

    function canCall(address _caller) external view override returns (bool) {
        return LibCallStorage.callStorage().canCall[_caller];
    }

    function getCallers() external view override returns (address[] memory) {
        return LibCallStorage.callStorage().callers;
    }
}

",869,128,"[M-09] Failed transfer with low level call could be overlooked

Submitted by harleythedog
Impact

The CallFacet.sol contract has the function _call :
function \_call(
 address \_target,
 bytes memory \_calldata,
 uint256 \_value
) internal {
 require(address(this).balance >= \_value, ""ETH\_BALANCE\_TOO\_LOW"");
 (bool success, ) = \_target.call{value: \_value}(\_calldata);
 require(success, ""CALL\_FAILED"");
 emit Call(msg.sender, \_target, \_calldata, \_value);
}

This function is utilized in a lot of different places. According to the Solidity docs, “The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed”.
As a result, it is possible that this call will not work but _call will not notice anything went wrong. It could be possible that a user is interacting with an exchange or token that has been deleted, but _call will not notice that something has gone wrong and as a result, ether can become stuck in the contract. For this reason, it would be better to also check for the contract’s existence prior to executing _target.call.
",1,,"pragma experimental ABIEncoderV2;
pragma solidity ^0.7.5;

import ""@pie-dao/diamond/contracts/libraries/LibDiamond.sol"";
import ""../../interfaces/ICallFacet.sol"";
import ""../shared/Reentry/ReentryProtection.sol"";
import ""../shared/Access/CallProtection.sol"";
import ""./LibCallStorage.sol"";

contract CallFacet is ReentryProtection, ICallFacet {
    uint256 public constant MAX_CALLERS = 50;

    
    modifier protectedCall() {
        require(
            msg.sender == LibDiamond.diamondStorage().contractOwner ||
                LibCallStorage.callStorage().canCall[msg.sender] ||
                msg.sender == address(this),
            ""NOT_ALLOWED""
        );
        _;
    }

    modifier onlyOwner() {
        require(
            msg.sender == LibDiamond.diamondStorage().contractOwner,
            ""NOT_ALLOWED""
        );
        _;
    }

    function addCaller(address _caller) external override onlyOwner {
        LibCallStorage.CallStorage storage callStorage =
            LibCallStorage.callStorage();

        require(callStorage.callers.length < MAX_CALLERS, ""TOO_MANY_CALLERS"");
        require(!callStorage.canCall[_caller], ""IS_ALREADY_CALLER"");
        require(_caller != address(0), ""INVALID_CALLER"");

        callStorage.callers.push(_caller);
        callStorage.canCall[_caller] = true;

        emit CallerAdded(_caller);
    }

    function removeCaller(address _caller) external override onlyOwner {
        LibCallStorage.CallStorage storage callStorage =
            LibCallStorage.callStorage();

        require(callStorage.canCall[_caller], ""IS_NOT_CALLER"");

        callStorage.canCall[_caller] = false;

        for (uint256 i = 0; i < callStorage.callers.length; i++) {
            address currentCaller = callStorage.callers[i];

            
            if (currentCaller == _caller) {
                callStorage.callers[i] = callStorage.callers[
                    callStorage.callers.length - 1
                ];
                callStorage.callers.pop();
                break;
            }
        }

        emit CallerRemoved(_caller);
    }

    function call(
        address[] memory _targets,
        bytes[] memory _calldata,
        uint256[] memory _values
    ) public override noReentry protectedCall {
        require(
            _targets.length == _calldata.length &&
                _values.length == _calldata.length,
            ""ARRAY_LENGTH_MISMATCH""
        );

        for (uint256 i = 0; i < _targets.length; i++) {
            _call(_targets[i], _calldata[i], _values[i]);
        }
    }

    function callNoValue(address[] memory _targets, bytes[] memory _calldata)
        public
        override
        noReentry
        protectedCall
    {
        require(_targets.length == _calldata.length, ""ARRAY_LENGTH_MISMATCH"");

        for (uint256 i = 0; i < _targets.length; i++) {
            _call(_targets[i], _calldata[i], 0);
        }
    }

    function singleCall(
        address _target,
        bytes calldata _calldata,
        uint256 _value
    ) external override noReentry protectedCall {
        _call(_target, _calldata, _value);
    }

    function _call(
        address _target,
        bytes memory _calldata,
        uint256 _value
    ) internal {
        require(address(this).balance >= _value, ""ETH_BALANCE_TOO_LOW"");
        (bool success, ) = _target.call{value: _value}(_calldata);
        require(success, ""CALL_FAILED"");
        emit Call(msg.sender, _target, _calldata, _value);
    }

    function canCall(address _caller) external view override returns (bool) {
        return LibCallStorage.callStorage().canCall[_caller];
    }

    function getCallers() external view override returns (address[] memory) {
        return LibCallStorage.callStorage().callers;
    }
}",840,0,1,,"{'ReviewingTheCode': ""The provided Solidity code snippet is a smart contract named 'CallFacet' that facilitates multi-call functionality with reentrancy protection and access control. It allows authorized callers to execute multiple calls in a single transaction, either with or without Ether value. The contract inherits from 'ReentryProtection' and implements the 'ICallFacet' interface. It also utilizes several libraries and modifiers to manage access and reentrancy."", 'IdentifyingKeyComponents': {'ContractName': 'CallFacet', 'Purpose': 'To enable authorized callers to execute multiple calls in a single transaction, with or without Ether value, while ensuring reentrancy protection and access control.', 'InheritanceAndImports': {'InheritsFrom': ['ReentryProtection', 'ICallFacet'], 'Imports': ['@pie-dao/diamond/contracts/libraries/LibDiamond.sol', '../../interfaces/ICallFacet.sol', '../shared/Reentry/ReentryProtection.sol', '../shared/Access/CallProtection.sol', './LibCallStorage.sol']}, 'StateVariables': [{'Name': 'MAX_CALLERS', 'Type': 'uint256', 'Purpose': 'Maximum number of callers allowed to be added to the contract.'}], 'FunctionsAndModifiers': [{'Name': 'protectedCall', 'Visibility': 'modifier', 'Purpose': 'Ensures that only the contract owner, authorized callers, or the contract itself can execute the function.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyOwner', 'Visibility': 'modifier', 'Purpose': 'Ensures that only the contract owner can execute the function.', 'Parameters': [], 'Returns': []}, {'Name': 'addCaller', 'Visibility': 'external', 'Purpose': 'Allows the contract owner to add a new authorized caller.', 'Parameters': ['address _caller'], 'Returns': []}, {'Name': 'removeCaller', 'Visibility': 'external', 'Purpose': 'Allows the contract owner to remove an authorized caller.', 'Parameters': ['address _caller'], 'Returns': []}, {'Name': 'call', 'Visibility': 'public', 'Purpose': 'Executes multiple calls with specified Ether values.', 'Parameters': ['address[] memory _targets', 'bytes[] memory _calldata', 'uint256[] memory _values'], 'Returns': []}, {'Name': 'callNoValue', 'Visibility': 'public', 'Purpose': 'Executes multiple calls without Ether value.', 'Parameters': ['address[] memory _targets', 'bytes[] memory _calldata'], 'Returns': []}, {'Name': 'singleCall', 'Visibility': 'external', 'Purpose': 'Executes a single call with a specified Ether value.', 'Parameters': ['address _target', 'bytes calldata _calldata', 'uint256 _value'], 'Returns': []}, {'Name': '_call', 'Visibility': 'internal', 'Purpose': 'Internal function to execute a single call with Ether value.', 'Parameters': ['address _target', 'bytes memory _calldata', 'uint256 _value'], 'Returns': []}, {'Name': 'canCall', 'Visibility': 'external', 'Purpose': 'Checks if a given address is an authorized caller.', 'Parameters': ['address _caller'], 'Returns': ['bool']}, {'Name': 'getCallers', 'Visibility': 'external', 'Purpose': 'Returns the list of authorized callers.', 'Parameters': [], 'Returns': ['address[] memory']}]}, 'ExternalInteractions': ['LibDiamond.diamondStorage()', 'LibCallStorage.callStorage()', 'External calls to addresses specified in _targets'], 'SpecialMechanisms': [""Reentrancy protection via 'noReentry' modifier"", ""Access control via 'protectedCall' and 'onlyOwner' modifiers"", 'Use of Diamond Storage pattern for managing state'], 'Questions': [""What is the purpose of the 'LibDiamond' library and how does it interact with this contract?"", ""How is the 'LibCallStorage' library structured and what data does it store?"", ""Are there any potential gas optimization opportunities in the 'removeCaller' function?"", ""What are the security implications of allowing the contract to call itself in the 'protectedCall' modifier?""]}","{'Findings': [{'Issue': 'Reentrancy Vulnerability', 'Severity': 'High', 'Description': 'The `_call` function performs an external call using `call` with a specified value, which could allow reentrancy attacks if the target contract is malicious. Although the `noReentry` modifier is used, it may not fully protect against all forms of reentrancy, especially across different functions or if the modifier is improperly implemented.', 'Impact': 'An attacker could exploit this vulnerability to re-enter the contract, potentially draining funds or manipulating the contract state.', 'Location': 'Function `_call` in `CallFacet` contract'}, {'Issue': 'Unbounded Array Iteration/Growth', 'Severity': 'Medium', 'Description': 'Functions like `removeCaller` and `addCaller` involve operations on the `callers` array without strict bounds. Iterating over or growing this array can lead to high gas costs, out-of-gas errors, or denial of service if the array becomes too large.', 'Impact': 'High gas consumption and potential denial of service if the array grows too large, making the functions impractical to use.', 'Location': 'Functions `removeCaller` and `addCaller` in `CallFacet` contract'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'Functions such as `call`, `callNoValue`, `addCaller`, and `removeCaller` do not adequately validate input parameters (e.g., array lengths, target addresses, or caller addresses). This could lead to unexpected behavior, errors, or calls to invalid/malicious addresses.', 'Impact': 'Potential for unintended behavior, failed transactions, or loss of funds due to invalid or malicious inputs.', 'Location': 'Functions `call`, `callNoValue`, `addCaller`, and `removeCaller` in `CallFacet` contract'}, {'Issue': 'Potential Front-Running', 'Severity': 'Low', 'Description': 'Functions like `addCaller` and `removeCaller` lack protection against front-running. An attacker could monitor pending transactions and manipulate the list of callers before the intended transaction is processed.', 'Impact': 'Unauthorized manipulation of the callers list, potentially leading to misuse of contract functionality.', 'Location': 'Functions `addCaller` and `removeCaller` in `CallFacet` contract'}, {'Issue': 'Insufficient Balance Check', 'Severity': 'Low', 'Description': ""The `_call` function checks the contract's balance before making an external call but does not account for potential changes in balance between the check and the call, which could lead to failed transactions."", 'Impact': ""Failed transactions if the contract's balance changes unexpectedly."", 'Location': 'Function `_call` in `CallFacet` contract'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': 'Functions like `_call` and `removeCaller` do not consistently emit events for failed operations, making it difficult to track unsuccessful attempts or diagnose issues.', 'Impact': 'Reduced visibility into contract operations, complicating debugging and auditing.', 'Location': 'Functions `_call` and `removeCaller` in `CallFacet` contract'}, {'Issue': 'Use of Experimental ABIEncoderV2', 'Severity': 'Low', 'Description': 'The contract uses the experimental `ABIEncoderV2` pragma, which is not recommended for production due to potential bugs and security issues.', 'Impact': 'Unexpected behavior or vulnerabilities due to unstable experimental features.', 'Location': 'Pragma statement'}], 'IssueNumber': 32, 'OutputList': 7}",300.036536693573,"---

**[M-09] Failed transfer with low level call could be overlooked**

**Report Description**:
The `_call` function in `CallFacet.sol` uses a low-level `call` to send Ether to a target address. According to the Solidity documentation, low-level calls return `true` even if the target address is non-existent. This means that the `require(success, ""CALL_FAILED"")` check will not detect cases where the target contract has been deleted or does not exist. As a result, Ether could become stuck in the contract, especially when interacting with deleted or non-existent contracts. The issue suggests checking the target contract's existence before executing the `call`.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the specific issue of low-level calls returning `true` for non-existent contracts. While the response list includes issues like reentrancy, unbounded array iteration, and insufficient balance checks, none of these directly address the problem of failing to detect non-existent contracts during low-level calls. This is a missed issue in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-09] Failed transfer with low level call could be overlooked**

---","```
None.
```",0.0
