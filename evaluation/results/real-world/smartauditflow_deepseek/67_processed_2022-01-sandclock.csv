nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
Vault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";

/**
 * A vault where other accounts can deposit an underlying token
 * currency and set distribution params for their principal and yield
 *
 * @dev Yield generation strategies not yet implemented
 */

contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    //
    // Constants
    //

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    //
    // State
    //

    /// Underlying ERC20 token accepted by the vault
    /// See {IVault}
    IERC20 public override(IVault) underlying;

    /// See {IVault}
    IStrategy public strategy;

    /// See {IVault}
    uint256 public investPerc;

    /// See {IVault}
    uint256 public immutable override(IVault) minLockPeriod;

    /// See {IVaultSponsoring}
    uint256 public override(IVaultSponsoring) totalSponsored;

    /// Depositors, represented as an NFT per deposit
    Depositors public depositors;

    /// Yield allocation
    Claimers public claimers;

    /// Unique IDs to correlate donations that belong to the same foundation
    Counters.Counter private _depositGroupIds;

    /**
     * @param _underlying Underlying ERC20 token to use.
     */
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    //
    // IVault
    //

    /// See {IVault}
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    /// See {IVault}
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    /// See {IVault}
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    /// See {IVault}
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    /// See {IVault}
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    /// See {IVault}
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    /// See {IVault}
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    /// See {IVault}
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    /// See {IVault}
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    /// See {IVault}
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    /// See {IVault}
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    //
    // IVaultSponsoring

    /// See {IVaultSponsoring}
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    /// See {IVaultSponsoring}
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    /// See {IVaultSponsoring}
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    //
    // Public API
    //

    /**
     * Computes the total amount of principal + yield currently controlled by the
     * vault and the strategy. The principal + yield is the total amount
     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.
     *
     * @return Total amount of principal and yield help by the vault (not including sponsored amount).
     */
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        // TODO no invested amount yet
        return totalUnderlying() - totalSponsored;
    }

    //
    // ERC165
    //

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    //
    // Internal API
    //

    /**
     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    /**
     * Withdraws the sponsored amount for the deposits with the ids provided
     * in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    /**
     * Creates a deposit with the given amount of underlying and claim
     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.
     * @notice This function assumes underlying will be transfered elsewhere in
     * the transaction.
     *
     * @notice Underlying must be transfered *after* this function, in order to
     * correctly calculate shares.
     *
     * @notice claims must add up to 100%.
     *
     * @param _amount Amount of underlying to consider @param claims claim
     * @param _lockedUntil When the depositor can unsponsor the amount.
     * @param claims Claim params
     * params.
     */
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    /**
     * Burns a deposit NFT and reduces the principal and shares of the claimer.
     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.
     *
     * @notice This function doesn't transfer any funds, it only updates the state.
     *
     * @notice Only the owner of the deposit may call this function.
     *
     * @param _tokenId The deposit ID to withdraw from.
     * @param _totalShares The total shares to consider for the withdraw.
     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.
     *
     * @return the amount to withdraw.
     */
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    /**
     * Computes amount of shares that will be received for a given deposit amount
     *
     * @param _amount Amount of deposit to consider.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount of shares the deposit will receive.
     */
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    /**
     * Computes the amount of underlying from a given number of shares
     *
     * @param _shares Number of shares.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount that corresponds to the number of shares.
     */
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            // TODO exclude sponsored assets
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    /**
     * Checks if the given address is a contract implementing IIntegration
     *
     * @param addr Address to check
     * @return true if contract is an IIntegraiont
     */
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",4418,652,"[H-01] forceUnsponsor() may open a window for attackers to manipulate the _totalShares and freeze users' funds at a certain deposit amount

function `_unsponsor()`, variables `totalSponsored`

https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L390-L401
if (_force && sponsorAmount > totalUnderlying()) {
    sponsorToTransfer = totalUnderlying();
} else if (!_force) {
    require(
        sponsorToTransfer <= totalUnderlying(),
        ""Vault: not enough funds to unsponsor""
    );
}

totalSponsored -= sponsorAmount;

underlying.safeTransfer(_to, sponsorToTransfer);

When sponsorAmount > totalUnderlying(), the contract will transfer totalUnderlying() to sponsorToTransfer, even if there are other depositors and totalShares > 0.
After that, and before others despoiting into the Vault, the Attacker can send 1 wei underlying token, then cal deposit() with 0.1 * 1e18 , since newShares = (_amount * _totalShares) / _totalUnderlyingMinusSponsored and _totalUnderlyingMinusSponsored is 1, with a tiny amount of underlying token, newShares will become extremly large.
As we stated in issue #166, when the value of totalShares is manipulated precisely, the attacker can plant a bomb, and the contract will not work when the deposit/withdraw amount reaches a certain value, freezing the user's funds.
 [H-02] Withdrawers can get more value returned than expected with reentrant call
Reentrancy call 
Submitted by camden, also found by cmichel and harleythedog
The impact of this is that users can get significantly more UST withdrawn than they would be alotted if they had done non-reentrant withdraw calls.
  [H-04] deposit() function is open to reentrancy attacks
Reentrancy attacks 
In Vault.sol the deposit() function is left wide open to reentrancy attacks. The function eventually calls \_createDeposit() => \_createClaim() which calls depositors.mint() which will then mint an NFT. When the NFT is minted the sender will receive a callback which can then be used to call the deposit() function again before execution is finished. An attacker can do this minting multiple NFT's for themselves. claimers.mint() is also called in the same function which can also be used to call back into the deposit function before execution is complete. Since there are several state updates before and after NFT's are minted this can be used to further manipulate the protocol like with newShares which is called before minting. This is not counting what an attacker can do with cross function reentrancy entering into several other protocol functions (like withdraw) before code execution is complete further manipulating the system.
  [H-05] sponsor() function in open to reentrancy attacks

Reentrancy guard, sponsor() function
In Vault.sol the sponsor() function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender. Since there are state updates after the call to depositors.mint() function this is especially dangerous. An attacker can make it so the totalSponsored amount is only updated once after calling mint() several times since the update takes place after the callback. The same will be true for the Sponsored event that is emitted.
  [M-04] unsponsor, claimYield and withdraw might fail unexpectedly
In function `  function _unsponsor` 
Submitted by danb, also found by ACai, cmichel, harleythedog, leastwood, palina, pedroais, and WatchPug
totalUnderlying() includes the invested assets, they are not in the contract balance.
when a user calls withdraw, claimYield or unsponsor, the system might not have enough assets in the balance and the transfer would fail.
especially, force unsponsor will always fail, because it tries to transfer the entire totalUnderlying(), which the system doesn't have:
https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L391
  [M-06] totalUnderlyingMinusSponsored() may revert on underflow and malfunction the contract
  [M-07] Vault can't receive deposits if underlying token charges fees on transfer

`function _transferAndCheckUnderlying` 
Some ERC20 tokens charge a fee for every transfer. If the underlying token of a vault is such a token any deposit to the protocol will fail.
Some tokens have the possibility of adding fees later on, e.g. USDT. So those have to be covered too.
Generally, the user would also receive fewer tokens on withdrawing in such a scenario but that's not the protocol's fault.
I rated the issue as medium since part of the protocol become unavailable in such a situation.
  [M-15] Check _to is not empty

functions claimYield, \_withdraw, and \_unsponsor should validate that \_to is not an empty 0x0 address to prevent accidental burns.

",8,,"pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";



contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    
    
    

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; 
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    
    
    

    
    
    IERC20 public override(IVault) underlying;

    
    IStrategy public strategy;

    
    uint256 public investPerc;

    
    uint256 public immutable override(IVault) minLockPeriod;

    
    uint256 public override(IVaultSponsoring) totalSponsored;

    
    Depositors public depositors;

    
    Claimers public claimers;

    
    Counters.Counter private _depositGroupIds;

    
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    
    
    

    
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    
    

    
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    
    
    

    
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        
        return totalUnderlying() - totalSponsored;
    }

    
    
    

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    
    
    

    
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",3364,4,4,,"{'ReviewingTheCode': ""The provided code snippet is a Solidity smart contract named 'Vault' that integrates with various external libraries and contracts. It appears to be a sophisticated vault system that allows users to deposit funds, sponsor the vault, claim yields, and withdraw funds. The contract also supports investment strategies and integration with external systems."", 'IdentifyingKeyComponents': {'ContractName': 'Vault', 'Purpose': 'To manage user deposits, sponsorships, yield claims, and withdrawals while integrating with investment strategies and external systems.', 'InheritanceAndImports': {'InheritsFrom': ['IVault', 'IVaultSponsoring', 'Context', 'ERC165', 'Trust'], 'Imports': ['@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol', '@openzeppelin/contracts/utils/Context.sol', '@openzeppelin/contracts/utils/Counters.sol', '@openzeppelin/contracts/utils/Address.sol', '@openzeppelin/contracts/utils/introspection/ERC165.sol', '@rari-capital/solmate/src/auth/Trust.sol', './vault/IVault.sol', './vault/IVaultSponsoring.sol', './lib/PercentMath.sol', './vault/Depositors.sol', './vault/Claimers.sol', './integrations/IIntegration.sol', './strategy/IStrategy.sol', './lib/ERC165Query.sol', 'hardhat/console.sol']}, 'StateVariables': [{'Name': 'MIN_SPONSOR_LOCK_DURATION', 'Type': 'uint256', 'Purpose': 'Minimum duration for which a sponsorship can be locked.'}, {'Name': 'SHARES_MULTIPLIER', 'Type': 'uint256', 'Purpose': 'Multiplier used for shares calculations.'}, {'Name': 'underlying', 'Type': 'IERC20', 'Purpose': 'The underlying ERC20 token managed by the vault.'}, {'Name': 'strategy', 'Type': 'IStrategy', 'Purpose': 'The investment strategy associated with the vault.'}, {'Name': 'investPerc', 'Type': 'uint256', 'Purpose': ""Percentage of the vault's funds that can be invested.""}, {'Name': 'minLockPeriod', 'Type': 'uint256', 'Purpose': 'Minimum lock period for deposits.'}, {'Name': 'totalSponsored', 'Type': 'uint256', 'Purpose': 'Total amount of funds sponsored in the vault.'}, {'Name': 'depositors', 'Type': 'Depositors', 'Purpose': 'Contract managing deposit-related operations.'}, {'Name': 'claimers', 'Type': 'Claimers', 'Purpose': 'Contract managing claim-related operations.'}, {'Name': '_depositGroupIds', 'Type': 'Counters.Counter', 'Purpose': 'Counter for tracking deposit group IDs.'}], 'FunctionsAndModifiers': [{'Name': 'setStrategy', 'Visibility': 'external', 'Purpose': 'Sets the investment strategy for the vault.', 'Parameters': ['address _strategy'], 'Returns': []}, {'Name': 'totalUnderlying', 'Visibility': 'public', 'Purpose': 'Returns the total amount of underlying tokens managed by the vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'totalShares', 'Visibility': 'public', 'Purpose': 'Returns the total number of shares in the vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'yieldFor', 'Visibility': 'public', 'Purpose': 'Calculates the yield for a specific address.', 'Parameters': ['address _to'], 'Returns': ['uint256']}, {'Name': 'deposit', 'Visibility': 'external', 'Purpose': 'Allows users to deposit funds into the vault.', 'Parameters': ['DepositParams calldata _params'], 'Returns': []}, {'Name': 'claimYield', 'Visibility': 'external', 'Purpose': 'Allows users to claim their yield.', 'Parameters': ['address _to'], 'Returns': []}, {'Name': 'withdraw', 'Visibility': 'external', 'Purpose': 'Allows users to withdraw their funds.', 'Parameters': ['address _to', 'uint256[] memory _ids'], 'Returns': []}, {'Name': 'forceWithdraw', 'Visibility': 'external', 'Purpose': 'Forces the withdrawal of funds, bypassing some checks.', 'Parameters': ['address _to', 'uint256[] memory _ids'], 'Returns': []}, {'Name': 'setInvestPerc', 'Visibility': 'external', 'Purpose': 'Sets the investment percentage for the vault.', 'Parameters': ['uint16 _investPerc'], 'Returns': []}, {'Name': 'investableAmount', 'Visibility': 'public', 'Purpose': 'Returns the amount of funds that can be invested.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'updateInvested', 'Visibility': 'external', 'Purpose': 'Updates the invested funds according to the strategy.', 'Parameters': [], 'Returns': []}, {'Name': 'sponsor', 'Visibility': 'external', 'Purpose': 'Allows users to sponsor the vault.', 'Parameters': ['uint256 _amount', 'uint256 _lockedUntil'], 'Returns': []}, {'Name': 'unsponsor', 'Visibility': 'external', 'Purpose': 'Allows users to unsponsor their funds.', 'Parameters': ['address _to', 'uint256[] memory _ids'], 'Returns': []}, {'Name': 'forceUnsponsor', 'Visibility': 'external', 'Purpose': 'Forces the unsponsoring of funds, bypassing some checks.', 'Parameters': ['address _to', 'uint256[] memory _ids'], 'Returns': []}, {'Name': 'totalUnderlyingMinusSponsored', 'Visibility': 'public', 'Purpose': 'Returns the total underlying amount minus sponsored funds.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'supportsInterface', 'Visibility': 'public', 'Purpose': 'Checks if the contract supports a specific interface.', 'Parameters': ['bytes4 interfaceId'], 'Returns': ['bool']}]}, 'ExternalInteractions': ['IERC20', 'IStrategy', 'Depositors', 'Claimers', 'IIntegration', 'IVault', 'IVaultSponsoring'], 'SpecialMechanisms': ['Investment strategy integration', 'Sponsorship mechanism', 'Yield calculation and claiming', 'Integration with external systems via IIntegration interface'], 'Questions': [""How are the 'Depositors' and 'Claimers' contracts structured and what specific functionalities do they provide?"", ""What is the exact role of the 'IIntegration' interface and how is it utilized within the vault?"", ""Are there any specific security considerations or potential vulnerabilities in the 'forceWithdraw' and 'forceUnsponsor' functions?"", ""How does the 'PercentMath' library handle percentage calculations and what are the valid ranges for percentages?""]}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `_withdraw`, `withdraw`, and `forceWithdraw` Functions', 'Severity': 'High', 'Description': 'Multiple functions (`_withdraw`, `withdraw`, `forceWithdraw`) transfer tokens before updating the internal state, making them susceptible to reentrancy attacks if the underlying token is malicious. This could allow attackers to re-enter the function and manipulate the state before updates are finalized.', 'Impact': 'Potential loss of funds due to reentrancy attacks, allowing attackers to drain the contract.', 'Location': 'Functions: `_withdraw`, `withdraw`, `forceWithdraw`'}, {'Issue': 'Potential Reentrancy in `_transferAndCheckUnderlying` Function', 'Severity': 'High', 'Description': 'The `_transferAndCheckUnderlying` function transfers tokens before performing balance checks, which could allow reentrancy attacks if the token contract is malicious and calls back into the contract before the balance check is completed.', 'Impact': ""An attacker could exploit this to manipulate the contract's state or steal funds."", 'Location': 'Function: `_transferAndCheckUnderlying`'}, {'Issue': 'Potential Reentrancy in `unsponsor` and `forceUnsponsor` Functions', 'Severity': 'High', 'Description': 'The `unsponsor` and `forceUnsponsor` functions call `_unsponsor`, which transfers tokens to the user. If the underlying token is malicious, it could re-enter the contract before state changes are finalized, potentially leading to reentrancy attacks.', 'Impact': 'An attacker could exploit this vulnerability to drain funds from the Vault.', 'Location': 'Functions: `unsponsor`, `forceUnsponsor`, `_unsponsor`'}, {'Issue': 'Potential Reentrancy in `deposit` Function', 'Severity': 'High', 'Description': 'The `deposit` function calls `_transferAndCheckUnderlying`, which transfers tokens from the user to the contract. If the underlying token is malicious, it could re-enter the `deposit` function before the state is updated, leading to unexpected behavior or loss of funds.', 'Impact': 'Reentrancy could allow an attacker to manipulate the contract state, potentially leading to loss of funds or other unintended consequences.', 'Location': 'Function: `deposit`'}, {'Issue': 'Lack of Input Validation in `setStrategy` Function', 'Severity': 'Medium', 'Description': 'The `setStrategy` function does not validate whether the `_strategy` address is a contract or implements the `IStrategy` interface. This could lead to setting an invalid or malicious strategy, causing runtime errors or unexpected behavior.', 'Impact': ""Loss of funds or disruption of the vault's operations if an invalid or malicious strategy is set."", 'Location': 'Function: `setStrategy`'}, {'Issue': 'Potential Integer Overflow in `_computeShares` and `_computeAmount` Functions', 'Severity': 'Medium', 'Description': ""The `_computeShares` and `_computeAmount` functions perform multiplication and division operations. While Solidity 0.8.x has built-in overflow checks, it's still important to ensure inputs are within safe bounds to prevent incorrect calculations."", 'Impact': 'Incorrect share or amount calculations, potentially leading to unfair distribution of funds.', 'Location': 'Functions: `_computeShares`, `_computeAmount`'}, {'Issue': 'Lack of Access Control in `forceWithdraw` and `forceUnsponsor` Functions', 'Severity': 'Medium', 'Description': 'The `forceWithdraw` and `forceUnsponsor` functions allow any user to bypass normal withdrawal or unsponsoring conditions, potentially leading to unauthorized withdrawals or disruptions.', 'Impact': 'Unauthorized withdrawals or unsponsoring of funds, leading to loss of funds or operational disruption.', 'Location': 'Functions: `forceWithdraw`, `forceUnsponsor`'}, {'Issue': 'Insufficient Validation in `sponsor` Function', 'Severity': 'Medium', 'Description': 'The `sponsor` function does not validate the `_amount` parameter to ensure it is greater than zero, potentially leading to zero-value sponsorships or unintended behavior.', 'Impact': 'Creation of zero-value sponsorships, causing unnecessary state changes or accounting issues.', 'Location': 'Function: `sponsor`'}, {'Issue': 'Potential Denial of Service in `_unsponsor` and `_createDeposit` Functions', 'Severity': 'Medium', 'Description': 'The `_unsponsor` and `_createDeposit` functions iterate over arrays, which could lead to denial of service if the arrays are too large, causing excessive gas consumption or transaction failures.', 'Impact': 'Denial of service due to high gas consumption, preventing legitimate operations.', 'Location': 'Functions: `_unsponsor`, `_createDeposit`'}, {'Issue': 'Potential Front-Running in `deposit` and `sponsor` Functions', 'Severity': 'Low', 'Description': 'The `deposit` and `sponsor` functions are susceptible to front-running attacks, where an attacker could manipulate the transaction order to gain an unfair advantage.', 'Impact': 'Unfair advantages in deposit or sponsor operations, potentially leading to financial losses.', 'Location': 'Functions: `deposit`, `sponsor`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Critical functions like `_withdraw`, `_unsponsor`, `setInvestPerc`, and `updateInvested` do not emit events, reducing transparency and making it difficult to track state changes.', 'Impact': 'Reduced auditability and transparency of contract operations.', 'Location': 'Functions: `_withdraw`, `_unsponsor`, `setInvestPerc`, `updateInvested`'}, {'Issue': 'Insufficient Validation in `_createDeposit` Function', 'Severity': 'Low', 'Description': 'The `_createDeposit` function does not validate the `_lockedUntil` parameter, potentially allowing funds to be locked indefinitely or for unreasonable durations.', 'Impact': 'Potential locking of funds for extended periods, reducing liquidity.', 'Location': 'Function: `_createDeposit`'}], 'IssueNumber': 19, 'OutputList': 12}",625.1368999481201,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] forceUnsponsor() may open a window for attackers to manipulate the _totalShares and freeze users' funds at a certain deposit amount**

**Report Description**:  
The `forceUnsponsor()` function in `Vault.sol` allows an attacker to manipulate `_totalShares` by exploiting the `_unsponsor()` function. When `sponsorAmount > totalUnderlying()`, the contract transfers `totalUnderlying()` to `sponsorToTransfer`, even if other depositors exist. An attacker can then deposit a tiny amount of underlying tokens, causing `newShares` to become extremely large due to the manipulated `_totalUnderlyingMinusSponsored`. This can freeze users' funds when the deposit/withdraw amount reaches a certain value.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of `forceUnsponsor()` allowing manipulation of `_totalShares` and freezing funds. The issue is unique and not covered by any of the responses.

---

#### **[H-02] Withdrawers can get more value returned than expected with reentrant call**

**Report Description**:  
The `withdraw` function is vulnerable to reentrancy attacks, allowing users to withdraw significantly more UST than expected by re-entering the function before state updates are completed.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in `_withdraw`, `withdraw`, and `forceWithdraw` Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in the `withdraw` function and explains the potential impact of attackers draining funds, which aligns with the issue report.

---

#### **[H-04] deposit() function is open to reentrancy attacks**

**Report Description**:  
The `deposit()` function in `Vault.sol` is vulnerable to reentrancy attacks due to the `depositors.mint()` and `claimers.mint()` callbacks. An attacker can re-enter the function before state updates are completed, minting multiple NFTs and manipulating the protocol.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy in `deposit` Function""**.

**Validation**:  
**Correct**. The response correctly identifies the reentrancy vulnerability in the `deposit` function and explains the potential impact of attackers manipulating the contract state, which aligns with the issue report.

---

#### **[H-05] sponsor() function is open to reentrancy attacks**

**Report Description**:  
The `sponsor()` function in `Vault.sol` lacks a reentrancy guard, allowing attackers to re-enter the function via the `depositors.mint()` callback. This can lead to incorrect updates of `totalSponsored` and other state variables.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific reentrancy vulnerability in the `sponsor()` function. The issue is unique and not covered by any of the responses.

---

#### **[M-04] unsponsor, claimYield, and withdraw might fail unexpectedly**

**Report Description**:  
The `_unsponsor`, `claimYield`, and `withdraw` functions may fail unexpectedly because `totalUnderlying()` includes invested assets not in the contract balance. This can cause transfers to fail, especially in `forceUnsponsor`, which attempts to transfer the entire `totalUnderlying()`.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of `totalUnderlying()` including invested assets, leading to potential transfer failures. The issue is unique and not covered by any of the responses.

---

#### **[M-06] totalUnderlyingMinusSponsored() may revert on underflow and malfunction the contract**

**Report Description**:  
The `totalUnderlyingMinusSponsored()` function may revert due to underflow, causing the contract to malfunction.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the underflow issue in `totalUnderlyingMinusSponsored()`. The issue is unique and not covered by any of the responses.

---

#### **[M-07] Vault can't receive deposits if underlying token charges fees on transfer**

**Report Description**:  
If the underlying token charges fees on transfer, deposits to the Vault will fail. This issue is particularly relevant for tokens like USDT, which can add fees later.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of tokens charging fees on transfer, which can prevent deposits. The issue is unique and not covered by any of the responses.

---

#### **[M-15] Check _to is not empty**

**Report Description**:  
The `claimYield`, `_withdraw`, and `_unsponsor` functions should validate that `_to` is not an empty address (0x0) to prevent accidental burns.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing validation for the `_to` address in the specified functions. The issue is unique and not covered by any of the responses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Withdrawers can get more value returned than expected with reentrant call**
- **[H-04] deposit() function is open to reentrancy attacks**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] forceUnsponsor() may open a window for attackers to manipulate the _totalShares and freeze users' funds at a certain deposit amount**
- **[H-05] sponsor() function is open to reentrancy attacks**
- **[M-04] unsponsor, claimYield, and withdraw might fail unexpectedly**
- **[M-06] totalUnderlyingMinusSponsored() may revert on underflow and malfunction the contract**
- **[M-07] Vault can't receive deposits if underlying token charges fees on transfer**
- **[M-15] Check _to is not empty**

---

The response list covers some reentrancy vulnerabilities but misses several critical issues, including manipulation of `_totalShares`, unexpected transfer failures, underflow risks, and token fee-related issues. These gaps highlight the need for a more comprehensive review of the contract's vulnerabilities.","```
1. Reentrancy Vulnerability in `_withdraw`, `withdraw`, and `forceWithdraw` Functions
2. Potential Reentrancy in `deposit` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **True Positive 1**: ""Reentrancy Vulnerability in `_withdraw`, `withdraw`, and `forceWithdraw` Functions"" appears at **Rank 1**.
   - **True Positive 2**: ""Potential Reentrancy in `deposit` Function"" appears at **Rank 4**.

2. **Calculate the precision at each rank**:
   - **Precision at Rank 1 (P@1)**: \( \frac{1}{1} = 1.0 \)
   - **Precision at Rank 4 (P@4)**: \( \frac{2}{4} = 0.5 \)

3. **Compute the Average Precision (AP)**:
   - AP = \( \frac{1.0 + 0.5}{2} = 0.75 \)

**Average Precision (AP)**: 0.75"
NonUSTStrategy.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import ""./curve/ICurve.sol"";
import ""./BaseStrategy.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/**
 * Strategy that handles non-UST tokens, by first converting them to UST via
 * Curve (https://curve.fi/), and only then depositing into EthAnchor
 */
contract NonUSTStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    // address of the Curve pool to use
    ICurve public curvePool;

    // index of the underlying token in the pool
    int128 public underlyingI;

    // index of the UST token in the pool
    int128 public ustI;

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner,
        address _curvePool,
        int128 _underlyingI,
        int128 _ustI
    )
        BaseStrategy(
            _vault,
            _treasury,
            _ethAnchorRouter,
            _exchangeRateFeeder,
            _ustToken,
            _aUstToken,
            _perfFeePct,
            _owner
        )
    {
        require(underlying != _ustToken, ""invalid underlying"");
        require(_curvePool != address(0), ""0x addr"");
        curvePool = ICurve(_curvePool);
        underlyingI = _underlyingI;
        ustI = _ustI;

        ustToken.safeApprove(_curvePool, type(uint256).max);
        underlying.safeApprove(_curvePool, type(uint256).max);
    }

    /**
     * Swaps the underlying currency for UST, and initiates a deposit of all
     * the converted UST into EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the deposit process, but does not finish it.
     */
    function doHardWork() external override(BaseStrategy) restricted {
        _swapUnderlyingToUst();
        _initDepositStable();
    }

    /**
     * Calls Curve to convert the existing underlying balance into UST
     */
    function _swapUnderlyingToUst() internal {
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            // slither-disable-next-line unused-return
            curvePool.exchange_underlying(
                underlyingI,
                ustI,
                underlyingBalance,
                0
            );
        }
    }

    /**
     * Calls Curve to convert the existing UST back into the underlying token
     */
    function _swapUstToUnderlying() internal {
        uint256 ustBalance = _getUstBalance();
        if (ustBalance > 0) {
            // slither-disable-next-line unused-return
            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);
        }
    }

    /**
     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.
     * Once UST is retrieved, convert it back to underlying via Curve
     *
     * @notice Must be called some time after `initRedeemStable()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending redeem operation
     */
    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {
        super.finishRedeemStable(idx);
        _swapUstToUnderlying();
    }

    /**
     * Amount, expressed in the underlying currency, currently in the strategy
     *
     * @notice both held and invested amounts are included here, using the
     * latest known exchange rates to the underlying currency
     *
     * @return The total amount of underlying
     */
    function investedAssets()
        external
        view
        override(BaseStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance();
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(
            address(aUstToken),
            true
        ) * aUstBalance) / 1e18) + pendingDeposits;
        return
            underlyingBalance +
            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);
    }
}",1005,137,"[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool

In short, the NonUSTStrategy is vulnerable to attacks by flash loans on curve pools.
Here's an outline of the attack:
Assume there is a vault with DAI underlying and a NonUSTStrategy with a DAI / UST curve pool
Take out a flash loan of DAI
Exchange a ton of DAI for UST
The exchange rate from DAI to UST has gone up (!!)
Withdraw or deposit from vault with more favorable terms than market
Transfer back UST to DAI
Repay flash loan
  [M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users

Function `_swapUnderlyingToUst`
https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/strategy/NonUSTStrategy.sol#L66-L69
NonUSTStrategy will swap the deposited non-UST assets into UST before depositing to EthAnchor. However, the swap fee is not attributed to the depositor correctly like many other yield farming vaults involving swaps (ZapIn).
An attacker can exploit it for the swap fees paid by other users by taking a majority share of the liquidity pool.
 [M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals

Submitted by leastwood, also found by danb
The investedAssets() function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in finishRedeemStable().
",3,,"pragma solidity ^0.8.10;

import ""./curve/ICurve.sol"";
import ""./BaseStrategy.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";


contract NonUSTStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    
    ICurve public curvePool;

    
    int128 public underlyingI;

    
    int128 public ustI;

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner,
        address _curvePool,
        int128 _underlyingI,
        int128 _ustI
    )
        BaseStrategy(
            _vault,
            _treasury,
            _ethAnchorRouter,
            _exchangeRateFeeder,
            _ustToken,
            _aUstToken,
            _perfFeePct,
            _owner
        )
    {
        require(underlying != _ustToken, ""invalid underlying"");
        require(_curvePool != address(0), ""0x addr"");
        curvePool = ICurve(_curvePool);
        underlyingI = _underlyingI;
        ustI = _ustI;

        ustToken.safeApprove(_curvePool, type(uint256).max);
        underlying.safeApprove(_curvePool, type(uint256).max);
    }

    
    function doHardWork() external override(BaseStrategy) restricted {
        _swapUnderlyingToUst();
        _initDepositStable();
    }

    
    function _swapUnderlyingToUst() internal {
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            
            curvePool.exchange_underlying(
                underlyingI,
                ustI,
                underlyingBalance,
                0
            );
        }
    }

    
    function _swapUstToUnderlying() internal {
        uint256 ustBalance = _getUstBalance();
        if (ustBalance > 0) {
            
            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);
        }
    }

    
    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {
        super.finishRedeemStable(idx);
        _swapUstToUnderlying();
    }

    
    function investedAssets()
        external
        view
        override(BaseStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance();
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(
            address(aUstToken),
            true
        ) * aUstBalance) / 1e18) + pendingDeposits;
        return
            underlyingBalance +
            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);
    }
}",664,1,2,,"{'ReviewingTheCode': 'The contract `NonUSTStrategy` is a Solidity smart contract that inherits from `BaseStrategy` and interacts with a Curve pool to swap underlying assets to UST and vice versa. It also handles deposits and redemptions of stable assets.', 'IdentifyingKeyComponents': {'ContractName': 'NonUSTStrategy', 'Purpose': 'To manage the swapping of underlying assets to UST and handle deposits and redemptions of stable assets using a Curve pool.', 'InheritanceAndImports': {'InheritsFrom': ['BaseStrategy'], 'Imports': ['./curve/ICurve.sol', './BaseStrategy.sol', '@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol']}, 'StateVariables': [{'Name': 'curvePool', 'Type': 'ICurve', 'Purpose': 'Interface to interact with the Curve pool.'}, {'Name': 'underlyingI', 'Type': 'int128', 'Purpose': 'Index of the underlying asset in the Curve pool.'}, {'Name': 'ustI', 'Type': 'int128', 'Purpose': 'Index of the UST token in the Curve pool.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with the necessary parameters and approves the Curve pool for token transfers.', 'Parameters': ['address _vault', 'address _treasury', 'address _ethAnchorRouter', 'address _exchangeRateFeeder', 'IERC20 _ustToken', 'IERC20 _aUstToken', 'uint16 _perfFeePct', 'address _owner', 'address _curvePool', 'int128 _underlyingI', 'int128 _ustI'], 'Returns': []}, {'Name': 'doHardWork', 'Visibility': 'external', 'Purpose': 'Executes the main strategy logic, including swapping underlying assets to UST and initiating stable deposits.', 'Parameters': [], 'Returns': []}, {'Name': '_swapUnderlyingToUst', 'Visibility': 'internal', 'Purpose': 'Swaps the underlying asset to UST using the Curve pool.', 'Parameters': [], 'Returns': []}, {'Name': '_swapUstToUnderlying', 'Visibility': 'internal', 'Purpose': 'Swaps UST to the underlying asset using the Curve pool.', 'Parameters': [], 'Returns': []}, {'Name': 'finishRedeemStable', 'Visibility': 'public', 'Purpose': 'Completes the redemption of stable assets and swaps UST back to the underlying asset.', 'Parameters': ['uint256 idx'], 'Returns': []}, {'Name': 'investedAssets', 'Visibility': 'external', 'Purpose': 'Calculates the total value of invested assets, including underlying assets and UST assets.', 'Parameters': [], 'Returns': ['uint256']}]}, 'ExternalInteractions': ['ICurve (Curve pool)', 'BaseStrategy', 'IERC20 (UST and aUST tokens)', 'SafeERC20 (for safe token transfers)'], 'SpecialMechanisms': ['The contract uses the Curve pool for swapping between underlying assets and UST.', 'It employs `SafeERC20` for secure token transfers and approvals.'], 'Questions': ['What is the purpose of `pendingRedeems` and `pendingDeposits` in the `investedAssets` function?', 'How does the `exchangeRateFeeder` work and what data does it provide?', 'Are there any potential risks associated with the use of `type(uint256).max` for token approvals?']}","{'Findings': [{'Issue': 'Unrestricted Approval for Curve Pool', 'Severity': 'High', 'Description': ""The contract grants unlimited approval to the Curve pool for both the underlying token and UST token. This could allow the Curve pool to spend an unlimited amount of these tokens from the contract's balance, which is a significant security risk if the Curve pool is compromised or behaves maliciously."", 'Impact': 'Potential loss of funds if the Curve pool is exploited or acts maliciously.', 'Location': 'Constructor, lines: `ustToken.safeApprove(_curvePool, type(uint256).max);` and `underlying.safeApprove(_curvePool, type(uint256).max);`'}, {'Issue': 'Lack of Input Validation for Curve Pool Indices', 'Severity': 'Medium', 'Description': 'The contract does not validate the `underlyingI` and `ustI` indices passed to the constructor. If these indices are incorrect, it could lead to unintended token swaps or failures in the Curve pool interactions.', 'Impact': 'Potential loss of funds or failed transactions due to incorrect Curve pool indices.', 'Location': 'Constructor, lines: `underlyingI = _underlyingI;` and `ustI = _ustI;`'}, {'Issue': 'Potential Reentrancy in `doHardWork` and `finishRedeemStable` Functions', 'Severity': 'Medium', 'Description': 'The `doHardWork` and `finishRedeemStable` functions call external functions (`_swapUnderlyingToUst`, `_initDepositStable`, `_swapUstToUnderlying`) without reentrancy guards. If the Curve pool or any other external contract called within these functions is malicious or compromised, it could potentially re-enter the contract and manipulate its state.', 'Impact': 'Reentrancy attacks could lead to unexpected state changes or loss of funds.', 'Location': 'Functions: `doHardWork`, `finishRedeemStable`'}, {'Issue': 'No Slippage Control in Token Swaps', 'Severity': 'Medium', 'Description': 'The `_swapUnderlyingToUst` and `_swapUstToUnderlying` functions do not implement any slippage control. This could result in unfavorable exchange rates during token swaps, leading to potential loss of value.', 'Impact': 'Potential loss of value due to unfavorable exchange rates during swaps.', 'Location': 'Functions: `_swapUnderlyingToUst` and `_swapUstToUnderlying`'}, {'Issue': 'Incorrect Calculation in `investedAssets` Function', 'Severity': 'Medium', 'Description': 'The `investedAssets` function calculates the total invested assets by summing the underlying balance and the result of `curvePool.get_dy_underlying`. However, this calculation does not account for potential slippage or fees in the Curve pool, which could lead to an inaccurate representation of the actual invested assets.', 'Impact': 'Inaccurate reporting of invested assets, potentially leading to incorrect financial decisions.', 'Location': 'Function: `investedAssets`'}, {'Issue': 'Lack of Access Control on `finishRedeemStable` Function', 'Severity': 'Low', 'Description': 'The `finishRedeemStable` function is marked as `public` and can be called by any external address. While it calls `super.finishRedeemStable(idx)`, which may have access control, the additional logic in this function (`_swapUstToUnderlying`) could be exploited if not properly restricted.', 'Impact': 'Unauthorized users could trigger the `_swapUstToUnderlying` function, potentially leading to unexpected behavior or state changes.', 'Location': 'Function: `finishRedeemStable`'}, {'Issue': 'Potential Division Precision Loss in `investedAssets` Function', 'Severity': 'Low', 'Description': 'The `investedAssets` function performs division with `1e18` which could lead to precision loss, especially when dealing with small amounts of tokens.', 'Impact': 'Minor inaccuracies in the calculation of invested assets.', 'Location': 'Function: `investedAssets`'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': ""The contract does not emit events for critical state changes, such as swaps or deposits. This makes it difficult to track and audit the contract's activity."", 'Impact': ""Lack of transparency and auditability could make it harder to monitor the contract's behavior and detect suspicious activity."", 'Location': 'Entire contract'}], 'IssueNumber': 50, 'OutputList': 8}",705.7355332374573,"### **[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool**

**Report Description**:
The `NonUSTStrategy` is vulnerable to flash loan attacks on Curve pools. An attacker can manipulate the exchange rate between the non-UST asset (e.g., DAI) and UST by taking out a flash loan, swapping a large amount of DAI for UST, and then withdrawing or depositing from the vault with more favorable terms. This can lead to significant financial losses for the vault and its users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific vulnerability of flash loan attacks on Curve pools in the `NonUSTStrategy`. While some issues related to Curve pools are mentioned (e.g., unrestricted approval, lack of input validation), none of them directly address the manipulation of exchange rates via flash loans. This is a critical oversight, as flash loan attacks are a well-known risk in DeFi protocols.

---

### **[M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users**

**Report Description**:
The `_swapUnderlyingToUst` function in `NonUSTStrategy.sol` does not correctly attribute swap fees to the depositor. This allows an attacker to exploit the swap fees paid by other users by taking a majority share of the liquidity pool. This misallocation of fees can lead to financial losses for legitimate users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper handling of swap fees in the `_swapUnderlyingToUst` function. While there are mentions of slippage control and incorrect calculations in `investedAssets`, none of these responses cover the specific vulnerability of fee misallocation. This is a significant gap, as improper fee handling can lead to direct financial losses for users.

---

### **[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Report Description**:
The `investedAssets()` function in `BaseStrategy.sol` and `NonUSTStrategy.sol` does not account for the performance fee charged by the treasury during strategy withdrawals. This leads to an inaccurate representation of the actual invested assets, which can mislead users and potentially lead to incorrect financial decisions.

**Match in Response List**:
Matches with the issue titled **""Incorrect Calculation in `investedAssets` Function""**.

**Validation**:
**Partially Correct**. The response identifies that the `investedAssets` function does not account for potential slippage or fees in the Curve pool, which is related to the issue. However, it does not specifically mention the performance fee charged by the treasury, which is a critical aspect of the vulnerability. While the response partially addresses the issue, it misses the core problem of performance fee exclusion.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Missed Issues from Issue Report**:
- **[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool**
- **[M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users**

---

### **Conclusion**
The response list partially addresses one issue but misses two critical vulnerabilities related to flash loan attacks and improper handling of swap fees. These gaps highlight the need for a more comprehensive review of the `NonUSTStrategy` contract to ensure all potential risks are identified and mitigated.","```
None.
```",0.0
BaseStrategy.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import ""../lib/PercentMath.sol"";
import ""../vault/IVault.sol"";
import ""./IStrategy.sol"";
import ""./anchor/IEthAnchorRouter.sol"";
import ""./anchor/IExchangeRateFeeder.sol"";

// import ""./Controllable.sol"";

/**
 * Base strategy that handles UST tokens and invests them via the EthAnchor
 * protocol (https://docs.anchorprotocol.com/ethanchor/ethanchor)
 */
abstract contract BaseStrategy is IStrategy, Trust {
    using SafeERC20 for IERC20;
    using PercentMath for uint256;

    event PerfFeeClaimed(uint256 amount);
    event PerfFeePctUpdated(uint256 pct);

    struct Operation {
        address operator;
        uint256 amount;
    }

    IERC20 public override(IStrategy) underlying;
    // Vault address
    address public override(IStrategy) vault;

    // address of the treasury
    address public treasury;

    // address for the UST token
    IERC20 public ustToken;

    // address for the aUST token (wrapped Anchor UST, received to accrue interest for an Anchor deposit)
    IERC20 public aUstToken;

    // performance fee taken by the treasury on profits
    uint16 public perfFeePct;

    // external contract to interact with EthAnchor
    IEthAnchorRouter public ethAnchorRouter;

    // external exchange rate provider
    IExchangeRateFeeder public exchangeRateFeeder;

    // amount currently pending in deposits to EthAnchor
    uint256 public pendingDeposits;

    // amount currently pending redeemption from EthAnchor
    uint256 public pendingRedeems;

    // deposit operations history
    Operation[] public depositOperations;

    // redeem operations history
    Operation[] public redeemOperations;

    // amount of UST converted (used to calculate yield)
    uint256 public convertedUst;

    // restructs a function to be called only by the vault or governance
    modifier restricted() {
        require(msg.sender == vault || isTrusted[msg.sender], ""restricted"");

        _;
    }

    modifier onlyVault() {
        require(msg.sender == vault, ""only vault"");

        _;
    }

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner
    ) Trust(_owner) {
        require(_ethAnchorRouter != address(0), ""0x addr"");
        require(_exchangeRateFeeder != address(0), ""0x addr"");
        require(address(_ustToken) != address(0), ""0x addr"");
        require(address(_aUstToken) != address(0), ""0x addr"");
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");

        treasury = _treasury;
        vault = _vault;
        underlying = IVault(_vault).underlying();
        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);
        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);
        ustToken = _ustToken;
        aUstToken = _aUstToken;
        perfFeePct = _perfFeePct;

        // pre-approve EthAnchor router to transact all UST and aUST
        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);
        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);
    }

    /**
     * Initiates a deposit of all the currently held UST into EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the deposit process, but does not finish it.
     */
    function doHardWork() external virtual override(IStrategy) restricted {
        _initDepositStable();
    }

    function _initDepositStable() internal {
        uint256 ustBalance = _getUstBalance();
        require(ustBalance > 0, ""balance 0"");
        pendingDeposits += ustBalance;
        address _operator = ethAnchorRouter.initDepositStable(ustBalance);
        depositOperations.push(
            Operation({operator: _operator, amount: ustBalance})
        );
    }

    /**
     * Calls EthAnchor with a pending deposit ID, and attempts to finish it.
     *
     * @notice Must be called some time after `doHardWork()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending deposit operation
     */
    function finishDepositStable(uint256 idx) external {
        require(depositOperations.length > idx, ""not running"");
        Operation storage operation = depositOperations[idx];
        ethAnchorRouter.finishDepositStable(operation.operator);

        pendingDeposits -= operation.amount;
        convertedUst += operation.amount;

        operation.operator = depositOperations[depositOperations.length - 1]
            .operator;
        operation.amount = depositOperations[depositOperations.length - 1]
            .amount;
        depositOperations.pop();
    }

    /**
     * Initiates a withdrawal of UST from EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the redeem process, but does not finish it.
     *
     * @param amount Amount of aUST to redeem
     */
    function initRedeemStable(uint256 amount) public restricted {
        uint256 aUstBalance = _getAUstBalance();
        require(amount > 0, ""amount 0"");
        require(aUstBalance >= amount, ""insufficient"");
        pendingRedeems += amount;
        address _operator = ethAnchorRouter.initRedeemStable(amount);
        redeemOperations.push(Operation({operator: _operator, amount: amount}));
    }

    /**
     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.
     *
     * @notice Must be called some time after `initRedeemStable()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending redeem operation
     */
    function finishRedeemStable(uint256 idx) public virtual {
        require(redeemOperations.length > idx, ""not running"");
        Operation storage operation = redeemOperations[idx];
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;
        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;
        uint256 ustBalanceBefore = _getUstBalance();

        ethAnchorRouter.finishRedeemStable(operation.operator);

        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;
        uint256 perfFee = redeemedAmount > originalUst
            ? (redeemedAmount - originalUst).percOf(perfFeePct)
            : 0;
        if (perfFee > 0) {
            ustToken.safeTransfer(treasury, perfFee);
            emit PerfFeeClaimed(perfFee);
        }
        convertedUst -= originalUst;
        pendingRedeems -= operation.amount;

        operation.operator = redeemOperations[redeemOperations.length - 1]
            .operator;
        operation.amount = redeemOperations[redeemOperations.length - 1].amount;
        redeemOperations.pop();
    }

    /**
     * Withdraws the entire amount back to the vault
     *
     * @notice since some of the amount may be deposited into EthAnchor, this
     * call may not withdraw all the funds right away. It will start a redeem
     * process on EthAnchor, but this function must be called again a second
     * time once that is finished.
     */
    function withdrawAllToVault() external override(IStrategy) restricted {
        uint256 aUstBalance = _getAUstBalance();
        if (aUstBalance > 0) {
            initRedeemStable(aUstBalance);
        }
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            underlying.safeTransfer(vault, underlyingBalance);
        }
    }

    /**
     * Withdraws a specified amount back to the vault
     *
     * @notice Unlike `withdrawToVault`, this function only considers the
     * amount currently not invested, but only what is currently held by the
     * strategy
     *
     * @param amount Amount to withdraw
     */
    function withdrawToVault(uint256 amount)
        external
        override(IStrategy)
        restricted
    {
        underlying.safeTransfer(vault, amount);
    }

    /**
     * Updates the performance fee
     *
     * @notice Can only be called by governance
     *
     * @param _perfFeePct The new performance fee %
     */
    function setPerfFeePct(uint16 _perfFeePct) external restricted {
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");
        perfFeePct = _perfFeePct;
        emit PerfFeePctUpdated(_perfFeePct);
    }

    /**
     * Amount, expressed in the underlying currency, currently in the strategy
     *
     * @notice both held and invested amounts are included here, using the
     * latest known exchange rates to the underlying currency
     *
     * @return The total amount of underlying
     */
    function investedAssets()
        external
        view
        virtual
        override(IStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        return
            underlyingBalance +
            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *
                aUstBalance) / 1e18);
    }

    // Amount of underlying tokens in the strategy
    function _getUnderlyingBalance() internal view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    // Amount of UST tokens in the strategy
    function _getUstBalance() internal view returns (uint256) {
        return ustToken.balanceOf(address(this));
    }

    // Amount of aUST tokens in the strategy
    function _getAUstBalance() internal view returns (uint256) {
        return aUstToken.balanceOf(address(this));
    }

    // Amount of pending deposit operations
    function depositOperationLength() external view returns (uint256) {
        return depositOperations.length;
    }

    // Amount of pending redeem operations
    function redeemOperationLength() external view returns (uint256) {
        return redeemOperations.length;
    }
}",2363,303,"[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys

Submitted by WatchPug
The current implementation requires trusted key holders (`isTrusted[msg.sender]`) to send transactions (`initRedeemStable()`) to initialize withdrawals from EthAnchor before the users can withdraw funds from the contract.
  [M-05] Add a timelock to BaseStrategy:setPerfFeePct

Submitted by Dravee
To give more trust to users: functions that set key/critical variables should be put behind a timelock.

[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals
 
Submitted by leastwood, also found by danb
The investedAssets() function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in finishRedeemStable().
",3,,"pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import ""../lib/PercentMath.sol"";
import ""../vault/IVault.sol"";
import ""./IStrategy.sol"";
import ""./anchor/IEthAnchorRouter.sol"";
import ""./anchor/IExchangeRateFeeder.sol"";




abstract contract BaseStrategy is IStrategy, Trust {
    using SafeERC20 for IERC20;
    using PercentMath for uint256;

    event PerfFeeClaimed(uint256 amount);
    event PerfFeePctUpdated(uint256 pct);

    struct Operation {
        address operator;
        uint256 amount;
    }

    IERC20 public override(IStrategy) underlying;
    
    address public override(IStrategy) vault;

    
    address public treasury;

    
    IERC20 public ustToken;

    
    IERC20 public aUstToken;

    
    uint16 public perfFeePct;

    
    IEthAnchorRouter public ethAnchorRouter;

    
    IExchangeRateFeeder public exchangeRateFeeder;

    
    uint256 public pendingDeposits;

    
    uint256 public pendingRedeems;

    
    Operation[] public depositOperations;

    
    Operation[] public redeemOperations;

    
    uint256 public convertedUst;

    
    modifier restricted() {
        require(msg.sender == vault || isTrusted[msg.sender], ""restricted"");

        _;
    }

    modifier onlyVault() {
        require(msg.sender == vault, ""only vault"");

        _;
    }

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner
    ) Trust(_owner) {
        require(_ethAnchorRouter != address(0), ""0x addr"");
        require(_exchangeRateFeeder != address(0), ""0x addr"");
        require(address(_ustToken) != address(0), ""0x addr"");
        require(address(_aUstToken) != address(0), ""0x addr"");
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");

        treasury = _treasury;
        vault = _vault;
        underlying = IVault(_vault).underlying();
        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);
        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);
        ustToken = _ustToken;
        aUstToken = _aUstToken;
        perfFeePct = _perfFeePct;

        
        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);
        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);
    }

    
    function doHardWork() external virtual override(IStrategy) restricted {
        _initDepositStable();
    }

    function _initDepositStable() internal {
        uint256 ustBalance = _getUstBalance();
        require(ustBalance > 0, ""balance 0"");
        pendingDeposits += ustBalance;
        address _operator = ethAnchorRouter.initDepositStable(ustBalance);
        depositOperations.push(
            Operation({operator: _operator, amount: ustBalance})
        );
    }

    
    function finishDepositStable(uint256 idx) external {
        require(depositOperations.length > idx, ""not running"");
        Operation storage operation = depositOperations[idx];
        ethAnchorRouter.finishDepositStable(operation.operator);

        pendingDeposits -= operation.amount;
        convertedUst += operation.amount;

        operation.operator = depositOperations[depositOperations.length - 1]
            .operator;
        operation.amount = depositOperations[depositOperations.length - 1]
            .amount;
        depositOperations.pop();
    }

    
    function initRedeemStable(uint256 amount) public restricted {
        uint256 aUstBalance = _getAUstBalance();
        require(amount > 0, ""amount 0"");
        require(aUstBalance >= amount, ""insufficient"");
        pendingRedeems += amount;
        address _operator = ethAnchorRouter.initRedeemStable(amount);
        redeemOperations.push(Operation({operator: _operator, amount: amount}));
    }

    
    function finishRedeemStable(uint256 idx) public virtual {
        require(redeemOperations.length > idx, ""not running"");
        Operation storage operation = redeemOperations[idx];
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;
        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;
        uint256 ustBalanceBefore = _getUstBalance();

        ethAnchorRouter.finishRedeemStable(operation.operator);

        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;
        uint256 perfFee = redeemedAmount > originalUst
            ? (redeemedAmount - originalUst).percOf(perfFeePct)
            : 0;
        if (perfFee > 0) {
            ustToken.safeTransfer(treasury, perfFee);
            emit PerfFeeClaimed(perfFee);
        }
        convertedUst -= originalUst;
        pendingRedeems -= operation.amount;

        operation.operator = redeemOperations[redeemOperations.length - 1]
            .operator;
        operation.amount = redeemOperations[redeemOperations.length - 1].amount;
        redeemOperations.pop();
    }

    
    function withdrawAllToVault() external override(IStrategy) restricted {
        uint256 aUstBalance = _getAUstBalance();
        if (aUstBalance > 0) {
            initRedeemStable(aUstBalance);
        }
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            underlying.safeTransfer(vault, underlyingBalance);
        }
    }

    
    function withdrawToVault(uint256 amount)
        external
        override(IStrategy)
        restricted
    {
        underlying.safeTransfer(vault, amount);
    }

    
    function setPerfFeePct(uint16 _perfFeePct) external restricted {
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");
        perfFeePct = _perfFeePct;
        emit PerfFeePctUpdated(_perfFeePct);
    }

    
    function investedAssets()
        external
        view
        virtual
        override(IStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        return
            underlyingBalance +
            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *
                aUstBalance) / 1e18);
    }

    
    function _getUnderlyingBalance() internal view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    
    function _getUstBalance() internal view returns (uint256) {
        return ustToken.balanceOf(address(this));
    }

    
    function _getAUstBalance() internal view returns (uint256) {
        return aUstToken.balanceOf(address(this));
    }

    
    function depositOperationLength() external view returns (uint256) {
        return depositOperations.length;
    }

    
    function redeemOperationLength() external view returns (uint256) {
        return redeemOperations.length;
    }
}",1636,0,3,,"{'ReviewingTheCode': ""The code is a Solidity smart contract named 'BaseStrategy' that implements a strategy for managing assets in a vault. It interacts with external contracts for token management, deposit, and redemption operations. The contract uses OpenZeppelin and Solmate libraries for secure token handling and authorization."", 'IdentifyingKeyComponents': {'ContractName': 'BaseStrategy', 'Purpose': 'To manage and execute strategies for depositing and redeeming assets in a vault, including performance fee calculations and interactions with an anchor protocol for stablecoin operations.', 'InheritanceAndImports': {'InheritsFrom': ['IStrategy', 'Trust'], 'Imports': ['@openzeppelin/contracts/token/ERC20/IERC20.sol', '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol', '@rari-capital/solmate/src/auth/Trust.sol', '../lib/PercentMath.sol', '../vault/IVault.sol', './IStrategy.sol', './anchor/IEthAnchorRouter.sol', './anchor/IExchangeRateFeeder.sol']}, 'StateVariables': [{'Name': 'underlying', 'Type': 'IERC20', 'Purpose': 'The underlying token managed by the strategy.'}, {'Name': 'vault', 'Type': 'address', 'Purpose': 'The address of the vault that this strategy is associated with.'}, {'Name': 'treasury', 'Type': 'address', 'Purpose': 'The address where performance fees are sent.'}, {'Name': 'ustToken', 'Type': 'IERC20', 'Purpose': 'The UST token used in the strategy.'}, {'Name': 'aUstToken', 'Type': 'IERC20', 'Purpose': 'The aUST token used in the strategy.'}, {'Name': 'perfFeePct', 'Type': 'uint16', 'Purpose': 'The percentage of performance fee charged on profits.'}, {'Name': 'ethAnchorRouter', 'Type': 'IEthAnchorRouter', 'Purpose': 'The router for interacting with the EthAnchor protocol.'}, {'Name': 'exchangeRateFeeder', 'Type': 'IExchangeRateFeeder', 'Purpose': 'The feeder for exchange rate information.'}, {'Name': 'pendingDeposits', 'Type': 'uint256', 'Purpose': 'The amount of UST pending to be deposited.'}, {'Name': 'pendingRedeems', 'Type': 'uint256', 'Purpose': 'The amount of aUST pending to be redeemed.'}, {'Name': 'depositOperations', 'Type': 'Operation[]', 'Purpose': 'Array of ongoing deposit operations.'}, {'Name': 'redeemOperations', 'Type': 'Operation[]', 'Purpose': 'Array of ongoing redeem operations.'}, {'Name': 'convertedUst', 'Type': 'uint256', 'Purpose': 'The total amount of UST converted to aUST.'}], 'FunctionsAndModifiers': [{'Name': 'doHardWork', 'Visibility': 'external', 'Purpose': ""Executes the strategy's main operations, starting with deposit."", 'Parameters': [], 'Returns': []}, {'Name': '_initDepositStable', 'Visibility': 'internal', 'Purpose': 'Initiates a deposit of UST tokens into the EthAnchor protocol.', 'Parameters': [], 'Returns': []}, {'Name': 'finishDepositStable', 'Visibility': 'external', 'Purpose': 'Finalizes a deposit operation.', 'Parameters': ['uint256 idx'], 'Returns': []}, {'Name': 'initRedeemStable', 'Visibility': 'public', 'Purpose': 'Initiates a redemption of aUST tokens from the EthAnchor protocol.', 'Parameters': ['uint256 amount'], 'Returns': []}, {'Name': 'finishRedeemStable', 'Visibility': 'public', 'Purpose': 'Finalizes a redemption operation and calculates performance fees.', 'Parameters': ['uint256 idx'], 'Returns': []}, {'Name': 'withdrawAllToVault', 'Visibility': 'external', 'Purpose': 'Withdraws all assets back to the vault.', 'Parameters': [], 'Returns': []}, {'Name': 'withdrawToVault', 'Visibility': 'external', 'Purpose': 'Withdraws a specified amount of assets back to the vault.', 'Parameters': ['uint256 amount'], 'Returns': []}, {'Name': 'setPerfFeePct', 'Visibility': 'external', 'Purpose': 'Sets the performance fee percentage.', 'Parameters': ['uint16 _perfFeePct'], 'Returns': []}, {'Name': 'investedAssets', 'Visibility': 'external', 'Purpose': 'Returns the total amount of assets managed by the strategy.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_getUnderlyingBalance', 'Visibility': 'internal', 'Purpose': 'Returns the balance of the underlying token held by the contract.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_getUstBalance', 'Visibility': 'internal', 'Purpose': 'Returns the balance of UST tokens held by the contract.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_getAUstBalance', 'Visibility': 'internal', 'Purpose': 'Returns the balance of aUST tokens held by the contract.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'depositOperationLength', 'Visibility': 'external', 'Purpose': 'Returns the number of ongoing deposit operations.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'redeemOperationLength', 'Visibility': 'external', 'Purpose': 'Returns the number of ongoing redeem operations.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'restricted', 'Visibility': 'modifier', 'Purpose': 'Restricts function access to the vault or trusted addresses.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyVault', 'Visibility': 'modifier', 'Purpose': 'Restricts function access to the vault only.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['IERC20 (OpenZeppelin)', 'SafeERC20 (OpenZeppelin)', 'Trust (Solmate)', 'IVault', 'IEthAnchorRouter', 'IExchangeRateFeeder'], 'SpecialMechanisms': ['Performance fee calculation on redemption profits.', 'Use of arrays to track ongoing deposit and redemption operations.', 'Approval of maximum uint256 for token allowances to the EthAnchorRouter.'], 'Questions': ['How are the deposit and redeem operations managed in terms of concurrency and potential race conditions?', 'What is the exact mechanism for calculating the exchange rate between aUST and UST?', 'Are there any safeguards in place to handle potential failures in the EthAnchorRouter operations?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerabilities in `finishDepositStable` and `finishRedeemStable`', 'Severity': 'High', 'Description': 'Both functions make external calls before updating state variables (`pendingDeposits`, `convertedUst`, `pendingRedeems`), enabling reentrant attacks. The contract lacks reentrancy protection mechanisms (e.g., `nonReentrant` modifier), making it susceptible to fund drainage.', 'Impact': 'Attackers could repeatedly call these functions before state updates, potentially draining contract funds.', 'Location': 'BaseStrategy.sol: `finishDepositStable`, `finishRedeemStable`, `withdrawAllToVault`'}, {'Issue': 'Unhandled External Calls in `finishDepositStable` and `finishRedeemStable`', 'Severity': 'High', 'Description': 'External calls to `ethAnchorRouter` lack failure handling. If calls fail, state changes (e.g., `pendingDeposits`, `convertedUst`) still occur, causing inconsistencies.', 'Impact': 'State corruption and potential fund loss due to unhandled call failures.', 'Location': 'BaseStrategy.sol: `finishDepositStable`, `finishRedeemStable`'}, {'Issue': 'Potential Arithmetic Overflow/Underflow in `finishRedeemStable`', 'Severity': 'High', 'Description': 'Calculations like `convertedUst -= originalUst` risk underflow if `originalUst > convertedUst`. Division by zero may occur if `aUstBalance` is zero.', 'Impact': 'Incorrect state tracking or transaction reverts, leading to financial discrepancies or denial of service.', 'Location': 'BaseStrategy.sol: `finishRedeemStable`'}, {'Issue': 'Incorrect Enforcement of `onlyVault` Modifier', 'Severity': 'High', 'Description': 'The `onlyVault` modifier is defined but unused, allowing unauthorized access to vault-restricted functions.', 'Impact': 'Unauthorized entities could manipulate vault-only functions, risking fund loss.', 'Location': 'Modifier definition at line 57'}, {'Issue': 'Unvalidated External Contract Calls', 'Severity': 'Medium', 'Description': 'Calls to `ethAnchorRouter` and `exchangeRateFeeder` lack return value validation or trust checks, risking malicious behavior.', 'Impact': 'Unexpected behavior or fund loss due to compromised external contracts.', 'Location': 'BaseStrategy.sol: `finishDepositStable`, `finishRedeemStable`, `investedAssets`'}, {'Issue': 'Inaccurate Exchange Rate and Asset Calculations', 'Severity': 'Medium', 'Description': '`investedAssets` relies on unverified `exchangeRateFeeder` data, and `finishRedeemStable` miscalculates performance fees by assuming redeemed amounts are always profit. `convertedUst` and pending operation arrays may desync from actual state.', 'Impact': 'Misrepresented asset values, incorrect fee applications, and financial discrepancies.', 'Location': 'BaseStrategy.sol: `investedAssets`, `finishRedeemStable`, `finishDepositStable`'}, {'Issue': 'Insufficient Access Control on `setPerfFeePct`', 'Severity': 'Medium', 'Description': 'The `restricted` modifier allows overly broad access, and the function lacks bounds checks, enabling unreasonable fee settings.', 'Impact': 'Excessive fees or economic model disruption by trusted actors.', 'Location': 'BaseStrategy.sol: `setPerfFeePct`'}, {'Issue': 'Inefficient Storage Usage in Operations Arrays', 'Severity': 'Medium', 'Description': '`depositOperations` and `redeemOperations` arrays use gas-inefficient modifications (replacing and popping elements) and can grow unbounded, increasing costs.', 'Impact': 'Higher gas fees and potential out-of-gas errors as operations accumulate.', 'Location': 'BaseStrategy.sol: `finishDepositStable`, `finishRedeemStable`'}, {'Issue': 'Public Visibility of Sensitive Functions', 'Severity': 'Medium', 'Description': 'Critical functions like `finishDepositStable` and `finishRedeemStable` are public, exposing them to misuse.', 'Impact': 'Unauthorized interference with deposit/redeem operations.', 'Location': 'BaseStrategy.sol: `finishDepositStable`, `finishRedeemStable`'}, {'Issue': 'Incomplete Use of `Trust` Contract', 'Severity': 'Low', 'Description': 'The inherited `Trust` contract lacks dynamic address management, reducing flexibility.', 'Impact': 'Operational inefficiencies if trusted addresses need updates.', 'Location': 'Inheritance of `Trust` contract at line 12'}, {'Issue': 'Redundant Storage Writes in Operations Handling', 'Severity': 'Low', 'Description': 'Replacing and popping array elements in `finishDepositStable`/`finishRedeemStable` causes redundant storage writes.', 'Impact': 'Minor gas cost increases due to unoptimized operations.', 'Location': 'BaseStrategy.sol: `finishDepositStable`, `finishRedeemStable`'}], 'IssueNumber': 21, 'OutputList': 11}",306.37509775161743,"### **Output**

---

**[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys**

**Report Description**:  
The current implementation requires trusted key holders (`isTrusted[msg.sender]`) to send transactions (`initRedeemStable()`) to initialize withdrawals from EthAnchor before users can withdraw funds from the contract. If these key holders lose access to their keys, funds could be frozen indefinitely, leading to a centralization risk and potential loss of user funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the centralization risk associated with trusted key holders losing access to their keys. This issue is entirely missed, and no corresponding response is provided.

---

**[M-05] Add a timelock to BaseStrategy:setPerfFeePct**

**Report Description**:  
To increase user trust, functions that set key or critical variables (e.g., `setPerfFeePct`) should be put behind a timelock. This ensures that users have time to react to changes and prevents sudden or malicious adjustments to critical parameters.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Access Control on `setPerfFeePct`""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of access control and bounds checks on `setPerfFeePct`, which aligns with the issue's concern about critical variable changes. However, it does not mention the need for a timelock, which is a key recommendation in the issue report. The response partially addresses the issue but misses a critical detail.

---

**[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Report Description**:  
The `investedAssets()` function, implemented by the vault's strategy contracts, expresses a vault's investments in terms of the underlying currency. However, it does not account for the performance fee charged by the treasury, as shown in `finishRedeemStable()`. This oversight could lead to inaccurate representations of the vault's assets and misaligned financial calculations.

**Match in Response List**:  
Matches with the issue titled **""Inaccurate Exchange Rate and Asset Calculations""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with `investedAssets()` relying on unverified data and miscalculating performance fees. It correctly highlights the risk of misrepresented asset values and financial discrepancies, which aligns with the issue report's concerns.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Partially Correct Matches**:

- **[M-05] Add a timelock to BaseStrategy:setPerfFeePct**

**Missed Issues from Issue Report**:

- **[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys**

--- 

This evaluation highlights the coverage, accuracy, and sufficiency of the responses in addressing the issues reported. While some issues are correctly or partially addressed, others are entirely missed, indicating gaps in the response list.","```
1. Inaccurate Exchange Rate and Asset Calculations
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Inaccurate Exchange Rate and Asset Calculations"".
   - This issue appears at rank 6 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - At rank 6, there is 1 true positive.
   - \( P@6 = \frac{1}{6} \approx 0.1667 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - \( AP = 0.1667 \).

**Output**:
```
0.1667
```"
