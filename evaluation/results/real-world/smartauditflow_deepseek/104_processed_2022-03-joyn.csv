nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTXStakingZap.sol,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888,428,"[H-01] ERC20 transferFrom return values not checked
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.
",1,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888,1,0,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the `nonReentrant` modifier is correctly applied to all functions that interact with external contracts to prevent reentrancy attacks."",
        ""Check for potential integer overflows/underflows in arithmetic operations, especially in functions like `provideInventory721`, `provideInventory1155`, and `_addLiquidityAndLock`."",
        ""Ensure that all external calls (e.g., `transferFrom`, `safeBatchTransferFrom`, `approve`) are properly handled and checked for success to avoid unexpected behavior."",
        ""Review the `rescue` function to ensure it cannot be exploited to drain funds from the contract by unauthorized users.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC721 and ERC1155 standards in handling NFT transfers and approvals."",
        ""Ensure that the contract complies with ERC20 standards when interacting with WETH and other ERC20 tokens.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic in `transferFromERC721` and `approveERC721` functions to ensure they correctly handle special cases like CryptoKitties and CryptoPunks."",
        ""Analyze the `pairFor` function to ensure it correctly calculates the pair address for Uniswap/Sushiswap liquidity pools."",
        ""Check the logic in `_addLiquidityAndLock` to ensure it correctly handles liquidity provision and locking of LP tokens.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Review all interactions with external contracts (e.g., `INFTXVault`, `INFTXLPStaking`, `IUniswapV2Router01`) to ensure they are safe and correctly implemented."",
        ""Ensure that the contract handles potential failures in external calls gracefully, especially in functions like `addLiquidity721ETHTo` and `addLiquidity1155ETHTo`.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call critical functions like `setLPLockTime`, `setInventoryLockTime`, and `rescue`."",
        ""Ensure that the `onlyOwner` modifier is correctly applied to all functions that require restricted access.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, especially in loops and external calls within functions like `provideInventory721` and `provideInventory1155`."",
        ""Consider using `transfer` instead of `call` for ETH transfers to save gas, where applicable.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the contract handles slippage correctly in functions like `addLiquidity721ETHTo` and `addLiquidity1155ETHTo` by using the `minWethIn` and `minEthIn` parameters."",
        ""Review the logic for adding liquidity to ensure it protects against impermanent loss and manipulation.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Verify that the `timelockMintFor` and `timelockDepositFor` functions correctly handle the locking of tokens for the specified periods."",
        ""Ensure that the `UserStaked` event is emitted correctly to track staking activities.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Review the contract for potential front-running vulnerabilities, especially in functions that involve adding liquidity or staking tokens."",
        ""Consider implementing a commit-reveal scheme to mitigate front-running risks.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract has mechanisms to pause or halt operations in case of an emergency, such as a security breach."",
        ""Review the `receive` function to ensure it correctly handles incoming ETH transfers.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code is a Solidity smart contract named `NFTXStakingZap` that facilitates staking and liquidity provision for NFTs in the NFTX ecosystem. It interacts with various external contracts, including NFTX vaults, Uniswap, and staking contracts, to allow users to stake NFTs and provide liquidity in exchange for rewards. The contract is designed to handle both ERC721 and ERC1155 tokens, and it includes mechanisms for locking liquidity and inventory for specified periods."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXStakingZap"",
    ""Purpose"": ""To enable users to stake NFTs and provide liquidity in the NFTX ecosystem, with mechanisms for locking liquidity and inventory for specified periods."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ReentrancyGuard"", ""ERC721HolderUpgradeable"", ""ERC1155HolderUpgradeable""],
      ""Imports"": [
        ""./interface/INFTXVault.sol"",
        ""./interface/INFTXVaultFactory.sol"",
        ""./interface/INFTXSimpleFeeDistributor.sol"",
        ""./interface/INFTXLPStaking.sol"",
        ""./interface/INFTXInventoryStaking.sol"",
        ""./interface/ITimelockRewardDistributionToken.sol"",
        ""./interface/IUniswapV2Router01.sol"",
        ""./testing/IERC721.sol"",
        ""./token/IERC1155Upgradeable.sol"",
        ""./token/IERC20Upgradeable.sol"",
        ""./token/ERC721HolderUpgradeable.sol"",
        ""./token/ERC1155HolderUpgradeable.sol"",
        ""./util/OwnableUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""WETH"",
        ""Type"": ""IWETH"",
        ""Purpose"": ""Wrapped Ether contract interface for handling ETH/WETH conversions.""
      },
      {
        ""Name"": ""lpStaking"",
        ""Type"": ""INFTXLPStaking"",
        ""Purpose"": ""Interface for the LP staking contract.""
      },
      {
        ""Name"": ""inventoryStaking"",
        ""Type"": ""INFTXInventoryStaking"",
        ""Purpose"": ""Interface for the inventory staking contract.""
      },
      {
        ""Name"": ""nftxFactory"",
        ""Type"": ""INFTXVaultFactory"",
        ""Purpose"": ""Interface for the NFTX vault factory contract.""
      },
      {
        ""Name"": ""sushiRouter"",
        ""Type"": ""IUniswapV2Router01"",
        ""Purpose"": ""Interface for the Sushiswap router contract.""
      },
      {
        ""Name"": ""lpLockTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration for which LP tokens are locked.""
      },
      {
        ""Name"": ""inventoryLockTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration for which inventory tokens are locked.""
      },
      {
        ""Name"": ""BASE"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant representing the base unit for calculations.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setLPLockTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set the lock time for LP tokens."",
        ""Parameters"": [""uint256 newLPLockTime""],
        ""Returns"": []
      },
      {
        ""Name"": ""setInventoryLockTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set the lock time for inventory tokens."",
        ""Parameters"": [""uint256 newInventoryLockTime""],
        ""Returns"": []
      },
      {
        ""Name"": ""provideInventory721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to provide ERC721 tokens to the inventory staking contract."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory tokenIds""],
        ""Returns"": []
      },
      {
        ""Name"": ""provideInventory1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to provide ERC1155 tokens to the inventory staking contract."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory tokenIds"", ""uint256[] memory amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addLiquidity721ETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to add liquidity for ERC721 tokens using ETH."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethIn""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""addLiquidity1155ETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to add liquidity for ERC1155 tokens using ETH."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minEthIn""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""addLiquidity721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to add liquidity for ERC721 tokens using WETH."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethIn"", ""uint256 wethIn""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""addLiquidity1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to add liquidity for ERC1155 tokens using WETH."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minWethIn"", ""uint256 wethIn""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Prevents reentrancy attacks."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to the owner of the contract."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""INFTXVault"",
    ""INFTXVaultFactory"",
    ""INFTXSimpleFeeDistributor"",
    ""INFTXLPStaking"",
    ""INFTXInventoryStaking"",
    ""ITimelockRewardDistributionToken"",
    ""IUniswapV2Router01"",
    ""IWETH"",
    ""IERC721"",
    ""IERC1155Upgradeable"",
    ""IERC20Upgradeable""
  ],
  ""SpecialMechanisms"": [
    ""ReentrancyGuard: Used to prevent reentrancy attacks."",
    ""Ownable: Restricts certain functions to the contract owner."",
    ""ERC721HolderUpgradeable and ERC1155HolderUpgradeable: Allow the contract to receive ERC721 and ERC1155 tokens."",
    ""Timelock mechanisms: Lock LP and inventory tokens for specified periods.""
  ],
  ""Questions"": [
    ""How are the `transferFromERC721` and `approveERC721` functions handling special cases like CryptoKitties and CryptoPunks?"",
    ""What is the purpose of the `pairFor` function and how does it calculate the pair address?"",
    ""Are there any potential security risks associated with the `rescue` function, which allows the owner to withdraw any ERC20 token from the contract?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in ETH Handling"",
      ""Severity"": ""High"",
      ""Description"": ""The contract uses `call` to send ETH back to the user in functions like `addLiquidity721ETHTo` and `addLiquidity1155ETHTo`. This can potentially lead to reentrancy attacks if the recipient is a malicious contract, despite the use of the `nonReentrant` modifier. The risk arises because the `call` method does not limit gas or check return values, and state changes may not be fully secured before external calls."",
      ""Impact"": ""An attacker could exploit this to re-enter the contract and manipulate state or steal funds."",
      ""Location"": ""Functions: `addLiquidity721ETHTo`, `addLiquidity1155ETHTo`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `provideInventory721` and `provideInventory1155`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `provideInventory721` and `provideInventory1155` do not validate the length or content of `tokenIds` and `amounts` arrays. This could lead to unexpected behavior, runtime errors, or gas exhaustion if large or mismatched arrays are provided."",
      ""Impact"": ""Potential denial of service (DoS), incorrect state updates, or loss of funds due to invalid inputs."",
      ""Location"": ""Functions: `provideInventory721`, `provideInventory1155`""
    },
    {
      ""Issue"": ""Unrestricted Approval in Constructor"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor grants unlimited approval to the SushiSwap router for WETH tokens. This could be risky if the router is compromised or contains bugs, as it would allow the router to spend the contract's entire WETH balance."",
      ""Impact"": ""Potential loss of funds if the SushiSwap router is exploited or behaves maliciously."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Unbounded Loops in ERC721 and ERC1155 Handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `_addLiquidity721WETH`, `_addLiquidity1155WETH`, `provideInventory721`, and `provideInventory1155` contain loops over user-provided arrays. If these arrays are too large, they could cause out-of-gas errors, leading to transaction failures."",
      ""Impact"": ""Denial of service (DoS) due to gas exhaustion when processing large arrays."",
      ""Location"": ""Functions: `_addLiquidity721WETH`, `_addLiquidity1155WETH`, `provideInventory721`, `provideInventory1155`""
    },
    {
      ""Issue"": ""Potential Front-Running in Liquidity Provision"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `_addLiquidityAndLock`, `addLiquidity721To`, and `addLiquidity1155To` are susceptible to front-running attacks. Attackers could manipulate the liquidity pool state or exchange rates before the transaction is confirmed, leading to unfavorable terms for users."",
      ""Impact"": ""Financial loss due to manipulated liquidity provision or slippage."",
      ""Location"": ""Functions: `_addLiquidityAndLock`, `addLiquidity721To`, `addLiquidity1155To`""
    },
    {
      ""Issue"": ""Hardcoded Addresses for Special NFTs"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract hardcodes addresses for specific NFTs (e.g., CryptoKitties and CryptoPunks) in functions like `transferFromERC721` and `approveERC721`. This reduces flexibility and could cause issues if these contracts are upgraded or their addresses change."",
      ""Impact"": ""Reduced flexibility and potential incompatibility with future NFT standards or updates."",
      ""Location"": ""Functions: `transferFromERC721`, `approveERC721`""
    },
    {
      ""Issue"": ""Lack of Event Emission in Critical Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical functions like `setLPLockTime`, `setInventoryLockTime`, and `rescue` do not emit events when modifying state or performing sensitive actions. This reduces transparency and makes off-chain monitoring difficult."",
      ""Impact"": ""Reduced auditability and transparency of contract state changes."",
      ""Location"": ""Functions: `setLPLockTime`, `setInventoryLockTime`, `rescue`""
    },
    {
      ""Issue"": ""Unsafe Use of `call` in ETH Transfers"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `payable(to).call{value: ...}` for ETH transfers, which does not check return values or limit gas. While not directly exploitable in isolation, this pattern is less secure than alternatives like `transfer` or `send`."",
      ""Impact"": ""Potential gas inefficiency or unexpected behavior if the recipient's fallback function is complex."",
      ""Location"": ""Functions: `addLiquidity721ETHTo`, `addLiquidity1155ETHTo`""
    }
  ],
  ""IssueNumber"": 54,
  ""OutputList"": 8
}",444.0463228225708,120350.0,28.0,"### **[H-01] ERC20 transferFrom return values not checked**

**Report Description**:  
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked. Failing to validate the return value of `transferFrom()` could lead to silent failures, especially when dealing with non-compliant or malicious ERC20 tokens. This oversight may result in incorrect token balances or loss of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unchecked `transferFrom()` return values. None of the findings in the response list mention or describe the risks associated with failing to validate the return value of ERC20 `transferFrom()` calls. This is a critical oversight, as it directly impacts the security and reliability of token transfers in the contract.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] ERC20 transferFrom return values not checked**

---

### **Analysis**  
The response list fails to address the issue of unchecked `transferFrom()` return values, which is a significant security concern. This gap highlights the need for a more comprehensive review of the contract's handling of ERC20 token transfers, particularly focusing on validating return values to prevent silent failures and potential loss of funds.","```
None.
```",0.0
Splitter.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title Splitter
 * Building on the work from the Uniswap team at Uniswap and mirror.xyz Team
 */
contract Splitter is SplitStorage {
    /**** Mutable variables ****/
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    // The TransferETH event is emitted after each eth transfer in the split is attempted.
    event TransferETH(
        // The account to which the transfer was attempted.
        address account,
        // The amount for transfer that was attempted.
        uint256 amount,
        // Whether or not the transfer succeeded.
        bool success
    );

    // Emits when a window is incremented.
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    /**
     * @dev Claim the funds from the all windows.
     * @param percentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        // Make sure that the user has this allocation granted.
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    /**
     * @dev get Node hash of given data.
     * @param who {address} whitelisted user address
     * @param percentageAllocation {uint256} percentage of allocation
     * @return {bytes32} node hash
     */
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    /**
     * @dev get scaled amount from given amount and percentage.
     * @param amount {uint256} amount
     * @param scaledPercent {uint256} scaled percentage
     * @return scaledAmount {uint256} scaled amount
     */
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        /*
            Example:
                If there is 100 ETH in the account, and someone has 
                an allocation of 2%, we call this with 100 as the amount, and 200
                as the scaled percent.

                To find out the amount we use, for example: (100 * 200) / (100 * 100)
                which returns 2 -- i.e. 2% of the 100 ETH balance.
         */
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    /**
     * @dev claim for the given window.
     * @param window {uint256} Window to claim
     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            // The absolute amount that's claimable.
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    /**
     * @dev Function which handles increment window and puts amount to current window
     * @param royaltyAmount {uint256} Amount needs to be added in window.
     * @return {bool} Whether or not the window was incremented.
     */
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bool} Whether or not the window has been claimed.
     */
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    /**** Private Functions ****/

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     */
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    /**
     * @dev Function which returns the hash of the given window, tokenId and membershipContract.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bytes32} Hash of the given window, tokenId and membershipContract.
     */
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    /**
     * @dev Function to convert output amount from percentages.
     * @param amount {uint256} Amount for which percentage is to be calculated.
     * @param percent {uint256} Percentage
     * @return {uint256} Output amount.
     */
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        // Solidity 0.8.0 lets us do this without SafeMath.
        return (amount * percent) / 100;
    }

    /**
     * @dev Function to transfer split asset to the given address.
     * @param to {address} Address to transfer the split asset to.
     * @param value {uint256} Amount to transfer.
     */
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        // Try to transfer ETH to the given recipient.
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    /**
     * @dev transfer given amount of ETH in contract to the given address.
     * @param to {address} Address to transfer asset
     * @param value {uint256} Amount to transfer
     * @return {bool} Whether or not the transfer was successful.
     */
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        // Here increase the gas limit a reasonable amount above the default, and try
        // to send ETH to the recipient.
        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol
    /**
     * @dev Function to verify the given proof.
     * @param proof {bytes32[]} Proof to verify
     * @param root {bytes32} Root of the Merkle tree
     * @param leaf {bytes32} Leaf to verify
     * @return {bool} Whether or not the proof is valid.
     */
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",2162,293,"[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract
In general, the Splitter contract's `incrementWindow` function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the `incrementWindow` function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or `claimForAllWindows ` functions to steal the tokens in the contract.
  [H-03] DoS: claimForAllWindows() May Be Made Unusable By An Attacker
When the value of currentWindow is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.
currentWindow can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.
Furthermore, an attacker can continually increment currentWindow by calling `incrementWindow()`. An attacker can impersonate a IRoyaltyVault and send 1 WEI worth of WETH to pass the required checks.
  [M-02] Fixed Amount of Gas Sent in Call May Be Insufficient
The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the receive() function. As a result the user would be unable to receive funds from this function.
",3,,"pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";


contract Splitter is SplitStorage {
    
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    
    event TransferETH(
        
        address account,
        
        uint256 amount,
        
        bool success
    );

    
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    

    
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        
        return (amount * percent) / 100;
    }

    
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        
        
        
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    
    
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        
        return computedHash == root;
    }
}",1136,2,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in the `transferSplitAsset` and `attemptETHTransfer` functions."",
        ""Verify that all arithmetic operations are protected against overflow and underflow, especially in `scaleAmountByPercentage` and `amountFromPercent`."",
        ""Ensure that external calls to `IRoyaltyVault` and `IERC20` are safe and do not introduce vulnerabilities."",
        ""Review the Merkle proof verification in `verifyProof` to ensure it is correctly implemented and resistant to hash collisions.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to the ERC-20 standard, especially in the `transferSplitAsset` function."",
        ""Ensure that the contract complies with any relevant royalty distribution standards or guidelines.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic in `claimForAllWindows` and `claim` to ensure correct handling of multiple windows and claims."",
        ""Validate the correctness of the Merkle tree node generation in `getNode` and the hash generation in `getClaimHash`.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the interaction with `IRoyaltyVault` in `incrementWindow` to ensure it is secure and properly authenticated."",
        ""Review the interaction with `IERC20` in `transferSplitAsset` to ensure it handles token transfers correctly.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that only authorized entities can call `incrementWindow` by verifying the checks against `IRoyaltyVault`."",
        ""Review the `claim` and `claimForAllWindows` functions to ensure they are only callable by eligible users.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Optimize the loop in `claimForAllWindows` to reduce gas costs, especially for large numbers of windows."",
        ""Review the gas usage in `verifyProof` and consider optimizations for large proof arrays.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the contract does not interact with liquidity pools or AMMs in a way that could be exploited.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Verify that the contract is not vulnerable to flash loan attacks, especially in the `claim` and `claimForAllWindows` functions.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Ensure that the contract does not rely on external oracles for critical operations.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Review any governance mechanisms to ensure they are secure and resistant to manipulation.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the contract does not implement staking or reward mechanisms that could be exploited.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Verify that the contract does not introduce inflationary token models or other tokenomics risks.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities in the `claim` and `claimForAllWindows` functions."",
        ""Consider implementing commit-reveal schemes if necessary.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract does not allow for unauthorized fund drainage or malicious exits.""
      ]
    },
    {
      ""Area"": ""Cross-Chain Security"",
      ""Tasks"": [
        ""Verify that the contract does not interact with cross-chain protocols in a way that could introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract includes mechanisms to halt operations in case of an emergency.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided Solidity smart contract, named 'Splitter', is designed to manage and distribute funds (likely royalties) across multiple windows using a Merkle tree for proof verification. It inherits from 'SplitStorage' and interacts with an external 'IRoyaltyVault' interface and the 'IERC20' standard. The contract includes mechanisms for claiming funds, verifying proofs, and incrementing windows."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Splitter"",
    ""Purpose"": ""To manage and distribute funds across multiple windows using Merkle proofs for verification."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""SplitStorage""],
      ""Imports"": [
        ""IRoyaltyVault from @chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"",
        ""IERC20 from @openzeppelin/contracts/token/ERC20/IERC20.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""PERCENTAGE_SCALE"",
        ""Type"": ""uint256"",
        ""Purpose"": ""A constant used to scale percentages, set to 10e5.""
      },
      {
        ""Name"": ""IID_IROYALTY"",
        ""Type"": ""bytes4"",
        ""Purpose"": ""The interface ID for the IRoyaltyVault interface.""
      },
      {
        ""Name"": ""currentWindow"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Tracks the current window for fund distribution.""
      },
      {
        ""Name"": ""balanceForWindow"",
        ""Type"": ""uint256[]"",
        ""Purpose"": ""Stores the balance available for each window.""
      },
      {
        ""Name"": ""claimed"",
        ""Type"": ""mapping(bytes32 => bool)"",
        ""Purpose"": ""Tracks whether a claim has been made for a specific window and address.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""claimForAllWindows"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to claim funds for all windows they are eligible for."",
        ""Parameters"": [""uint256 percentageAllocation"", ""bytes32[] calldata merkleProof""],
        ""Returns"": []
      },
      {
        ""Name"": ""getNode"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Generates a Merkle tree node hash from an address and a percentage allocation."",
        ""Parameters"": [""address who"", ""uint256 percentageAllocation""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""scaleAmountByPercentage"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Scales an amount by a given percentage."",
        ""Parameters"": [""uint256 amount"", ""uint256 scaledPercent""],
        ""Returns"": [""uint256 scaledAmount""]
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to claim funds for a specific window."",
        ""Parameters"": [""uint256 window"", ""uint256 scaledPercentageAllocation"", ""bytes32[] calldata merkleProof""],
        ""Returns"": []
      },
      {
        ""Name"": ""incrementWindow"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Increments the current window and adds funds to the new window."",
        ""Parameters"": [""uint256 royaltyAmount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""isClaimed"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if a claim has been made for a specific window and address."",
        ""Parameters"": [""address who"", ""uint256 window""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""setClaimed"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Marks a claim as made for a specific window and address."",
        ""Parameters"": [""address who"", ""uint256 window""],
        ""Returns"": []
      },
      {
        ""Name"": ""getClaimHash"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Generates a hash for a specific window and address."",
        ""Parameters"": [""address who"", ""uint256 window""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""amountFromPercent"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Calculates an amount based on a percentage."",
        ""Parameters"": [""uint256 amount"", ""uint32 percent""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""transferSplitAsset"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Transfers a specified amount of the split asset to a recipient."",
        ""Parameters"": [""address to"", ""uint256 value""],
        ""Returns"": [""bool didSucceed""]
      },
      {
        ""Name"": ""attemptETHTransfer"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Attempts to transfer ETH to a recipient."",
        ""Parameters"": [""address to"", ""uint256 value""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""verifyProof"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Verifies a Merkle proof against a root and leaf."",
        ""Parameters"": [""bytes32[] memory proof"", ""bytes32 root"", ""bytes32 leaf""],
        ""Returns"": [""bool""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IRoyaltyVault: Used to verify the sender is a supported royalty vault and to get the splitter address."",
    ""IERC20: Used to interact with the split asset (likely an ERC20 token).""
  ],
  ""SpecialMechanisms"": [
    ""Merkle Proof Verification: Used to verify claims for funds."",
    ""Window Incrementation: Allows the contract to move to a new window and add funds to it.""
  ],
  ""Questions"": [
    ""What is the purpose of the 'PERCENTAGE_SCALE' constant and why is it set to 10e5?"",
    ""How is the 'merkleRoot' initialized and managed?"",
    ""What is the role of the 'SplitStorage' contract and what does it contain?"",
    ""How is the 'splitAsset' address determined and managed?"",
    ""Is there a mechanism to handle failed ETH transfers beyond the 'attemptETHTransfer' function?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in ETH Transfer and `transferSplitAsset`"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions (`attemptETHTransfer`, `transferSplitAsset`) perform external calls without following the checks-effects-interactions pattern, making them vulnerable to reentrancy attacks if the recipient is a malicious contract. This could allow attackers to manipulate the contract state or drain funds."",
      ""Impact"": ""Reentrancy attacks could lead to loss of funds or unintended state manipulation."",
      ""Location"": ""Functions `attemptETHTransfer`, `transferSplitAsset`""
    },
    {
      ""Issue"": ""Insufficient Gas Limit for ETH Transfer"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `attemptETHTransfer` function uses a fixed gas limit (e.g., 30000) for ETH transfers, which may be insufficient for contracts with complex fallback logic, leading to failed transfers."",
      ""Impact"": ""Failed transactions, potential loss of funds, or poor user experience."",
      ""Location"": ""Function `attemptETHTransfer`""
    },
    {
      ""Issue"": ""Unrestricted Window Increment"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `incrementWindow` function lacks proper access control or validation beyond checking if the caller is a supported Royalty Vault. This could allow unauthorized or excessive window increments, disrupting fund distribution."",
      ""Impact"": ""Unauthorized window manipulation, incorrect fund distribution, or denial of service."",
      ""Location"": ""Function `incrementWindow`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `scaleAmountByPercentage`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `scaleAmountByPercentage` function does not validate the `scaledPercent` input, potentially leading to incorrect scaling or arithmetic overflow if values exceed expected bounds (e.g., >10000)."",
      ""Impact"": ""Incorrect fund distribution due to improper scaling."",
      ""Location"": ""Function `scaleAmountByPercentage`""
    },
    {
      ""Issue"": ""Potential Front-Running in Claim Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `claim` and `claimForAllWindows` functions lack mechanisms to prevent front-running, allowing attackers to intercept claims by submitting transactions with higher gas fees."",
      ""Impact"": ""Legitimate users may lose funds to front-running attacks."",
      ""Location"": ""Functions `claim`, `claimForAllWindows`""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical state-changing functions (e.g., `setClaimed`) do not emit events, reducing transparency and auditability of contract interactions."",
      ""Impact"": ""Difficulty in tracking state changes or debugging issues."",
      ""Location"": ""Function `setClaimed`""
    },
    {
      ""Issue"": ""Unbounded Loop in `claimForAllWindows`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `claimForAllWindows` function iterates over all windows up to `currentWindow`, which could cause excessive gas consumption or out-of-gas errors if the window count is large."",
      ""Impact"": ""High gas costs or transaction failures, preventing users from claiming funds."",
      ""Location"": ""Function `claimForAllWindows`""
    },
    {
      ""Issue"": ""Incorrect Scaling in `scaleAmountByPercentage`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `scaleAmountByPercentage` function divides by 10000 instead of using the `PERCENTAGE_SCALE` constant, leading to potential inconsistencies in scaling calculations."",
      ""Impact"": ""Incorrect fund distribution due to improper scaling."",
      ""Location"": ""Function `scaleAmountByPercentage`""
    },
    {
      ""Issue"": ""Lack of Zero Address Check in `transferSplitAsset`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferSplitAsset` function does not validate if the recipient address is the zero address, risking permanent loss of funds if tokens are sent there."",
      ""Impact"": ""Permanent loss of funds if tokens are sent to the zero address."",
      ""Location"": ""Function `transferSplitAsset`""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 9
}",323.827584028244,43211.0,24.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**

**Report Description**:  
The `incrementWindow` function in the Splitter contract lacks proper access control. Anyone can impersonate a RoyaltyVault contract and call `incrementWindow`, causing `balanceForWindow` to exceed the actual contract balance. This allows verified users to exploit the `claim` or `claimForAllWindows` functions to steal tokens from the contract.

**Match in Response List**:  
Matches with the issue titled **""Unrestricted Window Increment""**.

**Validation**:  
**Correct**. The response accurately identifies the lack of access control in the `incrementWindow` function, which aligns with the issue described in the report. It correctly highlights the risk of unauthorized window manipulation and its impact on fund distribution.

---

#### **[H-03] DoS: claimForAllWindows() May Be Made Unusable By An Attacker**

**Report Description**:  
The `claimForAllWindows` function iterates over all windows up to `currentWindow`, which can be excessively incremented by an attacker impersonating a RoyaltyVault. This can cause the function to exceed the block gas limit, rendering it unusable. The issue is exacerbated because `currentWindow` can only increase, and attackers can increment it with minimal cost (e.g., sending 1 WEI of WETH).

**Match in Response List**:  
Matches with the issue titled **""Unbounded Loop in `claimForAllWindows`""**.

**Validation**:  
**Correct**. The response correctly identifies the unbounded loop in `claimForAllWindows` and its potential to cause excessive gas consumption or out-of-gas errors. This aligns with the issue described in the report, including the risk of denial of service due to an attacker incrementing `currentWindow`.

---

#### **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

**Report Description**:  
The `attemptETHTransfer` function uses a fixed gas limit of 30,000 for ETH transfers. This may be insufficient for contracts with complex fallback logic, leading to failed transfers and potential loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Gas Limit for ETH Transfer""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the fixed gas limit in `attemptETHTransfer` and its potential to cause failed transactions. This aligns with the issue described in the report, including the risk of poor user experience or loss of funds.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**  
- **[H-03] DoS: claimForAllWindows() May Be Made Unusable By An Attacker**  
- **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

**Partially Correct Matches**:  
*None*

**Missed Issues from Issue Report**:  
*None*

---

### **Conclusion**  
All issues in the `issue` report were correctly matched and validated in the `response_list`. The responses accurately identified the vulnerabilities, risks, and impacts described in the report, demonstrating a thorough understanding of Solidity security best practices. No gaps or missed issues were found.","```
1. Unrestricted Window Increment
2. Unbounded Loop in `claimForAllWindows`
3. Insufficient Gas Limit for ETH Transfer
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Unrestricted Window Increment"" appears at rank 3.
   - ""Unbounded Loop in `claimForAllWindows`"" appears at rank 7.
   - ""Insufficient Gas Limit for ETH Transfer"" appears at rank 2.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - At rank 3: \( P@3 = \frac{2}{3} \approx 0.6667 \)
   - At rank 7: \( P@7 = \frac{3}{7} \approx 0.4286 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.5 + 0.6667 + 0.4286}{3} \approx \frac{1.5953}{3} \approx 0.5318
   \]

**Output**:
```
0.5318
```"
CoreCollection.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    // ----------------- MODIFIER -----------------

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    // ----------------- EXTERNAL -----------------

    /**
     * @notice Initializes the collection
     * @dev This method is being called from the CoreFactory contract
     * @param _collectionName Name of the collection
     * @param _collectionSymbol Symbol of the collection
     * @param _collectionURI Base URI for the collection
     * @param _maxSupply The maximum number of tokens that can be minted
     * @param _mintFee The price of a token in this collection
     * @param _payableToken The address of the ERC20 this collection uses to settle transactions
     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed
     * @param _splitFactory base URI for the collection
     */
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    /**
     * @notice Allows the collection owner to airdrop tokens
     * @dev The Merkle tree defines for each address how much token can be claimed
     * @dev This method can only be called once
     * @param _root A Merkle root
     */
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    /**
     * @notice Allows the collection owner to change the collection's name and symbol
     * @dev This function is only callable by the collection's owner
     * @param _collectionName A collection name
     * @param _collectionSymbol A collection symbol
     */
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    /**
     * @notice This function is called to mint tokens from this ERC721 collection
     * @dev The collection must be initialized first
     * @param to Token recipient
     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token
     * @param claimableAmount The amount of tokens the user has been airdropped
     * @param amount The amount of tokens the user wants to mint
     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token
     */
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    /**
     * @notice Allows the contract owner to withdraw the funds generated by the token sales
     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner
     */
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    /**
     * @notice Set royalty vault address for collection
     * @dev All revenue (Primary sales + royalties from secondardy sales) 
     * from the collection are transferred to the vault when the vault is initialized
     * @param _royaltyVault The address of the royalty vault
     */
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    /**
     * @notice Set a provenance hash
     * @dev This hash is used to verify the minting ordering of a collection (à la BAYC)
     * This hash is generated off-chain
     * @param _proof The SHA256 generated hash
     */
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    // ----------------- PUBLIC -----------------

    /**
     * @notice Set the mint starting index
     * @dev The starting index can only be generated once
     */
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    // ---------------- VIEW ----------------

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    // ---------------- PRIVATE ----------------

    /**
     * @notice Mint token
     * @dev A starting index is calculated at the time of first mint
     * returns a tokenId
     * @param _to Token recipient
     */
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    /**
     * @notice Mint tokens in batch
     * @param _to Token recipient
     * @param _amount Number of tokens to include in batch
     * @param _isClaim Whether the batch mint is an airdrop or not
     */
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    // ---------------- INTERNAL ----------------

    /**
     * @notice This hook transfers tokens sitting in the royalty vault to the split contract
     * @dev The split contract is a contract that allows a team to share revenue together
     * @param _from Transfer sender
     * @param _to Transfer recipient
     * @param _tokenId TokenId of token being transferred
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",2331,310,"[H-04] CoreCollection can be reinitialized
Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.
Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.
However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.
  [H-07] Duplicate NFTs Can Be Minted if payableToken Has a Callback Attached to it
The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the payableToken is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because totalSupply() has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply check`. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.
  [H-08] Funds cannot be withdrawn in CoreCollection.withdraw
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the msg.sender ( who is the owner of the contract). The usage of transferFrom can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the withdraw function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.
",3,,"pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    

    
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    

    
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    

    
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    

    
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",1528,3,0,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for potential reentrancy attacks in functions like 'mintToken' and 'withdraw'."",
        ""Verify that all arithmetic operations are safe from overflow/underflow, especially in 'mint' and 'batchMint'."",
        ""Ensure that external calls (e.g., to 'IRoyaltyVault' and 'IERC20') are handled securely to prevent unexpected behavior."",
        ""Review the claim mechanism in 'mintToken' for potential vulnerabilities, especially with the use of Merkle proofs.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract fully adheres to the ERC721 standard, including all required functions and events."",
        ""Ensure that the contract correctly implements the 'ERC721Enumerable' extension for token enumeration."",
        ""Check that the 'Ownable' contract is correctly used to manage ownership and access control.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the 'setStartingIndex' function to ensure the starting index is calculated securely and unpredictably."",
        ""Review the batch minting logic in 'batchMint' for potential inefficiencies or bugs."",
        ""Examine the '_beforeTokenTransfer' function to ensure it correctly handles royalty distribution without introducing vulnerabilities.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze the interaction with 'IRoyaltyVault' to ensure it correctly handles royalty payments and distributions."",
        ""Verify that the 'IERC20' interactions in 'mintToken' and 'withdraw' are secure and handle edge cases (e.g., zero balances, failed transfers)."",
        ""Ensure that the 'splitFactory' address is validated and used securely in 'setRoyaltyVault'.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Check that all functions with 'onlyOwner' modifier are correctly restricted to the owner."",
        ""Verify that the 'onlyInitialized' and 'onlyUnInitialized' modifiers are used appropriately to prevent unauthorized access."",
        ""Ensure that the 'onlyValidSupply' and 'tokenExists' modifiers are correctly implemented to enforce constraints.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify potential gas inefficiencies in the 'batchMint' function, especially in the loop for minting multiple tokens."",
        ""Review the 'setStartingIndex' function for potential gas optimizations in the calculation of the starting index."",
        ""Check for redundant or unnecessary state variable updates that could increase gas costs.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Evaluate the 'mintToken' function for potential front-running risks, especially during token sales or claims."",
        ""Consider implementing a commit-reveal scheme or other mechanisms to mitigate front-running in critical functions.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that there is a mechanism to pause or halt critical functions (e.g., minting, claiming) in case of an emergency."",
        ""Verify that the contract has a clear and secure way to handle unexpected issues, such as failed external calls.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Review the 'setRoyaltyVault' function to ensure it is secure and only accessible by authorized entities (e.g., 'splitFactory' or owner)."",
        ""Ensure that any future governance mechanisms are implemented securely to prevent unauthorized changes.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Analyze the 'maxSupply' and 'mintFee' parameters to ensure they are set in a way that prevents inflationary token models."",
        ""Ensure that the 'withdraw' function does not allow for fund drainage or malicious exits.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code is a Solidity smart contract named 'CoreCollection' that combines multiple functionalities related to ERC721 tokens, including claimable tokens, payable tokens, and royalty management. The contract is designed to manage a collection of NFTs with features like minting, claiming, and handling royalties."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""CoreCollection"",
    ""Purpose"": ""To manage a collection of ERC721 tokens with features for minting, claiming, and handling royalties."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ERC721Claimable"", ""ERC721Enumerable"", ""ERC721Payable""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC721/ERC721.sol"",
        ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol"",
        ""./ERC721Payable.sol"",
        ""./ERC721Claimable.sol"",
        ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""initialized"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether the contract has been initialized.""
      },
      {
        ""Name"": ""_name"",
        ""Type"": ""string"",
        ""Purpose"": ""Name of the NFT collection.""
      },
      {
        ""Name"": ""_symbol"",
        ""Type"": ""string"",
        ""Purpose"": ""Symbol of the NFT collection.""
      },
      {
        ""Name"": ""_baseUri"",
        ""Type"": ""string"",
        ""Purpose"": ""Base URI for the NFT metadata.""
      },
      {
        ""Name"": ""maxSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum number of tokens that can be minted.""
      },
      {
        ""Name"": ""startingIndex"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Starting index for token IDs.""
      },
      {
        ""Name"": ""startingIndexBlock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Block number when the starting index was set.""
      },
      {
        ""Name"": ""HASHED_PROOF"",
        ""Type"": ""string"",
        ""Purpose"": ""Hashed proof for claim verification.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyInitialized"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the contract is initialized."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyUnInitialized"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the contract is not initialized."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyValidSupply"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the maximum supply is greater than 0."",
        ""Parameters"": [""uint256 _maxSupply""],
        ""Returns"": []
      },
      {
        ""Name"": ""tokenExists"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the token ID exists."",
        ""Parameters"": [""uint256 _tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with collection details."",
        ""Parameters"": [
          ""string memory _collectionName"",
          ""string memory _collectionSymbol"",
          ""string memory _collectionURI"",
          ""uint256 _maxSupply"",
          ""uint256 _mintFee"",
          ""address _payableToken"",
          ""bool _isForSale"",
          ""address _splitFactory""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""initializeClaims"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the claim mechanism with a Merkle root."",
        ""Parameters"": [""bytes32 _root""],
        ""Returns"": []
      },
      {
        ""Name"": ""setCollectionMeta"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the collection name and symbol."",
        ""Parameters"": [""string memory _collectionName"", ""string memory _collectionSymbol""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Mints tokens either as a claim or a sale."",
        ""Parameters"": [
          ""address to"",
          ""bool isClaim"",
          ""uint256 claimableAmount"",
          ""uint256 amount"",
          ""bytes32[] calldata merkleProof""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws the contract's balance of the payable token."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setRoyaltyVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the royalty vault address."",
        ""Parameters"": [""address _royaltyVault""],
        ""Returns"": []
      },
      {
        ""Name"": ""setHashedProof"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the hashed proof for claim verification."",
        ""Parameters"": [""string calldata _proof""],
        ""Returns"": []
      },
      {
        ""Name"": ""setStartingIndex"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the starting index for token IDs."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""name"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the name of the NFT collection."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""symbol"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the symbol of the NFT collection."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""baseURI"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the base URI for the NFT metadata."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""_baseURI"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to return the base URI."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""mint"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Mints a single token."",
        ""Parameters"": [""address _to""],
        ""Returns"": [""uint256 tokenId""]
      },
      {
        ""Name"": ""batchMint"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Mints multiple tokens in a batch."",
        ""Parameters"": [""address _to"", ""uint256 _amount"", ""bool _isClaim""],
        ""Returns"": []
      },
      {
        ""Name"": ""_beforeTokenTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles logic before token transfer, including royalty distribution."",
        ""Parameters"": [""address _from"", ""address _to"", ""uint256 _tokenId""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 (for handling payments)"",
    ""IRoyaltyVault (for handling royalties)"",
    ""Split Factory (for initializing the royalty vault)""
  ],
  ""SpecialMechanisms"": [
    ""Merkle tree for claim verification"",
    ""Batch minting for efficiency"",
    ""Royalty distribution mechanism via IRoyaltyVault""
  ],
  ""Questions"": [
    ""What is the purpose of the 'HASHED_PROOF' state variable and how is it used?"",
    ""How is the 'startingIndex' calculated and why is it necessary?"",
    ""What is the role of the 'splitFactory' and how is it used in the 'setRoyaltyVault' function?"",
    ""Are there any potential security risks with the 'mintToken' function, especially with the claim mechanism?"",
    ""How does the '_beforeTokenTransfer' function interact with the 'IRoyaltyVault' contract?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in `withdraw` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdraw` function transfers tokens directly to the owner without using the Checks-Effects-Interactions pattern. This could potentially allow for reentrancy attacks if the `payableToken` is a malicious contract that calls back into the `CoreCollection` contract."",
      ""Impact"": ""An attacker could exploit this vulnerability to drain the contract's funds or manipulate the contract's state."",
      ""Location"": ""Function `withdraw`""
    },
    {
      ""Issue"": ""Lack of Access Control on `setStartingIndex`"",
      ""Severity"": ""High"",
      ""Description"": ""The `setStartingIndex` function is publicly accessible and can be called by anyone. This can lead to manipulation of the starting index, which is critical for the fair distribution of tokens."",
      ""Impact"": ""Potential for unfair token distribution and exploitation by malicious actors."",
      ""Location"": ""Function `setStartingIndex`""
    },
    {
      ""Issue"": ""Uninitialized `splitFactory` and `royaltyVault`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `splitFactory` and `royaltyVault` addresses are not initialized in the constructor or checked for validity in the `setRoyaltyVault` function. This could lead to setting these addresses to invalid or malicious contracts."",
      ""Impact"": ""If `splitFactory` or `royaltyVault` is set to a malicious contract, it could lead to loss of funds or unauthorized access to the contract's functions."",
      ""Location"": ""Function `setRoyaltyVault`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `initialize` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize` function does not validate the `_payableToken` address or ensure that `_mintFee` is set correctly. This could lead to setting an invalid token address or incorrect mint fee."",
      ""Impact"": ""If `_payableToken` is invalid, it could cause issues with payment handling. If `_mintFee` is set incorrectly, it could lead to incorrect fee calculations."",
      ""Location"": ""Function `initialize`""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `mint` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `mint` function calculates the `tokenId` using arithmetic operations that could potentially overflow if `maxSupply` is not carefully managed."",
      ""Impact"": ""Integer overflow could lead to unexpected behavior or vulnerabilities in token ID generation."",
      ""Location"": ""Function `mint`""
    },
    {
      ""Issue"": ""Unrestricted `setHashedProof` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setHashedProof` function allows the owner to set the `HASHED_PROOF` string without any restrictions or validation. This could lead to setting an invalid or malicious proof."",
      ""Impact"": ""If `HASHED_PROOF` is set to an invalid value, it could affect the integrity of the contract or its interactions with other systems."",
      ""Location"": ""Function `setHashedProof`""
    },
    {
      ""Issue"": ""Lack of Event Emission in `initialize` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `initialize` function sets critical contract parameters but does not emit an event. This makes it harder to track and verify the initialization of the contract."",
      ""Impact"": ""Reduced transparency and auditability."",
      ""Location"": ""Function `initialize`""
    }
  ],
  ""IssueNumber"": 38,
  ""OutputList"": 7
}",320.4464662075043,52171.0,24.0,"### **[H-04] CoreCollection can be reinitialized**

**Report Description**:
The `initialize` function in `CoreCollection` sets the `initialized` flag but does not check if the contract has already been initialized. This allows the function to be rerun multiple times, potentially resetting critical variables like `payableToken`. While the function is `onlyOwner`, the risk remains that the owner could reset the contract either by mistake or with malicious intent, leading to system-breaking consequences.

**Match in Response List**:
Matches with the issue titled **""Lack of Input Validation in `initialize` Function""**.

**Validation**:
**Partially Correct**. The response identifies the lack of input validation in the `initialize` function but does not specifically address the reinitialization vulnerability. While it mentions the potential for setting an invalid `_payableToken` or incorrect `_mintFee`, it misses the critical detail that the function can be rerun multiple times, which is the core issue.

---

### **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**

**Report Description**:
The `mintToken()` function in `CoreCollection` allows users to mint unique tokens by either providing a merkle proof or paying a fee in `payableToken`. However, because the `payableToken` is paid before the token is minted, a callback attached to the token transfer could allow reentrancy. This could bypass the `totalSupply() + amount <= maxSupply` check, enabling the minting of duplicate NFTs if the user mints the last token and reenters the function.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the reentrancy risk in the `mintToken()` function or the potential for minting duplicate NFTs. This issue is entirely missed in the response list.

---

### **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Report Description**:
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the contract to the owner. However, many ERC20 tokens require that `allowance[from][msg.sender] >= amount`. Since `allowance[CoreCollection][CoreCollection] == 0`, the call to `withdraw` will revert, locking the funds in the contract permanently.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Risk in `withdraw` Function""**.

**Validation**:
**Incorrect**. The response misidentifies the core issue. While it mentions a reentrancy risk in the `withdraw` function, the actual problem is the incorrect use of `transferFrom`, which leads to funds being locked due to insufficient allowance. The response does not address this critical detail.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-04] CoreCollection can be reinitialized**

**Missed Issues from Issue Report**:
- **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**
- **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

---

### **Overall Assessment**
The response list partially addresses one issue ([H-04]) but misidentifies the core problem. It entirely misses two critical issues ([H-07] and [H-08]), indicating significant gaps in coverage and accuracy. The responses do not fully align with the vulnerabilities described in the issue report, and some critical risks are overlooked or misrepresented.","```
None.
```","Given that there are no true positives in the provided list, the **Average Precision (AP)** for the query is:

**0.0**"
RoyaltyVault.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    /**** Events ****/
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    /**
     * @dev Getting royaltyAsset balance of Vault.
     */
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    /**
     * @dev Send accumulated royalty to splitter.
     */
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    /**
     * @dev Set Platform fee for collection contract.
     * @param _platformFee Platform fee in scaled percentage.
     */
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    /**
     * @dev Set Platform fee recipient for collection.
     * @param _platformFeeRecipient Platform fee recipient address
     */
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    /**
     * @dev Get Splitter address of proxyVault.
     */
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    /**
     * @dev Checks for support of IRoyaltyVault.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",751,104,"[H-01] ERC20 transferFrom return values not checked
The transferFrom() function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.
  [H-05] Centralisation RIsk: Owner Of RoyaltyVault Can Take All Funds
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.
As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.
  [H-09] ERC20 tokens with no return value will fail to transfer
Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.
",3,,"pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",627,3,0,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for potential reentrancy attacks in the `sendToSplitter` function, especially during ERC20 token transfers."",
        ""Verify that the `platformFee` value is validated to ensure it is within a reasonable range (e.g., 0-10000)."",
        ""Ensure that external calls to `ISplitter` and `IERC20` are checked for success and handle potential failures gracefully."",
        ""Review the contract for any potential integer overflow/underflow issues, especially in fee calculations.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to the ERC20 standard for token interactions."",
        ""Ensure that the contract correctly implements the `ERC165` interface for interface support checks.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the fee distribution logic in `sendToSplitter` to ensure it correctly calculates and distributes the platform fee and splitter share."",
        ""Ensure that the `supportsInterface` function correctly identifies supported interfaces.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that the `splitterProxy` address is validated to ensure it points to a valid and functional contract."",
        ""Ensure that the contract handles potential failures in external calls to `ISplitter` and `IERC20`.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call `setPlatformFee` and `setPlatformFeeRecipient` functions."",
        ""Ensure that the ownership transfer mechanism in `Ownable` is secure and cannot be abused.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review the contract for any potential gas inefficiencies, especially in the `sendToSplitter` function."",
        ""Optimize state variable access and storage usage to reduce gas costs.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that there is a mechanism to pause or stop the distribution of funds in case of an emergency."",
        ""Verify that the contract can handle unexpected scenarios, such as a zero balance or invalid recipient addresses.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Ensure that the contract owner has appropriate controls and checks in place for setting fees and recipients."",
        ""Verify that the contract does not allow for unauthorized changes to critical parameters.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the fee distribution mechanism to ensure it does not lead to inflationary or deflationary issues."",
        ""Ensure that the contract can handle large amounts of royalty assets without causing economic imbalances.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running opportunities in the `sendToSplitter` function, especially during fee distribution."",
        ""Ensure that the contract uses best practices to mitigate front-running risks.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided Solidity code defines a `RoyaltyVault` contract that manages the distribution of royalty assets. The contract interacts with an external splitter contract to distribute funds and a platform fee recipient. The contract is designed to be owned, and it inherits from multiple contracts including `VaultStorage`, `IRoyaltyVault`, `ERC165`, and `Ownable`."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RoyaltyVault"",
    ""Purpose"": ""To manage and distribute royalty assets between a splitter contract and a platform fee recipient."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""VaultStorage"", ""IRoyaltyVault"", ""ERC165"", ""Ownable""],
      ""Imports"": [
        ""../interfaces/IRoyaltyVault.sol"",
        ""./VaultStorage.sol"",
        ""../interfaces/ISplitter.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/utils/introspection/ERC165.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""royaltyAsset"",
        ""Type"": ""address"",
        ""Purpose"": ""The address of the ERC20 token used as the royalty asset.""
      },
      {
        ""Name"": ""splitterProxy"",
        ""Type"": ""address"",
        ""Purpose"": ""The address of the splitter contract where the royalty assets are sent.""
      },
      {
        ""Name"": ""platformFee"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The fee percentage (in basis points) that is sent to the platform fee recipient.""
      },
      {
        ""Name"": ""platformFeeRecipient"",
        ""Type"": ""address"",
        ""Purpose"": ""The address of the platform fee recipient.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""getVaultBalance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the balance of the royalty asset in the vault."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""sendToSplitter"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Distributes the royalty assets between the splitter and the platform fee recipient."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setPlatformFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the platform fee percentage. Only callable by the owner."",
        ""Parameters"": [""uint256 _platformFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""setPlatformFeeRecipient"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the platform fee recipient address. Only callable by the owner."",
        ""Parameters"": [""address _platformFeeRecipient""],
        ""Returns"": []
      },
      {
        ""Name"": ""getSplitter"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the address of the splitter contract."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""supportsInterface"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if the contract supports a specific interface."",
        ""Parameters"": [""bytes4 interfaceId""],
        ""Returns"": [""bool""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ISplitter: The contract interacts with an external splitter contract to distribute funds and increment the splitter window."",
    ""IERC20: The contract interacts with an ERC20 token to transfer funds to the splitter and the platform fee recipient.""
  ],
  ""SpecialMechanisms"": [
    ""Ownership: The contract uses the `Ownable` pattern to restrict certain functions to the contract owner."",
    ""Fee Distribution: The contract calculates and distributes fees based on a platform fee percentage.""
  ],
  ""Questions"": [
    ""What is the purpose of the `VaultStorage` contract, and what state variables does it define?"",
    ""How is the `platformFee` value validated to ensure it is within a reasonable range (e.g., 0-10000)?"",
    ""Is there any mechanism to handle potential reentrancy attacks during the transfer of funds?"",
    ""What happens if the `splitterProxy` address is set to an invalid or non-existent contract?"",
    ""Is there any functionality to pause or stop the distribution of funds in case of an emergency?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The `sendToSplitter` function performs multiple external calls (e.g., ERC20 transfers and `incrementWindow`) without following the Checks-Effects-Interactions pattern or using a reentrancy guard. This could allow malicious contracts to re-enter the function and manipulate state or drain funds."",
      ""Impact"": ""An attacker could exploit this to re-enter the function, leading to loss of funds, incorrect state updates, or unauthorized fund transfers."",
      ""Location"": ""sendToSplitter function""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `setPlatformFee` and `setPlatformFeeRecipient` lack input validation. `setPlatformFee` does not check if the fee is within a reasonable range (e.g., 0 to 10000), and `setPlatformFeeRecipient` does not verify if the address is non-zero or valid."",
      ""Impact"": ""Invalid or malicious inputs could lead to incorrect fee calculations, loss of funds (if sent to a zero address), or operational disruptions."",
      ""Location"": ""setPlatformFee and setPlatformFeeRecipient functions""
    },
    {
      ""Issue"": ""Uninitialized Storage Variables"",
      ""Severity"": ""Medium"",
      ""Description"": ""Critical state variables like `splitterProxy`, `platformFee`, and `platformFeeRecipient` are not initialized in the constructor or a dedicated initialization function. This could lead to runtime errors or unintended behavior if accessed before being set."",
      ""Impact"": ""Uninitialized variables may cause contract malfunction, fund loss, or incorrect fee distribution."",
      ""Location"": ""State variables: splitterProxy, platformFee, platformFeeRecipient""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""Calculations in `sendToSplitter` (e.g., `platformShare` and `splitterShare`) involve arithmetic operations that could overflow or underflow if inputs are not properly constrained. While Solidity 0.8.x has built-in checks, explicit validation is still recommended."",
      ""Impact"": ""Incorrect fund distribution due to overflow/underflow, potentially causing financial discrepancies."",
      ""Location"": ""sendToSplitter function""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract fails to emit events for key state changes, such as updates to `splitterProxy` or `platformFeeRecipient`. This reduces transparency and makes auditing more difficult."",
      ""Impact"": ""Limited traceability of state changes, hindering debugging, monitoring, and compliance efforts."",
      ""Location"": ""State variables: splitterProxy, platformFeeRecipient""
    },
    {
      ""Issue"": ""Incomplete ERC165 Implementation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `supportsInterface` function only checks for `IRoyaltyVault` support, ignoring other interfaces (e.g., `ERC165`, `Ownable`). This could cause issues with systems relying on interface detection."",
      ""Impact"": ""Incorrect interface detection may disrupt integrations or expected functionality."",
      ""Location"": ""supportsInterface function""
    },
    {
      ""Issue"": ""Unchecked Return Values in External Calls"",
      ""Severity"": ""Low"",
      ""Description"": ""The `sendToSplitter` function does not explicitly handle return values from external calls (e.g., `transfer` and `incrementWindow`), relying solely on `require` statements. Best practice is to validate return values."",
      ""Impact"": ""Silent failures in external calls could lead to unexpected behavior."",
      ""Location"": ""sendToSplitter function""
    }
  ],
  ""IssueNumber"": 38,
  ""OutputList"": 7
}",311.7856321334839,31883.0,24.0,"### **[H-01] ERC20 transferFrom return values not checked**

**Report Description**:  
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.

**Match in Response List**:  
Matches with the issue titled **""Unchecked Return Values in External Calls""**.

**Validation**:  
**Correct**. The response identifies the issue of unchecked return values in external calls, which aligns with the reported vulnerability. Although the response focuses on the `sendToSplitter` function, the core concern of validating return values from external calls (e.g., `transfer` and `transferFrom`) is accurately addressed. This is consistent with Solidity best practices for secure contract interactions.

---

### **[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**

**Report Description**:  
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g., 100% = 10000), and that share of the contract's balance and future balances will be set to the `platformFeeRecipient` (which is in the owner's control) rather than the splitter contract. As a result, the owner can steal the entire contract balance and any future balances, avoiding the splitter.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the lack of input validation in the `setPlatformFee` function, which is a critical part of the reported vulnerability. However, it does not explicitly address the centralization risk or the potential for the owner to drain funds by setting an arbitrary fee. The response focuses on the absence of range checks but misses the broader security implications of this oversight.

---

### **[H-09] ERC20 tokens with no return value will fail to transfer**

**Report Description**:  
Although the ERC20 standard suggests that a transfer should return `true` on success, many tokens are non-compliant in this regard (including high-profile tokens like USDT). In that case, the `.transfer()` call here will revert even if the transfer is successful because Solidity will check that the `RETURNDATASIZE` matches the ERC20 interface.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The reported vulnerability highlights a critical edge case where non-compliant ERC20 tokens (e.g., USDT) can cause transfers to fail due to mismatched `RETURNDATASIZE`. This is a significant security concern that is entirely missed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] ERC20 transferFrom return values not checked**

**Partially Correct Matches**:

- **[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**

**Missed Issues from Issue Report**:

- **[H-09] ERC20 tokens with no return value will fail to transfer**

---

**Observations**:  
The response list covers some aspects of the reported issues but misses critical details in certain cases (e.g., centralization risk) and entirely overlooks others (e.g., non-compliant ERC20 tokens). To improve coverage and accuracy, the response list should explicitly address edge cases and broader security implications, such as centralization risks and non-standard token behaviors.","```
1. Unchecked Return Values in External Calls
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unchecked Return Values in External Calls"".
   - From the ranked list of predictions, this issue appears at rank 7.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 7, \( P@7 = \frac{1}{7} \approx 0.1429 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - Therefore, \( AP = 0.1429 \).

**Output**:
```
0.1429
```"
SplitFactory.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  /**** Immutable storage ****/

  address public immutable splitter;
  address public immutable royaltyVault;

  /**** Mmutable storage ****/
  // Gets set within the block, and then deleted.

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  /**** Events ****/

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  // ---------------- MODIFIER ----------------

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  /**
   * @dev Constructor
   * @param _splitter The address of the Splitter contract.
   */
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; // 5%
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  // ---------------- EXTERNAL ----------------

  /**
   * @dev Deploys a new SplitProxy and initializes collection's royalty vault.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _collectionContract The address of the collection contract.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  /**
   * @dev Deploys a new SplitProxy.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  /**
   * @dev Set Platform fee for collection contract.
   * @param _platformFee Platform fee in scaled percentage. (5% = 200)
   * @param _vault vault address.
   */
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  /**
   * @dev Set Platform fee recipient for collection contract.
   * @param _vault vault address.
   * @param _platformFeeRecipient Platform fee recipient.
   */
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  // ---------------- PRIVATE ----------------

  /**
   * @dev Creates a new SplitProxy.
   */
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",1197,175,"[M-01] DoS: Attacker May Front-Run createSplit() With A merkleRoot Causing Future Transactions With The Same merkleRoot to Revert
A merkleRoot may only be used once in `createSplit()` since it is used as salt to the deployment of a SplitProxy.
The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another createSplit() transaction with a higher gas price that uses the same merkleRoot but changes the other fields such as the `_collectionContract` or `_splitAsset()`. The original transaction will revert and the user will not be able to send any more transaction with this merkleRoot.
",1,,"pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  

  address public immutable splitter;
  address public immutable royaltyVault;

  
  

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; 
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  

  
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",893,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy risks in external calls to `IRoyaltyVault` and `ICoreCollection`."",
        ""Verify that all external calls are properly validated and handled to prevent malicious interactions."",
        ""Ensure that the `onlyAvailableSplit` modifier correctly prevents duplicate split IDs."",
        ""Review the use of `delete` statements to ensure state variables are properly cleared and not susceptible to unintended behavior.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to relevant ERC standards, especially if it interacts with ERC-20 or ERC-721 tokens."",
        ""Verify that the platform fee and recipient settings comply with any applicable regulations or standards.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Analyze the logic for creating and assigning splits and vaults to ensure there are no edge cases or bugs."",
        ""Review the use of Merkle roots in split creation to ensure correctness and security."",
        ""Verify the correctness of the `createSplitProxy` and `createVaultProxy` functions, including the use of `salt` for deterministic deployment.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the external calls to `IRoyaltyVault` and `ICoreCollection` to ensure they are safe and properly validated."",
        ""Check that the `setRoyaltyVault` function in `ICoreCollection` is called securely and only by authorized parties."",
        ""Ensure that the `setPlatformFee` and `setPlatformFeeRecipient` functions in `IRoyaltyVault` are protected against unauthorized access.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is correctly applied to functions that require ownership privileges."",
        ""Ensure that the `onlyAvailableSplit` modifier is used consistently and correctly to prevent unauthorized access."",
        ""Check that the `msg.sender` is properly validated in the `createSplit` function to ensure only the collection owner can create splits.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify opportunities to reduce gas usage in the `createSplitProxy` and `createVaultProxy` functions."",
        ""Review the use of state variables and mappings to ensure they are optimized for gas efficiency."",
        ""Check for unnecessary storage operations that could be optimized or removed.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Evaluate the potential for front-running in the `createSplit` function and recommend mitigations if necessary."",
        ""Ensure that the use of `salt` in proxy creation does not introduce vulnerabilities related to transaction ordering.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that there are mechanisms in place to halt or pause the contract in case of an emergency."",
        ""Ensure that critical functions can be paused or stopped by the owner to prevent malicious activities.""
      ]
    }
  ]
}

### Prioritization and Refinement:
- **Relevance:** Each task directly addresses issues identified in the initial analysis, ensuring that the audit covers all critical areas.
- **Specificity:** Tasks are clearly defined, specifying which functions or components need to be reviewed and what aspects to focus on.
- **Actionability:** Each task provides a clear course of action for the auditor, making it easy to execute and verify.

This structured task list ensures a comprehensive and efficient audit of the `SplitFactory` contract, addressing potential vulnerabilities and optimizing its functionality.","{
  ""ReviewingTheCode"": ""The provided Solidity code is for a contract named `SplitFactory` which appears to be a factory contract for creating and managing split proxies and vault proxies. It leverages OpenZeppelin's `Ownable` contract for ownership management and interacts with external contracts for royalty and split management."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SplitFactory"",
    ""Purpose"": ""To create and manage split proxies and vault proxies, facilitating the distribution of royalties and splits among participants."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@chestrnft/royalty-vault/contracts/ProxyVault.sol"",
        ""./SplitProxy.sol"",
        ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"",
        ""../interfaces/ICoreCollection.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""splitter"",
        ""Type"": ""address"",
        ""Purpose"": ""Immutable address of the splitter contract.""
      },
      {
        ""Name"": ""royaltyVault"",
        ""Type"": ""address"",
        ""Purpose"": ""Immutable address of the royalty vault contract.""
      },
      {
        ""Name"": ""merkleRoot"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Stores the Merkle root for split creation.""
      },
      {
        ""Name"": ""splitAsset"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the asset used for splits.""
      },
      {
        ""Name"": ""royaltyAsset"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the asset used for royalties.""
      },
      {
        ""Name"": ""splitterProxy"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the splitter proxy.""
      },
      {
        ""Name"": ""platformFee"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Platform fee percentage.""
      },
      {
        ""Name"": ""platformFeeRecipient"",
        ""Type"": ""address"",
        ""Purpose"": ""Address where platform fees are sent.""
      },
      {
        ""Name"": ""splits"",
        ""Type"": ""mapping(string => address)"",
        ""Purpose"": ""Maps split IDs to their respective proxy addresses.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyAvailableSplit"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures that a split ID is not already in use."",
        ""Parameters"": [""string memory _splitId""],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the splitter and royalty vault addresses, and sets the platform fee and recipient."",
        ""Parameters"": [""address _splitter"", ""address _royaltyVault""],
        ""Returns"": []
      },
      {
        ""Name"": ""createSplit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a split proxy and assigns it to a collection contract."",
        ""Parameters"": [""bytes32 _merkleRoot"", ""address _splitAsset"", ""address _collectionContract"", ""string memory _splitId""],
        ""Returns"": [""address splitProxy""]
      },
      {
        ""Name"": ""createSplit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a split proxy without assigning it to a collection contract."",
        ""Parameters"": [""bytes32 _merkleRoot"", ""address _splitAsset"", ""string memory _splitId""],
        ""Returns"": [""address splitProxy""]
      },
      {
        ""Name"": ""setPlatformFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the platform fee for a specific vault."",
        ""Parameters"": [""address _vault"", ""uint256 _platformFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""setPlatformFeeRecipient"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the platform fee recipient for a specific vault."",
        ""Parameters"": [""address _vault"", ""address _platformFeeRecipient""],
        ""Returns"": []
      },
      {
        ""Name"": ""createSplitProxy"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Deploys a new split proxy and stores its address."",
        ""Parameters"": [""string memory _splitId""],
        ""Returns"": [""address splitProxy""]
      },
      {
        ""Name"": ""createVaultProxy"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Deploys a new vault proxy and emits a creation event."",
        ""Parameters"": [""address splitProxy""],
        ""Returns"": [""address vault""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ICoreCollection.setRoyaltyVault"",
    ""IRoyaltyVault.setPlatformFee"",
    ""IRoyaltyVault.setPlatformFeeRecipient""
  ],
  ""SpecialMechanisms"": [
    ""Factory Pattern: The contract is a factory for creating split and vault proxies."",
    ""Proxy Pattern: Uses proxy contracts (`SplitProxy` and `ProxyVault`) for split and vault management."",
    ""Merkle Tree: Utilizes a Merkle root for split creation.""
  ],
  ""Questions"": [
    ""What is the purpose of the `merkleRoot` and how is it generated?"",
    ""How are the `splitAsset` and `royaltyAsset` addresses determined?"",
    ""Is there any validation on the `_splitId` parameter to ensure it is unique and properly formatted?"",
    ""What is the significance of the `salt` parameter in the `new` keyword for proxy creation?"",
    ""Are there any security considerations for the external calls to `IRoyaltyVault` and `ICoreCollection`?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in Split Creation"",
      ""Severity"": ""High"",
      ""Description"": ""The `createSplit` functions and other related functions do not implement any reentrancy guards, allowing potential recursive calls that could lead to unexpected behavior or loss of funds."",
      ""Impact"": ""An attacker could exploit this vulnerability to drain funds or manipulate the state of the contract in unintended ways."",
      ""Location"": ""Functions `createSplit`, `createSplitProxy`, `createVaultProxy`, `setPlatformFee`, `setPlatformFeeRecipient`""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""High"",
      ""Description"": ""Critical functions such as `createSplit` and `createVaultProxy` do not validate inputs like `_splitAsset`, `_collectionContract`, and `_splitId`, which could lead to deployment of splits with invalid or malicious addresses."",
      ""Impact"": ""Potential deployment of splits with invalid or malicious addresses, leading to loss of funds or other security vulnerabilities."",
      ""Location"": ""Functions `createSplit`, `createVaultProxy`, `setPlatformFeeRecipient`""
    },
    {
      ""Issue"": ""Lack of Access Control on Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `createSplit`, `setPlatformFee`, and `setPlatformFeeRecipient` lack proper access control, allowing unauthorized users to create splits or manipulate platform fees."",
      ""Impact"": ""Unauthorized creation of splits or manipulation of platform fees, leading to potential misuse or financial loss."",
      ""Location"": ""Functions `createSplit`, `setPlatformFee`, `setPlatformFeeRecipient`""
    },
    {
      ""Issue"": ""Incorrect Use of Immutable Variables"",
      ""Severity"": ""High"",
      ""Description"": ""Variables `splitter` and `royaltyVault` are declared as `immutable` but are assigned in the constructor without checks, potentially compromising the contract's functionality if incorrect or malicious addresses are used."",
      ""Impact"": ""Complete loss of control over the contract, allowing malicious actors to manipulate the split and vault creation process."",
      ""Location"": ""Constructor and state variable declarations""
    },
    {
      ""Issue"": ""Potential Front-Running in Split Creation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createSplit` functions use `onlyAvailableSplit` modifier to check split ID uniqueness, but this is susceptible to front-running, where an attacker could preemptively create a split with the same ID."",
      ""Impact"": ""An attacker could front-run the creation of a split, leading to potential loss of funds or denial of service."",
      ""Location"": ""Functions `createSplit`""
    },
    {
      ""Issue"": ""Uninitialized Storage Variables"",
      ""Severity"": ""Medium"",
      ""Description"": ""State variables like `merkleRoot`, `splitAsset`, and `royaltyAsset` are not initialized in the constructor and are only set during function calls, leading to potential undefined behavior if accessed before being set."",
      ""Impact"": ""Potential inconsistencies or unexpected behavior if state variables are accessed before being properly initialized."",
      ""Location"": ""Constructor and functions `createSplitProxy`, `createVaultProxy`""
    },
    {
      ""Issue"": ""State Variable Deletion Without Proper Checks"",
      ""Severity"": ""Low"",
      ""Description"": ""The `createSplitProxy` and `createVaultProxy` functions delete state variables like `merkleRoot`, `splitAsset`, and `royaltyAsset` after use, which could lead to unintended behavior if these variables are accessed later."",
      ""Impact"": ""Potential confusion or unintended behavior if state variables are accessed after deletion."",
      ""Location"": ""Functions `createSplitProxy`, `createVaultProxy`""
    },
    {
      ""Issue"": ""Hardcoded Platform Fee"",
      ""Severity"": ""Low"",
      ""Description"": ""The platform fee is hardcoded to 500 in the constructor, limiting flexibility if the fee needs to be adjusted in the future."",
      ""Impact"": ""Lack of flexibility in adjusting the platform fee, potentially leading to operational issues or financial inefficiencies."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical state changes such as setting the platform fee and recipient do not emit events, reducing transparency and auditability."",
      ""Impact"": ""Reduced transparency and auditability of critical state changes."",
      ""Location"": ""Functions `setPlatformFee`, `setPlatformFeeRecipient`""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 9
}",349.78166675567627,38351.0,24.0,"---

**[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Report Description**:
The `createSplit()` function uses a `merkleRoot` as a salt for deploying a `SplitProxy`. However, a `merkleRoot` can only be used once. An attacker can front-run a `createSplit()` transaction in the mempool by submitting a transaction with the same `merkleRoot` but different parameters (e.g., `_collectionContract` or `_splitAsset`) and a higher gas price. This causes the original transaction to revert, preventing the user from using the same `merkleRoot` in future transactions. This vulnerability can lead to a denial of service (DoS) for users attempting to create splits with specific `merkleRoot` values.

**Match in Response List**:
Matches with the issue titled **""Potential Front-Running in Split Creation""**.

**Validation**:
**Partially Correct**. The response identifies the risk of front-running in the `createSplit` function, which aligns with the issue described in the report. However, the response focuses on the uniqueness of the split ID rather than the `merkleRoot` being used as a salt. While the core concept of front-running is addressed, the specific impact of the `merkleRoot` being rendered unusable is not explicitly mentioned. This omission makes the response partially correct.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Missed Issues from Issue Report**:
- *None*

---","```
None.
```",0.0
