nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
MochiVault.sol,"// SPDX-License-Identifier: (c) Mochi.Fi, 2021

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@mochifi/library/contracts/CheapERC20.sol"";
import ""../interfaces/IERC3156FlashLender.sol"";
import ""../interfaces/IMochiVault.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IUSDM.sol"";

contract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {
    using Float for uint256;
    using CheapERC20 for IERC20;

    bytes32 public constant CALLBACK_SUCCESS =
        keccak256(""ERC3156FlashBorrower.onFlashLoan"");

    /// immutable variables
    IMochiEngine public immutable engine;
    IERC20 public override asset;

    /// for accruing debt
    uint256 public debtIndex;
    uint256 public lastAccrued;

    /// storage variables
    uint256 public override deposits;
    uint256 public override debts;
    int256 public override claimable;

    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.
    ///E.g. If the stability fees are 10% for a year
    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)

    /// result
    uint256 public liquidated;

    mapping(uint256 => Detail) public override details;
    mapping(uint256 => uint256) public lastDeposit;

    modifier updateDebt(uint256 _id) {
        accrueDebt(_id);
        _;
    }

    modifier wait(uint256 _id) {
        require(
            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,
            ""!wait""
        );
        accrueDebt(_id);
        _;
    }

    constructor(address _engine) {
        engine = IMochiEngine(_engine);
    }

    function initialize(address _asset) external override initializer {
        asset = IERC20(_asset);
        debtIndex = 1e18;
        lastAccrued = block.timestamp;
    }

    function liveDebtIndex() public view override returns (uint256 index) {
        return
            engine.mochiProfile().calculateFeeIndex(
                address(asset),
                debtIndex,
                lastAccrued
            );
    }

    function status(uint256 _id) public view override returns (Status) {
        return details[_id].status;
    }

    function currentDebt(uint256 _id) public view override returns (uint256) {
        require(details[_id].status != Status.Invalid, ""invalid"");
        uint256 newIndex = liveDebtIndex();
        return (details[_id].debt * newIndex) / details[_id].debtIndex;
    }

    function accrueDebt(uint256 _id) public {
        // global debt for vault
        // first, increase gloabal debt;
        uint256 currentIndex = liveDebtIndex();
        uint256 increased = (debts * currentIndex) / debtIndex - debts;
        debts += increased;
        claimable += int256(increased);
        // update global debtIndex
        debtIndex = currentIndex;
        lastAccrued = block.timestamp;
        // individual debt
        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {
            require(details[_id].status != Status.Invalid, ""invalid"");
            if (details[_id].debt != 0) {
                uint256 increasedDebt = (details[_id].debt * debtIndex) /
                    details[_id].debtIndex -
                    details[_id].debt;
                uint256 discountedDebt = increasedDebt.multiply(
                    engine.discountProfile().discount(engine.nft().ownerOf(_id))
                );
                debts -= discountedDebt;
                claimable -= int256(discountedDebt);
                details[_id].debt += (increasedDebt - discountedDebt);
            }
            details[_id].debtIndex = debtIndex;
        }
    }

    function increase(
        uint256 _id,
        uint256 _deposits,
        uint256 _borrows,
        address _referrer,
        bytes memory _data
    ) external {
        if (_id == type(uint256).max) {
            // mint if _id is -1
            _id = mint(msg.sender, _referrer);
        }
        if (_deposits > 0) {
            deposit(_id, _deposits);
        }
        if (_borrows > 0) {
            borrow(_id, _borrows, _data);
        }
    }

    function decrease(
        uint256 _id,
        uint256 _withdraws,
        uint256 _repays,
        bytes memory _data
    ) external {
        if (_repays > 0) {
            repay(_id, _repays);
        }
        if (_withdraws > 0) {
            withdraw(_id, _withdraws, _data);
        }
    }

    function mint(address _recipient, address _referrer)
        public
        returns (uint256 id)
    {
        id = engine.nft().mint(address(asset), _recipient);
        details[id].debtIndex = liveDebtIndex();
        details[id].status = Status.Idle;
        details[id].referrer = _referrer;
    }

    /// anyone can deposit collateral to given id
    /// it will even allow depositing to liquidated vault so becareful when depositing
    function deposit(uint256 _id, uint256 _amount)
        public
        override
        updateDebt(_id)
    {
        // should it be able to deposit if invalid?
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        require(
            details[_id].status == Status.Idle ||
                details[_id].status == Status.Collaterized ||
                details[_id].status == Status.Active,
            ""!depositable""
        );
        lastDeposit[_id] = block.timestamp;
        deposits += _amount;
        details[_id].collateral += _amount;
        if (details[_id].status == Status.Idle) {
            details[_id].status = Status.Collaterized;
        }
        asset.cheapTransferFrom(msg.sender, address(this), _amount);
    }

    /// should only be able to withdraw if status is not liquidatable
    function withdraw(
        uint256 _id,
        uint256 _amount,
        bytes memory _data
    ) public override wait(_id) {
        require(engine.nft().ownerOf(_id) == msg.sender, ""!approved"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        // update prior to interaction
        float memory price = engine.cssr().update(address(asset), _data);
        require(
            !_liquidatable(
                details[_id].collateral - _amount,
                price,
                details[_id].debt
            ),
            ""!healthy""
        );
        float memory cf = engine.mochiProfile().maxCollateralFactor(
            address(asset)
        );
        uint256 maxMinted = (details[_id].collateral - _amount)
            .multiply(cf)
            .multiply(price);
        require(details[_id].debt <= maxMinted, "">cf"");
        deposits -= _amount;
        details[_id].collateral -= _amount;
        if (details[_id].collateral == 0) {
            details[_id].status = Status.Idle;
        }
        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);
    }

    function borrow(
        uint256 _id,
        uint256 _amount,
        bytes memory _data
    ) public override updateDebt(_id) {
        // update prior to interaction
        float memory price = engine.cssr().update(address(asset), _data);
        float memory cf = engine.mochiProfile().maxCollateralFactor(
            address(asset)
        );
        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(
            price
        );
        require(engine.nft().ownerOf(_id) == msg.sender, ""!approved"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        if(details[_id].debt + _amount > maxMinted) {
            _amount = maxMinted - details[_id].debt;
        }
        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {
            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;
        }
        uint256 increasingDebt = (_amount * 1005) / 1000;
        uint256 totalDebt = details[_id].debt + increasingDebt;
        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), ""<minimum"");
        require(
            !_liquidatable(details[_id].collateral, price, totalDebt),
            ""!healthy""
        );
        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);
        // this will ensure debtIndex will not increase on further `updateDebt` triggers
        details[_id].debtIndex =
            (details[_id].debtIndex * (totalDebt)) /
            (details[_id].debt + _amount);
        details[_id].debt = totalDebt;
        details[_id].status = Status.Active;
        debts += _amount;
        engine.minter().mint(msg.sender, _amount);
    }

    /// someone sends usdm to this address and repays the debt
    /// will payback the leftover usdm
    function repay(uint256 _id, uint256 _amount)
        public
        override
        updateDebt(_id)
    {
        if (_amount > details[_id].debt) {
            _amount = details[_id].debt;
        }
        require(_amount > 0, ""zero"");
        if (debts < _amount) {
            // safe gaurd to some underflows
            debts = 0;
        } else {
            debts -= _amount;
        }
        details[_id].debt -= _amount;
        if (details[_id].debt == 0) {
            details[_id].status = Status.Collaterized;
        }
        engine.usdm().transferFrom(msg.sender, address(this), _amount);
        engine.usdm().burn(_amount);
    }

    function liquidate(
        uint256 _id,
        uint256 _collateral,
        uint256 _usdm
    ) external override updateDebt(_id) {
        require(msg.sender == address(engine.liquidator()), ""!liquidator"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        float memory price = engine.cssr().getPrice(address(asset));
        require(
            _liquidatable(details[_id].collateral, price, currentDebt(_id)),
            ""healthy""
        );

        debts -= _usdm;

        details[_id].collateral -= _collateral;
        details[_id].debt -= _usdm;

        asset.cheapTransfer(msg.sender, _collateral);
    }

    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount
    /// @notice should return false if _collateral * liquidationLimit < _debt
    function _liquidatable(
        uint256 _collateral,
        float memory _price,
        uint256 _debt
    ) internal view returns (bool) {
        float memory lf = engine.mochiProfile().liquidationFactor(
            address(asset)
        );
        // when debt is lower than liquidation value, it can be liquidated
        return _collateral.multiply(lf) < _debt.divide(_price);
    }

    function liquidatable(uint256 _id) external view returns (bool) {
        float memory price = engine.cssr().getPrice(address(asset));
        return _liquidatable(details[_id].collateral, price, currentDebt(_id));
    }

    function claim() external updateDebt(type(uint256).max) {
        require(claimable > 0, ""!claimable"");
        // reserving 25% to prevent potential risks
        uint256 toClaim = (uint256(claimable) * 75) / 100;
        mintFeeToPool(toClaim, address(0));
    }

    function mintFeeToPool(uint256 _amount, address _referrer) internal {
        claimable -= int256(_amount);
        if (address(0) != _referrer) {
            engine.minter().mint(address(engine.referralFeePool()), _amount);
            engine.referralFeePool().addReward(_referrer);
        } else {
            engine.minter().mint(address(engine.treasury()), _amount);
        }
    }

    // Flash Loan
    function maxFlashLoan(address _token)
        external
        view
        override
        returns (uint256)
    {
        require(_token == address(asset), ""!supported"");
        return asset.balanceOf(address(this));
    }

    function flashFee(address _token, uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        //should return 0.1337% * _amount;
        require(_token == address(asset), ""!supported"");
        return (_amount * 1337) / 1000000;
    }

    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external override returns (bool) {
        require(_token == address(asset), ""!supported"");
        uint256 fee = flashFee(_token, _amount);
        asset.cheapTransfer(address(_receiver), _amount);
        require(
            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==
                CALLBACK_SUCCESS,
            ""!callback""
        );
        asset.cheapTransferFrom(address(_receiver), address(this), _amount);
        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);
        return true;
    }
}",3028,374,"[H-01] Vault fails to track debt correctly that leads to bad debt
Arithmetic issue in function `borrow`

It's similar to the issue ""misuse amount as increasing debt in the vault contract"". Similar issue in a different place that leads to different exploit patterns and severity.
When users borrow usdm from a vault, the debt increases by the amount * 1.005.
    uint256 increasingDebt = (_amount * 1005) / 1000;

However, when the contract records the total debt it uses _amount instead of increasingDebt.
details[_id].debtIndex =
    (details[_id].debtIndex * (totalDebt)) /
    (details[_id].debt + _amount);
details[_id].debt = totalDebt;
details[_id].status = Status.Active;
debts += _amount;
 [H-05] debts calculation is not accurate

Submitted by gpersoon
Impact

The value of the global variable `debts` in the contract MochiVault.sol is calculated in an inconsistent way.
In the function borrow() the variable debts is increased with a value excluding the fee. However in repay() and liquidate() it is decreased with the same value as details\[\_id].debt is decreased, which is including the fee.
This would mean that debts will end up in a negative value when all debts are repay-ed. Luckily the function repay() prevents this from happening.
In the meantime the value of debts isn't accurate. This value is used directly or indirectly in:
utilizationRatio(), stabilityFee() calculateFeeIndex() of MochiProfileV0.sol
liveDebtIndex(), accrueDebt(), currentDebt() of MochiVault.sol
 [H-08] Anyone can extend withdraw wait period by depositing zero collateral

In MochiVault.sol, the `deposit` function allows anyone to deposit collateral into any position. A malicious user can call this function with amount = 0, which would reset the amount of time the owner has to wait before they can withdraw their collateral from their position. This is especially troublesome with longer delays, as a malicious user would only have to spend a little gas to lock out all other users from being able to withdraw from their positions, compromising the functionality of the contract altogether.

[M-04] Unchecked ERC20 transfer calls

Submitted by loop, also found by cmichel, defsec, gzeon, leastwood, nikitastupin, pants, and WatchPug
ERC20 transfer and transferFrom calls normally return true on a succesful transfer. In DutchAuctionLiquidator the call asset.transfer(msg.sender, _collateral); is made. asset refers to whichever ERC20 asset is used for the vault of that auction. If asset is an ERC20 token which does not comply with the EIP-20 standard it might return false on a failed transaction rather than revert. In this case it would count as a valid transaction even though it is not. If a vault would be making use of USDT the transfer call would always revert as USDT returns void on transfers.
There are a few more transfer(From) calls which are unchecked, these are however all on a predetermined asset (mochi, usdM and crv) and unlikely to cause problems.
 [M-10] griefing attack to block withdraws

Every time you deposit some assets in the vault (via deposit() of MochiVault.sol) then ""lastDeposit[_id]"" is set to block.timestamp. The modifier wait() checks this value and makes sure you cannot withdraw for ""delay()"" blocks. The default value for delay() is 3 minutes.
Knowing this delay you can do a griefing attack: On chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets). On chains with high gas fees: monitor the mempool for a withdraw() transaction and frontrun it with a deposit()
",5,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@mochifi/library/contracts/CheapERC20.sol"";
import ""../interfaces/IERC3156FlashLender.sol"";
import ""../interfaces/IMochiVault.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IUSDM.sol"";

contract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {
    using Float for uint256;
    using CheapERC20 for IERC20;

    bytes32 public constant CALLBACK_SUCCESS =
        keccak256(""ERC3156FlashBorrower.onFlashLoan"");

    
    IMochiEngine public immutable engine;
    IERC20 public override asset;

    
    uint256 public debtIndex;
    uint256 public lastAccrued;

    
    uint256 public override deposits;
    uint256 public override debts;
    int256 public override claimable;

    
    
    

    
    uint256 public liquidated;

    mapping(uint256 => Detail) public override details;
    mapping(uint256 => uint256) public lastDeposit;

    modifier updateDebt(uint256 _id) {
        accrueDebt(_id);
        _;
    }

    modifier wait(uint256 _id) {
        require(
            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,
            ""!wait""
        );
        accrueDebt(_id);
        _;
    }

    constructor(address _engine) {
        engine = IMochiEngine(_engine);
    }

    function initialize(address _asset) external override initializer {
        asset = IERC20(_asset);
        debtIndex = 1e18;
        lastAccrued = block.timestamp;
    }

    function liveDebtIndex() public view override returns (uint256 index) {
        return
            engine.mochiProfile().calculateFeeIndex(
                address(asset),
                debtIndex,
                lastAccrued
            );
    }

    function status(uint256 _id) public view override returns (Status) {
        return details[_id].status;
    }

    function currentDebt(uint256 _id) public view override returns (uint256) {
        require(details[_id].status != Status.Invalid, ""invalid"");
        uint256 newIndex = liveDebtIndex();
        return (details[_id].debt * newIndex) / details[_id].debtIndex;
    }

    function accrueDebt(uint256 _id) public {
        
        
        uint256 currentIndex = liveDebtIndex();
        uint256 increased = (debts * currentIndex) / debtIndex - debts;
        debts += increased;
        claimable += int256(increased);
        
        debtIndex = currentIndex;
        lastAccrued = block.timestamp;
        
        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {
            require(details[_id].status != Status.Invalid, ""invalid"");
            if (details[_id].debt != 0) {
                uint256 increasedDebt = (details[_id].debt * debtIndex) /
                    details[_id].debtIndex -
                    details[_id].debt;
                uint256 discountedDebt = increasedDebt.multiply(
                    engine.discountProfile().discount(engine.nft().ownerOf(_id))
                );
                debts -= discountedDebt;
                claimable -= int256(discountedDebt);
                details[_id].debt += (increasedDebt - discountedDebt);
            }
            details[_id].debtIndex = debtIndex;
        }
    }

    function increase(
        uint256 _id,
        uint256 _deposits,
        uint256 _borrows,
        address _referrer,
        bytes memory _data
    ) external {
        if (_id == type(uint256).max) {
            
            _id = mint(msg.sender, _referrer);
        }
        if (_deposits > 0) {
            deposit(_id, _deposits);
        }
        if (_borrows > 0) {
            borrow(_id, _borrows, _data);
        }
    }

    function decrease(
        uint256 _id,
        uint256 _withdraws,
        uint256 _repays,
        bytes memory _data
    ) external {
        if (_repays > 0) {
            repay(_id, _repays);
        }
        if (_withdraws > 0) {
            withdraw(_id, _withdraws, _data);
        }
    }

    function mint(address _recipient, address _referrer)
        public
        returns (uint256 id)
    {
        id = engine.nft().mint(address(asset), _recipient);
        details[id].debtIndex = liveDebtIndex();
        details[id].status = Status.Idle;
        details[id].referrer = _referrer;
    }

    
    
    function deposit(uint256 _id, uint256 _amount)
        public
        override
        updateDebt(_id)
    {
        
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        require(
            details[_id].status == Status.Idle ||
                details[_id].status == Status.Collaterized ||
                details[_id].status == Status.Active,
            ""!depositable""
        );
        lastDeposit[_id] = block.timestamp;
        deposits += _amount;
        details[_id].collateral += _amount;
        if (details[_id].status == Status.Idle) {
            details[_id].status = Status.Collaterized;
        }
        asset.cheapTransferFrom(msg.sender, address(this), _amount);
    }

    
    function withdraw(
        uint256 _id,
        uint256 _amount,
        bytes memory _data
    ) public override wait(_id) {
        require(engine.nft().ownerOf(_id) == msg.sender, ""!approved"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        
        float memory price = engine.cssr().update(address(asset), _data);
        require(
            !_liquidatable(
                details[_id].collateral - _amount,
                price,
                details[_id].debt
            ),
            ""!healthy""
        );
        float memory cf = engine.mochiProfile().maxCollateralFactor(
            address(asset)
        );
        uint256 maxMinted = (details[_id].collateral - _amount)
            .multiply(cf)
            .multiply(price);
        require(details[_id].debt <= maxMinted, "">cf"");
        deposits -= _amount;
        details[_id].collateral -= _amount;
        if (details[_id].collateral == 0) {
            details[_id].status = Status.Idle;
        }
        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);
    }

    function borrow(
        uint256 _id,
        uint256 _amount,
        bytes memory _data
    ) public override updateDebt(_id) {
        
        float memory price = engine.cssr().update(address(asset), _data);
        float memory cf = engine.mochiProfile().maxCollateralFactor(
            address(asset)
        );
        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(
            price
        );
        require(engine.nft().ownerOf(_id) == msg.sender, ""!approved"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        if(details[_id].debt + _amount > maxMinted) {
            _amount = maxMinted - details[_id].debt;
        }
        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {
            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;
        }
        uint256 increasingDebt = (_amount * 1005) / 1000;
        uint256 totalDebt = details[_id].debt + increasingDebt;
        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), ""<minimum"");
        require(
            !_liquidatable(details[_id].collateral, price, totalDebt),
            ""!healthy""
        );
        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);
        
        details[_id].debtIndex =
            (details[_id].debtIndex * (totalDebt)) /
            (details[_id].debt + _amount);
        details[_id].debt = totalDebt;
        details[_id].status = Status.Active;
        debts += _amount;
        engine.minter().mint(msg.sender, _amount);
    }

    
    
    function repay(uint256 _id, uint256 _amount)
        public
        override
        updateDebt(_id)
    {
        if (_amount > details[_id].debt) {
            _amount = details[_id].debt;
        }
        require(_amount > 0, ""zero"");
        if (debts < _amount) {
            
            debts = 0;
        } else {
            debts -= _amount;
        }
        details[_id].debt -= _amount;
        if (details[_id].debt == 0) {
            details[_id].status = Status.Collaterized;
        }
        engine.usdm().transferFrom(msg.sender, address(this), _amount);
        engine.usdm().burn(_amount);
    }

    function liquidate(
        uint256 _id,
        uint256 _collateral,
        uint256 _usdm
    ) external override updateDebt(_id) {
        require(msg.sender == address(engine.liquidator()), ""!liquidator"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        float memory price = engine.cssr().getPrice(address(asset));
        require(
            _liquidatable(details[_id].collateral, price, currentDebt(_id)),
            ""healthy""
        );

        debts -= _usdm;

        details[_id].collateral -= _collateral;
        details[_id].debt -= _usdm;

        asset.cheapTransfer(msg.sender, _collateral);
    }

    
    
    function _liquidatable(
        uint256 _collateral,
        float memory _price,
        uint256 _debt
    ) internal view returns (bool) {
        float memory lf = engine.mochiProfile().liquidationFactor(
            address(asset)
        );
        
        return _collateral.multiply(lf) < _debt.divide(_price);
    }

    function liquidatable(uint256 _id) external view returns (bool) {
        float memory price = engine.cssr().getPrice(address(asset));
        return _liquidatable(details[_id].collateral, price, currentDebt(_id));
    }

    function claim() external updateDebt(type(uint256).max) {
        require(claimable > 0, ""!claimable"");
        
        uint256 toClaim = (uint256(claimable) * 75) / 100;
        mintFeeToPool(toClaim, address(0));
    }

    function mintFeeToPool(uint256 _amount, address _referrer) internal {
        claimable -= int256(_amount);
        if (address(0) != _referrer) {
            engine.minter().mint(address(engine.referralFeePool()), _amount);
            engine.referralFeePool().addReward(_referrer);
        } else {
            engine.minter().mint(address(engine.treasury()), _amount);
        }
    }

    
    function maxFlashLoan(address _token)
        external
        view
        override
        returns (uint256)
    {
        require(_token == address(asset), ""!supported"");
        return asset.balanceOf(address(this));
    }

    function flashFee(address _token, uint256 _amount)
        public
        view
        override
        returns (uint256)
    {
        
        require(_token == address(asset), ""!supported"");
        return (_amount * 1337) / 1000000;
    }

    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external override returns (bool) {
        require(_token == address(asset), ""!supported"");
        uint256 fee = flashFee(_token, _amount);
        asset.cheapTransfer(address(_receiver), _amount);
        require(
            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==
                CALLBACK_SUCCESS,
            ""!callback""
        );
        asset.cheapTransferFrom(address(_receiver), address(this), _amount);
        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);
        return true;
    }
}",2692,3,2,,"{'ReviewingTheCode': ""The provided code snippet is a Solidity smart contract named 'MochiVault'. It is designed to manage a vault system for collateralized lending and borrowing, with features for depositing, withdrawing, borrowing, repaying, and liquidating assets. The contract also supports flash loans and integrates with external contracts for fee calculation, NFT management, and price oracles."", 'IdentifyingKeyComponents': {'ContractName': 'MochiVault', 'Purpose': 'To manage a vault system for collateralized lending and borrowing, including features for flash loans and liquidation.', 'InheritanceAndImports': {'InheritsFrom': ['Initializable', 'IMochiVault', 'IERC3156FlashLender'], 'Imports': ['@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol', '@mochifi/library/contracts/CheapERC20.sol', '../interfaces/IERC3156FlashLender.sol', '../interfaces/IMochiVault.sol', '../interfaces/IMochiEngine.sol', '../interfaces/IUSDM.sol']}, 'StateVariables': [{'Name': 'CALLBACK_SUCCESS', 'Type': 'bytes32', 'Purpose': 'Constant hash to validate flash loan callbacks.'}, {'Name': 'engine', 'Type': 'IMochiEngine', 'Purpose': 'Immutable reference to the MochiEngine contract.'}, {'Name': 'asset', 'Type': 'IERC20', 'Purpose': 'The ERC20 token managed by the vault.'}, {'Name': 'debtIndex', 'Type': 'uint256', 'Purpose': 'Index used to calculate accrued debt.'}, {'Name': 'lastAccrued', 'Type': 'uint256', 'Purpose': 'Timestamp of the last debt accrual.'}, {'Name': 'deposits', 'Type': 'uint256', 'Purpose': 'Total deposits in the vault.'}, {'Name': 'debts', 'Type': 'uint256', 'Purpose': 'Total debts in the vault.'}, {'Name': 'claimable', 'Type': 'int256', 'Purpose': 'Amount of fees claimable by the treasury or referral pool.'}, {'Name': 'liquidated', 'Type': 'uint256', 'Purpose': 'Total amount liquidated.'}, {'Name': 'details', 'Type': 'mapping(uint256 => Detail)', 'Purpose': 'Mapping of vault details by ID.'}, {'Name': 'lastDeposit', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Mapping of the last deposit timestamp by ID.'}], 'FunctionsAndModifiers': [{'Name': 'updateDebt', 'Visibility': 'modifier', 'Purpose': 'Accrues debt before executing a function.', 'Parameters': ['uint256 _id'], 'Returns': []}, {'Name': 'wait', 'Visibility': 'modifier', 'Purpose': 'Ensures a delay has passed before executing a function.', 'Parameters': ['uint256 _id'], 'Returns': []}, {'Name': 'initialize', 'Visibility': 'external', 'Purpose': 'Initializes the vault with the asset.', 'Parameters': ['address _asset'], 'Returns': []}, {'Name': 'liveDebtIndex', 'Visibility': 'public', 'Purpose': 'Returns the current debt index.', 'Parameters': [], 'Returns': ['uint256 index']}, {'Name': 'status', 'Visibility': 'public', 'Purpose': 'Returns the status of a vault.', 'Parameters': ['uint256 _id'], 'Returns': ['Status']}, {'Name': 'currentDebt', 'Visibility': 'public', 'Purpose': 'Returns the current debt of a vault.', 'Parameters': ['uint256 _id'], 'Returns': ['uint256']}, {'Name': 'accrueDebt', 'Visibility': 'public', 'Purpose': 'Accrues debt for a specific vault.', 'Parameters': ['uint256 _id'], 'Returns': []}, {'Name': 'increase', 'Visibility': 'external', 'Purpose': 'Increases deposits or borrows in a vault.', 'Parameters': ['uint256 _id', 'uint256 _deposits', 'uint256 _borrows', 'address _referrer', 'bytes memory _data'], 'Returns': []}, {'Name': 'decrease', 'Visibility': 'external', 'Purpose': 'Decreases deposits or repays debts in a vault.', 'Parameters': ['uint256 _id', 'uint256 _withdraws', 'uint256 _repays', 'bytes memory _data'], 'Returns': []}, {'Name': 'mint', 'Visibility': 'public', 'Purpose': 'Mints a new vault NFT.', 'Parameters': ['address _recipient', 'address _referrer'], 'Returns': ['uint256 id']}, {'Name': 'deposit', 'Visibility': 'public', 'Purpose': 'Deposits assets into a vault.', 'Parameters': ['uint256 _id', 'uint256 _amount'], 'Returns': []}, {'Name': 'withdraw', 'Visibility': 'public', 'Purpose': 'Withdraws assets from a vault.', 'Parameters': ['uint256 _id', 'uint256 _amount', 'bytes memory _data'], 'Returns': []}, {'Name': 'borrow', 'Visibility': 'public', 'Purpose': 'Borrows assets from a vault.', 'Parameters': ['uint256 _id', 'uint256 _amount', 'bytes memory _data'], 'Returns': []}, {'Name': 'repay', 'Visibility': 'public', 'Purpose': 'Repays debts in a vault.', 'Parameters': ['uint256 _id', 'uint256 _amount'], 'Returns': []}, {'Name': 'liquidate', 'Visibility': 'external', 'Purpose': 'Liquidates a vault.', 'Parameters': ['uint256 _id', 'uint256 _collateral', 'uint256 _usdm'], 'Returns': []}, {'Name': '_liquidatable', 'Visibility': 'internal', 'Purpose': 'Checks if a vault is liquidatable.', 'Parameters': ['uint256 _collateral', 'float memory _price', 'uint256 _debt'], 'Returns': ['bool']}, {'Name': 'liquidatable', 'Visibility': 'external', 'Purpose': 'Checks if a vault is liquidatable.', 'Parameters': ['uint256 _id'], 'Returns': ['bool']}, {'Name': 'claim', 'Visibility': 'external', 'Purpose': 'Claims fees from the vault.', 'Parameters': [], 'Returns': []}, {'Name': 'mintFeeToPool', 'Visibility': 'internal', 'Purpose': 'Mints fees to the treasury or referral pool.', 'Parameters': ['uint256 _amount', 'address _referrer'], 'Returns': []}, {'Name': 'maxFlashLoan', 'Visibility': 'external', 'Purpose': 'Returns the maximum flash loan amount.', 'Parameters': ['address _token'], 'Returns': ['uint256']}, {'Name': 'flashFee', 'Visibility': 'public', 'Purpose': 'Returns the fee for a flash loan.', 'Parameters': ['address _token', 'uint256 _amount'], 'Returns': ['uint256']}, {'Name': 'flashLoan', 'Visibility': 'external', 'Purpose': 'Executes a flash loan.', 'Parameters': ['IERC3156FlashBorrower _receiver', 'address _token', 'uint256 _amount', 'bytes calldata _data'], 'Returns': ['bool']}]}, 'ExternalInteractions': ['IMochiEngine', 'IERC20', 'IERC3156FlashBorrower', 'IMochiProfile', 'ICSSR', 'IMinter', 'IUSDM', 'INFT', 'IReferralFeePool', 'ITreasury'], 'SpecialMechanisms': ['Flash loan functionality compliant with ERC-3156.', 'Debt accrual mechanism based on a debt index.', 'Collateralized lending with liquidation checks.', 'Fee distribution to treasury and referral pool.'], 'Questions': [""What is the exact structure of the 'Detail' struct used in the 'details' mapping?"", ""How is the 'float' type defined and used in the contract?"", ""What is the purpose of the 'CheapERC20' library and how does it differ from standard ERC20?"", ""How does the 'mochiProfile' contract calculate fees and what are the parameters involved?"", ""What are the specific roles of the 'engine', 'minter', 'cssr', and 'nft' contracts in the vault's operations?""]}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `withdraw` Function', 'Severity': 'High', 'Description': ""The `withdraw` function transfers assets before updating the state, which could allow a reentrancy attack where an attacker can repeatedly call the function before the state is updated, potentially draining the contract's funds."", 'Impact': 'Loss of funds due to reentrancy attack.', 'Location': 'withdraw function in various contracts'}, {'Issue': 'Uninitialized State Variables', 'Severity': 'High', 'Description': 'The contract uses the `Initializable` pattern but does not initialize all state variables in the `initialize` function. This can lead to undefined behavior and potential vulnerabilities if the contract is upgraded or reinitialized.', 'Impact': 'Uninitialized state variables can cause unexpected behavior, leading to potential security risks such as unauthorized access or incorrect calculations.', 'Location': 'initialize function in various contracts'}, {'Issue': 'Lack of Access Control in `mint` Function', 'Severity': 'Medium', 'Description': 'The `mint` function is publicly accessible and does not have any access control mechanisms. This could allow unauthorized users to mint new tokens or NFTs, potentially leading to abuse or manipulation of the system.', 'Impact': 'Unauthorized minting could lead to inflation of the token supply or unauthorized creation of assets.', 'Location': 'mint function in various contracts'}, {'Issue': 'Potential Integer Overflow in `accrueDebt` Function', 'Severity': 'Medium', 'Description': 'The `accrueDebt` function performs arithmetic operations without checking for potential integer overflow. This could lead to unexpected behavior or vulnerabilities if the values involved are too large.', 'Impact': 'Integer overflow could lead to incorrect debt calculations, potentially causing financial losses or instability.', 'Location': 'accrueDebt function in various contracts'}, {'Issue': 'Insufficient Validation in `borrow` Function', 'Severity': 'Medium', 'Description': 'The `borrow` function does not sufficiently validate the `_amount` parameter against the available collateral and credit cap. This could lead to over-borrowing or violation of credit limits.', 'Impact': 'Potential over-borrowing or violation of credit limits, leading to financial instability or loss.', 'Location': 'borrow function in various contracts'}, {'Issue': 'Flash Loan Fee Calculation Vulnerability', 'Severity': 'Low', 'Description': 'The `flashFee` function calculates the fee as a fixed percentage of the loan amount. This approach may not account for varying market conditions and could lead to unfair fees or incorrect fee amounts.', 'Impact': 'Incorrect fee calculations could lead to financial discrepancies or exploitation of the flash loan mechanism.', 'Location': 'flashFee function in various contracts'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': ""Several critical functions such as `deposit`, `withdraw`, `borrow`, and `repay` do not emit events. This makes it difficult to track and audit changes to the contract's state."", 'Impact': 'Reduced transparency and auditability of contract state changes.', 'Location': 'deposit, withdraw, borrow, repay functions in various contracts'}, {'Issue': 'Unbounded Loops in `accrueDebt` Function', 'Severity': 'Medium', 'Description': 'The `accrueDebt` function iterates over all details in the mapping without a clear upper bound. This can lead to high gas consumption and potential denial of service (DoS) attacks if the number of details grows too large.', 'Impact': 'High gas consumption and potential DoS attacks.', 'Location': 'accrueDebt function in various contracts'}, {'Issue': 'Insufficient Validation in `deposit` Function', 'Severity': 'Medium', 'Description': 'The `deposit` function does not validate the `_amount` parameter to ensure it is greater than zero, which could lead to unnecessary state changes and potential vulnerabilities.', 'Impact': 'Unnecessary state changes and potential vulnerabilities.', 'Location': 'deposit function in various contracts'}, {'Issue': 'Lack of Access Control in `initialize` Function', 'Severity': 'Medium', 'Description': 'The `initialize` function can be called by any user, potentially allowing unauthorized initialization of the contract. This could lead to unexpected behavior or manipulation of the contract state.', 'Impact': 'Unauthorized initialization could lead to unexpected behavior or manipulation of the contract state.', 'Location': 'initialize function in various contracts'}, {'Issue': 'Potential Front-Running in `liquidate` Function', 'Severity': 'Medium', 'Description': 'The `liquidate` function does not include any mechanisms to prevent front-running. This could allow malicious actors to exploit the liquidation process for profit.', 'Impact': 'Front-running could lead to unfair liquidations, potentially causing financial loss to users.', 'Location': 'liquidate function in various contracts'}, {'Issue': 'Insufficient Validation in `liquidate` Function', 'Severity': 'Medium', 'Description': 'The `liquidate` function does not validate the `_collateral` and `_usdm` parameters sufficiently, which could lead to incorrect liquidation amounts.', 'Impact': 'Incorrect liquidation could lead to loss of funds or unfair liquidation of positions.', 'Location': 'liquidate function in various contracts'}, {'Issue': 'Unchecked External Call in `flashLoan` Function', 'Severity': 'High', 'Description': 'The `flashLoan` function makes an external call to `_receiver.onFlashLoan` without checking the return value or handling potential failures, which could lead to unexpected behavior or loss of funds.', 'Impact': 'If the external call fails or behaves maliciously, it could lead to loss of funds or other unintended consequences.', 'Location': 'flashLoan function in various contracts'}, {'Issue': 'Potential Division by Zero in `repay` Function', 'Severity': 'High', 'Description': 'The `repay` function performs division operations without checking if the divisor is zero. This could lead to a division by zero error and contract failure.', 'Impact': 'Potential contract failure and loss of funds.', 'Location': 'repay function in various contracts'}, {'Issue': 'Incorrect State Update in `liquidate` Function', 'Severity': 'Medium', 'Description': 'The `liquidate` function updates the state variables `debts`, `details[_id].collateral`, and `details[_id].debt` without ensuring atomicity. If the function fails mid-execution, the state could be left inconsistent.', 'Impact': 'Inconsistent state leading to potential vulnerabilities.', 'Location': 'liquidate function in various contracts'}], 'IssueNumber': 15, 'OutputList': 15}",693.9159359931946,"### **Output**

---

**[H-01] Vault fails to track debt correctly that leads to bad debt**

**Report Description**:
The `borrow` function in the vault contract incorrectly calculates the debt. When users borrow `usdm`, the debt increases by `_amount * 1.005`, but the total debt is recorded using `_amount` instead of `increasingDebt`. This inconsistency leads to incorrect debt tracking, which could result in bad debt and financial discrepancies in the system.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of incorrect debt tracking in the `borrow` function. The issue involves arithmetic errors and inconsistent state updates, which are not covered in the response list.

---

**[H-05] `debts` calculation is not accurate**

**Report Description**:
The global variable `debts` in `MochiVault.sol` is calculated inconsistently. In the `borrow` function, `debts` is increased by a value excluding the fee, while in `repay` and `liquidate`, it is decreased by a value including the fee. This inconsistency could lead to `debts` becoming negative when all debts are repaid, although `repay` prevents this. The inaccurate `debts` value affects several functions, including `utilizationRatio`, `stabilityFee`, and `accrueDebt`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the inconsistency in `debts` calculation across different functions. This issue is critical for accurate financial tracking and is not covered in the response list.

---

**[H-08] Anyone can extend withdraw wait period by depositing zero collateral**

**Report Description**:
The `deposit` function in `MochiVault.sol` allows anyone to deposit collateral into any position, even with `amount = 0`. This resets the `lastDeposit[_id]` timestamp, extending the wait period for withdrawals. A malicious user could exploit this to lock out other users from withdrawing their collateral, especially on chains with low gas fees, by repeatedly depositing zero amounts.

**Match in Response List**:
Matches with the issue titled **""Insufficient Validation in `deposit` Function""**.

**Validation**:
**Partially Correct**. The response identifies the lack of validation in the `deposit` function but does not specifically address the exploit of resetting the withdrawal wait period by depositing zero collateral. The impact of this vulnerability is more severe than the response suggests.

---

**[M-04] Unchecked ERC20 transfer calls**

**Report Description**:
The `asset.transfer` call in `DutchAuctionLiquidator` is unchecked, meaning it does not verify the return value. If the `asset` is an ERC20 token that does not comply with the EIP-20 standard (e.g., USDT, which returns `void` on transfers), the transfer could fail silently, leading to incorrect state updates and potential loss of funds.

**Match in Response List**:
Matches with the issue titled **""Unchecked External Call in `flashLoan` Function""**.

**Validation**:
**Partially Correct**. The response identifies the risk of unchecked external calls but does not specifically address the issue with ERC20 `transfer` calls. The vulnerability in `DutchAuctionLiquidator` is not directly covered.

---

**[M-10] Griefing attack to block withdraws**

**Report Description**:
The `deposit` function in `MochiVault.sol` sets `lastDeposit[_id]` to `block.timestamp`, which is used by the `wait` modifier to enforce a withdrawal delay. A malicious user can exploit this by depositing a tiny amount every 3 minutes (or frontrunning `withdraw` transactions on high gas fee chains) to block withdrawals for specific NFT IDs, effectively locking out other users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific griefing attack that exploits the `deposit` function to block withdrawals. This issue is critical for the contract's functionality and is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-08] Anyone can extend withdraw wait period by depositing zero collateral**
- **[M-04] Unchecked ERC20 transfer calls**

**Missed Issues from Issue Report**:
- **[H-01] Vault fails to track debt correctly that leads to bad debt**
- **[H-05] `debts` calculation is not accurate**
- **[M-10] Griefing attack to block withdraws**

---

### **Conclusion**
The response list partially addresses some issues but misses critical vulnerabilities related to debt tracking, `debts` calculation, and griefing attacks. The partially correct matches lack sufficient detail to fully address the reported issues. Significant gaps remain in the coverage of the provided issue report.","```
None.
```",0.0
FeePoolV0.sol,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IFeePool.sol"";
import ""../interfaces/IUSDM.sol"";
import ""../interfaces/IMochiEngine.sol"";

contract FeePoolV0 is IFeePool {
    IMochiEngine public immutable engine;

    IUniswapV2Router02 public immutable uniswapRouter;

    address public crvVoterRewardPool;

    uint256 public treasuryRatio;

    uint256 public vMochiRatio;

    uint256 public mochiShare;

    uint256 public treasuryShare;

    constructor(address _engine, address _uniswap) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
        treasuryRatio = 20e16;
        vMochiRatio = 80e16;
    }

    function updateReserve() external override {
        uint256 newReserve = engine.usdm().balanceOf(address(this)) -
            mochiShare -
            treasuryShare;
        treasuryShare += (newReserve * treasuryRatio) / 1e18;
        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;
    }

    function changecrvVoterRewardPool(address _pool) external {
        require(msg.sender == engine.governance(), ""!gov"");
        crvVoterRewardPool = _pool;
    }

    function changeTreasuryRatio(uint256 _ratio) external {
        require(msg.sender == engine.governance(), ""!gov"");
        treasuryRatio = _ratio;
    }

    function changevMochiRatio(uint256 _ratio) external {
        require(msg.sender == engine.governance(), ""!gov"");
        vMochiRatio = _ratio;
    }

    // this will open up arb oppertunity for Mochi
    // so we will not reward the caller, caller can benefit from flashbot
    // should decide which market we should use UniV2?V3? BalancerV2?
    function distributeMochi() external {
        // buy Mochi with mochiShare
        _buyMochi();
        _shareMochi();
    }

    function _buyMochi() internal {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = address(engine.mochi());
        usdm.approve(address(uniswapRouter), mochiShare);
        uniswapRouter.swapExactTokensForTokens(
            mochiShare,
            1,
            path,
            address(this),
            type(uint256).max
        );
    }

    function _shareMochi() internal {
        IMochi mochi = engine.mochi();
        uint256 mochiBalance = mochi.balanceOf(address(this));
        // send Mochi to vMochi Vault
        mochi.transfer(
            address(engine.vMochi()),
            (mochiBalance * vMochiRatio) / 1e18
        );
        // send Mochi to veCRV Holders
        mochi.transfer(
            crvVoterRewardPool,
            (mochiBalance * (1e18 - vMochiRatio)) / 1e18
        );
        // flush mochiShare
        mochiShare = 0;
        treasuryShare = 0;
    }

    function sendToTreasury() external {
        engine.usdm().transfer(engine.treasury(), treasuryShare);
        treasuryShare = 0;
    }
}",789,101,"[H-02] FeePoolV0.sol#distributeMochi() will unexpectedly flush treasuryShare, causing the protocol fee cannot be properly accounted for and collected

Submitted by WatchPug
`distributeMochi()` will call _buyMochi() to convert mochiShare to Mochi token and call _shareMochi() to send Mochi to vMochi Vault and veCRV Holders. It wont touch the treasuryShare.
However, in the current implementation, treasuryShare will be reset to 0. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.
FeePoolV0.sol#L79 L95 ```
function _shareMochi() internal {
    IMochi mochi = engine.mochi();
    uint256 mochiBalance = mochi.balanceOf(address(this));
    // send Mochi to vMochi Vault
    mochi.transfer(
        address(engine.vMochi()),
        (mochiBalance * vMochiRatio) / 1e18
    );
    // send Mochi to veCRV Holders
    mochi.transfer(
        crvVoterRewardPool,
        (mochiBalance * (1e18 - vMochiRatio)) / 1e18
    );
    // flush mochiShare
    mochiShare = 0;
    treasuryShare = 0;
}
```  [H-11] treasuryShare is Overwritten in FeePoolV0._shareMochi()
Function `_shareMochi()`  overwritten `treasuryShare`
The FeePoolV0.sol contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and vMochi contracts. However, when `distributeMochi()` is called to distribute mochi tokens to veCRV holders, both mochiShare and treasuryShare is flushed from the contract when there are still usdm tokens in the contract.
 [H-12] feePool is vulnerable to sandwich attack.

There's a permissionless function `distributeMochi` in FeePoolV0.sol L55-L62. Since everyone can trigger this function, an attacker can launch a sandwich attack with flashloan to steal the funds.
The devs have mentioned this concern in the comment. An attacker can steal the funds with a flash loan attack.
Attackers can steal all the funds in the pool. I consider this is a high-risk issue.
",3,,"pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IFeePool.sol"";
import ""../interfaces/IUSDM.sol"";
import ""../interfaces/IMochiEngine.sol"";

contract FeePoolV0 is IFeePool {
    IMochiEngine public immutable engine;

    IUniswapV2Router02 public immutable uniswapRouter;

    address public crvVoterRewardPool;

    uint256 public treasuryRatio;

    uint256 public vMochiRatio;

    uint256 public mochiShare;

    uint256 public treasuryShare;

    constructor(address _engine, address _uniswap) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
        treasuryRatio = 20e16;
        vMochiRatio = 80e16;
    }

    function updateReserve() external override {
        uint256 newReserve = engine.usdm().balanceOf(address(this)) -
            mochiShare -
            treasuryShare;
        treasuryShare += (newReserve * treasuryRatio) / 1e18;
        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;
    }

    function changecrvVoterRewardPool(address _pool) external {
        require(msg.sender == engine.governance(), ""!gov"");
        crvVoterRewardPool = _pool;
    }

    function changeTreasuryRatio(uint256 _ratio) external {
        require(msg.sender == engine.governance(), ""!gov"");
        treasuryRatio = _ratio;
    }

    function changevMochiRatio(uint256 _ratio) external {
        require(msg.sender == engine.governance(), ""!gov"");
        vMochiRatio = _ratio;
    }

    
    
    
    function distributeMochi() external {
        
        _buyMochi();
        _shareMochi();
    }

    function _buyMochi() internal {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = address(engine.mochi());
        usdm.approve(address(uniswapRouter), mochiShare);
        uniswapRouter.swapExactTokensForTokens(
            mochiShare,
            1,
            path,
            address(this),
            type(uint256).max
        );
    }

    function _shareMochi() internal {
        IMochi mochi = engine.mochi();
        uint256 mochiBalance = mochi.balanceOf(address(this));
        
        mochi.transfer(
            address(engine.vMochi()),
            (mochiBalance * vMochiRatio) / 1e18
        );
        
        mochi.transfer(
            crvVoterRewardPool,
            (mochiBalance * (1e18 - vMochiRatio)) / 1e18
        );
        
        mochiShare = 0;
        treasuryShare = 0;
    }

    function sendToTreasury() external {
        engine.usdm().transfer(engine.treasury(), treasuryShare);
        treasuryShare = 0;
    }
}",685,3,0,,"{'ReviewingTheCode': 'The contract appears to be a fee distribution mechanism for a DeFi protocol, handling the distribution of fees between the treasury, vMochi, and a CRV voter reward pool. It interacts with external contracts like Uniswap for token swaps and the MochiEngine for governance and token management.', 'IdentifyingKeyComponents': {'ContractName': 'FeePoolV0', 'Purpose': 'To manage and distribute fees collected in the protocol, allocating them between the treasury, vMochi, and a CRV voter reward pool.', 'InheritanceAndImports': {'InheritsFrom': ['IFeePool'], 'Imports': ['@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol', '../interfaces/IFeePool.sol', '../interfaces/IUSDM.sol', '../interfaces/IMochiEngine.sol']}, 'StateVariables': [{'Name': 'engine', 'Type': 'IMochiEngine', 'Purpose': 'Reference to the MochiEngine contract for governance and token management.'}, {'Name': 'uniswapRouter', 'Type': 'IUniswapV2Router02', 'Purpose': 'Reference to the Uniswap V2 Router for token swaps.'}, {'Name': 'crvVoterRewardPool', 'Type': 'address', 'Purpose': 'Address of the CRV voter reward pool.'}, {'Name': 'treasuryRatio', 'Type': 'uint256', 'Purpose': 'Ratio of fees allocated to the treasury.'}, {'Name': 'vMochiRatio', 'Type': 'uint256', 'Purpose': 'Ratio of fees allocated to vMochi.'}, {'Name': 'mochiShare', 'Type': 'uint256', 'Purpose': 'Amount of USDM allocated for buying Mochi tokens.'}, {'Name': 'treasuryShare', 'Type': 'uint256', 'Purpose': 'Amount of USDM allocated for the treasury.'}], 'FunctionsAndModifiers': [{'Name': 'updateReserve', 'Visibility': 'external', 'Purpose': 'Updates the reserve by calculating new allocations for the treasury and Mochi based on the current USDM balance.', 'Parameters': [], 'Returns': []}, {'Name': 'changecrvVoterRewardPool', 'Visibility': 'external', 'Purpose': 'Changes the address of the CRV voter reward pool. Only callable by governance.', 'Parameters': ['address _pool'], 'Returns': []}, {'Name': 'changeTreasuryRatio', 'Visibility': 'external', 'Purpose': 'Changes the ratio of fees allocated to the treasury. Only callable by governance.', 'Parameters': ['uint256 _ratio'], 'Returns': []}, {'Name': 'changevMochiRatio', 'Visibility': 'external', 'Purpose': 'Changes the ratio of fees allocated to vMochi. Only callable by governance.', 'Parameters': ['uint256 _ratio'], 'Returns': []}, {'Name': 'distributeMochi', 'Visibility': 'external', 'Purpose': 'Distributes Mochi tokens by buying them from Uniswap and then sharing them between vMochi and the CRV voter reward pool.', 'Parameters': [], 'Returns': []}, {'Name': '_buyMochi', 'Visibility': 'internal', 'Purpose': 'Internal function to buy Mochi tokens using USDM via Uniswap.', 'Parameters': [], 'Returns': []}, {'Name': '_shareMochi', 'Visibility': 'internal', 'Purpose': 'Internal function to distribute Mochi tokens between vMochi and the CRV voter reward pool.', 'Parameters': [], 'Returns': []}, {'Name': 'sendToTreasury', 'Visibility': 'external', 'Purpose': 'Sends the allocated USDM to the treasury.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['IUniswapV2Router02 (Uniswap V2 Router)', 'IMochiEngine (Mochi Engine for governance and token management)', 'IUSDM (USDM token contract)', 'IMochi (Mochi token contract)'], 'SpecialMechanisms': ['The contract uses Uniswap for token swaps to convert USDM to Mochi tokens.', 'It implements a fee distribution mechanism with adjustable ratios for treasury and vMochi allocations.'], 'Questions': [""What is the purpose of the 'crvVoterRewardPool' and how is it used in the protocol?"", ""How are the initial values for 'treasuryRatio' and 'vMochiRatio' determined?"", 'Is there any mechanism to handle slippage during the Uniswap swap?', 'What happens if the Mochi token balance is insufficient during the distribution process?']}","{'Findings': [{'Issue': 'Unrestricted Approval in `_buyMochi` Function', 'Severity': 'High', 'Description': 'The `_buyMochi` function approves the Uniswap router to spend the entire `mochiShare` amount without any restrictions. This could potentially lead to the Uniswap router spending more tokens than intended if the contract is compromised or if there is a reentrancy attack.', 'Impact': 'If exploited, this could result in the loss of funds from the contract.', 'Location': '_buyMochi function'}, {'Issue': 'Potential Reentrancy in `distributeMochi` Function', 'Severity': 'High', 'Description': 'The `distributeMochi` function calls `_buyMochi` and `_shareMochi` which involve external calls to Uniswap and token transfers. These external calls could potentially be exploited in a reentrancy attack if the external contracts are malicious or compromised.', 'Impact': 'An attacker could exploit reentrancy to manipulate the state of the contract, potentially draining funds or causing other unintended behavior.', 'Location': 'distributeMochi function, _buyMochi function, _shareMochi function'}, {'Issue': 'Lack of Reentrancy Protection', 'Severity': 'High', 'Description': 'The contract does not implement any reentrancy guards on functions that interact with external contracts, such as `_buyMochi` and `_shareMochi`. This could potentially allow an attacker to re-enter the contract and manipulate the state or funds.', 'Impact': 'Reentrancy attacks could lead to unexpected behavior or loss of funds.', 'Location': '_buyMochi function, _shareMochi function'}, {'Issue': 'Unrestricted Access to Critical Functions', 'Severity': 'High', 'Description': ""Functions such as `changecrvVoterRewardPool`, `changeTreasuryRatio`, and `changevMochiRatio` are only restricted to the `engine.governance()` address. If this address is compromised, an attacker could manipulate the contract's behavior, potentially leading to financial loss or disruption of the system."", 'Impact': 'An attacker could change critical parameters, leading to financial loss or system disruption.', 'Location': 'Functions: `changecrvVoterRewardPool`, `changeTreasuryRatio`, `changevMochiRatio`'}, {'Issue': 'Lack of Input Validation in `changecrvVoterRewardPool`, `changeTreasuryRatio`, and `changevMochiRatio` Functions', 'Severity': 'Medium', 'Description': 'The functions `changecrvVoterRewardPool`, `changeTreasuryRatio`, and `changevMochiRatio` do not validate the input parameters. This could lead to setting invalid or harmful values, such as zero addresses or ratios that exceed the expected range.', 'Impact': 'Invalid input values could disrupt the intended functionality of the contract, leading to incorrect distribution of funds or other operational issues.', 'Location': 'changecrvVoterRewardPool function, changeTreasuryRatio function, changevMochiRatio function'}, {'Issue': 'Potential Integer Overflow/Underflow in `updateReserve` Function', 'Severity': 'Medium', 'Description': ""The `updateReserve` function performs arithmetic operations on state variables without checking for potential overflow or underflow. Although Solidity 0.8.0 has built-in overflow checks, it's still good practice to ensure that such scenarios are handled explicitly."", 'Impact': 'An overflow or underflow could lead to incorrect calculations of `treasuryShare` and `mochiShare`, potentially causing funds to be misallocated.', 'Location': 'updateReserve function'}, {'Issue': 'Potential Front-Running in `distributeMochi`', 'Severity': 'Medium', 'Description': 'The `distributeMochi` function performs a swap on Uniswap and then distributes the tokens. This sequence of operations could be front-run by an attacker who could manipulate the price or the distribution amounts.', 'Impact': 'Front-running could lead to unfavorable swap rates or incorrect distribution amounts, potentially resulting in financial loss.', 'Location': 'Function `distributeMochi`'}, {'Issue': 'Lack of Event Emission for Critical State Changes', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical state changes such as updating the `crvVoterRewardPool`, `treasuryRatio`, or `vMochiRatio`. Emitting events is a good practice for transparency and allows off-chain monitoring of contract state changes.', 'Impact': 'Lack of event emission makes it harder to track and audit changes to the contract state, reducing transparency.', 'Location': 'changecrvVoterRewardPool function, changeTreasuryRatio function, changevMochiRatio function'}, {'Issue': 'Lack of Input Validation in Constructor', 'Severity': 'Low', 'Description': 'The constructor does not validate the input addresses `_engine` and `_uniswap`. If these addresses are set to zero or invalid addresses, it could lead to contract malfunction.', 'Impact': 'Setting invalid addresses could render the contract inoperable, requiring redeployment and potentially causing downtime or loss of funds.', 'Location': 'Constructor'}], 'IssueNumber': 10, 'OutputList': 9}",495.0040400028229,"### **Comparison of Issue Report and Response List**

---

#### **[H-02] FeePoolV0.sol#distributeMochi() will unexpectedly flush treasuryShare, causing the protocol fee cannot be properly accounted for and collected**

**Report Description**:  
The `distributeMochi()` function in `FeePoolV0.sol` calls `_buyMochi()` to convert `mochiShare` to Mochi tokens and `_shareMochi()` to distribute Mochi tokens to the vMochi Vault and veCRV Holders. However, the `_shareMochi()` function incorrectly resets both `mochiShare` and `treasuryShare` to `0`. This unexpected behavior prevents the protocol fee from being properly accounted for and collected, as `treasuryShare` is flushed prematurely.

**Match in Response List**:  
**No match found**. The response list does not address the issue of `treasuryShare` being incorrectly reset in the `_shareMochi()` function.

**Validation**:  
**Incorrect**. The response list does not identify or address this issue. The premature resetting of `treasuryShare` is a critical oversight that impacts the protocol's fee accounting and collection mechanism.

---

#### **[H-11] treasuryShare is Overwritten in FeePoolV0._shareMochi()**

**Report Description**:  
The `_shareMochi()` function in `FeePoolV0.sol` overwrites `treasuryShare` by resetting it to `0` along with `mochiShare`. This behavior is unexpected and problematic because `treasuryShare` should not be flushed when there are still `usdm` tokens in the contract. This issue disrupts the protocol's fee distribution mechanism.

**Match in Response List**:  
**No match found**. The response list does not address the issue of `treasuryShare` being overwritten in the `_shareMochi()` function.

**Validation**:  
**Incorrect**. The response list fails to identify or address this issue. The overwriting of `treasuryShare` is a significant flaw that affects the protocol's fee distribution logic.

---

#### **[H-12] FeePool is vulnerable to sandwich attack**

**Report Description**:  
The `distributeMochi()` function in `FeePoolV0.sol` is permissionless, allowing anyone to trigger it. This makes the contract vulnerable to a sandwich attack, where an attacker could use a flash loan to manipulate the price of Mochi tokens during the distribution process. This could result in the theft of funds from the pool.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running in `distributeMochi`""**.

**Validation**:  
**Partially Correct**. The response identifies the potential for front-running in the `distributeMochi` function, which is related to the sandwich attack vulnerability. However, the response does not explicitly mention the use of flash loans or the specific risk of fund theft, which are critical aspects of the issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-12] FeePool is vulnerable to sandwich attack**

**Missed Issues from Issue Report**:  
- **[H-02] FeePoolV0.sol#distributeMochi() will unexpectedly flush treasuryShare, causing the protocol fee cannot be properly accounted for and collected**  
- **[H-11] treasuryShare is Overwritten in FeePoolV0._shareMochi()**

---

### **Conclusion**  
The response list partially addresses one of the three issues in the issue report ([H-12]) but misses the other two critical issues ([H-02] and [H-11]). The missed issues involve significant flaws in the protocol's fee accounting and distribution mechanisms, which are not covered in the response list. Additionally, the response to [H-12] lacks sufficient detail to fully address the sandwich attack vulnerability. Overall, the response list has notable gaps in coverage and accuracy.","```
None.
```",0.0
ReferralFeePoolV0.sol,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IReferralFeePool.sol"";

contract ReferralFeePoolV0 is IReferralFeePool {
    IMochiEngine public immutable engine;
    IUniswapV2Router02 public immutable uniswapRouter;

    uint256 public rewards;

    mapping(address => uint256) public reward;

    constructor(address _engine, address _uniswap) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
    }

    function addReward(address _recipient) external override {
        uint256 newReward = engine.usdm().balanceOf(address(this)) - rewards;
        reward[_recipient] += newReward;
        rewards += newReward;
    }

    function claimRewardAsMochi() external {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = uniswapRouter.WETH();
        path[2] = address(engine.mochi());
        usdm.approve(address(uniswapRouter), reward[msg.sender]);
        // we are going to ingore the slippages here
        uniswapRouter.swapExactTokensForTokens(
            reward[msg.sender],
            1,
            path,
            address(this),
            type(uint256).max
        );
        engine.mochi().transfer(
            msg.sender,
            engine.mochi().balanceOf(address(this))
        );
    }
}",369,48,"[H-03] ReferralFeePoolV0.sol#claimRewardAsMochi() Array out of bound exception

Submitted by WatchPug, also found by pauliax
ReferralFeePoolV0.sol#L28 L42 ```
function claimRewardAsMochi() external {
    IUSDM usdm = engine.usdm();
    address[] memory path = new address[](2);
    path[0] = address(usdm);
    path[1] = uniswapRouter.WETH();
    path[2] = address(engine.mochi());
    usdm.approve(address(uniswapRouter), reward[msg.sender]);
    // we are going to ingore the slippages here
    uniswapRouter.swapExactTokensForTokens(
        reward[msg.sender],
        1,
        path,
        address(this),
        type(uint256).max
    );
```
In ReferralFeePoolV0.sol#claimRewardAsMochi(), path is defined as an array of length 2 while it should be length 3.
As a result, at L33, an out-of-bound exception will be thrown and revert the transaction.
 [H-06] Referrer can drain ReferralFeePoolV0

Submitted by gzeon
Impact

function `claimRewardAsMochi` in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.

[M-02] regerralFeePool is vulnerable to MEV searcher


`claimRewardAsMochi` in the ReferralFeePoolV0 ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to https://github.com/flashbots/pm.
Given the current state of the Ethereum network, users would likely be sandwiched. I consider this is a high-risk issue.
",3,,"pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IReferralFeePool.sol"";

contract ReferralFeePoolV0 is IReferralFeePool {
    IMochiEngine public immutable engine;
    IUniswapV2Router02 public immutable uniswapRouter;

    uint256 public rewards;

    mapping(address => uint256) public reward;

    constructor(address _engine, address _uniswap) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
    }

    function addReward(address _recipient) external override {
        uint256 newReward = engine.usdm().balanceOf(address(this)) - rewards;
        reward[_recipient] += newReward;
        rewards += newReward;
    }

    function claimRewardAsMochi() external {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = uniswapRouter.WETH();
        path[2] = address(engine.mochi());
        usdm.approve(address(uniswapRouter), reward[msg.sender]);
        
        uniswapRouter.swapExactTokensForTokens(
            reward[msg.sender],
            1,
            path,
            address(this),
            type(uint256).max
        );
        engine.mochi().transfer(
            msg.sender,
            engine.mochi().balanceOf(address(this))
        );
    }
}",344,2,1,,"{'ReviewingTheCode': 'The contract `ReferralFeePoolV0` is designed to manage and distribute referral rewards using the MochiEngine and UniswapV2Router02. It allows users to add rewards for recipients and claim rewards in the form of Mochi tokens.', 'IdentifyingKeyComponents': {'ContractName': 'ReferralFeePoolV0', 'Purpose': 'To manage referral rewards and allow users to claim these rewards in Mochi tokens.', 'InheritanceAndImports': {'InheritsFrom': ['IReferralFeePool'], 'Imports': ['@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol', '../interfaces/IMochiEngine.sol', '../interfaces/IReferralFeePool.sol']}, 'StateVariables': [{'Name': 'engine', 'Type': 'IMochiEngine', 'Purpose': 'Interface to interact with the MochiEngine contract.'}, {'Name': 'uniswapRouter', 'Type': 'IUniswapV2Router02', 'Purpose': 'Interface to interact with the UniswapV2Router02 contract.'}, {'Name': 'rewards', 'Type': 'uint256', 'Purpose': 'Total amount of rewards managed by the contract.'}, {'Name': 'reward', 'Type': 'mapping(address => uint256)', 'Purpose': 'Mapping of addresses to their respective reward amounts.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with the MochiEngine and UniswapV2Router02 addresses.', 'Parameters': ['address _engine', 'address _uniswap'], 'Returns': []}, {'Name': 'addReward', 'Visibility': 'external', 'Purpose': 'Adds a reward for a specified recipient.', 'Parameters': ['address _recipient'], 'Returns': []}, {'Name': 'claimRewardAsMochi', 'Visibility': 'external', 'Purpose': 'Allows a user to claim their reward in Mochi tokens by swapping USDM tokens via Uniswap.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['IMochiEngine: Used to interact with the MochiEngine contract.', 'IUniswapV2Router02: Used to interact with the UniswapV2Router02 contract for token swaps.', 'IUSDM: Interface for the USDM token, used in the `claimRewardAsMochi` function.'], 'SpecialMechanisms': ['The contract uses UniswapV2Router02 to swap USDM tokens for Mochi tokens, allowing users to claim their rewards in Mochi.'], 'Questions': ['How is the `newReward` calculated in the `addReward` function? It seems to subtract `rewards` from the balance of USDM, but is this the intended logic?', 'Is there a mechanism to prevent reentrancy attacks in the `claimRewardAsMochi` function?', 'What happens if the swap in `claimRewardAsMochi` fails? Is there a fallback mechanism?', 'How is the `path` array in `claimRewardAsMochi` intended to work with only two addresses? It seems to have three elements.']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `claimRewardAsMochi`', 'Severity': 'High', 'Description': 'The `claimRewardAsMochi` function makes an external call to `uniswapRouter.swapExactTokensForTokens` without following the checks-effects-interactions pattern, potentially allowing a reentrancy attack. Additionally, the function transfers tokens after the external call, which could be exploited if the token contract is malicious.', 'Impact': 'An attacker could drain the contract of its funds by repeatedly calling the function before the state is updated or exploit reentrancy during token transfer.', 'Location': 'claimRewardAsMochi function'}, {'Issue': 'Incorrect Path Length for Uniswap Swap', 'Severity': 'High', 'Description': 'The `path` array in `claimRewardAsMochi` is incorrectly initialized with a length of 2 but populated with 3 elements, causing out-of-bounds errors or unexpected behavior. This issue is also noted as using an incorrect path for a direct swap from USDM to Mochi.', 'Impact': 'The swap may fail or behave unexpectedly, potentially leading to loss of funds or failed transactions.', 'Location': 'claimRewardAsMochi function, line with path array initialization and assignment'}, {'Issue': 'High Slippage Risk in `claimRewardAsMochi` Function', 'Severity': 'High', 'Description': 'The `swapExactTokensForTokens` method is used with a minimum amount out parameter set to `1`, exposing the function to significant slippage risk. The function also lacks a mechanism to dynamically calculate or allow user-specified slippage tolerance.', 'Impact': 'Users may receive significantly fewer tokens than anticipated due to high slippage, leading to financial losses.', 'Location': 'claimRewardAsMochi function, line with `uniswapRouter.swapExactTokensForTokens`'}, {'Issue': 'Missing Access Control in `addReward` Function', 'Severity': 'High', 'Description': 'The `addReward` function lacks access control, allowing any external actor to manipulate rewards for any recipient. It also does not validate the `_recipient` address, which could lead to rewards being lost or misallocated.', 'Impact': 'Unauthorized users can manipulate reward distributions, leading to potential financial losses and abuse of the reward system.', 'Location': 'ReferralFeePoolV0.sol, function `addReward`'}, {'Issue': 'Incorrect Calculation of `newReward` in `addReward`', 'Severity': 'High', 'Description': 'The `newReward` calculation assumes the `rewards` variable accurately tracks total rewards distributed. If incorrect, this could lead to over-distribution or under-distribution of rewards.', 'Impact': 'Financial discrepancies and potential exploitation due to incorrect reward distribution.', 'Location': 'ReferralFeePoolV0.sol, function `addReward`'}, {'Issue': 'Unchecked External Call Return Values', 'Severity': 'High', 'Description': 'The `claimRewardAsMochi` function does not check the return value of `swapExactTokensForTokens`, leading to silent failures where the swap does not occur as expected.', 'Impact': 'Users may lose funds if the swap fails silently, and the contract state may become inconsistent.', 'Location': 'claimRewardAsMochi function, line with `uniswapRouter.swapExactTokensForTokens`'}, {'Issue': 'Potential Underflow in `addReward`', 'Severity': 'Medium', 'Description': 'The `newReward` calculation could underflow if `engine.usdm().balanceOf(address(this))` is less than `rewards`. While Solidity 0.8.0 has built-in checks, explicit handling is recommended.', 'Impact': 'Unexpected behavior or reverts, potentially disrupting the reward distribution mechanism.', 'Location': 'addReward function'}, {'Issue': 'Lack of ERC-20 Transfer Return Value Check', 'Severity': 'Medium', 'Description': 'The `claimRewardAsMochi` function transfers `mochi` tokens without checking the return value of the `transfer` function, potentially leading to silent failures.', 'Impact': 'Users may not receive their `mochi` tokens even if the function appears to execute successfully.', 'Location': 'claimRewardAsMochi function, line 42'}, {'Issue': 'Potential Reentrancy in `addReward` Function', 'Severity': 'Medium', 'Description': 'The `addReward` function updates state before external calls, but if the `usdm` token contract allows reentrancy, rewards could be incorrectly distributed.', 'Impact': 'Rewards could be incorrectly distributed, leading to potential loss of funds or unfair allocation.', 'Location': 'addReward function, line 25'}, {'Issue': 'Insufficient Approval for Uniswap Swap', 'Severity': 'Medium', 'Description': 'The `claimRewardAsMochi` function approves the Uniswap router to spend `usdm` tokens but does not check if the approval was successful.', 'Impact': 'Users may be unable to claim rewards if the approval process fails.', 'Location': 'claimRewardAsMochi function, line 36'}, {'Issue': 'Unnecessary or Excessive Approval', 'Severity': 'Medium', 'Description': 'The `approve` call in `claimRewardAsMochi` approves the entire reward amount for the Uniswap router, increasing the risk of over-spending if the router is compromised.', 'Impact': 'Increased risk of token theft or misuse if the Uniswap router is compromised.', 'Location': 'claimRewardAsMochi function, line with `usdm.approve`'}, {'Issue': 'Inefficient Storage Writes in `addReward`', 'Severity': 'Medium', 'Description': 'The `addReward` function performs two storage writes (`reward[_recipient] += newReward` and `rewards += newReward`), which could be optimized to save gas.', 'Impact': 'Increased gas costs for users interacting with the `addReward` function.', 'Location': 'addReward function'}, {'Issue': 'Inefficient Storage Access in `claimRewardAsMochi`', 'Severity': 'Medium', 'Description': 'The `claimRewardAsMochi` function accesses the `reward[msg.sender]` storage variable multiple times, which could be cached in memory to reduce gas usage.', 'Impact': 'Increased gas costs for users claiming rewards.', 'Location': 'claimRewardAsMochi function'}, {'Issue': 'No Event Emission for Reward Distribution', 'Severity': 'Low', 'Description': 'The `addReward` function updates the reward mapping but does not emit an event, reducing transparency and auditability.', 'Impact': 'Lack of transparency in reward distribution, making it harder to track allocations.', 'Location': 'addReward function, line 25'}, {'Issue': 'Unnecessary Path Array Size in `claimRewardAsMochi`', 'Severity': 'Low', 'Description': 'The `path` array is initialized with a size of 2 but used with 3 elements, which can lead to confusion or potential out-of-bounds errors.', 'Impact': 'Potential for runtime errors or unexpected behavior.', 'Location': 'claimRewardAsMochi function'}], 'IssueNumber': 35, 'OutputList': 15}",321.02035903930664,"### **[H-03] ReferralFeePoolV0.sol#claimRewardAsMochi() Array out of bound exception**

**Report Description**:
In the `claimRewardAsMochi` function of `ReferralFeePoolV0.sol`, the `path` array is initialized with a length of 2 but is populated with 3 elements. This results in an out-of-bounds exception when attempting to assign the third element, causing the transaction to revert. This issue is critical as it prevents the function from executing correctly, potentially leading to failed transactions and loss of functionality.

**Match in Response List**:
Matches with the issue titled **""Incorrect Path Length for Uniswap Swap""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the incorrect initialization of the `path` array. It correctly explains the potential for out-of-bounds errors and the impact on the function's execution, which aligns with the reported issue.

---

### **[H-06] Referrer can drain ReferralFeePoolV0**

**Report Description**:
The `claimRewardAsMochi` function in `ReferralFeePoolV0.sol` does not reduce the user's reward balance after claiming rewards. This oversight allows a referrer to repeatedly claim the same reward, potentially draining the fee pool. This is a high-severity issue as it can lead to significant financial losses.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address the issue of the reward balance not being reduced after claiming, which is a critical vulnerability allowing for the draining of the fee pool.

---

### **[M-02] ReferralFeePoolV0 is vulnerable to MEV searcher**

**Report Description**:
The `claimRewardAsMochi` function in `ReferralFeePoolV0.sol` ignores slippage control, setting the minimum amount out to `1`. This makes the function vulnerable to MEV (Miner Extractable Value) searchers, who can exploit the lack of slippage control to sandwich users, resulting in significant financial losses. This is a medium-severity issue due to the potential for user losses in a high-MEV environment.

**Match in Response List**:
Matches with the issue titled **""High Slippage Risk in `claimRewardAsMochi` Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue of high slippage risk in the `claimRewardAsMochi` function. It correctly explains the potential for financial losses due to the lack of slippage control, which aligns with the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-03] ReferralFeePoolV0.sol#claimRewardAsMochi() Array out of bound exception**
- **[M-02] ReferralFeePoolV0 is vulnerable to MEV searcher**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-06] Referrer can drain ReferralFeePoolV0**

---","```
1. Incorrect Path Length for Uniswap Swap
2. High Slippage Risk in `claimRewardAsMochi` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Incorrect Path Length for Uniswap Swap** appears at rank 2.
   - **High Slippage Risk in `claimRewardAsMochi` Function** appears at rank 3.

2. **Calculate the precision at each rank**:
   - At rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - At rank 3: \( P@3 = \frac{2}{3} \approx 0.6667 \)

3. **Average the precision values**:
   - \( AP = \frac{0.5 + 0.6667}{2} = \frac{1.1667}{2} \approx 0.5833 \)

**Average Precision (AP)**: 0.5833"
MochiProfileV0.sol,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""../interfaces/IMochiProfile.sol"";
import ""../interfaces/IMochiEngine.sol"";

///@notice this is where policies including some math is registered will be able to swap the profile when current profile is not suitable
///@dev this profile is built with https://docs.google.com/spreadsheets/d/1T2WKpwj5QmueR7O8R9AXNbnHLc-rJ_-8DLdRI2eJZqA
contract MochiProfileV0 is IMochiProfile {
    using Float for float;
    using Float for uint256;
    IMochiEngine public immutable engine;

    uint256 public override liquidityRequirement;

    uint256 public override minimumDebt;

    mapping(address => AssetClass) internal _assetClass;

    mapping(address => uint256) public override creditCap;

    uint256 public immutable secPerYear;

    uint256 public override delay;

    constructor(address _engine) {
        secPerYear = 31536000;
        engine = IMochiEngine(_engine);

        liquidityRequirement = 1000000e18; // 1million dollar
        minimumDebt = 1000e18;
        delay = 3 minutes;
    }

    modifier onlyGov() {
        require(msg.sender == engine.governance(), ""!gov"");
        _;
    }

    function assetClass(address _asset)
        public
        view
        override
        returns (AssetClass)
    {
        return _assetClass[_asset];
    }

    function changeLiquidityRequirement(uint256 _requirement)
        external
        override
        onlyGov
    {
        liquidityRequirement = _requirement;
    }

    function registerAsset(address _asset) external {
        uint256 liq = engine.cssr().getLiquidity(_asset);
        require(liq >= liquidityRequirement, ""<liquidity"");
        _register(_asset, AssetClass.Sigma);
    }

    function registerAssetByGov(
        address[] calldata _asset,
        AssetClass[] calldata _classes
    ) external onlyGov {
        for (uint256 i = 0; i < _asset.length; i++) {
            _register(_asset[i], _classes[i]);
            engine.vaultFactory().deployVault(_asset[i]);
        }
    }

    function _register(address _asset, AssetClass _class) internal {
        _assetClass[_asset] = _class;
    }

    function changeMinimumDebt(uint256 _debt) external override onlyGov {
        minimumDebt = _debt;
    }

    function changeAssetClass(
        address[] calldata _assets,
        AssetClass[] calldata _classes
    ) external override onlyGov {
        for (uint256 i = 0; i < _assets.length; i++) {
            _assetClass[_assets[i]] = _classes[i];
        }
    }

    function changeCreditCap(
        address[] calldata _assets,
        uint256[] calldata _caps
    ) external onlyGov {
        for (uint256 i = 0; i < _assets.length; i++) {
            creditCap[_assets[i]] = _caps[i];
        }
    }

    function setDelay(uint256 _delay) external onlyGov {
        delay = _delay;
    }

    ///@notice The Collateral Factor at which the users vault will be liquidated
    function liquidationFactor(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 95, denominator: 100});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 85, denominator: 100});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 80, denominator: 100});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 75, denominator: 100});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 65, denominator: 100});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 40, denominator: 100});
        } else {
            revert(""invalid"");
        }
    }

    function riskFactor(address _asset) public view returns (uint256) {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return 1;
        } else if (class == AssetClass.Alpha) {
            return 2;
        } else if (class == AssetClass.Gamma) {
            return 3;
        } else if (class == AssetClass.Delta) {
            return 4;
        } else if (class == AssetClass.Zeta) {
            return 5;
        } else if (class == AssetClass.Sigma) {
            return 6;
        } else {
            revert(""invalid"");
        }
    }

    function maxCollateralFactor(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 90, denominator: 100});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 80, denominator: 100});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 75, denominator: 100});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 65, denominator: 100});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 55, denominator: 100});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 45, denominator: 100});
        } else {
            revert(""invalid"");
        }
    }

    function baseFee() public pure returns (float memory) {
        return float({numerator: 5, denominator: 1000});
    }

    function liquidationFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 45, denominator: 1000});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 100, denominator: 1000});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 125, denominator: 1000});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 150, denominator: 1000});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 175, denominator: 1000});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 200, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function keeperFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 5, denominator: 1000});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 10, denominator: 1000});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 15, denominator: 1000});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 20, denominator: 1000});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 25, denominator: 1000});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 30, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function maxFee(AssetClass _class) public pure returns (float memory) {
        if (_class == AssetClass.Stable) {
            return float({numerator: 10, denominator: 1000});
        } else if (_class == AssetClass.Alpha) {
            return float({numerator: 15, denominator: 1000});
        } else if (_class == AssetClass.Gamma) {
            return float({numerator: 20, denominator: 1000});
        } else if (_class == AssetClass.Delta) {
            return float({numerator: 21, denominator: 1000});
        } else if (_class == AssetClass.Zeta) {
            return float({numerator: 22, denominator: 1000});
        } else if (_class == AssetClass.Sigma) {
            return float({numerator: 23, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function stabilityFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        float memory base = baseFee();
        AssetClass class = assetClass(_asset);
        float memory max = maxFee(class);
        float memory u = utilizationRatio(_asset);
        if (u.gt(float({numerator: 1, denominator: 1}))) {
            return max;
        }
        return base.add(max.sub(base).mul(u));
    }

    function calculateFeeIndex(
        address _asset,
        uint256 _currentIndex,
        uint256 _lastAccrued
    ) external view override returns (uint256) {
        float memory feePerYear = stabilityFee(_asset);
        uint256 timePassed = block.timestamp - _lastAccrued;
        float memory feeAccumulated = feePerYear.mul(
            float({numerator: timePassed, denominator: secPerYear})
        );
        return _currentIndex + _currentIndex.multiply(feeAccumulated);
    }

    ///@dev returns utilization ratio scaled with 1e18
    function utilizationRatio(address _asset)
        public
        view
        override
        returns (float memory ratio)
    {
        IMochiVault vault = engine.vaultFactory().getVault(_asset);
        uint256 debts = vault.debts();
        uint256 cap = creditCap[_asset];
        return float({numerator: debts, denominator: cap});
    }
}

",2270,285,"[H-04] registerAsset() can overwrite _assetClass value

Submitted by gpersoon, also found by jonah1005 and leastwood
Impact

Everyone can call the function `registerAsset()` of MochiProfileV0.sol Assuming the liquidity for the asset is sufficient, `registerAsset()` will reset the _assetClass of an already registered asset to AssetClass.Sigma.
When the _assetClass is changed to AssetClass.Sigma then liquidationFactor(), riskFactor(), maxCollateralFactor(), liquidationFee() keeperFee() maxFee() will also return a different value. Then the entire vault will behave differently. The threshold for liquidation will also be different, possibly leading to a liquidation that isn't supposed to happen.
 ",1,,"pragma solidity ^0.8.0;

import ""../interfaces/IMochiProfile.sol"";
import ""../interfaces/IMochiEngine.sol"";



contract MochiProfileV0 is IMochiProfile {
    using Float for float;
    using Float for uint256;
    IMochiEngine public immutable engine;

    uint256 public override liquidityRequirement;

    uint256 public override minimumDebt;

    mapping(address => AssetClass) internal _assetClass;

    mapping(address => uint256) public override creditCap;

    uint256 public immutable secPerYear;

    uint256 public override delay;

    constructor(address _engine) {
        secPerYear = 31536000;
        engine = IMochiEngine(_engine);

        liquidityRequirement = 1000000e18; 
        minimumDebt = 1000e18;
        delay = 3 minutes;
    }

    modifier onlyGov() {
        require(msg.sender == engine.governance(), ""!gov"");
        _;
    }

    function assetClass(address _asset)
        public
        view
        override
        returns (AssetClass)
    {
        return _assetClass[_asset];
    }

    function changeLiquidityRequirement(uint256 _requirement)
        external
        override
        onlyGov
    {
        liquidityRequirement = _requirement;
    }

    function registerAsset(address _asset) external {
        uint256 liq = engine.cssr().getLiquidity(_asset);
        require(liq >= liquidityRequirement, ""<liquidity"");
        _register(_asset, AssetClass.Sigma);
    }

    function registerAssetByGov(
        address[] calldata _asset,
        AssetClass[] calldata _classes
    ) external onlyGov {
        for (uint256 i = 0; i < _asset.length; i++) {
            _register(_asset[i], _classes[i]);
            engine.vaultFactory().deployVault(_asset[i]);
        }
    }

    function _register(address _asset, AssetClass _class) internal {
        _assetClass[_asset] = _class;
    }

    function changeMinimumDebt(uint256 _debt) external override onlyGov {
        minimumDebt = _debt;
    }

    function changeAssetClass(
        address[] calldata _assets,
        AssetClass[] calldata _classes
    ) external override onlyGov {
        for (uint256 i = 0; i < _assets.length; i++) {
            _assetClass[_assets[i]] = _classes[i];
        }
    }

    function changeCreditCap(
        address[] calldata _assets,
        uint256[] calldata _caps
    ) external onlyGov {
        for (uint256 i = 0; i < _assets.length; i++) {
            creditCap[_assets[i]] = _caps[i];
        }
    }

    function setDelay(uint256 _delay) external onlyGov {
        delay = _delay;
    }

    
    function liquidationFactor(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 95, denominator: 100});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 85, denominator: 100});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 80, denominator: 100});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 75, denominator: 100});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 65, denominator: 100});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 40, denominator: 100});
        } else {
            revert(""invalid"");
        }
    }

    function riskFactor(address _asset) public view returns (uint256) {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return 1;
        } else if (class == AssetClass.Alpha) {
            return 2;
        } else if (class == AssetClass.Gamma) {
            return 3;
        } else if (class == AssetClass.Delta) {
            return 4;
        } else if (class == AssetClass.Zeta) {
            return 5;
        } else if (class == AssetClass.Sigma) {
            return 6;
        } else {
            revert(""invalid"");
        }
    }

    function maxCollateralFactor(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 90, denominator: 100});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 80, denominator: 100});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 75, denominator: 100});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 65, denominator: 100});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 55, denominator: 100});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 45, denominator: 100});
        } else {
            revert(""invalid"");
        }
    }

    function baseFee() public pure returns (float memory) {
        return float({numerator: 5, denominator: 1000});
    }

    function liquidationFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 45, denominator: 1000});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 100, denominator: 1000});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 125, denominator: 1000});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 150, denominator: 1000});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 175, denominator: 1000});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 200, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function keeperFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        AssetClass class = assetClass(_asset);
        if (class == AssetClass.Stable) {
            return float({numerator: 5, denominator: 1000});
        } else if (class == AssetClass.Alpha) {
            return float({numerator: 10, denominator: 1000});
        } else if (class == AssetClass.Gamma) {
            return float({numerator: 15, denominator: 1000});
        } else if (class == AssetClass.Delta) {
            return float({numerator: 20, denominator: 1000});
        } else if (class == AssetClass.Zeta) {
            return float({numerator: 25, denominator: 1000});
        } else if (class == AssetClass.Sigma) {
            return float({numerator: 30, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function maxFee(AssetClass _class) public pure returns (float memory) {
        if (_class == AssetClass.Stable) {
            return float({numerator: 10, denominator: 1000});
        } else if (_class == AssetClass.Alpha) {
            return float({numerator: 15, denominator: 1000});
        } else if (_class == AssetClass.Gamma) {
            return float({numerator: 20, denominator: 1000});
        } else if (_class == AssetClass.Delta) {
            return float({numerator: 21, denominator: 1000});
        } else if (_class == AssetClass.Zeta) {
            return float({numerator: 22, denominator: 1000});
        } else if (_class == AssetClass.Sigma) {
            return float({numerator: 23, denominator: 1000});
        } else {
            revert(""invalid"");
        }
    }

    function stabilityFee(address _asset)
        public
        view
        override
        returns (float memory)
    {
        float memory base = baseFee();
        AssetClass class = assetClass(_asset);
        float memory max = maxFee(class);
        float memory u = utilizationRatio(_asset);
        if (u.gt(float({numerator: 1, denominator: 1}))) {
            return max;
        }
        return base.add(max.sub(base).mul(u));
    }

    function calculateFeeIndex(
        address _asset,
        uint256 _currentIndex,
        uint256 _lastAccrued
    ) external view override returns (uint256) {
        float memory feePerYear = stabilityFee(_asset);
        uint256 timePassed = block.timestamp - _lastAccrued;
        float memory feeAccumulated = feePerYear.mul(
            float({numerator: timePassed, denominator: secPerYear})
        );
        return _currentIndex + _currentIndex.multiply(feeAccumulated);
    }

    
    function utilizationRatio(address _asset)
        public
        view
        override
        returns (float memory ratio)
    {
        IMochiVault vault = engine.vaultFactory().getVault(_asset);
        uint256 debts = vault.debts();
        uint256 cap = creditCap[_asset];
        return float({numerator: debts, denominator: cap});
    }
}",2146,1,0,,"{'ReviewingTheCode': 'The provided code is a Solidity smart contract named MochiProfileV0, which implements the IMochiProfile interface. It manages asset profiles, including liquidity requirements, credit caps, and risk factors. The contract interacts with an external MochiEngine contract to fetch necessary data and perform operations like deploying vaults. The contract uses various modifiers to restrict access to governance-only functions.', 'IdentifyingKeyComponents': {'ContractName': 'MochiProfileV0', 'Purpose': 'To manage asset profiles, including liquidity requirements, credit caps, and risk factors, and to interact with the MochiEngine for additional operations.', 'InheritanceAndImports': {'InheritsFrom': ['IMochiProfile'], 'Imports': ['IMochiProfile.sol', 'IMochiEngine.sol']}, 'StateVariables': [{'Name': 'engine', 'Type': 'IMochiEngine', 'Purpose': 'Immutable reference to the MochiEngine contract.'}, {'Name': 'liquidityRequirement', 'Type': 'uint256', 'Purpose': 'Minimum liquidity requirement for registering an asset.'}, {'Name': 'minimumDebt', 'Type': 'uint256', 'Purpose': 'Minimum debt threshold for certain operations.'}, {'Name': '_assetClass', 'Type': 'mapping(address => AssetClass)', 'Purpose': 'Mapping to store the asset class for each asset.'}, {'Name': 'creditCap', 'Type': 'mapping(address => uint256)', 'Purpose': 'Mapping to store the credit cap for each asset.'}, {'Name': 'secPerYear', 'Type': 'uint256', 'Purpose': 'Number of seconds in a year, used for fee calculations.'}, {'Name': 'delay', 'Type': 'uint256', 'Purpose': 'Delay parameter used in the contract.'}], 'FunctionsAndModifiers': [{'Name': 'onlyGov', 'Visibility': 'modifier', 'Purpose': 'Restricts access to governance-only functions.', 'Parameters': [], 'Returns': []}, {'Name': 'assetClass', 'Visibility': 'public', 'Purpose': 'Returns the asset class of a given asset.', 'Parameters': ['address _asset'], 'Returns': ['AssetClass']}, {'Name': 'changeLiquidityRequirement', 'Visibility': 'external', 'Purpose': 'Changes the liquidity requirement for registering an asset.', 'Parameters': ['uint256 _requirement'], 'Returns': []}, {'Name': 'registerAsset', 'Visibility': 'external', 'Purpose': 'Registers an asset if it meets the liquidity requirement.', 'Parameters': ['address _asset'], 'Returns': []}, {'Name': 'registerAssetByGov', 'Visibility': 'external', 'Purpose': 'Registers multiple assets and deploys vaults for them.', 'Parameters': ['address[] calldata _asset', 'AssetClass[] calldata _classes'], 'Returns': []}, {'Name': '_register', 'Visibility': 'internal', 'Purpose': 'Internal function to register an asset with a specific class.', 'Parameters': ['address _asset', 'AssetClass _class'], 'Returns': []}, {'Name': 'changeMinimumDebt', 'Visibility': 'external', 'Purpose': 'Changes the minimum debt threshold.', 'Parameters': ['uint256 _debt'], 'Returns': []}, {'Name': 'changeAssetClass', 'Visibility': 'external', 'Purpose': 'Changes the asset class for multiple assets.', 'Parameters': ['address[] calldata _assets', 'AssetClass[] calldata _classes'], 'Returns': []}, {'Name': 'changeCreditCap', 'Visibility': 'external', 'Purpose': 'Changes the credit cap for multiple assets.', 'Parameters': ['address[] calldata _assets', 'uint256[] calldata _caps'], 'Returns': []}, {'Name': 'setDelay', 'Visibility': 'external', 'Purpose': 'Sets the delay parameter.', 'Parameters': ['uint256 _delay'], 'Returns': []}, {'Name': 'liquidationFactor', 'Visibility': 'public', 'Purpose': 'Returns the liquidation factor for a given asset.', 'Parameters': ['address _asset'], 'Returns': ['float memory']}, {'Name': 'riskFactor', 'Visibility': 'public', 'Purpose': 'Returns the risk factor for a given asset.', 'Parameters': ['address _asset'], 'Returns': ['uint256']}, {'Name': 'maxCollateralFactor', 'Visibility': 'public', 'Purpose': 'Returns the maximum collateral factor for a given asset.', 'Parameters': ['address _asset'], 'Returns': ['float memory']}, {'Name': 'baseFee', 'Visibility': 'public', 'Purpose': 'Returns the base fee.', 'Parameters': [], 'Returns': ['float memory']}, {'Name': 'liquidationFee', 'Visibility': 'public', 'Purpose': 'Returns the liquidation fee for a given asset.', 'Parameters': ['address _asset'], 'Returns': ['float memory']}, {'Name': 'keeperFee', 'Visibility': 'public', 'Purpose': 'Returns the keeper fee for a given asset.', 'Parameters': ['address _asset'], 'Returns': ['float memory']}, {'Name': 'maxFee', 'Visibility': 'public', 'Purpose': 'Returns the maximum fee for a given asset class.', 'Parameters': ['AssetClass _class'], 'Returns': ['float memory']}, {'Name': 'stabilityFee', 'Visibility': 'public', 'Purpose': 'Returns the stability fee for a given asset.', 'Parameters': ['address _asset'], 'Returns': ['float memory']}, {'Name': 'calculateFeeIndex', 'Visibility': 'external', 'Purpose': 'Calculates the fee index for a given asset.', 'Parameters': ['address _asset', 'uint256 _currentIndex', 'uint256 _lastAccrued'], 'Returns': ['uint256']}, {'Name': 'utilizationRatio', 'Visibility': 'public', 'Purpose': 'Returns the utilization ratio for a given asset.', 'Parameters': ['address _asset'], 'Returns': ['float memory']}]}, 'ExternalInteractions': ['IMochiEngine: Used to interact with the MochiEngine contract for governance, vault deployment, and liquidity checks.', 'IMochiVault: Used to interact with vaults for debt and utilization ratio calculations.'], 'SpecialMechanisms': ['Governance Modifier: Restricts certain functions to be called only by the governance address.', 'Fee Calculation: Implements complex fee calculations based on asset class and utilization ratio.', 'Vault Deployment: Automatically deploys vaults for registered assets.'], 'Questions': [""What is the exact purpose of the 'delay' variable and how is it used in the contract?"", ""Are there any specific security considerations for the 'onlyGov' modifier, such as potential governance attacks?"", ""How is the 'Float' library used in the contract, and what are its functionalities?"", 'What are the potential risks associated with the automatic deployment of vaults for registered assets?']}","{'Findings': [{'Issue': 'Reentrancy Risk in `registerAssetByGov` Function', 'Severity': 'High', 'Description': 'The `registerAssetByGov` function calls `engine.vaultFactory().deployVault(_asset[i])` within a loop. If `deployVault` involves external calls, it could potentially lead to reentrancy attacks.', 'Impact': 'Reentrancy attacks could manipulate the state of the contract, leading to loss of funds or other malicious activities.', 'Location': 'function registerAssetByGov(address[] calldata _asset, AssetClass[] calldata _classes)'}, {'Issue': 'Potential Integer Overflow in `calculateFeeIndex` Function', 'Severity': 'High', 'Description': 'The `calculateFeeIndex` function performs arithmetic operations without checking for potential integer overflow, especially when multiplying `_currentIndex` with `feeAccumulated`.', 'Impact': 'Integer overflow could lead to incorrect fee calculations, potentially affecting the financial integrity of the system.', 'Location': 'function calculateFeeIndex(address _asset, uint256 _currentIndex, uint256 _lastAccrued)'}, {'Issue': 'Division by Zero Risk in `utilizationRatio` Function', 'Severity': 'High', 'Description': 'The `utilizationRatio` function calculates the ratio of debts to credit cap without checking if the credit cap is zero, which could lead to a division by zero error.', 'Impact': ""Division by zero could cause the function to revert, potentially disrupting the system's operations."", 'Location': 'function utilizationRatio(address _asset)'}, {'Issue': 'Lack of Input Validation in `registerAssetByGov` Function', 'Severity': 'Medium', 'Description': 'The `registerAssetByGov` function does not validate the lengths of the `_asset` and `_classes` arrays. If these arrays have different lengths, it could lead to unexpected behavior or runtime errors.', 'Impact': 'Potential runtime errors or unintended behavior when registering assets with mismatched arrays.', 'Location': 'function registerAssetByGov(address[] calldata _asset, AssetClass[] calldata _classes)'}, {'Issue': 'Unrestricted Asset Registration in `registerAsset` Function', 'Severity': 'Medium', 'Description': 'The `registerAsset` function allows any user to register an asset without proper validation or authorization, potentially leading to unauthorized asset registration.', 'Impact': 'Unauthorized asset registration could lead to misuse or exploitation of the system.', 'Location': 'function registerAsset(address _asset)'}, {'Issue': 'Unbounded Loops in `registerAssetByGov`, `changeAssetClass`, and `changeCreditCap` Functions', 'Severity': 'Medium', 'Description': 'The functions `registerAssetByGov`, `changeAssetClass`, and `changeCreditCap` iterate over arrays of assets and classes/caps. If these arrays are too large, it could lead to excessive gas consumption or even out-of-gas errors.', 'Impact': 'High gas consumption, potential denial of service (DoS) due to out-of-gas errors.', 'Location': 'Functions: `registerAssetByGov`, `changeAssetClass`, `changeCreditCap`'}, {'Issue': 'Insufficient Access Control in `changeCreditCap` Function', 'Severity': 'Medium', 'Description': 'The `changeCreditCap` function is only restricted by the `onlyGov` modifier, but it does not validate the input arrays `_assets` and `_caps`. This could lead to unintended changes if the arrays are not properly managed.', 'Impact': 'Potential unintended changes to credit caps due to lack of input validation.', 'Location': 'function changeCreditCap(address[] calldata _assets, uint256[] calldata _caps)'}, {'Issue': 'Lack of Event Emission for State Changes', 'Severity': 'Low', 'Description': 'The contract does not emit events for state-changing functions such as `changeLiquidityRequirement`, `changeMinimumDebt`, and `changeAssetClass`. This makes it difficult to track changes and could lead to transparency issues.', 'Impact': 'Reduced transparency and difficulty in tracking state changes.', 'Location': 'Functions: `changeLiquidityRequirement`, `changeMinimumDebt`, `changeAssetClass`'}, {'Issue': 'Hardcoded Values in Constructor', 'Severity': 'Low', 'Description': 'The constructor initializes `liquidityRequirement`, `minimumDebt`, and `delay` with hardcoded values. This reduces flexibility and may require contract redeployment if these values need to be changed.', 'Impact': 'Reduced flexibility and potential need for contract redeployment if initial values need to be adjusted.', 'Location': 'Constructor'}, {'Issue': 'Insufficient Error Handling in `_register` Function', 'Severity': 'Low', 'Description': 'The `_register` function does not handle the case where an asset might already be registered, potentially leading to overwriting existing asset classes without proper checks.', 'Impact': ""Overwriting existing asset classes could lead to inconsistencies in the system's asset management."", 'Location': 'function _register(address _asset, AssetClass _class)'}], 'IssueNumber': 10, 'OutputList': 10}",588.4092748165131,"---

**[H-04] registerAsset() can overwrite _assetClass value**

**Report Description**:
The `registerAsset()` function in `MochiProfileV0.sol` allows any user to call it, assuming the liquidity for the asset is sufficient. This function resets the `_assetClass` of an already registered asset to `AssetClass.Sigma`. Changing the `_assetClass` affects multiple functions such as `liquidationFactor()`, `riskFactor()`, `maxCollateralFactor()`, `liquidationFee()`, `keeperFee()`, and `maxFee()`, leading to different behavior in the vault. This could result in unintended liquidations or other operational discrepancies.

**Match in Response List**:
Matches with the issue titled **""Unrestricted Asset Registration in `registerAsset` Function""**.

**Validation**:
**Partially Correct**. The response correctly identifies the issue of unrestricted asset registration in the `registerAsset` function, which aligns with the reported vulnerability. However, the response does not address the critical detail that this unrestricted registration can overwrite the `_assetClass` value, leading to significant changes in the vault's behavior. This omission makes the response partially correct, as it misses the core impact of the vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-04] registerAsset() can overwrite _assetClass value**

**Missed Issues from Issue Report**:
- *None*

---","```
None.
```",0.0
MochiTreasuryV0.sol,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/ICurveVotingEscrow.sol"";

contract MochiTreasuryV0 {
    IMochiEngine public immutable engine;

    IUniswapV2Router02 public immutable uniswapRouter;

    IERC20 public immutable crv;
    ICurveVotingEscrow public immutable veCrv;
    bool public lockCrv;
    uint256 public operationShare;
    uint256 public veCRVShare;

    constructor(
        address _engine,
        address _uniswap,
        address _crv,
        address _veCrv
    ) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
        crv = IERC20(_crv);
        veCrv = ICurveVotingEscrow(_veCrv);
        lockCrv = false;
    }

    receive() external payable {}

    function withdrawCRV() external {
        require(msg.sender == engine.governance(), ""!gov"");
        crv.transfer(msg.sender, crv.balanceOf(address(this)));
    }

    function withdrawLock() external {
        veCrv.withdraw();
    }

    function veCRVInitialize() external {
        require(lockCrv, ""!lock"");
        updateFee();
        _buyCRV();
        veCrv.create_lock(
            crv.balanceOf(address(this)),
            block.timestamp + 90 days
        );
    }

    function toggleLocking() external {
        require(msg.sender == engine.governance(), ""!gov"");
        lockCrv = !lockCrv;
    }

    function updateFee() public {
        uint256 updatedFee = engine.usdm().balanceOf(address(this)) -
            operationShare -
            veCRVShare;
        operationShare += updatedFee / 2;
        veCRVShare += updatedFee / 2;
    }

    function claimOperationCost() external {
        updateFee();
        engine.usdm().transfer(engine.operationWallet(), operationShare);
        operationShare = 0;
    }

    function veCRVlock() external {
        require(lockCrv, ""!lock"");
        updateFee();
        _buyCRV();
        _lockCRV();
        veCRVShare = 0;
    }

    function _buyCRV() internal {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = address(crv);
        usdm.approve(address(uniswapRouter), veCRVShare);
        uniswapRouter.swapExactTokensForTokens(
            veCRVShare,
            1,
            path,
            address(this),
            type(uint256).max
        );
    }

    function _lockCRV() internal {
        crv.approve(address(veCrv), crv.balanceOf(address(this)));
        veCrv.increase_amount(crv.balanceOf(address(this)));
        veCrv.increase_unlock_time(block.timestamp + 90 days);
    }
}",688,101,"[H-09] treasury is vulnerable to sandwich attack

There's a permissionless function `veCRVlock` in `MochiTreasury`. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds. MochiTreasuryV0.sol#L73-L94
Attackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.
 [M-14] MochiTreasuryV0.withdrawLock() Is Callable When Locking Has Been Toggled

`withdrawLock()` does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.

",2,,"pragma solidity ^0.8.0;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/ICurveVotingEscrow.sol"";

contract MochiTreasuryV0 {
    IMochiEngine public immutable engine;

    IUniswapV2Router02 public immutable uniswapRouter;

    IERC20 public immutable crv;
    ICurveVotingEscrow public immutable veCrv;
    bool public lockCrv;
    uint256 public operationShare;
    uint256 public veCRVShare;

    constructor(
        address _engine,
        address _uniswap,
        address _crv,
        address _veCrv
    ) {
        engine = IMochiEngine(_engine);
        uniswapRouter = IUniswapV2Router02(_uniswap);
        crv = IERC20(_crv);
        veCrv = ICurveVotingEscrow(_veCrv);
        lockCrv = false;
    }

    receive() external payable {}

    function withdrawCRV() external {
        require(msg.sender == engine.governance(), ""!gov"");
        crv.transfer(msg.sender, crv.balanceOf(address(this)));
    }

    function withdrawLock() external {
        veCrv.withdraw();
    }

    function veCRVInitialize() external {
        require(lockCrv, ""!lock"");
        updateFee();
        _buyCRV();
        veCrv.create_lock(
            crv.balanceOf(address(this)),
            block.timestamp + 90 days
        );
    }

    function toggleLocking() external {
        require(msg.sender == engine.governance(), ""!gov"");
        lockCrv = !lockCrv;
    }

    function updateFee() public {
        uint256 updatedFee = engine.usdm().balanceOf(address(this)) -
            operationShare -
            veCRVShare;
        operationShare += updatedFee / 2;
        veCRVShare += updatedFee / 2;
    }

    function claimOperationCost() external {
        updateFee();
        engine.usdm().transfer(engine.operationWallet(), operationShare);
        operationShare = 0;
    }

    function veCRVlock() external {
        require(lockCrv, ""!lock"");
        updateFee();
        _buyCRV();
        _lockCRV();
        veCRVShare = 0;
    }

    function _buyCRV() internal {
        IUSDM usdm = engine.usdm();
        address[] memory path = new address[](2);
        path[0] = address(usdm);
        path[1] = address(crv);
        usdm.approve(address(uniswapRouter), veCRVShare);
        uniswapRouter.swapExactTokensForTokens(
            veCRVShare,
            1,
            path,
            address(this),
            type(uint256).max
        );
    }

    function _lockCRV() internal {
        crv.approve(address(veCrv), crv.balanceOf(address(this)));
        veCrv.increase_amount(crv.balanceOf(address(this)));
        veCrv.increase_unlock_time(block.timestamp + 90 days);
    }
}",676,1,1,,"{'ReviewingTheCode': ""The contract 'MochiTreasuryV0' appears to manage treasury operations for a protocol, including CRV token handling, locking mechanisms, and fee distribution. It interacts with external contracts like Uniswap, MochiEngine, and Curve Voting Escrow."", 'IdentifyingKeyComponents': {'ContractName': 'MochiTreasuryV0', 'Purpose': 'Manages treasury operations, including CRV token handling, locking, and fee distribution.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol', '../interfaces/IMochiEngine.sol', '../interfaces/ICurveVotingEscrow.sol']}, 'StateVariables': [{'Name': 'engine', 'Type': 'IMochiEngine', 'Purpose': 'Interface to interact with the MochiEngine contract.'}, {'Name': 'uniswapRouter', 'Type': 'IUniswapV2Router02', 'Purpose': 'Interface to interact with the Uniswap V2 Router.'}, {'Name': 'crv', 'Type': 'IERC20', 'Purpose': 'CRV token contract interface.'}, {'Name': 'veCrv', 'Type': 'ICurveVotingEscrow', 'Purpose': 'Interface to interact with the Curve Voting Escrow contract.'}, {'Name': 'lockCrv', 'Type': 'bool', 'Purpose': 'Flag to indicate if CRV locking is enabled.'}, {'Name': 'operationShare', 'Type': 'uint256', 'Purpose': 'Share of fees allocated for operational costs.'}, {'Name': 'veCRVShare', 'Type': 'uint256', 'Purpose': 'Share of fees allocated for veCRV locking.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with addresses for engine, Uniswap router, CRV token, and veCRV contract.', 'Parameters': ['address _engine', 'address _uniswap', 'address _crv', 'address _veCrv'], 'Returns': []}, {'Name': 'receive', 'Visibility': 'external', 'Purpose': 'Allows the contract to receive Ether.', 'Parameters': [], 'Returns': []}, {'Name': 'withdrawCRV', 'Visibility': 'external', 'Purpose': 'Allows governance to withdraw CRV tokens from the treasury.', 'Parameters': [], 'Returns': []}, {'Name': 'withdrawLock', 'Visibility': 'external', 'Purpose': 'Withdraws locked CRV from the Curve Voting Escrow.', 'Parameters': [], 'Returns': []}, {'Name': 'veCRVInitialize', 'Visibility': 'external', 'Purpose': 'Initializes veCRV locking if enabled.', 'Parameters': [], 'Returns': []}, {'Name': 'toggleLocking', 'Visibility': 'external', 'Purpose': 'Toggles the CRV locking mechanism.', 'Parameters': [], 'Returns': []}, {'Name': 'updateFee', 'Visibility': 'public', 'Purpose': 'Updates the fee shares for operations and veCRV locking.', 'Parameters': [], 'Returns': []}, {'Name': 'claimOperationCost', 'Visibility': 'external', 'Purpose': 'Transfers the operation share to the operation wallet.', 'Parameters': [], 'Returns': []}, {'Name': 'veCRVlock', 'Visibility': 'external', 'Purpose': 'Locks CRV in the Curve Voting Escrow.', 'Parameters': [], 'Returns': []}, {'Name': '_buyCRV', 'Visibility': 'internal', 'Purpose': 'Buys CRV tokens using USDM via Uniswap.', 'Parameters': [], 'Returns': []}, {'Name': '_lockCRV', 'Visibility': 'internal', 'Purpose': 'Locks CRV tokens in the Curve Voting Escrow.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['IMochiEngine: Interface for MochiEngine contract.', 'IUniswapV2Router02: Interface for Uniswap V2 Router.', 'IERC20: Interface for CRV token.', 'ICurveVotingEscrow: Interface for Curve Voting Escrow contract.'], 'SpecialMechanisms': ['CRV Token Locking: The contract allows locking CRV tokens in the Curve Voting Escrow for a specified period.', 'Fee Distribution: The contract manages fee shares for operations and veCRV locking.'], 'Questions': [""What is the exact purpose of the 'operationShare' and 'veCRVShare' variables?"", ""How is the 'updateFee' function triggered and how often is it called?"", ""Are there any security considerations for the 'withdrawCRV' and 'withdrawLock' functions?"", 'Is there a mechanism to handle potential reentrancy attacks in the contract?', ""What is the expected behavior if the 'veCRVInitialize' function is called multiple times?""]}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `withdrawCRV` Function', 'Severity': 'High', 'Description': 'The `withdrawCRV` function transfers CRV tokens to the caller without following the checks-effects-interactions pattern, making it susceptible to reentrancy attacks if the CRV token contract is malicious or has a callback mechanism.', 'Impact': ""An attacker could exploit this vulnerability to drain the contract's CRV balance through repeated reentrant calls."", 'Location': 'Function `withdrawCRV` in multiple instances'}, {'Issue': 'Lack of Access Control on Critical Functions', 'Severity': 'High', 'Description': 'Functions such as `veCRVInitialize`, `veCRVlock`, `updateFee`, and `toggleLocking` lack proper access control, allowing any user to manipulate CRV locking, fee distribution, and other critical operations.', 'Impact': ""Unauthorized users could disrupt the protocol's intended functionality, leading to financial losses or operational inefficiencies."", 'Location': 'Functions `veCRVInitialize`, `veCRVlock`, `updateFee`, `toggleLocking` in multiple instances'}, {'Issue': 'Unchecked External Calls', 'Severity': 'High', 'Description': 'The contract makes external calls (e.g., `crv.transfer`, `veCrv.withdraw`, `uniswapRouter.swapExactTokensForTokens`) without verifying return values, which could lead to silent failures and unexpected behavior.', 'Impact': 'Failed external calls could result in loss of funds or incorrect state updates.', 'Location': 'Multiple locations: `crv.transfer`, `veCrv.withdraw`, `uniswapRouter.swapExactTokensForTokens`'}, {'Issue': 'Potential Front-Running in `veCRVInitialize` and `veCRVlock`', 'Severity': 'Medium', 'Description': 'The `veCRVInitialize` and `veCRVlock` functions involve buying and locking CRV tokens, which could be front-run by attackers to manipulate prices or locking conditions.', 'Impact': 'Financial loss due to unfavorable exchange rates or suboptimal locking conditions.', 'Location': 'Functions `veCRVInitialize` and `veCRVlock` in multiple instances'}, {'Issue': 'Insufficient Slippage Protection in `_buyCRV`', 'Severity': 'Medium', 'Description': 'The `_buyCRV` function sets a minimum output amount of `1` in Uniswap swaps, offering no effective slippage protection.', 'Impact': 'Potential loss of funds due to unfavorable price movements during swaps.', 'Location': 'Function `_buyCRV` in multiple instances'}, {'Issue': 'Potential Integer Overflow in `updateFee`', 'Severity': 'Medium', 'Description': 'The `updateFee` function performs arithmetic operations without explicit overflow checks, which could lead to incorrect fee calculations.', 'Impact': 'Incorrect fee distribution or unintended contract behavior.', 'Location': 'Function `updateFee` in multiple instances'}, {'Issue': 'Uninitialized State Variables', 'Severity': 'Low', 'Description': 'Variables `operationShare` and `veCRVShare` are not initialized in the constructor, leading to undefined behavior when first used.', 'Impact': 'Potential misallocation of funds or unexpected behavior in fee distribution.', 'Location': 'Constructor and `updateFee` function in multiple instances'}, {'Issue': 'Unrestricted ETH Reception', 'Severity': 'Low', 'Description': 'The `receive` function allows the contract to accept ETH without restrictions, which could lead to unintended deposits.', 'Impact': 'Accidental ETH transfers could lock funds in the contract without a clear recovery mechanism.', 'Location': '`receive() external payable` in multiple instances'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical state changes (e.g., CRV withdrawals, fee updates, locking toggles), reducing transparency.', 'Impact': 'Difficulty in tracking and auditing contract activities.', 'Location': 'Multiple functions (e.g., `withdrawCRV`, `updateFee`, `toggleLocking`)'}, {'Issue': 'Hardcoded Time Duration in CRV Locking', 'Severity': 'Low', 'Description': 'The `veCRVInitialize` and `_lockCRV` functions use a hardcoded 90-day lock period, reducing flexibility.', 'Impact': 'Inability to adjust locking periods without contract upgrades.', 'Location': 'Functions `veCRVInitialize` and `_lockCRV` in multiple instances'}], 'IssueNumber': 84, 'OutputList': 10}",658.2849290370941,"### **[H-09] Treasury is Vulnerable to Sandwich Attack**

**Report Description**:  
The permissionless function `veCRVlock` in `MochiTreasury` allows anyone to trigger it, making it susceptible to a sandwich attack. An attacker could use a flash loan to manipulate the price of CRV tokens during the locking process, potentially stealing funds from the treasury. This is a high-risk issue as it could result in the loss of all treasury funds.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running in `veCRVInitialize` and `veCRVlock`""**.

**Validation**:  
**Partially Correct**. The response identifies the potential for front-running in the `veCRVlock` function, which is related to the sandwich attack described in the issue. However, the response does not explicitly mention the use of flash loans or the specific risk of fund theft, which are critical aspects of the reported issue. While the response captures the general vulnerability, it misses key details that elevate the severity of the issue.

---

### **[M-14] `MochiTreasuryV0.withdrawLock()` Is Callable When Locking Has Been Toggled**

**Report Description**:  
The `withdrawLock()` function in `MochiTreasuryV0` does not prevent users from calling it when locking has been toggled. This could lead to unexpected withdrawals, potentially disrupting the intended functionality of the treasury.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The issue is not addressed in the response list. The response list does not mention the `withdrawLock()` function or the specific vulnerability of allowing withdrawals when locking has been toggled. This is a missed issue in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-09] Treasury is Vulnerable to Sandwich Attack**

**Missed Issues from Issue Report**:  
- **[M-14] `MochiTreasuryV0.withdrawLock()` Is Callable When Locking Has Been Toggled**

---

### **Overall Assessment**  
The response list partially addresses one of the two issues in the report. While it identifies a related vulnerability for the sandwich attack, it misses critical details that define the severity of the issue. The second issue regarding `withdrawLock()` is entirely missed, indicating a gap in the response list's coverage. Improvements are needed to ensure all vulnerabilities are accurately and sufficiently addressed.","```
None.
```",0.0
MochiEngine.sol,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""./vault/MochiVaultFactory.sol"";
import ""./assets/usdm.sol"";
import ""./interfaces/IMochiEngine.sol"";

contract MochiEngine is IMochiEngine {
    // immutable values
    IMochiVaultFactory public immutable override vaultFactory;
    // mutable values
    IMochi public override mochi;
    IVMochi public override vMochi;
    address public override governance;
    address public override treasury;
    address public override operationWallet;
    IUSDM public override usdm;
    IMinter public override minter;
    ICSSRRouter public override cssr;
    IMochiProfile public override mochiProfile;
    IDiscountProfile public override discountProfile;
    ILiquidator public override liquidator;
    IFeePool public override feePool;
    IReferralFeePool public override referralFeePool;
    IMochiNFT public override nft;

    constructor(address _governance) {
        governance = _governance;
        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));
        operationWallet = msg.sender;
    }

    modifier onlyGov() {
        require(msg.sender == governance, ""!gov"");
        _;
    }

    function changeMochi(address _mochi) external onlyGov {
        mochi = IMochi(_mochi);
    }

    function changeVMochi(address _vmochi) external onlyGov {
        vMochi = IVMochi(_vmochi);
    }

    function changeUSDM(address _usdm) external onlyGov {
        usdm = IUSDM(_usdm);
    }

    function changeMinter(address _minter) external onlyGov {
        minter = IMinter(_minter);
    }

    function changeGovernance(address _governance) external onlyGov {
        governance = _governance;
    }

    function changeTreasury(address _treasury) external onlyGov {
        treasury = _treasury;
    }

    function changeOperationWallet(address _operation) external onlyGov {
        operationWallet = _operation;
    }

    function changeCSSR(address _cssr) external onlyGov {
        cssr = ICSSRRouter(_cssr);
    }

    function changeProfile(address _profile) external onlyGov {
        mochiProfile = IMochiProfile(_profile);
    }

    function changeDiscountProfile(address _profile) external onlyGov {
        discountProfile = IDiscountProfile(_profile);
    }

    function changeLiquidator(address _liquidator) external onlyGov {
        liquidator = ILiquidator(_liquidator);
    }

    function changeFeePool(address _feePool) external onlyGov {
        feePool = IFeePool(_feePool);
    }

    function changeReferralFeePool(address _referralFeePool) external onlyGov {
        referralFeePool = IReferralFeePool(_referralFeePool);
    }

    function changeNFT(address _nft) external onlyGov {
        nft = IMochiNFT(_nft);
    }
}",661,94,"[H-10] Changing NFT contract in the MochiEngine would break the protocol

Submitted by jonah1005
Impact

MochiEngine allows the operator to change the NFT contract in MochiEngine.sol#L91-L93
All the vaults would point to a different NFT address. As a result, users would not be access their positions. The entire protocol would be broken.
IMHO, A function that would break the entire protocol shouldn't exist.
I consider this is a high-risk issue.
",1,,"pragma solidity ^0.8.0;

import ""./vault/MochiVaultFactory.sol"";
import ""./assets/usdm.sol"";
import ""./interfaces/IMochiEngine.sol"";

contract MochiEngine is IMochiEngine {
    
    IMochiVaultFactory public immutable override vaultFactory;
    
    IMochi public override mochi;
    IVMochi public override vMochi;
    address public override governance;
    address public override treasury;
    address public override operationWallet;
    IUSDM public override usdm;
    IMinter public override minter;
    ICSSRRouter public override cssr;
    IMochiProfile public override mochiProfile;
    IDiscountProfile public override discountProfile;
    ILiquidator public override liquidator;
    IFeePool public override feePool;
    IReferralFeePool public override referralFeePool;
    IMochiNFT public override nft;

    constructor(address _governance) {
        governance = _governance;
        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));
        operationWallet = msg.sender;
    }

    modifier onlyGov() {
        require(msg.sender == governance, ""!gov"");
        _;
    }

    function changeMochi(address _mochi) external onlyGov {
        mochi = IMochi(_mochi);
    }

    function changeVMochi(address _vmochi) external onlyGov {
        vMochi = IVMochi(_vmochi);
    }

    function changeUSDM(address _usdm) external onlyGov {
        usdm = IUSDM(_usdm);
    }

    function changeMinter(address _minter) external onlyGov {
        minter = IMinter(_minter);
    }

    function changeGovernance(address _governance) external onlyGov {
        governance = _governance;
    }

    function changeTreasury(address _treasury) external onlyGov {
        treasury = _treasury;
    }

    function changeOperationWallet(address _operation) external onlyGov {
        operationWallet = _operation;
    }

    function changeCSSR(address _cssr) external onlyGov {
        cssr = ICSSRRouter(_cssr);
    }

    function changeProfile(address _profile) external onlyGov {
        mochiProfile = IMochiProfile(_profile);
    }

    function changeDiscountProfile(address _profile) external onlyGov {
        discountProfile = IDiscountProfile(_profile);
    }

    function changeLiquidator(address _liquidator) external onlyGov {
        liquidator = ILiquidator(_liquidator);
    }

    function changeFeePool(address _feePool) external onlyGov {
        feePool = IFeePool(_feePool);
    }

    function changeReferralFeePool(address _referralFeePool) external onlyGov {
        referralFeePool = IReferralFeePool(_referralFeePool);
    }

    function changeNFT(address _nft) external onlyGov {
        nft = IMochiNFT(_nft);
    }
}",641,1,0,,"{'ReviewingTheCode': ""The provided code snippet is a Solidity smart contract named 'MochiEngine' that implements the 'IMochiEngine' interface. It serves as a central hub for managing various components of a DeFi system, including vaults, tokens, governance, and fee pools. The contract is designed to be controlled by a governance address, which can update the addresses of various components."", 'IdentifyingKeyComponents': {'ContractName': 'MochiEngine', 'Purpose': 'To act as a central management contract for a DeFi system, allowing governance to control and update various components such as vaults, tokens, and fee pools.', 'InheritanceAndImports': {'InheritsFrom': ['IMochiEngine'], 'Imports': ['./vault/MochiVaultFactory.sol', './assets/usdm.sol', './interfaces/IMochiEngine.sol']}, 'StateVariables': [{'Name': 'vaultFactory', 'Type': 'IMochiVaultFactory', 'Purpose': 'Factory contract for creating and managing vaults.'}, {'Name': 'mochi', 'Type': 'IMochi', 'Purpose': 'Main token contract.'}, {'Name': 'vMochi', 'Type': 'IVMochi', 'Purpose': 'Voting token contract.'}, {'Name': 'governance', 'Type': 'address', 'Purpose': 'Address with governance privileges.'}, {'Name': 'treasury', 'Type': 'address', 'Purpose': 'Address of the treasury wallet.'}, {'Name': 'operationWallet', 'Type': 'address', 'Purpose': 'Address of the operation wallet.'}, {'Name': 'usdm', 'Type': 'IUSDM', 'Purpose': 'Stablecoin contract.'}, {'Name': 'minter', 'Type': 'IMinter', 'Purpose': 'Contract responsible for minting tokens.'}, {'Name': 'cssr', 'Type': 'ICSSRRouter', 'Purpose': 'CSSR router contract.'}, {'Name': 'mochiProfile', 'Type': 'IMochiProfile', 'Purpose': 'Profile management contract.'}, {'Name': 'discountProfile', 'Type': 'IDiscountProfile', 'Purpose': 'Discount profile management contract.'}, {'Name': 'liquidator', 'Type': 'ILiquidator', 'Purpose': 'Liquidation contract.'}, {'Name': 'feePool', 'Type': 'IFeePool', 'Purpose': 'Fee pool contract.'}, {'Name': 'referralFeePool', 'Type': 'IReferralFeePool', 'Purpose': 'Referral fee pool contract.'}, {'Name': 'nft', 'Type': 'IMochiNFT', 'Purpose': 'NFT contract.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with a governance address and creates a new vault factory.', 'Parameters': ['address _governance'], 'Returns': []}, {'Name': 'onlyGov', 'Visibility': 'modifier', 'Purpose': 'Restricts function access to the governance address.', 'Parameters': [], 'Returns': []}, {'Name': 'changeMochi', 'Visibility': 'external', 'Purpose': 'Updates the address of the main token contract.', 'Parameters': ['address _mochi'], 'Returns': []}, {'Name': 'changeVMochi', 'Visibility': 'external', 'Purpose': 'Updates the address of the voting token contract.', 'Parameters': ['address _vmochi'], 'Returns': []}, {'Name': 'changeUSDM', 'Visibility': 'external', 'Purpose': 'Updates the address of the stablecoin contract.', 'Parameters': ['address _usdm'], 'Returns': []}, {'Name': 'changeMinter', 'Visibility': 'external', 'Purpose': 'Updates the address of the minter contract.', 'Parameters': ['address _minter'], 'Returns': []}, {'Name': 'changeGovernance', 'Visibility': 'external', 'Purpose': 'Updates the governance address.', 'Parameters': ['address _governance'], 'Returns': []}, {'Name': 'changeTreasury', 'Visibility': 'external', 'Purpose': 'Updates the treasury address.', 'Parameters': ['address _treasury'], 'Returns': []}, {'Name': 'changeOperationWallet', 'Visibility': 'external', 'Purpose': 'Updates the operation wallet address.', 'Parameters': ['address _operation'], 'Returns': []}, {'Name': 'changeCSSR', 'Visibility': 'external', 'Purpose': 'Updates the CSSR router address.', 'Parameters': ['address _cssr'], 'Returns': []}, {'Name': 'changeProfile', 'Visibility': 'external', 'Purpose': 'Updates the profile management contract address.', 'Parameters': ['address _profile'], 'Returns': []}, {'Name': 'changeDiscountProfile', 'Visibility': 'external', 'Purpose': 'Updates the discount profile management contract address.', 'Parameters': ['address _profile'], 'Returns': []}, {'Name': 'changeLiquidator', 'Visibility': 'external', 'Purpose': 'Updates the liquidation contract address.', 'Parameters': ['address _liquidator'], 'Returns': []}, {'Name': 'changeFeePool', 'Visibility': 'external', 'Purpose': 'Updates the fee pool contract address.', 'Parameters': ['address _feePool'], 'Returns': []}, {'Name': 'changeReferralFeePool', 'Visibility': 'external', 'Purpose': 'Updates the referral fee pool contract address.', 'Parameters': ['address _referralFeePool'], 'Returns': []}, {'Name': 'changeNFT', 'Visibility': 'external', 'Purpose': 'Updates the NFT contract address.', 'Parameters': ['address _nft'], 'Returns': []}]}, 'ExternalInteractions': ['MochiVaultFactory', 'IMochi', 'IVMochi', 'IUSDM', 'IMinter', 'ICSSRRouter', 'IMochiProfile', 'IDiscountProfile', 'ILiquidator', 'IFeePool', 'IReferralFeePool', 'IMochiNFT'], 'SpecialMechanisms': [""The contract uses the Factory pattern to create and manage vaults through the 'vaultFactory'."", ""The 'onlyGov' modifier ensures that only the governance address can execute certain functions.""], 'Questions': [""What is the purpose of the 'operationWallet' and how is it used?"", 'Are there any security measures in place to prevent the governance address from being compromised?', ""How are the various components (e.g., 'mochi', 'vMochi', 'usdm') integrated and used within the broader system?""]}","{'Findings': [{'Issue': 'Single Point of Failure in Governance', 'Severity': 'High', 'Description': 'The contract relies heavily on a single governance address to manage all critical functions and state changes. If this address is compromised or becomes unavailable, the entire system could be at risk. There is no mechanism for multi-signature or decentralized governance.', 'Impact': 'Compromise of the governance address could lead to unauthorized changes, loss of funds, or complete system failure. The lack of redundancy or decentralization increases the risk.', 'Location': 'Constructor, Modifier: `onlyGov`, Functions: `changeMochi`, `changeVMochi`, `changeUSDM`, `changeMinter`, `changeGovernance`, `changeTreasury`, `changeOperationWallet`, `changeCSSR`, `changeProfile`, `changeDiscountProfile`, `changeLiquidator`, `changeFeePool`, `changeReferralFeePool`, `changeNFT`'}, {'Issue': 'Lack of Input Validation in Change Functions', 'Severity': 'Medium', 'Description': 'The contract has multiple functions that allow the governance address to change critical contract addresses (e.g., `changeMochi`, `changeVMochi`, `changeUSDM`, etc.). However, these functions do not validate the input addresses to ensure they are not zero addresses or invalid addresses. This could lead to accidental or malicious setting of invalid addresses, potentially causing the contract to malfunction.', 'Impact': 'If an invalid address is set, the contract could become unusable or lead to loss of funds or functionality. For example, setting a zero address for `usdm` or `mochi` could break the entire system.', 'Location': 'Functions: `changeMochi`, `changeVMochi`, `changeUSDM`, `changeMinter`, `changeGovernance`, `changeTreasury`, `changeOperationWallet`, `changeCSSR`, `changeProfile`, `changeDiscountProfile`, `changeLiquidator`, `changeFeePool`, `changeReferralFeePool`, `changeNFT`'}, {'Issue': 'No Event Emission on State Changes', 'Severity': 'Low', 'Description': 'The contract does not emit events when critical state variables are changed (e.g., governance, treasury, operationWallet). This makes it difficult to track changes and could lead to transparency issues. Events are crucial for off-chain monitoring and auditing.', 'Impact': 'Reduced transparency and difficulty in tracking state changes, which could lead to unnoticed malicious activities or errors.', 'Location': 'Functions: `changeMochi`, `changeVMochi`, `changeUSDM`, `changeMinter`, `changeGovernance`, `changeTreasury`, `changeOperationWallet`, `changeCSSR`, `changeProfile`, `changeDiscountProfile`, `changeLiquidator`, `changeFeePool`, `changeReferralFeePool`, `changeNFT`'}, {'Issue': 'Immutable Vault Factory', 'Severity': 'Medium', 'Description': 'The `vaultFactory` is set as immutable and initialized in the constructor. This means that once the contract is deployed, the `vaultFactory` cannot be changed. If there is a bug or upgrade needed in the `vaultFactory`, the entire contract would need to be redeployed.', 'Impact': 'Lack of flexibility in upgrading or fixing the `vaultFactory` could lead to inefficiencies or vulnerabilities that cannot be addressed without redeploying the entire contract.', 'Location': 'Variable: `vaultFactory`, Constructor'}, {'Issue': 'Potential Reentrancy Risk in External Calls', 'Severity': 'Medium', 'Description': 'The contract makes external calls to other contracts (e.g., `vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));`). While there are no direct reentrancy risks in the current implementation, future modifications or interactions with these external contracts could introduce reentrancy vulnerabilities if not handled carefully.', 'Impact': 'If a reentrancy vulnerability is introduced, it could lead to loss of funds or other unintended behaviors.', 'Location': 'Constructor, External calls in change functions'}, {'Issue': 'No Ownership Transfer Mechanism', 'Severity': 'Medium', 'Description': 'The contract does not include a mechanism to transfer ownership (governance) to another address. This could lead to issues if the current governance address is lost or compromised, as there would be no way to recover control.', 'Impact': 'If the governance address is lost or compromised, the contract could become permanently inaccessible or controlled by an attacker.', 'Location': 'Constructor and `changeGovernance` function'}, {'Issue': 'No Check for Zero Address in Critical Functions', 'Severity': 'Medium', 'Description': 'Functions that change critical addresses (e.g., governance, treasury, operationWallet) do not check if the new address is the zero address. This could lead to accidental or intentional loss of control over these components.', 'Impact': 'Setting critical addresses to the zero address can render the contract unusable or lead to loss of funds and control.', 'Location': 'Functions like `changeGovernance`, `changeTreasury`, `changeOperationWallet`, etc.'}, {'Issue': 'No Fallback or Receive Function', 'Severity': 'Low', 'Description': 'The contract does not implement a fallback or receive function. This means that if Ether is sent to the contract directly, it will be rejected, potentially leading to loss of funds.', 'Impact': 'Direct Ether transfers to the contract will fail, leading to potential loss of funds.', 'Location': 'Contract level'}, {'Issue': 'No Emergency Stop Mechanism', 'Severity': 'Medium', 'Description': 'The contract does not include an emergency stop mechanism (pause/unpause) to halt operations in case of a critical issue or attack.', 'Impact': 'Inability to quickly stop operations in case of an emergency, potentially leading to further damage or loss.', 'Location': 'Entire contract.'}], 'IssueNumber': 14, 'OutputList': 9}",666.3905441761017,"---

**[H-10] Changing NFT contract in the MochiEngine would break the protocol**

**Report Description**:  
The `MochiEngine` contract allows the operator to change the NFT contract address (lines 91-93 in `MochiEngine.sol`). If the NFT contract is changed, all vaults would point to a different NFT address, rendering users unable to access their positions. This could break the entire protocol. The issue is considered high-risk because a function that can disrupt the entire protocol should not exist.

**Match in Response List**:  
Matches with the issue titled **""Single Point of Failure in Governance""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of a single governance address managing critical functions, which aligns with the issue of the operator being able to change the NFT contract. However, the response does not specifically address the impact of changing the NFT contract, which would break the protocol by making user positions inaccessible. While the governance risk is acknowledged, the specific vulnerability and its high-risk impact are not fully covered.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-10] Changing NFT contract in the MochiEngine would break the protocol**

**Missed Issues from Issue Report**:  
- *None*

---","```
None.
```",0.0
VestedRewardPool.sol,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""../interfaces/IMochi.sol"";
import ""@mochifi/vmochi/contracts/interfaces/IVMochi.sol"";

contract VestedRewardPool {
    IMochi public immutable mochi;
    IVMochi public immutable vMochi;

    uint256 public mochiUnderManagement;

    mapping(address => Vesting) public vesting;

    struct Vesting {
        uint256 vested;
        uint256 ends;
        uint256 claimable;
    }

    modifier checkClaimable(address recipient) {
        if (vesting[recipient].ends < block.timestamp) {
            vesting[recipient].claimable += vesting[recipient].vested;
            vesting[recipient].vested = 0;
            vesting[recipient].ends = 0;
        }
        _;
    }

    constructor(address _mochi, address _vmochi) {
        mochi = IMochi(_mochi);
        vMochi = IVMochi(_vmochi);
    }

    function vest(address _recipient) external checkClaimable(_recipient) {
        uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;
        uint256 weightedEnd = (vesting[_recipient].vested *
            vesting[_recipient].ends +
            amount *
            (block.timestamp + 90 days)) /
            (vesting[_recipient].vested + amount);
        vesting[_recipient].vested += amount;
        vesting[_recipient].ends = weightedEnd;
        mochiUnderManagement += amount;
    }

    function claim() external checkClaimable(msg.sender) {
        mochi.transfer(msg.sender, vesting[msg.sender].claimable);
        mochiUnderManagement -= vesting[msg.sender].claimable;
        vesting[msg.sender].claimable = 0;
    }

    function lock(uint256 _amount) external checkClaimable(msg.sender) {
        mochi.approve(address(vMochi), _amount);
        (, uint256 end) = vMochi.locked(msg.sender);
        if (end >= block.timestamp + 90 days) {
            vMochi.depositFor(msg.sender, _amount);
        } else {
            revert(""lock should be longer than 90 days"");
        }
        vesting[msg.sender].vested -= _amount;
        mochiUnderManagement -= _amount;
    }

    function forceClaim(uint256 _amount) external checkClaimable(msg.sender) {
        mochi.transfer(msg.sender, _amount / 2);
        mochi.transfer(address(vMochi), _amount / 2);
        vesting[msg.sender].vested -= _amount;
        mochiUnderManagement -= _amount;
    }
}",586,72,"[H-13] Tokens Can Be Stolen By Frontrunning VestedRewardPool.vest() and VestedRewardPool.lock()

Submitted by leastwood
Impact

The VestedRewardPool.sol contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their mochi. The vest() function does not utilise safeTransferFrom() to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to vest() and effectively steal a recipient's vested tokens. The same issue applies to the lock() function.
Proof of Concept

VestedRewardPool.sol#L36 L46
VestedRewardPool.sol#L54 L64

",1,,"pragma solidity ^0.8.0;

import ""../interfaces/IMochi.sol"";
import ""@mochifi/vmochi/contracts/interfaces/IVMochi.sol"";

contract VestedRewardPool {
    IMochi public immutable mochi;
    IVMochi public immutable vMochi;

    uint256 public mochiUnderManagement;

    mapping(address => Vesting) public vesting;

    struct Vesting {
        uint256 vested;
        uint256 ends;
        uint256 claimable;
    }

    modifier checkClaimable(address recipient) {
        if (vesting[recipient].ends < block.timestamp) {
            vesting[recipient].claimable += vesting[recipient].vested;
            vesting[recipient].vested = 0;
            vesting[recipient].ends = 0;
        }
        _;
    }

    constructor(address _mochi, address _vmochi) {
        mochi = IMochi(_mochi);
        vMochi = IVMochi(_vmochi);
    }

    function vest(address _recipient) external checkClaimable(_recipient) {
        uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;
        uint256 weightedEnd = (vesting[_recipient].vested *
            vesting[_recipient].ends +
            amount *
            (block.timestamp + 90 days)) /
            (vesting[_recipient].vested + amount);
        vesting[_recipient].vested += amount;
        vesting[_recipient].ends = weightedEnd;
        mochiUnderManagement += amount;
    }

    function claim() external checkClaimable(msg.sender) {
        mochi.transfer(msg.sender, vesting[msg.sender].claimable);
        mochiUnderManagement -= vesting[msg.sender].claimable;
        vesting[msg.sender].claimable = 0;
    }

    function lock(uint256 _amount) external checkClaimable(msg.sender) {
        mochi.approve(address(vMochi), _amount);
        (, uint256 end) = vMochi.locked(msg.sender);
        if (end >= block.timestamp + 90 days) {
            vMochi.depositFor(msg.sender, _amount);
        } else {
            revert(""lock should be longer than 90 days"");
        }
        vesting[msg.sender].vested -= _amount;
        mochiUnderManagement -= _amount;
    }

    function forceClaim(uint256 _amount) external checkClaimable(msg.sender) {
        mochi.transfer(msg.sender, _amount / 2);
        mochi.transfer(address(vMochi), _amount / 2);
        vesting[msg.sender].vested -= _amount;
        mochiUnderManagement -= _amount;
    }
}",574,1,0,,"{'ReviewingTheCode': 'The contract is a VestedRewardPool designed to manage vesting and claiming of Mochi tokens. It allows users to vest tokens, claim vested tokens, lock tokens for a specified period, and force claim tokens. The contract interacts with external Mochi and vMochi contracts to manage token balances and locking mechanisms.', 'IdentifyingKeyComponents': {'ContractName': 'VestedRewardPool', 'Purpose': 'To manage the vesting, claiming, and locking of Mochi tokens for users.', 'InheritanceAndImports': {'InheritsFrom': [], 'Imports': ['../interfaces/IMochi.sol', '@mochifi/vmochi/contracts/interfaces/IVMochi.sol']}, 'StateVariables': [{'Name': 'mochi', 'Type': 'IMochi', 'Purpose': 'Interface for interacting with the Mochi token contract.'}, {'Name': 'vMochi', 'Type': 'IVMochi', 'Purpose': 'Interface for interacting with the vMochi token contract.'}, {'Name': 'mochiUnderManagement', 'Type': 'uint256', 'Purpose': 'Tracks the total amount of Mochi tokens managed by the contract.'}, {'Name': 'vesting', 'Type': 'mapping(address => Vesting)', 'Purpose': 'Stores vesting details for each user.'}], 'FunctionsAndModifiers': [{'Name': 'checkClaimable', 'Visibility': 'internal', 'Purpose': 'Modifier to update the claimable amount for a recipient if the vesting period has ended.', 'Parameters': ['address recipient'], 'Returns': []}, {'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with Mochi and vMochi contract addresses.', 'Parameters': ['address _mochi', 'address _vmochi'], 'Returns': []}, {'Name': 'vest', 'Visibility': 'external', 'Purpose': 'Allows a user to vest Mochi tokens for a specified period.', 'Parameters': ['address _recipient'], 'Returns': []}, {'Name': 'claim', 'Visibility': 'external', 'Purpose': 'Allows a user to claim their vested Mochi tokens.', 'Parameters': [], 'Returns': []}, {'Name': 'lock', 'Visibility': 'external', 'Purpose': 'Allows a user to lock their vested Mochi tokens for a specified period.', 'Parameters': ['uint256 _amount'], 'Returns': []}, {'Name': 'forceClaim', 'Visibility': 'external', 'Purpose': 'Allows a user to force claim their vested Mochi tokens, splitting them between the user and vMochi contract.', 'Parameters': ['uint256 _amount'], 'Returns': []}]}, 'ExternalInteractions': ['IMochi: Interface for interacting with the Mochi token contract.', 'IVMochi: Interface for interacting with the vMochi token contract.'], 'SpecialMechanisms': ['Vesting Mechanism: The contract manages vesting periods and claimable amounts for users.', 'Locking Mechanism: The contract allows users to lock their tokens for a specified period, ensuring they cannot be withdrawn prematurely.'], 'Questions': ['How is the weighted end time calculated in the vest function? Is the formula safe from potential overflow or underflow?', ""What happens if the lock function is called with an amount greater than the user's vested balance?"", 'Is there any mechanism to prevent reentrancy attacks in the claim and forceClaim functions?', 'How does the contract handle the case where the vMochi contract returns an unexpected value or reverts?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in `claim` Function', 'Severity': 'High', 'Description': ""The `claim` function transfers MOCHI tokens to the caller before updating the state, making it susceptible to reentrancy attacks. An attacker could recursively call the function to drain the contract's funds."", 'Impact': 'Potential loss of funds due to reentrancy attacks.', 'Location': '`claim` function'}, {'Issue': 'Reentrancy Vulnerability in `forceClaim` Function', 'Severity': 'High', 'Description': ""The `forceClaim` function transfers tokens to the caller and another address before updating the state, making it susceptible to reentrancy attacks. An attacker could recursively call the function to drain the contract's funds."", 'Impact': 'Potential loss of funds due to reentrancy attacks.', 'Location': '`forceClaim` function'}, {'Issue': 'Insufficient Input Validation in `vest` Function', 'Severity': 'Medium', 'Description': 'The `vest` function does not validate the `_recipient` address, which could lead to vesting tokens to a zero address or an invalid address, resulting in permanent loss of tokens.', 'Impact': 'Loss of tokens if vested to an invalid address.', 'Location': '`vest` function'}, {'Issue': 'Potential Integer Overflow in `vest` Function', 'Severity': 'Medium', 'Description': 'The calculation of `weightedEnd` in the `vest` function involves multiplication and division operations that could lead to integer overflow, causing incorrect vesting calculations.', 'Impact': 'Incorrect vesting calculations, potentially leading to unfair distribution of tokens.', 'Location': '`vest` function'}, {'Issue': 'Lack of Access Control in `forceClaim` Function', 'Severity': 'Medium', 'Description': 'The `forceClaim` function allows any user to claim and transfer half of the specified amount to themselves and the other half to the `vMochi` contract without any restrictions.', 'Impact': 'Potential loss of funds if exploited by unauthorized users.', 'Location': '`forceClaim` function'}, {'Issue': 'Incorrect State Update in `lock` Function', 'Severity': 'Medium', 'Description': 'The `lock` function updates the `vesting` state after transferring tokens. If the transfer fails, the state would still be updated, leading to inconsistencies.', 'Impact': 'Inconsistent state leading to potential loss of funds or incorrect token distribution.', 'Location': '`lock` function'}, {'Issue': 'Unbounded Loop in `checkClaimable` Modifier', 'Severity': 'Low', 'Description': 'The `checkClaimable` modifier iterates over all vesting entries for a recipient. If the number of vesting entries is large, it could lead to high gas consumption and potential denial of service.', 'Impact': 'High gas consumption and potential denial of service.', 'Location': 'Modifier `checkClaimable`'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical state changes such as vesting, claiming, and locking. This makes it difficult to track and audit these actions.', 'Impact': 'Reduced transparency and auditability of contract actions.', 'Location': 'Entire contract'}, {'Issue': 'Potential Front-Running in `vest` Function', 'Severity': 'Low', 'Description': 'The `vest` function is susceptible to front-running attacks, where an attacker could observe a pending vesting transaction and submit their own transaction with a higher gas fee to manipulate the vesting period or amount.', 'Impact': 'Manipulation of vesting periods or amounts leading to potential loss of funds.', 'Location': '`vest` function'}], 'IssueNumber': 10, 'OutputList': 9}",490.8323152065277,"---

**[H-13] Tokens Can Be Stolen By Frontrunning VestedRewardPool.vest() and VestedRewardPool.lock()**

**Report Description**:  
The `VestedRewardPool.sol` contract is designed to vest tokens for a minimum of 90 days before allowing recipients to withdraw their `mochi`. However, the `vest()` function does not use `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. This oversight allows an attacker to frontrun a call to `vest()` and steal the recipient's vested tokens. The same vulnerability exists in the `lock()` function, making it susceptible to similar frontrunning attacks.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running in `vest` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the front-running vulnerability in the `vest` function, which aligns with the issue report. However, it does not address the same vulnerability in the `lock()` function, nor does it mention the lack of `safeTransferFrom()` as a critical factor enabling the attack. The response also underestimates the severity of the issue, labeling it as ""Low"" instead of ""High,"" which is more appropriate given the potential for token theft.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-13] Tokens Can Be Stolen By Frontrunning VestedRewardPool.vest() and VestedRewardPool.lock()**

**Missed Issues from Issue Report**:  
- *None*

--- 

This evaluation highlights that while the response partially addresses the issue, it misses critical details and underestimates the severity. The lack of `safeTransferFrom()` and the vulnerability in the `lock()` function are significant omissions.","```
None.
```",0.0
MachiVaultFactory.sol,"// SPDX-License-Identifier: AGPL-3.0

pragma solidity ^0.8.0;

import ""@mochifi/library/contracts/Beacon.sol"";
import ""@mochifi/library/contracts/BeaconProxyDeployer.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IMochiVaultFactory.sol"";

contract MochiVaultFactory is IMochiVaultFactory {
    IMochiEngine public immutable engine;
    Beacon public immutable beacon;
    address public template;

    constructor(address _engine) {
        beacon = new Beacon(address(0));
        engine = IMochiEngine(_engine);
    }

    function updateTemplate(address _newTemplate) external override {
        require(msg.sender == engine.governance(), ""!gov"");
        address(beacon).call(abi.encode(_newTemplate));
        template = _newTemplate;
    }

    function deployVault(address _asset)
        external
        override
        returns (IMochiVault)
    {
        bytes memory initCode = abi.encodeWithSelector(
            bytes4(keccak256(""initialize(address)"")),
            _asset
        );
        return
            IMochiVault(BeaconProxyDeployer.deploy(address(beacon), initCode));
    }

    function getVault(address _asset)
        external
        view
        override
        returns (IMochiVault)
    {
        bytes memory initCode = abi.encodeWithSelector(
            bytes4(keccak256(""initialize(address)"")),
            _asset
        );
        return
            IMochiVault(
                BeaconProxyDeployer.calculateAddress(
                    address(this),
                    address(beacon),
                    initCode
                )
            );
    }
}",348,58,"[M-12] anyone can create a vault by directly calling the factory

Function `deployVault()`

In MochiVaultFactory.sol#L26-L37, there's no permission control in the vaultFactory. Anyone can create a vault. The transaction would be reverted when the government tries to deploy such an asset.
As the protocol checks whether the vault is a valid vault by comparing the contract's address with the computed address, the protocol would recognize the random vault as a valid one.
I consider this is a medium-risk issue.
",1,,"pragma solidity ^0.8.0;

import ""@mochifi/library/contracts/Beacon.sol"";
import ""@mochifi/library/contracts/BeaconProxyDeployer.sol"";
import ""../interfaces/IMochiEngine.sol"";
import ""../interfaces/IMochiVaultFactory.sol"";

contract MochiVaultFactory is IMochiVaultFactory {
    IMochiEngine public immutable engine;
    Beacon public immutable beacon;
    address public template;

    constructor(address _engine) {
        beacon = new Beacon(address(0));
        engine = IMochiEngine(_engine);
    }

    function updateTemplate(address _newTemplate) external override {
        require(msg.sender == engine.governance(), ""!gov"");
        address(beacon).call(abi.encode(_newTemplate));
        template = _newTemplate;
    }

    function deployVault(address _asset)
        external
        override
        returns (IMochiVault)
    {
        bytes memory initCode = abi.encodeWithSelector(
            bytes4(keccak256(""initialize(address)"")),
            _asset
        );
        return
            IMochiVault(BeaconProxyDeployer.deploy(address(beacon), initCode));
    }

    function getVault(address _asset)
        external
        view
        override
        returns (IMochiVault)
    {
        bytes memory initCode = abi.encodeWithSelector(
            bytes4(keccak256(""initialize(address)"")),
            _asset
        );
        return
            IMochiVault(
                BeaconProxyDeployer.calculateAddress(
                    address(this),
                    address(beacon),
                    initCode
                )
            );
    }
}",336,0,1,,"{'ReviewingTheCode': ""The provided code is a Solidity smart contract named 'MochiVaultFactory' that appears to be a factory contract for deploying and managing Mochi Vaults. The contract interacts with external contracts and libraries, and it implements the IMochiVaultFactory interface. The code is well-structured, with clear function definitions and state variables. The contract uses a Beacon pattern for deploying proxy contracts, which suggests a focus on upgradability and modularity."", 'IdentifyingKeyComponents': {'ContractName': 'MochiVaultFactory', 'Purpose': 'To act as a factory for deploying and managing Mochi Vaults, which are likely used for managing assets in a decentralized finance (DeFi) context.', 'InheritanceAndImports': {'InheritsFrom': ['IMochiVaultFactory'], 'Imports': ['@mochifi/library/contracts/Beacon.sol', '@mochifi/library/contracts/BeaconProxyDeployer.sol', '../interfaces/IMochiEngine.sol', '../interfaces/IMochiVaultFactory.sol']}, 'StateVariables': [{'Name': 'engine', 'Type': 'IMochiEngine', 'Purpose': 'Stores the reference to the MochiEngine contract, which likely provides governance and other core functionalities.'}, {'Name': 'beacon', 'Type': 'Beacon', 'Purpose': 'Stores the reference to the Beacon contract, which is used for deploying proxy contracts.'}, {'Name': 'template', 'Type': 'address', 'Purpose': 'Stores the address of the template contract that will be used for deploying new Mochi Vaults.'}], 'FunctionsAndModifiers': [{'Name': 'updateTemplate', 'Visibility': 'external', 'Purpose': 'Allows the governance to update the template contract address used for deploying new Mochi Vaults.', 'Parameters': ['address _newTemplate'], 'Returns': []}, {'Name': 'deployVault', 'Visibility': 'external', 'Purpose': 'Deploys a new Mochi Vault for a given asset using the BeaconProxyDeployer.', 'Parameters': ['address _asset'], 'Returns': ['IMochiVault']}, {'Name': 'getVault', 'Visibility': 'external', 'Purpose': 'Calculates and returns the address of a Mochi Vault for a given asset without deploying it.', 'Parameters': ['address _asset'], 'Returns': ['IMochiVault']}]}, 'ExternalInteractions': ['Beacon.sol', 'BeaconProxyDeployer.sol', 'IMochiEngine.sol', 'IMochiVaultFactory.sol'], 'SpecialMechanisms': ['The contract uses the Beacon pattern, which is a design pattern for deploying proxy contracts. This pattern allows for upgradability and modularity by separating the logic of the contract from its implementation.', 'The contract also uses the BeaconProxyDeployer library to deploy new Mochi Vaults, which suggests a focus on modularity and reusability.'], 'Questions': ['What is the exact role of the MochiEngine contract in this context?', 'How is the Beacon contract initialized with an address of 0 in the constructor? Is this intentional?', 'What are the specific functionalities of the Mochi Vaults that are being deployed?', 'Are there any security considerations or potential vulnerabilities in the use of the Beacon pattern and proxy deployment?']}","{'Findings': [{'Issue': 'Unsafe Low-Level Call', 'Severity': 'High', 'Description': 'The `updateTemplate` function uses a low-level call (`address(beacon).call`) to update the template address without checking the success of the call. This could lead to silent failures or unexpected behavior if the call fails.', 'Impact': 'If the call fails, the template address might not be updated correctly, leading to inconsistencies or vulnerabilities in the system.', 'Location': 'MochiVaultFactory.sol, function `updateTemplate`'}, {'Issue': 'Unrestricted Template Update', 'Severity': 'High', 'Description': 'The `updateTemplate` function allows the governance address to update the template address without any validation or checks on the new template. This could lead to the deployment of malicious or unintended contracts if the governance address is compromised.', 'Impact': 'Potential deployment of malicious contracts, leading to loss of funds or unauthorized actions.', 'Location': 'function updateTemplate(address _newTemplate)'}, {'Issue': 'Incorrect Beacon Initialization', 'Severity': 'High', 'Description': 'The `beacon` is initialized with a zero address in the constructor. This is incorrect because the beacon should be initialized with a valid implementation address to ensure that the proxy contracts deployed by the factory point to a valid implementation.', 'Impact': 'Deploying proxy contracts with a zero implementation address could lead to failed deployments or unexpected behavior in the system.', 'Location': 'constructor(address _engine)'}, {'Issue': 'Lack of Access Control in `deployVault`', 'Severity': 'Medium', 'Description': 'The `deployVault` function does not have any access control mechanisms, allowing any external caller to deploy a new vault. This could lead to unauthorized deployment of vaults, potentially causing resource exhaustion or other issues.', 'Impact': 'Unauthorized users could deploy vaults, leading to potential abuse or resource exhaustion.', 'Location': 'MochiVaultFactory.sol, function `deployVault`'}, {'Issue': 'Potential Reentrancy in `deployVault`', 'Severity': 'Medium', 'Description': 'The `deployVault` function calls an external contract (`BeaconProxyDeployer.deploy`) without using a reentrancy guard. This could potentially allow for reentrancy attacks if the external contract is malicious or compromised.', 'Impact': 'A malicious contract could exploit reentrancy to manipulate the state or cause unexpected behavior during the deployment of a vault.', 'Location': 'MochiVaultFactory.sol, function `deployVault`'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'The `updateTemplate` and `deployVault` functions do not validate the input addresses (`_newTemplate` and `_asset`). This could lead to the deployment of vaults with invalid or malicious addresses, potentially causing vulnerabilities or unexpected behavior.', 'Impact': 'Invalid or malicious addresses could lead to vulnerabilities, such as the deployment of malicious contracts or the loss of funds.', 'Location': 'updateTemplate and deployVault functions'}, {'Issue': 'Insufficient Validation in `updateTemplate` Function', 'Severity': 'Medium', 'Description': 'The `updateTemplate` function only checks if the caller is the governance address but does not validate the `_newTemplate` address. If an invalid address is provided, it could lead to unexpected behavior or vulnerabilities.', 'Impact': 'Setting an invalid template address could result in deployment failures or vulnerabilities in the vaults created by the factory.', 'Location': 'MochiVaultFactory.sol, function `updateTemplate`'}, {'Issue': 'Immutable `engine` and `beacon` Variables', 'Severity': 'Low', 'Description': 'The `engine` and `beacon` variables are marked as `immutable`, meaning they cannot be changed after deployment. While this is generally a good practice for security, it also means that if there is a need to upgrade these components, the entire contract would need to be redeployed.', 'Impact': 'Lack of flexibility in upgrading or changing the `engine` or `beacon` components without redeploying the contract.', 'Location': 'MochiVaultFactory.sol, lines declaring `engine` and `beacon`'}, {'Issue': 'Potential Front-Running in `updateTemplate`', 'Severity': 'Low', 'Description': 'The `updateTemplate` function is susceptible to front-running attacks because it updates the template address without any mechanism to prevent race conditions. An attacker could monitor the blockchain for pending transactions and submit their own transaction to update the template address first.', 'Impact': 'An attacker could front-run the `updateTemplate` transaction to set a malicious template address, potentially compromising the system.', 'Location': 'MochiVaultFactory.sol, function `updateTemplate`'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': 'The `updateTemplate` function does not emit an event when the template is updated. Emitting events is a best practice for tracking state changes and providing transparency to off-chain systems.', 'Impact': 'Lack of event emission makes it harder to track template changes and could complicate debugging and monitoring.', 'Location': 'function updateTemplate(address _newTemplate)'}], 'IssueNumber': 50, 'OutputList': 10}",572.1436262130737,"---

**[M-12] Anyone can create a vault by directly calling the factory**

**Report Description**:
The `deployVault()` function in `MochiVaultFactory.sol` lacks permission control, allowing anyone to create a vault. While the transaction would revert when the government tries to deploy such an asset, the protocol recognizes the random vault as valid by comparing the contract's address with the computed address. This is considered a medium-risk issue due to the potential for unauthorized vault creation and the associated risks.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control in `deployVault`""**.

**Validation**:
**Correct**. The response accurately identifies the issue of unrestricted access to the `deployVault` function, allowing any external caller to deploy a new vault. This aligns with the reported issue, highlighting the risk of unauthorized vault deployment and potential resource exhaustion. The response correctly captures the core vulnerability and its impact.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-12] Anyone can create a vault by directly calling the factory**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

---","```
1. Lack of Access Control in `deployVault`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is `Lack of Access Control in 'deployVault'`.
   - This issue appears at rank 4 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - At rank 4, there is 1 true positive.
   - \( P@4 = \frac{1}{4} = 0.25 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.25 \).

**Output**:
```
0.25
```"
