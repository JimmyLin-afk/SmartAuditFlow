nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
MapleLoan.sol,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IERC20 }             from ""../modules/erc20/src/interfaces/IERC20.sol"";
import { IMapleProxyFactory } from ""../modules/maple-proxy-factory/contracts/interfaces/IMapleProxyFactory.sol"";

import { ERC20Helper } from ""../modules/erc20-helper/src/ERC20Helper.sol"";

import { IMapleLoan } from ""./interfaces/IMapleLoan.sol"";
import { IMapleGlobalsLike } from ""./interfaces/Interfaces.sol"";

import { MapleLoanInternals } from ""./MapleLoanInternals.sol"";

/// @title MapleLoan implements a primitive loan with additional functionality, and is intended to be proxied.
contract MapleLoan is IMapleLoan, MapleLoanInternals {

    modifier whenProtocolNotPaused() {
        require(!isProtocolPaused(), ""ML:PROTOCOL_PAUSED"");
        _;
    }

    /********************************/
    /*** Administrative Functions ***/
    /********************************/

    function migrate(address migrator_, bytes calldata arguments_) external override {
        require(msg.sender == _factory(),        ""ML:M:NOT_FACTORY"");
        require(_migrate(migrator_, arguments_), ""ML:M:FAILED"");
    }

    function setImplementation(address newImplementation_) external override {
        require(msg.sender == _factory(),               ""ML:SI:NOT_FACTORY"");
        require(_setImplementation(newImplementation_), ""ML:SI:FAILED"");
    }

    function upgrade(uint256 toVersion_, bytes calldata arguments_) external override {
        require(msg.sender == _borrower, ""ML:U:NOT_BORROWER"");

        emit Upgraded(toVersion_, arguments_);

        IMapleProxyFactory(_factory()).upgradeInstance(toVersion_, arguments_);
    }

    /************************/
    /*** Borrow Functions ***/
    /************************/

    function acceptBorrower() external override {
        require(msg.sender == _pendingBorrower, ""ML:AB:NOT_PENDING_BORROWER"");

        _pendingBorrower = address(0);

        emit BorrowerAccepted(_borrower = msg.sender);
    }

    function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:CL:TRANSFER_FROM_FAILED"");

        ( principal_, interest_ ) = _closeLoan();

        emit LoanClosed(principal_, interest_);
    }

    function drawdownFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused returns (uint256 collateralPosted_) {
        require(msg.sender == _borrower, ""ML:DF:NOT_BORROWER"");

        emit FundsDrawnDown(amount_, destination_);

        // Post additional collateral required to facilitate this drawdown, if needed.
        uint256 additionalCollateralRequired = getAdditionalCollateralRequiredFor(amount_);

        if (additionalCollateralRequired > uint256(0)) {
            // Determine collateral currently unaccounted for.
            uint256 unaccountedCollateral = _getUnaccountedAmount(_collateralAsset);

            // Post required collateral, specifying then amount lacking as the optional amount to be transferred from.
            collateralPosted_ = postCollateral(
                additionalCollateralRequired > unaccountedCollateral ? additionalCollateralRequired - unaccountedCollateral : uint256(0)
            );
        }

        _drawdownFunds(amount_, destination_);
    }

    function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:MP:TRANSFER_FROM_FAILED"");

        ( principal_, interest_ ) = _makePayment();

        emit PaymentMade(principal_, interest_);
    }

    function postCollateral(uint256 amount_) public override whenProtocolNotPaused returns (uint256 collateralPosted_) {
        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(
            amount_ == uint256(0) || ERC20Helper.transferFrom(_collateralAsset, msg.sender, address(this), amount_),
            ""ML:PC:TRANSFER_FROM_FAILED""
        );

        emit CollateralPosted(collateralPosted_ = _postCollateral());
    }

    function proposeNewTerms(address refinancer_, bytes[] calldata calls_) external override whenProtocolNotPaused {
        require(msg.sender == _borrower, ""ML:PNT:NOT_BORROWER"");

        emit NewTermsProposed(_proposeNewTerms(refinancer_, calls_), refinancer_, calls_);
    }

    function removeCollateral(uint256 amount_, address destination_) external override whenProtocolNotPaused {
        require(msg.sender == _borrower, ""ML:RC:NOT_BORROWER"");

        emit CollateralRemoved(amount_, destination_);

        _removeCollateral(amount_, destination_);
    }

    function returnFunds(uint256 amount_) public override whenProtocolNotPaused returns (uint256 fundsReturned_) {
        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:RF:TRANSFER_FROM_FAILED"");

        emit FundsReturned(fundsReturned_ = _returnFunds());
    }

    function setPendingBorrower(address pendingBorrower_) external override {
        require(msg.sender == _borrower, ""ML:SPB:NOT_BORROWER"");

        emit PendingBorrowerSet(_pendingBorrower = pendingBorrower_);
    }

    /**********************/
    /*** Lend Functions ***/
    /**********************/

    function acceptLender() external override {
        require(msg.sender == _pendingLender, ""ML:AL:NOT_PENDING_LENDER"");

        _pendingLender = address(0);

        emit LenderAccepted(_lender = msg.sender);
    }

    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external override whenProtocolNotPaused {
        require(msg.sender == _lender, ""ML:ANT:NOT_LENDER"");

        // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:ACT:TRANSFER_FROM_FAILED"");

        emit NewTermsAccepted(_acceptNewTerms(refinancer_, calls_), refinancer_, calls_);

        uint256 extra = _getUnaccountedAmount(_fundsAsset);

        // NOTE: This block ensures unaccounted funds (pre-existing or due to over-funding) gets redirected to the lender.
        if (extra > uint256(0)) {
            emit FundsRedirected(extra, _lender);
            require(ERC20Helper.transfer(_fundsAsset, _lender, extra), ""ML:ANT:TRANSFER_FAILED"");
        }
    }

    function claimFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused {
        require(msg.sender == _lender, ""ML:CF:NOT_LENDER"");

        emit FundsClaimed(amount_, destination_);

        _claimFunds(amount_, destination_);
    }

    function fundLoan(address lender_, uint256 amount_) external override whenProtocolNotPaused returns (uint256 fundsLent_) {
        // The amount specified is an optional amount to be transferred from the caller, as a convenience for EOAs.
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:FL:TRANSFER_FROM_FAILED"");

        // If the loan is not active, fund it.
        if (_nextPaymentDueDate == uint256(0)) {
            emit Funded(lender_, fundsLent_ = _fundLoan(lender_), _nextPaymentDueDate);
        }

        uint256 extra = _getUnaccountedAmount(_fundsAsset);

        // NOTE: This block is not only a stopgap solution to allow a LiquidityLockerV1 to send funds to a DebtLocker, while maintaining PoolV1 accounting,
        //       but also ensures unaccounted funds (pre-existing or due to over-funding) gets redirected to the lender.
        if (extra > uint256(0)) {
            emit FundsRedirected(extra, _lender);
            require(ERC20Helper.transfer(_fundsAsset, _lender, extra), ""ML:FL:TRANSFER_FAILED"");
        }
    }

    function repossess(address destination_) external override whenProtocolNotPaused returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {
        require(msg.sender == _lender, ""ML:R:NOT_LENDER"");

        ( collateralRepossessed_, fundsRepossessed_ ) = _repossess(destination_);

        emit Repossessed(collateralRepossessed_, fundsRepossessed_, destination_);
    }

    function setPendingLender(address pendingLender_) external override {
        require(msg.sender == _lender, ""ML:SPL:NOT_LENDER"");

        emit PendingLenderSet(_pendingLender = pendingLender_);
    }

    /*******************************/
    /*** Miscellaneous Functions ***/
    /*******************************/

    function skim(address token_, address destination_) external override whenProtocolNotPaused returns (uint256 skimmed_) {
        require((msg.sender == _borrower) || (msg.sender == _lender),    ""L:S:NO_AUTH"");
        require((token_ != _fundsAsset) && (token_ != _collateralAsset), ""L:S:INVALID_TOKEN"");

        emit Skimmed(token_, skimmed_ = IERC20(token_).balanceOf(address(this)), destination_);

        require(ERC20Helper.transfer(token_, destination_, skimmed_), ""L:S:TRANSFER_FAILED"");
    }

    /**********************/
    /*** View Functions ***/
    /**********************/

    function getAdditionalCollateralRequiredFor(uint256 drawdown_) public view override returns (uint256 collateral_) {
        // Determine the collateral needed in the contract for a reduced drawable funds amount.
        uint256 collateralNeeded = _getCollateralRequiredFor(_principal, _drawableFunds - drawdown_, _principalRequested, _collateralRequired);

        return collateralNeeded > _collateral ? collateralNeeded - _collateral : uint256(0);
    }

    function getEarlyPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();
    }

    function getNextPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getNextPaymentBreakdown();
    }

    function isProtocolPaused() public view override returns (bool paused_) {
        return IMapleGlobalsLike(IMapleProxyFactory(_factory()).mapleGlobals()).protocolPaused();
    }

    /****************************/
    /*** State View Functions ***/
    /****************************/

    function borrower() external view override returns (address borrower_) {
        return _borrower;
    }

    function claimableFunds() external view override returns (uint256 claimableFunds_) {
        return _claimableFunds;
    }

    function collateral() external view override returns (uint256 collateral_) {
        return _collateral;
    }

    function collateralAsset() external view override returns (address collateralAsset_) {
        return _collateralAsset;
    }

    function collateralRequired() external view override returns (uint256 collateralRequired_) {
        return _collateralRequired;
    }

    function drawableFunds() external view override returns (uint256 drawableFunds_) {
        return _drawableFunds;
    }

    function earlyFeeRate() external view override returns (uint256 earlyFeeRate_) {
        return _earlyFeeRate;
    }

    function endingPrincipal() external view override returns (uint256 endingPrincipal_) {
        return _endingPrincipal;
    }

    function excessCollateral() external view override returns (uint256 excessCollateral_) {
        uint256 collateralNeeded = _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);

        return _collateral > collateralNeeded ? _collateral - collateralNeeded : uint256(0);
    }

    function factory() external view override returns (address factory_) {
        return _factory();
    }

    function fundsAsset() external view override returns (address fundsAsset_) {
        return _fundsAsset;
    }

    function gracePeriod() external view override returns (uint256 gracePeriod_) {
        return _gracePeriod;
    }

    function implementation() external view override returns (address implementation_) {
        return _implementation();
    }

    function interestRate() external view override returns (uint256 interestRate_) {
        return _interestRate;
    }

    function lateFeeRate() external view override returns (uint256 lateFeeRate_) {
        return _lateFeeRate;
    }

    function lateInterestPremium() external view override returns (uint256 lateInterestPremium_) {
        return _lateInterestPremium;
    }

    function lender() external view override returns (address lender_) {
        return _lender;
    }

    function nextPaymentDueDate() external view override returns (uint256 nextPaymentDueDate_) {
        return _nextPaymentDueDate;
    }

    function paymentInterval() external view override returns (uint256 paymentInterval_) {
        return _paymentInterval;
    }

    function paymentsRemaining() external view override returns (uint256 paymentsRemaining_) {
        return _paymentsRemaining;
    }

    function pendingBorrower() external view override returns (address pendingBorrower_) {
        return _pendingBorrower;
    }

    function pendingLender() external view override returns (address pendingLender_) {
        return _pendingLender;
    }

    function principalRequested() external view override returns (uint256 principalRequested_) {
        return _principalRequested;
    }

    function principal() external view override returns (uint256 principal_) {
        return _principal;
    }

    // NOTE: This is needed for `fundLoan` call from PoolV1.
    function superFactory() external view override returns (address superFactory_) {
        return _factory();
    }

}",3055,345,"[H-01] makePayment() Lack of access control allows malicious lender to retrieve a large portion of the funds earlier, making the borrower suffer fund loss

Submitted by WatchPug
MapleLoan.sol L86-L93
function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
    // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
    require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:MP:TRANSFER_FROM_FAILED"");

    ( principal_, interest_ ) = _makePayment();

    emit PaymentMade(principal_, interest_);
}

The current implementation allows anyone to call makePayment() and repay the loan with _drawableFunds.
This makes it possible for a malicious lender to call makePayment() multiple times right after fundLoan() and retrieve most of the funds back immediately, while then borrower must continue to make payments or lose the collateral.
 [M-01] Anyone can call `closeLoan()` to close the loan

Submitted by WatchPug
MapleLoan.sol L56-L63
function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
    // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.
    require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:CL:TRANSFER_FROM_FAILED"");

    ( principal_, interest_ ) = _closeLoan();

    emit LoanClosed(principal_, interest_);
}

Based on the context, we believe that the closeLoan() should only be called by the borrower. However, the current implementation allows anyone to call closeLoan() anytime after fundLoan().
If there is no earlyFee, this enables a griefing attack, causing the borrower and lender to abandon this contract and redo everything which costs more gas.
If a platform fee exits, the lender will also suffer fund loss from the platform fee charged in fundLoan()
",2,,"pragma solidity ^0.8.7;

import { IERC20 }             from ""../modules/erc20/src/interfaces/IERC20.sol"";
import { IMapleProxyFactory } from ""../modules/maple-proxy-factory/contracts/interfaces/IMapleProxyFactory.sol"";

import { ERC20Helper } from ""../modules/erc20-helper/src/ERC20Helper.sol"";

import { IMapleLoan } from ""./interfaces/IMapleLoan.sol"";
import { IMapleGlobalsLike } from ""./interfaces/Interfaces.sol"";

import { MapleLoanInternals } from ""./MapleLoanInternals.sol"";


contract MapleLoan is IMapleLoan, MapleLoanInternals {

    modifier whenProtocolNotPaused() {
        require(!isProtocolPaused(), ""ML:PROTOCOL_PAUSED"");
        _;
    }

    
    
    

    function migrate(address migrator_, bytes calldata arguments_) external override {
        require(msg.sender == _factory(),        ""ML:M:NOT_FACTORY"");
        require(_migrate(migrator_, arguments_), ""ML:M:FAILED"");
    }

    function setImplementation(address newImplementation_) external override {
        require(msg.sender == _factory(),               ""ML:SI:NOT_FACTORY"");
        require(_setImplementation(newImplementation_), ""ML:SI:FAILED"");
    }

    function upgrade(uint256 toVersion_, bytes calldata arguments_) external override {
        require(msg.sender == _borrower, ""ML:U:NOT_BORROWER"");

        emit Upgraded(toVersion_, arguments_);

        IMapleProxyFactory(_factory()).upgradeInstance(toVersion_, arguments_);
    }

    
    
    

    function acceptBorrower() external override {
        require(msg.sender == _pendingBorrower, ""ML:AB:NOT_PENDING_BORROWER"");

        _pendingBorrower = address(0);

        emit BorrowerAccepted(_borrower = msg.sender);
    }

    function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:CL:TRANSFER_FROM_FAILED"");

        ( principal_, interest_ ) = _closeLoan();

        emit LoanClosed(principal_, interest_);
    }

    function drawdownFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused returns (uint256 collateralPosted_) {
        require(msg.sender == _borrower, ""ML:DF:NOT_BORROWER"");

        emit FundsDrawnDown(amount_, destination_);

        
        uint256 additionalCollateralRequired = getAdditionalCollateralRequiredFor(amount_);

        if (additionalCollateralRequired > uint256(0)) {
            
            uint256 unaccountedCollateral = _getUnaccountedAmount(_collateralAsset);

            
            collateralPosted_ = postCollateral(
                additionalCollateralRequired > unaccountedCollateral ? additionalCollateralRequired - unaccountedCollateral : uint256(0)
            );
        }

        _drawdownFunds(amount_, destination_);
    }

    function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {
        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:MP:TRANSFER_FROM_FAILED"");

        ( principal_, interest_ ) = _makePayment();

        emit PaymentMade(principal_, interest_);
    }

    function postCollateral(uint256 amount_) public override whenProtocolNotPaused returns (uint256 collateralPosted_) {
        
        require(
            amount_ == uint256(0) || ERC20Helper.transferFrom(_collateralAsset, msg.sender, address(this), amount_),
            ""ML:PC:TRANSFER_FROM_FAILED""
        );

        emit CollateralPosted(collateralPosted_ = _postCollateral());
    }

    function proposeNewTerms(address refinancer_, bytes[] calldata calls_) external override whenProtocolNotPaused {
        require(msg.sender == _borrower, ""ML:PNT:NOT_BORROWER"");

        emit NewTermsProposed(_proposeNewTerms(refinancer_, calls_), refinancer_, calls_);
    }

    function removeCollateral(uint256 amount_, address destination_) external override whenProtocolNotPaused {
        require(msg.sender == _borrower, ""ML:RC:NOT_BORROWER"");

        emit CollateralRemoved(amount_, destination_);

        _removeCollateral(amount_, destination_);
    }

    function returnFunds(uint256 amount_) public override whenProtocolNotPaused returns (uint256 fundsReturned_) {
        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:RF:TRANSFER_FROM_FAILED"");

        emit FundsReturned(fundsReturned_ = _returnFunds());
    }

    function setPendingBorrower(address pendingBorrower_) external override {
        require(msg.sender == _borrower, ""ML:SPB:NOT_BORROWER"");

        emit PendingBorrowerSet(_pendingBorrower = pendingBorrower_);
    }

    
    
    

    function acceptLender() external override {
        require(msg.sender == _pendingLender, ""ML:AL:NOT_PENDING_LENDER"");

        _pendingLender = address(0);

        emit LenderAccepted(_lender = msg.sender);
    }

    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external override whenProtocolNotPaused {
        require(msg.sender == _lender, ""ML:ANT:NOT_LENDER"");

        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:ACT:TRANSFER_FROM_FAILED"");

        emit NewTermsAccepted(_acceptNewTerms(refinancer_, calls_), refinancer_, calls_);

        uint256 extra = _getUnaccountedAmount(_fundsAsset);

        
        if (extra > uint256(0)) {
            emit FundsRedirected(extra, _lender);
            require(ERC20Helper.transfer(_fundsAsset, _lender, extra), ""ML:ANT:TRANSFER_FAILED"");
        }
    }

    function claimFunds(uint256 amount_, address destination_) external override whenProtocolNotPaused {
        require(msg.sender == _lender, ""ML:CF:NOT_LENDER"");

        emit FundsClaimed(amount_, destination_);

        _claimFunds(amount_, destination_);
    }

    function fundLoan(address lender_, uint256 amount_) external override whenProtocolNotPaused returns (uint256 fundsLent_) {
        
        require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), ""ML:FL:TRANSFER_FROM_FAILED"");

        
        if (_nextPaymentDueDate == uint256(0)) {
            emit Funded(lender_, fundsLent_ = _fundLoan(lender_), _nextPaymentDueDate);
        }

        uint256 extra = _getUnaccountedAmount(_fundsAsset);

        
        
        if (extra > uint256(0)) {
            emit FundsRedirected(extra, _lender);
            require(ERC20Helper.transfer(_fundsAsset, _lender, extra), ""ML:FL:TRANSFER_FAILED"");
        }
    }

    function repossess(address destination_) external override whenProtocolNotPaused returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {
        require(msg.sender == _lender, ""ML:R:NOT_LENDER"");

        ( collateralRepossessed_, fundsRepossessed_ ) = _repossess(destination_);

        emit Repossessed(collateralRepossessed_, fundsRepossessed_, destination_);
    }

    function setPendingLender(address pendingLender_) external override {
        require(msg.sender == _lender, ""ML:SPL:NOT_LENDER"");

        emit PendingLenderSet(_pendingLender = pendingLender_);
    }

    
    
    

    function skim(address token_, address destination_) external override whenProtocolNotPaused returns (uint256 skimmed_) {
        require((msg.sender == _borrower) || (msg.sender == _lender),    ""L:S:NO_AUTH"");
        require((token_ != _fundsAsset) && (token_ != _collateralAsset), ""L:S:INVALID_TOKEN"");

        emit Skimmed(token_, skimmed_ = IERC20(token_).balanceOf(address(this)), destination_);

        require(ERC20Helper.transfer(token_, destination_, skimmed_), ""L:S:TRANSFER_FAILED"");
    }

    
    
    

    function getAdditionalCollateralRequiredFor(uint256 drawdown_) public view override returns (uint256 collateral_) {
        
        uint256 collateralNeeded = _getCollateralRequiredFor(_principal, _drawableFunds - drawdown_, _principalRequested, _collateralRequired);

        return collateralNeeded > _collateral ? collateralNeeded - _collateral : uint256(0);
    }

    function getEarlyPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();
    }

    function getNextPaymentBreakdown() external view override returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getNextPaymentBreakdown();
    }

    function isProtocolPaused() public view override returns (bool paused_) {
        return IMapleGlobalsLike(IMapleProxyFactory(_factory()).mapleGlobals()).protocolPaused();
    }

    
    
    

    function borrower() external view override returns (address borrower_) {
        return _borrower;
    }

    function claimableFunds() external view override returns (uint256 claimableFunds_) {
        return _claimableFunds;
    }

    function collateral() external view override returns (uint256 collateral_) {
        return _collateral;
    }

    function collateralAsset() external view override returns (address collateralAsset_) {
        return _collateralAsset;
    }

    function collateralRequired() external view override returns (uint256 collateralRequired_) {
        return _collateralRequired;
    }

    function drawableFunds() external view override returns (uint256 drawableFunds_) {
        return _drawableFunds;
    }

    function earlyFeeRate() external view override returns (uint256 earlyFeeRate_) {
        return _earlyFeeRate;
    }

    function endingPrincipal() external view override returns (uint256 endingPrincipal_) {
        return _endingPrincipal;
    }

    function excessCollateral() external view override returns (uint256 excessCollateral_) {
        uint256 collateralNeeded = _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);

        return _collateral > collateralNeeded ? _collateral - collateralNeeded : uint256(0);
    }

    function factory() external view override returns (address factory_) {
        return _factory();
    }

    function fundsAsset() external view override returns (address fundsAsset_) {
        return _fundsAsset;
    }

    function gracePeriod() external view override returns (uint256 gracePeriod_) {
        return _gracePeriod;
    }

    function implementation() external view override returns (address implementation_) {
        return _implementation();
    }

    function interestRate() external view override returns (uint256 interestRate_) {
        return _interestRate;
    }

    function lateFeeRate() external view override returns (uint256 lateFeeRate_) {
        return _lateFeeRate;
    }

    function lateInterestPremium() external view override returns (uint256 lateInterestPremium_) {
        return _lateInterestPremium;
    }

    function lender() external view override returns (address lender_) {
        return _lender;
    }

    function nextPaymentDueDate() external view override returns (uint256 nextPaymentDueDate_) {
        return _nextPaymentDueDate;
    }

    function paymentInterval() external view override returns (uint256 paymentInterval_) {
        return _paymentInterval;
    }

    function paymentsRemaining() external view override returns (uint256 paymentsRemaining_) {
        return _paymentsRemaining;
    }

    function pendingBorrower() external view override returns (address pendingBorrower_) {
        return _pendingBorrower;
    }

    function pendingLender() external view override returns (address pendingLender_) {
        return _pendingLender;
    }

    function principalRequested() external view override returns (uint256 principalRequested_) {
        return _principalRequested;
    }

    function principal() external view override returns (uint256 principal_) {
        return _principal;
    }

    
    function superFactory() external view override returns (address superFactory_) {
        return _factory();
    }

}",2642,1,1,,"{'ReviewingTheCode': 'The provided code is a Solidity smart contract named `MapleLoan` that implements a loan management system. It includes functionalities for loan lifecycle management such as fund drawdown, payment, collateral management, and loan closure. The contract interacts with external ERC20 tokens and uses a proxy factory pattern for upgradability.', 'IdentifyingKeyComponents': {'ContractName': 'MapleLoan', 'Purpose': 'To manage the lifecycle of a loan, including fund drawdown, payments, collateral management, and loan closure, while ensuring protocol-level security and upgradability.', 'InheritanceAndImports': {'InheritsFrom': ['MapleLoanInternals', 'IMapleLoan'], 'Imports': ['IERC20', 'IMapleProxyFactory', 'ERC20Helper', 'IMapleGlobalsLike']}, 'StateVariables': [{'Name': '_borrower', 'Type': 'address', 'Purpose': 'Stores the address of the borrower.'}, {'Name': '_pendingBorrower', 'Type': 'address', 'Purpose': 'Stores the address of the pending borrower.'}, {'Name': '_lender', 'Type': 'address', 'Purpose': 'Stores the address of the lender.'}, {'Name': '_pendingLender', 'Type': 'address', 'Purpose': 'Stores the address of the pending lender.'}, {'Name': '_fundsAsset', 'Type': 'address', 'Purpose': 'Stores the address of the ERC20 token used for loan funds.'}, {'Name': '_collateralAsset', 'Type': 'address', 'Purpose': 'Stores the address of the ERC20 token used as collateral.'}, {'Name': '_collateral', 'Type': 'uint256', 'Purpose': 'Stores the amount of collateral posted.'}, {'Name': '_principal', 'Type': 'uint256', 'Purpose': 'Stores the principal amount of the loan.'}, {'Name': '_nextPaymentDueDate', 'Type': 'uint256', 'Purpose': 'Stores the due date for the next payment.'}], 'FunctionsAndModifiers': [{'Name': 'whenProtocolNotPaused', 'Visibility': 'modifier', 'Purpose': 'Ensures the protocol is not paused before executing the function.', 'Parameters': [], 'Returns': []}, {'Name': 'migrate', 'Visibility': 'external', 'Purpose': 'Migrates the loan to a new implementation.', 'Parameters': ['address migrator_', 'bytes calldata arguments_'], 'Returns': []}, {'Name': 'setImplementation', 'Visibility': 'external', 'Purpose': 'Sets a new implementation for the loan.', 'Parameters': ['address newImplementation_'], 'Returns': []}, {'Name': 'upgrade', 'Visibility': 'external', 'Purpose': 'Upgrades the loan to a new version.', 'Parameters': ['uint256 toVersion_', 'bytes calldata arguments_'], 'Returns': []}, {'Name': 'acceptBorrower', 'Visibility': 'external', 'Purpose': 'Accepts the pending borrower.', 'Parameters': [], 'Returns': []}, {'Name': 'closeLoan', 'Visibility': 'external', 'Purpose': 'Closes the loan and returns the principal and interest.', 'Parameters': ['uint256 amount_'], 'Returns': ['uint256 principal_', 'uint256 interest_']}, {'Name': 'drawdownFunds', 'Visibility': 'external', 'Purpose': 'Draws down funds from the loan.', 'Parameters': ['uint256 amount_', 'address destination_'], 'Returns': ['uint256 collateralPosted_']}, {'Name': 'makePayment', 'Visibility': 'external', 'Purpose': 'Makes a payment towards the loan.', 'Parameters': ['uint256 amount_'], 'Returns': ['uint256 principal_', 'uint256 interest_']}, {'Name': 'postCollateral', 'Visibility': 'public', 'Purpose': 'Posts collateral to the loan.', 'Parameters': ['uint256 amount_'], 'Returns': ['uint256 collateralPosted_']}, {'Name': 'proposeNewTerms', 'Visibility': 'external', 'Purpose': 'Proposes new terms for the loan.', 'Parameters': ['address refinancer_', 'bytes[] calldata calls_'], 'Returns': []}, {'Name': 'removeCollateral', 'Visibility': 'external', 'Purpose': 'Removes collateral from the loan.', 'Parameters': ['uint256 amount_', 'address destination_'], 'Returns': []}, {'Name': 'returnFunds', 'Visibility': 'public', 'Purpose': 'Returns funds to the lender.', 'Parameters': ['uint256 amount_'], 'Returns': ['uint256 fundsReturned_']}, {'Name': 'setPendingBorrower', 'Visibility': 'external', 'Purpose': 'Sets a pending borrower.', 'Parameters': ['address pendingBorrower_'], 'Returns': []}, {'Name': 'acceptLender', 'Visibility': 'external', 'Purpose': 'Accepts the pending lender.', 'Parameters': [], 'Returns': []}, {'Name': 'acceptNewTerms', 'Visibility': 'external', 'Purpose': 'Accepts new terms for the loan.', 'Parameters': ['address refinancer_', 'bytes[] calldata calls_', 'uint256 amount_'], 'Returns': []}, {'Name': 'claimFunds', 'Visibility': 'external', 'Purpose': 'Claims funds from the loan.', 'Parameters': ['uint256 amount_', 'address destination_'], 'Returns': []}, {'Name': 'fundLoan', 'Visibility': 'external', 'Purpose': 'Funds the loan.', 'Parameters': ['address lender_', 'uint256 amount_'], 'Returns': ['uint256 fundsLent_']}, {'Name': 'repossess', 'Visibility': 'external', 'Purpose': 'Repossesses collateral and funds.', 'Parameters': ['address destination_'], 'Returns': ['uint256 collateralRepossessed_', 'uint256 fundsRepossessed_']}, {'Name': 'setPendingLender', 'Visibility': 'external', 'Purpose': 'Sets a pending lender.', 'Parameters': ['address pendingLender_'], 'Returns': []}, {'Name': 'skim', 'Visibility': 'external', 'Purpose': 'Skims excess tokens from the contract.', 'Parameters': ['address token_', 'address destination_'], 'Returns': ['uint256 skimmed_']}, {'Name': 'getAdditionalCollateralRequiredFor', 'Visibility': 'public', 'Purpose': 'Calculates the additional collateral required for a drawdown.', 'Parameters': ['uint256 drawdown_'], 'Returns': ['uint256 collateral_']}, {'Name': 'getEarlyPaymentBreakdown', 'Visibility': 'external', 'Purpose': 'Returns the breakdown of an early payment.', 'Parameters': [], 'Returns': ['uint256 principal_', 'uint256 interest_']}, {'Name': 'getNextPaymentBreakdown', 'Visibility': 'external', 'Purpose': 'Returns the breakdown of the next payment.', 'Parameters': [], 'Returns': ['uint256 principal_', 'uint256 interest_']}, {'Name': 'isProtocolPaused', 'Visibility': 'public', 'Purpose': 'Checks if the protocol is paused.', 'Parameters': [], 'Returns': ['bool paused_']}]}, 'ExternalInteractions': ['IERC20 for ERC20 token interactions', 'IMapleProxyFactory for upgradability and factory interactions', 'IMapleGlobalsLike for protocol-level state checks'], 'SpecialMechanisms': ['Proxy Factory Pattern for upgradability', 'ERC20Helper library for safe ERC20 transfers', 'Modifiers for access control and state checks'], 'Questions': ['How is the `_migrate` function implemented in `MapleLoanInternals`?', 'What is the exact logic in `_getCollateralRequiredFor` for calculating collateral requirements?', 'How does the `_proposeNewTerms` function handle the refinancer and calls?', 'What is the purpose of the `_getUnaccountedAmount` function and how is it used?']}","{'Findings': [{'Issue': 'Potential Reentrancy in `closeLoan` Function', 'Severity': 'High', 'Description': 'The `closeLoan` function performs an external call to `ERC20Helper.transferFrom` before updating the state. This could potentially allow a reentrancy attack if the `_fundsAsset` is a malicious contract.', 'Impact': 'An attacker could exploit this to re-enter the function and manipulate the state, potentially leading to loss of funds.', 'Location': 'function closeLoan(uint256 amount_)'}, {'Issue': 'Potential Reentrancy in `drawdownFunds` Function', 'Severity': 'High', 'Description': 'The `drawdownFunds` function calls `_drawdownFunds` after potentially transferring collateral. If `_drawdownFunds` interacts with external contracts or makes external calls, it could be susceptible to reentrancy attacks.', 'Impact': 'An attacker could potentially re-enter the function and manipulate the state or drain funds.', 'Location': 'function drawdownFunds(uint256 amount_, address destination_)'}, {'Issue': 'Insufficient Access Control in `migrate` Function', 'Severity': 'High', 'Description': 'The `migrate` function only checks if the caller is the factory, but it does not validate the `migrator_` address or the `arguments_` passed to it. This could allow a malicious factory to execute arbitrary code or migrate the contract to an unsafe state.', 'Impact': 'Potential for unauthorized contract migration leading to loss of funds or control over the contract.', 'Location': 'function migrate(address migrator_, bytes calldata arguments_)'}, {'Issue': 'Uninitialized State Variables', 'Severity': 'High', 'Description': 'The contract does not initialize several state variables (e.g., `_borrower`, `_lender`, `_pendingBorrower`, `_pendingLender`). Uninitialized state variables can lead to unexpected behavior and vulnerabilities.', 'Impact': 'Potential for unexpected behavior or exploitation due to uninitialized state variables.', 'Location': 'State variables throughout the contract'}, {'Issue': 'Lack of Access Control in `skim` Function', 'Severity': 'Medium', 'Description': 'The `skim` function allows any address that is either the borrower or the lender to transfer any token (excluding the funds and collateral assets) from the contract. This could potentially allow a malicious borrower or lender to drain unintended tokens from the contract.', 'Impact': 'Potential loss of tokens that are not intended to be part of the loan agreement.', 'Location': 'function skim(address token_, address destination_)'}, {'Issue': 'Unchecked External Call in `upgrade` Function', 'Severity': 'Medium', 'Description': 'The `upgrade` function makes an external call to `IMapleProxyFactory(_factory()).upgradeInstance(toVersion_, arguments_)` without checking the return value. If the call fails, the function will not revert, potentially leading to an inconsistent state.', 'Impact': 'The contract might end up in an inconsistent state if the external call fails silently.', 'Location': 'function upgrade(uint256 toVersion_, bytes calldata arguments_)'}, {'Issue': 'Insufficient Collateral Check in `drawdownFunds` Function', 'Severity': 'Medium', 'Description': 'The `drawdownFunds` function calculates the additional collateral required but does not enforce that the borrower has actually posted the required collateral before allowing the drawdown. This could lead to under-collateralized loans.', 'Impact': 'Under-collateralized loans could lead to financial losses for the lender if the borrower defaults.', 'Location': 'function drawdownFunds(uint256 amount_, address destination_)'}, {'Issue': 'Potential Front-Running in `acceptBorrower` and `acceptLender` Functions', 'Severity': 'Medium', 'Description': 'The `acceptBorrower` and `acceptLender` functions allow the pending borrower or lender to accept their role. However, there is no mechanism to prevent front-running attacks where a malicious actor could intercept and replace the pending address.', 'Impact': 'A malicious actor could front-run the transaction and set themselves as the borrower or lender.', 'Location': 'function acceptBorrower() and function acceptLender()'}, {'Issue': 'Potential Integer Overflow in `getAdditionalCollateralRequiredFor` Function', 'Severity': 'Low', 'Description': ""The `getAdditionalCollateralRequiredFor` function performs arithmetic operations without using SafeMath or equivalent checks. While Solidity 0.8.x has built-in overflow checks, it's still a good practice to explicitly handle such cases to avoid potential issues."", 'Impact': 'Potential integer overflow leading to incorrect collateral calculations.', 'Location': 'function getAdditionalCollateralRequiredFor(uint256 drawdown_)'}, {'Issue': 'Missing Event Emission in `setPendingBorrower` and `setPendingLender` Functions', 'Severity': 'Low', 'Description': 'The `setPendingBorrower` and `setPendingLender` functions do not emit events when the pending borrower or lender is set. Emitting events is a best practice for transparency and traceability of state changes.', 'Impact': 'Lack of transparency and traceability in state changes.', 'Location': 'function setPendingBorrower(address pendingBorrower_) and function setPendingLender(address pendingLender_)'}], 'IssueNumber': 30, 'OutputList': 10}",337.39013504981995,"### **[H-01] makePayment() Lack of access control allows malicious lender to retrieve a large portion of the funds earlier, making the borrower suffer fund loss**

**Report Description**:  
The `makePayment()` function in `MapleLoan.sol` lacks access control, allowing anyone (including a malicious lender) to call it. This enables a lender to repeatedly call `makePayment()` immediately after `fundLoan()` to retrieve most of the funds back, while the borrower is still obligated to make payments or risk losing collateral. This design flaw can lead to significant financial loss for the borrower.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of insufficient access control in the `makePayment()` function. The issue is entirely missed, and none of the responses in the list cover the described vulnerability or its impact.

---

### **[M-01] Anyone can call `closeLoan()` to close the loan**

**Report Description**:  
The `closeLoan()` function in `MapleLoan.sol` lacks access control, allowing anyone to call it after `fundLoan()`. This can lead to griefing attacks, where a malicious actor forces the borrower and lender to abandon the contract and redo the process, incurring additional gas costs. If a platform fee exists, the lender may also suffer financial loss due to the fee charged during `fundLoan()`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of insufficient access control in the `closeLoan()` function. While the list includes a finding about reentrancy in `closeLoan()`, it does not cover the access control vulnerability described in the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] makePayment() Lack of access control allows malicious lender to retrieve a large portion of the funds earlier, making the borrower suffer fund loss**  
- **[M-01] Anyone can call `closeLoan()` to close the loan**

---

### **Analysis of Gaps**  
The `response_list` fails to address the core issues of insufficient access control in both `makePayment()` and `closeLoan()` functions. While the list includes findings related to reentrancy and other vulnerabilities, it does not cover the specific risks and impacts described in the issue report. This indicates a significant gap in the response list's coverage of access control vulnerabilities in the contract.","```
None.
```",0.0
MapleLoanInternals.sol,"// SPDX-License-Identifier: AGPL-3.0-or-later
pragma solidity ^0.8.7;

import { IERC20 } from ""../modules/erc20/src/interfaces/IERC20.sol"";

import { ERC20Helper }  from ""../modules/erc20-helper/src/ERC20Helper.sol"";
import { MapleProxied } from ""../modules/maple-proxy-factory/contracts/MapleProxied.sol"";

import { ILenderLike } from ""./interfaces/Interfaces.sol"";

/// @title MapleLoanInternals defines the storage layout and internal logic of MapleLoan.
contract MapleLoanInternals is MapleProxied {

    uint256 private constant SCALED_ONE = uint256(10 ** 18);

    // Roles
    address internal _borrower;         // The address of the borrower.
    address internal _lender;           // The address of the lender.
    address internal _pendingBorrower;  // The address of the pendingBorrower, the only address that can accept the borrower role.
    address internal _pendingLender;    // The address of the pendingLender, the only address that can accept the lender role.

    // Assets
    address internal _collateralAsset;  // The address of the asset used as collateral.
    address internal _fundsAsset;       // The address of the asset used as funds.

    // Loan Term Parameters
    uint256 internal _gracePeriod;      // The number of seconds a payment can be late.
    uint256 internal _paymentInterval;  // The number of seconds between payments.

    // Rates
    uint256 internal _interestRate;         // The annualized interest rate of the loan.
    uint256 internal _earlyFeeRate;         // The fee rate for prematurely closing loans.
    uint256 internal _lateFeeRate;          // The fee rate for late payments.
    uint256 internal _lateInterestPremium;  // The amount to increase the interest rate by for late payments.

    // Requested Amounts
    uint256 internal _collateralRequired;  // The collateral the borrower is expected to put up to draw down all _principalRequested.
    uint256 internal _principalRequested;  // The funds the borrowers wants to borrow.
    uint256 internal _endingPrincipal;     // The principal to remain at end of loan.

    // State
    uint256 internal _drawableFunds;       // The amount of funds that can be drawn down.
    uint256 internal _claimableFunds;      // The amount of funds that the lender can claim (principal repayments, interest, etc).
    uint256 internal _collateral;          // The amount of collateral, in collateral asset, that is currently posted.
    uint256 internal _nextPaymentDueDate;  // The timestamp of due date of next payment.
    uint256 internal _paymentsRemaining;   // The number of payments remaining.
    uint256 internal _principal;           // The amount of principal yet to be paid down.

    // Refinance
    bytes32 internal _refinanceCommitment;

    /**********************************/
    /*** Internal General Functions ***/
    /**********************************/

    /// @dev Clears all state variables to end a loan, but keep borrower and lender withdrawal functionality intact.
    function _clearLoanAccounting() internal {
        _gracePeriod     = uint256(0);
        _paymentInterval = uint256(0);

        _interestRate        = uint256(0);
        _earlyFeeRate        = uint256(0);
        _lateFeeRate         = uint256(0);
        _lateInterestPremium = uint256(0);

        _endingPrincipal = uint256(0);

        _nextPaymentDueDate = uint256(0);
        _paymentsRemaining  = uint256(0);
        _principal          = uint256(0);
    }

    /**
     *  @dev   Initializes the loan.
     *  @param borrower_   The address of the borrower.
     *  @param assets_     Array of asset addresses.
     *                         [0]: collateralAsset,
     *                         [1]: fundsAsset.
     *  @param termDetails_ Array of loan parameters:
     *                         [0]: gracePeriod,
     *                         [1]: paymentInterval,
     *                         [2]: payments,
     *  @param amounts_    Requested amounts:
     *                         [0]: collateralRequired,
     *                         [1]: principalRequested,
     *                         [2]: endingPrincipal.
     *  @param rates_      Fee parameters:
     *                         [0]: interestRate,
     *                         [1]: earlyFeeRate,
     *                         [2]: lateFeeRate,
     *                         [3]: lateInterestPremium.
     */
    function _initialize(
        address borrower_,
        address[2] memory assets_,
        uint256[3] memory termDetails_,
        uint256[3] memory amounts_,
        uint256[4] memory rates_
    )
        internal
    {
        // Principal requested need to be non-zero (see `_getCollateralRequiredFor` math).
        require(amounts_[1] > uint256(0), ""MLI:I:INVALID_PRINCIPAL"");

        // Ending principal needs to be less than or equal to principal requested.
        require(amounts_[2] <= amounts_[1], ""MLI:I:INVALID_ENDING_PRINCIPAL"");

        _borrower = borrower_;

        _collateralAsset = assets_[0];
        _fundsAsset      = assets_[1];

        _gracePeriod       = termDetails_[0];
        _paymentInterval   = termDetails_[1];
        _paymentsRemaining = termDetails_[2];

        _collateralRequired = amounts_[0];
        _principalRequested = amounts_[1];
        _endingPrincipal    = amounts_[2];

        _interestRate        = rates_[0];
        _earlyFeeRate        = rates_[1];
        _lateFeeRate         = rates_[2];
        _lateInterestPremium = rates_[3];
    }

    /**************************************/
    /*** Internal Borrow-side Functions ***/
    /**************************************/

    /// @dev Prematurely ends a loan by making all remaining payments.
    function _closeLoan() internal returns (uint256 principal_, uint256 interest_) {
        require(block.timestamp <= _nextPaymentDueDate, ""MLI:CL:PAYMENT_IS_LATE"");

        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();

        uint256 totalPaid_ = principal_ + interest_;

        // The drawable funds are increased by the extra funds in the contract, minus the total needed for payment.
        _drawableFunds = _drawableFunds + _getUnaccountedAmount(_fundsAsset) - totalPaid_;

        _claimableFunds += totalPaid_;

        _clearLoanAccounting();
    }

    /// @dev Sends `amount_` of `_drawableFunds` to `destination_`.
    function _drawdownFunds(uint256 amount_, address destination_) internal {
        _drawableFunds -= amount_;

        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), ""MLI:DF:TRANSFER_FAILED"");
        require(_isCollateralMaintained(),                                ""MLI:DF:INSUFFICIENT_COLLATERAL"");
    }

    /// @dev Makes a payment to progress the loan closer to maturity.
    function _makePayment() internal returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getNextPaymentBreakdown();

        uint256 totalPaid_ = principal_ + interest_;

        // The drawable funds are increased by the extra funds in the contract, minus the total needed for payment.
        // NOTE: This line will revert if not enough funds were added for the full payment amount.
        _drawableFunds = (_drawableFunds + _getUnaccountedAmount(_fundsAsset)) - totalPaid_;

        _claimableFunds += totalPaid_;

        if (_paymentsRemaining == uint256(1)) {
            _clearLoanAccounting();  // Assumes `_getNextPaymentBreakdown` returns a `principal_` that is `_principal`.
        } else {
            _nextPaymentDueDate += _paymentInterval;
            _principal          -= principal_;
            _paymentsRemaining--;
        }
    }

    /// @dev Registers the delivery of an amount of collateral to be posted.
    function _postCollateral() internal returns (uint256 collateralPosted_) {
        _collateral += (collateralPosted_ = _getUnaccountedAmount(_collateralAsset));
    }

    /// @dev Sets refinance commitment given refinance operations.
    function _proposeNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 proposedRefinanceCommitment_) {
        // NOTE: There is no way to invalidate the `refinanceCommitment` (i.e. bytes32(0)) without explicitly setting it if `calls_.length` is 0.
        return _refinanceCommitment =
            calls_.length > uint256(0)
                ? _getRefinanceCommitment(refinancer_, calls_)
                : bytes32(0);
    }

    /// @dev Sends `amount_` of `_collateral` to `destination_`.
    function _removeCollateral(uint256 amount_, address destination_) internal {
        _collateral -= amount_;

        require(ERC20Helper.transfer(_collateralAsset, destination_, amount_), ""MLI:RC:TRANSFER_FAILED"");
        require(_isCollateralMaintained(),                                     ""MLI:RC:INSUFFICIENT_COLLATERAL"");
    }

    /// @dev Registers the delivery of an amount of funds to be returned as `_drawableFunds`.
    function _returnFunds() internal returns (uint256 fundsReturned_) {
        _drawableFunds += (fundsReturned_ = _getUnaccountedAmount(_fundsAsset));
    }

    /************************************/
    /*** Internal Lend-side Functions ***/
    /************************************/

    /// @dev Processes refinance operations.
    function _acceptNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 acceptedRefinanceCommitment_) {
        // NOTE: A zero refinancer address and/or empty calls array will never (probabilistically) match a refinance commitment in storage.
        require(_refinanceCommitment == (acceptedRefinanceCommitment_ = _getRefinanceCommitment(refinancer_, calls_)), ""MLI:ANT:COMMITMENT_MISMATCH"");

        uint256 size;

        assembly {
            size := extcodesize(refinancer_)
        }

        require(size != uint256(0), ""MLI:ANT:INVALID_REFINANCER"");

        // Clear refinance commitment to prevent implications of re-acceptance of another call to `_acceptNewTerms`.
        _refinanceCommitment = bytes32(0);

        uint256 callCount = calls_.length;

        for (uint256 i; i < callCount; ++i) {
            ( bool success, ) = refinancer_.delegatecall(calls_[i]);
            require(success, ""MLI:ANT:FAILED"");
        }

        // Ensure that collateral is maintained after changes made.
        require(_isCollateralMaintained(), ""MLI:ANT:INSUFFICIENT_COLLATERAL"");
    }

    /// @dev Sends `amount_` of `_claimableFunds` to `destination_`.
    /// @dev If `amount_` is higher than `_claimableFunds` the transaction will underflow and revert.
    function _claimFunds(uint256 amount_, address destination_) internal {
        _claimableFunds -= amount_;

        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), ""MLI:CF:TRANSFER_FAILED"");
    }

    /// @dev Fund the loan and kick off the repayment requirements.
    function _fundLoan(address lender_) internal returns (uint256 fundsLent_) {
        // Can only fund loan if there are payments remaining (as defined by the initialization) and no payment is due yet (as set by a funding).
        require((_nextPaymentDueDate == uint256(0)) && (_paymentsRemaining != uint256(0)), ""MLI:FL:LOAN_ACTIVE"");

        _lender             = lender_;
        _nextPaymentDueDate = block.timestamp + _paymentInterval;

        // Amount funded and principal are as requested.
        fundsLent_ = _principal = _principalRequested;

        // Cannot under-fund loan, but over-funding results in additional funds left unaccounted for.
        require(_getUnaccountedAmount(_fundsAsset) >= fundsLent_, ""MLI:FL:WRONG_FUND_AMOUNT"");

        // Transfer the annualized treasury fee, if any, to the Maple treasury, and decrement drawable funds.
        uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

        // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.
        uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

        // Drawable funds is the amount funded, minus any fees.
        _drawableFunds = fundsLent_ - treasuryFee - delegateFee;

        require(
            treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),
            ""MLI:FL:T_TRANSFER_FAILED""
        );

        require(
            delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),
            ""MLI:FL:PD_TRANSFER_FAILED""
        );
    }

    /// @dev Reset all state variables in order to release funds and collateral of a loan in default.
    function _repossess(address destination_) internal returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {
        uint256 nextPaymentDueDate = _nextPaymentDueDate;

        require(
            nextPaymentDueDate != uint256(0) && (block.timestamp > nextPaymentDueDate + _gracePeriod),
            ""MLI:R:NOT_IN_DEFAULT""
        );

        _clearLoanAccounting();

        // Uniquely in `_repossess`, stop accounting for all funds so that they can be swept.
        _collateral     = uint256(0);
        _claimableFunds = uint256(0);
        _drawableFunds  = uint256(0);

        // Either there is no collateral to repossess, or the transfer of the collateral succeeds.
        require(
            (collateralRepossessed_ = _getUnaccountedAmount(_collateralAsset)) == uint256(0) ||
            ERC20Helper.transfer(_collateralAsset, destination_, collateralRepossessed_),
            ""MLI:R:C_TRANSFER_FAILED""
        );

        // Either there are no funds to repossess, or the transfer of the funds succeeds.
        require(
            (fundsRepossessed_ = _getUnaccountedAmount(_fundsAsset)) == uint256(0) ||
            ERC20Helper.transfer(_fundsAsset, destination_, fundsRepossessed_),
            ""MLI:R:F_TRANSFER_FAILED""
        );
    }

    /*******************************/
    /*** Internal View Functions ***/
    /*******************************/

    /// @dev Returns whether the amount of collateral posted is commensurate with the amount of drawn down (outstanding) principal.
    function _isCollateralMaintained() internal view returns (bool isMaintained_) {
        return _collateral >= _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);
    }

    /// @dev Get principal and interest breakdown for paying off the entire loan early.
    function _getEarlyPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {
        principal_ = _principal;
        interest_  = (_principal * _earlyFeeRate) / SCALED_ONE;
    }

    /// @dev Get principal and interest breakdown for next standard payment.
    function _getNextPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getPaymentBreakdown(
            block.timestamp,
            _nextPaymentDueDate,
            _paymentInterval,
            _principal,
            _endingPrincipal,
            _paymentsRemaining,
            _interestRate,
            _lateFeeRate,
            _lateInterestPremium
        );
    }

    /// @dev Returns the amount of an `asset_` that this contract owns, which is not currently accounted for by its state variables.
    function _getUnaccountedAmount(address asset_) internal view virtual returns (uint256 unaccountedAmount_) {
        return IERC20(asset_).balanceOf(address(this))
            - (asset_ == _collateralAsset ? _collateral : uint256(0))                   // `_collateral` is `_collateralAsset` accounted for.
            - (asset_ == _fundsAsset ? _claimableFunds + _drawableFunds : uint256(0));  // `_claimableFunds` and `_drawableFunds` are `_fundsAsset` accounted for.
    }

    /*******************************/
    /*** Internal Pure Functions ***/
    /*******************************/

    /// @dev Returns the total collateral to be posted for some drawn down (outstanding) principal and overall collateral ratio requirement.
    function _getCollateralRequiredFor(
        uint256 principal_,
        uint256 drawableFunds_,
        uint256 principalRequested_,
        uint256 collateralRequired_
    )
        internal pure returns (uint256 collateral_)
    {
        // Where (collateral / outstandingPrincipal) should be greater or equal to (collateralRequired / principalRequested).
        // NOTE: principalRequested_ cannot be 0, which is reasonable, since it means this was never a loan.
        return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_;
    }

    /// @dev Returns principal and interest portions of a payment instalment, given generic, stateless loan parameters.
    function _getInstallment(uint256 principal_, uint256 endingPrincipal_, uint256 interestRate_, uint256 paymentInterval_, uint256 totalPayments_)
        internal pure virtual returns (uint256 principalAmount_, uint256 interestAmount_)
    {
        /*************************************************************************************************\
         *                             |                                                                 *
         * A = installment amount      |      /                         \     /           R           \  *
         * P = principal remaining     |     |  /                 \      |   | ----------------------- | *
         * R = interest rate           | A = | | P * ( 1 + R ) ^ N | - E | * |   /             \       | *
         * N = payments remaining      |     |  \                 /      |   |  | ( 1 + R ) ^ N | - 1  | *
         * E = ending principal target |      \                         /     \  \             /      /  *
         *                             |                                                                 *
         *                             |---------------------------------------------------------------- *
         *                                                                                               *
         * - Where R           is `periodicRate`                                                         *
         * - Where (1 + R) ^ N is `raisedRate`                                                           *
         * - Both of these rates are scaled by 1e18 (e.g., 12% => 0.12 * 10 ** 18)                       *
        \*************************************************************************************************/

        uint256 periodicRate = _getPeriodicInterestRate(interestRate_, paymentInterval_);
        uint256 raisedRate   = _scaledExponent(SCALED_ONE + periodicRate, totalPayments_, SCALED_ONE);

        // NOTE: If a lack of precision in `_scaledExponent` results in a `raisedRate` smaller than one, assume it to be one and simplify the equation.
        if (raisedRate <= SCALED_ONE) return ((principal_ - endingPrincipal_) / totalPayments_, uint256(0));

        uint256 total = ((((principal_ * raisedRate) / SCALED_ONE) - endingPrincipal_) * periodicRate) / (raisedRate - SCALED_ONE);

        interestAmount_  = _getInterest(principal_, interestRate_, paymentInterval_);
        principalAmount_ = total >= interestAmount_ ? total - interestAmount_ : uint256(0);
    }

    /// @dev Returns an amount by applying an annualized and scaled interest rate, to a principal, over an interval of time.
    function _getInterest(uint256 principal_, uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 interest_) {
        return (principal_ * _getPeriodicInterestRate(interestRate_, interval_)) / SCALED_ONE;
    }

    /// @dev Returns total principal and interest portion of a number of payments, given generic, stateless loan parameters and loan state.
    function _getPaymentBreakdown(
        uint256 currentTime_,
        uint256 nextPaymentDueDate_,
        uint256 paymentInterval_,
        uint256 principal_,
        uint256 endingPrincipal_,
        uint256 paymentsRemaining_,
        uint256 interestRate_,
        uint256 lateFeeRate_,
        uint256 lateInterestPremium_
    )
        internal pure virtual
        returns (uint256 principalAmount_, uint256 interestAmount_)
    {
        ( principalAmount_,interestAmount_ ) = _getInstallment(
            principal_,
            endingPrincipal_,
            interestRate_,
            paymentInterval_,
            paymentsRemaining_
        );

        principalAmount_ = paymentsRemaining_ == uint256(1) ? principal_ : principalAmount_;

        if (currentTime_ > nextPaymentDueDate_) {
            interestAmount_ += _getInterest(principal_, interestRate_ + lateInterestPremium_, currentTime_ - nextPaymentDueDate_);
            interestAmount_ += (lateFeeRate_ * principal_) / SCALED_ONE;
        }
    }

    /// @dev Returns the interest rate over an interval, given an annualized interest rate.
    function _getPeriodicInterestRate(uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 periodicInterestRate_) {
        return (interestRate_ * interval_) / uint256(365 days);
    }

    /// @dev Returns refinance commitment given refinance parameters.
    function _getRefinanceCommitment(address refinancer_, bytes[] calldata calls_) internal pure returns (bytes32 refinanceCommitment_) {
        return keccak256(abi.encode(refinancer_, calls_));
    }

    /**
     *  @dev Returns exponentiation of a scaled base value.
     *
     *       Walk through example:
     *       LINE  |  base_          |  exponent_  |  one_  |  result_
     *             |  3_00           |  18         |  1_00  |  0_00
     *        A    |  3_00           |  18         |  1_00  |  1_00
     *        B    |  3_00           |  9          |  1_00  |  1_00
     *        C    |  9_00           |  9          |  1_00  |  1_00
     *        D    |  9_00           |  9          |  1_00  |  9_00
     *        B    |  9_00           |  4          |  1_00  |  9_00
     *        C    |  81_00          |  4          |  1_00  |  9_00
     *        B    |  81_00          |  2          |  1_00  |  9_00
     *        C    |  6_561_00       |  2          |  1_00  |  9_00
     *        B    |  6_561_00       |  1          |  1_00  |  9_00
     *        C    |  43_046_721_00  |  1          |  1_00  |  9_00
     *        D    |  43_046_721_00  |  1          |  1_00  |  387_420_489_00
     *        B    |  43_046_721_00  |  0          |  1_00  |  387_420_489_00
     *
     * Another implementation of this algorithm can be found in Dapphub's DSMath contract:
     * https://github.com/dapphub/ds-math/blob/ce67c0fa9f8262ecd3d76b9e4c026cda6045e96c/src/math.sol#L77
     */
    function _scaledExponent(uint256 base_, uint256 exponent_, uint256 one_) internal pure returns (uint256 result_) {
        // If exponent_ is odd, set result_ to base_, else set to one_.
        result_ = exponent_ & uint256(1) != uint256(0) ? base_ : one_;          // A

        // Divide exponent_ by 2 (overwriting itself) and proceed if not zero.
        while ((exponent_ >>= uint256(1)) != uint256(0)) {                      // B
            base_ = (base_ * base_) / one_;                                     // C

            // If exponent_ is even, go back to top.
            if (exponent_ & uint256(1) == uint256(0)) continue;

            // If exponent_ is odd, multiply result_ is multiplied by base_.
            result_ = (result_ * base_) / one_;                                 // D
        }
    }

}",5492,477,"[M-02] Unsafe implementation of fundLoan() allows attacker to steal collateral from an unfunded loan

Submitted by WatchPug
MapleLoanInternals.sol L257-L273
uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

// Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.
uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

// Drawable funds is the amount funded, minus any fees.
_drawableFunds = fundsLent_ - treasuryFee - delegateFee;

require(
    treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),
    ""MLI:FL:T_TRANSFER_FAILED""
);

require(
    delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),
    ""MLI:FL:PD_TRANSFER_FAILED""
    );

In the current implementation, mapleTreasury, poolDelegate and treasuryFee are taken from user input lender_, which can be faked by setting up a contract with ILenderLike interfaces.
This allows the attacker to set very high fees, making _drawableFunds near 0.
Since mapleTreasury and poolDelegate are also read from lender_, treasuryFee and investorFee can be retrieved back to the attacker.
As a result, the borrower won't get any _drawableFunds while also being unable to remove collateral.
",1,,"pragma solidity ^0.8.7;

import { IERC20 } from ""../modules/erc20/src/interfaces/IERC20.sol"";

import { ERC20Helper }  from ""../modules/erc20-helper/src/ERC20Helper.sol"";
import { MapleProxied } from ""../modules/maple-proxy-factory/contracts/MapleProxied.sol"";

import { ILenderLike } from ""./interfaces/Interfaces.sol"";


contract MapleLoanInternals is MapleProxied {

    uint256 private constant SCALED_ONE = uint256(10 ** 18);

    
    address internal _borrower;         
    address internal _lender;           
    address internal _pendingBorrower;  
    address internal _pendingLender;    

    
    address internal _collateralAsset;  
    address internal _fundsAsset;       

    
    uint256 internal _gracePeriod;      
    uint256 internal _paymentInterval;  

    
    uint256 internal _interestRate;         
    uint256 internal _earlyFeeRate;         
    uint256 internal _lateFeeRate;          
    uint256 internal _lateInterestPremium;  

    
    uint256 internal _collateralRequired;  
    uint256 internal _principalRequested;  
    uint256 internal _endingPrincipal;     

    
    uint256 internal _drawableFunds;       
    uint256 internal _claimableFunds;      
    uint256 internal _collateral;          
    uint256 internal _nextPaymentDueDate;  
    uint256 internal _paymentsRemaining;   
    uint256 internal _principal;           

    
    bytes32 internal _refinanceCommitment;

    
    
    

    
    function _clearLoanAccounting() internal {
        _gracePeriod     = uint256(0);
        _paymentInterval = uint256(0);

        _interestRate        = uint256(0);
        _earlyFeeRate        = uint256(0);
        _lateFeeRate         = uint256(0);
        _lateInterestPremium = uint256(0);

        _endingPrincipal = uint256(0);

        _nextPaymentDueDate = uint256(0);
        _paymentsRemaining  = uint256(0);
        _principal          = uint256(0);
    }

    
    function _initialize(
        address borrower_,
        address[2] memory assets_,
        uint256[3] memory termDetails_,
        uint256[3] memory amounts_,
        uint256[4] memory rates_
    )
        internal
    {
        
        require(amounts_[1] > uint256(0), ""MLI:I:INVALID_PRINCIPAL"");

        
        require(amounts_[2] <= amounts_[1], ""MLI:I:INVALID_ENDING_PRINCIPAL"");

        _borrower = borrower_;

        _collateralAsset = assets_[0];
        _fundsAsset      = assets_[1];

        _gracePeriod       = termDetails_[0];
        _paymentInterval   = termDetails_[1];
        _paymentsRemaining = termDetails_[2];

        _collateralRequired = amounts_[0];
        _principalRequested = amounts_[1];
        _endingPrincipal    = amounts_[2];

        _interestRate        = rates_[0];
        _earlyFeeRate        = rates_[1];
        _lateFeeRate         = rates_[2];
        _lateInterestPremium = rates_[3];
    }

    
    
    

    
    function _closeLoan() internal returns (uint256 principal_, uint256 interest_) {
        require(block.timestamp <= _nextPaymentDueDate, ""MLI:CL:PAYMENT_IS_LATE"");

        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();

        uint256 totalPaid_ = principal_ + interest_;

        
        _drawableFunds = _drawableFunds + _getUnaccountedAmount(_fundsAsset) - totalPaid_;

        _claimableFunds += totalPaid_;

        _clearLoanAccounting();
    }

    
    function _drawdownFunds(uint256 amount_, address destination_) internal {
        _drawableFunds -= amount_;

        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), ""MLI:DF:TRANSFER_FAILED"");
        require(_isCollateralMaintained(),                                ""MLI:DF:INSUFFICIENT_COLLATERAL"");
    }

    
    function _makePayment() internal returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getNextPaymentBreakdown();

        uint256 totalPaid_ = principal_ + interest_;

        
        
        _drawableFunds = (_drawableFunds + _getUnaccountedAmount(_fundsAsset)) - totalPaid_;

        _claimableFunds += totalPaid_;

        if (_paymentsRemaining == uint256(1)) {
            _clearLoanAccounting();  
        } else {
            _nextPaymentDueDate += _paymentInterval;
            _principal          -= principal_;
            _paymentsRemaining--;
        }
    }

    
    function _postCollateral() internal returns (uint256 collateralPosted_) {
        _collateral += (collateralPosted_ = _getUnaccountedAmount(_collateralAsset));
    }

    
    function _proposeNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 proposedRefinanceCommitment_) {
        
        return _refinanceCommitment =
            calls_.length > uint256(0)
                ? _getRefinanceCommitment(refinancer_, calls_)
                : bytes32(0);
    }

    
    function _removeCollateral(uint256 amount_, address destination_) internal {
        _collateral -= amount_;

        require(ERC20Helper.transfer(_collateralAsset, destination_, amount_), ""MLI:RC:TRANSFER_FAILED"");
        require(_isCollateralMaintained(),                                     ""MLI:RC:INSUFFICIENT_COLLATERAL"");
    }

    
    function _returnFunds() internal returns (uint256 fundsReturned_) {
        _drawableFunds += (fundsReturned_ = _getUnaccountedAmount(_fundsAsset));
    }

    
    
    

    
    function _acceptNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 acceptedRefinanceCommitment_) {
        
        require(_refinanceCommitment == (acceptedRefinanceCommitment_ = _getRefinanceCommitment(refinancer_, calls_)), ""MLI:ANT:COMMITMENT_MISMATCH"");

        uint256 size;

        assembly {
            size := extcodesize(refinancer_)
        }

        require(size != uint256(0), ""MLI:ANT:INVALID_REFINANCER"");

        
        _refinanceCommitment = bytes32(0);

        uint256 callCount = calls_.length;

        for (uint256 i; i < callCount; ++i) {
            ( bool success, ) = refinancer_.delegatecall(calls_[i]);
            require(success, ""MLI:ANT:FAILED"");
        }

        
        require(_isCollateralMaintained(), ""MLI:ANT:INSUFFICIENT_COLLATERAL"");
    }

    
    
    function _claimFunds(uint256 amount_, address destination_) internal {
        _claimableFunds -= amount_;

        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), ""MLI:CF:TRANSFER_FAILED"");
    }

    
    function _fundLoan(address lender_) internal returns (uint256 fundsLent_) {
        
        require((_nextPaymentDueDate == uint256(0)) && (_paymentsRemaining != uint256(0)), ""MLI:FL:LOAN_ACTIVE"");

        _lender             = lender_;
        _nextPaymentDueDate = block.timestamp + _paymentInterval;

        
        fundsLent_ = _principal = _principalRequested;

        
        require(_getUnaccountedAmount(_fundsAsset) >= fundsLent_, ""MLI:FL:WRONG_FUND_AMOUNT"");

        
        uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

        
        uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);

        
        _drawableFunds = fundsLent_ - treasuryFee - delegateFee;

        require(
            treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),
            ""MLI:FL:T_TRANSFER_FAILED""
        );

        require(
            delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),
            ""MLI:FL:PD_TRANSFER_FAILED""
        );
    }

    
    function _repossess(address destination_) internal returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {
        uint256 nextPaymentDueDate = _nextPaymentDueDate;

        require(
            nextPaymentDueDate != uint256(0) && (block.timestamp > nextPaymentDueDate + _gracePeriod),
            ""MLI:R:NOT_IN_DEFAULT""
        );

        _clearLoanAccounting();

        
        _collateral     = uint256(0);
        _claimableFunds = uint256(0);
        _drawableFunds  = uint256(0);

        
        require(
            (collateralRepossessed_ = _getUnaccountedAmount(_collateralAsset)) == uint256(0) ||
            ERC20Helper.transfer(_collateralAsset, destination_, collateralRepossessed_),
            ""MLI:R:C_TRANSFER_FAILED""
        );

        
        require(
            (fundsRepossessed_ = _getUnaccountedAmount(_fundsAsset)) == uint256(0) ||
            ERC20Helper.transfer(_fundsAsset, destination_, fundsRepossessed_),
            ""MLI:R:F_TRANSFER_FAILED""
        );
    }

    
    
    

    
    function _isCollateralMaintained() internal view returns (bool isMaintained_) {
        return _collateral >= _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);
    }

    
    function _getEarlyPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {
        principal_ = _principal;
        interest_  = (_principal * _earlyFeeRate) / SCALED_ONE;
    }

    
    function _getNextPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {
        ( principal_, interest_ ) = _getPaymentBreakdown(
            block.timestamp,
            _nextPaymentDueDate,
            _paymentInterval,
            _principal,
            _endingPrincipal,
            _paymentsRemaining,
            _interestRate,
            _lateFeeRate,
            _lateInterestPremium
        );
    }

    
    function _getUnaccountedAmount(address asset_) internal view virtual returns (uint256 unaccountedAmount_) {
        return IERC20(asset_).balanceOf(address(this))
            - (asset_ == _collateralAsset ? _collateral : uint256(0))                   
            - (asset_ == _fundsAsset ? _claimableFunds + _drawableFunds : uint256(0));  
    }

    
    
    

    
    function _getCollateralRequiredFor(
        uint256 principal_,
        uint256 drawableFunds_,
        uint256 principalRequested_,
        uint256 collateralRequired_
    )
        internal pure returns (uint256 collateral_)
    {
        
        
        return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_;
    }

    
    function _getInstallment(uint256 principal_, uint256 endingPrincipal_, uint256 interestRate_, uint256 paymentInterval_, uint256 totalPayments_)
        internal pure virtual returns (uint256 principalAmount_, uint256 interestAmount_)
    {
        

        uint256 periodicRate = _getPeriodicInterestRate(interestRate_, paymentInterval_);
        uint256 raisedRate   = _scaledExponent(SCALED_ONE + periodicRate, totalPayments_, SCALED_ONE);

        
        if (raisedRate <= SCALED_ONE) return ((principal_ - endingPrincipal_) / totalPayments_, uint256(0));

        uint256 total = ((((principal_ * raisedRate) / SCALED_ONE) - endingPrincipal_) * periodicRate) / (raisedRate - SCALED_ONE);

        interestAmount_  = _getInterest(principal_, interestRate_, paymentInterval_);
        principalAmount_ = total >= interestAmount_ ? total - interestAmount_ : uint256(0);
    }

    
    function _getInterest(uint256 principal_, uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 interest_) {
        return (principal_ * _getPeriodicInterestRate(interestRate_, interval_)) / SCALED_ONE;
    }

    
    function _getPaymentBreakdown(
        uint256 currentTime_,
        uint256 nextPaymentDueDate_,
        uint256 paymentInterval_,
        uint256 principal_,
        uint256 endingPrincipal_,
        uint256 paymentsRemaining_,
        uint256 interestRate_,
        uint256 lateFeeRate_,
        uint256 lateInterestPremium_
    )
        internal pure virtual
        returns (uint256 principalAmount_, uint256 interestAmount_)
    {
        ( principalAmount_,interestAmount_ ) = _getInstallment(
            principal_,
            endingPrincipal_,
            interestRate_,
            paymentInterval_,
            paymentsRemaining_
        );

        principalAmount_ = paymentsRemaining_ == uint256(1) ? principal_ : principalAmount_;

        if (currentTime_ > nextPaymentDueDate_) {
            interestAmount_ += _getInterest(principal_, interestRate_ + lateInterestPremium_, currentTime_ - nextPaymentDueDate_);
            interestAmount_ += (lateFeeRate_ * principal_) / SCALED_ONE;
        }
    }

    
    function _getPeriodicInterestRate(uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 periodicInterestRate_) {
        return (interestRate_ * interval_) / uint256(365 days);
    }

    
    function _getRefinanceCommitment(address refinancer_, bytes[] calldata calls_) internal pure returns (bytes32 refinanceCommitment_) {
        return keccak256(abi.encode(refinancer_, calls_));
    }

    
    function _scaledExponent(uint256 base_, uint256 exponent_, uint256 one_) internal pure returns (uint256 result_) {
        
        result_ = exponent_ & uint256(1) != uint256(0) ? base_ : one_;          

        
        while ((exponent_ >>= uint256(1)) != uint256(0)) {                      
            base_ = (base_ * base_) / one_;                                     

            
            if (exponent_ & uint256(1) == uint256(0)) continue;

            
            result_ = (result_ * base_) / one_;                                 
        }
    }

}",3148,0,1,,"{'ReviewingTheCode': 'The provided code snippet is a Solidity smart contract named `MapleLoanInternals` that appears to manage the internal logic of a loan system. It includes functions for initializing loans, managing payments, handling collateral, and dealing with loan refinancing. The contract inherits from `MapleProxied` and uses several imported modules and interfaces to interact with ERC20 tokens and other external contracts.', 'IdentifyingKeyComponents': {'ContractName': 'MapleLoanInternals', 'Purpose': 'To manage the internal logic of a loan system, including loan initialization, payments, collateral management, and refinancing.', 'InheritanceAndImports': {'InheritsFrom': ['MapleProxied'], 'Imports': ['IERC20', 'ERC20Helper', 'MapleProxied', 'ILenderLike']}, 'StateVariables': [{'Name': '_borrower', 'Type': 'address', 'Purpose': 'Stores the address of the borrower.'}, {'Name': '_lender', 'Type': 'address', 'Purpose': 'Stores the address of the lender.'}, {'Name': '_pendingBorrower', 'Type': 'address', 'Purpose': 'Stores the address of a pending borrower.'}, {'Name': '_pendingLender', 'Type': 'address', 'Purpose': 'Stores the address of a pending lender.'}, {'Name': '_collateralAsset', 'Type': 'address', 'Purpose': 'Stores the address of the collateral asset.'}, {'Name': '_fundsAsset', 'Type': 'address', 'Purpose': 'Stores the address of the funds asset.'}, {'Name': '_gracePeriod', 'Type': 'uint256', 'Purpose': 'Stores the grace period for loan payments.'}, {'Name': '_paymentInterval', 'Type': 'uint256', 'Purpose': 'Stores the interval between loan payments.'}, {'Name': '_interestRate', 'Type': 'uint256', 'Purpose': 'Stores the interest rate for the loan.'}, {'Name': '_earlyFeeRate', 'Type': 'uint256', 'Purpose': 'Stores the early fee rate for the loan.'}, {'Name': '_lateFeeRate', 'Type': 'uint256', 'Purpose': 'Stores the late fee rate for the loan.'}, {'Name': '_lateInterestPremium', 'Type': 'uint256', 'Purpose': 'Stores the late interest premium for the loan.'}, {'Name': '_collateralRequired', 'Type': 'uint256', 'Purpose': 'Stores the required collateral for the loan.'}, {'Name': '_principalRequested', 'Type': 'uint256', 'Purpose': 'Stores the requested principal amount for the loan.'}, {'Name': '_endingPrincipal', 'Type': 'uint256', 'Purpose': 'Stores the ending principal amount for the loan.'}, {'Name': '_drawableFunds', 'Type': 'uint256', 'Purpose': 'Stores the amount of funds that can be drawn.'}, {'Name': '_claimableFunds', 'Type': 'uint256', 'Purpose': 'Stores the amount of funds that can be claimed.'}, {'Name': '_collateral', 'Type': 'uint256', 'Purpose': 'Stores the amount of collateral held.'}, {'Name': '_nextPaymentDueDate', 'Type': 'uint256', 'Purpose': 'Stores the due date for the next payment.'}, {'Name': '_paymentsRemaining', 'Type': 'uint256', 'Purpose': 'Stores the number of payments remaining.'}, {'Name': '_principal', 'Type': 'uint256', 'Purpose': 'Stores the current principal amount.'}, {'Name': '_refinanceCommitment', 'Type': 'bytes32', 'Purpose': 'Stores the refinance commitment hash.'}], 'FunctionsAndModifiers': [{'Name': '_clearLoanAccounting', 'Visibility': 'internal', 'Purpose': 'Clears the loan accounting variables.', 'Parameters': [], 'Returns': []}, {'Name': '_initialize', 'Visibility': 'internal', 'Purpose': 'Initializes the loan with the provided parameters.', 'Parameters': ['address borrower_', 'address[2] memory assets_', 'uint256[3] memory termDetails_', 'uint256[3] memory amounts_', 'uint256[4] memory rates_'], 'Returns': []}, {'Name': '_closeLoan', 'Visibility': 'internal', 'Purpose': 'Closes the loan and returns the principal and interest.', 'Parameters': [], 'Returns': ['uint256 principal_', 'uint256 interest_']}, {'Name': '_drawdownFunds', 'Visibility': 'internal', 'Purpose': 'Draws down funds from the loan.', 'Parameters': ['uint256 amount_', 'address destination_'], 'Returns': []}, {'Name': '_makePayment', 'Visibility': 'internal', 'Purpose': 'Makes a payment on the loan.', 'Parameters': [], 'Returns': ['uint256 principal_', 'uint256 interest_']}, {'Name': '_postCollateral', 'Visibility': 'internal', 'Purpose': 'Posts collateral to the loan.', 'Parameters': [], 'Returns': ['uint256 collateralPosted_']}, {'Name': '_proposeNewTerms', 'Visibility': 'internal', 'Purpose': 'Proposes new terms for the loan.', 'Parameters': ['address refinancer_', 'bytes[] calldata calls_'], 'Returns': ['bytes32 proposedRefinanceCommitment_']}, {'Name': '_removeCollateral', 'Visibility': 'internal', 'Purpose': 'Removes collateral from the loan.', 'Parameters': ['uint256 amount_', 'address destination_'], 'Returns': []}, {'Name': '_returnFunds', 'Visibility': 'internal', 'Purpose': 'Returns funds to the loan.', 'Parameters': [], 'Returns': ['uint256 fundsReturned_']}, {'Name': '_acceptNewTerms', 'Visibility': 'internal', 'Purpose': 'Accepts new terms for the loan.', 'Parameters': ['address refinancer_', 'bytes[] calldata calls_'], 'Returns': ['bytes32 acceptedRefinanceCommitment_']}, {'Name': '_claimFunds', 'Visibility': 'internal', 'Purpose': 'Claims funds from the loan.', 'Parameters': ['uint256 amount_', 'address destination_'], 'Returns': []}, {'Name': '_fundLoan', 'Visibility': 'internal', 'Purpose': 'Funds the loan.', 'Parameters': ['address lender_'], 'Returns': ['uint256 fundsLent_']}, {'Name': '_repossess', 'Visibility': 'internal', 'Purpose': 'Repossesses collateral and funds from a defaulted loan.', 'Parameters': ['address destination_'], 'Returns': ['uint256 collateralRepossessed_', 'uint256 fundsRepossessed_']}, {'Name': '_isCollateralMaintained', 'Visibility': 'internal', 'Purpose': 'Checks if the collateral is maintained.', 'Parameters': [], 'Returns': ['bool isMaintained_']}, {'Name': '_getEarlyPaymentBreakdown', 'Visibility': 'internal', 'Purpose': 'Calculates the early payment breakdown.', 'Parameters': [], 'Returns': ['uint256 principal_', 'uint256 interest_']}, {'Name': '_getNextPaymentBreakdown', 'Visibility': 'internal', 'Purpose': 'Calculates the next payment breakdown.', 'Parameters': [], 'Returns': ['uint256 principal_', 'uint256 interest_']}, {'Name': '_getUnaccountedAmount', 'Visibility': 'internal', 'Purpose': 'Gets the unaccounted amount of an asset.', 'Parameters': ['address asset_'], 'Returns': ['uint256 unaccountedAmount_']}, {'Name': '_getCollateralRequiredFor', 'Visibility': 'internal', 'Purpose': 'Calculates the required collateral for a given principal.', 'Parameters': ['uint256 principal_', 'uint256 drawableFunds_', 'uint256 principalRequested_', 'uint256 collateralRequired_'], 'Returns': ['uint256 collateral_']}, {'Name': '_getInstallment', 'Visibility': 'internal', 'Purpose': 'Calculates the installment for a loan payment.', 'Parameters': ['uint256 principal_', 'uint256 endingPrincipal_', 'uint256 interestRate_', 'uint256 paymentInterval_', 'uint256 totalPayments_'], 'Returns': ['uint256 principalAmount_', 'uint256 interestAmount_']}, {'Name': '_getInterest', 'Visibility': 'internal', 'Purpose': 'Calculates the interest for a loan.', 'Parameters': ['uint256 principal_', 'uint256 interestRate_', 'uint256 interval_'], 'Returns': ['uint256 interest_']}, {'Name': '_getPaymentBreakdown', 'Visibility': 'internal', 'Purpose': 'Calculates the payment breakdown for a loan.', 'Parameters': ['uint256 currentTime_', 'uint256 nextPaymentDueDate_', 'uint256 paymentInterval_', 'uint256 principal_', 'uint256 endingPrincipal_', 'uint256 paymentsRemaining_', 'uint256 interestRate_', 'uint256 lateFeeRate_', 'uint256 lateInterestPremium_'], 'Returns': ['uint256 principalAmount_', 'uint256 interestAmount_']}, {'Name': '_getPeriodicInterestRate', 'Visibility': 'internal', 'Purpose': 'Calculates the periodic interest rate.', 'Parameters': ['uint256 interestRate_', 'uint256 interval_'], 'Returns': ['uint256 periodicInterestRate_']}, {'Name': '_getRefinanceCommitment', 'Visibility': 'internal', 'Purpose': 'Calculates the refinance commitment hash.', 'Parameters': ['address refinancer_', 'bytes[] calldata calls_'], 'Returns': ['bytes32 refinanceCommitment_']}, {'Name': '_scaledExponent', 'Visibility': 'internal', 'Purpose': 'Calculates the scaled exponent.', 'Parameters': ['uint256 base_', 'uint256 exponent_', 'uint256 one_'], 'Returns': ['uint256 result_']}]}, 'ExternalInteractions': ['IERC20', 'ERC20Helper', 'ILenderLike'], 'SpecialMechanisms': ['The contract uses a proxy pattern through inheritance from `MapleProxied`.', 'It includes complex financial calculations for loan payments, interest, and collateral requirements.'], 'Questions': ['How is the `_getUnaccountedAmount` function used in the context of the loan accounting?', 'What is the purpose of the `_refinanceCommitment` variable and how is it utilized in the refinancing process?', 'Are there any specific security considerations for the delegatecall in `_acceptNewTerms`?', 'How does the `_scaledExponent` function work, and what are its potential limitations or edge cases?']}","{'Findings': [{'Issue': 'Potential Reentrancy in Token Transfers', 'Severity': 'High', 'Description': 'Multiple functions (`_drawdownFunds`, `_removeCollateral`, `_claimFunds`, `_fundLoan`, `_repossess`) use `ERC20Helper.transfer` for token transfers without implementing checks-effects-interactions pattern. This could lead to reentrancy attacks if the token contract is malicious or has a callback mechanism.', 'Impact': 'An attacker could exploit this to re-enter the contract and manipulate its state, potentially draining funds or causing other unintended behavior.', 'Location': 'Functions: `_drawdownFunds`, `_removeCollateral`, `_claimFunds`, `_fundLoan`, `_repossess`'}, {'Issue': 'Unchecked External Calls in `_acceptNewTerms`', 'Severity': 'High', 'Description': 'The `_acceptNewTerms` function uses `delegatecall` to execute arbitrary calls from the `refinancer_` address. If the `refinancer_` is malicious, it could execute arbitrary code in the context of the contract, potentially leading to severe vulnerabilities.', 'Impact': ""A malicious `refinancer_` could manipulate the contract's state, steal funds, or cause other unintended behavior."", 'Location': 'Function: `_acceptNewTerms`'}, {'Issue': 'Lack of Input Validation in `_initialize`', 'Severity': 'Medium', 'Description': 'The `_initialize` function does not validate input addresses (e.g., `borrower_`, `assets_`). If these addresses are zero or invalid, it could lead to unexpected behavior or loss of funds.', 'Impact': 'Invalid addresses could cause the contract to malfunction, leading to potential fund loss or contract being stuck.', 'Location': 'Function: `_initialize`'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': ""The contract performs arithmetic operations in functions like `_getInstallment`, `_getInterest`, and `_scaledExponent` without explicit checks for overflow/underflow. Although Solidity 0.8.x has built-in checks, it's still good practice to handle such cases explicitly."", 'Impact': 'Incorrect calculations could lead to financial loss or incorrect loan terms.', 'Location': 'Functions: `_getInstallment`, `_getInterest`, `_scaledExponent`'}, {'Issue': 'Insufficient Collateral Check', 'Severity': 'Medium', 'Description': ""The `_isCollateralMaintained` function checks collateral sufficiency but does not account for potential fluctuations in the collateral asset's value, which could lead to under-collateralization."", 'Impact': 'Under-collateralization could result in losses for the lender if the borrower defaults.', 'Location': 'Function: `_isCollateralMaintained`'}, {'Issue': 'Potential Front-Running in Refinancing', 'Severity': 'Medium', 'Description': 'Functions like `_proposeNewTerms` and `_acceptNewTerms` lack mechanisms to prevent front-running. An attacker could intercept and manipulate terms before they are accepted.', 'Impact': 'Front-running could lead to unfair refinancing terms or manipulation of the loan agreement.', 'Location': 'Functions: `_proposeNewTerms`, `_acceptNewTerms`'}, {'Issue': 'Lack of Event Emission', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical state changes (e.g., loan initialization, fund transfers, collateral adjustments). Events are essential for off-chain monitoring and auditing.', 'Impact': 'Lack of transparency and difficulty in tracking contract activities.', 'Location': 'Entire contract'}], 'IssueNumber': 12, 'OutputList': 7}",632.3176159858704,"---

**[M-02] Unsafe implementation of fundLoan() allows attacker to steal collateral from an unfunded loan**

**Report Description**:
The `fundLoan()` function in `MapleLoanInternals.sol` calculates `treasuryFee` and `delegateFee` based on user-provided `lender_` input, which can be faked by setting up a contract with the `ILenderLike` interface. This allows an attacker to set excessively high fees, reducing `_drawableFunds` to near zero. Additionally, since `mapleTreasury` and `poolDelegate` are also read from `lender_`, the attacker can retrieve the fees back to themselves. As a result, the borrower receives no `_drawableFunds` and cannot remove collateral, effectively allowing the attacker to steal the collateral.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of unsafe implementation in `fundLoan()` that allows an attacker to manipulate fees and steal collateral. While the response list covers other vulnerabilities such as reentrancy, unchecked external calls, and input validation, it misses this critical issue entirely. The lack of coverage for this vulnerability represents a significant gap in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-02] Unsafe implementation of fundLoan() allows attacker to steal collateral from an unfunded loan**

---","```
None.
```",0.0
