nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
LaunchEvent.sol,"// SPDX-License-Identifier: None
// Copyright (c) 2022 Trader Joe - All rights reserved

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./interfaces/IJoeFactory.sol"";
import ""./interfaces/IJoePair.sol"";
import ""./interfaces/IJoeRouter02.sol"";
import ""./interfaces/IRocketJoeFactory.sol"";
import ""./interfaces/IRocketJoeToken.sol"";
import ""./interfaces/IWAVAX.sol"";

/// @title Rocket Joe Launch Event
/// @author Trader Joe
/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price
contract LaunchEvent is Ownable {
    /// @notice The phases the launch event can be in
    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw
    enum Phase {
        NotStarted,
        PhaseOne,
        PhaseTwo,
        PhaseThree
    }

    struct UserInfo {
        /// @notice How much AVAX user can deposit for this launch event
        /// @dev Can be increased by burning more rJOE, but will always be
        /// smaller than `maxAllocation`
        uint256 allocation;
        /// @notice How much AVAX user has deposited for this launch event
        uint256 balance;
        /// @notice Whether user has withdrawn the LP
        bool hasWithdrawnPair;
        /// @notice Whether user has withdrawn the issuing token incentives
        bool hasWithdrawnIncentives;
    }

    /// @notice Issuer of sale tokens
    address public issuer;

    /// @notice The start time of phase 1
    uint256 public auctionStart;

    uint256 public PHASE_ONE_DURATION;
    uint256 public PHASE_ONE_NO_FEE_DURATION;
    uint256 public PHASE_TWO_DURATION;

    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,
    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.
    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,
    /// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives
    uint256 public tokenIncentivesPercent;

    /// @notice Floor price in AVAX per token (can be 0)
    /// @dev floorPrice is scaled to 1e18
    uint256 public floorPrice;

    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens
    uint256 public userTimelock;

    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens
    uint256 public issuerTimelock;

    /// @notice The max withdraw penalty during phase 1, in parts per 1e18
    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17
    uint256 public maxWithdrawPenalty;

    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18
    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`
    uint256 public fixedWithdrawPenalty;

    IRocketJoeToken public rJoe;
    uint256 public rJoePerAvax;
    IWAVAX private WAVAX;
    IERC20Metadata public token;

    IJoeRouter02 private router;
    IJoeFactory private factory;
    IRocketJoeFactory public rocketJoeFactory;

    bool private initialized;
    bool public stopped;

    uint256 public maxAllocation;

    mapping(address => UserInfo) public getUserInfo;

    /// @dev The address of the JoePair, set after createLiquidityPool is called
    IJoePair public pair;

    /// @dev The total amount of wavax that was sent to the router to create the initial liquidity pair.
    /// Used to calculate the amount of LP to send based on the user's participation in the launch event
    uint256 private wavaxAllocated;

    /// @dev The exact supply of LP minted when creating the initial liquidity pair.
    uint256 private lpSupply;

    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial
    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`
    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed
    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,
    /// tokenReserve will be equal to 0)
    uint256 private tokenReserve;

    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right
    /// amounts to issuer and users
    uint256 private tokenIncentivesBalance;
    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created
    uint256 private tokenIncentivesForUsers;
    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.
    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there
    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`
    uint256 private tokenIncentiveIssuerRefund;

    /// @dev wavaxReserve is the exact amount of WAVAX that needs to be kept inside the contract in order to send everyone's
    /// WAVAX. If there is some excess (because someone sent token directly to the contract), the
    /// penaltyCollector can collect the excess using `skim()`
    uint256 private wavaxReserve;

    event IssuingTokenDeposited(address indexed token, uint256 amount);

    event UserParticipated(
        address indexed user,
        uint256 avaxAmount,
        uint256 rJoeAmount
    );

    event UserWithdrawn(address indexed user, uint256 avaxAmount);

    event LiquidityPoolCreated(
        address indexed pair,
        address indexed token0,
        address indexed token1,
        uint256 amount0,
        uint256 amount1
    );

    event UserLiquidityWithdrawn(
        address indexed user,
        address indexed pair,
        uint256 amount
    );

    event IssuerLiquidityWithdrawn(
        address indexed issuer,
        address indexed pair,
        uint256 amount
    );

    event Stopped();

    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);

    event TokenEmergencyWithdraw(address indexed user, uint256 amount);

    /// @notice Receive AVAX from the WAVAX contract
    /// @dev Needed for withdrawing from WAVAX contract
    receive() external payable {
        require(
            msg.sender == address(WAVAX),
            ""LaunchEvent: you can't send AVAX directly to this contract""
        );
    }

    /// @notice Modifier which ensures contract is in a defined phase
    modifier atPhase(Phase _phase) {
        _atPhase(_phase);
        _;
    }

    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed
    modifier timelockElapsed() {
        uint256 phase3Start = auctionStart +
            PHASE_ONE_DURATION +
            PHASE_TWO_DURATION;
        if (msg.sender == issuer) {
            require(
                block.timestamp > phase3Start + issuerTimelock,
                ""LaunchEvent: can't withdraw before issuer's timelock""
            );
        } else {
            require(
                block.timestamp > phase3Start + userTimelock,
                ""LaunchEvent: can't withdraw before user's timelock""
            );
        }
        _;
    }

    /// @notice Ensures launch event is stopped/running
    modifier isStopped(bool _stopped) {
        if (_stopped) {
            require(stopped, ""LaunchEvent: is still running"");
        } else {
            require(!stopped, ""LaunchEvent: stopped"");
        }
        _;
    }

    /// @notice Initialise the launch event with needed paramaters
    /// @param _issuer Address of the token issuer
    /// @param _auctionStart The start time of the auction
    /// @param _token The contract address of auctioned token
    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives
    /// @param _floorPrice The minimum price the token is sold at
    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18
    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18
    /// @param _maxAllocation The maximum amount of AVAX depositable
    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity
    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity
    /// @dev This function is called by the factory immediately after it creates the contract instance
    function initialize(
        address _issuer,
        uint256 _auctionStart,
        address _token,
        uint256 _tokenIncentivesPercent,
        uint256 _floorPrice,
        uint256 _maxWithdrawPenalty,
        uint256 _fixedWithdrawPenalty,
        uint256 _maxAllocation,
        uint256 _userTimelock,
        uint256 _issuerTimelock
    ) external atPhase(Phase.NotStarted) {
        require(!initialized, ""LaunchEvent: already initialized"");

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
        WAVAX = IWAVAX(rocketJoeFactory.wavax());
        router = IJoeRouter02(rocketJoeFactory.router());
        factory = IJoeFactory(rocketJoeFactory.factory());
        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());
        rJoePerAvax = rocketJoeFactory.rJoePerAvax();

        require(
            _maxWithdrawPenalty <= 5e17,
            ""LaunchEvent: maxWithdrawPenalty too big""
        ); // 50%
        require(
            _fixedWithdrawPenalty <= 5e17,
            ""LaunchEvent: fixedWithdrawPenalty too big""
        ); // 50%
        require(
            _userTimelock <= 7 days,
            ""LaunchEvent: can't lock user LP for more than 7 days""
        );
        require(
            _issuerTimelock > _userTimelock,
            ""LaunchEvent: issuer can't withdraw before users""
        );
        require(
            _auctionStart > block.timestamp,
            ""LaunchEvent: start of phase 1 cannot be in the past""
        );

        issuer = _issuer;

        auctionStart = _auctionStart;
        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();
        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();
        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();

        token = IERC20Metadata(_token);
        uint256 balance = token.balanceOf(address(this));

        tokenIncentivesPercent = _tokenIncentivesPercent;

        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`
        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).
        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`
        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);
        tokenIncentivesForUsers = balance - tokenReserve;
        tokenIncentivesBalance = tokenIncentivesForUsers;

        floorPrice = _floorPrice;

        maxWithdrawPenalty = _maxWithdrawPenalty;
        fixedWithdrawPenalty = _fixedWithdrawPenalty;

        maxAllocation = _maxAllocation;

        userTimelock = _userTimelock;
        issuerTimelock = _issuerTimelock;
        initialized = true;
    }

    /// @notice The current phase the auction is in
    function currentPhase() public view returns (Phase) {
        if (block.timestamp < auctionStart || auctionStart == 0) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp <
            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }

    /// @notice Deposits AVAX and burns rJoe
    /// @dev Checks are done in the `_depositWAVAX` function
    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Burn tokens and update allocation.
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        wavaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        WAVAX.deposit{value: msg.value}();

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }

    /// @notice Withdraw AVAX, only permitted during phase 1 and 2
    /// @param _amount The amount of AVAX to withdraw
    function withdrawAVAX(uint256 _amount) public isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        wavaxReserve -= _amount;

        WAVAX.withdraw(_amount);
        _safeTransferAVAX(msg.sender, amountMinusFee);
        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
    }

    /// @notice Create the JoePair
    /// @dev Can only be called once after phase 3 has started
    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        require(
            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||
                IJoePair(
                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)
                ).totalSupply() ==
                0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(wavaxReserve > 0, ""LaunchEvent: no wavax balance"");

        uint256 tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (
            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated
        ) {
            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        WAVAX.approve(address(router), wavaxReserve);
        token.approve(address(router), tokenAllocated);

        /// We can't trust the output cause of reflect tokens
        (, , lpSupply) = router.addLiquidity(
            wavaxAddress, // tokenA
            tokenAddress, // tokenB
            wavaxReserve, // amountADesired
            tokenAllocated, // amountBDesired
            wavaxReserve, // amountAMin
            tokenAllocated, // amountBMin
            address(this), // to
            block.timestamp // deadline
        );

        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));
        wavaxAllocated = wavaxReserve;
        wavaxReserve = 0;

        tokenReserve -= tokenAllocated;

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            wavaxAllocated
        );
    }

    /// @notice Withdraw liquidity pool tokens
    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnPair,
            ""LaunchEvent: liquidity already withdrawn""
        );

        uint256 balance = pairBalance(msg.sender);
        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            balance = lpSupply / 2;

            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);

            if (tokenReserve > 0) {
                uint256 amount = tokenReserve;
                tokenReserve = 0;
                token.transfer(msg.sender, amount);
            }
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }

    /// @notice Withdraw incentives tokens
    function withdrawIncentives() external isStopped(false) {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnIncentives,
            ""LaunchEvent: incentives already withdrawn""
        );

        user.hasWithdrawnIncentives = true;
        uint256 amount;

        if (msg.sender == issuer) {
            amount = tokenIncentiveIssuerRefund;
        } else {
            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;
        }

        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        tokenIncentivesBalance -= amount;

        token.transfer(msg.sender, amount);
    }

    /// @notice Withdraw AVAX if launch has been cancelled
    function emergencyWithdraw() external isStopped(true) {
        if (msg.sender != issuer) {
            UserInfo storage user = getUserInfo[msg.sender];
            require(
                user.balance > 0,
                ""LaunchEvent: expected user to have non-zero balance to perform emergency withdraw""
            );

            uint256 balance = user.balance;
            user.balance = 0;
            wavaxReserve -= balance;
            WAVAX.withdraw(balance);

            _safeTransferAVAX(msg.sender, balance);

            emit AvaxEmergencyWithdraw(msg.sender, balance);
        } else {
            uint256 balance = tokenReserve + tokenIncentivesBalance;
            tokenReserve = 0;
            tokenIncentivesBalance = 0;
            token.transfer(issuer, balance);
            emit TokenEmergencyWithdraw(msg.sender, balance);
        }
    }

    /// @notice Stops the launch event and allows participants withdraw deposits
    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }

    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.
    /// Any excess tokens are sent to the penaltyCollector
    function skim() external {
        address penaltyCollector = rocketJoeFactory.penaltyCollector();

        uint256 excessToken = token.balanceOf(address(this)) -
            tokenReserve -
            tokenIncentivesBalance;
        if (excessToken > 0) {
            token.transfer(penaltyCollector, excessToken);
        }

        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;
        if (excessWavax > 0) {
            WAVAX.transfer(penaltyCollector, excessWavax);
        }

        uint256 excessAvax = address(this).balance;
        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);
    }

    /// @notice Returns the current penalty for early withdrawal
    /// @return The penalty to apply to a withdrawal amount
    function getPenalty() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - auctionStart;
        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {
            return 0;
        } else if (timeElapsed < PHASE_ONE_DURATION) {
            return
                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *
                    maxWithdrawPenalty) /
                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);
        }
        return fixedWithdrawPenalty;
    }

    /// @notice Returns the current balance of the pool
    /// @return The balances of WAVAX and issued token held by the launch contract
    function getReserves() external view returns (uint256, uint256) {
        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);
    }

    /// @notice Get the rJOE amount needed to deposit AVAX
    /// @param _avaxAmount The amount of AVAX to deposit
    /// @return The amount of rJOE needed
    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {
        return _avaxAmount * rJoePerAvax;
    }

    /// @notice The total amount of liquidity pool tokens the user can withdraw
    /// @param _user The address of the user to check
    function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        return (user.balance * lpSupply) / wavaxAllocated / 2;
    }

    /// @dev Bytecode size optimization for the `atPhase` modifier.
    /// This works becuase internal functions are not in-lined in modifiers
    function _atPhase(Phase _phase) internal view {
        if (_phase == Phase.NotStarted) {
            require(
                currentPhase() == Phase.NotStarted,
                ""LaunchEvent: not in not started""
            );
        } else if (_phase == Phase.PhaseOne) {
            require(
                currentPhase() == Phase.PhaseOne,
                ""LaunchEvent: not in phase one""
            );
        } else if (_phase == Phase.PhaseTwo) {
            require(
                currentPhase() == Phase.PhaseTwo,
                ""LaunchEvent: not in phase two""
            );
        } else if (_phase == Phase.PhaseThree) {
            require(
                currentPhase() == Phase.PhaseThree,
                ""LaunchEvent: not in phase three""
            );
        } else {
            revert(""LaunchEvent: unknown state"");
        }
    }

    /// @notice Send AVAX
    /// @param _to The receiving address
    /// @param _value The amount of AVAX to send
    /// @dev Will revert on failure
    function _safeTransferAVAX(address _to, uint256 _value) internal {
        (bool success, ) = _to.call{value: _value}(new bytes(0));
        require(success, ""LaunchEvent: avax transfer failed"");
    }
}

",5261,626,"[H-01] Users can lose value in emergency state

Submitted by cmichel, also found by static
Imagine the following sequence of events:
LaunchEvent.createPair() is called which sets wavaxReserve = 0, adds liquidity to the pair and receives lpSupply LP tokens.
LaunchEvent.allowEmergencyWithdraw() is called which enters emergency / paused mode and disallows normal withdrawals.
Users can only call LaunchEvent.emergencyWithdraw which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.
   [H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached

Submitted by cmichel
In LaunchEvent.createPair, when the floor price is not reached (floorPrice > wavaxReserve * 1e18 / tokenAllocated), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.
Note that the floorPrice is supposed to have a precision of 18:
/// @param _floorPrice Price of each token in AVAX, scaled to 1e18
The floorPrice > (wavaxReserve * 1e18) / tokenAllocated check is correct but the tokenAllocated computation involves the token decimals:
// @audit should be wavaxReserve * 1e18 / floorPrice
tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;

This computation does not work for tokens that don't have 18 decimals.
  
[M-02] Owner of LaunchEvent token has the ability to DOS attack the event

The owner of the token for which the `LaunchEvent` was created, has the ability to DOS attack the event. They can prevent the LaunchEvent from creating a JoePair which in turn limits the access to the following two functions: withdrawLiquidity() & withdrawIncentives(). Thus, stopping anybody from withdrawing their LP tokens.
The owner of the RocketJoe platform has the ability to enable the emergency withdrawal allowing the depositors to take back their AVAX. But, they lose their burned rJOE tokens and the gas fees.
The dev team might use this attack vector if they think the price of their token is too low. In that case, they can DOS attack the LaunchEvent. If the RocketJoe owner enables the emergency withdrawal, the dev team is able to take back their initial deposit. Thus, they don't lose anything but their reputation.
  [M-05] Failed transfer with low level call could be overlooked

Submitted by harleythedog, also found by sirhashalot
In LaunchEvent.sol, the function _safeTransferAVAX is as follows:
function _safeTransferAVAX(address _to, uint256 _value) internal {
    (bool success, ) = _to.call{value: _value}(new bytes(0));
    require(success, ""LaunchEvent: avax transfer failed"");
}

This function is utilized in a few different places in the contract. According to the Solidity docs), ""The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed"".
As a result, it is possible that this call will fail, but _safeTransferAVAX will not notice anything went wrong. In particular, it is possible that the address rocketJoeFactory.penaltyCollector() is a deleted contract (perhaps a security flaw was found and selfdestruct was called so that users know to use an updated smart contract), but _safeTransferAVAX will not revert. If rocketJoeFactory.penaltyCollector() is indeed a non-existent contract, it would be better for _safeTransferAVAX to revert until an admin can manually correct the penaltyCollector in the factory.
 
[M-07] withdrawAVAX() function has call to sender without reentrancy protection

Submitted by jayjonah8
In LauchEvent.sol the `withdrawAVAX()` function makes an external call to the msg.sender by way of _safeTransferAVAX. This allows the caller to reenter this and other functions in this and other protocol files. To prevent reentrancy and cross function reentrancy there should be reentrancy guard modifiers placed on the withdrawAVAX() function and any other function that makes external calls to the caller.
 
[M-08] LP Tokens May Be Locked in Contract Due to allowEmergencyWithdraw() in Stage 3

Submitted by kirk-baird
The function `allowEmergencyWithdraw()` may be called by the rocketJoeFactory.owner() at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.
Proof of Concept

If allowEmergencyWithdraw() is called stopped is set to true. As a result functions withdrawIncentives() and withdrawLiquidity() will revert due to the isStopped(false) modifier reverting.
Additionally, emergencyWithdraw() will revert since all the WAVAX and token balances have been transferred to the liquidity pool.
Thus, depositors and issuers will have no methods of removing their LP tokens or incentives.
  [M-09] createPair() expects zero slippage

The LaunchEvent.sol `createPair()` function calls router.addLiquidity() with a amountADesired == amountAMin and amountBDesired == amountBMin. Because there is no allowance for slippage, if the zero slippage requirement is not met then the addLiquidity() function will revert and prevent users from using the createPair() function. This could be caused either by frontrunning the createPair call or in a situation where the liquidity pool exists but does not allow for zero slippage with the assets it is holding.
  [M-10] Use safeTransfer/safeTransferFrom consistently instead of `transfer/transferFrom`
 It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin’s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.
  [M-12] Pair creation can be denied

Submitted by cmichel, also found by harleythedog, UncleGrandpa925, and WatchPug
The LaunchEvent.createPair requires that no previous pool was created for the WAVAX <> _token pair.
function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
    (address wavaxAddress, address tokenAddress) = (
        address(WAVAX),
        address(token)
    );
    // @audit grief: anyone can create pair
    require(
        factory.getPair(wavaxAddress, tokenAddress) == address(0),
        ""LaunchEvent: pair already created""
    );

    // ...
}

A griefer can create a pool for the WAVAX <> _token pair by calling JoeFactory.createPair(WAVAX, _token) while the launch event phase 1 or 2 is running. No liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.
",9,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./interfaces/IJoeFactory.sol"";
import ""./interfaces/IJoePair.sol"";
import ""./interfaces/IJoeRouter02.sol"";
import ""./interfaces/IRocketJoeFactory.sol"";
import ""./interfaces/IRocketJoeToken.sol"";
import ""./interfaces/IWAVAX.sol"";




contract LaunchEvent is Ownable {
    
    
    enum Phase {
        NotStarted,
        PhaseOne,
        PhaseTwo,
        PhaseThree
    }

    struct UserInfo {
        
        
        
        uint256 allocation;
        
        uint256 balance;
        
        bool hasWithdrawnPair;
        
        bool hasWithdrawnIncentives;
    }

    
    address public issuer;

    
    uint256 public auctionStart;

    uint256 public PHASE_ONE_DURATION;
    uint256 public PHASE_ONE_NO_FEE_DURATION;
    uint256 public PHASE_TWO_DURATION;

    
    
    
    
    uint256 public tokenIncentivesPercent;

    
    
    uint256 public floorPrice;

    
    uint256 public userTimelock;

    
    uint256 public issuerTimelock;

    
    
    uint256 public maxWithdrawPenalty;

    
    
    uint256 public fixedWithdrawPenalty;

    IRocketJoeToken public rJoe;
    uint256 public rJoePerAvax;
    IWAVAX private WAVAX;
    IERC20Metadata public token;

    IJoeRouter02 private router;
    IJoeFactory private factory;
    IRocketJoeFactory public rocketJoeFactory;

    bool private initialized;
    bool public stopped;

    uint256 public maxAllocation;

    mapping(address => UserInfo) public getUserInfo;

    
    IJoePair public pair;

    
    
    uint256 private wavaxAllocated;

    
    uint256 private lpSupply;

    
    
    
    
    
    uint256 private tokenReserve;

    
    
    uint256 private tokenIncentivesBalance;
    
    uint256 private tokenIncentivesForUsers;
    
    
    
    uint256 private tokenIncentiveIssuerRefund;

    
    
    
    uint256 private wavaxReserve;

    event IssuingTokenDeposited(address indexed token, uint256 amount);

    event UserParticipated(
        address indexed user,
        uint256 avaxAmount,
        uint256 rJoeAmount
    );

    event UserWithdrawn(address indexed user, uint256 avaxAmount);

    event LiquidityPoolCreated(
        address indexed pair,
        address indexed token0,
        address indexed token1,
        uint256 amount0,
        uint256 amount1
    );

    event UserLiquidityWithdrawn(
        address indexed user,
        address indexed pair,
        uint256 amount
    );

    event IssuerLiquidityWithdrawn(
        address indexed issuer,
        address indexed pair,
        uint256 amount
    );

    event Stopped();

    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);

    event TokenEmergencyWithdraw(address indexed user, uint256 amount);

    
    
    receive() external payable {
        require(
            msg.sender == address(WAVAX),
            ""LaunchEvent: you can't send AVAX directly to this contract""
        );
    }

    
    modifier atPhase(Phase _phase) {
        _atPhase(_phase);
        _;
    }

    
    modifier timelockElapsed() {
        uint256 phase3Start = auctionStart +
            PHASE_ONE_DURATION +
            PHASE_TWO_DURATION;
        if (msg.sender == issuer) {
            require(
                block.timestamp > phase3Start + issuerTimelock,
                ""LaunchEvent: can't withdraw before issuer's timelock""
            );
        } else {
            require(
                block.timestamp > phase3Start + userTimelock,
                ""LaunchEvent: can't withdraw before user's timelock""
            );
        }
        _;
    }

    
    modifier isStopped(bool _stopped) {
        if (_stopped) {
            require(stopped, ""LaunchEvent: is still running"");
        } else {
            require(!stopped, ""LaunchEvent: stopped"");
        }
        _;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    function initialize(
        address _issuer,
        uint256 _auctionStart,
        address _token,
        uint256 _tokenIncentivesPercent,
        uint256 _floorPrice,
        uint256 _maxWithdrawPenalty,
        uint256 _fixedWithdrawPenalty,
        uint256 _maxAllocation,
        uint256 _userTimelock,
        uint256 _issuerTimelock
    ) external atPhase(Phase.NotStarted) {
        require(!initialized, ""LaunchEvent: already initialized"");

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
        WAVAX = IWAVAX(rocketJoeFactory.wavax());
        router = IJoeRouter02(rocketJoeFactory.router());
        factory = IJoeFactory(rocketJoeFactory.factory());
        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());
        rJoePerAvax = rocketJoeFactory.rJoePerAvax();

        require(
            _maxWithdrawPenalty <= 5e17,
            ""LaunchEvent: maxWithdrawPenalty too big""
        ); 
        require(
            _fixedWithdrawPenalty <= 5e17,
            ""LaunchEvent: fixedWithdrawPenalty too big""
        ); 
        require(
            _userTimelock <= 7 days,
            ""LaunchEvent: can't lock user LP for more than 7 days""
        );
        require(
            _issuerTimelock > _userTimelock,
            ""LaunchEvent: issuer can't withdraw before users""
        );
        require(
            _auctionStart > block.timestamp,
            ""LaunchEvent: start of phase 1 cannot be in the past""
        );

        issuer = _issuer;

        auctionStart = _auctionStart;
        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();
        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();
        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();

        token = IERC20Metadata(_token);
        uint256 balance = token.balanceOf(address(this));

        tokenIncentivesPercent = _tokenIncentivesPercent;

        
        
        
        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);
        tokenIncentivesForUsers = balance - tokenReserve;
        tokenIncentivesBalance = tokenIncentivesForUsers;

        floorPrice = _floorPrice;

        maxWithdrawPenalty = _maxWithdrawPenalty;
        fixedWithdrawPenalty = _fixedWithdrawPenalty;

        maxAllocation = _maxAllocation;

        userTimelock = _userTimelock;
        issuerTimelock = _issuerTimelock;
        initialized = true;
    }

    
    function currentPhase() public view returns (Phase) {
        if (block.timestamp < auctionStart || auctionStart == 0) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp <
            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }

    
    
    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        
        if (newAllocation > user.allocation) {
            
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            
            
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        wavaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        WAVAX.deposit{value: msg.value}();

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }

    
    
    function withdrawAVAX(uint256 _amount) public isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        wavaxReserve -= _amount;

        WAVAX.withdraw(_amount);
        _safeTransferAVAX(msg.sender, amountMinusFee);
        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
    }

    
    
    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        require(
            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||
                IJoePair(
                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)
                ).totalSupply() ==
                0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(wavaxReserve > 0, ""LaunchEvent: no wavax balance"");

        uint256 tokenAllocated = tokenReserve;

        
        if (
            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated
        ) {
            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        WAVAX.approve(address(router), wavaxReserve);
        token.approve(address(router), tokenAllocated);

        
        (, , lpSupply) = router.addLiquidity(
            wavaxAddress, 
            tokenAddress, 
            wavaxReserve, 
            tokenAllocated, 
            wavaxReserve, 
            tokenAllocated, 
            address(this), 
            block.timestamp 
        );

        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));
        wavaxAllocated = wavaxReserve;
        wavaxReserve = 0;

        tokenReserve -= tokenAllocated;

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            wavaxAllocated
        );
    }

    
    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnPair,
            ""LaunchEvent: liquidity already withdrawn""
        );

        uint256 balance = pairBalance(msg.sender);
        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            balance = lpSupply / 2;

            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);

            if (tokenReserve > 0) {
                uint256 amount = tokenReserve;
                tokenReserve = 0;
                token.transfer(msg.sender, amount);
            }
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }

    
    function withdrawIncentives() external isStopped(false) {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnIncentives,
            ""LaunchEvent: incentives already withdrawn""
        );

        user.hasWithdrawnIncentives = true;
        uint256 amount;

        if (msg.sender == issuer) {
            amount = tokenIncentiveIssuerRefund;
        } else {
            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;
        }

        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        tokenIncentivesBalance -= amount;

        token.transfer(msg.sender, amount);
    }

    
    function emergencyWithdraw() external isStopped(true) {
        if (msg.sender != issuer) {
            UserInfo storage user = getUserInfo[msg.sender];
            require(
                user.balance > 0,
                ""LaunchEvent: expected user to have non-zero balance to perform emergency withdraw""
            );

            uint256 balance = user.balance;
            user.balance = 0;
            wavaxReserve -= balance;
            WAVAX.withdraw(balance);

            _safeTransferAVAX(msg.sender, balance);

            emit AvaxEmergencyWithdraw(msg.sender, balance);
        } else {
            uint256 balance = tokenReserve + tokenIncentivesBalance;
            tokenReserve = 0;
            tokenIncentivesBalance = 0;
            token.transfer(issuer, balance);
            emit TokenEmergencyWithdraw(msg.sender, balance);
        }
    }

    
    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }

    
    
    function skim() external {
        address penaltyCollector = rocketJoeFactory.penaltyCollector();

        uint256 excessToken = token.balanceOf(address(this)) -
            tokenReserve -
            tokenIncentivesBalance;
        if (excessToken > 0) {
            token.transfer(penaltyCollector, excessToken);
        }

        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;
        if (excessWavax > 0) {
            WAVAX.transfer(penaltyCollector, excessWavax);
        }

        uint256 excessAvax = address(this).balance;
        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);
    }

    
    
    function getPenalty() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - auctionStart;
        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {
            return 0;
        } else if (timeElapsed < PHASE_ONE_DURATION) {
            return
                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *
                    maxWithdrawPenalty) /
                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);
        }
        return fixedWithdrawPenalty;
    }

    
    
    function getReserves() external view returns (uint256, uint256) {
        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);
    }

    
    
    
    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {
        return _avaxAmount * rJoePerAvax;
    }

    
    
    function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        return (user.balance * lpSupply) / wavaxAllocated / 2;
    }

    
    
    function _atPhase(Phase _phase) internal view {
        if (_phase == Phase.NotStarted) {
            require(
                currentPhase() == Phase.NotStarted,
                ""LaunchEvent: not in not started""
            );
        } else if (_phase == Phase.PhaseOne) {
            require(
                currentPhase() == Phase.PhaseOne,
                ""LaunchEvent: not in phase one""
            );
        } else if (_phase == Phase.PhaseTwo) {
            require(
                currentPhase() == Phase.PhaseTwo,
                ""LaunchEvent: not in phase two""
            );
        } else if (_phase == Phase.PhaseThree) {
            require(
                currentPhase() == Phase.PhaseThree,
                ""LaunchEvent: not in phase three""
            );
        } else {
            revert(""LaunchEvent: unknown state"");
        }
    }

    
    
    
    
    function _safeTransferAVAX(address _to, uint256 _value) internal {
        (bool success, ) = _to.call{value: _value}(new bytes(0));
        require(success, ""LaunchEvent: avax transfer failed"");
    }
}",3591,2,7,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities, especially in functions involving AVAX transfers (`depositAVAX`, `withdrawAVAX`, `emergencyWithdraw`)."",
        ""Verify that all arithmetic operations are safe from overflow/underflow, particularly in `depositAVAX`, `withdrawAVAX`, and `createPair`."",
        ""Ensure that external calls (e.g., `WAVAX.deposit`, `router.addLiquidity`) are handled securely and do not introduce vulnerabilities."",
        ""Review the use of `call` in `_safeTransferAVAX` to ensure it is safe from reentrancy and gas limit issues.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-20 standards, especially in token transfers and approvals."",
        ""Ensure that the contract does not violate any regulatory requirements related to token launches or liquidity pools.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic for calculating `tokenReserve`, `tokenIncentivesForUsers`, and `tokenIncentiveIssuerRefund` in `initialize` and `createPair` to ensure correctness."",
        ""Verify the penalty calculation logic in `getPenalty` and its application in `withdrawAVAX`."",
        ""Check the allocation and withdrawal logic in `withdrawLiquidity` and `withdrawIncentives` for correctness and edge cases.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the interactions with external contracts (`WAVAX`, `JoeRouter02`, `JoeFactory`, `RocketJoeFactory`) to ensure they are secure and correctly implemented."",
        ""Verify that the contract handles potential failures in external calls (e.g., `router.addLiquidity`) gracefully.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that only the issuer can call certain functions (e.g., `withdrawLiquidity` for the issuer)."",
        ""Verify that the `allowEmergencyWithdraw` function is restricted to the RocketJoeFactory owner."",
        ""Check that the `initialize` function can only be called once and is restricted to the correct phase.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, particularly in `depositAVAX`, `withdrawAVAX`, and `createPair`."",
        ""Review the use of mappings and loops to ensure they are efficient and do not lead to excessive gas consumption.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Verify that the liquidity pool creation in `createPair` is secure and does not expose the contract to manipulation."",
        ""Check that the `floorPrice` is enforced correctly during liquidity pool creation."",
        ""Ensure that the contract handles edge cases where liquidity pair creation fails or is interrupted.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Review the contract for vulnerabilities to flash loan attacks, particularly in `depositAVAX` and `withdrawAVAX`."",
        ""Ensure that the contract’s logic does not allow for manipulation through flash loans.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Verify that the contract does not rely on external price feeds that could be manipulated."",
        ""Ensure that the `floorPrice` and other price-related calculations are secure and tamper-proof.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Review the `allowEmergencyWithdraw` function to ensure it is secure and cannot be abused."",
        ""Verify that the contract’s governance mechanisms (e.g., timelocks, penalties) are implemented securely.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the incentive distribution in `withdrawIncentives` is fair and secure."",
        ""Verify that the contract does not allow for double withdrawals or other reward-related vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the tokenomics of the launch event to ensure it is not susceptible to inflationary or deflationary risks."",
        ""Verify that the `maxAllocation` and other token-related parameters are set appropriately.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for vulnerabilities to front-running, particularly in `depositAVAX` and `withdrawAVAX`."",
        ""Ensure that the contract’s logic does not allow for manipulation through transaction ordering.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Verify that the contract’s emergency stop mechanism (`allowEmergencyWithdraw`) cannot be abused to drain funds."",
        ""Ensure that the issuer cannot withdraw funds prematurely or without proper checks.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Review the emergency stop mechanism (`allowEmergencyWithdraw`) to ensure it is secure and cannot be abused."",
        ""Verify that the contract can be safely stopped and that funds can be withdrawn securely in an emergency.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `LaunchEvent` is designed to manage a token launch event with multiple phases, including participation, liquidity creation, and withdrawal mechanisms. It handles AVAX deposits, token incentives, and liquidity pool creation while enforcing timelocks and penalties for withdrawals. The contract is modular, relying on external contracts like `WAVAX`, `JoeRouter02`, and `JoeFactory` for core functionalities."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LaunchEvent"",
    ""Purpose"": ""To manage a token launch event with phased participation, liquidity pool creation, and withdrawal mechanisms, while enforcing timelocks and penalties."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"",
        ""./interfaces/IJoeFactory.sol"",
        ""./interfaces/IJoePair.sol"",
        ""./interfaces/IJoeRouter02.sol"",
        ""./interfaces/IRocketJoeFactory.sol"",
        ""./interfaces/IRocketJoeToken.sol"",
        ""./interfaces/IWAVAX.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""issuer"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the issuer who initiates the launch event.""
      },
      {
        ""Name"": ""auctionStart"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp when the auction (Phase One) starts.""
      },
      {
        ""Name"": ""PHASE_ONE_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of Phase One in seconds.""
      },
      {
        ""Name"": ""PHASE_ONE_NO_FEE_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration within Phase One where no withdrawal fees are applied.""
      },
      {
        ""Name"": ""PHASE_TWO_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of Phase Two in seconds.""
      },
      {
        ""Name"": ""tokenIncentivesPercent"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Percentage of tokens allocated as incentives.""
      },
      {
        ""Name"": ""floorPrice"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum price of the token in AVAX.""
      },
      {
        ""Name"": ""userTimelock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Time duration after Phase Three before users can withdraw liquidity.""
      },
      {
        ""Name"": ""issuerTimelock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Time duration after Phase Three before the issuer can withdraw liquidity.""
      },
      {
        ""Name"": ""maxWithdrawPenalty"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum penalty percentage for withdrawing AVAX during Phase One.""
      },
      {
        ""Name"": ""fixedWithdrawPenalty"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fixed penalty percentage for withdrawing AVAX during Phase Two.""
      },
      {
        ""Name"": ""rJoe"",
        ""Type"": ""IRocketJoeToken"",
        ""Purpose"": ""rJoe token contract interface.""
      },
      {
        ""Name"": ""rJoePerAvax"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of rJoe tokens required per AVAX deposited.""
      },
      {
        ""Name"": ""WAVAX"",
        ""Type"": ""IWAVAX"",
        ""Purpose"": ""Wrapped AVAX contract interface.""
      },
      {
        ""Name"": ""token"",
        ""Type"": ""IERC20Metadata"",
        ""Purpose"": ""The token being launched.""
      },
      {
        ""Name"": ""router"",
        ""Type"": ""IJoeRouter02"",
        ""Purpose"": ""JoeRouter02 contract interface for adding liquidity.""
      },
      {
        ""Name"": ""factory"",
        ""Type"": ""IJoeFactory"",
        ""Purpose"": ""JoeFactory contract interface for creating pairs.""
      },
      {
        ""Name"": ""rocketJoeFactory"",
        ""Type"": ""IRocketJoeFactory"",
        ""Purpose"": ""RocketJoeFactory contract interface for factory-specific settings.""
      },
      {
        ""Name"": ""initialized"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to ensure the contract is only initialized once.""
      },
      {
        ""Name"": ""stopped"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to indicate if the contract is in emergency stop mode.""
      },
      {
        ""Name"": ""maxAllocation"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum AVAX amount a user can deposit.""
      },
      {
        ""Name"": ""getUserInfo"",
        ""Type"": ""mapping(address => UserInfo)"",
        ""Purpose"": ""Mapping to store user-specific information.""
      },
      {
        ""Name"": ""pair"",
        ""Type"": ""IJoePair"",
        ""Purpose"": ""Liquidity pair contract interface.""
      },
      {
        ""Name"": ""wavaxAllocated"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of WAVAX allocated to the liquidity pool.""
      },
      {
        ""Name"": ""lpSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total supply of liquidity pool tokens.""
      },
      {
        ""Name"": ""tokenReserve"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of tokens reserved for the liquidity pool.""
      },
      {
        ""Name"": ""tokenIncentivesBalance"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of tokens allocated as incentives.""
      },
      {
        ""Name"": ""tokenIncentivesForUsers"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of incentive tokens allocated to users.""
      },
      {
        ""Name"": ""tokenIncentiveIssuerRefund"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of incentive tokens refunded to the issuer.""
      },
      {
        ""Name"": ""wavaxReserve"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of WAVAX reserved for the liquidity pool.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract with necessary parameters."",
        ""Parameters"": [
          ""_issuer"",
          ""_auctionStart"",
          ""_token"",
          ""_tokenIncentivesPercent"",
          ""_floorPrice"",
          ""_maxWithdrawPenalty"",
          ""_fixedWithdrawPenalty"",
          ""_maxAllocation"",
          ""_userTimelock"",
          ""_issuerTimelock""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""currentPhase"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the current phase of the launch event."",
        ""Parameters"": [],
        ""Returns"": [""Phase""]
      },
      {
        ""Name"": ""depositAVAX"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to deposit AVAX during Phase One."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawAVAX"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to withdraw AVAX during Phase One or Two with a penalty."",
        ""Parameters"": [""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""createPair"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a liquidity pair during Phase Three."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users or the issuer to withdraw liquidity after the timelock."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawIncentives"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users or the issuer to withdraw token incentives."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows emergency withdrawal of AVAX or tokens when the contract is stopped."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""allowEmergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the RocketJoeFactory owner to enable emergency withdrawals."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""skim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers excess tokens or AVAX to the penalty collector."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""getPenalty"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the penalty for withdrawing AVAX."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getReserves"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the current reserves of WAVAX and tokens."",
        ""Parameters"": [],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""getRJoeAmount"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the amount of rJoe required for a given AVAX deposit."",
        ""Parameters"": [""_avaxAmount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""pairBalance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the liquidity pool balance of a user."",
        ""Parameters"": [""_user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_atPhase"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Modifier to ensure the contract is in a specific phase."",
        ""Parameters"": [""_phase""],
        ""Returns"": []
      },
      {
        ""Name"": ""_safeTransferAVAX"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Safely transfers AVAX to a specified address."",
        ""Parameters"": [""_to"", ""_value""],
        ""Returns"": []
      },
      {
        ""Name"": ""timelockElapsed"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the timelock has elapsed before allowing withdrawals."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""isStopped"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the contract is in a specific stopped state."",
        ""Parameters"": [""_stopped""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""WAVAX (IWAVAX)"",
    ""JoeRouter02 (IJoeRouter02)"",
    ""JoeFactory (IJoeFactory)"",
    ""RocketJoeFactory (IRocketJoeFactory)"",
    ""RocketJoeToken (IRocketJoeToken)""
  ],
  ""SpecialMechanisms"": [
    ""Phased Event Management: The contract operates in multiple phases (NotStarted, PhaseOne, PhaseTwo, PhaseThree) with specific rules for each phase."",
    ""Timelock Mechanism: Enforces a timelock for withdrawals, ensuring users and the issuer cannot withdraw liquidity prematurely."",
    ""Penalty System: Implements a dynamic penalty system for AVAX withdrawals during Phase One and a fixed penalty during Phase Two."",
    ""Emergency Stop: Allows the contract to be stopped, enabling emergency withdrawals of AVAX and tokens.""
  ],
  ""Questions"": [
    ""How is the floor price enforced during the creation of the liquidity pair?"",
    ""What happens if the token balance changes after initialization?"",
    ""Are there any checks to prevent reentrancy attacks, especially during AVAX transfers?"",
    ""How are the `tokenIncentivesForUsers` and `tokenIncentiveIssuerRefund` calculated and allocated?"",
    ""Is there a mechanism to handle edge cases where the liquidity pair creation fails?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in `withdrawAVAX` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdrawAVAX` function transfers AVAX to the user before updating the state, making it susceptible to reentrancy attacks. A malicious contract could recursively call the function to drain the contract's AVAX balance."",
      ""Impact"": ""Potential loss of funds due to reentrancy attacks, allowing an attacker to withdraw more AVAX than entitled."",
      ""Location"": ""`withdrawAVAX` function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `initialize` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize` function does not validate critical inputs such as `_token` (ERC20 token address), `_issuer` (zero address check), and `_auctionStart` (reasonable timestamp). This could lead to contract malfunction or exploitation."",
      ""Impact"": ""Invalid inputs may cause unexpected behavior, financial losses, or security vulnerabilities."",
      ""Location"": ""`initialize` function""
    },
    {
      ""Issue"": ""Potential Front-Running in `createPair` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createPair` function lacks mechanisms to prevent front-running, allowing attackers to manipulate liquidity pool creation by observing and front-running transactions."",
      ""Impact"": ""Unfair advantages in liquidity pool creation, potentially leading to financial losses for legitimate users."",
      ""Location"": ""`createPair` function""
    },
    {
      ""Issue"": ""Unrestricted Access to `allowEmergencyWithdraw` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `allowEmergencyWithdraw` function can be called by the owner of `rocketJoeFactory` without additional safeguards. If the owner's account is compromised, an attacker could enable emergency withdrawals prematurely."",
      ""Impact"": ""Unauthorized emergency withdrawals could disrupt contract operations and lead to loss of funds."",
      ""Location"": ""`allowEmergencyWithdraw` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations in functions like `depositAVAX`, `getPenalty`, and `pairBalance` lack overflow/underflow checks, which could lead to incorrect calculations."",
      ""Impact"": ""Incorrect calculations may result in financial discrepancies or contract malfunction."",
      ""Location"": ""`depositAVAX`, `getPenalty`, `pairBalance` functions""
    },
    {
      ""Issue"": ""Lack of Access Control in `skim` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `skim` function allows any user to transfer excess tokens/AVAX to the penalty collector without authorization, risking misuse."",
      ""Impact"": ""Unauthorized transfers could deplete excess funds, affecting contract operations."",
      ""Location"": ""`skim` function""
    },
    {
      ""Issue"": ""Insufficient Event Logging"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical functions like `initialize`, `emergencyWithdraw`, and `skim` do not emit events, reducing transparency and auditability."",
      ""Impact"": ""Difficulty in tracking state changes and auditing contract activity."",
      ""Location"": ""`initialize`, `emergencyWithdraw`, `skim` functions""
    },
    {
      ""Issue"": ""Unbounded Loop in `skim` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `skim` function may incur high gas costs or fail due to out-of-gas errors when processing large amounts of tokens/AVAX."",
      ""Impact"": ""Potential transaction failures or excessive gas costs."",
      ""Location"": ""`skim` function""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 8
}",443.4900302886963,100628.0,24.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Users can lose value in emergency state**

**Report Description**:  
In the `LaunchEvent` contract, if `LaunchEvent.createPair()` is called, it sets `wavaxReserve = 0`, adds liquidity to the pair, and receives LP tokens. If `LaunchEvent.allowEmergencyWithdraw()` is then called, it enters emergency mode, disallowing normal withdrawals. Users can only call `LaunchEvent.emergencyWithdraw`, which reverts because the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users also don't receive their LP tokens, resulting in a total loss of their deposit.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem involves a sequence of events leading to users losing their deposits due to the emergency withdrawal mechanism, which is not covered in the response list.

---

#### **[H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached**

**Report Description**:  
In `LaunchEvent.createPair`, when the floor price is not reached (`floorPrice > wavaxReserve * 1e18 / tokenAllocated`), the tokens sent to the pool are lowered to match the raised WAVAX at the floor price. However, the `tokenAllocated` computation involves the token's decimals, which is incorrect for tokens that don't have 18 decimals. The correct computation should be `wavaxReserve * 1e18 / floorPrice`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, which involves incorrect mathematical operations for tokens with decimals other than 18.

---

#### **[M-02] Owner of LaunchEvent token has the ability to DOS attack the event**

**Report Description**:  
The owner of the token for which the `LaunchEvent` was created can prevent the creation of a `JoePair`, limiting access to `withdrawLiquidity()` and `withdrawIncentives()`. This stops anyone from withdrawing their LP tokens. The owner of the RocketJoe platform can enable emergency withdrawals, allowing depositors to take back their AVAX but lose their burned rJOE tokens and gas fees. This could be used by the dev team if they think the token price is too low.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, which involves a potential denial-of-service (DOS) attack by the token owner.

---

#### **[M-05] Failed transfer with low level call could be overlooked**

**Report Description**:  
In `LaunchEvent.sol`, the function `_safeTransferAVAX` uses a low-level call to transfer AVAX. According to the Solidity docs, low-level calls return `true` if the account called is non-existent. This means the call could fail, but `_safeTransferAVAX` would not notice. If `rocketJoeFactory.penaltyCollector()` is a deleted contract, `_safeTransferAVAX` will not revert, leading to potential issues.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, which involves the potential for failed transfers to be overlooked due to low-level call behavior.

---

#### **[M-07] withdrawAVAX() function has call to sender without reentrancy protection**

**Report Description**:  
In `LaunchEvent.sol`, the `withdrawAVAX()` function makes an external call to `msg.sender` via `_safeTransferAVAX`, allowing the caller to reenter this and other functions. This could lead to reentrancy and cross-function reentrancy attacks. Reentrancy guard modifiers should be added to prevent this.

**Match in Response List**:  
**Correct**. Matches with the issue titled **""Reentrancy Risk in `withdrawAVAX` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy risk in the `withdrawAVAX` function and explains the potential impact, aligning with Solidity best practices.

---

#### **[M-08] LP Tokens May Be Locked in Contract Due to `allowEmergencyWithdraw()` in Stage 3**

**Report Description**:  
The function `allowEmergencyWithdraw()` can be called by the `rocketJoeFactory.owner()` at any time. If called while the protocol is in Stage 3 and a pair has been created, LP tokens will be locked, preventing both issuers and depositors from withdrawing. This is because `withdrawIncentives()` and `withdrawLiquidity()` will revert due to the `isStopped(false)` modifier, and `emergencyWithdraw()` will revert because all WAVAX and token balances have been transferred to the liquidity pool.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, which involves LP tokens being locked due to the emergency withdrawal mechanism.

---

#### **[M-09] `createPair()` expects zero slippage**

**Report Description**:  
The `createPair()` function in `LaunchEvent.sol` calls `router.addLiquidity()` with `amountADesired == amountAMin` and `amountBDesired == amountBMin`, allowing no slippage. If the zero slippage requirement is not met, `addLiquidity()` will revert, preventing users from using the `createPair()` function. This could be caused by frontrunning or a liquidity pool that doesn't allow zero slippage.

**Match in Response List**:  
**Partially Correct**. Matches with the issue titled **""Potential Front-Running in `createPair` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the potential for front-running in `createPair()` but does not address the zero slippage issue, which is a critical aspect of the vulnerability.

---

#### **[M-10] Use safeTransfer/safeTransferFrom consistently instead of `transfer/transferFrom`**

**Report Description**:  
It is recommended to use `safeTransfer` or `safeTransferFrom` instead of `transfer/transferFrom` unless it is certain that the given token reverts on failure. Failure to do so can cause silent transfer failures, affecting token accounting in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, which involves the use of unsafe token transfer methods.

---

#### **[M-12] Pair creation can be denied**

**Report Description**:  
The `LaunchEvent.createPair` function requires that no previous pool was created for the `WAVAX <> _token` pair. A griefer can create a pool for this pair by calling `JoeFactory.createPair(WAVAX, _token)` during phase 1 or 2 of the launch event. This prevents liquidity from being provided, forcing an emergency state for users and the issuer to withdraw.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue, which involves the potential for griefing by denying pair creation.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-07] withdrawAVAX() function has call to sender without reentrancy protection**

**Partially Correct Matches**:

- **[M-09] `createPair()` expects zero slippage**

**Missed Issues from Issue Report**:

- **[H-01] Users can lose value in emergency state**
- **[H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached**
- **[M-02] Owner of LaunchEvent token has the ability to DOS attack the event**
- **[M-05] Failed transfer with low level call could be overlooked**
- **[M-08] LP Tokens May Be Locked in Contract Due to `allowEmergencyWithdraw()` in Stage 3**
- **[M-10] Use safeTransfer/safeTransferFrom consistently instead of `transfer/transferFrom`**
- **[M-12] Pair creation can be denied**

---

The response list covers only one issue correctly and partially addresses another, leaving the majority of the issues in the report unaddressed. This indicates significant gaps in the response list's coverage of the vulnerabilities and risks identified in the issue report.","```
1. Reentrancy Risk in `withdrawAVAX` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Reentrancy Risk in `withdrawAVAX` Function"".
   - This issue appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Average the precision values for all true positives**:
   - There is only one true positive, so the AP is simply the precision at rank 1.

**Average Precision (AP)**:
```
1.0
```"
RocketJoeStaking.sol,"// SPDX-License-Identifier: None

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./RocketJoeToken.sol"";

/// @title Rocket Joe Staking
/// @author Trader Joe
/// @notice Stake JOE to earn rJOE
contract RocketJoeStaking is Initializable, OwnableUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct UserInfo {
        uint256 amount; // How many JOE tokens the user has provided
        uint256 rewardDebt; // Reward debt. See explanation below
        //
        // We do some fancy math here. Basically, any point in time, the amount of JOEs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * accRJoePerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. `accRJoePerShare` (and `lastRewardTimestamp`) gets updated
        //   2. User receives the pending reward sent to his/her address
        //   3. User's `amount` gets updated
        //   4. User's `rewardDebt` gets updated
    }

    IERC20Upgradeable public joe;
    uint256 public lastRewardTimestamp;

    /// @dev Accumulated rJOE per share, times PRECISION. See above
    uint256 public accRJoePerShare;
    /// @notice Precision of accRJoePerShare
    uint256 private PRECISION;

    RocketJoeToken public rJoe;
    uint256 public rJoePerSec;

    /// @dev Info of each user that stakes LP tokens
    mapping(address => UserInfo) public userInfo;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);

    /// @notice Initialize with needed parameters
    /// @param _joe Address of the JOE token contract
    /// @param _rJoe Address of the rJOE token contract
    /// @param _rJoePerSec Number of rJOE tokens created per second
    /// @param _startTime Timestamp at which rJOE rewards starts
    function initialize(
        IERC20Upgradeable _joe,
        RocketJoeToken _rJoe,
        uint256 _rJoePerSec,
        uint256 _startTime
    ) public initializer {
        __Ownable_init();

        require(
            _startTime > block.timestamp,
            ""RocketJoeStaking: rJOE minting needs to start after the current timestamp""
        );

        PRECISION = 1e18;

        joe = _joe;
        rJoe = _rJoe;
        rJoePerSec = _rJoePerSec;
        lastRewardTimestamp = _startTime;
    }

    /// @notice Get pending rJoe for a given `_user`
    /// @param _user The user to lookup
    /// @return The number of pending rJOE tokens for `_user`
    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo storage user = userInfo[_user];
        uint256 joeSupply = joe.balanceOf(address(this));
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }

    /// @notice Deposit joe to RocketJoeStaking for rJoe allocation
    /// @param _amount Amount of JOE to deposit
    function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        if (user.amount > 0) {
            uint256 pending = (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
            _safeRJoeTransfer(msg.sender, pending);
        }
        user.amount = user.amount + _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        joe.safeTransferFrom(address(msg.sender), address(this), _amount);
        emit Deposit(msg.sender, _amount);
    }

    /// @notice Withdraw JOE and accumulated rJOE from RocketJoeStaking
    /// @param _amount Amount of JOE to withdraw
    function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount = user.amount - _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(address(msg.sender), _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY
    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        joe.safeTransfer(address(msg.sender), _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }

    /// @notice Update emission rate
    /// @param _rJoePerSec The new value for rJoePerSec
    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
        updatePool();
        rJoePerSec = _rJoePerSec;
        emit UpdateEmissionRate(msg.sender, _rJoePerSec);
    }

    /// @notice Update reward variables of the given pool with latest data
    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = joe.balanceOf(address(this));
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare =
            accRJoePerShare +
            (rJoeReward * PRECISION) /
            joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }

    /// @notice Safe rJoe transfer function, just in case if rounding error causes pool to not have enough JOEs
    /// @param _to Address that wil receive rJoe
    /// @param _amount The amount to send
    function _safeRJoeTransfer(address _to, uint256 _amount) internal {
        uint256 rJoeBal = rJoe.balanceOf(address(this));
        if (_amount > rJoeBal) {
            rJoe.transfer(_to, rJoeBal);
        } else {
            rJoe.transfer(_to, _amount);
        }
    }
}

",1640,191,"[M-01] Improper Upper Bound Definition on the Fee

Submitted by Jujic
The `rJoePerSec` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.
Proof of Concept

https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L151
``` function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
    updatePool();
    rJoePerSec = _rJoePerSec;
    emit UpdateEmissionRate(msg.sender, _rJoePerSec);
}
```  [M-03] createRJLaunchEvent() can be called by anyone with 1 Wei of _token and stop others from creating RJLaunchEvent with the same token anymore

Submitted by WatchPug, also found by p4st13r4
https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L132
 In the current implementation, RocketJoeFactory.sol#createRJLaunchEvent() can be called by anyone with at least 1 Wei of _token.
This allows a malicious user or attacker to call createRJLaunchEvent() with minimal cost and stop others, especially the platform itself or the rightful issuer of the token from creating the RJLaunchEvent.
  [M-04] Uninitialized RocketJoeStaking.lastRewardTimestamp can inflate rJoe supply

Submitted by cmichel
The `RocketJoeStaking.lastRewardTimestamp` is initialized to zero. Usually, this does not matter as updatePool is called before the first deposit and when joeSupply = joe.balanceOf(address(this)) == 0, it is set to the current time.
 However, if a user first directly transfers Joe tokens to the contract before the first updatePool call, the block.timestamp - lastRewardTimestamp = block.timestamp will be a large timestamp value and lots of rJoe will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the rJoe total supply might not be desired.   [M-06] possibility of minting rJOE tokens before ownership is changed to RocketJoeStaking

Submitted by hubble
There is a possibility of the `rJOE` tokens in RocketJoeToken.sol to be minted by original owner without staking any JOE, before the ownership is transferred to RocketJoeStaking
Proof of Concept

Contract : RocketJoeToken.sol Line : 37  ``` function mint(address _to, uint256 _amount) external onlyOwner { _mint(_to, _amount); } ```
  [M-11] Re-enterable Code When Making a Deposit to Stake

Note: this attack requires rJoe to relinquish control during tranfer() which under the current RocketJoeToken it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.
This vulnerability would allow the entire rJoe balance to be drained from the contract.
",5,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./RocketJoeToken.sol"";




contract RocketJoeStaking is Initializable, OwnableUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct UserInfo {
        uint256 amount; 
        uint256 rewardDebt; 
        
        
        
        
        
        
        
        
        
        
        
    }

    IERC20Upgradeable public joe;
    uint256 public lastRewardTimestamp;

    
    uint256 public accRJoePerShare;
    
    uint256 private PRECISION;

    RocketJoeToken public rJoe;
    uint256 public rJoePerSec;

    
    mapping(address => UserInfo) public userInfo;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);

    
    
    
    
    
    function initialize(
        IERC20Upgradeable _joe,
        RocketJoeToken _rJoe,
        uint256 _rJoePerSec,
        uint256 _startTime
    ) public initializer {
        __Ownable_init();

        require(
            _startTime > block.timestamp,
            ""RocketJoeStaking: rJOE minting needs to start after the current timestamp""
        );

        PRECISION = 1e18;

        joe = _joe;
        rJoe = _rJoe;
        rJoePerSec = _rJoePerSec;
        lastRewardTimestamp = _startTime;
    }

    
    
    
    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo storage user = userInfo[_user];
        uint256 joeSupply = joe.balanceOf(address(this));
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }

    
    
    function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        if (user.amount > 0) {
            uint256 pending = (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
            _safeRJoeTransfer(msg.sender, pending);
        }
        user.amount = user.amount + _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        joe.safeTransferFrom(address(msg.sender), address(this), _amount);
        emit Deposit(msg.sender, _amount);
    }

    
    
    function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount = user.amount - _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(address(msg.sender), _amount);
        emit Withdraw(msg.sender, _amount);
    }

    
    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        joe.safeTransfer(address(msg.sender), _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }

    
    
    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
        updatePool();
        rJoePerSec = _rJoePerSec;
        emit UpdateEmissionRate(msg.sender, _rJoePerSec);
    }

    
    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = joe.balanceOf(address(this));
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare =
            accRJoePerShare +
            (rJoeReward * PRECISION) /
            joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }

    
    
    
    function _safeRJoeTransfer(address _to, uint256 _amount) internal {
        uint256 rJoeBal = rJoe.balanceOf(address(this));
        if (_amount > rJoeBal) {
            rJoe.transfer(_to, rJoeBal);
        } else {
            rJoe.transfer(_to, _amount);
        }
    }
}",1130,0,5,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in deposit, withdraw, and emergencyWithdraw functions."",
        ""Verify that all arithmetic operations are protected against overflow and underflow using SafeMath or Solidity 0.8.x built-in checks."",
        ""Ensure that external calls (e.g., joe.safeTransferFrom, rJoe.transfer) are safe and do not introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to ERC-20 standards for token interactions."",
        ""Verify that the contract follows OpenZeppelin's upgradeable patterns correctly.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the reward calculation logic in pendingRJoe and updatePool functions for accuracy and potential edge cases."",
        ""Ensure that the precision factor (PRECISION) is correctly applied in all calculations.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit the interaction with the JOE and rJOE tokens to ensure they are handled securely."",
        ""Verify that the rJoe.mint function in updatePool is called safely and does not introduce vulnerabilities.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Ensure that only the owner can update the emission rate via updateEmissionRate function."",
        ""Verify that the initialize function can only be called once and is protected against unauthorized access.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, particularly in updatePool and pendingRJoe functions."",
        ""Consider using storage variables more efficiently to reduce gas costs.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the staking and reward distribution mechanisms are secure and cannot be manipulated."",
        ""Verify that the emergencyWithdraw function correctly handles user funds without compromising the reward system.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the emission rate (rJoePerSec) to ensure it does not lead to inflationary issues."",
        ""Assess the impact of large deposits or withdrawals on the reward distribution system.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities in deposit and withdraw functions."",
        ""Consider implementing commit-reveal schemes if necessary to mitigate front-running risks.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the emergencyWithdraw function is a reliable fallback mechanism for users to retrieve their funds."",
        ""Verify that there are no conditions where users could be locked out of their funds.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code is a Solidity smart contract named 'RocketJoeStaking'. It is designed to allow users to stake JOE tokens and earn rJOE tokens as rewards. The contract is upgradeable and uses OpenZeppelin libraries for ERC20 token handling, ownership, and initialization. The contract includes mechanisms for depositing, withdrawing, and emergency withdrawing staked tokens, as well as updating the emission rate of rJOE tokens."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RocketJoeStaking"",
    ""Purpose"": ""To enable staking of JOE tokens and distribute rJOE tokens as rewards."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Initializable"", ""OwnableUpgradeable""],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""./RocketJoeToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""joe"",
        ""Type"": ""IERC20Upgradeable"",
        ""Purpose"": ""The JOE token contract.""
      },
      {
        ""Name"": ""lastRewardTimestamp"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last reward distribution.""
      },
      {
        ""Name"": ""accRJoePerShare"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Accumulated rJOE per share.""
      },
      {
        ""Name"": ""PRECISION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Precision factor for calculations.""
      },
      {
        ""Name"": ""rJoe"",
        ""Type"": ""RocketJoeToken"",
        ""Purpose"": ""The rJOE token contract.""
      },
      {
        ""Name"": ""rJoePerSec"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Emission rate of rJOE tokens per second.""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(address => UserInfo)"",
        ""Purpose"": ""Mapping of user addresses to their staking information.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the JOE token, rJOE token, emission rate, and start time."",
        ""Parameters"": [""IERC20Upgradeable _joe"", ""RocketJoeToken _rJoe"", ""uint256 _rJoePerSec"", ""uint256 _startTime""],
        ""Returns"": []
      },
      {
        ""Name"": ""pendingRJoe"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the pending rJOE rewards for a user."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to deposit JOE tokens for staking."",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw staked JOE tokens."",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw staked JOE tokens without claiming rewards."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updateEmissionRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the emission rate of rJOE tokens."",
        ""Parameters"": [""uint256 _rJoePerSec""],
        ""Returns"": []
      },
      {
        ""Name"": ""updatePool"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the staking pool's reward distribution."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_safeRJoeTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Safely transfers rJOE tokens to a recipient."",
        ""Parameters"": [""address _to"", ""uint256 _amount""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20Upgradeable (JOE token)"",
    ""RocketJoeToken (rJOE token)""
  ],
  ""SpecialMechanisms"": [
    ""The contract uses the Initializable and OwnableUpgradeable patterns for upgradeability and ownership management."",
    ""It implements a staking mechanism where users can deposit JOE tokens and earn rJOE tokens as rewards."",
    ""The contract uses a precision factor (PRECISION) for accurate reward calculations.""
  ],
  ""Questions"": [
    ""How is the initial distribution of rJOE tokens handled?"",
    ""Are there any mechanisms to prevent reentrancy attacks?"",
    ""What happens if the JOE token balance in the contract is zero during reward distribution?"",
    ""Is there a limit to the emission rate of rJOE tokens?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in `deposit` and `withdraw` Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple instances highlight reentrancy risks in `deposit` and `withdraw` functions due to external token transfers (`_safeRJoeTransfer`, `joe.safeTransfer`) being executed before state updates. This could allow attackers to recursively call these functions, potentially draining funds."",
      ""Impact"": ""Loss of funds due to reentrancy attacks, where attackers withdraw more tokens than entitled."",
      ""Location"": ""deposit and withdraw functions across multiple reports""
    },
    {
      ""Issue"": ""Potential Integer Overflow in Reward Calculations"",
      ""Severity"": ""High"",
      ""Description"": ""Arithmetic operations in `updatePool`, `pendingRJoe`, and related functions (e.g., `multiplier * rJoePerSec`, `(rJoeReward * PRECISION) / joeSupply`) risk integer overflow or precision loss, especially with large values. Solidity 0.8.0's built-in checks may not prevent all edge cases."",
      ""Impact"": ""Incorrect reward distribution, financial losses, or contract malfunction."",
      ""Location"": ""updatePool, pendingRJoe, and related functions across multiple reports""
    },
    {
      ""Issue"": ""Lack of Input Validation in `initialize` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize` function fails to validate critical inputs (e.g., zero addresses for `_joe`/`_rJoe`, unreasonable `_rJoePerSec` values), risking contract deployment with invalid parameters."",
      ""Impact"": ""Contract may become unusable or behave unexpectedly, leading to fund loss or reward miscalculations."",
      ""Location"": ""initialize function across multiple reports""
    },
    {
      ""Issue"": ""Unrestricted `updateEmissionRate` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The owner can arbitrarily change the emission rate (`rJoePerSec`) without limits or timelocks, enabling sudden manipulation of rewards. Front-running risks are also noted."",
      ""Impact"": ""Unfair reward distribution, disrupted incentives, or potential abuse by the owner."",
      ""Location"": ""updateEmissionRate function across multiple reports""
    },
    {
      ""Issue"": ""Potential Front-Running in Critical Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `deposit`, `withdraw`, and `updateEmissionRate` are vulnerable to front-running, where attackers exploit transaction ordering for unfair advantages."",
      ""Impact"": ""Manipulation of rewards or fund withdrawals, disadvantaging honest users."",
      ""Location"": ""deposit, withdraw, updateEmissionRate functions across multiple reports""
    },
    {
      ""Issue"": ""Lack of Reentrancy Protection in `emergencyWithdraw`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `emergencyWithdraw` function lacks reentrancy guards and may fail if token transfers revert (e.g., blacklisted addresses), causing denial-of-service."",
      ""Impact"": ""Users may be unable to withdraw funds in emergencies, leading to asset loss."",
      ""Location"": ""emergencyWithdraw function across multiple reports""
    },
    {
      ""Issue"": ""Precision Loss in Reward Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Fixed precision (`PRECISION = 1e18`) in divisions may truncate small values, especially with low `rJoePerSec` or `joeSupply`, skewing rewards."",
      ""Impact"": ""Users receive fewer rewards than expected, eroding trust."",
      ""Location"": ""pendingRJoe, updatePool functions across multiple reports""
    },
    {
      ""Issue"": ""Uninitialized `PRECISION` Variable"",
      ""Severity"": ""Low"",
      ""Description"": ""`PRECISION` is only set in `initialize`, risking incorrect calculations if used before initialization."",
      ""Impact"": ""Inaccurate reward calculations before initialization."",
      ""Location"": ""PRECISION variable and initialize function across multiple reports""
    },
    {
      ""Issue"": ""Lack of Event Emission in State-Changing Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical functions like `updatePool` and `emergencyWithdraw` omit events, reducing transparency and auditability."",
      ""Impact"": ""Harder to track state changes or audit contract activity."",
      ""Location"": ""updatePool, emergencyWithdraw functions across multiple reports""
    }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 9
}",352.5912129878998,43421.0,24.0,"### **Comparison of Issue Report and Response List**

---

#### **[M-01] Improper Upper Bound Definition on the Fee**

**Report Description**:  
The `rJoePerSec` variable in `RocketJoeStaking.sol` does not have any upper or lower bounds. If the value is set too large, it can lead to reversions in several critical functions, potentially disrupting the contract's functionality.

**Match in Response List**:  
Matches with the issue titled **""Unrestricted `updateEmissionRate` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the unrestricted `updateEmissionRate` function, which allows the owner to set `rJoePerSec` without bounds. This aligns with the reported vulnerability, as the lack of bounds can lead to reversions and contract instability.

---

#### **[M-03] `createRJLaunchEvent()` can be called by anyone with 1 Wei of `_token` and stop others from creating RJLaunchEvent with the same token anymore**

**Report Description**:  
The `createRJLaunchEvent()` function in `RocketJoeFactory.sol` can be called by anyone with at least 1 Wei of `_token`. This allows a malicious user to create an event with minimal cost, preventing others (including the platform or rightful token issuer) from creating an event with the same token.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this specific vulnerability, which involves improper access control and potential abuse of the `createRJLaunchEvent` function.

---

#### **[M-04] Uninitialized `RocketJoeStaking.lastRewardTimestamp` can inflate `rJoe` supply**

**Report Description**:  
The `lastRewardTimestamp` variable in `RocketJoeStaking.sol` is initialized to zero. If a user transfers `Joe` tokens to the contract before the first `updatePool` call, the large timestamp difference can inflate the `rJoe` supply, even though the tokens are not distributed to users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of uninitialized state variables leading to unintended inflation of the `rJoe` supply.

---

#### **[M-06] Possibility of minting `rJOE` tokens before ownership is changed to `RocketJoeStaking`**

**Report Description**:  
The `mint` function in `RocketJoeToken.sol` allows the original owner to mint `rJOE` tokens without staking any `JOE` before ownership is transferred to `RocketJoeStaking`. This could lead to unauthorized token minting.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of improper access control in the `mint` function, which could allow unauthorized token minting.

---

#### **[M-11] Re-enterable Code When Making a Deposit to Stake**

**Report Description**:  
The `deposit` function in the staking contract contains reentrancy risks due to external token transfers. Although the current `RocketJoeToken` implementation does not allow reentrancy, this pattern is highly risky and should be avoided to prevent potential fund draining.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Risk in `deposit` and `withdraw` Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy risk in the `deposit` function, even though the current implementation is not exploitable. This aligns with the reported vulnerability and Solidity best practices for avoiding reentrancy.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Improper Upper Bound Definition on the Fee**
- **[M-11] Re-enterable Code When Making a Deposit to Stake**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-03] `createRJLaunchEvent()` can be called by anyone with 1 Wei of `_token` and stop others from creating RJLaunchEvent with the same token anymore**
- **[M-04] Uninitialized `RocketJoeStaking.lastRewardTimestamp` can inflate `rJoe` supply**
- **[M-06] Possibility of minting `rJOE` tokens before ownership is changed to `RocketJoeStaking`**

---

### **Conclusion**

The response list effectively addresses some of the reported issues, particularly those related to reentrancy and unrestricted emission rates. However, it misses several critical vulnerabilities, including improper access control in `createRJLaunchEvent`, uninitialized state variables, and unauthorized token minting. These gaps highlight the need for a more comprehensive review of the contract's security posture.","```
1. Unrestricted `updateEmissionRate` Function
2. Reentrancy Risk in `deposit` and `withdraw` Functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Reentrancy Risk in `deposit` and `withdraw` Functions"" appears at rank 1.
   - ""Unrestricted `updateEmissionRate` Function"" appears at rank 4.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - At rank 4: \( P@4 = \frac{2}{4} = 0.5 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 0.5}{2} = 0.75 \)

**Output**:
```
0.75
```"
