nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}

",5808,615,"[H-01] buyAndSwap1155WETH() function may cause loss of user assets

Submitted by cccz
In the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail
  [H-03] A vault can be locked from MarketplaceZap and StakingZap

Submitted by p4st13r4, also found by cmichel, GreyArt, hyh, jayjonah8, leastwood, pauliax, shenwilly, and WatchPug
Any user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.
Every operation performed by the marketplace, that deals with vToken minting, performs this check:
require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");

A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace
  [M-01] Missing non reentrancy modifier

Submitted by robee
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
  [M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to

function `buyAndSwap721WETH` 
https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L226-L249
  [M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address

Submitted by hyh
transferFromERC721(address assetAddr, uint256 tokenId, address to) should transfer from msg.sender to to. It transfers to address(this) instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).
  [M-12] buyAndSwap1155WETH Does Not Work As Intended

Submitted by leastwood
The `buyAndSwap1155WETH` function in NFTXMarketplaceZap aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the msg.sender account and use these tokens in purchasing vault tokens. However, the _buyVaultToken call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.
",6,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",4873,2,4,,"{'ReviewingTheCode': 'The provided code is a Solidity smart contract named `NFTXMarketplaceZap`. It facilitates interactions with the NFTX protocol, allowing users to mint, sell, buy, swap, and redeem NFTs across different vaults. The contract integrates with external protocols like Uniswap (Sushiswap) for token swaps and handles both ERC721 and ERC1155 tokens. It also includes reentrancy protection and ownership management.', 'IdentifyingKeyComponents': {'ContractName': 'NFTXMarketplaceZap', 'Purpose': 'To provide a streamlined interface for users to interact with NFTX vaults, enabling operations like minting, selling, buying, swapping, and redeeming NFTs using ETH or WETH.', 'InheritanceAndImports': {'InheritsFrom': ['Ownable', 'ReentrancyGuard', 'ERC721HolderUpgradeable', 'ERC1155HolderUpgradeable'], 'Imports': ['./interface/INFTXVault.sol', './interface/INFTXVaultFactory.sol', './interface/INFTXFeeDistributor.sol', './interface/INFTXLPStaking.sol', './interface/ITimelockRewardDistributionToken.sol', './interface/IUniswapV2Router01.sol', './testing/IERC721.sol', './token/IERC1155Upgradeable.sol', './token/IERC20Upgradeable.sol', './token/ERC721HolderUpgradeable.sol', './token/ERC1155HolderUpgradeable.sol', './util/OwnableUpgradeable.sol']}, 'StateVariables': [{'Name': 'WETH', 'Type': 'IWETH', 'Purpose': 'Wrapped Ether contract interface for handling ETH/WETH conversions.'}, {'Name': 'lpStaking', 'Type': 'INFTXLPStaking', 'Purpose': 'Interface for NFTX LP staking contract.'}, {'Name': 'nftxFactory', 'Type': 'INFTXVaultFactory', 'Purpose': 'Interface for NFTX vault factory contract.'}, {'Name': 'sushiRouter', 'Type': 'IUniswapV2Router01', 'Purpose': 'Interface for Sushiswap router for token swaps.'}, {'Name': 'BASE', 'Type': 'uint256', 'Purpose': 'Constant representing the base unit for calculations (10^18).'}], 'FunctionsAndModifiers': [{'Name': 'mintAndSell721', 'Visibility': 'public', 'Purpose': 'Mints ERC721 NFTs into a vault and sells the vault tokens for ETH.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256 minWethOut', 'address[] calldata path', 'address to'], 'Returns': []}, {'Name': 'buyAndSwap721', 'Visibility': 'public', 'Purpose': 'Buys vault tokens with ETH and swaps them for specific ERC721 NFTs.', 'Parameters': ['uint256 vaultId', 'uint256[] memory idsIn', 'uint256[] memory specificIds', 'address[] calldata path', 'address to'], 'Returns': []}, {'Name': 'nonReentrant', 'Visibility': 'modifier', 'Purpose': 'Prevents reentrant calls to functions.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyOwner', 'Visibility': 'modifier', 'Purpose': 'Restricts function access to the contract owner.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['INFTXVault: Interface for interacting with NFTX vaults.', 'INFTXVaultFactory: Interface for NFTX vault factory.', 'IUniswapV2Router01: Interface for Sushiswap router for token swaps.', 'IWETH: Interface for Wrapped Ether contract.'], 'SpecialMechanisms': ['ReentrancyGuard: Prevents reentrant calls to functions.', 'Ownable: Manages contract ownership and restricts certain functions to the owner.', 'Token Swaps: Utilizes Sushiswap for token swaps between WETH and vault tokens.', 'ERC721 and ERC1155 Handling: Supports both ERC721 and ERC1155 tokens for minting, swapping, and redeeming.'], 'Questions': ['How are the specificIds and randomIds handled in the swap and redeem functions?', 'What is the purpose of the `pairFor` function, and how is it used in the contract?', 'Are there any potential security risks with the external contract calls, especially with the Sushiswap router?', 'How is the `minWethOut` parameter calculated and enforced in the sell functions?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in ETH/WETH Handling', 'Severity': 'High', 'Description': 'Multiple functions such as `buyAndSwap721`, `buyAndSwap1155`, and `buyAndRedeem` perform external calls to `WETH.withdraw` and transfer ETH to the user after swapping. Although the `nonReentrant` modifier is used, the transfer of ETH could still be exploited if the recipient is a malicious contract that re-enters the function before the state is updated.', 'Impact': 'An attacker could potentially re-enter the function and manipulate the state, leading to loss of funds or unexpected behavior.', 'Location': 'Functions: `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, `buyAndSwap721WETH`, `buyAndSwap1155WETH`, `buyAndRedeemWETH`'}, {'Issue': 'Unbounded Loops in ERC721/ERC1155 Operations', 'Severity': 'Medium', 'Description': 'Functions like `_mint721`, `_swap721`, `_swap1155`, and `_mint1155` contain loops that iterate over arrays of token IDs or amounts without a limit on the number of iterations. This could lead to gas exhaustion or denial of service if the arrays are too large.', 'Impact': 'High gas consumption or out-of-gas errors could occur, potentially causing transactions to fail.', 'Location': 'Functions: `_mint721`, `_swap721`, `_swap1155`, `_mint1155`, `buyAndSwap1155`, `buyAndSwap1155WETH`'}, {'Issue': 'Lack of Input Validation in ERC721/ERC1155 Transfers', 'Severity': 'Medium', 'Description': 'Functions `transferFromERC721` and `approveERC721` do not validate input parameters such as `assetAddr`, `tokenId`, or `to`. This could lead to unexpected behavior or vulnerabilities if invalid or malicious addresses are provided.', 'Impact': 'An attacker could manipulate the contract into transferring or approving tokens to unintended addresses, potentially leading to loss of assets.', 'Location': 'Functions: `transferFromERC721`, `approveERC721`'}, {'Issue': 'Potential Front-Running in Token Swaps', 'Severity': 'Medium', 'Description': 'Functions like `_buyVaultToken`, `_sellVaultTokenWETH`, and `_sellVaultTokenETH` use `sushiRouter.swapTokensForExactTokens` and similar methods without mechanisms to mitigate front-running. This could allow attackers to manipulate prices before the transaction is confirmed.', 'Impact': 'Users may receive less favorable swap rates, leading to financial losses.', 'Location': 'Functions: `_buyVaultToken`, `_sellVaultTokenWETH`, `_sellVaultTokenETH`'}, {'Issue': 'Unchecked Return Value in External Calls', 'Severity': 'Medium', 'Description': 'Functions such as `_sellVaultTokenETH`, `_sellVaultTokenWETH`, and `buyAndSwap721WETH` do not check the return value of external calls like `sushiRouter.swapExactTokensForETH` or `WETH.transfer`, which could lead to silent failures.', 'Impact': 'Tokens may not be transferred as expected, leading to potential loss of funds or incorrect state.', 'Location': 'Functions: `_sellVaultTokenETH`, `_sellVaultTokenWETH`, `buyAndSwap721WETH`, `buyAndSwap1155WETH`, `buyAndRedeemWETH`'}, {'Issue': 'Hardcoded Addresses for CryptoKitties and CryptoPunks', 'Severity': 'Low', 'Description': 'Functions `transferFromERC721` and `approveERC721` contain hardcoded addresses for specific NFT contracts (e.g., CryptoKitties and CryptoPunks). This reduces flexibility and could cause issues if these contracts are upgraded or deprecated.', 'Impact': 'The contract may become incompatible with future versions of the hardcoded contracts.', 'Location': 'Functions: `transferFromERC721`, `approveERC721`'}, {'Issue': 'Lack of Event Emission for Critical State Changes', 'Severity': 'Low', 'Description': 'Several critical functions like `_mint721`, `_mint1155`, `_swap1155`, and `_redeem` do not emit events after performing important state changes. This reduces transparency and makes it harder to track contract activity.', 'Impact': 'Reduced transparency and difficulty in tracking contract activity.', 'Location': 'Functions: `_mint721`, `_mint1155`, `_swap1155`, `_redeem`, `_sellVaultTokenWETH`, `_sellVaultTokenETH`'}, {'Issue': 'Potential Integer Overflow in Arithmetic Operations', 'Severity': 'Low', 'Description': 'Functions like `_mint721`, `_mint1155`, and `buyAndRedeem` perform arithmetic operations that could potentially overflow or underflow. While Solidity 0.8.0 has built-in checks, it is still good practice to explicitly handle such cases.', 'Impact': 'Potential for unexpected behavior or vulnerabilities if arithmetic operations are not handled correctly.', 'Location': 'Functions: `_mint721`, `_mint1155`, `buyAndRedeem`'}], 'IssueNumber': 60, 'OutputList': 8}",574.3367047309875,"### **Comparison and Evaluation**

---

#### **[H-01] buyAndSwap1155WETH() function may cause loss of user assets**

**Report Description**:  
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap.sol` uses the `WETH` provided by the user to exchange `VaultToken`. However, when executing the `_buyVaultToken` method, `msg.value` is used instead of `maxWethIn`. Since `msg.value` is 0, the call will fail, potentially causing a loss of user assets.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem lies in the incorrect use of `msg.value` instead of `maxWethIn`, which is not covered in the response list. This is a critical oversight that could lead to asset loss.

---

#### **[H-03] A vault can be locked from MarketplaceZap and StakingZap**

**Report Description**:  
Any user owning a `vToken` of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone. This is due to a check in the contract that requires the balance of `vToken` to match the expected value. A malicious user can transfer any amount > 0 of `vToken` to the zap contracts, making the vault functionality unavailable for all users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves a malicious user locking the vault functionality by transferring `vToken`, which is not mentioned in the response list. This is a significant security risk.

---

#### **[M-01] Missing non reentrancy modifier**

**Report Description**:  
Certain functions are missing the `nonReentrant` modifier, even though other public/external functions use it. While no direct exploit was found, the absence of this modifier could potentially lead to reentrancy vulnerabilities.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in ETH/WETH Handling""**.

**Validation**:  
**Partially Correct**. The response identifies reentrancy as a concern but focuses on `WETH.withdraw` and ETH transfers, which is not the same as the missing `nonReentrant` modifier in other functions. The response partially covers the issue but misses the broader context of missing modifiers.

---

#### **[M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to**

**Report Description**:  
The `buyAndSwap721WETH` function should return unused `WETH/ETH` back to `msg.sender` instead of `to`. This is a design flaw that could lead to incorrect handling of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves incorrect fund handling, which is not covered in the response list.

---

#### **[M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address**

**Report Description**:  
The `transferFromERC721` function should transfer `Cryptokitties` from `msg.sender` to `to`, but it transfers them to `address(this)` instead. This leads to incorrect NFT accounting and potential loss of assets.

**Match in Response List**:  
Matches with the issue titled **""Hardcoded Addresses for CryptoKitties and CryptoPunks""**.

**Validation**:  
**Partially Correct**. The response mentions hardcoded addresses for `CryptoKitties` but does not address the incorrect transfer logic. The response partially covers the issue but misses the critical detail of the wrong transfer destination.

---

#### **[M-12] buyAndSwap1155WETH Does Not Work As Intended**

**Report Description**:  
The `buyAndSwap1155WETH` function expects to transfer `WETH` tokens from `msg.sender` and use them to purchase vault tokens. However, the `_buyVaultToken` call uses `msg.value` instead of `maxWethIn`, causing the function to fail unless the user supplies both `WETH` and native `ETH`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves incorrect parameter usage, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] Missing non reentrancy modifier**  
- **[M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address**

**Missed Issues from Issue Report**:  
- **[H-01] buyAndSwap1155WETH() function may cause loss of user assets**  
- **[H-03] A vault can be locked from MarketplaceZap and StakingZap**  
- **[M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to**  
- **[M-12] buyAndSwap1155WETH Does Not Work As Intended**

---

### **Conclusion**  
The response list partially addresses some issues but misses critical vulnerabilities and design flaws. Significant gaps exist in the coverage of high and medium-severity issues, particularly those related to incorrect parameter usage, fund handling, and vault locking. The response list needs to be expanded to address these critical security concerns.","```
None.
```",0.0
NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
} 
",1672,172,"[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees

Submitted by cccz, also found by WatchPug
In the NFTXSimpleFeeDistributor.sol contract, the `distribute` function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.
function distribute(uint256 vaultId) external override virtual nonReentrant {
  require(nftxVaultFactory != address(0));
  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

  if (distributionPaused || allocTotal == 0) {
    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
    return;
  }

  uint256 length = feeReceivers.length;
  uint256 leftover;
  for (uint256 i = 0; i <length; i++) {
    FeeReceiver memory _feeReceiver = feeReceivers[i];
    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
    amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;
    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
    if (!complete) {
      leftover = amountToSend;
    } else {
      leftover = 0;
    }
  }

In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.
  [M-01] Missing non reentrancy modifier

Submitted by robee
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..

[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver

Submitted by GreyArt
The addReceiver() function fails to check if the _receiver already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.
The receiver would receive more than expected (until the duplicate entry has been removed).
   [M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract

Submitted by hyh
Double spending of fees being distributed will happen in favor of the first fee receivers in the feeReceivers list at the expense of the last ones. As _sendForReceiver doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.
  [M-14] Return variable can remain unassigned in _sendForReceiver

Submitted by sirhashalot, also found by pauliax
The _sendForReceiver() function only sets a return function in the ""if"" code block, not the ""else"" case. If the ""else"" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover > 0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.
This problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.
   [M-16] Malicious receiver can make `distribute` function denial of service
`distribute` function 
In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee
",6,,"pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1605,1,5,,"{'ReviewingTheCode': 'The provided smart contract is a fee distribution mechanism for NFTX, designed to manage and distribute fees collected from various vaults. It integrates with LP staking, inventory staking, and a treasury. The contract is upgradeable, uses SafeERC20 for token transfers, and includes mechanisms to pause distributions and rescue tokens.', 'IdentifyingKeyComponents': {'ContractName': 'NFTXSimpleFeeDistributor', 'Purpose': 'To distribute fees collected from NFTX vaults to various receivers, including LP staking, inventory staking, and the treasury.', 'InheritanceAndImports': {'InheritsFrom': ['ReentrancyGuardUpgradeable', 'PausableUpgradeable'], 'Imports': ['INFTXLPStaking', 'INFTXSimpleFeeDistributor', 'INFTXInventoryStaking', 'INFTXVaultFactory', 'IERC20Upgradeable', 'SafeERC20Upgradeable', 'SafeMathUpgradeable', 'PausableUpgradeable', 'ReentrancyGuardUpgradeable']}, 'StateVariables': [{'Name': 'distributionPaused', 'Type': 'bool', 'Purpose': 'Indicates whether fee distribution is paused.'}, {'Name': 'nftxVaultFactory', 'Type': 'address', 'Purpose': 'Address of the NFTX vault factory.'}, {'Name': 'lpStaking', 'Type': 'address', 'Purpose': 'Address of the LP staking contract.'}, {'Name': 'treasury', 'Type': 'address', 'Purpose': 'Address of the treasury.'}, {'Name': 'allocTotal', 'Type': 'uint256', 'Purpose': 'Total allocation points for fee receivers.'}, {'Name': 'feeReceivers', 'Type': 'FeeReceiver[]', 'Purpose': 'List of fee receivers and their allocation points.'}, {'Name': 'inventoryStaking', 'Type': 'address', 'Purpose': 'Address of the inventory staking contract.'}], 'FunctionsAndModifiers': [{'Name': '__SimpleFeeDistributor__init__', 'Visibility': 'public', 'Purpose': 'Initializes the contract with LP staking and treasury addresses.', 'Parameters': ['address _lpStaking', 'address _treasury'], 'Returns': []}, {'Name': 'distribute', 'Visibility': 'external', 'Purpose': 'Distributes fees from a specific vault to the fee receivers.', 'Parameters': ['uint256 vaultId'], 'Returns': []}, {'Name': 'addReceiver', 'Visibility': 'external', 'Purpose': 'Adds a new fee receiver with a specific allocation point.', 'Parameters': ['uint256 _allocPoint', 'address _receiver', 'bool _isContract'], 'Returns': []}, {'Name': 'initializeVaultReceivers', 'Visibility': 'external', 'Purpose': 'Initializes fee receivers for a new vault.', 'Parameters': ['uint256 _vaultId'], 'Returns': []}, {'Name': 'changeReceiverAlloc', 'Visibility': 'public', 'Purpose': 'Changes the allocation point of an existing fee receiver.', 'Parameters': ['uint256 _receiverIdx', 'uint256 _allocPoint'], 'Returns': []}, {'Name': 'changeReceiverAddress', 'Visibility': 'public', 'Purpose': 'Changes the address of an existing fee receiver.', 'Parameters': ['uint256 _receiverIdx', 'address _address', 'bool _isContract'], 'Returns': []}, {'Name': 'removeReceiver', 'Visibility': 'external', 'Purpose': 'Removes a fee receiver from the list.', 'Parameters': ['uint256 _receiverIdx'], 'Returns': []}, {'Name': 'setTreasuryAddress', 'Visibility': 'public', 'Purpose': 'Sets the treasury address.', 'Parameters': ['address _treasury'], 'Returns': []}, {'Name': 'setLPStakingAddress', 'Visibility': 'public', 'Purpose': 'Sets the LP staking address.', 'Parameters': ['address _lpStaking'], 'Returns': []}, {'Name': 'setInventoryStakingAddress', 'Visibility': 'public', 'Purpose': 'Sets the inventory staking address.', 'Parameters': ['address _inventoryStaking'], 'Returns': []}, {'Name': 'setNFTXVaultFactory', 'Visibility': 'external', 'Purpose': 'Sets the NFTX vault factory address.', 'Parameters': ['address _factory'], 'Returns': []}, {'Name': 'pauseFeeDistribution', 'Visibility': 'external', 'Purpose': 'Pauses or unpauses fee distribution.', 'Parameters': ['bool pause'], 'Returns': []}, {'Name': 'rescueTokens', 'Visibility': 'external', 'Purpose': 'Rescues tokens stuck in the contract.', 'Parameters': ['address _address'], 'Returns': []}, {'Name': '_addReceiver', 'Visibility': 'internal', 'Purpose': 'Internal function to add a new fee receiver.', 'Parameters': ['uint256 _allocPoint', 'address _receiver', 'bool _isContract'], 'Returns': []}, {'Name': '_sendForReceiver', 'Visibility': 'internal', 'Purpose': 'Internal function to send fees to a receiver.', 'Parameters': ['FeeReceiver memory _receiver', 'uint256 _vaultId', 'address _vault', 'uint256 amountToSend'], 'Returns': ['bool']}]}, 'ExternalInteractions': ['INFTXVaultFactory', 'INFTXLPStaking', 'INFTXInventoryStaking', 'IERC20Upgradeable'], 'SpecialMechanisms': [""Upgradeable contract using OpenZeppelin's Pausable and ReentrancyGuard."", 'SafeERC20 for secure token transfers.', 'Fee distribution mechanism with allocation points.'], 'Questions': ['How are the allocation points for fee receivers determined?', 'What happens if the `distribute` function is called while `distributionPaused` is true?', 'Is there a mechanism to handle failed token transfers to fee receivers?', 'How is the `allocTotal` updated when receivers are added, removed, or modified?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in `distribute` Function', 'Severity': 'High', 'Description': 'The `distribute` function interacts with external contracts via `_sendForReceiver`, which includes a low-level call to the receiver address. This could potentially lead to a reentrancy attack if the receiver is a malicious contract. Although the function is marked as `nonReentrant`, the use of low-level calls (`call`) could still be risky if not handled properly.', 'Impact': 'An attacker could exploit this vulnerability to re-enter the `distribute` function, potentially draining funds or causing unexpected behavior.', 'Location': 'distribute function, _sendForReceiver function'}, {'Issue': 'Unrestricted Token Rescue Function', 'Severity': 'High', 'Description': ""The `rescueTokens` function allows the owner to withdraw any ERC20 tokens from the contract without any restrictions. This could lead to loss of funds if the owner's private key is compromised or if the owner acts maliciously."", 'Impact': 'Potential loss of user funds or tokens held in the contract.', 'Location': 'Function `rescueTokens`'}, {'Issue': 'Lack of Input Validation in Receiver Functions', 'Severity': 'Medium', 'Description': 'Functions like `_addReceiver`, `changeReceiverAlloc`, and `changeReceiverAddress` do not validate input parameters sufficiently. For example, `_allocPoint` could be set to a very high value, potentially causing arithmetic overflow or unexpected behavior.', 'Impact': 'Potential manipulation of fee distribution or contract state.', 'Location': 'Functions `_addReceiver`, `changeReceiverAlloc`, `changeReceiverAddress`'}, {'Issue': 'Unchecked External Call in `_sendForReceiver`', 'Severity': 'Medium', 'Description': 'The `_sendForReceiver` function makes an external call to `_receiver.receiver` without checking the return value of the low-level call. This could lead to silent failures where the call fails but the function continues execution as if it succeeded.', 'Impact': 'Funds could be lost or incorrectly allocated if the external call fails silently.', 'Location': 'Function: _sendForReceiver'}, {'Issue': 'Potential Integer Overflow in `allocTotal`', 'Severity': 'Medium', 'Description': 'The `allocTotal` variable is updated by adding and subtracting `allocPoint` values. While Solidity 0.8.0 has built-in overflow checks, it is still important to ensure that the `allocTotal` does not exceed reasonable bounds, which could lead to unexpected behavior.', 'Impact': 'If `allocTotal` exceeds its expected bounds, it could lead to incorrect fee distribution calculations.', 'Location': '`changeReceiverAlloc` and `removeReceiver` functions'}, {'Issue': 'Potential Front-Running in `changeReceiverAlloc` and `changeReceiverAddress` Functions', 'Severity': 'Low', 'Description': 'The `changeReceiverAlloc` and `changeReceiverAddress` functions allow the owner to modify the allocation points and receiver addresses, respectively. However, these changes are not protected against front-running attacks, where an attacker could observe the transaction and take advantage of the change before it is applied.', 'Impact': 'Front-running could lead to unintended consequences, such as funds being sent to the wrong address or incorrect allocation of funds.', 'Location': 'changeReceiverAlloc function, changeReceiverAddress function'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': 'Some critical functions like `initializeVaultReceivers` and `_sendForReceiver` do not emit events. This lack of transparency makes it difficult to track and audit changes and actions within the contract.', 'Impact': 'Lack of event emission reduces transparency and auditability, making it harder to detect and respond to suspicious activities.', 'Location': 'initializeVaultReceivers and _sendForReceiver functions'}, {'Issue': 'Missing Zero Address Check in `setInventoryStakingAddress` Function', 'Severity': 'Low', 'Description': 'The `setInventoryStakingAddress` function does not check if the new address is the zero address. This could lead to setting an invalid address, which might cause issues when interacting with the inventory staking contract.', 'Impact': 'Setting an invalid address could lead to failed transactions or loss of functionality related to inventory staking.', 'Location': '`setInventoryStakingAddress` function'}], 'IssueNumber': 10, 'OutputList': 8}",530.1500239372253,"### **[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees**

**Report Description**:
In the `NFTXSimpleFeeDistributor.sol` contract, the `distribute` function uses the `_sendForReceiver` function to distribute fees. The `_sendForReceiver` function does not return a value when the receiver is not a contract, causing it to default to `false`. This leads the `distribute` function to incorrectly assume that the fee transfer failed, resulting in leftover fees being sent again in the next iteration. This issue can cause receivers to receive more fees than intended, especially when the receiver is an EOA (Externally Owned Account).

**Match in Response List**:
Matches with the issue titled **""Unchecked External Call in `_sendForReceiver`""**.

**Validation**:
**Partially Correct**. The response identifies the issue with unchecked external calls in the `_sendForReceiver` function but does not fully capture the specific problem of the function defaulting to `false` when the receiver is not a contract. The response focuses on the general risk of unchecked external calls but misses the critical detail that leads to double fee distribution.

---

### **[M-01] Missing non reentrancy modifier**

**Report Description**:
Several functions in the contract are missing the `nonReentrant` modifier, even though other public/external functions use it. While no direct exploit was found, the absence of this modifier in functions that interact with external contracts or handle funds could potentially lead to reentrancy attacks.

**Match in Response List**:
Matches with the issue titled **""Potential Reentrancy Vulnerability in `distribute` Function""**.

**Validation**:
**Correct**. The response accurately identifies the potential reentrancy risk in the `distribute` function, which aligns with the issue of missing `nonReentrant` modifiers. The response correctly highlights the risk of reentrancy when interacting with external contracts, even though the function is marked as `nonReentrant`.

---

### **[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver**

**Report Description**:
The `addReceiver` function does not check if the `_receiver` already exists in the `feeReceivers` list. This oversight could lead to the same receiver being added multiple times, resulting in erroneous fee distributions. Receivers could receive more fees than intended until the duplicate entry is removed.

**Match in Response List**:
Matches with the issue titled **""Lack of Input Validation in Receiver Functions""**.

**Validation**:
**Correct**. The response correctly identifies the lack of input validation in functions like `addReceiver`, which aligns with the issue of failing to check for existing receivers. The response highlights the potential for manipulation of fee distribution due to insufficient validation, which is consistent with the reported issue.

---

### **[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract**

**Report Description**:
The `_sendForReceiver` function does not return `true` when the receiver is not a contract, causing the `distribute` function to incorrectly assume that the transfer failed. This results in double spending of fees, favoring the first receivers in the `feeReceivers` list at the expense of the last ones. This issue leads to double payments for some receivers and missed payments for others.

**Match in Response List**:
Matches with the issue titled **""Unchecked External Call in `_sendForReceiver`""**.

**Validation**:
**Partially Correct**. The response identifies the issue with unchecked external calls in the `_sendForReceiver` function but does not fully capture the specific problem of the function defaulting to `false` when the receiver is not a contract. The response focuses on the general risk of unchecked external calls but misses the critical detail that leads to double fee distribution.

---

### **[M-14] Return variable can remain unassigned in _sendForReceiver**

**Report Description**:
The `_sendForReceiver` function only sets a return value in the ""if"" block, not the ""else"" case. If the ""else"" case is true, no value is returned, causing the function to default to `false`. This oversight can lead to incorrect fee distribution, as the `distribute` function will assume the transfer failed and send leftover fees to the treasury.

**Match in Response List**:
Matches with the issue titled **""Unchecked External Call in `_sendForReceiver`""**.

**Validation**:
**Partially Correct**. The response identifies the issue with unchecked external calls in the `_sendForReceiver` function but does not fully capture the specific problem of the function defaulting to `false` when the ""else"" case is true. The response focuses on the general risk of unchecked external calls but misses the critical detail that leads to incorrect fee distribution.

---

### **[M-16] Malicious receiver can make `distribute` function denial of service**

**Report Description**:
The `distribute` function calls the `_sendForReceiver` function to distribute fees. If a malicious receiver is added to the `feeReceivers` list, it could cause the `distribute` function to fail, leading to a denial of service. This could prevent legitimate fee distributions from occurring.

**Match in Response List**:
Matches with the issue titled **""Potential Reentrancy Vulnerability in `distribute` Function""**.

**Validation**:
**Correct**. The response accurately identifies the potential reentrancy risk in the `distribute` function, which aligns with the issue of a malicious receiver causing a denial of service. The response correctly highlights the risk of reentrancy when interacting with external contracts, even though the function is marked as `nonReentrant`.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Missing non reentrancy modifier**
- **[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver**
- **[M-16] Malicious receiver can make `distribute` function denial of service**

**Partially Correct Matches**:

- **[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees**
- **[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract**
- **[M-14] Return variable can remain unassigned in _sendForReceiver**

**Missed Issues from Issue Report**:

- *None*

---","```
1. Potential Reentrancy Vulnerability in `distribute` Function
2. Lack of Input Validation in Receiver Functions
3. Potential Reentrancy Vulnerability in `distribute` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **True Positive 1**: ""Potential Reentrancy Vulnerability in `distribute` Function"" appears at rank 1.
   - **True Positive 2**: ""Lack of Input Validation in Receiver Functions"" appears at rank 3.
   - **True Positive 3**: ""Potential Reentrancy Vulnerability in `distribute` Function"" appears again at rank 1.

2. **Calculate the precision at each rank where a true positive appears**:
   - **Precision at rank 1 (P@1)**: Number of true positives up to rank 1 / rank 1 = 1/1 = 1.0
   - **Precision at rank 3 (P@3)**: Number of true positives up to rank 3 / rank 3 = 2/3 ≈ 0.6667

3. **Average the precision values**:
   - AP = (P@1 + P@3) / 2 = (1.0 + 0.6667) / 2 ≈ 0.8333

**Output**:
```
0.8333
```"
NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

// Authors: @0xKiwi_ and @alexgausman.

contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    // Added in v1.0.3.
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    // // This function allows for the manager to set their own arbitrary eligibility contract.
    // // Once eligiblity is set, it cannot be unset or changed.
    // Disabled for launch.
    // function setEligibilityStorage(address _newEligibility) public virtual {
    //     onlyPrivileged();
    //     require(
    //         address(eligibilityStorage) == address(0),
    //         ""NFTXVault: eligibility already set""
    //     );
    //     eligibilityStorage = INFTXEligibility(_newEligibility);
    //     // Toggle this to let the contract know to check eligibility now.
    //     allowAllItems = false;
    //     emit CustomEligibilityDeployed(address(_newEligibility));
    // }

    // The manager has control over options like fees and features
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        // Take the NFTs.
        uint256 count = receiveNFTs(tokenIds, amounts);

        // Mint to the user.
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burn(msg.sender, base * amount);

        // Pay the tokens + toll.
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        // Withdraw from vault.
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        // Give the NFTs first, so the user wont get the same thing back, just to be nice. 
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    // Added in v1.0.3.
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    // Added in v1.0.3.
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    // Added in v1.0.3.
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                // We may already own the NFT here so we check in order:
                // Does the vault own it?
                //   - If so, check if its in holdings list
                //      - If so, we reject. This means the NFT has already been claimed for.
                //      - If not, it means we have not yet accounted for this NFT, so we continue.
                //   -If not, we ""pull"" it from the msg.sender and add to holdings.
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            // This will always be fine considering the validations made above. 
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        // Do not charge fees if the zap contract is calling
        // Added in v1.0.3. Changed to mapping in v1.0.5.
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            // Changed to a _transfer() in v1.0.3.
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Changed in v1.0.4.
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            // Default.
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Cryptokitties.
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            // Fix here for frontrun attack. Added in v1.0.2.
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            // Default.
            // Allow other contracts to ""push"" into the vault, safely.
            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4750,561,"[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users

Submitted by pedroais
Pool Manager can front-run entry fee to 100% and users could lose all their deposits.
Proof of Concept

Considering: The pool manager is the creator of the pool. Anyone can create a pool. Manager is not a trusted actor.
Anyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10**18 (100% as this is a per token fee).
  [M-09] Bypass zap timelock

Submitted by gzeon
The default value of inventoryLockTime in NFTXStakingZap is 7 days while DEFAULT_LOCKTIME in NFTXInventoryStaking is 2 ms. These timelock value are used in NFTXInventoryStaking to eventually call _timelockMint in XTokenUpgradeable.
https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74
function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {
  uint256 timelockFinish = block.timestamp + timelockLength;
  timelock[account] = timelockFinish;
  emit Timelocked(account, timelockFinish);
  _mint(account, amount);
}

The applicable timelock is calculated by block.timestamp + timelockLength, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling deposit in NFTXInventoryStaking
",2,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";



contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true , true , true , true , true );
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    
    
    
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        
        uint256 count = receiveNFTs(tokenIds, amounts);

        
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        
        _burn(msg.sender, base * amount);

        
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                
                
                
                
                
                
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        
        
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            
            
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            
            
            
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4033,0,2,,"{'ReviewingTheCode': 'The provided code is a Solidity smart contract named `NFTXVaultUpgradeable`. It is designed to manage a vault for NFTs, allowing users to mint, redeem, and swap NFTs within the vault. The contract is upgradeable and inherits from multiple contracts to provide functionalities like ownership, reentrancy protection, and safe handling of ERC721 and ERC1155 tokens.', 'IdentifyingKeyComponents': {'ContractName': 'NFTXVaultUpgradeable', 'Purpose': 'The contract serves as a vault for NFTs, enabling users to mint, redeem, and swap NFTs. It also manages fees, eligibility criteria, and interactions with external contracts like the NFTX Vault Factory and Eligibility Manager.', 'InheritanceAndImports': {'InheritsFrom': ['OwnableUpgradeable', 'ERC20FlashMintUpgradeable', 'ReentrancyGuardUpgradeable', 'ERC721SafeHolderUpgradeable', 'ERC1155SafeHolderUpgradeable', 'INFTXVault'], 'Imports': ['./interface/INFTXVault.sol', './interface/INFTXVaultFactory.sol', './interface/INFTXEligibility.sol', './interface/INFTXEligibilityManager.sol', './interface/INFTXLPStaking.sol', './interface/INFTXFeeDistributor.sol', './token/ERC20FlashMintUpgradeable.sol', './token/ERC721SafeHolderUpgradeable.sol', './token/ERC1155SafeHolderUpgradeable.sol', './token/IERC721Upgradeable.sol', './token/IERC1155Upgradeable.sol', './util/OwnableUpgradeable.sol', './util/ReentrancyGuardUpgradeable.sol', './util/EnumerableSetUpgradeable.sol']}, 'StateVariables': [{'Name': 'vaultId', 'Type': 'uint256', 'Purpose': 'Unique identifier for the vault.'}, {'Name': 'manager', 'Type': 'address', 'Purpose': 'Address of the manager who can perform privileged actions.'}, {'Name': 'assetAddress', 'Type': 'address', 'Purpose': 'Address of the NFT contract associated with the vault.'}, {'Name': 'vaultFactory', 'Type': 'INFTXVaultFactory', 'Purpose': 'Reference to the NFTX Vault Factory contract.'}, {'Name': 'eligibilityStorage', 'Type': 'INFTXEligibility', 'Purpose': 'Contract that handles eligibility criteria for NFTs in the vault.'}, {'Name': 'is1155', 'Type': 'bool', 'Purpose': 'Indicates whether the vault handles ERC1155 tokens.'}, {'Name': 'allowAllItems', 'Type': 'bool', 'Purpose': 'Indicates whether all items are allowed in the vault without eligibility checks.'}, {'Name': 'enableMint', 'Type': 'bool', 'Purpose': 'Indicates whether minting is enabled in the vault.'}, {'Name': 'enableRandomRedeem', 'Type': 'bool', 'Purpose': 'Indicates whether random redemption is enabled in the vault.'}, {'Name': 'enableTargetRedeem', 'Type': 'bool', 'Purpose': 'Indicates whether targeted redemption is enabled in the vault.'}, {'Name': 'holdings', 'Type': 'EnumerableSetUpgradeable.UintSet', 'Purpose': 'Set of token IDs held in the vault.'}, {'Name': 'quantity1155', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Mapping of token IDs to their quantities for ERC1155 tokens.'}, {'Name': 'enableRandomSwap', 'Type': 'bool', 'Purpose': 'Indicates whether random swapping is enabled in the vault.'}, {'Name': 'enableTargetSwap', 'Type': 'bool', 'Purpose': 'Indicates whether targeted swapping is enabled in the vault.'}], 'FunctionsAndModifiers': [{'Name': '__NFTXVault_init', 'Visibility': 'public', 'Purpose': 'Initializes the vault with a name, symbol, asset address, and other parameters.', 'Parameters': ['string memory _name', 'string memory _symbol', 'address _assetAddress', 'bool _is1155', 'bool _allowAllItems'], 'Returns': []}, {'Name': 'finalizeVault', 'Visibility': 'external', 'Purpose': 'Finalizes the vault by setting the manager to the zero address.', 'Parameters': [], 'Returns': []}, {'Name': 'setVaultMetadata', 'Visibility': 'public', 'Purpose': 'Sets the metadata (name and symbol) of the vault.', 'Parameters': ['string memory name_', 'string memory symbol_'], 'Returns': []}, {'Name': 'setVaultFeatures', 'Visibility': 'public', 'Purpose': 'Enables or disables various features of the vault (minting, random/targeted redemption, random/targeted swapping).', 'Parameters': ['bool _enableMint', 'bool _enableRandomRedeem', 'bool _enableTargetRedeem', 'bool _enableRandomSwap', 'bool _enableTargetSwap'], 'Returns': []}, {'Name': 'assignDefaultFeatures', 'Visibility': 'external', 'Purpose': 'Assigns default features to the vault, only callable by a specific developer address.', 'Parameters': [], 'Returns': []}, {'Name': 'setFees', 'Visibility': 'public', 'Purpose': 'Sets the fees for various operations in the vault.', 'Parameters': ['uint256 _mintFee', 'uint256 _randomRedeemFee', 'uint256 _targetRedeemFee', 'uint256 _randomSwapFee', 'uint256 _targetSwapFee'], 'Returns': []}, {'Name': 'disableVaultFees', 'Visibility': 'public', 'Purpose': 'Disables all fees in the vault.', 'Parameters': [], 'Returns': []}, {'Name': 'deployEligibilityStorage', 'Visibility': 'external', 'Purpose': 'Deploys a new eligibility storage contract for the vault.', 'Parameters': ['uint256 moduleIndex', 'bytes calldata initData'], 'Returns': ['address']}, {'Name': 'setManager', 'Visibility': 'public', 'Purpose': 'Sets the manager address for the vault.', 'Parameters': ['address _manager'], 'Returns': []}, {'Name': 'mint', 'Visibility': 'external', 'Purpose': 'Mints vault tokens by depositing NFTs into the vault.', 'Parameters': ['uint256[] calldata tokenIds', 'uint256[] calldata amounts'], 'Returns': ['uint256']}, {'Name': 'mintTo', 'Visibility': 'public', 'Purpose': 'Mints vault tokens to a specified address by depositing NFTs into the vault.', 'Parameters': ['uint256[] memory tokenIds', 'uint256[] memory amounts', 'address to'], 'Returns': ['uint256']}, {'Name': 'redeem', 'Visibility': 'external', 'Purpose': 'Redeems vault tokens for NFTs.', 'Parameters': ['uint256 amount', 'uint256[] calldata specificIds'], 'Returns': ['uint256[] memory']}, {'Name': 'redeemTo', 'Visibility': 'public', 'Purpose': 'Redeems vault tokens for NFTs and sends them to a specified address.', 'Parameters': ['uint256 amount', 'uint256[] memory specificIds', 'address to'], 'Returns': ['uint256[] memory']}, {'Name': 'swap', 'Visibility': 'external', 'Purpose': 'Swaps NFTs within the vault.', 'Parameters': ['uint256[] calldata tokenIds', 'uint256[] calldata amounts', 'uint256[] calldata specificIds'], 'Returns': ['uint256[] memory']}, {'Name': 'swapTo', 'Visibility': 'public', 'Purpose': 'Swaps NFTs within the vault and sends them to a specified address.', 'Parameters': ['uint256[] memory tokenIds', 'uint256[] memory amounts', 'uint256[] memory specificIds', 'address to'], 'Returns': ['uint256[] memory']}, {'Name': 'flashLoan', 'Visibility': 'public', 'Purpose': 'Allows flash loans to be taken from the vault.', 'Parameters': ['IERC3156FlashBorrowerUpgradeable receiver', 'address token', 'uint256 amount', 'bytes memory data'], 'Returns': ['bool']}, {'Name': 'onlyPrivileged', 'Visibility': 'internal', 'Purpose': 'Modifier to ensure that only the owner or manager can call certain functions.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyOwnerIfPaused', 'Visibility': 'internal', 'Purpose': 'Modifier to ensure that only the owner can call certain functions if the vault is paused.', 'Parameters': ['uint256 lockId'], 'Returns': []}]}, 'ExternalInteractions': ['INFTXVaultFactory', 'INFTXEligibility', 'INFTXEligibilityManager', 'INFTXFeeDistributor', 'IERC721Upgradeable', 'IERC1155Upgradeable'], 'SpecialMechanisms': ['Upgradeable contract pattern', 'Reentrancy protection using ReentrancyGuardUpgradeable', 'Safe handling of ERC721 and ERC1155 tokens', 'EnumerableSet for managing token IDs', 'Flash loan functionality'], 'Questions': ['What is the purpose of the `UNUSED_FEE1`, `UNUSED_FEE2`, and `UNUSED_FEE3` variables?', 'How is the randomness in `getRandomTokenIdFromVault` ensured to be secure and unbiased?', 'Are there any potential risks associated with the `flashLoan` function?', 'How does the `onlyOwnerIfPaused` modifier interact with the `vaultFactory.isLocked` function?', 'What are the specific eligibility criteria managed by `eligibilityStorage`?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in `mintTo` and `redeemTo` Functions', 'Severity': 'High', 'Description': 'The `mintTo` and `redeemTo` functions, despite being marked as `nonReentrant`, interact with external contracts (e.g., `receiveNFTs`, `withdrawNFTsTo`, `_chargeAndDistributeFees`). If these external contracts are malicious or compromised, they could potentially re-enter the functions, leading to unexpected behavior or loss of funds.', 'Impact': 'Reentrancy attacks could allow an attacker to manipulate the state of the contract, potentially leading to loss of funds or unauthorized minting/redeeming of tokens.', 'Location': 'Functions: `mintTo`, `redeemTo`, `receiveNFTs`, `withdrawNFTsTo`, `_chargeAndDistributeFees`'}, {'Issue': 'Lack of Input Validation in `mintTo` and `redeemTo` Functions', 'Severity': 'High', 'Description': 'The `mintTo` and `redeemTo` functions do not validate the lengths of `tokenIds` and `amounts` arrays. Mismatched array lengths could lead to unexpected behavior or vulnerabilities such as out-of-bounds access.', 'Impact': 'Potential for reentrancy attacks, unexpected state changes, or loss of funds if the input arrays are not properly validated.', 'Location': 'Functions: `mintTo`, `redeemTo`'}, {'Issue': 'Lack of Access Control in `assignDefaultFeatures` Function', 'Severity': 'High', 'Description': 'The `assignDefaultFeatures` function only checks if the caller is a specific hardcoded address (0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a). This is a security risk as it relies on a single address for authorization, which could be compromised or misused.', 'Impact': 'An attacker or malicious actor who gains control of the hardcoded address could manipulate the swap features, potentially leading to unauthorized operations or financial losses.', 'Location': 'Function: `assignDefaultFeatures`'}, {'Issue': 'Reentrancy Risk in `withdrawNFTsTo` Function', 'Severity': 'High', 'Description': 'The `withdrawNFTsTo` function transfers NFTs to an external address before updating the internal state, which could be exploited in a reentrancy attack.', 'Impact': 'An attacker could potentially reenter the contract and manipulate the state, leading to loss of funds or incorrect state changes.', 'Location': 'Function: `withdrawNFTsTo`'}, {'Issue': 'Use of `blockhash` for Randomness in `getRandomTokenIdFromVault`', 'Severity': 'Medium', 'Description': 'The `getRandomTokenIdFromVault` function uses `blockhash` and other block-related variables to generate randomness. This method is predictable and can be manipulated by miners, making it unsuitable for secure randomness generation.', 'Impact': 'Miners could potentially manipulate the randomness, leading to unfair advantages in the selection of token IDs during redemption or swapping.', 'Location': 'Function: `getRandomTokenIdFromVault`'}, {'Issue': 'Lack of Input Validation in `setVaultFeatures` Function', 'Severity': 'Medium', 'Description': 'The `setVaultFeatures` function allows the privileged user to enable or disable various features of the vault without validating the input parameters. This could lead to unintended behavior if invalid or malicious values are passed.', 'Impact': 'Accidental or malicious changes to the vault features could disrupt the normal operation of the vault, potentially leading to financial losses or reduced functionality.', 'Location': 'Function: `setVaultFeatures`'}, {'Issue': 'Uninitialized `randNonce` Variable', 'Severity': 'Medium', 'Description': 'The `randNonce` variable is used in the `getRandomTokenIdFromVault` function to generate a random index but is never initialized. This could lead to predictable or biased random number generation.', 'Impact': 'An attacker could predict or influence the random token selection, potentially gaining an unfair advantage in the vault operations.', 'Location': 'Variable: `randNonce` in `getRandomTokenIdFromVault` function'}, {'Issue': 'Potential Front-Running in `getRandomTokenIdFromVault` Function', 'Severity': 'Medium', 'Description': 'The `getRandomTokenIdFromVault` function generates a random token ID based on block variables and a nonce. This method is susceptible to front-running attacks, where an attacker could predict or manipulate the outcome by observing the blockchain state before the transaction is mined.', 'Impact': 'Front-running could allow attackers to manipulate the selection of tokens, leading to unfair advantages and potential loss of value for other users.', 'Location': 'Function: `getRandomTokenIdFromVault`'}, {'Issue': 'Hardcoded Addresses in `transferERC721` and `transferFromERC721` Functions', 'Severity': 'Low', 'Description': 'The `transferERC721` and `transferFromERC721` functions contain hardcoded addresses for specific NFT contracts (e.g., CryptoKitties and CryptoPunks). This reduces the flexibility of the contract and could cause issues if these addresses change or if the contract needs to support other NFT standards.', 'Impact': 'The contract may not function correctly with updated or different NFT contracts, limiting its functionality and requiring manual updates to the code.', 'Location': 'Functions: `transferERC721`, `transferFromERC721`'}, {'Issue': 'Lack of Event Emission in Critical Functions', 'Severity': 'Low', 'Description': ""Some critical functions such as `setManager`, `setFees`, and `deployEligibilityStorage` do not emit events after state changes. This reduces transparency and makes it harder to track changes to the vault's state."", 'Impact': 'Reduced transparency and auditability of state changes.', 'Location': 'Functions: `setManager`, `setFees`, `deployEligibilityStorage`'}, {'Issue': 'Potential Integer Overflow in `receiveNFTs` Function', 'Severity': 'Low', 'Description': 'The `receiveNFTs` function does not check for potential integer overflow when adding to `quantity1155` and `count` variables. This could lead to unexpected behavior or vulnerabilities.', 'Impact': 'Integer overflow could lead to incorrect accounting of NFTs, potentially resulting in loss of funds or other unexpected behavior.', 'Location': 'Function: `receiveNFTs`'}], 'IssueNumber': 12, 'OutputList': 11}",686.1320571899414,"### **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Report Description**:
The Pool Manager, who is the creator of the pool, can front-run the entry fee to 100% (uint(1 ether) = 10**18), which is a per-token fee. This allows the manager to steal the entire value of user deposits. The issue arises because the manager is not a trusted actor, and anyone can create a pool. If a large deposit is made, the manager can exploit this vulnerability to set the fee to the maximum value, resulting in significant financial loss for users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of front-running by the Pool Manager to set fees to 100%. This is a critical oversight, as the described vulnerability poses a significant risk to user funds. The response list focuses on other issues such as reentrancy, input validation, and access control but does not cover this specific front-running scenario.

---

### **[M-09] Bypass zap timelock**

**Report Description**:
The `inventoryLockTime` in `NFTXStakingZap` defaults to 7 days, while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. The `_timelockMint` function in `XTokenUpgradeable` calculates the timelock as `block.timestamp + timelockLength`, even if the existing timelock is further in the future. This allows a user to reduce their long timelock (e.g., 7 days) to 2 ms by calling the `deposit` function in `NFTXInventoryStaking`, effectively bypassing the intended timelock mechanism.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of bypassing the zap timelock. This is a significant oversight, as the described vulnerability allows users to circumvent the intended timelock mechanism, potentially leading to unauthorized or premature minting of tokens. The response list focuses on other issues such as reentrancy, input validation, and randomness generation but does not cover this specific timelock bypass scenario.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**
- **[M-09] Bypass zap timelock**

---

The response list fails to address the two critical issues identified in the issue report. Both issues involve significant security risks that could lead to financial losses for users. The response list should be expanded to include these vulnerabilities to ensure comprehensive coverage of potential risks in the smart contract.","```
None.
```",0.0
NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}

",4828,479,"[M-08] Low-level call return value not checked

Submitted by cmichel
The NFTXStakingZap.addLiquidity721ETHTo function performs a low-level .call in payable(to).call{value: msg.value-amountEth} but does not check the return value if the call succeeded.
",1,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888,0,1,,"{'ReviewingTheCode': 'The provided code is a Solidity smart contract named `NFTXStakingZap` that facilitates staking and liquidity provision for NFTs in the NFTX ecosystem. It interacts with various external contracts, including NFTX vaults, Uniswap/Sushiswap, and ERC721/ERC1155 tokens. The contract allows users to stake NFTs, add liquidity, and lock their stakes for a specified period. It also includes mechanisms for handling ERC721 and ERC1155 tokens, as well as ETH/WETH conversions.', 'IdentifyingKeyComponents': {'ContractName': 'NFTXStakingZap', 'Purpose': 'To enable users to stake NFTs, provide liquidity, and lock their stakes in the NFTX ecosystem.', 'InheritanceAndImports': {'InheritsFrom': ['Ownable', 'ReentrancyGuard', 'ERC721HolderUpgradeable', 'ERC1155HolderUpgradeable'], 'Imports': ['./interface/INFTXVault.sol', './interface/INFTXVaultFactory.sol', './interface/INFTXSimpleFeeDistributor.sol', './interface/INFTXLPStaking.sol', './interface/INFTXInventoryStaking.sol', './interface/ITimelockRewardDistributionToken.sol', './interface/IUniswapV2Router01.sol', './testing/IERC721.sol', './token/IERC1155Upgradeable.sol', './token/IERC20Upgradeable.sol', './token/ERC721HolderUpgradeable.sol', './token/ERC1155HolderUpgradeable.sol', './util/OwnableUpgradeable.sol']}, 'StateVariables': [{'Name': 'WETH', 'Type': 'IWETH', 'Purpose': 'Wrapped Ether contract for handling ETH/WETH conversions.'}, {'Name': 'lpStaking', 'Type': 'INFTXLPStaking', 'Purpose': 'Contract for staking liquidity provider tokens.'}, {'Name': 'inventoryStaking', 'Type': 'INFTXInventoryStaking', 'Purpose': 'Contract for staking inventory tokens.'}, {'Name': 'nftxFactory', 'Type': 'INFTXVaultFactory', 'Purpose': 'Factory contract for creating and managing NFTX vaults.'}, {'Name': 'sushiRouter', 'Type': 'IUniswapV2Router01', 'Purpose': 'Sushiswap router for adding liquidity.'}, {'Name': 'lpLockTime', 'Type': 'uint256', 'Purpose': 'Time duration for locking liquidity provider tokens.'}, {'Name': 'inventoryLockTime', 'Type': 'uint256', 'Purpose': 'Time duration for locking inventory tokens.'}, {'Name': 'BASE', 'Type': 'uint256', 'Purpose': 'Base unit for calculations, set to 10^18.'}], 'FunctionsAndModifiers': [{'Name': 'setLPLockTime', 'Visibility': 'external', 'Purpose': 'Set the lock time for liquidity provider tokens.', 'Parameters': ['uint256 newLPLockTime'], 'Returns': []}, {'Name': 'setInventoryLockTime', 'Visibility': 'external', 'Purpose': 'Set the lock time for inventory tokens.', 'Parameters': ['uint256 newInventoryLockTime'], 'Returns': []}, {'Name': 'provideInventory721', 'Visibility': 'public', 'Purpose': 'Stake ERC721 tokens into an NFTX vault.', 'Parameters': ['uint256 vaultId', 'uint256[] memory tokenIds'], 'Returns': []}, {'Name': 'provideInventory1155', 'Visibility': 'public', 'Purpose': 'Stake ERC1155 tokens into an NFTX vault.', 'Parameters': ['uint256 vaultId', 'uint256[] memory tokenIds', 'uint256[] memory amounts'], 'Returns': []}, {'Name': 'addLiquidity721ETH', 'Visibility': 'public', 'Purpose': 'Add liquidity to a vault using ERC721 tokens and ETH.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256 minWethIn'], 'Returns': ['uint256']}, {'Name': 'addLiquidity721ETHTo', 'Visibility': 'public', 'Purpose': 'Add liquidity to a vault using ERC721 tokens and ETH, specifying the recipient.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256 minWethIn', 'address to'], 'Returns': ['uint256']}, {'Name': 'addLiquidity1155ETH', 'Visibility': 'public', 'Purpose': 'Add liquidity to a vault using ERC1155 tokens and ETH.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256[] memory amounts', 'uint256 minEthIn'], 'Returns': ['uint256']}, {'Name': 'addLiquidity1155ETHTo', 'Visibility': 'public', 'Purpose': 'Add liquidity to a vault using ERC1155 tokens and ETH, specifying the recipient.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256[] memory amounts', 'uint256 minEthIn', 'address to'], 'Returns': ['uint256']}, {'Name': 'addLiquidity721', 'Visibility': 'public', 'Purpose': 'Add liquidity to a vault using ERC721 tokens and WETH.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256 minWethIn', 'uint256 wethIn'], 'Returns': ['uint256']}, {'Name': 'addLiquidity721To', 'Visibility': 'public', 'Purpose': 'Add liquidity to a vault using ERC721 tokens and WETH, specifying the recipient.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256 minWethIn', 'uint256 wethIn', 'address to'], 'Returns': ['uint256']}, {'Name': 'addLiquidity1155', 'Visibility': 'public', 'Purpose': 'Add liquidity to a vault using ERC1155 tokens and WETH.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256[] memory amounts', 'uint256 minWethIn', 'uint256 wethIn'], 'Returns': ['uint256']}, {'Name': 'addLiquidity1155To', 'Visibility': 'public', 'Purpose': 'Add liquidity to a vault using ERC1155 tokens and WETH, specifying the recipient.', 'Parameters': ['uint256 vaultId', 'uint256[] memory ids', 'uint256[] memory amounts', 'uint256 minWethIn', 'uint256 wethIn', 'address to'], 'Returns': ['uint256']}, {'Name': 'transferFromERC721', 'Visibility': 'internal', 'Purpose': 'Transfer ERC721 tokens, handling special cases for CryptoKitties and CryptoPunks.', 'Parameters': ['address assetAddr', 'uint256 tokenId', 'address to'], 'Returns': []}, {'Name': 'approveERC721', 'Visibility': 'internal', 'Purpose': 'Approve ERC721 tokens, handling special cases for CryptoKitties and CryptoPunks.', 'Parameters': ['address assetAddr', 'address to', 'uint256 tokenId'], 'Returns': []}, {'Name': 'pairFor', 'Visibility': 'internal', 'Purpose': 'Calculate the address of a Uniswap/Sushiswap pair.', 'Parameters': ['address tokenA', 'address tokenB'], 'Returns': ['address pair']}, {'Name': 'sortTokens', 'Visibility': 'internal', 'Purpose': 'Sort two token addresses for use in pair address calculation.', 'Parameters': ['address tokenA', 'address tokenB'], 'Returns': ['address token0', 'address token1']}, {'Name': 'rescue', 'Visibility': 'external', 'Purpose': 'Rescue tokens stuck in the contract, only callable by the owner.', 'Parameters': ['address token'], 'Returns': []}]}, 'ExternalInteractions': ['INFTXVault', 'INFTXVaultFactory', 'INFTXSimpleFeeDistributor', 'INFTXLPStaking', 'INFTXInventoryStaking', 'ITimelockRewardDistributionToken', 'IUniswapV2Router01', 'IERC721', 'IERC1155Upgradeable', 'IERC20Upgradeable', 'IWETH'], 'SpecialMechanisms': ['ReentrancyGuard: Prevents reentrant calls to functions.', 'Ownable: Restricts certain functions to the contract owner.', 'ERC721HolderUpgradeable: Handles ERC721 token transfers and approvals.', 'ERC1155HolderUpgradeable: Handles ERC1155 token transfers and approvals.', 'Timelock: Implements a locking mechanism for staked tokens.', 'Uniswap/Sushiswap Integration: Facilitates liquidity provision and pair address calculation.'], 'Questions': ['How are the special cases for CryptoKitties and CryptoPunks handled in the `transferFromERC721` and `approveERC721` functions?', 'What is the purpose of the `timelockMintFor` function in the `INFTXInventoryStaking` contract?', 'How does the `pairFor` function ensure the correct Uniswap/Sushiswap pair address is calculated?', 'Are there any potential security risks associated with the `rescue` function?', 'How does the contract handle the conversion between ETH and WETH in liquidity provision functions?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in ETH Handling', 'Severity': 'High', 'Description': 'The functions `addLiquidity721ETHTo` and `addLiquidity1155ETHTo` use `call` to send ETH back to the user, which can lead to reentrancy attacks if the recipient is a malicious contract. Although the `nonReentrant` modifier is used, the state is not updated before the external call, potentially allowing an attacker to re-enter the function and manipulate the state.', 'Impact': 'An attacker could drain funds from the contract or manipulate its state, leading to financial loss or unintended behavior.', 'Location': 'Functions: `addLiquidity721ETHTo`, `addLiquidity1155ETHTo`'}, {'Issue': 'Unrestricted Approval for WETH', 'Severity': 'Medium', 'Description': 'The contract grants unlimited approval to the SushiSwap router for WETH in the constructor or other functions. This could be risky if the router is compromised or if there is a bug in its implementation.', 'Impact': ""A compromised or buggy router could drain the contract's WETH balance."", 'Location': 'Constructor, `_addLiquidity721WETH`, `_addLiquidity1155WETH`'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'Functions like `provideInventory721`, `provideInventory1155`, and others do not validate the length or content of input arrays (`tokenIds`, `amounts`). This could lead to unexpected behavior or runtime errors if the arrays are empty or contain invalid data.', 'Impact': 'Mismatched or invalid array lengths could cause the contract to behave unpredictably, potentially leading to loss of funds or incorrect state updates.', 'Location': 'Functions: `provideInventory721`, `provideInventory1155`, `addLiquidity1155To`'}, {'Issue': 'Unbounded Loops in NFT Handling', 'Severity': 'Medium', 'Description': 'Functions such as `provideInventory721`, `provideInventory1155`, and `_addLiquidity721WETH` iterate over arrays without bounds checking. Large arrays could lead to gas exhaustion or out-of-gas errors.', 'Impact': 'High gas consumption or failed transactions due to large input arrays, potentially causing denial of service.', 'Location': 'Functions: `provideInventory721`, `provideInventory1155`, `_addLiquidity721WETH`'}, {'Issue': 'Potential Front-Running in Liquidity Addition', 'Severity': 'Medium', 'Description': 'Functions like `_addLiquidityAndLock` and liquidity provision functions are susceptible to front-running attacks. Attackers could observe transactions in the mempool and manipulate prices or liquidity to their advantage.', 'Impact': 'Financial loss due to unfavorable exchange rates or manipulated liquidity pools.', 'Location': 'Functions: `_addLiquidityAndLock`, `addLiquidity721To`, `addLiquidity1155To`'}, {'Issue': 'Hardcoded Addresses for CryptoKitties and CryptoPunks', 'Severity': 'Low', 'Description': 'The contract hardcodes addresses for CryptoKitties and CryptoPunks in functions like `transferFromERC721` and `approveERC721`. This reduces flexibility and could cause issues if these contracts are upgraded or deprecated.', 'Impact': 'The contract may not function correctly with updated or deprecated NFT contracts, leading to potential loss of functionality.', 'Location': 'Functions: `transferFromERC721`, `approveERC721`'}, {'Issue': 'Lack of Event Emission for Critical State Changes', 'Severity': 'Low', 'Description': 'Functions like `setLPLockTime`, `setInventoryLockTime`, and `rescue` do not emit events when modifying critical state variables. This reduces transparency and makes it harder to track changes.', 'Impact': 'Reduced auditability and transparency, making it difficult to monitor contract state changes.', 'Location': 'Functions: `setLPLockTime`, `setInventoryLockTime`, `rescue`'}, {'Issue': 'Potential Integer Overflow', 'Severity': 'Low', 'Description': 'Functions like `provideInventory1155` perform arithmetic operations without explicit overflow checks. While Solidity 0.8.0 has built-in checks, explicit handling is still recommended.', 'Impact': 'Unexpected behavior due to integer overflow, though unlikely in practice.', 'Location': 'Functions: `provideInventory1155`, `_addLiquidity721WETH`, `_addLiquidity1155WETH`'}], 'IssueNumber': 72, 'OutputList': 8}",609.2562820911407,"---

**[M-08] Low-level call return value not checked**

**Report Description**:
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value to verify if the call succeeded. This oversight could allow the call to fail silently, potentially leading to loss of funds or unintended behavior if the recipient is a malicious contract or if the call fails for other reasons.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the specific issue of unchecked low-level call return values. While the response list includes a finding titled ""Reentrancy Vulnerability in ETH Handling,"" it focuses on the risk of reentrancy rather than the failure to check the return value of the `.call` operation. This misalignment means the core issue is not addressed, making the response incorrect for this specific vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-08] Low-level call return value not checked**

---","```
None.
```",0.0
