nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
ExtraRewardsDistributor.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";

/**
 * @title   ExtraRewardsDistributor
 * @author  adapted from ConvexFinance
 * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.
 */
contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    // token -> epoch -> amount
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    // token -> epochList
    mapping(address => uint256[]) public rewardEpochs;
    // token -> account -> last claimed epoch index
    mapping(address => mapping(address => uint256)) public userClaims;

    /* ========== EVENTS ========== */

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    /**
     * @dev Simple constructoor
     * @param _auraLocker Aura Locker address
     */
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    /* ========== ADD REWARDS ========== */

    /**
     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokenπ
     */
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    /**
     * @notice Add reward token to a specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens to add
     * @param _epoch    Which epoch to add to (must be less than the previous epoch)
     */
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    /**
     * @notice  Transfer reward tokens from sender to contract for vlCVX holders
     * @dev     Add reward token for specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens
     * @param _epoch    Epoch to add tokens to
     */
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        // Pull before reward accrual
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        //convert to reward per token
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        //add epoch to list
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        //event
        emit RewardAdded(_token, _epoch, _amount);
    }

    /* ========== GET REWARDS ========== */

    /**
     * @notice Claim rewards for a specific token since the first epoch.
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account      Address of vlCVX holder
     * @param _token        Reward token address
     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from
     */
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        //get claimable tokens
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            //set claim checkpoint
            userClaims[_token][_account] = index;

            //send
            IERC20(_token).safeTransfer(_account, claimableTokens);

            //event
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    /**
     * @notice  Allow a user to set their claimed index forward without claiming rewards
     *          Because claims cycle through all periods that a specific reward was given
     *          there becomes a situation where, for example, a new user could lock
     *          2 years from now and try to claim a token that was given out every week prior.
     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)
     * @param _token  Reward token to forfeit
     * @param _index  Epoch index to forfeit from
     */
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        //set claim checkpoint. next claim starts from index+1
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    /* ========== VIEW REWARDS ========== */

    /**
     * @notice Get claimable rewards (rewardToken) for vlCVX holder
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    /**
     * @notice  Get all claimable rewards by looping through each epoch starting with the latest
     *          saved epoch the user last claimed from
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        // e.g. tokenEpochs = 31, 21
        uint256 tokenEpochs = rewardEpochs[_token].length;

        // e.g. epochIndex = 0
        uint256 epochIndex = userClaims[_token][_account];
        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            //only claimable after rewards are ""locked in""
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                //return index user claims should be set to
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        //get balance and calc share
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    /**
     * @notice Simply gets the current epoch count for a given reward token
     * @param _token    Reward token address
     * @return _epochs  Number of epochs
     */
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",2365,268,"[H-01] User can forfeit other user rewards
User can forfeit other user rewards by giving a higher `_startIndex` in `getReward` function.
 
[M-05] Users can grief reward distribution
Users can grief reward distributions by spending dust.
If a reward is targeted for an epoch in the past, a user can front-run the txn in the mempool and call addRewardToEpoch() with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert
  [M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.   [M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens
If rewards are given in fee-on-transfer tokens, users may get no rewards, breaking functionality.
",4,,"pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";


contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    
    mapping(address => uint256[]) public rewardEpochs;
    
    mapping(address => mapping(address => uint256)) public userClaims;

    

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    

    
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        
        emit RewardAdded(_token, _epoch, _amount);
    }

    

    
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            
            userClaims[_token][_account] = index;

            
            IERC20(_token).safeTransfer(_account, claimableTokens);

            
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    

    
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        
        uint256 tokenEpochs = rewardEpochs[_token].length;

        
        uint256 epochIndex = userClaims[_token][_account];
        
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",1352,1,3,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for potential reentrancy attacks in the `_addReward` and `_getReward` functions, especially during token transfers."",
        ""Verify that all arithmetic operations, particularly in `_addReward` and `_claimableRewards`, are protected against overflow and underflow."",
        ""Ensure that external calls to `IAuraLocker` and `IERC20` are safe and do not allow for malicious contract interactions."",
        ""Review the `forfeitRewards` function to ensure it correctly updates user claims and does not allow for unintended state changes.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to ERC-20 standards, particularly in token transfers and balance checks."",
        ""Ensure that the contract follows best practices for reward distribution mechanisms.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the `_allClaimableRewards` function to ensure it correctly iterates through epochs and calculates claimable rewards without logical errors."",
        ""Review the `addRewardToEpoch` function to ensure it correctly handles backdating rewards and does not allow for invalid epoch assignments.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that interactions with `IAuraLocker` are secure and that the latest epoch data is always up-to-date."",
        ""Ensure that `IERC20` token transfers are handled securely and that the contract does not accept malicious tokens.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Check if there are any missing access controls on critical functions like `addReward`, `addRewardToEpoch`, and `forfeitRewards`."",
        ""Ensure that only authorized entities can call functions that modify state or transfer tokens.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Optimize the `_allClaimableRewards` function to reduce gas costs, especially in loops that iterate over epochs."",
        ""Review the `_addReward` function to minimize gas usage during token transfers and state updates.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the reward distribution mechanism is fair and that users cannot manipulate their rewards."",
        ""Verify that the `auraLocker` contract correctly provides the necessary data for reward calculations.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check if the contract is vulnerable to front-running attacks, particularly in the `addReward` and `getReward` functions."",
        ""Consider implementing commit-reveal schemes or other mechanisms to prevent front-running.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the contract has mechanisms to pause or halt reward distribution in case of emergencies."",
        ""Verify that there are no single points of failure that could lead to fund loss or contract exploitation.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract, ExtraRewardsDistributor, is designed to manage and distribute additional rewards to users based on their staking activity in the AuraLocker contract. It handles the addition of rewards, their distribution, and forfeiture mechanisms. The contract uses SafeERC20 for secure token transfers and ReentrancyGuard to prevent reentrancy attacks."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ExtraRewardsDistributor"",
    ""Purpose"": ""To distribute additional rewards to users based on their staking activity in the AuraLocker contract."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuard"", ""IExtraRewardsDistributor""],
      ""Imports"": [
        ""IAuraLocker"",
        ""IERC20"",
        ""SafeERC20"",
        ""ReentrancyGuard""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""auraLocker"",
        ""Type"": ""IAuraLocker"",
        ""Purpose"": ""Reference to the AuraLocker contract to interact with staking data.""
      },
      {
        ""Name"": ""rewardData"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Stores the reward data per token and epoch.""
      },
      {
        ""Name"": ""rewardEpochs"",
        ""Type"": ""mapping(address => uint256[])"",
        ""Purpose"": ""Stores the list of epochs for which rewards are available per token.""
      },
      {
        ""Name"": ""userClaims"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks the last claimed epoch for each user and token.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""addReward"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a reward for the latest epoch."",
        ""Parameters"": [""address _token"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""addRewardToEpoch"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a reward to a specific epoch."",
        ""Parameters"": [""address _token"", ""uint256 _amount"", ""uint256 _epoch""],
        ""Returns"": []
      },
      {
        ""Name"": ""_addReward"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to add a reward for a specific epoch."",
        ""Parameters"": [""address _token"", ""uint256 _amount"", ""uint256 _epoch""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Retrieves rewards for a user starting from a specific index."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _startIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""_getReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Internal function to retrieve rewards for a user."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _startIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""forfeitRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Forfeits rewards for a user up to a specific index."",
        ""Parameters"": [""address _token"", ""uint256 _index""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimableRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total claimable rewards for a user."",
        ""Parameters"": [""address _account"", ""address _token""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""claimableRewardsAtEpoch"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the claimable rewards for a user at a specific epoch."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _epoch""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_allClaimableRewards"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to calculate all claimable rewards for a user."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _startIndex""],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""_claimableRewards"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to calculate claimable rewards for a user at a specific epoch."",
        ""Parameters"": [""address _account"", ""address _token"", ""uint256 _epoch""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""rewardEpochsCount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the number of reward epochs for a specific token."",
        ""Parameters"": [""address _token""],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IAuraLocker: Used to interact with staking data and checkpoints."",
    ""IERC20: Used for token transfers and balance checks.""
  ],
  ""SpecialMechanisms"": [
    ""ReentrancyGuard: Prevents reentrancy attacks during reward distribution."",
    ""SafeERC20: Ensures safe token transfers.""
  ],
  ""Questions"": [
    ""Is there a mechanism to handle potential overflow in reward calculations?"",
    ""How is the latest epoch determined, and is there a risk of outdated data?"",
    ""Are there any checks to ensure the token address provided is valid and not a malicious contract?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Risk in _addReward Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_addReward` function uses the `nonReentrant` modifier but transfers tokens before updating the state, potentially exposing it to reentrancy attacks if the token contract is malicious. Although the modifier mitigates the risk, following the checks-effects-interactions pattern is recommended."",
      ""Impact"": ""Potential reentrancy attack leading to unexpected behavior or loss of funds."",
      ""Location"": ""_addReward function""
    },
    {
      ""Issue"": ""Unbounded Loop in _allClaimableRewards Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_allClaimableRewards` function iterates over all reward epochs for a given token, which could lead to excessive gas consumption or out-of-gas errors if the number of epochs becomes too large."",
      ""Impact"": ""Denial of service or high transaction costs due to gas limit issues."",
      ""Location"": ""_allClaimableRewards function""
    },
    {
      ""Issue"": ""Lack of Input Validation in addRewardToEpoch Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addRewardToEpoch` function does not validate the `_token` address or `_amount` parameter, potentially leading to issues if invalid inputs are provided."",
      ""Impact"": ""Potential loss of funds or unexpected behavior due to invalid inputs."",
      ""Location"": ""addRewardToEpoch function""
    },
    {
      ""Issue"": ""Potential Overflow in Reward Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The reward calculation in `_addReward` involves multiplying `_amount` by `1e20` before dividing by the total supply, which could overflow if `_amount` is very large. Solidity 0.8.x's built-in checks mitigate this risk."",
      ""Impact"": ""Incorrect reward distribution leading to potential loss of funds or unfair rewards."",
      ""Location"": ""_addReward function""
    },
    {
      ""Issue"": ""Inconsistent Function Overloading"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract contains multiple `getReward` functions with different parameters, which could lead to confusion or misuse."",
      ""Impact"": ""Potential confusion and errors in function calls."",
      ""Location"": ""getReward functions""
    },
    {
      ""Issue"": ""Potential Front-Running in Reward Claims"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `getReward` and `forfeitRewards` lack mechanisms to prevent front-running, allowing attackers to monitor the mempool and claim rewards before legitimate users."",
      ""Impact"": ""Loss of rewards for legitimate users."",
      ""Location"": ""getReward and forfeitRewards functions""
    },
    {
      ""Issue"": ""Lack of Access Control"",
      ""Severity"": ""High"",
      ""Description"": ""Critical functions like `addReward` and `addRewardToEpoch` lack access control, allowing any user to manipulate reward distributions."",
      ""Impact"": ""Potential abuse of the reward distribution mechanism."",
      ""Location"": ""addReward and addRewardToEpoch functions""
    },
    {
      ""Issue"": ""Insufficient Event Emission"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `forfeitRewards` emit events but lack detailed information (e.g., forfeited amount), reducing transparency."",
      ""Impact"": ""Reduced clarity in tracking state changes."",
      ""Location"": ""forfeitRewards function""
    }
  ],
  ""IssueNumber"": 40,
  ""OutputList"": 8
}",373.0390958786011,52045.0,26.0,"### **Output**

---

**[H-01] User can forfeit other user rewards**

**Report Description**:
A user can forfeit another user's rewards by providing a higher `_startIndex` in the `getReward` function. This allows malicious users to manipulate the reward distribution process, potentially causing legitimate users to lose their rewards.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue is not addressed in the `response_list`. The response list does not mention the specific vulnerability related to the manipulation of `_startIndex` in the `getReward` function, which is critical to this issue.

---

**[M-05] Users can grief reward distribution**

**Report Description**:
Users can grief reward distributions by spending dust amounts. If a reward is targeted for an epoch in the past, a user can front-run the transaction in the mempool and call `addRewardToEpoch()` with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert, disrupting the reward distribution process.

**Match in Response List**:
Matches with the issue titled **""Potential Front-Running in Reward Claims""**.

**Validation**:
**Partially Correct**. The response identifies the risk of front-running in reward claims but does not specifically address the issue of griefing through dust amounts or the manipulation of `addRewardToEpoch()`. The response is partially correct as it covers the broader concept of front-running but misses the specific details of this issue.

---

**[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**

**Report Description**:
Rewards may be locked forever if a user does not claim them for a very long time, such that too many epochs have passed. The platform may then be forced to reimburse the user for the locked rewards, causing significant economic loss.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue is not addressed in the `response_list`. The response list does not mention the risk of rewards being locked indefinitely due to unclaimed rewards over many epochs, which is the core of this issue.

---

**[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

**Report Description**:
If rewards are given in fee-on-transfer tokens, users may receive no rewards, breaking the functionality. This occurs because the actual amount received by the contract is less than the amount sent due to the fee-on-transfer mechanism, leading to discrepancies in reward distribution.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue is not addressed in the `response_list`. The response list does not mention the specific vulnerability related to fee-on-transfer tokens, which is critical to this issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-05] Users can grief reward distribution**

**Missed Issues from Issue Report**:
- **[H-01] User can forfeit other user rewards**
- **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**
- **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

--- 

### **Conclusion**
The `response_list` partially addresses one issue ([M-05]) but misses the other three issues entirely. The responses lack specificity and do not fully cover the vulnerabilities described in the `issue` report. Improvements are needed to ensure comprehensive coverage of all identified risks.","```
None.
```",0.0
AuraLocker.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}

/**
 * @title   AuraLocker
 * @author  ConvexFinance
 * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available
 *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes
 *          to depositors.
 * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.
 */
contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ==========     STRUCTS     ========== */

    struct RewardData {
        /// Timestamp for current period finish
        uint32 periodFinish;
        /// Last time any user took action
        uint32 lastUpdateTime;
        /// RewardRate for the rest of the period
        uint96 rewardRate;
        /// Ever increasing rewardPerToken rate, based on % of total supply
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; //epoch start date
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    /* ========== STATE VARIABLES ========== */

    // Rewards
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    //     Core reward data
    mapping(address => RewardData) public rewardData;
    //     Reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;
    //     User -> reward token -> amount
    mapping(address => mapping(address => UserData)) public userData;
    //     Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;
    //     Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // Balances
    //     Supplies and historic supply
    uint256 public lockedSupply;
    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply
    Epoch[] public epochs;
    //     Mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    // Voting
    //     Stored delegations
    mapping(address => address) private _delegates;
    //     Checkpointed votes
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    //     Delegatee balances (user -> unlock timestamp -> amount)
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    // Config
    //     Tokens
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    //     Denom for calcs
    uint256 public constant denominator = 10000;
    //     Staking cvxCrv
    address public immutable cvxcrvStaking;
    //     Incentives
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    //     Shutdown
    bool public isShutdown = false;

    // Basic token data
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== EVENTS ========== */

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    /***************************************
                    CONSTRUCTOR
    ****************************************/

    /**
     * @param _nameArg          Token name, simples
     * @param _symbolArg        Token symbol
     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)
     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)
     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)
     */
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    /***************************************
                    MODIFIER
    ****************************************/

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    /***************************************
                    ADMIN
    ****************************************/

    // Add a new reward token to be distributed to stakers
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); //max 5% per epoch
        require(_delay >= 2, ""min delay""); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    // Set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    /***************************************
                    ACTIONS
    ****************************************/

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount);
    }

    //lock tokens
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //add user balances
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(_amount);

        //add user lock records or add to current
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length
        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps until the next epoch date.
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        // e.g. now = 16
        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)
        // e.g. 17 <= (16 + 1)
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > expiryTime) break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        //checkpoint the delegatee
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        //relock or return to user
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    /***************************************
            DELEGATION & VOTE BALANCE
    ****************************************/

    /**
     * @dev Delegate votes from the sender to `newDelegatee`.
     */
    function delegate(address newDelegatee) external virtual nonReentrant {
        // Step 1: Get lock data
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        // Step 2: Update delegatee storage
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        // Step 3: Move balances around
        //         Delegate for the upcoming epoch
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        // Step 3.1: Add future unlocks and sum balances
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        // Step 3.2: Checkpoint old delegatee
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        // Step 3.3: Checkpoint new delegatee
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        // This would only skip on first checkpointing
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired
                // e.g. week 1 + 17 <= 18
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    // Should be maximum 18 iterations
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    /**
     * @dev Get the address `account` is currently delegating to.
     */
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    /**
     * @dev Gets the current votes balance for `account`
     */
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    /**
     * @dev Get the `pos`-th checkpoint for `account`.
     */
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    /**
     * @dev Get number of checkpoints for `account`.
     */
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    /**
     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.
     */
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    /**
     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.
     * It is but NOT the sum of all the delegated votes!
     */
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    /**
     * @dev Lookup a value in a list of (sorted) checkpoints.
     *      Copied from oz/ERC20Votes.sol
     */
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    /***************************************
                VIEWS - BALANCES
    ****************************************/

    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    // Balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    // Supply of all properly locked balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    // Supply of all properly locked balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    // Get an epoch index based on timestamp
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    /***************************************
                VIEWS - GENERAL
    ****************************************/

    // Number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /***************************************
                VIEWS - REWARDS
    ****************************************/

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    /***************************************
                REWARD FUNDING
    ****************************************/

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        //et = now - (finish-duration)
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        //current at now: rewardRate * elapsedTime
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",7734,876,"[M-03] Improperly Skewed Governance Mechanism
The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances. As a result, governance percentage thresholds will be significantly affected and potentially unmet.   [M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance
The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired. In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch.
  [M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848
Rewards distribution can be delayed/never distributed on the function `_rewardPerToken()`
  [M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.   [M-08] Locking up AURA Token does not increase voting power of individual
Per the documentation, AURA tokens can be locked in the AuraLocker to recieve vlAURA. vlAURA is voting power in the AURA ecosystem.
It is also possible for the users to delegate their voting power to a specific address by calling the `AuraLocker.delegate(address account)` function.
However, after users locked up their AURA tokens in exchange for vlAURA tokens, their voting power did not increase.
  [M-10] Increase voting power by tokenizing the address that locks the token
Without restriction on the type of address that lock the token in function `_lock`, a bad actor could lock the token through the smart contract.
  [M-14] Integer overflow will lock all rewards in AuraLocker
There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.
",7,,"pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}


contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    

    struct RewardData {
        
        uint32 periodFinish;
        
        uint32 lastUpdateTime;
        
        uint96 rewardRate;
        
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; 
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    

    
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    
    mapping(address => RewardData) public rewardData;
    
    mapping(address => mapping(address => bool)) public rewardDistributors;
    
    mapping(address => mapping(address => UserData)) public userData;
    
    uint256 public constant rewardsDuration = 86400 * 7;
    
    uint256 public constant lockDuration = rewardsDuration * 17;

    
    
    uint256 public lockedSupply;
    
    Epoch[] public epochs;
    
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    
    
    mapping(address => address) private _delegates;
    
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    
    
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    
    uint256 public constant denominator = 10000;
    
    address public immutable cvxcrvStaking;
    
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    
    bool public isShutdown = false;

    
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    

    
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    

    
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); 
        require(_delay >= 2, ""min delay""); 
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    

    
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        
        _lock(_account, _amount);
    }

    
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        
        _checkpointEpoch();

        
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        
        lockedSupply = lockedSupply.add(_amount);

        
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    
    function getReward(address _account) external {
        getReward(_account, false);
    }

    
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        
        
        if (epochs[epochindex - 1].date < currentEpoch) {
            
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        
        
        
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            
            locked = userBalance.locked;

            
            userBalance.nextUnlockIndex = length.to32();

            
            
            
            
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            
            
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                
                if (locks[i].unlockTime > expiryTime) break;

                
                locked = locked.add(locks[i].amount);

                
                
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                
                nextUnlockIndex++;
            }
            
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        
        if (reward > 0) {
            
            locked = locked.sub(reward.to112());

            
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    

    
    function delegate(address newDelegatee) external virtual nonReentrant {
        
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        
        
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                
                
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    

    
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        
        
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            
            
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    
                    break;
                }
            }
        }

        return amount;
    }

    
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    

    
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    

    
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        
        
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",6073,0,7,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for potential reentrancy attacks in functions handling external calls, especially `lock`, `getReward`, and `processExpiredLocks`."",
        ""Verify that all arithmetic operations are safe from overflow/underflow, particularly in reward calculations and epoch management."",
        ""Ensure that all external calls (e.g., `safeTransfer`, `safeTransferFrom`) are properly checked for success."",
        ""Review the use of `nonReentrant` modifier to ensure it is applied to all relevant functions.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Ensure the contract adheres to ERC-20 standards for token interactions, especially in reward distribution and delegation."",
        ""Verify that the contract complies with OpenZeppelin's `Ownable` and `ReentrancyGuard` patterns.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the reward distribution logic, especially in `_notifyReward` and `queueNewRewards`, to ensure accuracy and fairness."",
        ""Review the epoch management system in `_checkpointEpoch` and `findEpochId` for correctness and efficiency."",
        ""Examine the delegation mechanism in `delegate` and `_checkpointDelegate` to ensure votes are accurately tracked and updated.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that all interactions with external contracts (e.g., `IERC20`, `IRewardStaking`) are secure and handle potential failures."",
        ""Ensure that the `setApprovals` function correctly sets allowances for external staking contracts.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Check that only authorized users (e.g., `onlyOwner`) can call critical functions like `addReward`, `shutdown`, and `recoverERC20`."",
        ""Verify that reward distributors are properly authorized and managed in `approveRewardDistributor`.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, particularly in loops and reward calculations."",
        ""Review the use of storage variables and consider optimizations to reduce gas costs.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the reward distribution mechanism is fair and cannot be manipulated, especially in `_notifyReward` and `queueNewRewards`."",
        ""Verify that the locking mechanism in `_lock` and `processExpiredLocks` correctly handles user balances and supply updates.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Audit the delegation and voting power tracking system in `delegate`, `_checkpointDelegate`, and `getPastVotes` for vulnerabilities."",
        ""Ensure that the `getVotes` and `getPastTotalSupply` functions accurately reflect user voting power.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that the `shutdown` function effectively halts all critical operations and prevents further locks."",
        ""Ensure that the `emergencyWithdraw` function allows users to recover funds safely in case of shutdown.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract is a complex staking and reward distribution system designed to lock tokens, manage rewards, and handle delegation. It includes mechanisms for locking tokens, distributing rewards, and managing voting power through delegation. The contract is designed to be non-reentrant and uses OpenZeppelin libraries for security and ownership management."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""AuraLocker"",
    ""Purpose"": ""To manage token locking, reward distribution, and delegation for a staking system. It allows users to lock tokens, earn rewards, and delegate their voting power."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ReentrancyGuard"", ""Ownable"", ""IAuraLocker""],
      ""Imports"": [
        ""IERC20"",
        ""SafeERC20"",
        ""Ownable"",
        ""ReentrancyGuard"",
        ""AuraMath"",
        ""AuraMath32"",
        ""AuraMath112"",
        ""AuraMath224"",
        ""./Interfaces.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""rewardTokens"",
        ""Type"": ""address[]"",
        ""Purpose"": ""List of reward tokens that can be distributed.""
      },
      {
        ""Name"": ""queuedCvxCrvRewards"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Rewards queued for distribution.""
      },
      {
        ""Name"": ""newRewardRatio"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Ratio used to determine reward distribution.""
      },
      {
        ""Name"": ""rewardData"",
        ""Type"": ""mapping(address => RewardData)"",
        ""Purpose"": ""Stores reward data for each token.""
      },
      {
        ""Name"": ""rewardDistributors"",
        ""Type"": ""mapping(address => mapping(address => bool))"",
        ""Purpose"": ""Stores authorized reward distributors for each token.""
      },
      {
        ""Name"": ""userData"",
        ""Type"": ""mapping(address => mapping(address => UserData))"",
        ""Purpose"": ""Stores user-specific reward data.""
      },
      {
        ""Name"": ""rewardsDuration"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the reward period.""
      },
      {
        ""Name"": ""lockDuration"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration for which tokens are locked.""
      },
      {
        ""Name"": ""lockedSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total amount of locked tokens.""
      },
      {
        ""Name"": ""epochs"",
        ""Type"": ""Epoch[]"",
        ""Purpose"": ""Stores historical data of locked supply.""
      },
      {
        ""Name"": ""balances"",
        ""Type"": ""mapping(address => Balances)"",
        ""Purpose"": ""Stores user balances and unlock indices.""
      },
      {
        ""Name"": ""userLocks"",
        ""Type"": ""mapping(address => LockedBalance[])"",
        ""Purpose"": ""Stores user-specific lock data.""
      },
      {
        ""Name"": ""_delegates"",
        ""Type"": ""mapping(address => address)"",
        ""Purpose"": ""Stores user delegates.""
      },
      {
        ""Name"": ""_checkpointedVotes"",
        ""Type"": ""mapping(address => DelegateeCheckpoint[])"",
        ""Purpose"": ""Stores checkpointed votes for delegates.""
      },
      {
        ""Name"": ""delegateeUnlocks"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Stores unlock amounts for delegates.""
      },
      {
        ""Name"": ""stakingToken"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""Token used for staking.""
      },
      {
        ""Name"": ""cvxCrv"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the cvxCrv token.""
      },
      {
        ""Name"": ""denominator"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Denominator used in calculations.""
      },
      {
        ""Name"": ""cvxcrvStaking"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the cvxCrv staking contract.""
      },
      {
        ""Name"": ""kickRewardPerEpoch"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Reward rate for kicking expired locks.""
      },
      {
        ""Name"": ""kickRewardEpochDelay"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Delay before kick rewards are applied.""
      },
      {
        ""Name"": ""isShutdown"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates if the contract is shutdown.""
      },
      {
        ""Name"": ""_name"",
        ""Type"": ""string"",
        ""Purpose"": ""Name of the contract.""
      },
      {
        ""Name"": ""_symbol"",
        ""Type"": ""string"",
        ""Purpose"": ""Symbol of the contract.""
      },
      {
        ""Name"": ""_decimals"",
        ""Type"": ""uint8"",
        ""Purpose"": ""Decimals used for token calculations.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the staking token, cvxCrv token, and staking contract addresses."",
        ""Parameters"": [""string memory _nameArg"", ""string memory _symbolArg"", ""address _stakingToken"", ""address _cvxCrv"", ""address _cvxCrvStaking""],
        ""Returns"": []
      },
      {
        ""Name"": ""addReward"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new reward token and sets its distributor."",
        ""Parameters"": [""address _rewardsToken"", ""address _distributor""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveRewardDistributor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves or revokes a reward distributor for a token."",
        ""Parameters"": [""address _rewardsToken"", ""address _distributor"", ""bool _approved""],
        ""Returns"": []
      },
      {
        ""Name"": ""setKickIncentive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the kick reward rate and delay."",
        ""Parameters"": [""uint256 _rate"", ""uint256 _delay""],
        ""Returns"": []
      },
      {
        ""Name"": ""shutdown"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Shuts down the contract, preventing further locks."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""recoverERC20"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Recovers ERC20 tokens sent to the contract."",
        ""Parameters"": [""address _tokenAddress"", ""uint256 _tokenAmount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setApprovals"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets approvals for the cvxCrv staking contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Locks tokens for a user."",
        ""Parameters"": [""address _account"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""getReward"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims rewards for a user."",
        ""Parameters"": [""address _account"", ""bool _stake""],
        ""Returns"": []
      },
      {
        ""Name"": ""checkpointEpoch"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Checkpoints the current epoch."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""processExpiredLocks"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Processes expired locks for a user."",
        ""Parameters"": [""bool _relock""],
        ""Returns"": []
      },
      {
        ""Name"": ""kickExpiredLocks"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Kicks expired locks for a user."",
        ""Parameters"": [""address _account""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw tokens in case of shutdown."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""delegate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Delegates voting power to another address."",
        ""Parameters"": [""address newDelegatee""],
        ""Returns"": []
      },
      {
        ""Name"": ""delegates"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the delegatee for a user."",
        ""Parameters"": [""address account""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""getVotes"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the current voting power of a user."",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""checkpoints"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns a checkpoint for a delegatee."",
        ""Parameters"": [""address account"", ""uint32 pos""],
        ""Returns"": [""DelegateeCheckpoint memory""]
      },
      {
        ""Name"": ""numCheckpoints"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the number of checkpoints for a delegatee."",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint32""]
      },
      {
        ""Name"": ""getPastVotes"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the voting power of a user at a past timestamp."",
        ""Parameters"": [""address account"", ""uint256 timestamp""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getPastTotalSupply"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total supply at a past timestamp."",
        ""Parameters"": [""uint256 timestamp""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the balance of a user."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""balanceAtEpochOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the balance of a user at a specific epoch."",
        ""Parameters"": [""uint256 _epoch"", ""address _user""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""lockedBalances"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the locked balances of a user."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256 total"", ""uint256 unlockable"", ""uint256 locked"", ""LockedBalance[] memory lockData""]
      },
      {
        ""Name"": ""totalSupply"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total supply of locked tokens."",
        ""Parameters"": [],
        ""Returns"": [""uint256 supply""]
      },
      {
        ""Name"": ""totalSupplyAtEpoch"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total supply of locked tokens at a specific epoch."",
        ""Parameters"": [""uint256 _epoch""],
        ""Returns"": [""uint256 supply""]
      },
      {
        ""Name"": ""findEpochId"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Finds the epoch ID for a given timestamp."",
        ""Parameters"": [""uint256 _time""],
        ""Returns"": [""uint256 epoch""]
      },
      {
        ""Name"": ""epochCount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the number of epochs."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""decimals"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the decimals of the contract."",
        ""Parameters"": [],
        ""Returns"": [""uint8""]
      },
      {
        ""Name"": ""name"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the name of the contract."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""symbol"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the symbol of the contract."",
        ""Parameters"": [],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""claimableRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the claimable rewards for a user."",
        ""Parameters"": [""address _account""],
        ""Returns"": [""EarnedData[] memory userRewards""]
      },
      {
        ""Name"": ""lastTimeRewardApplicable"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the last time reward was applicable for a token."",
        ""Parameters"": [""address _rewardsToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""rewardPerToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the reward per token for a token."",
        ""Parameters"": [""address _rewardsToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_earned"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the earned rewards for a user."",
        ""Parameters"": [""address _user"", ""address _rewardsToken"", ""uint256 _balance""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_lastTimeRewardApplicable"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the last time reward was applicable."",
        ""Parameters"": [""uint256 _finishTime""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_rewardPerToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the reward per token."",
        ""Parameters"": [""address _rewardsToken""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""queueNewRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Queues new rewards for distribution."",
        ""Parameters"": [""uint256 _rewards""],
        ""Returns"": []
      },
      {
        ""Name"": ""notifyRewardAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Notifies the contract of a new reward amount."",
        ""Parameters"": [""address _rewardsToken"", ""uint256 _reward""],
        ""Returns"": []
      },
      {
        ""Name"": ""_notifyReward"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to notify the contract of a new reward."",
        ""Parameters"": [""address _rewardsToken"", ""uint256 _reward""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20"",
    ""IRewardStaking"",
    ""OpenZeppelin libraries (SafeERC20, Ownable, ReentrancyGuard)""
  ],
  ""SpecialMechanisms"": [
    ""Reward distribution mechanism with queued rewards"",
    ""Token locking mechanism with epochs"",
    ""Delegation mechanism with checkpointed votes"",
    ""Non-reentrant functions to prevent reentrancy attacks""
  ],
  ""Questions"": [
    ""How is the reward distribution ratio determined?"",
    ""What is the purpose of the `_checkpointDelegate` function and how does it work?"",
    ""How does the contract handle the case where multiple reward tokens are added?"",
    ""What are the implications of the `isShutdown` flag on the contract's functionality?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in `_processExpiredLocks` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_processExpiredLocks` function transfers tokens to the user before updating the state, making it susceptible to reentrancy attacks if the `stakingToken` is a malicious ERC20 token. Although some instances mention the `nonReentrant` modifier, the state update after transfer remains a risk."",
      ""Impact"": ""An attacker could exploit this vulnerability to drain funds from the contract or manipulate the contract's state."",
      ""Location"": ""`_processExpiredLocks` function, line 456 and other instances""
    },
    {
      ""Issue"": ""Potential Reentrancy in `lock` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `lock` function transfers tokens from the caller to the contract before updating the state, which could lead to reentrancy attacks if the token contract has a callback mechanism. The `nonReentrant` modifier is used, but the checks-effects-interactions pattern is not strictly followed."",
      ""Impact"": ""An attacker could manipulate the contract's state or drain funds."",
      ""Location"": ""`lock` function""
    },
    {
      ""Issue"": ""Potential Reentrancy in `emergencyWithdraw` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `emergencyWithdraw` function updates the state after transferring tokens, violating the checks-effects-interactions pattern and making it vulnerable to reentrancy attacks."",
      ""Impact"": ""An attacker could withdraw more tokens than they are entitled to, draining the contract's funds."",
      ""Location"": ""Function `emergencyWithdraw`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `addReward` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addReward` function does not validate the `_rewardsToken` and `_distributor` addresses, which could lead to the addition of invalid or malicious tokens and distributors."",
      ""Impact"": ""Invalid or malicious tokens could disrupt reward distribution, leading to loss of funds or unexpected behavior."",
      ""Location"": ""`addReward` function, line 200 and other instances""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `_notifyReward` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_notifyReward` function performs arithmetic operations without checking for potential integer overflow, especially when calculating `leftover` and `rdata.rewardRate`. Although Solidity 0.8.x has built-in overflow checks, edge cases should be handled gracefully."",
      ""Impact"": ""Incorrect reward distribution or contract malfunction due to overflow."",
      ""Location"": ""`_notifyReward` function, line 640 and other instances""
    },
    {
      ""Issue"": ""Unbounded Loop in `_checkpointEpoch` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_checkpointEpoch` function contains a loop that could run indefinitely if the `currentEpoch` is significantly behind the latest epoch, leading to high gas consumption or out-of-gas errors."",
      ""Impact"": ""High gas costs or transaction failures could disrupt the delegation mechanism or reward distribution."",
      ""Location"": ""Function `_checkpointEpoch`""
    },
    {
      ""Issue"": ""Insufficient Access Control in `notifyRewardAmount` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `notifyRewardAmount` function allows any reward distributor to notify rewards without validating the `_rewardsToken` address, potentially leading to unauthorized reward notifications."",
      ""Impact"": ""Incorrect reward distributions or manipulation of the reward system."",
      ""Location"": ""Function `notifyRewardAmount`""
    },
    {
      ""Issue"": ""Insufficient Event Emission in Critical Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical functions like `_lock`, `_processExpiredLocks`, `setApprovals`, and `shutdown` do not emit events, reducing transparency and making it difficult to track state changes."",
      ""Impact"": ""Lack of visibility into contract activity, complicating auditing and monitoring."",
      ""Location"": ""Functions `_lock`, `_processExpiredLocks`, `setApprovals`, `shutdown`""
    },
    {
      ""Issue"": ""Potential Division by Zero in `_rewardPerToken` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_rewardPerToken` function divides by `lockedSupply`, which could be zero. While the function checks for zero, explicit handling of edge cases is recommended."",
      ""Impact"": ""Potential division by zero leading to unexpected behavior."",
      ""Location"": ""Function `_rewardPerToken`""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 9
}",440.14072585105896,155000.0,24.0,"### **Summary of Matches and Gaps**

---

#### **[M-03] Improperly Skewed Governance Mechanism**

**Report Description**:  
The balance checkpointing system for governance is flawed because it does not properly maintain voting balances. The total supply of votes is tracked as the sum of all locked balances, but the individual voting power only tracks delegated balances. This discrepancy can significantly affect governance percentage thresholds, potentially rendering them unmet.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the governance mechanism or the discrepancy between locked and delegated balances. This is a critical oversight as it directly impacts the governance system's integrity.

---

#### **[M-04] AuraLocker Kick Reward Only Takes Last Locked Amount into Consideration, Instead of Whole Balance**

**Report Description**:  
In `AuraLocker`, when expired locks are processed via kicking, the kick reward calculation only considers the last locked amount instead of the entire balance. Specifically, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch, which is incorrect.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the incorrect reward calculation in `_processExpiredLocks`. This is a significant issue as it could lead to unfair reward distributions.

---

#### **[M-06] Rewards Distribution Can Be Delayed/Never Distributed on AuraLocker.sol#L848**

**Report Description**:  
Rewards distribution can be delayed or never distributed in the `_rewardPerToken` function. This could occur due to improper handling of reward calculations or edge cases, leading to a failure in distributing rewards to users.

**Match in Response List**:  
Matches with the issue titled **""Potential Division by Zero in `_rewardPerToken` Function""**.

**Validation**:  
**Partially Correct**. The response identifies a potential division by zero in `_rewardPerToken`, which could lead to delayed or failed reward distribution. However, it does not address other potential causes of delayed or failed distributions, such as improper reward calculations or edge cases.

---

#### **[M-07] Reward May Be Locked Forever If User Doesn't Claim Reward for a Very Long Time**

**Report Description**:  
If a user does not claim their reward for a very long time, the reward may be locked forever. This could force the platform to reimburse the user, causing significant economic loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of rewards being locked indefinitely due to prolonged inactivity. This is a critical oversight as it could lead to substantial financial losses for the platform.

---

#### **[M-08] Locking Up AURA Token Does Not Increase Voting Power of Individual**

**Report Description**:  
Per the documentation, locking AURA tokens in `AuraLocker` should grant vlAURA (voting power). However, after locking tokens, users' voting power does not increase, even though they can delegate their voting power.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of locked tokens not increasing voting power. This is a significant flaw in the governance mechanism.

---

#### **[M-10] Increase Voting Power by Tokenizing the Address That Locks the Token**

**Report Description**:  
The `_lock` function does not restrict the type of address that can lock tokens. A bad actor could lock tokens through a smart contract, potentially manipulating the voting system.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the lack of restrictions on the type of address that can lock tokens. This is a critical oversight as it could lead to manipulation of the voting system.

---

#### **[M-14] Integer Overflow Will Lock All Rewards in AuraLocker**

**Report Description**:  
There is a potential integer overflow in the rewards calculations, which would cause `updateReward()` to always revert, effectively locking all rewards.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow in `_notifyReward` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the potential integer overflow in reward calculations, which aligns with the reported issue. This could indeed lead to rewards being locked if `updateReward()` reverts due to overflow.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-14] Integer Overflow Will Lock All Rewards in AuraLocker**

**Partially Correct Matches**:

- **[M-06] Rewards Distribution Can Be Delayed/Never Distributed on AuraLocker.sol#L848**

**Missed Issues from Issue Report**:

- **[M-03] Improperly Skewed Governance Mechanism**
- **[M-04] AuraLocker Kick Reward Only Takes Last Locked Amount into Consideration, Instead of Whole Balance**
- **[M-07] Reward May Be Locked Forever If User Doesn't Claim Reward for a Very Long Time**
- **[M-08] Locking Up AURA Token Does Not Increase Voting Power of Individual**
- **[M-10] Increase Voting Power by Tokenizing the Address That Locks the Token**

---

### **Conclusion**

The response list partially addresses some issues but misses several critical vulnerabilities, particularly those related to governance mechanisms, reward calculations, and voting power. These gaps highlight the need for a more comprehensive review of the contract's functionality and security.",1. Potential Integer Overflow in `_notifyReward` Function,"To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Potential Integer Overflow in `_notifyReward` Function"".
   - This issue appears at rank 5 in the ranked list of predictions.

2. **Calculate the precision at rank 5 (\( P@5 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 5, \( P@5 = \frac{1}{5} = 0.2 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.2 \).

**Output**:
```
0.2
```"
ConvexMasterChef.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";

/**
 * @title   ConvexMasterChef
 * @author  ConvexFinance
 * @notice  Masterchef can distribute rewards to n pools over x time
 * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,
 *          and thus it can over complicate the distribution of these rewards.
 *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed
 *          pro-rata based on the allocation points in each pool vs the total alloc.
 */
contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of CVXs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.
        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.
        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.
        IRewarder rewarder;
    }

    //cvx
    IERC20 public immutable cvx;
    // CVX tokens created per block.
    uint256 public immutable rewardPerBlock;
    // Bonus muliplier for early cvx makers.
    uint256 public constant BONUS_MULTIPLIER = 2;

    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when CVX mining starts.
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    // Events
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    // Add a new lp to the pool. Can only be called by the owner.
    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    // Update the given pool's CVX allocation point. Can only be called by the owner.
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    // View function to see pending CVXs on frontend.
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        //cvx.mint(address(this), cvxReward);
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    // Deposit LP tokens to MasterChef for CVX allocation.
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2667,308,"[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect
In the ConvexMasterChef contract, a new staking pool can be added using the `add()` function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the `_lpToken` is the same as the reward token (cvx) or not.
  [M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds
All calculations are rounded down, since a lack of tokens in the contracts cannot be rounding errors' fault. So the function is redundant. On the other hand, if the contract is undersupplied with cvx tokens, this will cause depositors to be sent less tokens than needed (or none). This is especially unsafe because the tokens that were lacking are not resembled in accountings at all. Thus a depositor may invoke the safeRewardTransfer and not receive tokens they were supposed to.
  [M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control
Reward token accounting update in `deposit()` and `withdraw()` happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.
  [M-20] massUpdatePools() is susceptible to DoS with block gas limit
`massUpdatePools()` is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo. If poolInfo.length is big enough, block gas limit may be hit.   [M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools
  [M-22] Duplicate LP token could lead to incorrect reward distribution
It was observed that add function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with reward distribution

",6,,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";


contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    
    struct UserInfo {
        uint256 amount; 
        uint256 rewardDebt; 
        
        
        
        
        
        
        
        
        
        
        
    }

    
    struct PoolInfo {
        IERC20 lpToken; 
        uint256 allocPoint; 
        uint256 lastRewardBlock; 
        uint256 accCvxPerShare; 
        IRewarder rewarder;
    }

    
    IERC20 public immutable cvx;
    
    uint256 public immutable rewardPerBlock;
    
    uint256 public constant BONUS_MULTIPLIER = 2;

    
    PoolInfo[] public poolInfo;
    
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    
    uint256 public totalAllocPoint = 0;
    
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    
    
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2047,0,6,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for potential reentrancy attacks in functions that transfer tokens (e.g., `deposit`, `withdraw`, `emergencyWithdraw`)."",
        ""Verify that all arithmetic operations are protected against overflow/underflow using SafeMath."",
        ""Ensure that external calls (e.g., `IRewarder.onReward`) are safe and do not allow for reentrancy."",
        ""Review the `safeRewardTransfer` function to ensure it correctly handles insufficient balance scenarios.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to ERC-20 standards for token transfers."",
        ""Verify that the contract correctly implements the Ownable pattern for access control.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the reward calculation logic in `pendingCvx` and `updatePool` to ensure accuracy."",
        ""Verify that the `getMultiplier` function correctly calculates the reward multiplier within the start and end block range.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Ensure that interactions with the `IRewarder` interface are safe and do not introduce vulnerabilities."",
        ""Verify that the contract correctly handles external ERC-20 token transfers.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Confirm that only the owner can add or modify pools using the `add` and `set` functions."",
        ""Ensure that the `emergencyWithdraw` function does not bypass access control checks.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, especially in loops (e.g., `massUpdatePools`)."",
        ""Review the use of storage variables to minimize gas costs.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the contract correctly handles LP token balances and does not allow for manipulation."",
        ""Verify that the contract does not introduce impermanent loss risks for stakers.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Review the contract to ensure it is not vulnerable to flash loan attacks, especially in reward distribution.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Ensure that the contract does not rely on external oracles for critical operations.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Verify that the contract does not include governance or voting mechanisms that could be exploited.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that reward distribution is fair and accurate, based on staked amounts and allocation points."",
        ""Verify that the contract correctly handles the end of the reward period (`endBlock`).""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the reward distribution mechanism to ensure it does not lead to inflationary token models.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities in functions that update user rewards (e.g., `deposit`, `withdraw`).""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the owner cannot drain funds from the contract maliciously.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that the `emergencyWithdraw` function provides a safe exit mechanism for users in case of emergencies.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided Solidity code is for a ConvexMasterChef contract, which is a staking and rewards distribution contract. It allows users to deposit LP tokens, earn rewards in the form of CVX tokens, and withdraw their staked tokens. The contract also supports additional rewarders for extra incentives."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ConvexMasterChef"",
    ""Purpose"": ""To manage staking of LP tokens and distribute CVX rewards to users based on their staked amounts and the pool's allocation points."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""@openzeppelin/contracts-0.6/math/SafeMath.sol"",
        ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"",
        ""@openzeppelin/contracts-0.6/utils/Context.sol"",
        ""@openzeppelin/contracts-0.6/access/Ownable.sol"",
        ""./interfaces/IRewarder.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""cvx"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""The CVX token that is distributed as a reward.""
      },
      {
        ""Name"": ""rewardPerBlock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The amount of CVX tokens rewarded per block.""
      },
      {
        ""Name"": ""BONUS_MULTIPLIER"",
        ""Type"": ""uint256"",
        ""Purpose"": ""A constant multiplier for rewards, currently set to 2.""
      },
      {
        ""Name"": ""poolInfo"",
        ""Type"": ""PoolInfo[]"",
        ""Purpose"": ""Array of PoolInfo structs storing information about each staking pool.""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(uint256 => mapping(address => UserInfo))"",
        ""Purpose"": ""Mapping to store user-specific staking information for each pool.""
      },
      {
        ""Name"": ""totalAllocPoint"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total allocation points across all pools, used to calculate rewards.""
      },
      {
        ""Name"": ""startBlock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The block number when reward distribution starts.""
      },
      {
        ""Name"": ""endBlock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The block number when reward distribution ends.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""add"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Add a new pool with a specific allocation point, LP token, and rewarder."",
        ""Parameters"": [""uint256 _allocPoint"", ""IERC20 _lpToken"", ""IRewarder _rewarder"", ""bool _withUpdate""],
        ""Returns"": []
      },
      {
        ""Name"": ""set"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Update the allocation point and rewarder of an existing pool."",
        ""Parameters"": [""uint256 _pid"", ""uint256 _allocPoint"", ""IRewarder _rewarder"", ""bool _withUpdate"", ""bool _updateRewarder""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMultiplier"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculate the multiplier for rewards between two block numbers."",
        ""Parameters"": [""uint256 _from"", ""uint256 _to""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""pendingCvx"",
        ""Visibility"": ""external"",
        ""Purpose"": ""View function to get the pending CVX rewards for a user in a specific pool."",
        ""Parameters"": [""uint256 _pid"", ""address _user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""massUpdatePools"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Update all pools to reflect the latest rewards."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updatePool"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Update a specific pool to reflect the latest rewards."",
        ""Parameters"": [""uint256 _pid""],
        ""Returns"": []
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposit LP tokens into a pool to start earning rewards."",
        ""Parameters"": [""uint256 _pid"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Withdraw staked LP tokens from a pool and claim rewards."",
        ""Parameters"": [""uint256 _pid"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claim pending CVX rewards for a user in a specific pool."",
        ""Parameters"": [""uint256 _pid"", ""address _account""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Withdraw staked LP tokens from a pool without claiming rewards, used in emergencies."",
        ""Parameters"": [""uint256 _pid""],
        ""Returns"": []
      },
      {
        ""Name"": ""safeRewardTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Safely transfer CVX rewards to a user, ensuring the contract has enough balance."",
        ""Parameters"": [""address _to"", ""uint256 _amount""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20: Used for interacting with ERC20 tokens, specifically CVX and LP tokens."",
    ""IRewarder: An interface for additional rewarders that can be used to distribute extra incentives.""
  ],
  ""SpecialMechanisms"": [
    ""The contract uses a MasterChef-like mechanism for distributing rewards based on staked amounts and allocation points."",
    ""SafeMath and SafeERC20 libraries are used to prevent overflow and ensure safe token transfers."",
    ""The contract supports additional rewarders via the IRewarder interface, allowing for flexible reward distribution.""
  ],
  ""Questions"": [
    ""What is the purpose of the `rewardDebt` field in the UserInfo struct?"",
    ""How does the `BONUS_MULTIPLIER` affect the reward distribution?"",
    ""Is there any mechanism to handle the case where the reward period ends before all rewards are distributed?"",
    ""Are there any potential security risks associated with the `emergencyWithdraw` function?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in `deposit` and `withdraw` Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `deposit` and `withdraw` functions make external calls to the `rewarder` contract before updating the user's state, potentially allowing reentrancy attacks if the `rewarder` contract is malicious or compromised. The state should be updated before making any external calls."",
      ""Impact"": ""An attacker could exploit this to reenter the contract and manipulate the state, potentially leading to loss of funds or incorrect reward distribution."",
      ""Location"": ""Functions: `deposit`, `withdraw`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `add` and `set` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `add` and `set` functions do not validate input parameters such as `_allocPoint`, `_lpToken`, and `_rewarder`, which could lead to invalid or malicious inputs being accepted, causing unexpected behavior or vulnerabilities."",
      ""Impact"": ""Invalid inputs could disrupt reward distribution or cause the contract to behave unexpectedly."",
      ""Location"": ""Functions: `add`, `set`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `SafeMath` for arithmetic operations, but the Solidity version (0.6.12) lacks built-in overflow/underflow checks. While `SafeMath` mitigates risks, inconsistent use could still lead to vulnerabilities."",
      ""Impact"": ""Integer overflow/underflow could result in incorrect calculations, affecting reward distributions or user balances."",
      ""Location"": ""Functions: `pendingCvx`, `updatePool`, `deposit`, `withdraw`, `getMultiplier`""
    },
    {
      ""Issue"": ""Unbounded Loop in `massUpdatePools` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `massUpdatePools` function iterates over all pools in the `poolInfo` array, which could run out of gas if the number of pools grows too large, preventing updates in a single transaction."",
      ""Impact"": ""Outdated pool information could lead to incorrect reward calculations and distributions."",
      ""Location"": ""Function: `massUpdatePools`""
    },
    {
      ""Issue"": ""Potential Front-Running in `deposit` and `withdraw` Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `deposit` and `withdraw` functions update the user's state after performing external calls, making them susceptible to front-running attacks where an attacker could manipulate the state before the transaction is confirmed."",
      ""Impact"": ""Front-running could lead to unfair reward distributions or state manipulation."",
      ""Location"": ""Functions: `deposit`, `withdraw`""
    },
    {
      ""Issue"": ""Unrestricted `emergencyWithdraw` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `emergencyWithdraw` function allows users to withdraw funds without checks or penalties, which could be exploited to bypass intended protocols."",
      ""Impact"": ""Malicious users could withdraw funds unfairly, undermining protocol integrity."",
      ""Location"": ""Function: `emergencyWithdraw`""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract does not emit events for critical state changes, such as updates to `poolInfo` or `rewarder`, reducing transparency and auditability."",
      ""Impact"": ""Lack of event logging complicates tracking and auditing of contract state changes."",
      ""Location"": ""Functions: `set`, `add`, `updatePool`""
    },
    {
      ""Issue"": ""No Emergency Stop Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks an emergency stop function to pause operations during critical vulnerabilities or attacks, increasing risk exposure."",
      ""Impact"": ""In case of an attack, funds could be at risk until the issue is resolved."",
      ""Location"": ""Contract-wide""
    },
    {
      ""Issue"": ""No Check for Zero Address in Constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor does not validate if the `_cvx` address is zero, which could lead to deployment with an invalid token address."",
      ""Impact"": ""Invalid `cvx` address could render the contract non-functional, risking fund loss."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""No Check for Zero Amount in `deposit` and `withdraw` Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `deposit` and `withdraw` functions do not check for zero amounts, leading to unnecessary gas consumption or state changes."",
      ""Impact"": ""Spamming zero-amount transactions could increase gas costs and network congestion."",
      ""Location"": ""Functions: `deposit`, `withdraw`""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 10
}",420.6062662601471,65024.0,24.0,"### **Comparison and Evaluation**

---

#### **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**

**Report Description**:  
The `add()` function in the ConvexMasterChef contract does not check whether the `_lpToken` is the same as the reward token (cvx). This oversight could lead to incorrect reward calculations if `_lpToken` is set to cvx, as the contract does not account for this scenario.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect reward calculations when `_lpToken` is set to cvx. This is a specific vulnerability that is entirely missed.

---

#### **[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**

**Report Description**:  
The `safeRewardTransfer` function rounds down calculations, which could lead to depositors receiving fewer tokens than expected if the contract is undersupplied with cvx tokens. This is unsafe because the missing tokens are not accounted for, potentially causing loss of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of rounding down in `safeRewardTransfer` or the potential loss of funds due to undersupply of cvx tokens.

---

#### **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**

**Report Description**:  
The `deposit()` and `withdraw()` functions update reward token accounting after transferring rewards. If the reward token allows for transfer flow control (e.g., ERC777 hooks), an attacker could reenter these functions and drain all reward funds from the contract.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy in `deposit` and `withdraw` Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy risk in `deposit` and `withdraw` functions due to external calls before state updates. This aligns with the reported issue.

---

#### **[M-20] massUpdatePools() is susceptible to DoS with block gas limit**

**Report Description**:  
The `massUpdatePools()` function iterates over all pools in the `poolInfo` array, which could exceed the block gas limit if the number of pools is too large, leading to a denial of service (DoS).

**Match in Response List**:  
Matches with the issue titled **""Unbounded Loop in `massUpdatePools` Function""**.

**Validation**:  
**Correct**. The response correctly identifies the unbounded loop issue in `massUpdatePools`, which could lead to DoS due to gas limit constraints.

---

#### **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**

**Report Description**:  
The `add()` and `set()` functions do not call `massUpdatePools()` to update all pools, which could lead to outdated pool information and incorrect reward calculations.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing `massUpdatePools()` calls in `add()` and `set()` functions.

---

#### **[M-22] Duplicate LP token could lead to incorrect reward distribution**

**Report Description**:  
The `add()` function does not check for duplicate `lpToken`, allowing multiple pools with the same `lpToken`. This could lead to incorrect reward distribution.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation in `add` and `set` Functions""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of input validation in `add()` and `set()` functions but does not specifically mention the issue of duplicate `lpToken` leading to incorrect reward distribution.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**
- **[M-20] massUpdatePools() is susceptible to DoS with block gas limit**

**Partially Correct Matches**:

- **[M-22] Duplicate LP token could lead to incorrect reward distribution**

**Missed Issues from Issue Report**:

- **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**
- **[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**
- **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**

---

### **Conclusion**

The response list covers some critical issues, such as reentrancy and unbounded loops, but misses or partially addresses other vulnerabilities, such as incorrect reward calculations, loss of funds due to rounding, and missing `massUpdatePools()` calls. Improvements are needed to ensure comprehensive coverage of all identified issues.","```
1. Potential Reentrancy in `deposit` and `withdraw` Functions
2. Unbounded Loop in `massUpdatePools` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Potential Reentrancy in `deposit` and `withdraw` Functions"" appears at **rank 1**.
   - ""Unbounded Loop in `massUpdatePools` Function"" appears at **rank 4**.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - At rank 4: \( P@4 = \frac{2}{4} = 0.5 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 0.5}{2} = 0.75
   \]

**Output**:
```
0.75
```"
