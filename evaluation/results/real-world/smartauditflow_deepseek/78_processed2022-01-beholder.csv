nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
FlashGovernanceArbiter.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""./Governable.sol"";
import ""hardhat/console.sol"";
import ""../facades/Burnable.sol"";

///@title Flash Governance Arbiter
///@author Justin Goro
/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.
 * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.
 * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.
 * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed
 * By default, the asset is EYE.
 */
contract FlashGovernanceArbiter is Governable {
  /**
   * @param actor user making flash governance decision
   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.
   * @param amount is the amount of the deposit_asset to be put up as decision collateral.
   * @param target is the contract that will be affected by the flash governance decision.
   */
  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);

  mapping(address => bool) enforceLimitsActive;

  constructor(address dao) Governable(dao) {}

  struct FlashGovernanceConfig {
    address asset;
    uint256 amount;
    uint256 unlockTime;
    bool assetBurnable;
  }

  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.
  struct SecurityParameters {
    uint8 maxGovernanceChangePerEpoch; //prevents flash governance from wrecking the incentives.
    uint256 epochSize; //only one flash governance action can happen per epoch to prevent governance DOS
    uint256 lastFlashGovernanceAct;
    uint8 changeTolerance; //1-100 maximum percentage any numeric variable can be changed through flash gov
  }

  //the current parameters determining the rules of flash governance
  FlashGovernanceConfig public flashGovernanceConfig;
  SecurityParameters public security;

  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules
   *without undermining the terms under which pending decisions were made.
   */
  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config

  /**
   *@notice An attempt is made to withdraw the current deposit requirement.
   * For a given user, flash governance decisions can only happen one at a time
   *@param sender is the user making the flash governance decision
   *@param target is the contract that will be affected by the flash governance decision.
   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.
   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.
   */
  function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
    if (
      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&
      pendingFlashDecision[target][sender].unlockTime < block.timestamp
    ) {
      require(
        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),
        ""Limbo: flash governance disabled for rest of epoch""
      );
      pendingFlashDecision[target][sender] = flashGovernanceConfig;
      pendingFlashDecision[target][sender].unlockTime += block.timestamp;

      security.lastFlashGovernanceAct = block.timestamp;
      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);
    } else {
      revert(""LIMBO: governance decision rejected."");
    }
  }

  /**
   *@param asset is the asset type put up as decision collateral. Must be burnable.
   *@param amount is the amount of the deposit_asset to be put up as decision collateral.
   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision
   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.
   */
  function configureFlashGovernance(
    address asset,
    uint256 amount,
    uint256 unlockTime,
    bool assetBurnable
  ) public virtual onlySuccessfulProposal {
    flashGovernanceConfig.asset = asset;
    flashGovernanceConfig.amount = amount;
    flashGovernanceConfig.unlockTime = unlockTime;
    flashGovernanceConfig.assetBurnable = assetBurnable;
  }

  /**
    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS
    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations
    @param changeTolerance is the amount by which a variable can be changed through flash governance.
    */
  function configureSecurityParameters(
    uint8 maxGovernanceChangePerEpoch,
    uint256 epochSize,
    uint8 changeTolerance
  ) public virtual onlySuccessfulProposal {
    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;
    security.epochSize = epochSize;
    require(security.changeTolerance < 100, ""Limbo: % between 0 and 100"");
    security.changeTolerance = changeTolerance;
  }

  /**
    @notice LimboDAO proposals for burning flash governance collateral act through this function
    @param targetContract is the contract that is affected by the flash governance decision.
    @param user is the user who made the flash governance decision
    @param asset is the collateral asset to be burnt
    @param amount is the amount of the collateral to be burnt
    */
  function burnFlashGovernanceAsset(
    address targetContract,
    address user,
    address asset,
    uint256 amount
  ) public virtual onlySuccessfulProposal {
    if (pendingFlashDecision[targetContract][user].assetBurnable) {
      Burnable(asset).burn(amount);
    }

    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
  }

  /**
   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset
   *@param targetContract is the contract that is affected by the flash governance decision.
   *@param asset is the collateral asset to be withdrawn
   */
  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
    require(
      pendingFlashDecision[targetContract][msg.sender].asset == asset &&
        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
      ""Limbo: Flashgovernance decision pending.""
    );
    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
      msg.sender,
      pendingFlashDecision[targetContract][msg.sender].amount
    );
    delete pendingFlashDecision[targetContract][msg.sender];
  }

  /**
   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance
   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.
   * @param enforce for the given context, set whether variable movement limits are enforced or not.
   */
  function setEnforcement(bool enforce) public {
    enforceLimitsActive[msg.sender] = enforce;
  }

  ///@dev for negative values, relative comparisons need to be calculated correctly.
  function enforceToleranceInt(int256 v1, int256 v2) public view {
    if (!configured) return;
    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);
    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);
    enforceTolerance(uv1, uv2);
  }

  ///@notice Allows functions to enforce maximum limits on a per variable basis
  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.
  function enforceTolerance(uint256 v1, uint256 v2) public view {
    if (!configured || !enforceLimitsActive[msg.sender]) return;
    //bonus points for readability
    if (v1 > v2) {
      if (v2 == 0) require(v1 <= 1, ""FE1"");
      else require(((v1 - v2) * 100) < security.changeTolerance * v1, ""FE1"");
    } else {
      if (v1 == 0) require(v2 <= 1, ""FE1"");
      else require(((v2 - v1) * 100) < security.changeTolerance * v1, ""FE1"");
    }
  }
}",1924,186,"[H-01] Lack of access control on assertGovernanceApproved can cause funds to be locked

Submitted by shw, also found by kirk-baird and pauliax
Lack of access control on the `assertGovernanceApproved` function of FlashGovernanceArbiter allows anyone to lock other users' funds in the contract as long as the users have approved the contract to transfer flashGovernanceConfig.amount of flashGovernanceConfig.asset from them.
Proof of Concept

Alice wants to execute a flash governance decision (e.g., disable to the protocol), so she first calls approve on the flashGovernanceConfig.asset to allow FlashGovernanceArbiter to transfer flashGovernanceConfig.amount of assets from her.
An attacker Bob, who listens to the mempool, notices Alice's approve transaction and decides to front-run it. He calls assertGovernanceApproved with sender being Alice, target being any address, and emergency being true.
As a result, Alice cannot execute her flash governance decision, and her funds are locked in the contract for the flashGovernanceConfig.unlockTime period.
Referenced code: DAO/FlashGovernanceArbiter.sol#L60-L81
  [H-04] Logic error in burnFlashGovernanceAsset can cause locked assets to be stolen

Submitted by shw
A logic error in the `burnFlashGovernanceAsset` function that resets a user's pendingFlashDecision allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.
Proof of Concept

An attacker Alice executes a malicious flash governance decision, and her assets are locked in the FlashGovernanceArbiter contract.
The community disagrees with Alice's flash governance decision and calls burnFlashGovernanceAsset to burn her locked assets. However, the burnFlashGovernanceAsset function resets Alice's pendingFlashDecision to the default config (see line 134).
A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.
Now, Alice calls withdrawGovernanceAsset to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's pendingFlashDecision is reset to the default, the unlockTime < block.timestamp condition is fulfilled, and the withdrawal succeeds.
  [H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request

Submitted by kirk-baird
Users who have not called `withdrawGovernanceAsset()` after they have locked their tokens from a previous proposal (i.e. assertGovernanceApproved), will lose their tokens if assertGovernanceApproved() is called again with the same target and sender.
The sender will lose pendingFlashDecision[target][sender].amount tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.
The impact of this is worsened by another vulnerability, that is assertGovernanceApproved() is a public function and may be called by any arbitrary user so long as the sender field has called approve() for FlashGovernanceArbiter on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary sender.

[M-01] Incorrect unlockTime can DOS withdrawGovernanceAsset

Submitted by csanuragjain
unlockTime is set incorrectly.
Proof of Concept

Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol
Observe the assertGovernanceApproved function ```
function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
...
pendingFlashDecision[target][sender].unlockTime += block.timestamp;
...
}
```  [M-02] Reentrancy on Flash Governance Proposal Withdrawal

Submitted by kirk-baird
The function withdrawGovernanceAsset() is vulnerable to reentrancy, which would allow the attacker to drain the balance of the flashGoverananceConfig.asset.
Note: this attack assumes the attacker may gain control of the execution flow in asset.tranfer() which is the case for many ERC20 tokens such as those that implement ERC777 but will depend on which asset is chosen in the configuration.
  [M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance

Submitted by kirk-baird
The proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.
Proof of Concept

The function burnFlashGovernanceAsset() will simply overwrite the user's state with pendingFlashDecision[targetContract][user] = flashGovernanceConfig; as seen below.
function burnFlashGovernanceAsset(
  address targetContract,
  address user,
  address asset,
  uint256 amount
) public virtual onlySuccessfulProposal {
  if (pendingFlashDecision[targetContract][user].assetBurnable) {
    Burnable(asset).burn(amount);
  }

  pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
}
",6,,"pragma solidity 0.8.4;
import ""./Governable.sol"";
import ""hardhat/console.sol"";
import ""../facades/Burnable.sol"";




contract FlashGovernanceArbiter is Governable {
  
  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);

  mapping(address => bool) enforceLimitsActive;

  constructor(address dao) Governable(dao) {}

  struct FlashGovernanceConfig {
    address asset;
    uint256 amount;
    uint256 unlockTime;
    bool assetBurnable;
  }

  
  struct SecurityParameters {
    uint8 maxGovernanceChangePerEpoch; 
    uint256 epochSize; 
    uint256 lastFlashGovernanceAct;
    uint8 changeTolerance; 
  }

  
  FlashGovernanceConfig public flashGovernanceConfig;
  SecurityParameters public security;

  
  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; 

  
  function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
    if (
      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&
      pendingFlashDecision[target][sender].unlockTime < block.timestamp
    ) {
      require(
        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),
        ""Limbo: flash governance disabled for rest of epoch""
      );
      pendingFlashDecision[target][sender] = flashGovernanceConfig;
      pendingFlashDecision[target][sender].unlockTime += block.timestamp;

      security.lastFlashGovernanceAct = block.timestamp;
      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);
    } else {
      revert(""LIMBO: governance decision rejected."");
    }
  }

  
  function configureFlashGovernance(
    address asset,
    uint256 amount,
    uint256 unlockTime,
    bool assetBurnable
  ) public virtual onlySuccessfulProposal {
    flashGovernanceConfig.asset = asset;
    flashGovernanceConfig.amount = amount;
    flashGovernanceConfig.unlockTime = unlockTime;
    flashGovernanceConfig.assetBurnable = assetBurnable;
  }

  
  function configureSecurityParameters(
    uint8 maxGovernanceChangePerEpoch,
    uint256 epochSize,
    uint8 changeTolerance
  ) public virtual onlySuccessfulProposal {
    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;
    security.epochSize = epochSize;
    require(security.changeTolerance < 100, ""Limbo: % between 0 and 100"");
    security.changeTolerance = changeTolerance;
  }

  
  function burnFlashGovernanceAsset(
    address targetContract,
    address user,
    address asset,
    uint256 amount
  ) public virtual onlySuccessfulProposal {
    if (pendingFlashDecision[targetContract][user].assetBurnable) {
      Burnable(asset).burn(amount);
    }

    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
  }

  
  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
    require(
      pendingFlashDecision[targetContract][msg.sender].asset == asset &&
        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
      ""Limbo: Flashgovernance decision pending.""
    );
    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
      msg.sender,
      pendingFlashDecision[targetContract][msg.sender].amount
    );
    delete pendingFlashDecision[targetContract][msg.sender];
  }

  
  function setEnforcement(bool enforce) public {
    enforceLimitsActive[msg.sender] = enforce;
  }

  
  function enforceToleranceInt(int256 v1, int256 v2) public view {
    if (!configured) return;
    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);
    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);
    enforceTolerance(uv1, uv2);
  }

  
  
  function enforceTolerance(uint256 v1, uint256 v2) public view {
    if (!configured || !enforceLimitsActive[msg.sender]) return;
    
    if (v1 > v2) {
      if (v2 == 0) require(v1 <= 1, ""FE1"");
      else require(((v1 - v2) * 100) < security.changeTolerance * v1, ""FE1"");
    } else {
      if (v1 == 0) require(v2 <= 1, ""FE1"");
      else require(((v2 - v1) * 100) < security.changeTolerance * v1, ""FE1"");
    }
  }
}",1017,3,3,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in the `assertGovernanceApproved` function, especially around the `transferFrom` call."",
        ""Verify that all arithmetic operations are safe from overflow/underflow, particularly in the `enforceTolerance` and `enforceToleranceInt` functions."",
        ""Ensure that the `burnFlashGovernanceAsset` function correctly handles the `Burnable` interface calls and does not allow unauthorized burns."",
        ""Review the `withdrawGovernanceAsset` function to ensure it properly checks conditions before transferring assets.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-20 standards in token transfers, especially in `assertGovernanceApproved` and `withdrawGovernanceAsset`."",
        ""Ensure that the `Burnable` interface is correctly implemented and used in `burnFlashGovernanceAsset`.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Analyze the logic in `assertGovernanceApproved` to ensure it correctly handles time locks and emergency conditions."",
        ""Review the `enforceTolerance` and `enforceToleranceInt` functions to ensure they correctly enforce the specified tolerance checks."",
        ""Verify that the `configureFlashGovernance` and `configureSecurityParameters` functions correctly update the respective configurations.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Check all external calls to `IERC20` and `Burnable` to ensure they are safe and do not introduce vulnerabilities."",
        ""Verify that the `Governable` contract's inherited functions are correctly used and do not introduce unexpected behavior.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Review the `onlySuccessfulProposal` modifier to ensure it correctly restricts access to `configureFlashGovernance`, `configureSecurityParameters`, and `burnFlashGovernanceAsset`."",
        ""Ensure that `setEnforcement` correctly manages the `enforceLimitsActive` mapping and does not allow unauthorized changes.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas usage in frequently called functions such as `assertGovernanceApproved` and `enforceTolerance`."",
        ""Check for redundant or unnecessary storage writes in `configureFlashGovernance` and `configureSecurityParameters`.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Verify that the `flashDecision` event is correctly emitted and logs all necessary information."",
        ""Ensure that the `pendingFlashDecision` mapping is correctly managed and does not allow for double-spending or unauthorized changes.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the `flashGovernanceConfig` and `pendingFlashDecision` structures to ensure they do not allow for inflationary or deflationary exploits."",
        ""Verify that the `burnFlashGovernanceAsset` function does not allow for excessive burning that could destabilize the token economy.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities in `assertGovernanceApproved` and `withdrawGovernanceAsset`."",
        ""Consider implementing commit-reveal schemes or other protections if necessary.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Verify that the contract has mechanisms to pause or halt operations in case of an emergency."",
        ""Ensure that critical functions like `assertGovernanceApproved` and `burnFlashGovernanceAsset` can be safely stopped if needed.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided code snippet is a Solidity smart contract named 'FlashGovernanceArbiter' that facilitates governance decisions through a mechanism involving token transfers, time locks, and security parameters. The contract is designed to enforce governance rules, manage pending decisions, and allow for asset burning and withdrawal under specific conditions."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""FlashGovernanceArbiter"",
    ""Purpose"": ""To manage and enforce governance decisions through a mechanism involving token transfers, time locks, and security parameters."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Governable""],
      ""Imports"": [""./Governable.sol"", ""hardhat/console.sol"", ""../facades/Burnable.sol""]
    },
    ""StateVariables"": [
      {
        ""Name"": ""enforceLimitsActive"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks whether enforcement of limits is active for a given address.""
      },
      {
        ""Name"": ""flashGovernanceConfig"",
        ""Type"": ""FlashGovernanceConfig"",
        ""Purpose"": ""Stores the configuration for flash governance, including asset, amount, unlock time, and burnable status.""
      },
      {
        ""Name"": ""security"",
        ""Type"": ""SecurityParameters"",
        ""Purpose"": ""Stores security parameters such as max governance change per epoch, epoch size, last flash governance act, and change tolerance.""
      },
      {
        ""Name"": ""pendingFlashDecision"",
        ""Type"": ""mapping(address => mapping(address => FlashGovernanceConfig))"",
        ""Purpose"": ""Tracks pending flash governance decisions for a given target and user.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""assertGovernanceApproved"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Asserts that a governance decision is approved, involving token transfer and time lock checks."",
        ""Parameters"": [""address sender"", ""address target"", ""bool emergency""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureFlashGovernance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures the flash governance parameters."",
        ""Parameters"": [""address asset"", ""uint256 amount"", ""uint256 unlockTime"", ""bool assetBurnable""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureSecurityParameters"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures the security parameters for the governance mechanism."",
        ""Parameters"": [""uint8 maxGovernanceChangePerEpoch"", ""uint256 epochSize"", ""uint8 changeTolerance""],
        ""Returns"": []
      },
      {
        ""Name"": ""burnFlashGovernanceAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns the governance asset if it is burnable and updates the pending decision."",
        ""Parameters"": [""address targetContract"", ""address user"", ""address asset"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawGovernanceAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows withdrawal of the governance asset after the unlock time has passed."",
        ""Parameters"": [""address targetContract"", ""address asset""],
        ""Returns"": []
      },
      {
        ""Name"": ""setEnforcement"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the enforcement status for the caller."",
        ""Parameters"": [""bool enforce""],
        ""Returns"": []
      },
      {
        ""Name"": ""enforceToleranceInt"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Enforces tolerance checks on integer values."",
        ""Parameters"": [""int256 v1"", ""int256 v2""],
        ""Returns"": []
      },
      {
        ""Name"": ""enforceTolerance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Enforces tolerance checks on unsigned integer values."",
        ""Parameters"": [""uint256 v1"", ""uint256 v2""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20: Used for token transfers."",
    ""Burnable: Used for burning assets if they are burnable.""
  ],
  ""SpecialMechanisms"": [
    ""Time Locks: Used to enforce governance decisions only after a certain unlock time."",
    ""Security Parameters: Configurable parameters to control the frequency and tolerance of governance changes."",
    ""Asset Burning: Mechanism to burn assets if they are marked as burnable.""
  ],
  ""Questions"": [
    ""What is the purpose of the 'configured' variable mentioned in the enforceTolerance functions? It is not defined in the provided code."",
    ""How is the 'onlySuccessfulProposal' modifier implemented? It is used in several functions but not defined in the provided code."",
    ""What is the exact role of the 'Governable' contract inherited by FlashGovernanceArbiter? More details on its functionality would be helpful."",
    ""Are there any specific security considerations or potential vulnerabilities in the token transfer and burning mechanisms?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Uninitialized `configured` Variable"",
      ""Severity"": ""High"",
      ""Description"": ""The `configured` variable is used in `enforceTolerance` and `enforceToleranceInt` functions but is never initialized or set in the contract. This could lead to unexpected behavior or vulnerabilities if the variable is assumed to be in a certain state."",
      ""Impact"": ""Security checks may be bypassed, leading to potential vulnerabilities in the governance mechanism."",
      ""Location"": ""enforceTolerance, enforceToleranceInt functions""
    },
    {
      ""Issue"": ""Potential Reentrancy in `withdrawGovernanceAsset`"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdrawGovernanceAsset` function performs an external call to transfer tokens before updating the state. This could potentially allow a reentrancy attack if the token contract is malicious or compromised, leading to repeated withdrawals or other unexpected behavior."",
      ""Impact"": ""An attacker could exploit this to drain funds or manipulate the contract state."",
      ""Location"": ""withdrawGovernanceAsset function""
    },
    {
      ""Issue"": ""Incorrect Logic in `assertGovernanceApproved`"",
      ""Severity"": ""High"",
      ""Description"": ""The `assertGovernanceApproved` function checks if `pendingFlashDecision[target][sender].unlockTime < block.timestamp` before allowing a governance decision. However, if `pendingFlashDecision[target][sender]` is not initialized, this check will always pass, potentially allowing unauthorized governance decisions."",
      ""Impact"": ""Unauthorized governance decisions could be made, leading to manipulation of the system."",
      ""Location"": ""assertGovernanceApproved function""
    },
    {
      ""Issue"": ""Unrestricted Access to `setEnforcement`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setEnforcement` function allows any user to set the enforcement status for themselves without any access control. This could be abused by malicious users to bypass security checks or disrupt the governance mechanism."",
      ""Impact"": ""Malicious users could disable enforcement checks, weakening the security of the governance system."",
      ""Location"": ""setEnforcement function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `configureSecurityParameters`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `configureSecurityParameters` function does not validate the input values for `maxGovernanceChangePerEpoch`, `epochSize`, and `changeTolerance`. This could lead to setting invalid or insecure parameters, such as a `changeTolerance` value that is too high or too low."",
      ""Impact"": ""Incorrect security parameters could weaken the governance mechanism, making it easier for attackers to manipulate the system."",
      ""Location"": ""configureSecurityParameters function""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `enforceTolerance`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `enforceTolerance` function performs arithmetic operations without checking for potential integer overflow. For example, `(v1 - v2) * 100` could overflow if `v1` and `v2` are large enough."",
      ""Impact"": ""Integer overflow could lead to incorrect tolerance checks, potentially allowing invalid governance decisions."",
      ""Location"": ""enforceTolerance function""
    },
    {
      ""Issue"": ""Insufficient Validation in `assertGovernanceApproved`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `assertGovernanceApproved` function does not validate the `sender` or `target` addresses, which could lead to unintended behavior if invalid or malicious addresses are provided. Additionally, the function does not check if the `flashGovernanceConfig.asset` is a valid ERC20 token."",
      ""Impact"": ""Invalid or malicious addresses could lead to failed transactions or unexpected behavior. Additionally, if the asset is not a valid ERC20 token, the `transferFrom` call could fail or behave unexpectedly."",
      ""Location"": ""assertGovernanceApproved function""
    },
    {
      ""Issue"": ""Lack of Event Emission in Critical Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical functions such as `configureFlashGovernance` and `configureSecurityParameters` do not emit events to log changes. This makes it difficult to track and audit changes to the governance configuration and security parameters."",
      ""Impact"": ""Lack of event emission reduces transparency and makes it harder to audit and track changes, potentially leading to governance or operational issues."",
      ""Location"": ""configureFlashGovernance, configureSecurityParameters functions""
    }
  ],
  ""IssueNumber"": 9,
  ""OutputList"": 8
}",402.62504506111145,46762.0,28.0,"### **[H-01] Lack of access control on `assertGovernanceApproved` can cause funds to be locked**

**Report Description**:  
The `assertGovernanceApproved` function in `FlashGovernanceArbiter` lacks access control, allowing anyone to lock other users' funds in the contract if the users have approved the contract to transfer `flashGovernanceConfig.amount` of `flashGovernanceConfig.asset`. An attacker can front-run a user's transaction and call `assertGovernanceApproved` with the user's address as the `sender`, locking their funds for the `flashGovernanceConfig.unlockTime` period. This prevents the user from executing their flash governance decision and locks their funds.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of access control in `assertGovernanceApproved`. The closest match is the ""Incorrect Logic in `assertGovernanceApproved`"" finding, which focuses on the `unlockTime` check but does not address the lack of access control or the risk of funds being locked. This issue remains unaddressed in the response list.

---

### **[H-04] Logic error in `burnFlashGovernanceAsset` can cause locked assets to be stolen**

**Report Description**:  
The `burnFlashGovernanceAsset` function resets a user's `pendingFlashDecision` to the default configuration, allowing the user to steal other users' assets locked in future flash governance decisions. An attacker can exploit this by withdrawing another user's locked assets after their own `pendingFlashDecision` is reset, effectively stealing the assets.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the logic error in `burnFlashGovernanceAsset`. The closest match is the ""Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance"" finding, which discusses the overwriting of the user's state but does not address the risk of stealing other users' assets. This issue remains unaddressed in the response list.

---

### **[H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request**

**Report Description**:  
Users who do not call `withdrawGovernanceAsset()` after locking their tokens from a previous proposal will lose their tokens if `assertGovernanceApproved()` is called again with the same `target` and `sender`. The new amount overwrites the previous amount, causing the tokens to become unaccounted for and locked in the contract. This issue is exacerbated by the fact that `assertGovernanceApproved()` is a public function and can be called by any user.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of token loss due to overwriting in `assertGovernanceApproved`. The closest match is the ""Incorrect Logic in `assertGovernanceApproved`"" finding, which focuses on the `unlockTime` check but does not address the overwriting of token amounts. This issue remains unaddressed in the response list.

---

### **[M-01] Incorrect `unlockTime` can DOS `withdrawGovernanceAsset`**

**Report Description**:  
The `unlockTime` is set incorrectly in `assertGovernanceApproved`, as it adds `block.timestamp` to the existing `unlockTime` instead of setting it to a future timestamp. This could lead to a denial of service (DOS) in `withdrawGovernanceAsset` if the `unlockTime` is set to a value that is never reached.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect `unlockTime` calculation in `assertGovernanceApproved`. The closest match is the ""Incorrect Logic in `assertGovernanceApproved`"" finding, which focuses on the `unlockTime` check but does not address the incorrect addition of `block.timestamp`. This issue remains unaddressed in the response list.

---

### **[M-02] Reentrancy on Flash Governance Proposal Withdrawal**

**Report Description**:  
The `withdrawGovernanceAsset` function is vulnerable to reentrancy, as it performs an external call to transfer tokens before updating the state. An attacker could exploit this to drain the balance of the `flashGovernanceConfig.asset` if the token contract is malicious or compromised.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy in `withdrawGovernanceAsset`""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in `withdrawGovernanceAsset`. It correctly explains the risks associated with performing an external call before updating the state, which aligns with Solidity best practices for secure contract interactions.

---

### **[M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance**

**Report Description**:  
The `burnFlashGovernanceAsset` function overwrites the user's state with `flashGovernanceConfig` instead of deducting their balance. This means that burning a user's tokens for a flash governance proposal does not result in the user losing any funds and may even unlock their funds sooner.

**Match in Response List**:  
Matches with the issue titled **""Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `burnFlashGovernanceAsset` function. It correctly explains that the user's state is overwritten instead of their balance being deducted, which aligns with the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] Reentrancy on Flash Governance Proposal Withdrawal**
- **[M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] Lack of access control on `assertGovernanceApproved` can cause funds to be locked**
- **[H-04] Logic error in `burnFlashGovernanceAsset` can cause locked assets to be stolen**
- **[H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request**
- **[M-01] Incorrect `unlockTime` can DOS `withdrawGovernanceAsset`**

--- 

The response list addresses some issues correctly but misses several critical vulnerabilities, particularly those related to access control, logic errors, and incorrect state handling. These gaps highlight the need for a more comprehensive review of the contract's security mechanisms.","```
1. Potential Reentrancy in `withdrawGovernanceAsset`
2. Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - The true positives are:
     - ""Potential Reentrancy in `withdrawGovernanceAsset`""
     - ""Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance""

   - From the ranked list of predictions:
     - ""Potential Reentrancy in `withdrawGovernanceAsset`"" appears at rank 2.
     - ""Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance"" does not appear in the ranked list.

2. **Calculate the precision at the rank where the true positive appears**:
   - For ""Potential Reentrancy in `withdrawGovernanceAsset`"" at rank 2:
     - Precision at rank 2 (\( P@2 \)) = \( \frac{1}{2} = 0.5 \)

   - Since the second true positive does not appear in the ranked list, its precision is 0.

3. **Compute the Average Precision (AP)**:
   - AP = \( \frac{0.5 + 0}{2} = 0.25 \)

**Output**:
- **Average Precision (AP)**: 0.25"
LimboDAO.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../ERC677/ERC677.sol"";
import ""../Flan.sol"";
import ""./ProposalFactory.sol"";
import ""../facades/SwapFactoryLike.sol"";
import ""../facades/UniPairLike.sol"";
import ""./Governable.sol"";

// import ""hardhat/console.sol"";

library TransferHelper {
  function ERC20NetTransfer(
    address token,
    address from,
    address to,
    int256 amount
  ) public {
    if (amount > 0) {
      require(IERC20(token).transferFrom(from, to, uint256(amount)), ""LimboDAO: ERC20 transfer from failed."");
    } else {
      require(IERC20(token).transfer(from, uint256(amount * (-1))), ""LimboDAO: ERC20 transfer failed."");
    }
  }
}

enum FateGrowthStrategy {
  straight,
  directRoot,
  indirectTwoRootEye
}

enum ProposalDecision {
  voting,
  approved,
  rejected
}

///@title Limbo DAO
///@author Justin Goro
/**@notice
 *This is the first MicroDAO associated with MorgothDAO. A MicroDAO manages parameterization of running dapps without having
 *control over existential functionality. This is not to say that some of the decisions taken are not critical but that the domain
 *of influence is confined to the local Dapp - Limbo in this case.
 * LimboDAO has two forms of decision making: proposals and flash governance. For proposals, voting power is required. Voting power in LimboDAO is measured
 * by a points system called Fate. Staking EYE or an EYE based LP earns Fate at a quadratic rate. Fate can be used to list a proposal for voting or to vote.
 * Using Fate to make a governance decisions spens it out of existince. So Fate reflects the opportunity cost of staking.
 * Flash governance is for instant decision making that cannot wait for voting to occur. Best used for small tweaks to parameters or emergencies.
 * Flash governance requires a governance asset (EYE) be staked at the time of the execution. The asset cannot be withdrawn for a certain period of time,
 * allowing for Fate holders to vote on the legitimacy of the decision. If the decision is considered malicious, the staked EYE is burnt.
 */
///@dev Contracts subject to LimboDAO must inherit the Governable abstract contract.
contract LimboDAO is Ownable {
  event daoKilled(address newOwner);
  event proposalLodged(address proposal, address proposer);
  event voteCast(address voter, address proposal, int256 fateCast);
  event assetApproval(address asset, bool appoved);
  event proposalExecuted(address proposal, bool approved);
  event assetBurnt(address burner, address asset, uint256 fateCreated);

  using TransferHelper for address;
  uint256 constant ONE = 1 ether;
  uint256 precision = 1e9;

  struct DomainConfig {
    address limbo;
    address flan;
    address eye;
    address fate;
    bool live;
    address flashGoverner;
    address sushiFactory;
    address uniFactory;
  }

  struct ProposalConfig {
    uint256 votingDuration;
    uint256 requiredFateStake;
    address proposalFactory; //check this for creating proposals
  }

  struct ProposalState {
    int256 fate;
    ProposalDecision decision;
    address proposer;
    uint256 start;
    Proposal proposal;
  }

  //rateCrate
  struct FateState {
    uint256 fatePerDay;
    uint256 fateBalance;
    uint256 lastDamnAdjustment;
  }

  struct AssetClout {
    uint256 fateWeight;
    uint256 balance;
  }

  DomainConfig public domainConfig;
  ProposalConfig public proposalConfig;

  /**@notice for staking EYE, we simply take the square root of staked amount.
   * For LP tokens, only half the value of the token is EYE so it's tempting to take the square root for the EYE balance. However this punishes the holder by ignoring the cost incurred by supplying the other asset. Since the other asset at rest is equal in value to the EYE balance, we just multiply the calculation by 2.
   */
  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;
  mapping(address => bool) public assetApproved;
  mapping(address => FateState) public fateState; //lateDate

  //Fate is earned per day. Keeping track of relative staked values, we can increment user balance
  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; //user->asset->weight

  ProposalState public currentProposalState;
  ProposalState public previousProposalState;

  // Since staking EYE precludes it from earning Flan on Limbo, fateToFlan can optionally be set to a non zero number to allow fat holders to spend their fate for Flan.
  uint256 public fateToFlan;

  modifier isLive() {
    require(domainConfig.live, ""LimboDAO: DAO is not live."");
    _;
  }

  function nextProposal() internal {
    previousProposalState = currentProposalState;
    currentProposalState.proposal = Proposal(address(0));
    currentProposalState.fate = 0;
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.proposer = address(0);
    currentProposalState.start = 0;
  }

  modifier onlySuccessfulProposal() {
    // console.log('onlySuccessfulProposal');
    require(successfulProposal(msg.sender), ""LimboDAO: approve proposal"");
    _;
    //nextProposal();
  }

  ///@notice has a proposal successfully been approved?
  function successfulProposal(address proposal) public view returns (bool) {
    return
      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);
  }

  modifier updateCurrentProposal() {
    incrementFateFor(_msgSender());
    if (address(currentProposalState.proposal) != address(0)) {
      uint256 durationSinceStart = block.timestamp - currentProposalState.start;
      if (
        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting
      ) {
        if (currentProposalState.fate > 0) {
          currentProposalState.decision = ProposalDecision.approved;
          currentProposalState.proposal.orchestrateExecute();
          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;
        } else {
          currentProposalState.decision = ProposalDecision.rejected;
        }
        emit proposalExecuted(
          address(currentProposalState.proposal),
          currentProposalState.decision == ProposalDecision.approved
        );
        nextProposal();
      }
    }
    _;
  }

  modifier incrementFate() {
    incrementFateFor(_msgSender());
    _;
  }

  function incrementFateFor(address user) public {
    FateState storage state = fateState[user];
    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);
    state.lastDamnAdjustment = block.timestamp;
  }

  ///@param limbo address of Limbo
  ///@param flan address of Flan
  ///@param eye address of EYE token
  ///@param proposalFactory authenticates and instantiates valid proposals for voting
  ///@param sushiFactory is the SushiSwap Factory contract
  ///@param uniFactory is the UniSwapV2 Factory contract
  ///@param flashGoverner oversees flash governance cryptoeconomics
  ///@param precisionOrderOfMagnitude when comparing fractional values, it's not necessary to get every last digit right
  ///@param sushiLPs valid EYE containing LP tokens elligible for earning Fate through staking
  ///@param uniLPs valid EYE containing LP tokens elligible for earning Fate through staking
  function seed(
    address limbo,
    address flan,
    address eye,
    address proposalFactory,
    address sushiFactory,
    address uniFactory,
    address flashGoverner,
    uint256 precisionOrderOfMagnitude,
    address[] memory sushiLPs,
    address[] memory uniLPs
  ) public onlyOwner {
    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);
    proposalConfig.votingDuration = 2 days;
    proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours
    proposalConfig.proposalFactory = proposalFactory;
    precision = 10**precisionOrderOfMagnitude;
    for (uint256 i = 0; i < sushiLPs.length; i++) {
      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;
      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
    for (uint256 i = 0; i < uniLPs.length; i++) {
      require(UniPairLike(uniLPs[i]).factory() == uniFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;
      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
  }

  ///@notice allows Limbo to be governed by a new DAO
  ///@dev functions marked by onlyOwner are governed by MorgothDAO
  function killDAO(address newOwner) public onlyOwner isLive {
    domainConfig.live = false;
    Governable(domainConfig.flan).setDAO(newOwner);
    Governable(domainConfig.limbo).setDAO(newOwner);
    emit daoKilled(newOwner);
  }

  ///@notice optional conversion rate of Fate to Flan
  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {
    fateToFlan = rate;
  }

  ///@notice caller spends their Fate to earn Flan
  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {
    require(fateToFlan > 0, ""LimboDAO: Fate conversion to Flan disabled."");
    fateState[msg.sender].fateBalance -= fate;
    flan = (fateToFlan * fate) / ONE;
    Flan(domainConfig.flan).mint(msg.sender, flan);
  }

  /**@notice handles proposal lodging logic. A deposit of Fate is removed from the user. If the decision is a success, half the fate is returned.
   *  This is to encourage only lodging of proposals that are likely to succeed.
   *  @dev not for external calling. Use the proposalFactory to lodge a proposal instead.
   */
  function makeProposal(address proposal, address proposer) public updateCurrentProposal {
    address sender = _msgSender();
    require(sender == proposalConfig.proposalFactory, ""LimboDAO: only Proposal Factory"");
    require(address(currentProposalState.proposal) == address(0), ""LimboDAO: active proposal."");

    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;
    currentProposalState.proposal = Proposal(proposal);
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.fate = 0;
    currentProposalState.proposer = proposer;
    currentProposalState.start = block.timestamp;
    emit proposalLodged(proposal, proposer);
  }

  ///@notice handles proposal voting logic.
  ///@param proposal contract to be voted on
  ///@param fate positive is YES, negative is NO. Absolute value is deducted from caller.
  function vote(address proposal, int256 fate) public incrementFate isLive {
    require(
      proposal == address(currentProposalState.proposal), //this is just to protect users with out of sync UIs
      ""LimboDAO: stated proposal does not match current proposal""
    );
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: voting on proposal closed"");
    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {
      int256 currentFate = currentProposalState.fate;
      //check if voting has ended
      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {
        revert(""LimboDAO: voting for current proposal has ended."");
      } else if (
        //The following if statement checks if the vote is flipped by fate
        fate * currentFate < 0 && //sign different
        (fate + currentFate) * fate > 0 //fate flipped current fate onto the same side of zero as fate
      ) {
        //extend voting duration when vote flips decision. Suggestion made by community member
        currentProposalState.start = currentProposalState.start + 2 hours;
      }
    }
    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);
    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;

    currentProposalState.fate += fate;
    emit voteCast(_msgSender(), proposal, fate);
  }

  ///@notice pushes the decision to execute a successful proposal. For convenience only
  function executeCurrentProposal() public updateCurrentProposal {}

  ///@notice parameterizes the voting
  ///@param requiredFateStake the amount of Fate required to lodge a proposal
  ///@param votingDuration the duration of voting in seconds
  ///@param proposalFactory the address of the proposal factory
  function setProposalConfig(
    uint256 votingDuration,
    uint256 requiredFateStake,
    address proposalFactory
  ) public onlySuccessfulProposal {
    proposalConfig.votingDuration = votingDuration;
    proposalConfig.requiredFateStake = requiredFateStake;
    proposalConfig.proposalFactory = proposalFactory;
  }

  ///@notice Assets approved for earning Fate
  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {
    assetApproved[asset] = approved;
    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;
    emit assetApproval(asset, approved);
  }

  ///@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.
  ///@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question
  ///@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half
  ///@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm
  ///@param asset the asset being staked
  function setEYEBasedAssetStake(
    uint256 finalAssetBalance,
    uint256 finalEYEBalance,
    uint256 rootEYE,
    address asset
  ) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    FateGrowthStrategy strategy = fateGrowthStrategy[asset];

    //verifying that rootEYE value is accurate within precision.
    uint256 rootEYESquared = rootEYE * rootEYE;
    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);
    require(
      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,
      ""LimboDAO: Stake EYE invariant.""
    );
    AssetClout storage clout = stakedUserAssetWeight[sender][asset];
    fateState[sender].fatePerDay -= clout.fateWeight;
    uint256 initialBalance = clout.balance;
    //EYE
    if (strategy == FateGrowthStrategy.directRoot) {
      require(finalAssetBalance == finalEYEBalance, ""LimboDAO: staking eye invariant."");
      require(asset == domainConfig.eye);

      clout.fateWeight = rootEYE;
      clout.balance = finalAssetBalance;
      fateState[sender].fatePerDay += rootEYE;
    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {
      //LP
      clout.fateWeight = 2 * rootEYE;
      fateState[sender].fatePerDay += clout.fateWeight;

      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);
      finalEYEBalance /= precision;
      require(
        finalEYEBalance == impliedEye, //precision cap
        ""LimboDAO: stake invariant check 2.""
      );
      clout.balance = finalAssetBalance;
    } else {
      revert(""LimboDAO: asset growth strategy not accounted for"");
    }
    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);
    asset.ERC20NetTransfer(sender, address(this), netBalance);
  }

  /**
   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.
   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset
   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.
   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent
   * loss of EYE.
   *@param asset the asset to burn and can be EYE or EYE based assets
   *@param amount the amount of asset to burn
   */
  function burnAsset(address asset, uint256 amount) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    require(ERC677(asset).transferFrom(sender, address(this), amount), ""LimboDAO: transferFailed"");
    uint256 fateCreated = fateState[_msgSender()].fateBalance;
    if (asset == domainConfig.eye) {
      fateCreated = amount * 10;
      ERC677(domainConfig.eye).burn(amount);
    } else {
      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * amount) / ONE;
      fateCreated = impliedEye * 20;
    }
    fateState[_msgSender()].fateBalance += fateCreated;
    emit assetBurnt(_msgSender(), asset, fateCreated);
  }

  ///@notice grants unlimited Flan minting power to an address.
  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {
    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);
  }

  ///@notice call this after initial config is complete.
  function makeLive() public onlyOwner {
    require(
      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),
      ""LimboDAO: transfer ownership of limbo and flan.""
    );
    domainConfig.live = true;
  }

  ///@notice if the DAO is being dismantled, it's necessary to transfer any owned items
  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {
    Ownable(thing).transferOwnership(destination);
  }

  function timeRemainingOnProposal() public view returns (uint256) {
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: proposal finished."");
    uint256 elapsed = block.timestamp - currentProposalState.start;
    if (elapsed > proposalConfig.votingDuration) return 0;
    return proposalConfig.votingDuration - elapsed;
  }

  /**@notice seed is a goro idiom for initialize that you tend to find in all the dapps I've written.
   * I prefer initialization funcitons to parameterized solidity constructors for reasons beyond the scope of this comment.
   */
  function _seed(
    address limbo,
    address flan,
    address eye,
    address sushiFactory,
    address uniFactory,
    address flashGoverner
  ) internal {
    domainConfig.limbo = limbo;
    domainConfig.flan = flan;
    domainConfig.eye = eye;
    domainConfig.uniFactory = uniFactory;
    domainConfig.sushiFactory = sushiFactory;
    domainConfig.flashGoverner = flashGoverner;
    assetApproved[eye] = true;
    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;
  }

  function getFlashGoverner() external view returns (address) {
    return domainConfig.flashGoverner;
  }
}",4664,453,"[H-07] LP pricing formula is vulnerable to flashloan manipulation
 `burnAsset` function of `LimboDAO` 
Submitted by shw
The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more fate than he is supposed to with a relatively low cost.
With the large portion of fate he gets, he has more voting power to influence the system's decisions, or even he can convert his fate to Flan tokens for a direct profit.
  [M-04] The system can get to a ""stuck"" state if a bad proposal (proposal that can't be executed) is accepted

LimboDAO.sol (`updateCurrentProposal() `modifier and makeProposal() function)

The LimboDAO contract has a variable that indicates the current proposal - every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an UpdateMultipleSoulConfigProposal proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass - the users won't be able to vote anymore (because the vote function will revert), and the proposal can't be executed - the execute function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.
When trying to call the executeCurrentProposal() function that activates the updateCurrentProposal() modifier, the modifier will check the balance of fate, it will see that it's positive and will call currentProposalState.proposal.orchestrateExecute() to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with voting state).
When trying to call makeProposal() function to make a new proposal it will revert because the current proposal is not equal to address(0).
",2,,"pragma solidity 0.8.4;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../ERC677/ERC677.sol"";
import ""../Flan.sol"";
import ""./ProposalFactory.sol"";
import ""../facades/SwapFactoryLike.sol"";
import ""../facades/UniPairLike.sol"";
import ""./Governable.sol"";



library TransferHelper {
  function ERC20NetTransfer(
    address token,
    address from,
    address to,
    int256 amount
  ) public {
    if (amount > 0) {
      require(IERC20(token).transferFrom(from, to, uint256(amount)), ""LimboDAO: ERC20 transfer from failed."");
    } else {
      require(IERC20(token).transfer(from, uint256(amount * (-1))), ""LimboDAO: ERC20 transfer failed."");
    }
  }
}

enum FateGrowthStrategy {
  straight,
  directRoot,
  indirectTwoRootEye
}

enum ProposalDecision {
  voting,
  approved,
  rejected
}





contract LimboDAO is Ownable {
  event daoKilled(address newOwner);
  event proposalLodged(address proposal, address proposer);
  event voteCast(address voter, address proposal, int256 fateCast);
  event assetApproval(address asset, bool appoved);
  event proposalExecuted(address proposal, bool approved);
  event assetBurnt(address burner, address asset, uint256 fateCreated);

  using TransferHelper for address;
  uint256 constant ONE = 1 ether;
  uint256 precision = 1e9;

  struct DomainConfig {
    address limbo;
    address flan;
    address eye;
    address fate;
    bool live;
    address flashGoverner;
    address sushiFactory;
    address uniFactory;
  }

  struct ProposalConfig {
    uint256 votingDuration;
    uint256 requiredFateStake;
    address proposalFactory; 
  }

  struct ProposalState {
    int256 fate;
    ProposalDecision decision;
    address proposer;
    uint256 start;
    Proposal proposal;
  }

  
  struct FateState {
    uint256 fatePerDay;
    uint256 fateBalance;
    uint256 lastDamnAdjustment;
  }

  struct AssetClout {
    uint256 fateWeight;
    uint256 balance;
  }

  DomainConfig public domainConfig;
  ProposalConfig public proposalConfig;

  
  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;
  mapping(address => bool) public assetApproved;
  mapping(address => FateState) public fateState; 

  
  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; 

  ProposalState public currentProposalState;
  ProposalState public previousProposalState;

  
  uint256 public fateToFlan;

  modifier isLive() {
    require(domainConfig.live, ""LimboDAO: DAO is not live."");
    _;
  }

  function nextProposal() internal {
    previousProposalState = currentProposalState;
    currentProposalState.proposal = Proposal(address(0));
    currentProposalState.fate = 0;
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.proposer = address(0);
    currentProposalState.start = 0;
  }

  modifier onlySuccessfulProposal() {
    
    require(successfulProposal(msg.sender), ""LimboDAO: approve proposal"");
    _;
    
  }

  
  function successfulProposal(address proposal) public view returns (bool) {
    return
      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);
  }

  modifier updateCurrentProposal() {
    incrementFateFor(_msgSender());
    if (address(currentProposalState.proposal) != address(0)) {
      uint256 durationSinceStart = block.timestamp - currentProposalState.start;
      if (
        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting
      ) {
        if (currentProposalState.fate > 0) {
          currentProposalState.decision = ProposalDecision.approved;
          currentProposalState.proposal.orchestrateExecute();
          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;
        } else {
          currentProposalState.decision = ProposalDecision.rejected;
        }
        emit proposalExecuted(
          address(currentProposalState.proposal),
          currentProposalState.decision == ProposalDecision.approved
        );
        nextProposal();
      }
    }
    _;
  }

  modifier incrementFate() {
    incrementFateFor(_msgSender());
    _;
  }

  function incrementFateFor(address user) public {
    FateState storage state = fateState[user];
    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);
    state.lastDamnAdjustment = block.timestamp;
  }

  
  
  
  
  
  
  
  
  
  
  function seed(
    address limbo,
    address flan,
    address eye,
    address proposalFactory,
    address sushiFactory,
    address uniFactory,
    address flashGoverner,
    uint256 precisionOrderOfMagnitude,
    address[] memory sushiLPs,
    address[] memory uniLPs
  ) public onlyOwner {
    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);
    proposalConfig.votingDuration = 2 days;
    proposalConfig.requiredFateStake = 223 * ONE; 
    proposalConfig.proposalFactory = proposalFactory;
    precision = 10**precisionOrderOfMagnitude;
    for (uint256 i = 0; i < sushiLPs.length; i++) {
      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;
      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
    for (uint256 i = 0; i < uniLPs.length; i++) {
      require(UniPairLike(uniLPs[i]).factory() == uniFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;
      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
  }

  
  
  function killDAO(address newOwner) public onlyOwner isLive {
    domainConfig.live = false;
    Governable(domainConfig.flan).setDAO(newOwner);
    Governable(domainConfig.limbo).setDAO(newOwner);
    emit daoKilled(newOwner);
  }

  
  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {
    fateToFlan = rate;
  }

  
  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {
    require(fateToFlan > 0, ""LimboDAO: Fate conversion to Flan disabled."");
    fateState[msg.sender].fateBalance -= fate;
    flan = (fateToFlan * fate) / ONE;
    Flan(domainConfig.flan).mint(msg.sender, flan);
  }

  
  function makeProposal(address proposal, address proposer) public updateCurrentProposal {
    address sender = _msgSender();
    require(sender == proposalConfig.proposalFactory, ""LimboDAO: only Proposal Factory"");
    require(address(currentProposalState.proposal) == address(0), ""LimboDAO: active proposal."");

    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;
    currentProposalState.proposal = Proposal(proposal);
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.fate = 0;
    currentProposalState.proposer = proposer;
    currentProposalState.start = block.timestamp;
    emit proposalLodged(proposal, proposer);
  }

  
  
  
  function vote(address proposal, int256 fate) public incrementFate isLive {
    require(
      proposal == address(currentProposalState.proposal), 
      ""LimboDAO: stated proposal does not match current proposal""
    );
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: voting on proposal closed"");
    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {
      int256 currentFate = currentProposalState.fate;
      
      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {
        revert(""LimboDAO: voting for current proposal has ended."");
      } else if (
        
        fate * currentFate < 0 && 
        (fate + currentFate) * fate > 0 
      ) {
        
        currentProposalState.start = currentProposalState.start + 2 hours;
      }
    }
    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);
    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;

    currentProposalState.fate += fate;
    emit voteCast(_msgSender(), proposal, fate);
  }

  
  function executeCurrentProposal() public updateCurrentProposal {}

  
  
  
  
  function setProposalConfig(
    uint256 votingDuration,
    uint256 requiredFateStake,
    address proposalFactory
  ) public onlySuccessfulProposal {
    proposalConfig.votingDuration = votingDuration;
    proposalConfig.requiredFateStake = requiredFateStake;
    proposalConfig.proposalFactory = proposalFactory;
  }

  
  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {
    assetApproved[asset] = approved;
    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;
    emit assetApproval(asset, approved);
  }

  
  
  
  
  
  function setEYEBasedAssetStake(
    uint256 finalAssetBalance,
    uint256 finalEYEBalance,
    uint256 rootEYE,
    address asset
  ) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    FateGrowthStrategy strategy = fateGrowthStrategy[asset];

    
    uint256 rootEYESquared = rootEYE * rootEYE;
    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);
    require(
      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,
      ""LimboDAO: Stake EYE invariant.""
    );
    AssetClout storage clout = stakedUserAssetWeight[sender][asset];
    fateState[sender].fatePerDay -= clout.fateWeight;
    uint256 initialBalance = clout.balance;
    
    if (strategy == FateGrowthStrategy.directRoot) {
      require(finalAssetBalance == finalEYEBalance, ""LimboDAO: staking eye invariant."");
      require(asset == domainConfig.eye);

      clout.fateWeight = rootEYE;
      clout.balance = finalAssetBalance;
      fateState[sender].fatePerDay += rootEYE;
    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {
      
      clout.fateWeight = 2 * rootEYE;
      fateState[sender].fatePerDay += clout.fateWeight;

      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);
      finalEYEBalance /= precision;
      require(
        finalEYEBalance == impliedEye, 
        ""LimboDAO: stake invariant check 2.""
      );
      clout.balance = finalAssetBalance;
    } else {
      revert(""LimboDAO: asset growth strategy not accounted for"");
    }
    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);
    asset.ERC20NetTransfer(sender, address(this), netBalance);
  }

  
  function burnAsset(address asset, uint256 amount) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    require(ERC677(asset).transferFrom(sender, address(this), amount), ""LimboDAO: transferFailed"");
    uint256 fateCreated = fateState[_msgSender()].fateBalance;
    if (asset == domainConfig.eye) {
      fateCreated = amount * 10;
      ERC677(domainConfig.eye).burn(amount);
    } else {
      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * amount) / ONE;
      fateCreated = impliedEye * 20;
    }
    fateState[_msgSender()].fateBalance += fateCreated;
    emit assetBurnt(_msgSender(), asset, fateCreated);
  }

  
  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {
    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);
  }

  
  function makeLive() public onlyOwner {
    require(
      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),
      ""LimboDAO: transfer ownership of limbo and flan.""
    );
    domainConfig.live = true;
  }

  
  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {
    Ownable(thing).transferOwnership(destination);
  }

  function timeRemainingOnProposal() public view returns (uint256) {
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: proposal finished."");
    uint256 elapsed = block.timestamp - currentProposalState.start;
    if (elapsed > proposalConfig.votingDuration) return 0;
    return proposalConfig.votingDuration - elapsed;
  }

  
  function _seed(
    address limbo,
    address flan,
    address eye,
    address sushiFactory,
    address uniFactory,
    address flashGoverner
  ) internal {
    domainConfig.limbo = limbo;
    domainConfig.flan = flan;
    domainConfig.eye = eye;
    domainConfig.uniFactory = uniFactory;
    domainConfig.sushiFactory = sushiFactory;
    domainConfig.flashGoverner = flashGoverner;
    assetApproved[eye] = true;
    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;
  }

  function getFlashGoverner() external view returns (address) {
    return domainConfig.flashGoverner;
  }
}",3290,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy risks in functions that interact with external contracts, especially `ERC20NetTransfer` and `burnAsset`."",
        ""Verify that all arithmetic operations are protected against overflow/underflow, particularly in `incrementFateFor` and `convertFateToFlan`."",
        ""Ensure that external calls (e.g., `transferFrom`, `transfer`) are properly checked for success and handle revert cases."",
        ""Audit the `vote` function for potential manipulation of voting deadlines and fate calculations.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Confirm that the contract adheres to ERC-20 and ERC-677 standards, especially in token transfer functions."",
        ""Verify that the `Ownable` pattern is correctly implemented and that ownership transfer is secure.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the `setEYEBasedAssetStake` function for correctness in calculating `fateWeight` and `impliedEye`."",
        ""Analyze the `incrementFateFor` function to ensure accurate fate balance updates over time."",
        ""Examine the `vote` function's logic for extending voting deadlines based on fate votes.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify the correct usage of `SwapFactoryLike` and `UniPairLike` interfaces in the `seed` function."",
        ""Ensure that interactions with external tokens (e.g., `Flan`, `ERC677`) are secure and properly validated."",
        ""Check that the `ProposalFactory` contract is correctly used in `makeProposal` and `setProposalConfig`.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that `onlyOwner` and `onlySuccessfulProposal` modifiers are correctly applied to sensitive functions."",
        ""Ensure that the `isLive` modifier is consistently used to prevent actions when the DAO is not live."",
        ""Check that the `transferOwnershipOfThing` function securely transfers ownership of external contracts.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Optimize state variable updates in `incrementFateFor` and `setEYEBasedAssetStake` to reduce gas costs."",
        ""Minimize storage reads/writes in functions like `vote` and `makeProposal`."",
        ""Evaluate the use of `precision` and `ONE` constants to avoid unnecessary calculations.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Audit the `seed` function for proper validation of LP tokens and their factory addresses."",
        ""Ensure that the `assetApproved` mapping is correctly updated for LP tokens in the `seed` function.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Check for vulnerabilities in the `vote` function that could be exploited via flash loans."",
        ""Ensure that the `setEYEBasedAssetStake` function is resistant to manipulation via flash loans.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Verify that the `makeProposal` function correctly enforces the `requiredFateStake`."",
        ""Ensure that the `vote` function properly handles negative fate votes and deadline extensions."",
        ""Audit the `executeCurrentProposal` function to ensure proposals are executed only when valid.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Ensure that the `setEYEBasedAssetStake` function correctly calculates and updates `fateWeight` and `fatePerDay`."",
        ""Verify that the `burnAsset` function correctly mints fate tokens based on the burned asset.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities in the `vote` and `makeProposal` functions."",
        ""Evaluate the use of `block.timestamp` in the `vote` function for potential manipulation.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Ensure that the `killDAO` function correctly disables the DAO and transfers ownership."",
        ""Verify that the `makeLive` function is secure and only callable by the owner.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code represents a DAO (Decentralized Autonomous Organization) named LimboDAO, which manages proposals, voting, and asset management. It includes mechanisms for proposal creation, voting, execution, and asset staking. The contract interacts with external tokens and factories, and it uses a custom library for ERC20 token transfers."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LimboDAO"",
    ""Purpose"": ""To manage a DAO with functionalities for proposal creation, voting, execution, and asset staking."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""../ERC677/ERC677.sol"",
        ""../Flan.sol"",
        ""./ProposalFactory.sol"",
        ""../facades/SwapFactoryLike.sol"",
        ""../facades/UniPairLike.sol"",
        ""./Governable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""domainConfig"",
        ""Type"": ""DomainConfig"",
        ""Purpose"": ""Stores configuration related to the DAO's domain, including addresses of key contracts and status.""
      },
      {
        ""Name"": ""proposalConfig"",
        ""Type"": ""ProposalConfig"",
        ""Purpose"": ""Stores configuration related to proposals, including voting duration and required stakes.""
      },
      {
        ""Name"": ""fateGrowthStrategy"",
        ""Type"": ""mapping(address => FateGrowthStrategy)"",
        ""Purpose"": ""Maps assets to their respective fate growth strategies.""
      },
      {
        ""Name"": ""assetApproved"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Maps assets to their approval status within the DAO.""
      },
      {
        ""Name"": ""fateState"",
        ""Type"": ""mapping(address => FateState)"",
        ""Purpose"": ""Stores the fate state of users, including balance and growth rate.""
      },
      {
        ""Name"": ""stakedUserAssetWeight"",
        ""Type"": ""mapping(address => mapping(address => AssetClout))"",
        ""Purpose"": ""Maps users and assets to their respective staked weights and balances.""
      },
      {
        ""Name"": ""currentProposalState"",
        ""Type"": ""ProposalState"",
        ""Purpose"": ""Stores the state of the current proposal, including fate, decision, and proposer.""
      },
      {
        ""Name"": ""previousProposalState"",
        ""Type"": ""ProposalState"",
        ""Purpose"": ""Stores the state of the previous proposal.""
      },
      {
        ""Name"": ""fateToFlan"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Stores the conversion rate from fate to flan tokens.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""isLive"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the DAO is live before executing certain functions.""
      },
      {
        ""Name"": ""nextProposal"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Resets the state for the next proposal.""
      },
      {
        ""Name"": ""onlySuccessfulProposal"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the function is called by a successful proposal.""
      },
      {
        ""Name"": ""successfulProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if a proposal is successful."",
        ""Parameters"": [""address proposal""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""updateCurrentProposal"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates the current proposal state and increments fate for the caller.""
      },
      {
        ""Name"": ""incrementFate"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Increments fate for the caller.""
      },
      {
        ""Name"": ""incrementFateFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Increments fate for a specified user."",
        ""Parameters"": [""address user""]
      },
      {
        ""Name"": ""seed"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the DAO with key addresses and configurations."",
        ""Parameters"": [
          ""address limbo"",
          ""address flan"",
          ""address eye"",
          ""address proposalFactory"",
          ""address sushiFactory"",
          ""address uniFactory"",
          ""address flashGoverner"",
          ""uint256 precisionOrderOfMagnitude"",
          ""address[] memory sushiLPs"",
          ""address[] memory uniLPs""
        ]
      },
      {
        ""Name"": ""killDAO"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Kills the DAO and transfers ownership to a new address."",
        ""Parameters"": [""address newOwner""]
      },
      {
        ""Name"": ""setFateToFlan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the conversion rate from fate to flan tokens."",
        ""Parameters"": [""uint256 rate""]
      },
      {
        ""Name"": ""convertFateToFlan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Converts fate tokens to flan tokens."",
        ""Parameters"": [""uint256 fate""],
        ""Returns"": [""uint256 flan""]
      },
      {
        ""Name"": ""makeProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Creates a new proposal."",
        ""Parameters"": [""address proposal"", ""address proposer""]
      },
      {
        ""Name"": ""vote"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to vote on a proposal."",
        ""Parameters"": [""address proposal"", ""int256 fate""]
      },
      {
        ""Name"": ""executeCurrentProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Executes the current proposal.""
      },
      {
        ""Name"": ""setProposalConfig"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the configuration for proposals."",
        ""Parameters"": [""uint256 votingDuration"", ""uint256 requiredFateStake"", ""address proposalFactory""]
      },
      {
        ""Name"": ""setApprovedAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Approves or disapproves an asset."",
        ""Parameters"": [""address asset"", ""bool approved""]
      },
      {
        ""Name"": ""setEYEBasedAssetStake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the stake based on EYE token balance."",
        ""Parameters"": [
          ""uint256 finalAssetBalance"",
          ""uint256 finalEYEBalance"",
          ""uint256 rootEYE"",
          ""address asset""
        ]
      },
      {
        ""Name"": ""burnAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns an asset and creates fate tokens."",
        ""Parameters"": [""address asset"", ""uint256 amount""]
      },
      {
        ""Name"": ""approveFlanMintingPower"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Approves or disapproves flan minting power for a minter."",
        ""Parameters"": [""address minter"", ""bool enabled""]
      },
      {
        ""Name"": ""makeLive"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Makes the DAO live.""
      },
      {
        ""Name"": ""transferOwnershipOfThing"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers ownership of a specified contract."",
        ""Parameters"": [""address thing"", ""address destination""]
      },
      {
        ""Name"": ""timeRemainingOnProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the time remaining on the current proposal."",
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_seed"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to seed the DAO with key addresses."",
        ""Parameters"": [
          ""address limbo"",
          ""address flan"",
          ""address eye"",
          ""address sushiFactory"",
          ""address uniFactory"",
          ""address flashGoverner""
        ]
      },
      {
        ""Name"": ""getFlashGoverner"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the address of the flash governer."",
        ""Returns"": [""address""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""OpenZeppelin's Ownable and IERC20"",
    ""ERC677"",
    ""Flan"",
    ""ProposalFactory"",
    ""SwapFactoryLike"",
    ""UniPairLike"",
    ""Governable""
  ],
  ""SpecialMechanisms"": [
    ""Proposal creation and voting mechanism"",
    ""Asset staking and fate growth strategies"",
    ""Conversion of fate to flan tokens"",
    ""Use of modifiers for access control and state updates""
  ],
  ""Questions"": [
    ""How is the fate growth strategy determined for each asset?"",
    ""What is the significance of the `rootEYE` parameter in `setEYEBasedAssetStake`?"",
    ""How does the `updateCurrentProposal` modifier handle proposal execution timing?"",
    ""What are the specific roles of `SwapFactoryLike` and `UniPairLike` in the DAO?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in `vote` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `vote` function does not follow the checks-effects-interactions pattern, potentially allowing reentrancy attacks if external calls are made to malicious contracts. This could lead to manipulation of voting outcomes or fund drainage."",
      ""Impact"": ""An attacker could exploit this to manipulate voting outcomes or drain funds."",
      ""Location"": ""Function `vote` in `LimboDAO` contract""
    },
    {
      ""Issue"": ""Potential Reentrancy in `convertFateToFlan` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `convertFateToFlan` function updates the user's `fateBalance` state after minting Flan tokens, which could lead to reentrancy attacks if the `mint` function in the `Flan` contract is not properly secured."",
      ""Impact"": ""An attacker could drain the contract of Flan tokens or manipulate the `fateBalance` state."",
      ""Location"": ""Function `convertFateToFlan`""
    },
    {
      ""Issue"": ""Potential Reentrancy in `ERC20NetTransfer`"",
      ""Severity"": ""High"",
      ""Description"": ""The `ERC20NetTransfer` function in the `TransferHelper` library performs an external call to transfer tokens without following the checks-effects-interactions pattern, potentially allowing reentrancy attacks."",
      ""Impact"": ""An attacker could exploit this to re-enter the contract and manipulate the state, potentially leading to loss of funds or other unintended behavior."",
      ""Location"": ""TransferHelper library, `ERC20NetTransfer` function""
    },
    {
      ""Issue"": ""Insufficient Access Control in `killDAO` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `killDAO` function allows the owner to transfer ownership of the DAO to a new address without proper validation or restrictions, potentially leading to unauthorized transfer of control."",
      ""Impact"": ""An attacker could gain control of the DAO and manipulate its operations, leading to potential loss of funds or unauthorized changes to the contract state."",
      ""Location"": ""Function: `killDAO`""
    },
    {
      ""Issue"": ""Unrestricted Access to `makeProposal` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `makeProposal` function does not validate the `proposer` address, allowing malicious actors to create proposals on behalf of others or without proper authorization."",
      ""Impact"": ""Unauthorized creation of proposals, potentially leading to governance manipulation."",
      ""Location"": ""Function `makeProposal`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `seed` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `seed` function does not validate the input addresses, particularly the `sushiLPs` and `uniLPs` arrays, which could lead to setting critical contract addresses to zero or invalid addresses."",
      ""Impact"": ""Critical contract addresses could be set to invalid values, leading to a loss of functionality or control."",
      ""Location"": ""Function `seed` in `LimboDAO` contract""
    },
    {
      ""Issue"": ""Unrestricted Access to `setFateToFlan` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setFateToFlan` function can be called by any successful proposal without additional validation, potentially allowing malicious proposals to manipulate the conversion rate."",
      ""Impact"": ""Malicious actors could manipulate the conversion rate between Fate and Flan, leading to unfair economic advantages."",
      ""Location"": ""Function `setFateToFlan`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `setEYEBasedAssetStake` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setEYEBasedAssetStake` function does not validate the `finalAssetBalance` and `finalEYEBalance` inputs sufficiently, potentially leading to incorrect calculations of `fateWeight` and `fatePerDay`."",
      ""Impact"": ""Incorrect calculations could lead to unfair voting power distribution or governance manipulation."",
      ""Location"": ""Function `setEYEBasedAssetStake`""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `incrementFateFor` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `incrementFateFor` function calculates `fateBalance` by multiplying `fatePerDay` with the time difference, which could lead to an integer overflow if `fatePerDay` is large."",
      ""Impact"": ""Incorrect calculation of `fateBalance`, potentially leading to unfair advantage or loss of funds."",
      ""Location"": ""Function `incrementFateFor`""
    },
    {
      ""Issue"": ""Potential Division by Zero in `setEYEBasedAssetStake` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setEYEBasedAssetStake` function performs division operations without checking for zero values, which could result in a division by zero error."",
      ""Impact"": ""A division by zero error could cause the function to revert, potentially disrupting the DAO's staking mechanism."",
      ""Location"": ""`setEYEBasedAssetStake` function""
    },
    {
      ""Issue"": ""Lack of Event Emission in Critical Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Several critical functions such as `setProposalConfig`, `setApprovedAsset`, and `transferOwnershipOfThing` do not emit events, making it difficult to track changes and actions on the blockchain."",
      ""Impact"": ""Reduced transparency and auditability of contract actions."",
      ""Location"": ""Functions `setProposalConfig`, `setApprovedAsset`, `transferOwnershipOfThing`""
    },
    {
      ""Issue"": ""Uninitialized State Variables"",
      ""Severity"": ""Low"",
      ""Description"": ""The `currentProposalState` and `previousProposalState` state variables are not initialized in the constructor, which could lead to unexpected behavior if accessed before being properly set."",
      ""Impact"": ""Uninitialized state variables could cause the contract to behave unpredictably, potentially leading to vulnerabilities or errors."",
      ""Location"": ""State variables `currentProposalState` and `previousProposalState`""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 12
}",492.07450008392334,91309.0,24.0,"### **[H-07] LP pricing formula is vulnerable to flashloan manipulation**

**Report Description**:  
The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE tokens into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to obtain more `fate` than they are entitled to at a relatively low cost. With the large portion of `fate`, the attacker gains increased voting power to influence the system's decisions or convert `fate` to Flan tokens for direct profit.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of flashloan manipulation in the LP pricing formula. This is a critical vulnerability that could lead to governance manipulation and financial exploitation, but it is entirely missed in the response list.

---

### **[M-04] The system can get to a ""stuck"" state if a bad proposal (proposal that can't be executed) is accepted**

**Report Description**:  
The `LimboDAO` contract has a variable that indicates the current proposal, and only one proposal can exist at a time. A proposal can only be replaced if the previous proposal is either accepted and executed or rejected. If a proposal that cannot succeed (e.g., an `UpdateMultipleSoulConfigProposal` with insufficient gas or too many tokens) is accepted, the system will become stuck. The `vote` function will revert because the voting period has ended, and the `execute` function will revert because the proposal cannot be executed. As a result, the proposal remains as the current proposal, and new proposals cannot be registered.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of the system becoming stuck due to an unexecutable proposal. This is a medium-severity issue that could disrupt the governance process, but it is entirely missed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-07] LP pricing formula is vulnerable to flashloan manipulation**  
- **[M-04] The system can get to a ""stuck"" state if a bad proposal (proposal that can't be executed) is accepted**

---

### **Conclusion**  
The `response_list` fails to address two critical issues from the `issue` report: the flashloan manipulation vulnerability in the LP pricing formula and the potential for the system to become stuck due to an unexecutable proposal. These gaps indicate a lack of coverage for governance-related vulnerabilities and financial manipulation risks in the response list.","```
None.
```",0.0
Limbo.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}",7824,631,"[M-10] user won't be able to get his rewards in case of staking with amount = 0

Submitted by CertoraInc, also found by Randyyy
Limbo.sol (stake() function)

If a user has a pending reward and he calls the stake function with amount = 0, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)
That's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward
",1,,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";


enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, 
  perpetual 
}



struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; 
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; 
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; 
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; 
  uint256 initialCrossingBonus; 
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; 
  uint256 crossingMigrationDelay; 
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; 
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}





contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; 
  bool protocolEnabled = true;

  
  CrossingConfig public crossingConfig;

  
  
  mapping(address => mapping(uint256 => Soul)) public souls;

  
  mapping(address => uint256) public latestIndex;

  
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  
  
  
  
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor 
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  
  
  
  
  
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  
  
  
  
  
  
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  
  
  
  
  
  
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  
  
  
  
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; 
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  
  
  
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  
  
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  
  
  
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  
  
  
  
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  
  
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; 
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}",3769,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities, especially in functions like `stake`, `unstake`, and `migrate`."",
        ""Verify that all arithmetic operations are safe from overflow/underflow, particularly in reward calculations."",
        ""Ensure external calls (e.g., `IERC20.transfer`, `AngbandLike.executePower`) are safely handled and revert on failure."",
        ""Review the `migrate` function for potential risks associated with external contract interactions.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-20 standards for token interactions."",
        ""Ensure that the governance mechanisms comply with best practices for decentralized governance.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Audit the reward calculation logic in `updateSoul` and `getPending` for accuracy and potential edge cases."",
        ""Review the crossing bonus calculation in `claimBonus` for correctness and potential vulnerabilities."",
        ""Check the logic in `attemptToTargetAPY` for ensuring the desired APY is correctly targeted.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Review all interactions with external contracts (e.g., `FlanLike`, `BehodlerLike`, `AngbandLike`) for safety and correctness."",
        ""Ensure that the `FlashGovernanceArbiterLike` contract enforces tolerance correctly and securely.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only authorized users can call governance functions like `configureCrossingConfig` and `disableProtocol`."",
        ""Ensure that the `onlySuccessfulProposal` and `governanceApproved` modifiers are correctly implemented and enforced.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, particularly in loops and complex calculations."",
        ""Consider using `view` and `pure` functions where possible to reduce gas costs.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Review the AMM interactions in `migrate` and `claimSecondaryRewards` for potential risks like impermanent loss."",
        ""Ensure that the `AMMHelper` contract is used securely and correctly.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Check if the contract is vulnerable to flash loan attacks, particularly in functions that calculate rewards or bonuses."",
        ""Implement safeguards if necessary to prevent flash loan manipulation.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Audit the governance mechanisms for vulnerabilities like vote manipulation or replay attacks."",
        ""Ensure that proposals are securely executed and that only valid proposals can be enacted.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Verify that the staking and reward distribution mechanisms are secure and fair."",
        ""Ensure that users cannot manipulate the system to gain unfair rewards.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the tokenomics model for potential risks like inflation or deflation."",
        ""Ensure that the `Flan` token minting is controlled and does not lead to excessive inflation.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check for potential front-running vulnerabilities, particularly in functions like `stake` and `unstake`."",
        ""Consider implementing commit-reveal schemes if necessary to prevent front-running.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract does not have mechanisms that could be used to drain funds maliciously."",
        ""Verify that the `protocolEnabled` flag is used correctly to prevent unauthorized shutdowns.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Review the `disableProtocol` and `enableProtocol` functions for correct implementation and security."",
        ""Ensure that there are proper emergency stop mechanisms in place to protect user funds.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided Solidity code is for a complex contract named 'Limbo' that appears to manage staking, rewards, and token migration within a DeFi ecosystem. The contract integrates with multiple external contracts and libraries, and it uses governance mechanisms to control certain functionalities."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Limbo"",
    ""Purpose"": ""To manage staking, rewards, and token migration within a DeFi ecosystem, including functionalities like staking tokens, claiming rewards, and migrating tokens to another contract (Behodler)."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Governable""],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""./facades/LimboDAOLike.sol"",
        ""./facades/Burnable.sol"",
        ""./facades/BehodlerLike.sol"",
        ""./facades/FlanLike.sol"",
        ""./facades/UniPairLike.sol"",
        ""./facades/MigratorLike.sol"",
        ""./facades/AMMHelper.sol"",
        ""./facades/AngbandLike.sol"",
        ""./facades/LimboAddTokenToBehodlerPowerLike.sol"",
        ""./DAO/Governable.sol"",
        ""./facades/FlashGovernanceArbiterLike.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""crossingConfig"",
        ""Type"": ""CrossingConfig"",
        ""Purpose"": ""Stores configuration parameters related to the token migration process.""
      },
      {
        ""Name"": ""souls"",
        ""Type"": ""mapping(address => mapping(uint256 => Soul))"",
        ""Purpose"": ""Tracks the state and parameters of each token's 'soul' (staking and migration state).""
      },
      {
        ""Name"": ""latestIndex"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Keeps track of the latest index for each token's soul.""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(address => mapping(address => mapping(uint256 => User)))"",
        ""Purpose"": ""Stores user-specific staking and reward information.""
      },
      {
        ""Name"": ""tokenCrossingParameters"",
        ""Type"": ""mapping(address => mapping(uint256 => CrossingParameters))"",
        ""Purpose"": ""Stores parameters related to the crossing (migration) process for each token.""
      },
      {
        ""Name"": ""unstakeApproval"",
        ""Type"": ""mapping(address => mapping(address => mapping(address => uint256)))"",
        ""Purpose"": ""Tracks approvals for unstaking tokens on behalf of another user.""
      },
      {
        ""Name"": ""Flan"",
        ""Type"": ""FlanLike"",
        ""Purpose"": ""Interface for interacting with the Flan token contract.""
      },
      {
        ""Name"": ""protocolEnabled"",
        ""Type"": ""bool"",
        ""Purpose"": ""Controls whether the protocol is enabled or disabled.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""attemptToTargetAPY"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Attempts to adjust the Flan per second (FPS) rate to target a desired APY."",
        ""Parameters"": [""address token"", ""uint256 desiredAPY"", ""uint256 daiThreshold""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateSoul"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the soul state and accumulated rewards for a token."",
        ""Parameters"": [""address token""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureCrossingConfig"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures the crossing configuration parameters."",
        ""Parameters"": [
          ""address behodler"",
          ""address angband"",
          ""address ammHelper"",
          ""address morgothPower"",
          ""uint256 migrationInvocationReward"",
          ""uint256 crossingMigrationDelay"",
          ""uint16 rectInflationFactor""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""disableProtocol"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Disables the protocol."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""enableProtocol"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Enables the protocol."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""adjustSoul"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adjusts the soul parameters for a token."",
        ""Parameters"": [""address token"", ""uint256 initialCrossingBonus"", ""int256 crossingBonusDelta"", ""uint256 fps""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureSoul"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures the soul parameters for a token."",
        ""Parameters"": [""address token"", ""uint256 crossingThreshold"", ""uint256 soulType"", ""uint256 state"", ""uint256 index"", ""uint256 fps""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureCrossingParameters"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures the crossing parameters for a token."",
        ""Parameters"": [""address token"", ""uint256 initialCrossingBonus"", ""int256 crossingBonusDelta"", ""bool burnable"", ""uint256 crossingThreshold""],
        ""Returns"": []
      },
      {
        ""Name"": ""stake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to stake tokens."",
        ""Parameters"": [""address token"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""unstake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to unstake tokens."",
        ""Parameters"": [""address token"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""unstakeFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to unstake tokens on behalf of another user."",
        ""Parameters"": [""address token"", ""uint256 amount"", ""address holder""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to claim staking rewards."",
        ""Parameters"": [""address token"", ""uint256 index""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimBonus"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to claim a bonus for crossing over."",
        ""Parameters"": [""address token"", ""uint256 index""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimSecondaryRewards"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a user to claim secondary rewards."",
        ""Parameters"": [""address token""],
        ""Returns"": []
      },
      {
        ""Name"": ""migrate"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Migrates a token to the Behodler contract."",
        ""Parameters"": [""address token""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveUnstake"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Approves another address to unstake tokens on behalf of the caller."",
        ""Parameters"": [""address soul"", ""address unstaker"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""rewardAdjustDebt"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Adjusts the user's reward debt after claiming rewards."",
        ""Parameters"": [""address recipient"", ""uint256 pending"", ""uint256 accumulatedFlanPerShare"", ""User storage user""],
        ""Returns"": []
      },
      {
        ""Name"": ""currentSoul"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the current soul state for a token."",
        ""Parameters"": [""address token""],
        ""Returns"": [""Soul storage""]
      },
      {
        ""Name"": ""getPending"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the pending rewards for a user."",
        ""Parameters"": [""User memory user"", ""Soul memory soul""],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""OpenZeppelin's Ownable, IERC20, and SafeERC20 contracts"",
    ""FlanLike contract for Flan token interactions"",
    ""BehodlerLike contract for Behodler interactions"",
    ""AngbandLike contract for executing powers"",
    ""AMMHelper contract for AMM operations"",
    ""LimboAddTokenToBehodlerPowerLike contract for token migration"",
    ""FlashGovernanceArbiterLike contract for governance enforcement""
  ],
  ""SpecialMechanisms"": [
    ""Governance-controlled functions using 'governanceApproved' and 'onlySuccessfulProposal' modifiers"",
    ""Staking and reward distribution mechanism"",
    ""Token migration mechanism involving multiple external contracts"",
    ""Crossing parameters and bonus calculation for token migration""
  ],
  ""Questions"": [
    ""What is the exact role of the 'FlashGovernanceArbiterLike' contract and how does it enforce tolerance?"",
    ""How is the 'RectangleOfFairness' calculated and why is it significant in the migration process?"",
    ""What are the specific conditions under which the 'protocolEnabled' flag is toggled?"",
    ""How are the 'SoulState' and 'SoulType' enums used in the contract's logic?"",
    ""What are the potential risks associated with the token migration process, especially with external contract interactions?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in Unstake Function"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple instances of reentrancy vulnerabilities were found in `unstake`, `unstakeFor`, and `_unstake` functions where tokens are transferred before updating the user's staked amount and reward debt. This can be exploited to drain funds."",
      ""Impact"": ""An attacker could repeatedly call the function to withdraw more tokens than entitled, leading to loss of funds."",
      ""Location"": ""Functions: `unstake`, `unstakeFor`, `Limbo::_unstake`""
    },
    {
      ""Issue"": ""Unrestricted Token Transfer in MigrationLib"",
      ""Severity"": ""High"",
      ""Description"": ""The `migrate` function in `MigrationLib` transfers the entire token balance to `morgothPower` without checks, risking unauthorized transfers if the address is compromised."",
      ""Impact"": ""Potential loss of funds or unauthorized token transfers."",
      ""Location"": ""MigrationLib.migrate function""
    },
    {
      ""Issue"": ""Insufficient Access Control in `configureCrossingConfig`"",
      ""Severity"": ""High"",
      ""Description"": ""The `configureCrossingConfig` function lacks proper access control or input validation, allowing unauthorized changes to critical protocol parameters."",
      ""Impact"": ""Unauthorized changes could lead to protocol manipulation or financial loss."",
      ""Location"": ""Function `configureCrossingConfig`""
    },
    {
      ""Issue"": ""Uninitialized Soul State"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `Soul` struct can be initialized with an uninitialized state (`SoulType.uninitialized`), leading to unexpected behavior if not handled properly."",
      ""Impact"": ""Potential for unauthorized operations or incorrect state transitions."",
      ""Location"": ""Functions: `configureSoul`, `updateSoul`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `configureSoul` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `configureSoul` function does not validate `soulType` and `state` parameters, risking invalid state configurations."",
      ""Impact"": ""Invalid states could disrupt protocol functionality."",
      ""Location"": ""Function `configureSoul`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations in functions like `adjustSoul`, `claimBonus`, and reward calculations lack overflow/underflow checks, despite Solidity 0.8.x safeguards."",
      ""Impact"": ""Incorrect calculations could lead to fund loss or protocol malfunction."",
      ""Location"": ""Functions: `adjustSoul`, `claimBonus`, `updateSoul`""
    },
    {
      ""Issue"": ""Insufficient Validation in `migrate` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `migrate` function does not validate token addresses or check return values, risking failed migrations or malicious token interactions."",
      ""Impact"": ""Migration failures or loss of funds due to invalid tokens."",
      ""Location"": ""Function `migrate`""
    },
    {
      ""Issue"": ""Potential Front-Running in `stake` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `stake` function updates state after token transfers, making it vulnerable to front-running attacks for unfair reward manipulation."",
      ""Impact"": ""Unfair reward distribution or staking manipulation."",
      ""Location"": ""Function `stake`""
    },
    {
      ""Issue"": ""Lack of Event Emission in Critical Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical functions like `adjustSoul`, `configureCrossingParameters`, and protocol toggles do not emit events, reducing transparency."",
      ""Impact"": ""Harder to track state changes or debug issues."",
      ""Location"": ""Functions: `adjustSoul`, `configureCrossingParameters`, `disableProtocol`, `enableProtocol`""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 9
}",424.07754588127136,99701.0,24.0,"### **[M-10] User Won't Be Able to Get His Rewards in Case of Staking with Amount = 0**

**Report Description**:  
In the `stake()` function of `Limbo.sol`, if a user has a pending reward and calls the `stake` function with `amount = 0`, they won't be able to claim their reward. This occurs because the reward calculation is only performed if the staked amount (provided as a parameter) is greater than 0. However, the reward debt is updated even if the amount is 0, effectively overwriting the reward without allowing the user to claim it. This behavior can lead to users losing their rightful rewards, especially in edge cases where they attempt to stake with a zero amount.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While the response list includes findings related to the `stake` function (e.g., potential front-running), it does not cover the scenario where users are unable to claim rewards when staking with `amount = 0`. This is a distinct issue that requires specific attention to ensure users can claim their rewards regardless of the staked amount.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-10] User Won't Be Able to Get His Rewards in Case of Staking with Amount = 0**

---

The response list does not adequately address the issue described in the report. The issue highlights a specific edge case in the `stake()` function that could lead to users losing their rewards, which is not covered by any of the findings in the response list. This represents a gap in the response list's coverage of vulnerabilities and risks in the smart contract.","```
None.
```",0.0
UniswapHelper.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""./facades/UniPairLike.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./DAO/Governable.sol"";
// import ""hardhat/console.sol"";
import ""./ERC677/ERC20Burnable.sol"";
import ""./facades/FlanLike.sol"";
import ""./testing/realUniswap/interfaces/IUniswapV2Factory.sol"";
import ""./facades/AMMHelper.sol"";

contract BlackHole {}

///@Title Uniswap V2 helper for managing Flan liquidity on Uniswap V2, Sushiswap and any other compatible AMM
///@author Justin Goro
/**@notice Flan liquidity is boosted on Uniswap (or Sushiswap) via open market operations at the point of a token migration.
  * UniswapHelper handles all the mechanics as well managing a just-in-time (Justin Time?) oracle
 */
contract UniswapHelper is Governable, AMMHelper {
  address limbo;

  struct UniVARS {
    UniPairLike Flan_SCX_tokenPair;
    address behodler;
    address blackHole;
    address flan;
    uint256 divergenceTolerance;
    uint256 minQuoteWaitDuration;
    address DAI;
    uint8 precision; // behodler uses a binary search. The higher this number, the more precise
    IUniswapV2Factory factory;
    uint8 priceBoostOvershoot; //percentage (0-100) for which the price must be overcorrected when strengthened to account for other AMMs
  }

  struct FlanQuote {
    uint256 DaiScxSpotPrice;
    uint256 DaiBalanceOnBehodler;
    uint256 blockProduced;
  }

  /**@dev the Dai SCX price and the Dai balance on Behodler are both sampled twice before a migration can occur. 
  * The two samples have to be spaced a minimum duration and have to be the same values (within an error threshold). The objective here is to make price manipulation untenably expensive for an attacker
  * so that the mining power expended (or the opportunity cost of eth staked) far exceeds the benefit to manipulating Limbo.
  * The assumption of price stability isn't a bug because migrations aren't required to happen frequently. Instead if natural price drift occurs for non malicious reasons,
  * the migration can be reattempted until a period of sufficient calm allows for migration. If a malicious actor injects volatility in order to prevent migration, by the principle
  * of antifragility, they're doing the entire Ethereum ecosystem a service at their own expense.
  */
  FlanQuote[2] public latestFlanQuotes; //0 is latest

  UniVARS VARS;

  //not sure why codebases don't use keyword ether but I'm reluctant to entirely part with that tradition for now.
  uint256 constant EXA = 1e18;

  //needs to be updated for future Martian, Lunar and Venusian blockchains although I suspect Lunar colonies will be very Terracentric because of low time lag.
  uint256 constant year = (1 days * 365);

  /*
    instead of relying on oracles, we simply require snapshots of important 
    prices to be taken at intervals far enough apart.
    If an attacker wishes to overstate or understate a price through market manipulation,
    they'd have to keep it out of equilibrium over the span of the two snapshots or they'd
    have to time the manipulation to happen as the snapshots occur. As a miner,
    they could do this through transaction ordering but they'd have to win two blocks at precise moments
    which is statistically highly unlikely. 
    The snapshot enforcement can be hindered by false negatives. Natural price variation, for instance, but the cost
    of this is just having to snapshot again when the market is calmer. Since migration is not not time sensitive,
    this is a cost worth bearing.
    */
  modifier ensurePriceStability() {
    _ensurePriceStability();
    _;
  }

  modifier onlyLimbo() {
    require(msg.sender == limbo);
    _;
  }

  constructor(address _limbo, address limboDAO) Governable(limboDAO) {
    limbo = _limbo;
    VARS.blackHole = address(new BlackHole());
    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
  }

  ///@notice LP tokens minted during migration are discarded.
  function blackHole() public view returns (address) {
    return VARS.blackHole;
  }

  ///@notice Uniswap factory contract
  function setFactory(address factory) public {
    require(block.chainid != 1, ""Uniswap factory hardcoded on mainnet"");
    VARS.factory = IUniswapV2Factory(factory);
  }

  ///@dev Only for testing: On mainnet Dai has a fixed address.
  function setDAI(address dai) public {
    require(block.chainid != 1, ""DAI hardcoded on mainnet"");
    VARS.DAI = dai;
  }

  ///@notice main configuration function.
  ///@dev We prefer to use configuration functions rather than a constructor for a number of reasons.
  ///@param _limbo Limbo contract
  ///@param FlanSCXPair The Uniswap flan/SCX pair
  ///@param behodler Behodler AMM
  ///@param flan The flan token
  ///@param divergenceTolerance The amount of price difference between the two quotes that is tolerated before a migration is attempted 
  ///@param minQuoteWaitDuration The minimum duration between the sampling of oracle data used for migration
  ///@param precision In order to query the tokens redeemed by a quantity of SCX, Behodler performs a binary search. Precision refers to the max iterations of the search.
  ///@param priceBoostOvershoot Flan targets parity with Dai. If we set Flan to equal Dai then between migrations, it will always be below Dai. Overshoot gives us some runway by intentionally ""overshooting"" the price
  function configure(
    address _limbo,
    address FlanSCXPair,
    address behodler,
    address flan,
    uint256 divergenceTolerance,
    uint256 minQuoteWaitDuration,
    uint8 precision,
    uint8 priceBoostOvershoot
  ) public onlySuccessfulProposal {
    limbo = _limbo;
    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);
    VARS.behodler = behodler;
    VARS.flan = flan;
    require(divergenceTolerance >= 100, ""Divergence of 100 is parity"");
    VARS.divergenceTolerance = divergenceTolerance;
    VARS.minQuoteWaitDuration = minQuoteWaitDuration;
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    VARS.precision = precision == 0 ? precision : precision;
    require(priceBoostOvershoot < 100, ""Set overshoot to number between 1 and 100."");
    VARS.priceBoostOvershoot = priceBoostOvershoot;
  }

  ///@notice Samples the two values required for migration. Must be called twice before migration can occur.
  function generateFLNQuote() public override {
    latestFlanQuotes[1] = latestFlanQuotes[0];
    (
      latestFlanQuotes[0].DaiScxSpotPrice,
      latestFlanQuotes[0].DaiBalanceOnBehodler
    ) = getLatestFLNQuote();
    latestFlanQuotes[0].blockProduced = block.number;
  }

  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {
    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(
      VARS.DAI,
      10000,
      1 ether,
      VARS.precision
    );
    dai_scx = (daiToRelease * EXA) / (1 ether);

    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);
  }

  ///@notice When tokens are migrated to Behodler, SCX is generated. This SCX is used to boost Flan liquidity and nudge the price of Flan back to parity with Dai
  ///@param rectangleOfFairness refers to the quantity of SCX held back to be used for open market Flan stabilizing operations
  ///@dev makes use of price tilting. Be sure to understand the concept of price tilting before trying to understand the final if statement.
  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {
    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));

    //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.
    //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes
    require((localSCXBalance * 100) / rectangleOfFairness == 98, ""EM"");
    rectangleOfFairness = localSCXBalance;

    //get DAI per scx
    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));
    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;

    //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.
    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);
    address pair = address(VARS.Flan_SCX_tokenPair);
    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);

    if (existingFlanOnLP < DesiredFinalFlanOnLP) {
      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;

      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;
      FlanLike(VARS.flan).mint(pair, flanToMint);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      {
        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
      }
    } else {
      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();

      FlanLike(VARS.flan).mint(pair, minFlan + 2);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
    }
    //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.
    _zeroOutQuotes();
  }

  ///@notice helper function for converting a desired APY into a flan per second (FPS) statistic
  ///@param minAPY Here APY refers to the dollar value of flan relative to the dollar value of the threshold
  ///@param daiThreshold The DAI value of the target threshold to list on Behodler. Threshold is an approximation of the AVB on Behodler
  function minAPY_to_FPS(
    uint256 minAPY, //divide by 10000 to get percentage
    uint256 daiThreshold
  ) public override view ensurePriceStability returns (uint256 fps) {
    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;
    // console.log(""DAI threshold %s"", daiThreshold);
    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;
    fps = returnOnThreshold / (year);
  }

  ///@notice Buys Flan with a specified token, apportions 1% of the purchased Flan to the caller and burns the rest.
  ///@param inputToken The token used to buy Flan
  ///@param amount amount of input token used to buy Flan
  ///@param recipient receives 1% of Flan purchased as an incentive to call this function regularly
  ///@dev Assumes a pair for Flan/InputToken exists on Uniswap
  function buyFlanAndBurn(
    address inputToken,
    uint256 amount,
    address recipient
  ) public override {
    address pair = VARS.factory.getPair(inputToken, VARS.flan);

    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);
    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);

    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);
    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;
    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;
    IERC20(inputToken).transfer(pair, amount);
    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), """");
    uint256 reward = (amountOut / 100);
    ERC20Burnable(VARS.flan).transfer(recipient, reward);
    ERC20Burnable(VARS.flan).burn(amountOut - reward);
  }

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountOut) {
    uint256 amountInWithFee = amountIn * 997;
    uint256 numerator = amountInWithFee * reserveOut;
    uint256 denominator = reserveIn * 1000 + amountInWithFee;
    amountOut = numerator / denominator;
  }

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountIn) {
    uint256 numerator = reserveIn * amountOut * 1000;
    uint256 denominator = (reserveOut - amountOut) * 997;
    amountIn = (numerator / denominator) + 1;
  }

  function _zeroOutQuotes() internal {
    delete latestFlanQuotes[0];
    delete latestFlanQuotes[1];
  }

  //the purpose of the divergence code is to bring the robustness of a good oracle without requiring an oracle
  function _ensurePriceStability() internal view {
    FlanQuote[2] memory localFlanQuotes; //save gas
    localFlanQuotes[0] = latestFlanQuotes[0];
    localFlanQuotes[1] = latestFlanQuotes[1];

    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice
      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice
      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;

    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler
      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler
      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;

    // console.log(""dai balance divergence %s"", daiBalanceDivergence);
    require(
      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,
      ""EG""
    );

    require(
      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&
        localFlanQuotes[1].blockProduced > 0,
      ""EH""
    );
  }
}",3665,289,"[M-07] Calling generateFLNQuote twice in every block prevents any migration

Submitted by camden, also found by GeekyLumberjack, kirk-baird, and shw
https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138 In the Uniswap helper, generateFLNQuote is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a blockProduced value of the current block's number.
These quotes are used in the _ensurePriceStability function. The last require statement here is key: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285
   [M-11] You can grief migrations by sending SCX to the UniswapHelper

Submitted by camden, also found by robee
The attack here allows the attacker to prevent migrations.
The attack here is recoverable because we can just call buyFlanAndBurn (f it worked as expected) with SCX as the input token to buy Flan with the extra SCX, then run the migration again.
   [M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks

Submitted by hyh
Trades can happen at a manipulated price and end up receiving fewer Flan to be bought than current market price dictates.
For example, at the time a user decides to call buyFlanAndBurn Flan trades at 0.8 in the input token terms at the corresponding DEX pool. If the input token holdings are big enough to compensate for pool manipulation costs, the following can happen: Flan buy order will be seen by a malicious bot, that buys Flan, pushing it to 0.9 before UniswapHelper's order comes through, and selling it back right afterwards. This way, given a cumulative impact of the trades on Flan's market price, the input token will be overspent.
This yields direct loss for the system as input token market operations have lesser effect than expected at the expense of contract holdings.

",3,,"pragma solidity 0.8.4;
import ""./facades/UniPairLike.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./DAO/Governable.sol"";

import ""./ERC677/ERC20Burnable.sol"";
import ""./facades/FlanLike.sol"";
import ""./testing/realUniswap/interfaces/IUniswapV2Factory.sol"";
import ""./facades/AMMHelper.sol"";

contract BlackHole {}




contract UniswapHelper is Governable, AMMHelper {
  address limbo;

  struct UniVARS {
    UniPairLike Flan_SCX_tokenPair;
    address behodler;
    address blackHole;
    address flan;
    uint256 divergenceTolerance;
    uint256 minQuoteWaitDuration;
    address DAI;
    uint8 precision; 
    IUniswapV2Factory factory;
    uint8 priceBoostOvershoot; 
  }

  struct FlanQuote {
    uint256 DaiScxSpotPrice;
    uint256 DaiBalanceOnBehodler;
    uint256 blockProduced;
  }

  
  FlanQuote[2] public latestFlanQuotes; 

  UniVARS VARS;

  
  uint256 constant EXA = 1e18;

  
  uint256 constant year = (1 days * 365);

  
  modifier ensurePriceStability() {
    _ensurePriceStability();
    _;
  }

  modifier onlyLimbo() {
    require(msg.sender == limbo);
    _;
  }

  constructor(address _limbo, address limboDAO) Governable(limboDAO) {
    limbo = _limbo;
    VARS.blackHole = address(new BlackHole());
    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
  }

  
  function blackHole() public view returns (address) {
    return VARS.blackHole;
  }

  
  function setFactory(address factory) public {
    require(block.chainid != 1, ""Uniswap factory hardcoded on mainnet"");
    VARS.factory = IUniswapV2Factory(factory);
  }

  
  function setDAI(address dai) public {
    require(block.chainid != 1, ""DAI hardcoded on mainnet"");
    VARS.DAI = dai;
  }

  
  
  
  
  
  
  
  
  
  
  function configure(
    address _limbo,
    address FlanSCXPair,
    address behodler,
    address flan,
    uint256 divergenceTolerance,
    uint256 minQuoteWaitDuration,
    uint8 precision,
    uint8 priceBoostOvershoot
  ) public onlySuccessfulProposal {
    limbo = _limbo;
    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);
    VARS.behodler = behodler;
    VARS.flan = flan;
    require(divergenceTolerance >= 100, ""Divergence of 100 is parity"");
    VARS.divergenceTolerance = divergenceTolerance;
    VARS.minQuoteWaitDuration = minQuoteWaitDuration;
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    VARS.precision = precision == 0 ? precision : precision;
    require(priceBoostOvershoot < 100, ""Set overshoot to number between 1 and 100."");
    VARS.priceBoostOvershoot = priceBoostOvershoot;
  }

  
  function generateFLNQuote() public override {
    latestFlanQuotes[1] = latestFlanQuotes[0];
    (
      latestFlanQuotes[0].DaiScxSpotPrice,
      latestFlanQuotes[0].DaiBalanceOnBehodler
    ) = getLatestFLNQuote();
    latestFlanQuotes[0].blockProduced = block.number;
  }

  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {
    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(
      VARS.DAI,
      10000,
      1 ether,
      VARS.precision
    );
    dai_scx = (daiToRelease * EXA) / (1 ether);

    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);
  }

  
  
  
  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {
    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));

    
    
    require((localSCXBalance * 100) / rectangleOfFairness == 98, ""EM"");
    rectangleOfFairness = localSCXBalance;

    
    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));
    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;

    
    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);
    address pair = address(VARS.Flan_SCX_tokenPair);
    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);

    if (existingFlanOnLP < DesiredFinalFlanOnLP) {
      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;

      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;
      FlanLike(VARS.flan).mint(pair, flanToMint);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      {
        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
      }
    } else {
      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();

      FlanLike(VARS.flan).mint(pair, minFlan + 2);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
    }
    
    _zeroOutQuotes();
  }

  
  
  
  function minAPY_to_FPS(
    uint256 minAPY, 
    uint256 daiThreshold
  ) public override view ensurePriceStability returns (uint256 fps) {
    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;
    
    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;
    fps = returnOnThreshold / (year);
  }

  
  
  
  
  
  function buyFlanAndBurn(
    address inputToken,
    uint256 amount,
    address recipient
  ) public override {
    address pair = VARS.factory.getPair(inputToken, VARS.flan);

    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);
    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);

    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);
    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;
    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;
    IERC20(inputToken).transfer(pair, amount);
    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), """");
    uint256 reward = (amountOut / 100);
    ERC20Burnable(VARS.flan).transfer(recipient, reward);
    ERC20Burnable(VARS.flan).burn(amountOut - reward);
  }

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountOut) {
    uint256 amountInWithFee = amountIn * 997;
    uint256 numerator = amountInWithFee * reserveOut;
    uint256 denominator = reserveIn * 1000 + amountInWithFee;
    amountOut = numerator / denominator;
  }

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountIn) {
    uint256 numerator = reserveIn * amountOut * 1000;
    uint256 denominator = (reserveOut - amountOut) * 997;
    amountIn = (numerator / denominator) + 1;
  }

  function _zeroOutQuotes() internal {
    delete latestFlanQuotes[0];
    delete latestFlanQuotes[1];
  }

  
  function _ensurePriceStability() internal view {
    FlanQuote[2] memory localFlanQuotes; 
    localFlanQuotes[0] = latestFlanQuotes[0];
    localFlanQuotes[1] = latestFlanQuotes[1];

    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice
      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice
      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;

    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler
      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler
      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;

    
    require(
      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,
      ""EG""
    );

    require(
      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&
        localFlanQuotes[1].blockProduced > 0,
      ""EH""
    );
  }
}",2373,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for reentrancy vulnerabilities in functions like `stabilizeFlan` and `buyFlanAndBurn`."",
        ""Verify that all external calls (e.g., `transfer`, `mint`, `swap`) are properly handled to prevent reentrancy."",
        ""Ensure all arithmetic operations are safe from overflow/underflow using Solidity 0.8.4's built-in checks."",
        ""Review the use of `require` statements to ensure they adequately protect against invalid states.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""Verify that the contract adheres to ERC-20 standards, especially in token transfers and burns."",
        ""Ensure that the contract complies with any specific DAO governance standards used in `Governable`.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Review the logic in `stabilizeFlan` to ensure it correctly calculates and adjusts liquidity."",
        ""Check the accuracy of the `getAmountOut` and `getAmountIn` functions for correct Uniswap-like calculations."",
        ""Verify the price stability checks in `_ensurePriceStability` for correctness and robustness.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit all interactions with external contracts (e.g., `UniPairLike`, `BehodlerLike`, `IUniswapV2Factory`) for potential risks."",
        ""Ensure that the contract handles potential failures in external calls gracefully.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyLimbo` modifier is correctly applied to restrict access to the Limbo contract."",
        ""Ensure that the `onlySuccessfulProposal` modifier in `configure` is correctly implemented to enforce DAO governance."",
        ""Check that the `setFactory` and `setDAI` functions are properly restricted to prevent unauthorized changes.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, such as repeated storage reads/writes in `generateFLNQuote` and `stabilizeFlan`."",
        ""Review the use of loops and large data structures for potential gas savings.""
      ]
    },
    {
      ""Area"": ""Liquidity Pools & AMM Risks"",
      ""Tasks"": [
        ""Ensure that the contract protects against impermanent loss in liquidity pools."",
        ""Verify that the contract handles edge cases in liquidity adjustments, such as zero liquidity or extreme price movements.""
      ]
    },
    {
      ""Area"": ""Flash Loan Protection"",
      ""Tasks"": [
        ""Check if the contract is vulnerable to flash loan attacks, especially in functions like `stabilizeFlan` and `buyFlanAndBurn`."",
        ""Implement safeguards to mitigate potential flash loan risks.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Verify that the price quotes from `getLatestFLNQuote` are reliable and tamper-proof."",
        ""Ensure that the contract has mechanisms to detect and respond to oracle manipulation.""
      ]
    },
    {
      ""Area"": ""Governance & Voting Security"",
      ""Tasks"": [
        ""Review the DAO governance mechanisms in `Governable` for potential vulnerabilities."",
        ""Ensure that governance proposals are securely executed and cannot be manipulated.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards"",
      ""Tasks"": [
        ""Verify that the reward distribution in `buyFlanAndBurn` is fair and secure."",
        ""Ensure that the contract protects against staking-related vulnerabilities, such as reward manipulation.""
      ]
    },
    {
      ""Area"": ""Tokenomics Risks"",
      ""Tasks"": [
        ""Review the token minting and burning mechanisms in `stabilizeFlan` and `buyFlanAndBurn` for potential inflationary risks."",
        ""Ensure that the contract does not allow for excessive token minting or burning that could destabilize the token economy.""
      ]
    },
    {
      ""Area"": ""Transaction Ordering & Front-running"",
      ""Tasks"": [
        ""Check if the contract is vulnerable to front-running, especially in functions like `buyFlanAndBurn`."",
        ""Implement commit-reveal schemes or other mechanisms to mitigate front-running risks.""
      ]
    },
    {
      ""Area"": ""Exit Scams/Rug Pulls"",
      ""Tasks"": [
        ""Ensure that the contract does not have mechanisms that allow for fund drainage or malicious exits."",
        ""Verify that all funds are securely managed and cannot be withdrawn without proper authorization.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""Check if the contract has emergency stop mechanisms to halt operations in case of critical vulnerabilities."",
        ""Ensure that the contract can be paused or stopped securely without causing additional risks.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The provided smart contract, UniswapHelper, is designed to interact with Uniswap and Behodler protocols, manage liquidity, and stabilize token prices. It includes functionalities for generating quotes, stabilizing token prices, and burning tokens. The contract is governed by a DAO and has specific mechanisms to ensure price stability and manage external interactions."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""UniswapHelper"",
    ""Purpose"": ""To manage liquidity, stabilize token prices, and interact with Uniswap and Behodler protocols."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Governable"", ""AMMHelper""],
      ""Imports"": [
        ""./facades/UniPairLike.sol"",
        ""./facades/BehodlerLike.sol"",
        ""./DAO/Governable.sol"",
        ""./ERC677/ERC20Burnable.sol"",
        ""./facades/FlanLike.sol"",
        ""./testing/realUniswap/interfaces/IUniswapV2Factory.sol"",
        ""./facades/AMMHelper.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""limbo"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the Limbo contract.""
      },
      {
        ""Name"": ""VARS"",
        ""Type"": ""UniVARS"",
        ""Purpose"": ""Struct containing various configuration parameters for Uniswap and Behodler interactions.""
      },
      {
        ""Name"": ""latestFlanQuotes"",
        ""Type"": ""FlanQuote[2]"",
        ""Purpose"": ""Array to store the latest two Flan quotes for price stability checks.""
      },
      {
        ""Name"": ""EXA"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant representing 1e18, used for precision in calculations.""
      },
      {
        ""Name"": ""year"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant representing the number of seconds in a year.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""ensurePriceStability"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures that the price is stable before executing a function."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyLimbo"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to the Limbo contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the Limbo and LimboDAO addresses."",
        ""Parameters"": [""address _limbo"", ""address limboDAO""],
        ""Returns"": []
      },
      {
        ""Name"": ""blackHole"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the address of the BlackHole contract."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""setFactory"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the Uniswap factory address, except on mainnet."",
        ""Parameters"": [""address factory""],
        ""Returns"": []
      },
      {
        ""Name"": ""setDAI"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the DAI token address, except on mainnet."",
        ""Parameters"": [""address dai""],
        ""Returns"": []
      },
      {
        ""Name"": ""configure"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures the contract with various parameters for Uniswap and Behodler interactions."",
        ""Parameters"": [
          ""address _limbo"",
          ""address FlanSCXPair"",
          ""address behodler"",
          ""address flan"",
          ""uint256 divergenceTolerance"",
          ""uint256 minQuoteWaitDuration"",
          ""uint8 precision"",
          ""uint8 priceBoostOvershoot""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""generateFLNQuote"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Generates a new Flan quote and updates the latestFlanQuotes array."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""getLatestFLNQuote"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Retrieves the latest Flan quote from Behodler."",
        ""Parameters"": [],
        ""Returns"": [""uint256 dai_scx"", ""uint256 daiBalanceOnBehodler""]
      },
      {
        ""Name"": ""stabilizeFlan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Stabilizes the Flan token price by adjusting liquidity and minting/burning tokens."",
        ""Parameters"": [""uint256 rectangleOfFairness""],
        ""Returns"": [""uint256 lpMinted""]
      },
      {
        ""Name"": ""minAPY_to_FPS"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the required FPS (Flan Per Second) to achieve a minimum APY."",
        ""Parameters"": [""uint256 minAPY"", ""uint256 daiThreshold""],
        ""Returns"": [""uint256 fps""]
      },
      {
        ""Name"": ""buyFlanAndBurn"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buys Flan tokens from Uniswap and burns a portion of them."",
        ""Parameters"": [""address inputToken"", ""uint256 amount"", ""address recipient""],
        ""Returns"": []
      },
      {
        ""Name"": ""getAmountOut"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the amount of output tokens for a given input amount in a Uniswap pair."",
        ""Parameters"": [""uint256 amountIn"", ""uint256 reserveIn"", ""uint256 reserveOut""],
        ""Returns"": [""uint256 amountOut""]
      },
      {
        ""Name"": ""getAmountIn"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the amount of input tokens required for a given output amount in a Uniswap pair."",
        ""Parameters"": [""uint256 amountOut"", ""uint256 reserveIn"", ""uint256 reserveOut""],
        ""Returns"": [""uint256 amountIn""]
      },
      {
        ""Name"": ""_zeroOutQuotes"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Clears the latestFlanQuotes array."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_ensurePriceStability"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Ensures that the price is stable by checking the latest Flan quotes."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""UniPairLike"",
    ""BehodlerLike"",
    ""IUniswapV2Factory"",
    ""FlanLike"",
    ""ERC20Burnable""
  ],
  ""SpecialMechanisms"": [
    ""Price stability checks using latestFlanQuotes"",
    ""Liquidity management and token minting/burning"",
    ""Governance through DAO (Governable)""
  ],
  ""Questions"": [
    ""What is the exact purpose of the BlackHole contract?"",
    ""How is the rectangleOfFairness parameter calculated and used in stabilizeFlan?"",
    ""Are there any specific security considerations for the external contract interactions?"",
    ""How is the DAO governance integrated into the contract, and what are the specific governance mechanisms?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in `buyFlanAndBurn` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `buyFlanAndBurn` function transfers tokens and then calls `swap` on a Uniswap pair. This sequence can be exploited in a reentrancy attack if the pair contract is malicious or compromised."",
      ""Impact"": ""An attacker could re-enter the function and manipulate the state or steal funds, leading to significant financial losses."",
      ""Location"": ""Function `buyFlanAndBurn` in `UniswapHelper` contract""
    },
    {
      ""Issue"": ""Uninitialized Storage Pointer"",
      ""Severity"": ""High"",
      ""Description"": ""The `UniVARS` struct is used without proper initialization in the `configure` function, leading to undefined behavior and potential security vulnerabilities."",
      ""Impact"": ""Undefined behavior, potential exploitation of uninitialized variables."",
      ""Location"": ""Function `configure` in `UniswapHelper` contract""
    },
    {
      ""Issue"": ""Unrestricted Minting of Flan Tokens"",
      ""Severity"": ""High"",
      ""Description"": ""The `stabilizeFlan` function allows for the minting of Flan tokens without proper validation or restrictions, which could lead to inflation of the token supply if exploited."",
      ""Impact"": ""Potential token inflation and devaluation of the Flan token."",
      ""Location"": ""Function `stabilizeFlan` in `UniswapHelper` contract""
    },
    {
      ""Issue"": ""Hardcoded Mainnet Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract hardcodes addresses for the Uniswap factory and DAI token specifically for the Ethereum mainnet. This reduces flexibility and can cause issues when deploying the contract on other networks or if the addresses change."",
      ""Impact"": ""Deployment on non-mainnet chains will fail or require manual adjustments, reducing flexibility and increasing maintenance overhead."",
      ""Location"": ""Constructor and `configure` function in `UniswapHelper` contract""
    },
    {
      ""Issue"": ""Lack of Input Validation in `configure` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `configure` function does not validate all input parameters, such as addresses for `FlanSCXPair`, `behodler`, and `flan`. This can lead to incorrect or malicious configurations."",
      ""Impact"": ""Invalid or malicious configurations can compromise the contract's functionality and security."",
      ""Location"": ""Function `configure` in `UniswapHelper` contract""
    },
    {
      ""Issue"": ""Insufficient Price Stability Check"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_ensurePriceStability` function checks for price divergence but does not account for extreme market conditions or rapid price changes. This can lead to incorrect assumptions about price stability."",
      ""Impact"": ""Incorrect assumptions about price stability can lead to financial losses or incorrect contract behavior."",
      ""Location"": ""Function `_ensurePriceStability` in `UniswapHelper` contract""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `getAmountOut` and `getAmountIn` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getAmountOut` and `getAmountIn` functions perform multiplication and division operations without checking for potential integer overflow. This can lead to incorrect output amounts."",
      ""Impact"": ""Incorrect output amounts can lead to financial losses or incorrect contract behavior."",
      ""Location"": ""Functions `getAmountOut` and `getAmountIn` in `UniswapHelper` contract""
    },
    {
      ""Issue"": ""Uninitialized Precision Variable"",
      ""Severity"": ""Low"",
      ""Description"": ""The precision variable in the `configure` function is set to 0 if the input precision is 0, but it does not handle other invalid values. This can lead to unintended behavior in calculations."",
      ""Impact"": ""Incorrect precision values can lead to inaccurate calculations and contract behavior."",
      ""Location"": ""Function `configure` in `UniswapHelper` contract""
    },
    {
      ""Issue"": ""Lack of Event Logging"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract does not emit events for critical state changes, such as configuration updates or token transfers. This reduces transparency and makes it harder to track contract activity."",
      ""Impact"": ""Reduced transparency and difficulty in tracking contract activity."",
      ""Location"": ""Various functions in `UniswapHelper` contract""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 9
}",431.5964939594269,69848.0,24.0,"### **[M-07] Calling `generateFLNQuote` twice in every block prevents any migration**

**Report Description**:  
The `generateFLNQuote` function in the `UniswapHelper` contract is public, allowing any user to generate the latest quote. If this function is called twice in the same block, both quotes will have the same `blockProduced` value. This behavior is problematic because the `_ensurePriceStability` function relies on these quotes to validate price stability. The last `require` statement in `_ensurePriceStability` checks for divergence between the latest quotes, but if both quotes are from the same block, the check will fail, preventing migrations.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of calling `generateFLNQuote` twice in the same block or its impact on migrations. This is a missed issue in the response list.

---

### **[M-11] You can grief migrations by sending SCX to the UniswapHelper**

**Report Description**:  
An attacker can prevent migrations by sending SCX tokens to the `UniswapHelper` contract. This attack is recoverable by calling `buyFlanAndBurn` with SCX as the input token to buy Flan and then rerunning the migration. However, the attack temporarily disrupts the migration process, causing inconvenience and potential delays.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of griefing migrations by sending SCX to the `UniswapHelper`. This is a missed issue in the response list.

---

### **[M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks**

**Report Description**:  
The `buyFlanAndBurn` function is vulnerable to sandwich attacks, where a malicious bot can manipulate the price of Flan before and after the function's execution. For example, if Flan is trading at 0.8 in input token terms, the bot can buy Flan, pushing the price to 0.9 before the function executes, and then sell it back afterward. This results in the input token being overspent, leading to direct financial losses for the system.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy in `buyFlanAndBurn` Function""**.

**Validation**:  
**Partially Correct**. The response identifies a security concern in the `buyFlanAndBurn` function but mischaracterizes it as a reentrancy issue rather than a sandwich attack. While both are valid concerns, the core issue of price manipulation via sandwich attacks is not addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks**

**Missed Issues from Issue Report**:  
- **[M-07] Calling `generateFLNQuote` twice in every block prevents any migration**  
- **[M-11] You can grief migrations by sending SCX to the UniswapHelper**

---

The response list fails to address two critical issues ([M-07] and [M-11]) and mischaracterizes the issue in [M-14]. Improvements are needed to ensure comprehensive coverage of the reported vulnerabilities.","```
None.
```",0.0
