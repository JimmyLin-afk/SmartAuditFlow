nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
SwappableYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";

/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.
/// @dev This contract adheres to the PoolTogether yield source interface.
/// @dev This contract inherits AssetManager which extends OwnableUpgradable.
/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.
contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /// @notice Emitted when the swappable yield source is initialized.
  /// @param yieldSource Address of yield source used to initialize this swappable yield source.
  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param owner Swappable yield source owner.
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  /// @notice Emitted when a yield source has been successfuly set.
  /// @param yieldSource Yield source address that was set.
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.
  /// @param yieldSource Yield source address that provided funds.
  /// @param amount Amount of funds transferred.
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.
  /// @param from Address that transferred funds.
  /// @param to Address that received funds.
  /// @param amount Amount of tokens transferred.
  /// @param token ERC20 token transferred.
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  /// @notice Yield source interface.
  IYieldSource public yieldSource;

  /// @notice Mock Initializer to initialize implementations used by minimal proxies.
  function freeze() public initializer {
    //no-op
  }

  /// @notice Hack to determine if address passed is an actual yield source.
  /// @dev If depositTokenAddressData.length is not superior to 0, then staticcall didn't return any data.
  /// @param _yieldSource Yield source address to check.
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  /// @notice Initializes the swappable yield source with the yieldSource address provided.
  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.
  /// @param _yieldSource Yield source address used to initialize this swappable yield source.
  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param _owner Swappable yield source owner.
  /// @return true if operation is successful.
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).
  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.
  /// @return true if operation is successful.
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.
  /// @param tokens Amount of tokens.
  /// @return Number of shares.
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      // rate = tokens / shares
      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  /// @notice Calculates the number of tokens a user has in the yield source.
  /// @param shares Amount of shares.
  /// @return Number of tokens.
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      // tokens = shares * (yieldSourceTotalSupply / totalShares)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  /// @notice Mint tokens to the user.
  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.
  /// @param mintAmount Amount of asset tokens to be minted.
  /// @param to User whose balance will receive the tokens.
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  /// @notice Burn shares from user's balance.
  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.
  /// @param burnAmount Amount of asset tokens to be burnt.
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).
  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).
  /// @dev Shares from the swappable yield source are minted to the `to` address.
  /// @param amount Amount of `depositToken()` to be supplied.
  /// @param to User whose balance will receive the tokens.
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return ERC20 asset token address.
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).
  /// @return Underlying balance of swappable tokens.
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  /// @notice Redeems tokens from the current yield source.
  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.
  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.
  /// @param amount Amount of `depositToken()` to withdraw.
  /// @return Actual amount of tokens that were redeemed.
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  /// @notice Determine if passed yield source is different from current yield source.
  /// @param _yieldSource Yield source address to check.
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  /// @notice Set new yield source.
  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).
  /// @param _newYieldSource New yield source address to set.
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  /// @notice Set new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param _newYieldSource New yield source address to set.
  /// @return true if operation is successful.
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amount` requested.
  /// @dev `currentBalance` can be superior to `amount` if yield has been accruing between redeeming and checking for a mathematical error.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param _amount Amount of funds to transfer from passed yield source to current yield source.
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We only verify it is a different yield source in the public function cause we already check for it in `_setYieldSource` function.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param amount Amount of funds to transfer from passed yield source to current yield source.
  /// @return true if operation is successful.
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  /// @notice Swap current yield source for new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.
  /// @param _newYieldSource New yield source address to set and transfer funds to.
  /// @return true if operation is successful.
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param erc20Token ERC20 token to transfer.
  /// @param to Recipient of the tokens.
  /// @param amount Amount of tokens to transfer.
  /// @return true if operation is successful.
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",3524,331,"[H-01] `onlyOwnerOrAssetManager` can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source
The function `swapYieldSource` SwappableYieldSource.sol` L307
Can be called by the owner (deployer / initializer) or Asset Manager. The function will take all funds from the old Yield Source, and transfer them to the new Yield source. Any contract that implement the function function depositToken() external returns (address) will pass the check
However, if either the owner or the `assetManager` have malicious intent, this function allows them to instantly rug all funds

 [H-02] redeemToken can fail for certain tokens
The `SwappableYieldSource.redeemToken` function transfers tokens from the contract back to the sender, however, it uses the `ERC20.transferFrom(address(this), msg.sender, redeemableBalance)` function for this. Some deposit token implementations might fail as transferFrom checks if the contract approved itself for the redeemableBalance instead of skipping the allowance check in case the sender is the from address.   [H-03] setYieldSource leads to temporary wrong results
The use of `setYieldSource` leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.
The function `balanceOfToken` will show the wrong results, because it is based on `_sharesToToken`, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.
More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls `_mintShares`, which calls `_tokenToShares`, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).
  [H-04] SwappableYieldSource: Missing same deposit token check in transferFunds() `transferFunds()` will transfer funds from a specified yield source _yieldSource to the current yield source set in the contract _currentYieldSource. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.
  [M-01] Single-step process for critical ownership transfer/renounce is risky The `SwappableYieldSource` allows owners and asset managers to set/swap/transfer yield sources/funds. As such, the contract ownership plays a critical role in the protocol.
Given that `AssetManager` is derived from `Ownable`, the ownership management of this contract defaults to `Ownable`’s `transferOwnership()` and `renounceOwnership()` methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.   [M-02] Use of `safeApprove` will always cause `approveMax` to revert
Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as (1) Deprecated because of approve-like race condition and (2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.
The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0. See issue page for referenced code.
 
[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens
The `supplyTokenTo` function of SwappableYieldSource assumes that amount of _depositToken is transferred to itself after calling the safeTransferFrom function (and thus it supplies amount of token to the yield source). However, this may not be true if the _depositToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. SwappableYieldSource.sol L211-L212   [M-04] Old yield source still has infinite approval After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).",8,"pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";





contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  
  
  
  
  
  
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  
  
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  
  
  
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  
  
  
  
  
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  
  IYieldSource public yieldSource;

  
  function freeze() public initializer {
    
  }

  
  
  
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  
  
  
  
  
  
  
  
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  
  
  
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  
  
  
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  
  
  
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  
  
  
  
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  
  
  
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  
  
  
  
  
  
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  
  
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  
  
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  
  
  
  
  
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  
  
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  
  
  
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  
  
  
  
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  
  
  
  
  
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  
  
  
  
  
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  
  
  
  
  
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  
  
  
  
  
  
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",1938,4,4,"This Solidity smart contract (`SwappableYieldSource`) has a number of potential vulnerabilities and issues that may lead to security risks or unexpected behavior. Here's a list of the identified vulnerabilities:

---

### 1. **Unchecked Initialization (Upgradeable Contract Risk)**
   - The `initialize` function does not use a re-entrancy guard or check for prior initialization. While it uses `initializer`, if somehow the `_requireYieldSource` or other logic fails, it might still leave the contract in a vulnerable state.
   - The `freeze` function is included but does nothing, implying improper use or lack of implementation to properly manage contract initialization or upgrades.

---

### 2. **Improper Yield Source Validation**
   - `_requireYieldSource` uses a static call to check the `depositToken` function of the `_yieldSource`. However:
     - If the `depositToken` function isn't implemented properly, the validation logic may behave unexpectedly.
     - The check for `isInvalidYieldSource` is unclear; while it decodes `depositTokenAddressData`, it appears to function contrary to validating the `yieldSource`, as it enforces `depositTokenAddress != address(0)` to ensure validity but negates the result. This could lead to bypassing validation.

---

### 3. **Reentrancy Risks**
   - While the contract uses `ReentrancyGuardUpgradeable` in some key functions (e.g., `supplyTokenTo` and `redeemToken`), other critical areas such as `_transferFunds`, `_setYieldSource`, and related internal operations do not implement a re-entrancy guard.
   - Specifically, the `swapYieldSource` and `transferFunds` functions interact with external `_newYieldSource` contracts without sufficient safety measures.

---

### 4. **Approval Race Condition**
   - The `approveMaxAmount` and other approval-related logic may face a race condition issue with ERC-20 tokens due to the well-known `approve` attack pattern. While SafeERC20Upgradeable mitigates most risks, repeated `safeApprove`/`safeIncreaseAllowance` operations could still be problematic if allowance is modified concurrently.

---

### 5. **Unhandled Return Values**
   - Functions like `_requireYieldSource` and `_sharesToToken` operate on external calls and calculations but do not adequately validate return values (e.g., `staticcall` result in `_requireYieldSource`).
   - `_transferFunds` assumes `_yieldSource.redeemToken(_amount)` operates successfully but does not handle failure cases, and also assumes `_amount` matches the current balance without retry logic.

---

### 6. **Vulnerable Transfer Functions**
   - `transferERC20` allows privileged users (`onlyOwnerOrAssetManager`) to transfer arbitrary ERC-20 tokens stored in the contract except for the deposit token. This could result in a malicious actor exploiting privileges or mistakes (e.g., transferring critical tokens needed for yield).

---

### 7. **No Enforcement of Token Balance Integrity**
   - The `_tokenToShares` and `_sharesToToken` calculations rely on `FixedPoint` math, assuming that the `totalSupply` of shares aligns exactly with the token balances in the contract. However:
     - If discrepancies occur (e.g., due to `transferERC20` misuse or external token interactions), these calculations may break.
   - There's also no mechanism to reconcile or audit balances to detect such discrepancies.

---

### 8. **Broken `_tokenToShares` and `_sharesToToken` Logic**
   - These functions rely on `FixedPoint.calculateMantissa` and `FixedPoint.multiplyUintByMantissa`. However:
     - If `balanceOfToken(address(this))` is zero (e.g., no yield exists), division by zero or incorrect calculations may occur.
     - The logic assumes `totalSupply` and `balanceOfToken` are perfectly proportional, which might not hold true in deployed environments.

---

### 9. **Privileges and Centralization Risk**
   - The use of `onlyOwner` and `onlyOwnerOrAssetManager` gives a centralized entity or role control over critical operations, such as swapping yield sources and transferring funds. This creates significant centralization risks:
     - A malicious or compromised owner can change the yield source to a malicious contract, draining user funds.
     - Privileged roles can approve and transfer tokens arbitrarily.

---

### 10. **Potential Denial of Service (DoS) via `swapYieldSource`**
   - The `swapYieldSource` function assumes that the `_currentYieldSource.redeemToken` and `_newYieldSource.supplyTokenTo` operations always succeed. If any operation reverts (e.g., due to gas limits, external errors, or frozen tokens), it locks the contract into an unusable state.

---

### 11. **Upgradeability Risks**
   - The `__Ownable_init`, `__ReentrancyGuard_init`, and `__ERC20_init` calls are used during initialization. However:
     - No upgradeability checks or mechanisms are implemented to prevent future upgrades from introducing vulnerabilities or wiping state.
   - Since the proxy upgrade pattern is intended, the contract's logic can be freely replaced by an owner or privileged actor.

---

### 12. **Lack of Emergency Functions**
   - There's no mechanism to ""pause"" or ""freeze"" contract functionality in case of emergency (e.g., a `CircuitBreaker` pattern).
   - The `freeze` function exists but lacks implementation.

---

### 13. **Duplicate Deposit Token Validation during Yield Source Swap**
   - The `_setYieldSource` function ensures that the `depositToken` of the old and new yield source must match. While this is a safeguard, there's no mechanism to ensure that both yield sources independently handle tokens safely or do not misuse them.

---

### 14. **Compatibility Issues with Nonstandard ERC-20s**
   - The contract assumes all ERC-20 tokens strictly adhere to the ERC-20 standard. Tokens with nonstandard behaviors (e.g., no `return` value from transfer/approve functions) may break the contract's logic.

---

### 15. **Limited Decimals Validation**
   - The `initialize` function enforces `require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"")`, but does not validate or restrict decimal overflows or extreme values.

---

### 16. **Unverified Safety of `yieldSource` Entrypoints**
   - Functions like `redeemToken` and `supplyTokenTo` interact directly with `yieldSource`. The safety of the contracts implementing `IYieldSource` is assumed, but unchecked interactions may lead to undefined behavior.

---

In summary, this contract requires significant improvements in terms of input validation, privilege decentralization, safety mechanisms (e.g., re-entrancy protection), and internal consistency to prevent vulnerabilities. Proper auditing and rigorous testing should address these issues before deploying this contract.","### **[H-01] `onlyOwnerOrAssetManager` can swap Yield Source in `SwappableYieldSource` at any time, immediately rugging all funds from old yield source**

**Report Description**:
The function `swapYieldSource` in `SwappableYieldSource.sol` can be called by the owner (deployer/initializer) or the Asset Manager. The function allows for the transfer of all funds from the old Yield Source to a new Yield Source. If either the owner or the Asset Manager has malicious intent, they can exploit this function to ""rug"" all funds.

**Match in Response List**:
Matches with the issue titled **""Privileges and Centralization Risk""**.

**Validation**:
**Partially correct**. The response identifies the centralized risk where privileged users (owner/asset manager) could misuse their authority to drain funds. It rightly highlights the danger of allowing unrestricted control over yield sources and funds. However, it doesn't explicitly address the specific exploitability of `swapYieldSource` in the report. The issue report highlights that this function could immediately transfer all funds to a new malicious yield source, but the response is more general, discussing centralization risks without detailing the specific misuse of `swapYieldSource`. 

**Suggestions**:
The response could be more specific about the `swapYieldSource` function and the direct impact of privileged control over this function, suggesting more granular access control or multi-signature requirements to prevent abuse.

---

### **[H-02] `redeemToken` can fail for certain tokens**

**Report Description**:
The `redeemToken` function in `SwappableYieldSource.sol` uses `ERC20.transferFrom(address(this), msg.sender, redeemableBalance)`. For some tokens, this call may fail if the token implementation requires that the contract approves itself for the transfer, rather than allowing the sender to do so.

**Match in Response List**:
Matches with the issue titled **""Vulnerable Transfer Functions""**.

**Validation**:
**Partially correct**. The response mentions a broader issue with the `transferERC20` function, which allows privileged users to transfer arbitrary tokens. While it doesn't directly address the `redeemToken` issue with `transferFrom`, it does correctly note potential risks in the broader context of transfers. However, the response doesn't specifically mention the issue of token-specific failures in `redeemToken`, such as those caused by allowance mechanisms or specific token behaviors.

**Suggestions**:
The response could be improved by explicitly discussing the failure modes of `transferFrom` with certain ERC20 token implementations. It should advise checking for token-specific behaviors (like allowance requirements) and suggest adding handling logic for failed transfers.

---

### **[H-03] `setYieldSource` leads to temporary wrong results**

**Report Description**:
The use of `setYieldSource` changes the underlying yield source but leaves the contract in an inconsistent state, as the underlying balances are not yet transferred, while the shares remain unchanged. This causes the `balanceOfToken` function to show incorrect results due to reliance on outdated yield source information.

**Match in Response List**:
Matches with the issue titled **""Broken `_tokenToShares` and `_sharesToToken` Logic""**.

**Validation**:
**Correct**. The response highlights a logical issue with the `_tokenToShares` and `_sharesToToken` functions, which could break if the yield source is changed without properly transferring the underlying assets. The concern about balance discrepancies and incorrect calculations aligns well with the issue described in the report. However, the response focuses more on the technical math side rather than directly addressing the problem of temporary inconsistency introduced by `setYieldSource`.

**Suggestions**:
A suggestion to mitigate this issue would be to introduce a state flag that ensures balances are updated before or after the yield source change to prevent incorrect results in functions like `balanceOfToken`.

---

### **[H-04] Missing same deposit token check in `transferFunds()`**

**Report Description**:
The `transferFunds` function in `SwappableYieldSource` does not check if the deposit tokens are the same before transferring funds from a specified yield source to the current yield source. If the specified yield source's assets are of a higher valuation, the malicious owner or asset manager can exploit this difference.

**Match in Response List**:
No match found.

**Validation**:
**No match**. The response does not directly address this issue, which involves missing validation to ensure that the deposit tokens being transferred between yield sources are the same. This is an important logical flaw that could lead to malicious exploitation by privileged users.

**Suggestions**:
The response should specifically mention the need for validation to ensure that the deposit tokens involved in the transfer are identical, or provide suggestions for adding token comparison checks to prevent this kind of exploit.

---

### **[M-01] Single-step process for critical ownership transfer/renounce is risky**

**Report Description**:
The contract's ownership management, derived from `Ownable`, allows critical functions like ownership transfer and renouncement in a single step, which can be risky and irreversible if a mistake is made.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Risks""**.

**Validation**:
**Incorrect match**. The response discusses reentrancy risks, which is not directly related to the ownership transfer issue. While reentrancy is a concern in contracts with external calls, this specific issue is about ownership transfer and renouncement risks, which require a different response.

**Suggestions**:
The response should directly address the risks related to ownership management, suggesting alternatives like multi-signature mechanisms or time-locked ownership transfers to reduce the risk of irreversible actions.

---

### **[M-02] Use of `safeApprove` will always cause `approveMax` to revert**

**Report Description**:
The issue notes that `safeApprove` is used in `mStableYieldSource` and causes reverts when used to increase allowances beyond the initial setting of 0, which conflicts with the intended behavior of increasing the allowance.

**Match in Response List**:
Matches with the issue titled **""Approval Race Condition""**.

**Validation**:
**Correct**. The response accurately identifies the issue with `safeApprove` and the associated race condition with ERC-20 token approvals. The response highlights the inappropriate use of `safeApprove` for increasing allowances, which aligns well with the problem described in the report.

**Suggestions**:
The response is adequate but could further clarify that switching to `safeIncreaseAllowance` would resolve this issue and prevent the revert from occurring.

---

### **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**

**Report Description**:
The `supplyTokenTo` function assumes that the full amount of the deposit token is transferred after calling `safeTransferFrom`. However, if the token is a transfer-on-fee or deflationary token, the actual received amount might be less than expected, leading to inconsistencies.

**Match in Response List**:
No match found.

**Validation**:
**No match**. The response does not address the specific issue of handling transfer-on-fee or deflationary tokens, which could result in incorrect balances during token supply operations.

**Suggestions**:
The response should suggest adding checks to verify the actual amount transferred, possibly using events or a balance snapshot before and after the transfer to ensure consistency.

---

### **[M-04] Old yield source still has infinite approval**

**Report Description**:
After swapping a yield source, the old yield source still retains infinite approval, which can be exploited if the old yield source isn't secure.

**Match in Response List**:
No match found.

**Validation**:
**No match**. The response does not mention the issue of leaving infinite approval on the old yield source, which could allow malicious actors to exploit it even after a swap has occurred.

**Suggestions**:
The response should include a suggestion to reset or revoke approvals on the old yield source after a swap to avoid potential security risks.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**:

**[R-13] Lack of Emergency Functions**

**Response Description**:
The response suggests that there are no mechanisms to ""pause"" or ""freeze"" contract functionality in case of an emergency, and recommends implementing a `CircuitBreaker` pattern.

**Assessment**:
**Valid Concern**. While this issue was not explicitly mentioned in the report, incorporating emergency stop mechanisms like a circuit breaker is a recognized best practice in Solidity to mitigate the damage during an attack or malfunction. This suggestion is valid and should be considered to enhance the security of the contract.

**Recommendations**:
The contract should implement a `CircuitBreaker` or `pause` functionality that can be triggered by an authorized address to temporarily halt critical operations in the event of an emergency.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] redeemToken can fail for certain tokens** - Partially addressed by ""Vulnerable Transfer Functions.""
- **[M-02] Use of `safeApprove` will always cause `approveMax` to revert** - Correctly addressed by ""Approval Race Condition.""

**Partially Correct Matches**:

- **[H-01] `onlyOwnerOrAssetManager` can swap Yield Source** - Partially addressed by ""Privileges and Centralization Risk.""
- **[H-03] `setYieldSource` leads to temporary wrong results** - Partially addressed by ""Broken `_tokenToShares` and `_sharesToToken` Logic.""
- **[M-01] Single-step process for critical ownership transfer/renounce is risky** - Incorrectly matched to ""Reentrancy Risks.""

**Missed Issues from Issue Report**:

- **[H-04] Missing same deposit token check in `transferFunds()`**
- **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**
- **[M-04] Old

 yield source still has infinite approval**

**GPT-Generated Potential Issues (May Be Incorrect)**:

- **[R-13] Lack of Emergency Functions** - A valid suggestion not identified in the original issue report.
",2,3,3,16,"```
1. Broken `_tokenToShares` and `_sharesToToken` Logic
2. Approval Race Condition
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Broken `_tokenToShares` and `_sharesToToken` Logic"" appears at rank **8**.
   - ""Approval Race Condition"" appears at rank **4**.

2. **Calculate the precision at each rank**:
   - For rank 4: \( P@4 = \frac{1}{4} = 0.25 \)
   - For rank 8: \( P@8 = \frac{2}{8} = 0.25 \)

3. **Average the precision values**:
   - \( AP = \frac{0.25 + 0.25}{2} = 0.25 \)

**Output**:
```
0.25
```"
