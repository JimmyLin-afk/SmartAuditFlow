nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP,APs
RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {
    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public orderbook;
    /// @dev nfthub instance, to query current card owner
    IRCNftHubL2 public nfthub;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev address of the Factory so only the Factory can add new markets
    address public override factoryAddress;
    /// @dev so only markets can use certain functions
    mapping(address => bool) public override isMarket;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public marketBalance;
    /// @dev a quick check if a uesr is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 marketBalanceDiscrepancy;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent any cards for specific market
    mapping(address => bool) public override marketPaused;

    /*╔═════════════════════════════════╗
      ║            UBER OWNER           ║
      ╚═════════════════════════════════╝*/
    /// @dev high level owner who can change the factory address
    address public override uberOwner;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        // at initiation, uberOwner and owner will be the same
        uberOwner = msgSender();

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1000000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /// @notice only allow markets to call these functions
    modifier onlyMarkets {
        require(isMarket[msgSender()], ""Not authorised"");
        _;
    }

    /// @notice only allow orderbook to call these functions
    modifier onlyOrderbook {
        require(msgSender() == address(orderbook), ""Not authorised"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║           ADD MARKETS           ║
      ╚═════════════════════════════════╝*/

    /// @dev so only markets can move funds from deposits to marketPots and vice versa
    function addMarket(address _newMarket) external override {
        require(msgSender() == factoryAddress, ""Not factory"");
        isMarket[_newMarket] = true;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyOwner
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUTOR - PUBLIC  │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyOwner
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyOwner {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental for a specific market
    function changePauseMarket(address _market) external override onlyOwner {
        require(isMarket[_market], ""This isn't a market"");
        marketPaused[_market] = !marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyOwner {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add a user to the whitelist
    function addToWhitelist(address _user) public override {
        IRCFactory factory = IRCFactory(factoryAddress);
        require(factory.isGovernor(msgSender()), ""Not authorised"");
        isAllowed[_user] = !isAllowed[_user];
    }

    /// @notice Add multiple users to the whitelist
    function batchAddToWhitelist(address[] calldata _users) public override {
        for (uint256 index = 0; index < _users.length; index++) {
            addToWhitelist(_users[index]);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governanace functions

    function setFactoryAddress(address _newFactory) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newFactory != address(0), ""Must set an address"");
        factoryAddress = _newFactory;
    }

    function setOrderbookAddress(address _newOrderbook) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newOrderbook != address(0), ""Must set an address"");
        orderbook = IRCOrderbook(_newOrderbook);
    }

    function setNftHubAddress(address _NFTHubAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_NFTHubAddress != address(0), ""Must set an address"");
        nfthub = IRCNftHubL2(_NFTHubAddress);
    }

    function setTokenAddress(address _newToken) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    function changeUberOwner(address _newUberOwner) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0), ""Must set an address"");
        uberOwner = _newUberOwner;
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract (newRental) or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        public
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(isAllowed[msgSender()], ""Not in whitelist"");
        }
        erc20.transferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        if (
            (user[_user].deposit + _amount) >
            (user[_user].bidRate / minRentalDayDivisor)
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // stpe 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount) external override {
        erc20.transferFrom(msgSender(), address(this), _amount);
        if (_amount > marketBalanceDiscrepancy) {
            marketBalanceDiscrepancy = 0;
        } else {
            marketBalanceDiscrepancy -= _amount;
        }
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            marketBalanceDiscrepancy += _amount - marketBalance;
            _amount -= (_amount - marketBalance);
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;

        return true;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        assert(marketPot[msgSender()] >= _amount);
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        onlyMarkets
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        if (
            isForeclosed[_user] &&
            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.transferFrom(_sponsor, address(this), _amount);
        marketPot[msgSender()] += _amount;
        totalMarketPots += _amount;
        return true;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyMarkets
        returns (bool)
    {
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        if (user[_user].lastRentCalc == 0) {
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
        return true;
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    /// @notice provides the sum total of a users bids accross all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyOrderbook {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !isMarket[_newOwner]
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed =
                    rentOwedBetweenTimestmaps(
                        block.timestamp,
                        _timeOwnershipChanged,
                        _newPrice
                    );
                collectRentUser(_newOwner, block.timestamp);

                // they have enough funds, just collect the extra
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /// @dev called when all a user's bids have been removed, disables foreclosure state
    function resetUser(address _user) external override onlyOrderbook {
        isForeclosed[_user] = false;
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calcualtion and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calcualtes the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestmaps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the amount of deposit a user is able to withdraw
    /// @notice ..after considering rent due to be paid
    /// @param _user the user to query
    function depositAbleToWithdraw(address _user)
        internal
        view
        returns (uint256)
    {
        uint256 collection = rentOwedUser(_user, block.timestamp);
        if (collection >= user[_user].deposit) {
            return 0;
        } else {
            return uint256(user[_user].deposit) - (collection);
        }
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)
            //                   = (deposit * 1day) / totalUserDailyRent
            uint256 timeLeftOfDeposit =
                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard =
                user[_user].lastRentCalc + timeLeftOfDeposit;

            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {
                // calculate how long they can own the new card for
                uint256 _rentAlreadyOwed =
                    rentOwedBetweenTimestmaps(
                        user[_user].lastRentCalc,
                        _timeOfNewBid,
                        totalUserDailyRent
                    );
                uint256 _depositAtTimeOfNewBid =
                    user[_user].deposit - _rentAlreadyOwed;
                uint256 _timeLeftOfDepositWithNewBid =
                    (_depositAtTimeOfNewBid * 1 days) /
                        (totalUserDailyRent + _newBid);
                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            // if no rentals they'll foreclose after the heat death of the universe
            return type(uint256).max;
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        assert(_timeToCollectTo != 0);
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts =
                    ((_timeToCollectTo - previousCollectionTime) *
                        uint256(user[_user].deposit)) / rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepsitLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets availiable balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",7143.0,761.0,"[H-01] Unchecked ERC20 transfers can cause lock up
Some major tokens went live before ERC20 was finalized, resulting in a discrepancy whether the transfer functions should (A) return a boolean or (B) revert/fail on error. The current best practice is that they should revert, but return “true” on success. However, not every token claiming ERC20-compatibility is doing this — some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.
  [H-04] Anyone can affect deposits of any user and turn the owner of the token
On RCTreasury, we have the method `collectRentUser`. This method is public, so anyone can call it using whatever user and whatever timestamp. So, calling this method using user = XXXXX and _timeToCollectTo = type(uint256).max), would make isForeclosed[user] = true.
  [M-01] payout doesn't fix isForeclosed state
The function `payout` of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.

 [M-02] Critical uberOwner address changes should be a two-step process
As specified, `uberOwners` of Factory, Orderbook and Treasury have the highest privileges in the system because they can upgrade contracts of market, Nfthub, order book, treasury, token and factory which form the critical components of the protocol.
The contracts allow for `uberOwners` to be changed to a different address from the contract owner/deployer using the changeUberOwner() function which is callable by the current uberOwner. While this function checks for zero-address, there is no validation of the new address being correct. If the current uberOwner incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the uberOwner cannot be corrected and none of the other functions that require uberOwner caller can be executed.
  [M-03] Missing balancedBooks modifier could result in failed system insolvency detection
The `balancedBooks` modifier is used to “check that funds haven't gone missing during this function call” and is applied to deposit, withdrawDeposit, payRent, payout and sponsor Treasury functions which move funds in and out of the Treasury or adjust its market/user balances.
However, this modifier is missing in the `refundUser()` and topupMarketBalance() functions which also perform similar actions. The impact is that any miscalculations in these functions will lead to the system becoming insolvent.
  [M-16] Deposits can be denied by abusing maxContractBalance
A whale can stop anyone from depositing by front-running a user's deposit with a deposit that pushes the contract balance to the maxContractBalance limit first. The user's deposit will then fail in the check. Afterwards, the whale can withdraw again.
Any users can be blocked from depositing which prevents them from renting cards. This allows an attacker to manipulate the outcome of a market in their favor by strategically preventing other competitors to bid on their cards (causing forfeiture due to a low deposit balance).   [M-17] Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected
The function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.
The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable timeLeftOfDeposit indicates the time left of deposit, starting from now. However, at line 672, the foreclosureTimeWithoutNewCard is calculated by timeLeftOfDeposit plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.",8.0,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";


contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {
    
    
    IRCOrderbook public orderbook;
    
    IRCNftHubL2 public nfthub;
    
    IERC20 public override erc20;
    
    address public override bridgeAddress;
    
    address public override factoryAddress;
    
    mapping(address => bool) public override isMarket;
    
    uint256 public override totalDeposits;
    
    mapping(address => uint256) public override marketPot;
    
    uint256 public override totalMarketPots;
    
    uint256 public marketBalance;
    
    mapping(address => bool) public override isForeclosed;
    
    uint256 marketBalanceDiscrepancy;
   
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    uint256 public override minRentalDayDivisor;
    
    uint256 public override maxContractBalance;
    
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;


    bool public override globalPause;
    
    mapping(address => bool) public override marketPaused;


    address public override uberOwner;

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);

    

    constructor(address _tokenAddress) {
        
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        
        uberOwner = msgSender();

        
        setMinRental(24 * 6); 
        setMaxContractBalance(1000000 ether); 
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    

    
    modifier balancedBooks {
        _;
        
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    
    modifier onlyMarkets {
        require(isMarket[msgSender()], ""Not authorised"");
        _;
    }

    
    modifier onlyOrderbook {
        require(msgSender() == address(orderbook), ""Not authorised"");
        _;
    }

    

    
    function addMarket(address _newMarket) external override {
        require(msgSender() == factoryAddress, ""Not factory"");
        isMarket[_newMarket] = true;
    }

    

    
    

    

    
    
    function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

    
    
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyOwner
    {
        maxContractBalance = _newBalanceLimit;
    }

    

    
    function changeGlobalPause() external override onlyOwner {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    
    function changePauseMarket(address _market) external override onlyOwner {
        require(isMarket[_market], ""This isn't a market"");
        marketPaused[_market] = !marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    

    
    function toggleWhitelist() external override onlyOwner {
        whitelistEnabled = !whitelistEnabled;
    }

    
    function addToWhitelist(address _user) public override {
        IRCFactory factory = IRCFactory(factoryAddress);
        require(factory.isGovernor(msgSender()), ""Not authorised"");
        isAllowed[_user] = !isAllowed[_user];
    }

    
    function batchAddToWhitelist(address[] calldata _users) public override {
        for (uint256 index = 0; index < _users.length; index++) {
            addToWhitelist(_users[index]);
        }
    }

    
    
    
    
    

    function setFactoryAddress(address _newFactory) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newFactory != address(0), ""Must set an address"");
        factoryAddress = _newFactory;
    }

    function setOrderbookAddress(address _newOrderbook) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newOrderbook != address(0), ""Must set an address"");
        orderbook = IRCOrderbook(_newOrderbook);
    }

    function setNftHubAddress(address _NFTHubAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_NFTHubAddress != address(0), ""Must set an address"");
        nfthub = IRCNftHubL2(_NFTHubAddress);
    }

    function setTokenAddress(address _newToken) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    function changeUberOwner(address _newUberOwner) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0), ""Must set an address"");
        uberOwner = _newUberOwner;
    }

    

    
    
    
    
    
    function deposit(uint256 _amount, address _user)
        public
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(isAllowed[msgSender()], ""Not in whitelist"");
        }
        erc20.transferFrom(msgSender(), address(this), _amount);

        
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        
        if (
            (user[_user].deposit + _amount) >
            (user[_user].bidRate / minRentalDayDivisor)
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
        return true;
    }

    
    
    
    
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        
        
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        
        collectRentUser(_msgSender, block.timestamp);

        
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }

    
    
    function topupMarketBalance(uint256 _amount) external override {
        erc20.transferFrom(msgSender(), address(this), _amount);
        if (_amount > marketBalanceDiscrepancy) {
            marketBalanceDiscrepancy = 0;
        } else {
            marketBalanceDiscrepancy -= _amount;
        }
        marketBalance += _amount;
    }

    

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    
    

    
    
    
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            marketBalanceDiscrepancy += _amount - marketBalance;
            _amount -= (_amount - marketBalance);
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;

        return true;
    }

    
    
    
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        assert(marketPot[msgSender()] >= _amount);
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    
    function refundUser(address _user, uint256 _refund)
        external
        override
        onlyMarkets
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        if (
            isForeclosed[_user] &&
            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
    }

    
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.transferFrom(_sponsor, address(this), _amount);
        marketPot[msgSender()] += _amount;
        totalMarketPots += _amount;
        return true;
    }

    
    
    
    function updateLastRentalTime(address _user)
        external
        override
        onlyMarkets
        returns (bool)
    {
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        if (user[_user].lastRentCalc == 0) {
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
        return true;
    }

    

    
    
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    
    
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    

    
    
    
    
    
    
    
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyOrderbook {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !isMarket[_newOwner]
        ) {
            
            
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                

                uint256 _additionalRentOwed =
                    rentOwedBetweenTimestmaps(
                        block.timestamp,
                        _timeOwnershipChanged,
                        _newPrice
                    );
                collectRentUser(_newOwner, block.timestamp);

                
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
            } else {
                
                if (user[_newOwner].rentalRate != 0) {
                    
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                }
            }
        }
        
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    
    function resetUser(address _user) external override onlyOrderbook {
        isForeclosed[_user] = false;
    }

    

    
    
    
    
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    
    
    
    
    
    
    function rentOwedBetweenTimestmaps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    
    
    
    function depositAbleToWithdraw(address _user)
        internal
        view
        returns (uint256)
    {
        uint256 collection = rentOwedUser(_user, block.timestamp);
        if (collection >= user[_user].deposit) {
            return 0;
        } else {
            return uint256(user[_user].deposit) - (collection);
        }
    }

    
    
    
    
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            
            
            uint256 timeLeftOfDeposit =
                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard =
                user[_user].lastRentCalc + timeLeftOfDeposit;

            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {
                
                uint256 _rentAlreadyOwed =
                    rentOwedBetweenTimestmaps(
                        user[_user].lastRentCalc,
                        _timeOfNewBid,
                        totalUserDailyRent
                    );
                uint256 _depositAtTimeOfNewBid =
                    user[_user].deposit - _rentAlreadyOwed;
                uint256 _timeLeftOfDepositWithNewBid =
                    (_depositAtTimeOfNewBid * 1 days) /
                        (totalUserDailyRent + _newBid);
                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            
            return type(uint256).max;
        }
    }

    
    
    
    
    
    
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        assert(_timeToCollectTo != 0);
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                
                uint256 timeUsersDepositLasts =
                    ((_timeToCollectTo - previousCollectionTime) *
                        uint256(user[_user].deposit)) / rentOwedByUser;
                
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }
    
}",4101.0,2,5,"The Solidity smart contract provided has several potential **vulnerabilities** and **risks** that require careful consideration during audits. Below is a list of identified vulnerabilities and weaknesses:

---

### 1. **Insufficient Access Control**
   - **Issue:**
     - The contract uses `onlyOwner`, and `onlyMarkets`, and overly relies on `msgSender()` for access control, but access control boundaries are not well-defined in some functions.
     - Example: The `addToWhitelist()` function allows governors (verified through other contracts) to toggle whitelist access for addresses. Such delegation may lead to unintended consequences or abuses.
     - The constructor designates `uberOwner`, but the control over core functionality (e.g., `factoryAddress` and `bridgeAddress`) might not be adequately monitored.
   - **Impact:** Unauthorized access or privilege escalation.

---

### 2. **Hardcoded Values**
   - **Issue:**
     - Hardcoding values like `setMinRental(24 * 6)` and `setMaxContractBalance(1000000 ether)` leads to inflexibility and assumptions that may not scale with the system.
   - **Impact:** Any change in requirements or tokenomics would require redeployment or additional handling logic.

---

### 3. **Approval Race Condition**
   - **Issue:**
     - ERC20 `approve()` calls are susceptible to race conditions (e.g., in `setBridgeAddress()` and other ERC20-related functions).
     - Function examples: 
       - `erc20.approve(_newBridge, type(uint256).max)` risks exploitation since unlimited allowances are inherently unsafe.
       - `erc20.transferFrom()` assumes proper allowance, but allowance could be exploited in overlapping executions.
   - **Impact:** Reentrancy or loss of tokens due to malicious actor increasing/decreasing allowances.

---

### 4. **Global Pause Risks**
   - **Issue:**
     - `globalPause` and `marketPaused` rely entirely on `onlyOwner`, which could centralize control or result in misuse or mismanagement.
     - There is no mechanism to introduce decentralized governance to control such operations.
   - **Impact:** Unexpected global disruptions or governance risks.

---

### 5. **Logic Errors in `rentOwedUser` and `collectRentUser`**
   - **Issue:**
     - The logic around rent calculations (`rentOwedUser`) involves potential overflows due to time differences (`_timeToCollectTo - user[_user].lastRentCalc`).
     - In `collectRentUser`, if `rentOwedByUser > user[_user].deposit`, assumptions concerning `_increaseMarketBalance()` may create leftover state inconsistencies.
   - **Impact:** Incorrect rent calculations or potential underflows/overflows.

---

### 6. **Foreclosure Logic Flaw**
   - **Issue:**
     - The foreclosure time in `foreclosureTimeUser()` may allow users to exploit deposit/rental-rate discrepancies (i.e., deposit manipulation could delay foreclosure).
   - **Impact:** Users can manipulate their deposits or bids to delay or avoid foreclosure.

---

### 7. **ERC20 Dependencies Without Validation**
   - **Issue:**
     - There is no guarantee that `erc20` implements standard ERC20 functionality (e.g., it could be a malicious or erroneously implemented token).
     - The reliance on `erc20.transferFrom` and `erc20.transfer` does not verify the return value.
     - Function examples:
       - `deposit()`
       - `withdrawDeposit()`
       - `sponsor()`
   - **Impact:** Token misbehavior leading to loss of funds or contract malfunction.

---

### 8. **Reentrancy Risks**
   - **Issue:**
     - While the contract does not directly perform external contract calls in state-changing logic, certain functions like `withdrawDeposit()` and `payRent()` rely on token transfers that are vulnerable if the `erc20` uses non-standard behavior or external logic in `transfer()` (e.g., malicious tokens).
   - **Impact:** Reentrancy leading to malicious manipulation of contract state.

---

### 9. **Lack of Input Validation**
   - **Issue:**
     - Functions like `deposit()`, `withdrawDeposit()`, `addMarket()`, and `setXAddress()` do not impose strict input validations (e.g., non-zero amounts, proper address checks, etc.).
     - Example: `setFactoryAddress`, `setTokenAddress`, and `setBridgeAddress` allow setting of arbitrary addresses without ensuring contract validity.
   - **Impact:** Input of invalid or malicious data leading to unexpected behavior.

---

### 10. **Ambiguity in Whitelist Management**
   - **Issue:**
     - The `toggleWhitelist` and `batchAddToWhitelist` functions do not clearly delineate how whitelist management should interact with existing settings.
     - Potential coordination issues may occur if different governors try to modify the whitelist simultaneously.
   - **Impact:** Compromised functionality and security risks.

---

### 11. **Lack of Event Emission on Critical Changes**
   - **Issue:**
     - Functions like `setTokenAddress`, `setBridgeAddress`, and `changeUberOwner` make critical changes but do not emit events.
   - **Impact:** Reduced transparency and difficulty in auditing actions.

---

### 12. **Unused Storage Variables**
   - **Issue:**
     - `marketBalanceDiscrepancy` is managed in `payRent()` and `topupMarketBalance()` but may not be effectively used, creating confusion about its purpose.
   - **Impact:** Storage inefficiency and potential vulnerability if poorly understood.

---

### 13. **Potential Overflows/Underflows with SafeCast Misuse**
   - **Issue:**
     - While the contract uses `SafeCast`, there is no validation for whether casting operations are safe in user-specific scenarios (e.g., in `deposit()` or `withdrawDeposit()`).
     - Certain calculations with `SafeCast.toUint128()` might truncate values, leading to incorrect state updates.
   - **Impact:** Incorrect deposits, withdrawals, or other user-associated data manipulations.

---

### 14. **Centralization Risks in `uberOwner`**
   - **Issue:**
     - The `uberOwner` address wields significant control and has access to critical functions (e.g., `setFactoryAddress()`).
     - A compromised or malicious uberOwner could compromise the protocol.
   - **Impact:** Trust assumptions in the protocol are centralized, introducing single points of failure.

---

### 15. **Dependency on External Contracts**
   - **Issue:**
     - Contracts like `IRCFactory`, `IRCBridge`, and `IRCOrderbook` are extensively integrated, but their implementation details are unknown.
   - **Impact:** Malicious contract interactions or unexpected incompatibility.

---

### 16. **Unhandled Edge Cases**
   - **Examples:**
     - Large or unexpected token amounts (`uint256`) that cannot be cast to `uint128` without truncation.
     - Rent calculations assuming positive time deltas (e.g., incorrect timestamps or rewinding system time).
     - Paused markets might result in unclaimed rents or deposits stuck in undefined states.

---

### Recommendations:
1. Implement more robust and decentralized access control.
2. Avoid hardcoding values or provide governance mechanisms for their updates.
3. Validate inputs and outputs from all ERC20 interactions.
4. Handle reentrancy risks using locks or checks-effects-interactions patterns.
5. Test foreclosure logic against potential edge cases or exploits.
6. Emit events for all critical state updates.
7. Add comprehensive tests for underflow/overflow scenarios, especially during casting operations.
8. Decentralize or rigorously control `uberOwner` privileges.

These vulnerabilities should be carefully addressed to improve the contract's robustness and security.","### **Analysis of Issue and Response Alignment**

#### **[H-01] Unchecked ERC20 transfers can cause lock up**

- **Report Description**:
  The issue highlights that the transfer function behavior of some ERC20 tokens is inconsistent. These tokens may return `true/false`, revert without returning anything, or fail silently. The lack of return value validation in ERC20 interactions risks silent failure of token transfers, potentially locking up tokens.

- **Match in Response List**:
  Matches with **""ERC20 Dependencies Without Validation""**.

- **Validation**:
  **Correct**. The response addresses the issue by noting the absence of validation for return values of `erc20.transfer` and `erc20.transferFrom`, which aligns with the report. These concerns are consistent with best practices for securing token interactions.

- **Suggestions**:
  Explicitly suggest checking return values for ERC20 methods and implementing fallback mechanisms for non-compliant tokens.

---

#### **[H-04] Anyone can affect deposits of any user and turn the owner of the token**

- **Report Description**:
  The `collectRentUser` method allows anyone to manipulate the deposit state of any user by calling the function with arbitrary user IDs and maximum timestamps. This could force a user into foreclosure.

- **Match in Response List**:
  Matches with **""Logic Errors in `rentOwedUser` and `collectRentUser`""**.

- **Validation**:
  **Partially Correct**. While the response mentions issues in `collectRentUser`, it focuses on rent calculation overflows rather than the ability of attackers to manipulate state using arbitrary inputs. The response should explicitly address access control vulnerabilities in this function.

- **Suggestions**:
  - Restrict access to the function or add validation to ensure only authorized users can call it for their accounts.
  - Validate timestamp inputs to prevent abuse.

---

#### **[M-01] payout doesn't fix `isForeclosed` state**

- **Report Description**:
  After receiving a payout, users should regain financial solvency and their foreclosure status should be reversed. However, the `payout` function does not update `isForeclosed`.

- **Match in Response List**:
  **No match found.**

- **Validation**:
  **Unaddressed**. The response list does not address the foreclosure state update issue in the `payout` function.

- **Suggestions**:
  - Include logic in `payout` to re-evaluate and reset the `isForeclosed` status when users receive funds sufficient to meet the solvency threshold.

---

#### **[M-02] Critical `uberOwner` address changes should be a two-step process**

- **Report Description**:
  The `changeUberOwner` function allows critical privilege changes without a confirmation step. If an invalid address is mistakenly assigned, the system could lock indefinitely.

- **Match in Response List**:
  Matches with **""Centralization Risks in `uberOwner`""** and **""Lack of Input Validation""**.

- **Validation**:
  **Partially Correct**. The response highlights the risks of centralized control and the absence of input validation but does not propose a two-step confirmation process or mechanism to recover from an invalid address.

- **Suggestions**:
  - Introduce a two-step process for owner changes (e.g., commit and confirm stages).
  - Validate new addresses to ensure accessibility and implement a fallback mechanism for errors.

---

#### **[M-03] Missing `balancedBooks` modifier could result in failed system insolvency detection**

- **Report Description**:
  The `balancedBooks` modifier ensures fund integrity but is missing in functions like `refundUser()` and `topupMarketBalance()`. This could allow unnoticed miscalculations, leading to insolvency.

- **Match in Response List**:
  **No match found.**

- **Validation**:
  **Unaddressed**. The response list does not address the omission of the `balancedBooks` modifier.

- **Suggestions**:
  - Apply the `balancedBooks` modifier to functions handling financial state changes.
  - Audit all functions for similar missing checks.

---

#### **[M-16] Deposits can be denied by abusing `maxContractBalance`**

- **Report Description**:
  An attacker could temporarily hit the `maxContractBalance` limit by front-running deposits, blocking other users. This could manipulate market outcomes.

- **Match in Response List**:
  **No match found.**

- **Validation**:
  **Unaddressed**. The response list does not consider abuse of the `maxContractBalance` limit.

- **Suggestions**:
  - Introduce per-user deposit caps or enforce queue-based processing for deposits.
  - Reassess the utility of the `maxContractBalance` limit in light of potential abuse.

---

#### **[M-17] Function `foreclosureTimeUser` returns a shorter foreclosure time than expected**

- **Report Description**:
  The function calculates foreclosure time based on outdated data, leading to underestimation of the actual foreclosure duration.

- **Match in Response List**:
  Matches with **""Foreclosure Logic Flaw""**.

- **Validation**:
  **Correct**. The response identifies inconsistencies in foreclosure calculations and aligns with the report's findings.

- **Suggestions**:
  Revise the calculation logic to use the current timestamp consistently for accurate results.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[Response 3] Approval Race Condition**

- **Assessment**:
  **Valid Concern**. Approval race conditions are a known risk in ERC20 token interactions. This issue is indirectly related to the unchecked ERC20 calls mentioned in [H-01] but expands on potential risks from overlapping approvals.

- **Recommendations**:
  Adopt the ""check and decrease allowance"" pattern to prevent exploitation.

---

#### **[Response 16] Unhandled Edge Cases**

- **Assessment**:
  **Valid Concern**. Edge cases like timestamp discrepancies and large token amounts merit additional safeguards. These are indirectly related to issues [M-16] and [M-17].

- **Recommendations**:
  - Perform comprehensive input validation for timestamps and amounts.
  - Use unit testing to simulate edge cases and verify system behavior.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- [H-01] Unchecked ERC20 transfers can cause lock up
- [M-17] Function `foreclosureTimeUser` returns a shorter foreclosure time than expected

**Partially Correct Matches**:
- [H-04] Anyone can affect deposits of any user and turn the owner of the token
- [M-02] Critical `uberOwner` address changes should be a two-step process

**Missed Issues from Issue Report**:
- [M-01] payout doesn't fix `isForeclosed` state
- [M-03] Missing `balancedBooks` modifier
- [M-16] Deposits can be denied by abusing `maxContractBalance`

**GPT-Generated Potential Issues (May Be Incorrect)**:
- [Response 3] Approval Race Condition
- [Response 16] Unhandled Edge Cases",2,2,3,16,"```
1. ERC20 Dependencies Without Validation
2. Foreclosure Logic Flaw
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **ERC20 Dependencies Without Validation** appears at rank 7.
   - **Foreclosure Logic Flaw** appears at rank 6.

2. **Calculate the precision at each rank where a true positive appears**:
   - For **Foreclosure Logic Flaw** at rank 6:
     \[
     P@6 = \frac{1}{6} \approx 0.1667
     \]
   - For **ERC20 Dependencies Without Validation** at rank 7:
     \[
     P@7 = \frac{2}{7} \approx 0.2857
     \]

3. **Average the precision values**:
   \[
   AP = \frac{0.1667 + 0.2857}{2} \approx 0.2262
   \]

**Average Precision (AP)**: 0.2262",0.2262
RCMarket.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";

/// @title Reality Cards Market
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    // CONTRACT SETUP
    /// @dev = how many outcomes/teams/NFTs etc
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    /// @dev type of event.
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    /// @dev so the Factory can check it's a market
    bool public constant override isMarket = true;
    /// @dev counts the total NFTs minted across all events at the time market created
    /// @dev nft tokenId = card Id + totalNftMintCount
    uint256 public totalNftMintCount;

    // CONTRACT VARIABLES
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    // PRICE, DEPOSITS, RENT
    /// @dev in wei
    mapping(uint256 => uint256) public cardPrice;
    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.
    mapping(address => uint256) public rentCollectedPerUser;
    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout
    mapping(uint256 => uint256) public rentCollectedPerCard;
    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    /// @dev an easy way to track the above across all cards
    uint256 public totalRentCollected;
    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)
    mapping(address => uint256) public exitedTimestamp;

    // PARAMETERS
    /// @dev read from the Factory upon market creation, can not be changed for existing market
    /// @dev the minimum required price increase in %
    uint256 public minimumPriceIncreasePercent;
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public minRentalDayDivisor;
    /// @dev maximum number of times to calcualte rent in one transaction
    uint256 public maxRentIterations;

    // TIME
    /// @dev how many seconds each user has held each card for, for determining winnings
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld
    mapping(uint256 => uint256) public totalTimeHeld;
    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.
    mapping(uint256 => uint256) public timeLastCollected;
    /// @dev to track the max timeheld of each card (for giving NFT to winner)
    mapping(uint256 => uint256) public longestTimeHeld;
    /// @dev to track who has owned it the most (for giving NFT to winner)
    mapping(uint256 => address) public longestOwner;
    /// @dev to track the card timeHeldLimit for the current owner
    mapping(uint256 => uint256) public cardTimeLimit;

    // TIMESTAMPS
    /// @dev when the market opens
    uint32 public marketOpeningTime;
    /// @dev when the market locks
    uint32 public override marketLockingTime;
    /// @dev when the question can be answered on realitio
    /// @dev only needed for circuit breaker
    uint32 public oracleResolutionTime;

    // PAYOUT VARIABLES
    uint256 public winningOutcome;
    /// @dev prevent users withdrawing twice
    mapping(address => bool) public userAlreadyWithdrawn;
    /// @dev prevent users claiming twice
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool
    /// @dev the artist
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    /// @dev the affiliate
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    /// @dev the winner
    uint256 public winnerCut;
    /// @dev the market creator
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    /// @dev card specific recipients
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    // ORACLE VARIABLES
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _numberOfCards how many Cards in this market
    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _marketCreatorAddress where to send market creator's cut, if any
    /// @param _realitioQuestion the question posted to the Oracle
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        // external contract variables:
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        // get adjustable parameters from the factory/treasury
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        // initialiiize!
        winningOutcome = MAX_UINT256; // default invalid

        // assign arguments to public variables
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        // reduce artist cut to zero if zero adddress set
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        // reduce affiliate cut to zero if zero adddress set
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        // check the validity of card affiliate array.
        // if not valid, reduce payout to zero
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        // if winner takes all mode, set winnerCut to max
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        // post question to Oracle
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        // move to OPEN immediately if market opening time in the past
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    /*╔═════════════════════════════════╗
      ║            MODIFIERS            ║
      ╚═════════════════════════════════╝*/

    /// @notice automatically opens market if appropriate
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    /// @notice automatically locks market if appropriate
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    /// @dev can only be called by Card owners
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║     NFT HUB CONTRACT CALLS      ║
      ╚═════════════════════════════════╝*/

    /// @notice send NFT to mainnet
    /// @dev upgrades not possible if market not approved
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    /// @notice gets the owner of the NFT via their Card Id
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    /// @notice gets tokenURI via their Card Id
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called internally during contract open state
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called externaly by Orderbook during contract open state
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    /*╔═════════════════════════════════╗
      ║        ORACLE FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @dev called within initializer only
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    /// @notice has the oracle finalised
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    /// @dev sets the winning outcome
    /// @dev market.setWinner() will revert if done twice, because wrong state
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        // check market state to prevent market closing early
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        // call the market
        setWinner(uint256(_winningOutcome));
    }

    /// @dev admin override of the oracle
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    /*╔═════════════════════════════════╗
      ║  MARKET RESOLUTION FUNCTIONS    ║
      ╚═════════════════════════════════╝*/

    /// @notice checks whether the competition has ended, if so moves to LOCKED state
    /// @dev can be called by anyone
    /// @dev public because called within autoLock modifier & setWinner
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        // do a final rent collection before the contract is locked down

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                // bring the cards back to the market so the winners get the satisfcation of claiming them
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    /// @notice called by getWinnerFromOracle, sets the winner
    /// @param _winningOutcome the index of the winning card
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            // change the locking time to allow lockMarket to lock
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            // get the winner. This will revert if answer is not resolved.
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    /// @notice pays out winnings, or returns funds
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    /// @notice the longest owner of each NFT gets to keep it
    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known
    /// @param _card the id of the card, the index
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    /// @notice pays winnings
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        // calculate longest owner's extra winnings, if relevant
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            // return all rent paid on winning card
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            // calculate normal winnings, if any
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    /// @notice returns all funds to users in case of invalid outcome
    function _returnRent() internal {
        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    /// @notice all payouts happen through here
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)
    /// @dev they are not called within setWinner() because of the risk of an
    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings
    /// @dev [hangover from when ether was native currency, keeping in case we return to this]

    /// @notice pay artist
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    /// @notice pay market creator
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    /// @notice pay affiliate
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    /// @notice pay card affiliate
    /// @dev does not call _processStakeholderPayment because it works differently
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             EXTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @dev basically functions that have _checkState(States.OPEN) on first line

    /// @notice collects rent for all cards
    /// @dev cannot be external because it is called within the lockMarket function, therefore public
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    /// @notice rent every Card at the minimum price
    /// @param _maxSumOfPrices a limit to the sum of the bids to place
    function rentAllCards(uint256 _maxSumOfPrices) external {
        // check that not being front run
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    /// @notice to rent a Card
    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate
    /// @param _newPrice the price to rent the card for
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _startingPosition where to start looking to insert the bid into the orderbook
    /// @param _card the index of the card to update
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    // the owner may only increase by more than X% or reduce their price
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                // do some cleaning up before we collect rent or check their bidRate
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                // check sufficient deposit
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                // replaces _newBid and _updateBid
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    /// @notice to change your timeHeldLimit without having to re-rent
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _card the index of the card to update
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    /// @notice stop renting all cards
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    /// @notice stop renting a card and/or remove from orderbook
    /// @dev public because called by exitAll()
    /// @dev doesn't need to be current owner so user can prevent ownership returning to them
    /// @dev does not apply minimum rental duration, because it returns ownership to the next user
    /// @param _card The card index to exit
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        // block frontrunning attack
        exitedTimestamp[_msgSender] = block.timestamp;

        // collectRent first
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            // if current owner, find a new one
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            // if not owner, just delete from orderbook
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by user, sponsor is msgSender
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    /// @dev actually processes the sponsorship
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        // send tokens to the Treasury
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        // just so user can get it back if invalid outcome
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        // allocate equally to each card, in case card specific affiliates
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             INTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @notice collects rent for a specific card
    /// @dev also calculates and updates how long the current user has held the card for
    /// @dev is not a problem if called externally, but making internal over public to save gas
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        // don't collect rent beyond the locking time
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)
        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            // Calculate the card timeLimitTimestamp
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            // input bools
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            // outputs
            bool _newOwner;
            uint256 _refundTime; // seconds of rent to refund the user

            /* Permutations of the events: Foreclosure, Time limit and Market Locking
            ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐
            │Case       │1│2│3│4│5│6│7│8│
            ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤
            │Foreclosure│0│0│0│0│1│1│1│1│
            │Time Limit │0│0│1│1│0│0│1│1│
            │Market Lock│0│1│0│1│0│1│0│1│
            └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘
            */

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 1
                // didn't foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN simple rent collect, same owner
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                // CASE 2
                // didn't foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN refund rent between locking and now
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                // CASE 3
                // didn't foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN refund rent between time limit and now
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                // CASE 4
                // didn't foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN refund rent between the earliest event and now
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    // time limit hit before market locked
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    // market locked before time limit hit
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 5
                // did foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN rent OK, find new owner
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                // CASE 6
                // did foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN if foreclosed first rent ok, otherwise refund after locking
                if (_timeUserForeclosed < marketLockingTime) {
                    // user foreclosed before market locked
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // market locked before user foreclosed
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                // CASE 7
                // did foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN if foreclosed first rent ok, otherwise refund after limit
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    // user foreclosed before time limit
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // time limit hit before user foreclosed
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                // CASE 8
                // did foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN (╯°益°)╯彡┻━┻
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    // user foreclosed first (or at same time as time limit)
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    // time limit hit first
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    // market locked first
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking
            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls
    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    /// @dev processes actual rent collection and updates the state
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        // if the user has a timeLimit, adjust it as necessary
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        // longest owner tracking
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    /// @dev should only be called thrice
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    /*╔═════════════════════════════════╗
      ║        CIRCUIT BREAKER          ║
      ╚═════════════════════════════════╝*/

    /// @dev in case Oracle never resolves for any reason
    /// @dev does not set a winner so same as invalid outcome
    /// @dev market does not need to be locked, just in case lockMarket bugs out
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",10267.0,1122.0,"[H-02] Can access cards of other markets
Within `RCMarket.sol` the functions ownerOf and `onlyTokenOwner` do not check if the `_cardId/_token` is smaller than `numberOfCards`. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for `isMarketApproved` can be circumvented by trying to move the card via another market.
  [H-03] anyone can call function sponsor
This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:   [M-07] maxSumOfPrices check is broken
`rentAllCards()` requires the sender to specify a `_maxSumOfPrices` parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.
However, this function parameter constraint for `_maxSumOfPrices` is broken in the function implementation which leads to the total number of bids placed greater than the _maxSumOfPrices specified.
  [M-13] Wrong calculation on `_collectRentAction`
The method `_collectRentAction` contains the following code:
in case 6, it is doing: ```
_refundTime = block.timestamp - marketLockingTime;
```
instead of: ```
_refundTime = _timeUserForeclosed - marketLockingTime;
```",3.0,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";


contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {

    
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    
    bool public constant override isMarket = true;
    
    
    uint256 public totalNftMintCount;

    
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    
    
    mapping(uint256 => uint256) public cardPrice;
    
    mapping(address => uint256) public rentCollectedPerUser;
    
    mapping(uint256 => uint256) public rentCollectedPerCard;
    
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    
    uint256 public totalRentCollected;
    
    mapping(address => uint256) public exitedTimestamp;

    
    
    
    uint256 public minimumPriceIncreasePercent;
    
    uint256 public minRentalDayDivisor;
    
    uint256 public maxRentIterations;

    
    
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    
    mapping(uint256 => uint256) public totalTimeHeld;
    
    mapping(uint256 => uint256) public timeLastCollected;
    
    mapping(uint256 => uint256) public longestTimeHeld;
    
    mapping(uint256 => address) public longestOwner;
    
    mapping(uint256 => uint256) public cardTimeLimit;

    
    
    uint32 public marketOpeningTime;
    
    uint32 public override marketLockingTime;
    
    
    uint32 public oracleResolutionTime;

    
    uint256 public winningOutcome;
    
    mapping(address => bool) public userAlreadyWithdrawn;
    
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; 
    
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    
    uint256 public winnerCut;
    
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    

    
    
    
    
    
    
    
    
    
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        
        winningOutcome = MAX_UINT256; 

        
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        
        
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    

    
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    

    
    
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); 
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    
    
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    
    
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    

    
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    
    
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        
        setWinner(uint256(_winningOutcome));
    }

    
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    

    
    
    
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    
    
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    
    
    
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    
    function _returnRent() internal {
        
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    
    
    
    

    
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    
    
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    

    

    
    
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    
    
    function rentAllCards(uint256 _maxSumOfPrices) external {
        
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    
    
    
    
    
    
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    
    
    
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    
    
    
    
    
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        
        exitedTimestamp[_msgSender] = block.timestamp;

        
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    
    
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    
    
    
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    

    
    
    
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        
        
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            
            bool _newOwner;
            uint256 _refundTime; 

            

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                
                
                
                
                
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                
                
                
                
                
                if (_timeUserForeclosed < marketLockingTime) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                
                
                
                
                
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                
                
                
                
                
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); 

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            
            
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    
    
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    

    
    
    
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    
}",6724.0,2,2,"The code provided is a complex Solidity smart contract, and vulnerabilities within it can stem from security weaknesses, assumptions in implementation, or broader design flaws. Below is a list of potential vulnerabilities and risks related to this contract:

---

### 1. **Reentrancy Issues**
   - **Problem**: Reentrancy attacks happen when an external contract is called, and the external call triggers reentry into the current contract before execution completes. For example:
      - `_payout()` uses `assert(treasury.payout(_recipient, _amount))`. If `treasury.payout` interacts with a malicious external contract, it could trigger reentrant behavior.
   - **Mitigation**:
      - Use reentrancy guards (`nonReentrant` modifier).
      - Avoid state updates after calling external contracts.
      
---

### 2. **Unchecked External Interaction (oracle-related vulnerabilities)**
   - Functions like `getWinnerFromOracle()` and `_postQuestionToOracle()` interact with the `realitio` oracle. If the oracle or question resolution is manipulated, an attacker could supply falsified data (e.g., forge the winning outcome).
   - **Mitigation**:
      - Ensure oracles have a trusted mechanism to validate data.
      - Set specific conditions for acceptable oracle design/address changes.

---

### 3. **Unchecked Loops (Gas Limit Issues)**
   - Several loops (`for` and `while`) are used in functions like `initialize`, `collectRentAllCards`, `exitAll`, etc.:
      - Example: `collectRentAllCards()` iterates over all cards in a loop and could exceed the gas limit if `numberOfCards` is high.
   - **Mitigation**:
      - Avoid large loops or allow incremental execution through multiple transactions.
      - Introduce timeout or partial collection using capped iterations (`batching` patterns).

---

### 4. **Circular Dependencies**
   - The contract heavily relies on external contracts/interfaces (e.g., `IRCOrderbook`, `IRCTreasury`, `IRealitio`, etc.). If any of these external relationships introduce vulnerabilities or unexpected behaviors, the system behaves unpredictably.
   - **Example**: `findNewOwner` and `removeBidFromOrderbook` in the orderbook may have unexpected consequences or fail silently.
   - **Mitigation**:
      - Perform audits on external contract dependencies.
      - Implement sanity checks, fallback behaviors, or timeouts when interacting with critical external systems.

---

### 5. **Upgradeability Risks**
   - Since `RCMarket` uses the `Initializable` modifier (OpenZeppelin), it's designed for proxy-based upgradeability. Certain risks include:
     - Improper initialization (e.g., forgetting to call `initializer`).
     - Attackers may reinitialize the contract if `initialize()` isn't properly secured (e.g., no explicit owner verification).
   - **Mitigation**:
      - Implement robust access control (e.g., ensure only the factory/owner can call `initialize()`).
      - Ensure reinitialization is impossible (`initializer` is a one-time-only function).
  
---

### 6. **Price Manipulation**
   - **Problem**: The market heavily involves dynamic pricing for `cardPrice[_card]`, where prices can increase or decrease based on demand. A malicious actor could:
     1. Sybil attack: Create multiple accounts to bid and manipulate prices artificially.
     2. Exploit the minimum percentage increase mechanism by setting or removing prices strategically.
   - **Mitigation**:
      - Establish anti-Sybil protections (e.g., KYC enforcement or deposit requirements).
      - Limit the frequency or size of price adjustments.

---

### 7. **Potential Griefing via Excessive Time Held Limit**
   - Owners of cards can set extreme `_timeHeldLimit` values during `newRental()`. This can lock certain cards and prevent others from obtaining them even when conditions change.
   - **Mitigation**:
      - Enforce stricter bounds for `updateTimeHeldLimit` inputs.

---

### 8. **Front-Running Vulnerabilities**
   - Functionality dependent on user bids/orders (e.g., `newRental`, `updateTimeHeldLimit`, `transferCard`) may be front-run by miners or other users who can anticipate transactions (e.g., using `mempool` sniffing).
   - **Mitigation**:
      - Introduce mechanisms for delayed order execution or commit/reveal schemes to prevent front-running.
      - Use a randomized or rolling prioritization mechanism.

---

### 9. **Lack of Circuit Breakers**
   - The circuit breaker is intended (`circuitBreaker()`), but it only activates **12 weeks post-oracle resolution timeout**. In the case of vulnerabilities or abnormal behavior, the long delay before circuit breaker triggers could expose users to losses.
   - **Mitigation**:
      - Allow stakeholders or governance mechanisms to enable an emergency circuit breaker.

---

### 10. **Inconsistent State Management**
   - The `state` variable tracks the smart contract state but relies heavily on external and internal logic for proper transitions.
   - Examples of issues:
     - Critical state transitions (e.g., `lockMarket`) depend on assumptions about rent collection.
     - Undefined/ambiguous behavior when `lockMarket` or `_incrementState` calls overlap or get interrupted.
   - **Mitigation**:
      - Validate all state transitions explicitly and ensure edge cases (e.g., partial rent collection failures) are handled properly.

---

### 11. **Failure to Validate `msgSender` in All Contexts**
   - The contract relies on `msgSender()` (native meta-transaction support via `NativeMetaTransaction`) in most functions. Any weaknesses in `NativeMetaTransaction` could compromise authentication of users.
   - **Mitigation**:
      - Use robust libraries, ensure signature checks are secure, and thoroughly test the meta-transaction framework.

---

### 12. **Error-Prone Timeout Calculations**
   - The contract involves extensive timing logic (e.g., `marketOpeningTime`, `marketLockingTime`, and `oracleResolutionTime`). If discrepancies occur (e.g., setting incorrect timestamps or reliance on `block.timestamp` where miner manipulation is possible), these durations can be exploited.
   - **Mitigation**:
      - Use stringent validation for timestamps and configuration.
      - Avoid relying directly on `block.timestamp`.

---

### 13. **No Comprehensive Access Control**
   - **Lack of Granular Access Control**:
     - For instance, functions like `setAmicableResolution` allow resolution by `factory.owner()`. If ownership of `factory` is compromised, malicious winners could be set dishonestly.
   - **Mitigation**:
      - Use a role-based access control mechanism (`RBAC` or `Ownable` via OpenZeppelin).

---

### 14. **Lack of Clear Fail-Safes for Infinite States**
   - Functions such as `_incrementState` or excessive `while` loops (e.g., `_collectRentAction`) have infinite patterns, assuming maximum iterations (`maxRentIterations` is an attempt to throttle).
   - **Example Failure**: If `maxRentIterations` is low and collection never resolves within bounds, certain cards could become ""stuck.""
   - **Mitigation**:
      - Introduce mechanisms to transition states safely even in edge cases.

---

### 15. **Event and Logging Risks**
   - The contract emits numerous events. However, most emitted data isn't consistently validated (e.g., `LogLongestOwner` assumes `longestOwner[_card]` correctness).
   - **Mitigation**:
      - Log critical state changes only after full verification of data sources and contract logic.

---

### 16. **Assumption of Constant Stakeholder Addresses**
   - Addresses like `artistAddress`, `affiliateAddress`, and others are set during initialization. If any address becomes unusable (e.g., blacklisting or malicious compromise), stakeholders could lose access.
   - **Mitigation**:
      - Allow updates to these addresses through DAO or multi-signature authorization.

---

### 17. **Token Transfer Risks**
   - `_transferCard()` and `transferNft` rely on `nfthub`, assuming it performs safe transfers and adheres to the ERC721 or ERC1155 interface.
   - **Mitigation**:
      - Explicitly integrate safeguards for non-standard token behavior or check whether the `nfthub` implementation is secure.
      
---

This smart contract requires a **security audit** to ensure that all identified and latent risks are remediated.","### **Analysis of Issues and Responses**

---

#### **[H-02] Can access cards of other markets**

**Report Description**:
Within `RCMarket.sol`, the functions `ownerOf` and `onlyTokenOwner` do not validate if `_cardId/_token` is smaller than `numberOfCards`. Consequently, users could supply an invalid card ID to access cards from other markets. The `upgradeCard` function is particularly vulnerable, as it allows bypassing the `isMarketApproved` check using this exploit.

**Match in Response List**:
**No match found.**

**Validation**:
**Unaddressed.** None of the responses in the `{response_list}` explicitly acknowledge or resolve the vulnerability allowing access to cards of other markets. This issue involves improper bounds checking, which is a critical input validation flaw.

**Suggestions**:
- Add explicit bounds checks for `_cardId` and `_token` in `ownerOf` and `onlyTokenOwner` functions.
- Ensure that the `upgradeCard` function verifies card ownership and market approval.

---

#### **[H-03] Anyone can call function sponsor**

**Report Description**:
The `sponsor` function is designed to be callable only by the factory but lacks authorization checks. This oversight allows any user to invoke the function with arbitrary `_sponsorAddress`, potentially transferring tokens if the allowance is greater than 0.

**Match in Response List**:
Partially matches **""No Comprehensive Access Control""**.

**Validation**:
**Partially Correct.** The response addresses the general lack of access control in functions like `setAmicableResolution`. However, it does not explicitly mention the `sponsor` function or its specific vulnerability.

**Suggestions**:
- Add role-based access control (e.g., OpenZeppelin's `Ownable` or `RBAC`) to restrict `sponsor` to the factory.
- Test for similar vulnerabilities across other functions.

---

#### **[M-07] maxSumOfPrices check is broken**

**Report Description**:
The `rentAllCards()` function requires a `_maxSumOfPrices` parameter for front-running protection. However, the parameter is improperly implemented, allowing the total bids placed to exceed the specified limit, negating its intended purpose.

**Match in Response List**:
Partially matches **""Front-Running Vulnerabilities""**.

**Validation**:
**Partially Correct.** The response highlights front-running risks in functions like `newRental` and `transferCard`, but it does not directly address the broken implementation of `_maxSumOfPrices` in `rentAllCards()`.

**Suggestions**:
- Fix the logic for `_maxSumOfPrices` to ensure bids cannot exceed the specified limit.
- Incorporate a commit/reveal scheme to enhance front-running protection.

---

#### **[M-13] Wrong calculation on `_collectRentAction`**

**Report Description**:
The `_collectRentAction` function includes incorrect calculations that could lead to logical errors, potentially impacting rent collection and market stability.

**Match in Response List**:
Partially matches **""Inconsistent State Management""** and **""Unchecked Loops (Gas Limit Issues)""**.

**Validation**:
**Partially Correct.** The responses discuss risks of gas limit issues and improper state transitions but do not specifically identify or propose fixes for the erroneous calculations in `_collectRentAction`.

**Suggestions**:
- Audit and correct the calculations in `_collectRentAction`.
- Implement unit tests to validate the correctness of calculations and their edge cases.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[9] Lack of Circuit Breakers**

**Response Description**:
The circuit breaker mechanism triggers only after a 12-week timeout, which may not suffice in emergencies or vulnerabilities.

**Assessment**:
**Valid Concern.** The long delay before circuit breaker activation poses a risk. Stakeholders should have a quicker way to halt operations.

**Recommendations**:
- Allow immediate activation of the circuit breaker through governance or a multisig mechanism.

---

#### **[5] Upgradeability Risks**

**Response Description**:
Improper use of the `Initializable` modifier may lead to reinitialization attacks if `initialize()` is not secured.

**Assessment**:
**Valid Concern.** Proxy upgradeability introduces reinitialization risks, which should be mitigated with proper owner checks.

**Recommendations**:
- Ensure `initializer` is a one-time function with robust ownership checks.
- Add tests to validate upgrade logic.

---

#### **[12] Error-Prone Timeout Calculations**

**Response Description**:
The contract heavily relies on timing logic (`marketOpeningTime`, `oracleResolutionTime`), which could be exploited if timestamps are improperly set or manipulated.

**Assessment**:
**Valid Concern.** Timing logic should be secured against manipulation.

**Recommendations**:
- Use secure timestamp validations.
- Implement mechanisms to handle timing edge cases.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None.

#### **Partially Correct Matches**:
1. **[H-03] Anyone can call function sponsor** → Matches **""No Comprehensive Access Control""**.
2. **[M-07] maxSumOfPrices check is broken** → Matches **""Front-Running Vulnerabilities""**.
3. **[M-13] Wrong calculation on `_collectRentAction`** → Matches **""Inconsistent State Management""** and **""Unchecked Loops (Gas Limit Issues)""**.

#### **Missed Issues from Issue Report**:
1. **[H-02] Can access cards of other markets**: No bounds checks for `_cardId` and `_token` in `ownerOf` and `onlyTokenOwner`.

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
1. **[9] Lack of Circuit Breakers**: Valid concern about delays in circuit breaker activation.
2. **[5] Upgradeability Risks**: Valid concern about reinitialization vulnerabilities.
3. **[12] Error-Prone Timeout Calculations**: Valid concern about potential timestamp manipulation.

---

Let me know if you need further details or modifications to the analysis!",0,3,1,17,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these values is also 0.",0
RCFactory.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";

/// @title Reality Cards Factory
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    //≡≡≡≡≡≡≡ CONTRACT VARIABLES ≡≡≡≡≡≡≡//
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRealitio public realitio;

    ///// CONTRACT ADDRESSES /////
    /// @dev reference contract
    address public referenceContractAddress;
    /// @dev increments each time a new reference contract is added
    uint256 public referenceContractVersion;
    /// @dev market addresses, mode // address
    /// @dev these are not used for anything, just an easy way to get markets
    mapping(uint256 => address[]) public marketAddresses;
    mapping(address => bool) public mappingOfMarkets;

    ///// GOVERNANCE VARIABLES- OWNER /////
    /// @dev artist / winner / market creator / affiliate / card affiliate
    uint256[5] public potDistribution;
    /// @dev minimum tokens that must be sent when creating market which forms iniital pot
    uint256 public sponsorshipRequired;
    /// @dev adjust required price increase (in %)
    uint256 public override minimumPriceIncreasePercent;
    /// @dev market opening time must be at least this many seconds in the future
    uint32 public advancedWarning;
    /// @dev market closing time must be no more than this many seconds in the future
    uint32 public maximumDuration;
    /// @dev list of governors
    mapping(address => bool) public governors;
    /// @dev if false, anyone can create markets
    bool public marketCreationGovernorsOnly = true;
    /// @dev if false, anyone can be an affiliate
    bool public approvedAffilliatesOnly = true;
    /// @dev if false, anyone can be an artist
    bool public approvedArtistsOnly = true;
    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity
    bool public override trapIfUnapproved = true;
    /// @dev high level owner who can change the factory address
    address public uberOwner;
    /// @dev the maximum number of rent collections to perform in a single transaction
    uint256 public override maxRentIterations;
    /// @dev the address of the arbitrator
    address public arbitrator;
    /// @dev the time allowed to dispute the oracle answer
    uint32 public timeout;

    ///// GOVERNANCE VARIABLES- GOVERNORS /////
    /// @dev unapproved markets hidden from the interface
    mapping(address => bool) public override isMarketApproved;
    /// @dev allows artist to receive cut of total rent
    mapping(address => bool) public isArtistApproved;
    /// @dev allows affiliate to receive cut of total rent
    mapping(address => bool) public isAffiliateApproved;
    /// @dev allows card affiliate to receive cut of total rent
    mapping(address => bool) public isCardAffiliateApproved;
    /// @dev a limit to the number of NFTs to mint per market
    uint256 public nftMintingLimit;

    ///// OTHER /////
    /// @dev counts the total NFTs minted across all events
    /// @dev ... so the appropriate token id is used when upgrading to mainnet
    uint256 public totalNftMintCount;

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        uint32 mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool hidden);
    event LogAdvancedWarning(uint256 _newAdvancedWarning);
    event LogMaximumDuration(uint256 _newMaximumDuration);

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    /// @dev Treasury must be deployed before Factory
    constructor(
        IRCTreasury _treasuryAddress,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasuryAddress) != address(0));
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        // at initiation, uberOwner and owner will be the same
        uberOwner = msgSender();

        // initialise contract variable
        treasury = _treasuryAddress;

        // initialise adjustable parameters
        // artist // winner // creator // affiliate // card affiliates
        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate
        setminimumPriceIncreasePercent(10); // 10%
        setNFTMintingLimit(60); // current gas limit (12.5m) allows for 60 NFTs to be minted
        setMaxRentIterations(35); // limit appears to be 41, set safe at 35 for now.
        // oracle
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); // 24 hours
    }

    /*╔═════════════════════════════════╗
      ║          VIEW FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice Fetch the address of the most recently created market
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return the address of the most recent market in the given mode
    function getMostRecentMarket(uint256 _mode)
        external
        view
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    /// @notice Fetch all the market addresses for a given mode
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return an array of all markets in a given mode
    function getAllMarkets(uint256 _mode)
        external
        view
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    /// @notice Returns the currently set pot distribution
    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @dev include the owner as a governor
    modifier onlyGovernors() {
        require(
            governors[msgSender()] || owner() == msgSender(),
            ""Not approved""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - OWNER (SETUP)  ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier

    /// @notice where the NFTs live
    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but
    /// @dev ... keeping flexible in case returning to previous contract
    /// @param _newAddress the address to set
    /// @param _newNftMintCount the number of NFTs this contract has minted, in order to keep them unique
    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)
        external
        onlyOwner
    {
        require(address(_newAddress) != address(0));
        nfthub = _newAddress;
        totalNftMintCount = _newNftMintCount;
    }

    /// @notice set the address of the orderbook contract
    /// @param _newAddress the address to set
    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {
        require(address(_newAddress) != address(0));
        orderbook = _newAddress;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier
    // Min price increase & pot distribution emitted by Market.
    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUTOR - PUBLIC  │
      └────────────────────────────────────┘*/

    /// @notice update stakeholder payouts
    /// @dev in basis points (so 1000 = 100%)
    /// @param _artistCut The artist that designed the card
    /// @param _winnerCut Extra cut for the longest owner
    /// @param _creatorCut The creator of the market
    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts
    /// @param _cardAffiliateCut An affiliate cur for specific cards
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                1000,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    /// @notice how much above the current price a user must bid, in %
    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%
    function setminimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    /// @notice A limit to the number of NFTs to mint per market
    /// @dev to avoid gas limits
    /// @param _mintLimit the limit to set
    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {
        nftMintingLimit = _mintLimit;
    }

    /// @notice A limit to the number of rent collections per transaction
    /// @dev to avoid gas limits
    /// @param _rentLimit the limit to set
    function setMaxRentIterations(uint256 _rentLimit)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
    }

    /// @notice set the address of the reality.eth contracts
    /// @param _newAddress the address to set
    function setRealitioAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    /// @notice address of the arbitrator, in case of continued disputes on reality.eth
    /// @param _newAddress the address to set
    function setArbitrator(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    /// @notice set how long reality.eth waits for disputes before finalising
    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs
    function setTimeout(uint32 _newTimeout) public onlyOwner {
        timeout = _newTimeout;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  │
      └──────────────────────────────────────────┘*/

    /// @notice whether or not only governors can create the market
    function changeMarketCreationGovernorsOnly() external onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    /// @notice whether or not anyone can be an artist
    function changeApprovedArtistsOnly() external onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    /// @notice whether or not anyone can be an affiliate
    function changeApprovedAffilliatesOnly() external onlyOwner {
        approvedAffilliatesOnly = !approvedAffilliatesOnly;
    }

    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot
    /// @param _amount the sponsorship required in wei
    function setSponsorshipRequired(uint256 _amount) external onlyOwner {
        sponsorshipRequired = _amount;
    }

    /// @notice if true, Cards in unapproved markets can't be upgraded
    function changeTrapCardsIfUnapproved() external onlyOwner {
        trapIfUnapproved = !trapIfUnapproved;
    }

    /// @notice market opening time must be at least this many seconds in the future
    /// @param _newAdvancedWarning the warning time to set in seconds
    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {
        advancedWarning = _newAdvancedWarning;
        emit LogAdvancedWarning(_newAdvancedWarning);
    }

    /// @notice market closing time must be no more than this many seconds in the future
    /// @param _newMaximumDuration the duration limit to set in seconds
    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {
        maximumDuration = _newMaximumDuration;
        emit LogMaximumDuration(_newMaximumDuration);
    }

    /// @notice to fetch the owner of the contract
    /// @dev used to specifiy the Ownable contract instead of the interface
    function owner()
        public
        view
        override(IRCFactory, Ownable)
        returns (address)
    {
        return Ownable.owner();
    }

    /// @notice check if an address is a governor
    /// @param _user the address to query
    /// @return boolean return if true or false
    function isGovernor(address _user) external view override returns (bool) {
        return governors[_user];
    }

    // EDIT GOVERNORS

    /// @notice add or remove an address from market creator whitelist
    /// @param _governor the address to change approval for
    /// @dev recommended to check isGovernor() afterwards to confirm the desired outcome
    function changeGovernorApproval(address _governor) external onlyOwner {
        require(_governor != address(0));
        governors[_governor] = !governors[_governor];
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - GOVERNORS      ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyGovernors modifier

    /// @notice markets are default hidden from the interface, this reveals them
    /// @param _market the market address to change approval for
    function changeMarketApproval(address _market) external onlyGovernors {
        require(_market != address(0));
        // check it's an RC contract
        IRCMarket _marketToApprove = IRCMarket(_market);
        assert(_marketToApprove.isMarket());
        isMarketApproved[_market] = !isMarketApproved[_market];
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    /// @notice artistAddress, passed in createMarket, must be approved
    /// @param _artist the artist address to change approval for
    function changeArtistApproval(address _artist) external onlyGovernors {
        require(_artist != address(0));
        isArtistApproved[_artist] = !isArtistApproved[_artist];
    }

    /// @notice affiliateAddress, passed in createMarket, must be approved
    /// @param _affiliate the affiliate address to change approval for
    function changeAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];
    }

    /// @notice cardAffiliateAddress, passed in createMarket, must be approved
    /// @param _affiliate the card affiliate address to change approval for
    function changeCardAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[
            _affiliate
        ];
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governanace functions

    /// @notice change the reference contract for the contract logic
    function setReferenceContractAddress(address _newAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newAddress != address(0));
        // check it's an RC contract
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        assert(newContractVariable.isMarket());
        // set
        referenceContractAddress = _newAddress;
        // increment version
        referenceContractVersion += 1;
    }

    /// @notice to change or renounce ownership of the uberOwner role
    function changeUberOwner(address _newUberOwner) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0));
        uberOwner = _newUberOwner;
    }

    /*╔═════════════════════════════════╗
      ║         MARKET CREATION         ║
      ╚═════════════════════════════════╝*/

    /// @notice Creates a new market with the given parameters
    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _tokenURIs location of NFT metadata
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _realitioQuestion the details of the event to send to the oracle
    /// @param _sponsorship amount of sponsorship to create the market with
    /// @return The address of the new market
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address) {
        address _creator = msgSender();

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                isArtistApproved[_artistAddress] ||
                    _artistAddress == address(0),
                ""Artist not approved""
            );
        }
        // affiliate
        if (approvedAffilliatesOnly) {
            require(
                isAffiliateApproved[_affiliateAddress] ||
                    _affiliateAddress == address(0),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||
                        _cardAffiliateAddresses[i] == address(0),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(governors[_creator] || owner() == _creator, ""Not approved"");
        }

        // check timestamps
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        // check market opening time
        if (advancedWarning != 0) {
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        // check market locking time
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        // check oracle resolution time (no more than 1 week after market locking to get result)
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );

        // check the number of NFTs to mint is within limits
        require(
            _tokenURIs.length <= nftMintingLimit,
            ""Too many tokens to mint""
        );

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            _mode,
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            totalNftMintCount
        );

        // tell Treasury, Orderbook, and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress);
        nfthub.addMarket(_newAddress);
        orderbook.addMarket(
            _newAddress,
            _tokenURIs.length,
            minimumPriceIncreasePercent
        );

        // update internals
        marketAddresses[_mode].push(_newAddress);
        mappingOfMarkets[_newAddress] = true;

        // initialize the market
        IRCMarket(_newAddress).initialize({
            _mode: _mode,
            _timestamps: _timestamps,
            _numberOfTokens: _tokenURIs.length,
            _totalNftMintCount: totalNftMintCount,
            _artistAddress: _artistAddress,
            _affiliateAddress: _affiliateAddress,
            _cardAffiliateAddresses: _cardAffiliateAddresses,
            _marketCreatorAddress: _creator,
            _realitioQuestion: _realitioQuestion
        });

        // create the NFTs
        require(address(nfthub) != address(0), ""Nfthub not set"");
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            uint256 _tokenId = i + totalNftMintCount;
            require(
                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
                ""Nft Minting Failed""
            );
        }

        // increment totalNftMintCount
        totalNftMintCount = totalNftMintCount + _tokenURIs.length;

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    /// @dev called by the market upon initialise
    /// @dev not passed to initialise to avoid stack too deep error
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",5732.0,635.0,"[M-05] RCFactory.createMarket() does not enforce _timestamps and _timestamps being larger than _timestamps, even though proper functioning requires them to be so
`RCFactory.createMarket()` does not enforce `_timestamps[1]` and `_timestamps[2]` being larger than _timestamps[0], even though proper functioning requires them to be so.
IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. (1)
The comments explicitly state that _incrementState() should be called ""thrice"" (2)
However, it is possible to create a market where these events do not occur sequentially.",1.0,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";




contract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {
    

    
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRealitio public realitio;

    
    
    address public referenceContractAddress;
    
    uint256 public referenceContractVersion;
    
    
    mapping(uint256 => address[]) public marketAddresses;
    mapping(address => bool) public mappingOfMarkets;

    
    
    uint256[5] public potDistribution;
    
    uint256 public sponsorshipRequired;
    
    uint256 public override minimumPriceIncreasePercent;
    
    uint32 public advancedWarning;
    
    uint32 public maximumDuration;
    
    mapping(address => bool) public governors;
    
    bool public marketCreationGovernorsOnly = true;
    
    bool public approvedAffilliatesOnly = true;
    
    bool public approvedArtistsOnly = true;
    
    bool public override trapIfUnapproved = true;
    
    address public uberOwner;
    
    uint256 public override maxRentIterations;
    
    address public arbitrator;
    
    uint32 public timeout;

    
    
    mapping(address => bool) public override isMarketApproved;
    
    mapping(address => bool) public isArtistApproved;
    
    mapping(address => bool) public isAffiliateApproved;
    
    mapping(address => bool) public isCardAffiliateApproved;
    
    uint256 public nftMintingLimit;

    
    
    
    uint256 public totalNftMintCount;

    

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        uint32 mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool hidden);
    event LogAdvancedWarning(uint256 _newAdvancedWarning);
    event LogMaximumDuration(uint256 _newMaximumDuration);

    

    
    constructor(
        IRCTreasury _treasuryAddress,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasuryAddress) != address(0));
        
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        
        uberOwner = msgSender();

        
        treasury = _treasuryAddress;

        
        
        setPotDistribution(20, 0, 0, 20, 100); 
        setminimumPriceIncreasePercent(10); 
        setNFTMintingLimit(60); 
        setMaxRentIterations(35); 
        
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); 
    }

    

    
    
    
    function getMostRecentMarket(uint256 _mode)
        external
        view
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    
    
    
    function getAllMarkets(uint256 _mode)
        external
        view
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    
    
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    

    
    modifier onlyGovernors() {
        require(
            governors[msgSender()] || owner() == msgSender(),
            ""Not approved""
        );
        _;
    }

    
    

    
    
    
    
    
    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)
        external
        onlyOwner
    {
        require(address(_newAddress) != address(0));
        nfthub = _newAddress;
        totalNftMintCount = _newNftMintCount;
    }

    
    
    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {
        require(address(_newAddress) != address(0));
        orderbook = _newAddress;
    }

    
    
    
    

    

    
    
    
    
    
    
    
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                1000,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    
    
    function setminimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    
    
    
    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {
        nftMintingLimit = _mintLimit;
    }

    
    
    
    function setMaxRentIterations(uint256 _rentLimit)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
    }

    
    
    function setRealitioAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    
    
    function setArbitrator(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    
    
    function setTimeout(uint32 _newTimeout) public onlyOwner {
        timeout = _newTimeout;
    }

    

    
    function changeMarketCreationGovernorsOnly() external onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    
    function changeApprovedArtistsOnly() external onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    
    function changeApprovedAffilliatesOnly() external onlyOwner {
        approvedAffilliatesOnly = !approvedAffilliatesOnly;
    }

    
    
    function setSponsorshipRequired(uint256 _amount) external onlyOwner {
        sponsorshipRequired = _amount;
    }

    
    function changeTrapCardsIfUnapproved() external onlyOwner {
        trapIfUnapproved = !trapIfUnapproved;
    }

    
    
    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {
        advancedWarning = _newAdvancedWarning;
        emit LogAdvancedWarning(_newAdvancedWarning);
    }

    
    
    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {
        maximumDuration = _newMaximumDuration;
        emit LogMaximumDuration(_newMaximumDuration);
    }

    
    
    function owner()
        public
        view
        override(IRCFactory, Ownable)
        returns (address)
    {
        return Ownable.owner();
    }

    
    
    
    function isGovernor(address _user) external view override returns (bool) {
        return governors[_user];
    }

    

    
    
    
    function changeGovernorApproval(address _governor) external onlyOwner {
        require(_governor != address(0));
        governors[_governor] = !governors[_governor];
    }

    
    

    
    
    function changeMarketApproval(address _market) external onlyGovernors {
        require(_market != address(0));
        
        IRCMarket _marketToApprove = IRCMarket(_market);
        assert(_marketToApprove.isMarket());
        isMarketApproved[_market] = !isMarketApproved[_market];
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    
    
    function changeArtistApproval(address _artist) external onlyGovernors {
        require(_artist != address(0));
        isArtistApproved[_artist] = !isArtistApproved[_artist];
    }

    
    
    function changeAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];
    }

    
    
    function changeCardAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[
            _affiliate
        ];
    }

    
    
    
    

    
    function setReferenceContractAddress(address _newAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newAddress != address(0));
        
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        assert(newContractVariable.isMarket());
        
        referenceContractAddress = _newAddress;
        
        referenceContractVersion += 1;
    }

    
    function changeUberOwner(address _newUberOwner) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0));
        uberOwner = _newUberOwner;
    }

    

    
    
    
    
    
    
    
    
    
    
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address) {
        address _creator = msgSender();

        
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        
        
        if (approvedArtistsOnly) {
            require(
                isArtistApproved[_artistAddress] ||
                    _artistAddress == address(0),
                ""Artist not approved""
            );
        }
        
        if (approvedAffilliatesOnly) {
            require(
                isAffiliateApproved[_affiliateAddress] ||
                    _affiliateAddress == address(0),
                ""Affiliate not approved""
            );
            
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||
                        _cardAffiliateAddresses[i] == address(0),
                    ""Card affiliate not approved""
                );
            }
        }

        
        if (marketCreationGovernorsOnly) {
            require(governors[_creator] || owner() == _creator, ""Not approved"");
        }

        
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        
        if (advancedWarning != 0) {
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );

        
        require(
            _tokenURIs.length <= nftMintingLimit,
            ""Too many tokens to mint""
        );

        
        
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            _mode,
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            totalNftMintCount
        );

        
        
        treasury.addMarket(_newAddress);
        nfthub.addMarket(_newAddress);
        orderbook.addMarket(
            _newAddress,
            _tokenURIs.length,
            minimumPriceIncreasePercent
        );

        
        marketAddresses[_mode].push(_newAddress);
        mappingOfMarkets[_newAddress] = true;

        
        IRCMarket(_newAddress).initialize({
            _mode: _mode,
            _timestamps: _timestamps,
            _numberOfTokens: _tokenURIs.length,
            _totalNftMintCount: totalNftMintCount,
            _artistAddress: _artistAddress,
            _affiliateAddress: _affiliateAddress,
            _cardAffiliateAddresses: _cardAffiliateAddresses,
            _marketCreatorAddress: _creator,
            _realitioQuestion: _realitioQuestion
        });

        
        require(address(nfthub) != address(0), ""Nfthub not set"");
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            uint256 _tokenId = i + totalNftMintCount;
            require(
                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
                ""Nft Minting Failed""
            );
        }

        
        totalNftMintCount = totalNftMintCount + _tokenURIs.length;

        
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    
    
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }
    
}",3005.0,0,1,"The provided Solidity smart contract, `RCFactory`, has a considerable amount of code and includes several governance features, settings management, and market creation logic. Below is an analysis of **potential vulnerabilities** and areas for improvement:

---

### 1. **Centralization Risks**
   - **`onlyOwner` Prone Functions**: Many setup functions (e.g., `setPotDistribution`, `setArbitrator`, etc.) are restricted to the contract owner via the `onlyOwner` modifier.
     - **Risk**: If the owner is compromised or behaves maliciously, it could disrupt the ecosystem by changing critical parameters.
     - **Example**: `changeTrapCardsIfUnapproved`, `changeUberOwner`, `setReferenceContractAddress` can drastically alter behavior or permissions.
   - **Mitigation**: Introduce a **multi-sig wallet** for owner-related operations, requiring multiple approvals for actions.

---

### 2. **Code Execution at Cloned Contracts**
   - **Unchecked Reference Contract (`referenceContractAddress`)**: The `createMarket()` function clones a contract at the `referenceContractAddress` using OpenZeppelin's Clones library. However:
     - The `referenceContractAddress` is upgradable (by `uberOwner`).
     - If a malicious contract is set as `referenceContractAddress`, it could result in the deployment of vulnerable or malicious instances.
     - **Mitigation**: Validate the bytecode or address before updating `referenceContractAddress`.

---

### 3. **Lack of Proper Input Validation**
   - **Unvalidated `_newOwner` or `_newAddress`**:
     - Functions like `changeUberOwner()`, `setReferenceContractAddress()`, and others accept arbitrary addresses, which could result in incorrect or malicious inputs.
     - **Mitigation**: Validate correctness of the address (e.g., ensure it points to a valid contract or wallet).
   - **Dangerous `_timestamps` Array Manipulation**:
     - The `_timestamps` array in `createMarket()` could cause issues.
     - Specifically, there's only light validation for `_timestamps[0]`, `_timestamps[1]`, and `_timestamps[2]` (market opening, locking, and resolution times).
     - **Mitigation**: Add thorough boundary checks, e.g., validate all timestamps against current time, etc.

---

### 4. **Overflows / Gas Inefficiencies**
   - **Gas Overflow/Infinite Loops**:
     - Function `createMarket()` includes a `for` loop iterating over `_cardAffiliateAddresses` and `_tokenURIs`, with no explicit check for very large arrays.
       - If the arrays are excessively large, this could cause **out-of-gas errors** or make the transaction expensive.
     - **Mitigation**: Explicitly restrict input array sizes.

---

### 5. **Issues with Event Emission**
   - Critical settings (e.g., `changeUberOwner()`, `setArbitrator()`, etc.) do not emit events after changes are made.
     - Lack of events makes it harder to track important changes on-chain.
     - **Mitigation**: Emit events for every state-changing function.

---

### 6. **External Call Risks**
   - Several external calls are made without verifying their success:
     - `Clones.clone()`
     - `treasury.checkSponsorship()`
     - `nfthub.mint()`
   - Example: In `createMarket()`, if `nfthub.mint` fails, the entire process reverts.
     - **Mitigation**: Wrap external calls in inline checks, or use `try-catch` blocks where necessary.

---

### 7. **Potential Reentrancy Risks**
   - While most functions don't handle direct token transfers, the use of external calls to `nfthub`, `orderbook`, and `treasury` may introduce indirect reentrancy risks, especially in future integrations.
     - **Mitigation**: Follow the “Checks-Effects-Interactions” pattern rigorously.

---

### 8. **Fixed Ownership (`uberOwner`) Manipulation**
   - Functions like `setReferenceContractAddress()` and `changeUberOwner()` depend on `uberOwner`, which bypasses `onlyOwner`. This creates **multiple centralized access points** for critical changes.
     - If `uberOwner` is compromised, it would allow the attacker to replace the reference contract or set a malicious owner.
     - **Mitigation**: Introduce stricter access control.

---

### 9. **Lack of Upgrade Plan for Key State Variables**
   - Core variables like `treasury`, `nfthub`, and `orderbook` are central to system operation, yet they can only be updated by the `onlyOwner`.
   - The architecture doesn't explicitly support **proxy-based upgrades** for resilience and maintainability.
   - **Mitigation**: Use the Transparent Proxy Pattern.

---

### 10. **Insufficient Protections for Critical State Modifications**
   - No explicit delays or safeguards are present for sudden changes (e.g., approval/unapproval of addresses in mappings: `isGovernor`, `isAffiliateApproved`, etc.).
   - Sudden modifications could disrupt critical workflows or allow malicious actors to exploit newly approved/removed addresses.
   - **Mitigation**: Use a **time-locked modifier** for sensitive operations.

---

### 11. **Hardcoded Parameters**
   - Constants like `setTimeout(86400)` or `setNFTMintingLimit(60)` are effectively hardcoded during initialization.
     - If these values need adjustment due to evolving requirements, it requires redeployment or owner intervention.
     - **Mitigation**: Maintain update flexibility but tie changes to community/governance approvals.

---

### 12. **Missing Enumerable Validations for Markets**
   - Functions like `getMostRecentMarket()` assume that there are always markets **in existence** for the given `_mode`.
     - If `marketAddresses[_mode]` is empty, this function will underflow or revert with an out-of-bounds error.
     - **Mitigation**: Add a pre-condition check: `marketAddresses[_mode].length > 0`.

---

### 13. **Insufficient Visibility into NftHub State Changes**
   - Operations involving `nfthub` (e.g., `mint`, `addMarket`) lack detailed error handling or event transparency.
     - Since this appears critical to NFT minting, issues here could impact the marketplace heavily.
     - **Mitigation**: Add return value checks for state-changing calls.

---

### 14. **Trap Card Vulnerability**
   - The function `changeTrapCardsIfUnapproved()` toggles `trapIfUnapproved` without enforcing **reason-based changes** or any checks on marketplaces or affiliates.
   - A malicious actor with ownership access can flip this variable unpredictably.
   - **Mitigation**: Establish additional runtime checks and evidence requirements for altering such flags.

---

## Summary of Vulnerabilities
| **Vulnerability**                                  | **Type**                  | **Severity** |
| -------------------------------------------------- | ------------------------- | ------------ |
| Centralization Risk (onlyOwner/uberOwner)          | Governance Abuse          | High         |
| Reference Contract Cloning Risk                   | External Contract Risk    | High         |
| Array Loop Issues (Timestamps, Affiliates)         | Gas/Logic Inefficiency    | Medium       |
| Lack of Input Validation & Event Emission          | Validation/Transparency   | Medium       |
| Hardcoded Parameters                               | Upgradability             | Medium       |
| Potential Reentrancy (External Calls)              | Reentrancy Risk           | Low to Medium|
| Missing Safeguards for State Modifications         | Governance Abuse          | Low to Medium|

By addressing these vulnerabilities, the `RCFactory` contract can be made more robust and resilient to both internal misconfigurations and external attacks.","---

### **Analysis of Alignment Between Issue Report and Response List**

---

#### **[M-05] RCFactory.createMarket() does not enforce _timestamps validation**

**Report Description**:
The `RCFactory.createMarket()` function does not enforce `_timestamps[1]` and `_timestamps[2]` being larger than `_timestamps[0]`. This lack of validation risks logical errors in the market's progression through its states (CLOSED → OPEN → LOCKED → WITHDRAW). Without ensuring these timestamps are sequential, the contract may operate in an invalid or unpredictable state.

**Match in Response List**:
**Matched with ""Lack of Proper Input Validation"" → ""Dangerous _timestamps Array Manipulation"".**

**Validation**:
**Partially Correct**. The response identifies `_timestamps` in `createMarket()` as a potential source of issues, mentioning ""light validation"" as a problem and suggesting adding thorough boundary checks. However, the response does not specifically highlight the requirement for `_timestamps[1]` and `_timestamps[2]` to be larger than `_timestamps[0]`, which is the critical logical error pointed out in the issue report.

**Suggestions**:
- The response should explicitly state that `_timestamps[1]` (locking time) and `_timestamps[2]` (resolution time) must be strictly greater than `_timestamps[0]` (opening time).
- Propose a validation mechanism to enforce sequential timestamps, such as:
  ```solidity
  require(_timestamps[0] < _timestamps[1] && _timestamps[1] < _timestamps[2], ""Timestamps must be sequential"");
  ```

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[3] Dangerous _timestamps Array Manipulation**

**Response Description**:
The `_timestamps` array in `createMarket()` is flagged for having insufficient validation. The response recommends adding boundary checks, particularly against the current time.

**Assessment**:
**Valid Concern**, but partially related. The suggestion for validating `_timestamps` is on the right track but lacks specific recommendations for enforcing sequential logic, which is essential for the correct functioning of the contract.

**Recommendations**:
- Enhance the response by explicitly requiring `_timestamps[1]` and `_timestamps[2]` to be larger than `_timestamps[0]` as a necessary logical condition.
- Validate against current block timestamps where applicable to prevent setting invalid times (e.g., past timestamps).

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None identified for full correctness in addressing the issue.

#### **Partially Correct Matches**:
- **[M-05] RCFactory.createMarket() does not enforce _timestamps validation**: Matched with ""Dangerous _timestamps Array Manipulation"" but lacks explicit coverage of the need for sequential timestamps.

#### **Missed Issues from Issue Report**:
- None. The `_timestamps` issue is partially addressed but requires refinement.

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
- **[3] Dangerous _timestamps Array Manipulation**: Valid but incomplete concern about insufficient timestamp validation. Refinement needed to address logical sequence requirements.

---

This analysis suggests that while the responses align partially with the reported issue, further specificity and clarity are required to fully address the problem. Additional recommendations are provided to strengthen the response.",0,1,0,14,"```
None.
```",0.0,0
,,,,,,,,4,8,,,2,6,4,47,,,