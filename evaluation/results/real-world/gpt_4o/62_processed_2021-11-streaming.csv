nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
Locke.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";

// ====== Governance =====
contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    /// Update pending governor
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    /// Accepts governorship
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    /// Remove governor
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    // ====== Modifiers =======
    /// Governed function
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    // ====== Modifiers =======
    /// Governed function
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    /// Emergency governed function
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}

// ====== Stream =====
contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    // ======= Structs ========
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    // ======= Storage ========
    // ==== Immutables =====
    // stream start time
    uint32 private immutable startTime;
    // length of stream
    uint32 private immutable streamDuration;
    // length of time depositTokens are locked after stream ends
    uint32 private immutable depositLockDuration;
    // length of time rewardTokens are locked after stream ends
    uint32 private immutable rewardLockDuration;

    // end of stream
    uint32 private immutable endStream;
    // end of deposit lock
    uint32 private immutable endDepositLock;
    // end of reward lock
    uint32 private immutable endRewardLock;

    // Token given to depositer
    address public immutable rewardToken;
    // Token deposited
    address public immutable depositToken;

    // This stream's id
    uint64 public immutable streamId;

    // fee percent on reward tokens
    uint16 private immutable feePercent;
    // are fees enabled
    bool private immutable feeEnabled;

    // deposits are basically a *sale* to the stream creator if true
    bool public immutable isSale;

    // stream creator
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    // ============

    //  == sloc a ==
    // internal reward token amount to be given to depositors
    uint112 private rewardTokenAmount;
    // internal deposit token amount locked/to be sold to stream creator
    uint112 private depositTokenAmount;
    // ============

    // == slot b ==
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    // ============

    // == slot c ==
    uint256 private cumulativeRewardPerToken;
    // ============

    // == slot d ==
    uint256 private totalVirtualBalance;
    // ============

    // == slot e ==
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    // ============

    // mapping of address to number of tokens not yet streamed over
    mapping (address => TokenStream) public tokensNotYetStreamed;

    // external incentives to stream creator
    mapping (address => uint112) public incentives;

    // ======= Events ========
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    // ======= Modifiers ========
    modifier updateStream(address who) {
        // save bytecode space by making it a jump instead of inlining at cost of gas
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            // set lastUpdates if need be
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            // accumulate reward per token info
            cumulativeRewardPerToken = rewardPerToken();

            // update user rewards
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            // update users last cumulative reward per token
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            // update users unstreamed balance
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                // some time has passed since this user last interacted
                // update ts not yet streamed
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            // handle global unstreamed
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            // stream tokens over
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            // already ensure that blocktimestamp is less than endStream so guaranteed ok here
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) // inherit factory governance
        public 
    {
        // set fee info
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        // limit feePercent
        require(feePercent < 10000, ""fee"");
    
        // store streamParams
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        // set tokens
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        // set streamId
        streamId = _streamId;

        // set sale info
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    /**
     * @dev Returns relevant internal token amounts
    **/
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    /**
     * @dev Returns fee parameters
    **/
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    /**
     * @dev Returns stream parameters
    **/
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            // ∆time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        // duration / timeRemaining * amount
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    /**
     * @dev Allows _anyone_ to fund this stream, if its before the stream start time
    **/
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        // transfer from sender
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        // if fee is enabled, take a fee
        if (feeEnabled) {
            // Safety:
            //  1. feePercent & y are casted up to u256, so cannot overflow when multiplying
            //  2. downcast is safe because (x*y)/MAX_X is guaranteed to be smaller than y which is uint112
            //  3. amount is guaranteed to be greater than feeAmt
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            // since this operation can be repeated, we cannot assume no overflow so use checked math
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

    /**
     *  @dev Deposits depositTokens into this stream
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // require(block.timestamp < endStream, ""stake:!stream"");

        // transfer tokens over
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            // not a straight sale, so give the user some receipt tokens
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

    /**
     *  @dev Allows a stream depositor to withdraw a specific amount of depositTokens during a stream,
     *  up to their tokensNotYetStreamed amount
     * 
     *  additionally, updates tokensNotYetStreamed
    */ 
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        // do the transfer
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

    /**
     *  @dev Allows a stream depositor to exit their entire remaining tokens that haven't streamed
     *  and burns receiptTokens if its not a sale.
     * 
     *  additionally, updates tokensNotYetStreamed. Lock is done in withdraw
    */ 
    function exit() public updateStream(msg.sender) {
        // checked in updateStream
        // is the stream still going on? thats the only time a depositer can withdraw
        // require(block.timestamp < endStream, ""withdraw:!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

    /**
     *  @dev Allows anyone to incentivize this stream with extra tokens
     *  and requires the incentive to not be the reward or deposit token
    */ 
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

    /**
     *  @dev Allows the stream creator to claim an incentive once the stream is done
    */ 
    function claimIncentive(address token) public lock {
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

    /**
     *  @dev Allows a receipt token holder to reclaim deposit tokens if the deposit lock is done & their receiptToken amount
     *  is greater than the requested amount
    */ 
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        // NOTE: given that endDepositLock is strictly *after* the last time withdraw or exit is callable
        // we dont need to updateStream(msg.sender)
        require(amount > 0, ""amt"");

        // is the stream over + the deposit lock period over? thats the only time receiptTokens can be burned for depositTokens after stream is over
        require(block.timestamp > endDepositLock, ""lock"");

        // burn the receiptTokens
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        // send the receipt token holder back the funds
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

    /**
     *  @dev Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens
    */ 
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        // accumulate reward per token info
        cumulativeRewardPerToken = rewardPerToken();

        // update user rewards
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        // update users last cumulative reward per token
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        // transfer the tokens
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

    /**
     *  @dev Allows a creator to claim sold tokens if the stream has ended & this contract is a sale
    */ 
    function creatorClaimSoldTokens(address destination) public lock {
        // can only claim when its a sale
        require(isSale, ""!sale"");

        // only can claim once
        require(!claimedDepositTokens, ""claimed"");
        // creator is claiming
        require(msg.sender == streamCreator, ""!creator"");
        // stream ended
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

    /**
     *  @dev Allows the governance contract of the factory to select a destination
     *  and transfer fees (in rewardTokens) to that address totaling the total fee amount
    */ 
    function claimFees(address destination) public lock externallyGoverned {
        // Stream is done
        require(block.timestamp >= endStream, ""stream"");

        // reset fee amount
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            // transfer and emit event
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            // transfer and emit event
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    // ======== Non-protocol functions ========

    /**
     *  @dev Allows the stream creator to save tokens
     *  There are some limitations to this:
     *      1. if its deposit token:
     *          - DepositLock is fully done
     *          - There are excess deposit tokens (balance - depositTokenAmount)
     *      2. if its the reward token:
     *          - RewardLock is fully done
     *          - Excess defined as balance - (rewardTokenAmount + rewardTokenFeeAmount)
     *      3. if incentivized:
     *          - excesss defined as bal - incentives[token]
    */ 
    function recoverTokens(address token, address recipient) public lock {
        // NOTE: it is the stream creators responsibility to save
        // tokens on behalf of their users.
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            // get the balance of this contract
            // check what isnt claimable by either party
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            // allow saving of the token
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            // check current balance vs internal balance
            //
            // NOTE: if a token rebases, i.e. changes balance out from under us,
            // most of this contract breaks and rugs depositors. this isn't exclusive
            // to this function but this function would in theory allow someone to rug
            // and recover the excess (if it is worth anything)

            // check what isnt claimable by depositors and governance
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        // not reward token nor deposit nor incentivized token, free to transfer
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    /**
     *  @dev Allows anyone to flashloan reward or deposit token for a 10bps fee
    */
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        // the `to` contract should have a public function with the signature:
        // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; // 10bps fee

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    /**
     *  @dev Allows inherited governance contract to call functions on behalf of this contract
     *  This is a potentially dangerous function so to ensure trustlessness, *all* balances
     *  that may matter are guaranteed to not change.
     * 
     *  The primary usecase is for claiming potentially airdrops that may have accrued on behalf of this contract
    */
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        // cannot have an active incentive for the callee
        require(incentives[who] == 0, ""inc"");
        // cannot be to deposit token nor reward token
        require(who != depositToken && who != rewardToken, ""erc"");

        // get token balances
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        // require no change in balances
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    // ======= Structs ========
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    // ======= Storage ========
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; // 500/10000 == 5%

    // =======  Events  =======
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    /**
     * @dev Deploys a minimal contract pointing to streaming logic. This contract will also be the token contract
     * for the receipt token. It custodies the depositTokens until depositLockDuration is complete. After
     * lockDuration is completed, the depositTokens can be claimed by the original depositors
     * 
    **/
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        // perform checks

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        // TODO: figure out sane salt, i.e. streamid + x? streamid guaranteed to be unique
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        // DATA VALIDATION:
        //  there is no real concept of ""sane"" limits here, and if misconfigured its ultimated
        //  not a massive deal so no data validation is done
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",6655,856,"[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`, which may cause fund loss to users“uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);”
In the current implementation, `depositTokenFlashloanFeeAmount` is not excluded when calculating `excess` depositToken. Therefore, the stream creator can call `recoverTokens(depositToken, recipient)` and retrieve `depositTokenFlashloanFeeAmount` if there are any.

[H-02] Tokens can be stolen when `depositToken == rewardToken`
The `Streaming` contract allows the deposit and reward tokens to be the same token.
The reward and deposit balances are also correctly tracked independently in depositTokenAmount and rewardTokenAmount. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:
“function recoverTokens(address token, address recipient) public lock {}”

[H-03] Reward token not correctly recovered
The Streaming contract allows recovering the reward token by calling `recoverTokens(rewardToken, recipient)`.
However, the excess amount is computed incorrectly as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`:
“function recoverTokens(address token, address recipient) public lock {“

[H-04] Improper implementation of arbitraryCall() allows protocol gov to steal funds from users' wallets
Function `arbitraryCall`
“function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {“
When an incentiveToken is claimed after `endStream`, `incentives[who]` will be 0 for that `incentiveToken`.
If the protocol gov is malicious or compromised, they can call `arbitraryCall()` with the address of the incentiveToken as who and `transferFrom()` as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.

[H-05] Possible incentive theft through the arbitraryCall() function
The `Locke.arbitraryCall()` function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).
However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().

[H-06] Creating rewardTokens without streaming depositTokensfunction `updateStreamInternal`
`stake` and `withdraws` can generate rewardTokens without streaming depositTokens. It does not matter whether the stream is a sale or not.
The following lines can increase the reward balance on a `withdraw` some time after `stake`:[H-07] Business logic bug in `_abdicate()` function - 2 Bugs
The `_abdicate()` function at  is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the ""gov"" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.

[H-08] ts.tokens sometimes calculated incorrectly
Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.
Now after some time he stakes some tokens again. At the second stake `updateStream()` is called and the following if condition is false because `ts.tokens==0`
“if (acctTimeDelta > 0 && ts.tokens > 0) {“
Thus `ts.lastUpdate` is not updated and stays at the value from the first withdraw. Now he does a second withdraw. `updateStream()` is called an calculates the updated value of `ts.tokens`. However it uses `ts.lastUpdate`, which is the time from the first withdraw and not from the second stake. So the value of `ts.token` is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.

[H-09] DOS while dealing with erc20 when value(i.e amount*decimals) is high but less than type(uint112).max
reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls `exit` or `withdraw` function it will revert and that user will not able to withdraw funds permanentaly.

[H-10] recoverTokens doesn't work when isSale is true
In `recoverTokens` function, the logic to calculate the excess number of deposit tokens in the contract is:
""uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);”
This breaks in the case where isSale is true and the deposit tokens have already been claimed through the use of creatorClaimSoldTokens. In this case, redemeedDepositTokens will be zero, and depositTokenAmount will still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.

[M-02] Any `arbitraryCall` gathered airdrop can be stolen with recoverTokens
Any airdrop gathered with arbitraryCall will be immediately lost as an attacker can track arbitraryCall transactions and back run them with calls to recoverTokens, which doesn't track any tokens besides reward, deposit and incentive tokens, and will give the airdrop away.

[M-04] arbitraryCall() can get blocked by an attacker
`arbitraryCall()` use case is to claim airdrops by ""gov"". If the address ""who"" is a token that could be send as an incentive by an attacker via createIncentive() then such claim can be made unusable, because on L735 there is a `require(incentives[who] == 0, ""inc"");` that reverts if a ""who"" token was received as an incentive.
In this case the the `incentives[who]` can be set to 0 by the stream creator by calling claimIncentive() but only after the stream has ended according to require(block.timestamp >= endStream, ""stream""); (L520)",12,"pragma solidity ^0.8.0;

import ""./LockeERC20.sol"";
import ""solmate/utils/SafeTransferLib.sol"";
import ""solmate/tokens/ERC20.sol"";


contract Governed {
    address public gov;
    address private pendingGov;
    address public emergency_gov;

    event NewGov(address indexed oldGov, address indexed newGov);
    event NewPendingGov(address indexed oldPendingGov, address indexed newPendingGov);

    constructor(address _governor, address _emergency_governor) public {
        gov = _governor;
        emergency_gov = _emergency_governor;
    }

    function governorship() public view returns (address, address, address) {
        return (gov, emergency_gov, pendingGov);
    }

    
    function setPendingGov(address newPendingGov) governed public {
        address old = pendingGov;
        pendingGov = newPendingGov;
        emit NewPendingGov(old, newPendingGov);
    }

    
    function acceptGov() public {
        require(pendingGov == msg.sender, ""!pending"");
        address old = gov;
        gov = pendingGov;
        emit NewGov(old, pendingGov);
    }

    function setEmergencyGov(address who) public governed {
        emergency_gov = who;
    } 

    
    function __abdicate() governed public {
        address old = gov;
        gov = address(0);
        emit NewGov(old, address(0));
    }

    
    
    modifier governed {
        require(msg.sender == gov, ""!gov"");
        _;
    }

    
    modifier emergency_governed {
        require(msg.sender == gov || msg.sender == emergency_gov, ""!egov"");
        _;
    }
}

interface IGoverned {
    function gov() external view returns (address);
    function emergency_gov() external view returns (address);
}

abstract contract ExternallyGoverned {
    IGoverned public gov;

    constructor(address governor) {
        gov = IGoverned(governor);
    }

    
    
    modifier externallyGoverned {
        require(msg.sender == gov.gov(), ""!gov"");
        _;
    }

    
    modifier externallyEmergencyGoverned {
        require(msg.sender == gov.gov() || msg.sender == gov.emergency_gov(), ""!e_gov"");
        _;
    }
}

interface LockeCallee {
    function lockeCall(address initiator, address token, uint256 amount, bytes calldata data) external;
}


contract Stream is LockeERC20, ExternallyGoverned {
    using SafeTransferLib for ERC20;    
    
    struct TokenStream {
        uint256 lastCumulativeRewardPerToken;
        uint256 virtualBalance;
        uint112 rewards;
        uint112 tokens;
        uint32 lastUpdate;
        bool merkleAccess;
    }

    
    
    
    uint32 private immutable startTime;
    
    uint32 private immutable streamDuration;
    
    uint32 private immutable depositLockDuration;
    
    uint32 private immutable rewardLockDuration;

    
    uint32 private immutable endStream;
    
    uint32 private immutable endDepositLock;
    
    uint32 private immutable endRewardLock;

    
    address public immutable rewardToken;
    
    address public immutable depositToken;

    
    uint64 public immutable streamId;

    
    uint16 private immutable feePercent;
    
    bool private immutable feeEnabled;

    
    bool public immutable isSale;

    
    address public immutable streamCreator;

    uint112 private immutable depositDecimalsOne;
    

    
    
    uint112 private rewardTokenAmount;
    
    uint112 private depositTokenAmount;
    

    
    uint112 private rewardTokenFeeAmount;
    uint112 private depositTokenFlashloanFeeAmount;
    uint8 private unlocked = 1;
    bool private claimedDepositTokens;
    

    
    uint256 private cumulativeRewardPerToken;
    

    
    uint256 private totalVirtualBalance;
    

    
    uint112 public unstreamed;
    uint112 private redeemedDepositTokens;
    uint32 private lastUpdate;
    

    
    mapping (address => TokenStream) public tokensNotYetStreamed;

    
    mapping (address => uint112) public incentives;

    
    event StreamFunded(uint256 amount);
    event Staked(address indexed who, uint256 amount);
    event Withdrawn(address indexed who, uint256 amount);
    event StreamIncentivized(address indexed token, uint256 amount);
    event StreamIncentiveClaimed(address indexed token, uint256 amount);
    event SoldTokensClaimed(address indexed who, uint256 amount);
    event DepositTokensReclaimed(address indexed who, uint256 amount);
    event FeesClaimed(address indexed token, address indexed who, uint256 amount);
    event RecoveredTokens(address indexed token, address indexed recipient, uint256 amount);
    event RewardsClaimed(address indexed who, uint256 amount);
    event Flashloaned(address indexed token, address indexed who, uint256 amount, uint256 fee);

    
    modifier updateStream(address who) {
        
        updateStreamInternal(who);
        _;
    }

    function updateStreamInternal(address who) internal {
        require(block.timestamp < endStream , ""!stream"");
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        if (block.timestamp >= startTime) {
            
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = uint32(block.timestamp);
            }
            if (lastUpdate == 0) {
                lastUpdate = uint32(block.timestamp);
            }

            
            cumulativeRewardPerToken = rewardPerToken();

            
            ts.rewards = earned(ts, cumulativeRewardPerToken);
            
            ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

            
            uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;
            if (acctTimeDelta > 0 && ts.tokens > 0) {
                
                
                ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));
                ts.lastUpdate = uint32(block.timestamp);
            }

            
            uint32 tdelta = uint32(block.timestamp - lastUpdate);
            
            if (tdelta > 0 && unstreamed > 0) {
                uint256 globalStreamingSpeedPerSecond = (uint256(unstreamed) * 10**6)/ (endStream - lastUpdate);
                unstreamed -= uint112((uint256(tdelta) * globalStreamingSpeedPerSecond) / 10**6);
            }
            
            lastUpdate = uint32(block.timestamp);
        } else {
            if (ts.lastUpdate == 0) {
                ts.lastUpdate = startTime;
            }
            if (lastUpdate == 0) {
                lastUpdate = startTime;
            }
        }
    }


    function lockInternal() internal {
        require(unlocked == 1, ""re"");
        unlocked = 2;
    }
    modifier lock {
        lockInternal();
        _;
        unlocked = 1;
    }

    constructor(
        uint64 _streamId,
        address creator,
        bool _isSale,
        address _rewardToken,
        address _depositToken,
        uint32 _startTime,
        uint32 _streamDuration,
        uint32 _depositLockDuration,
        uint32 _rewardLockDuration,
        uint16 _feePercent,
        bool _feeEnabled

    )
        LockeERC20(_depositToken, _streamId, _startTime + _streamDuration)
        ExternallyGoverned(msg.sender) 
        public 
    {
        
        feePercent = _feePercent;
        feeEnabled = _feeEnabled;

        
        require(feePercent < 10000, ""fee"");
    
        
        startTime = _startTime;
        streamDuration = _streamDuration;
        depositLockDuration = _depositLockDuration;
        rewardLockDuration = _rewardLockDuration;

        endStream = startTime + streamDuration;
        endDepositLock = endStream + depositLockDuration;
        endRewardLock = endStream + rewardLockDuration;
    
        
        depositToken = _depositToken;
        rewardToken = _rewardToken;

        
        streamId = _streamId;

        
        isSale = _isSale;
    
        streamCreator = creator;

        depositDecimalsOne = uint112(10**ERC20(depositToken).decimals());
    }

    
    function tokenAmounts() public view returns (uint112, uint112, uint112, uint112) {
        return (rewardTokenAmount, depositTokenAmount, rewardTokenFeeAmount, depositTokenFlashloanFeeAmount);
    }

    
    function feeParams() public view returns (uint16, bool) {
        return (feePercent, feeEnabled);
    }

    
    function streamParams() public view returns (uint32,uint32,uint32,uint32) {
        return (
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration
        );
    }

    function lastApplicableTime() internal view returns (uint32) {
        return block.timestamp <= endStream ? uint32(block.timestamp) : endStream;
    }

    function rewardPerToken() public view returns (uint256) {
        if (totalVirtualBalance == 0) {
            return cumulativeRewardPerToken;
        } else {
            
            return cumulativeRewardPerToken + (
                ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration) 
                / totalVirtualBalance
            );
        }
    }

    function dilutedBalance(uint112 amount) internal view returns (uint256) {
        
        if (block.timestamp < startTime) {
            return amount;
        } else {
            uint32 timeRemaining = endStream - uint32(block.timestamp);
            return ((uint256(streamDuration) * amount * 10**6) / timeRemaining) / 10**6;
        }
    }

    function getEarned(address who) public view returns (uint256) {
        TokenStream storage ts = tokensNotYetStreamed[who];
        return earned(ts, rewardPerToken());
    }

    function earned(TokenStream storage ts, uint256 currCumRewardPerToken) internal view returns (uint112) {
        return uint112(ts.virtualBalance * (currCumRewardPerToken - ts.lastCumulativeRewardPerToken) / depositDecimalsOne) + ts.rewards;
    }

    
    function fundStream(uint112 amount) public lock {
        require(amount > 0, ""amt"");
        require(block.timestamp < startTime, ""time"");
        uint112 amt;

        
        uint256 prevBal = ERC20(rewardToken).balanceOf(address(this));
        ERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(rewardToken).balanceOf(address(this));
        require(newBal < type(uint112).max && newBal > prevBal, ""erc"");

        amount = uint112(newBal - prevBal);
        
        if (feeEnabled) {
            
            
            
            
            uint112 feeAmt;
            unchecked {
                feeAmt = uint112(uint256(feePercent) * uint256(amount) / 10000); 
                amt = amount - feeAmt;
            }

            
            rewardTokenFeeAmount += feeAmt;
            rewardTokenAmount += amt;
        } else {
            amt = amount;
            rewardTokenAmount += amt;
        }
        
        emit StreamFunded(amt);
    }

     
    function stake(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        
        

        
        uint256 prevBal = ERC20(depositToken).balanceOf(address(this));
        ERC20(depositToken).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(depositToken).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");
        
        uint112 trueDepositAmt = uint112(newBal - prevBal);

        depositTokenAmount += trueDepositAmt;
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        ts.tokens += trueDepositAmt;

        uint256 virtualBal = dilutedBalance(trueDepositAmt);
        ts.virtualBalance += virtualBal;
        totalVirtualBalance += virtualBal;
        unstreamed += trueDepositAmt;

        if (!isSale) {
            
            _mint(msg.sender, trueDepositAmt);
        } else {
        }

        emit Staked(msg.sender, trueDepositAmt);
    }

     
    function withdraw(uint112 amount) public lock updateStream(msg.sender) {
        require(amount > 0, ""amt"");

        
        
        
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];

        require(ts.tokens >= amount, ""amt"");
        ts.tokens -= amount;

        uint256 virtualBal = dilutedBalance(amount);
        ts.virtualBalance -= virtualBal;
        totalVirtualBalance -= virtualBal;
        depositTokenAmount -= amount;
        if (!isSale) {
            _burn(msg.sender, amount);
        } else {
        }

        
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit Withdrawn(msg.sender, amount);
    }

     
    function exit() public updateStream(msg.sender) {
        
        
        
        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        uint112 amount = ts.tokens;
        withdraw(amount);
    }

     
    function createIncentive(address token, uint112 amount) public lock {
        require(token != rewardToken && token != depositToken, ""inc"");
        
        uint256 prevBal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        uint256 newBal = ERC20(token).balanceOf(address(this));
        require(newBal <= type(uint112).max && newBal > prevBal, ""erc"");

        uint112 amt = uint112(newBal - prevBal);
        incentives[token] += amt;
        emit StreamIncentivized(token, amt);
    }

     
    function claimIncentive(address token) public lock {
        
        require(msg.sender == streamCreator, ""!creator"");
        
        require(block.timestamp >= endStream, ""stream"");
        uint112 amount = incentives[token];
        require(amount > 0, ""amt"");
        incentives[token] = 0;
        ERC20(token).safeTransfer(msg.sender, amount);
        emit StreamIncentiveClaimed(token, amount);
    }

     
    function claimDepositTokens(uint112 amount) public lock {
        require(!isSale, ""sale"");
        
        
        require(amount > 0, ""amt"");

        
        require(block.timestamp > endDepositLock, ""lock"");

        
        _burn(msg.sender, amount);

        redeemedDepositTokens += amount;

        
        ERC20(depositToken).safeTransfer(msg.sender, amount);

        emit DepositTokensReclaimed(msg.sender, amount);
    }

     
    function claimReward() public lock {
        require(block.timestamp > endRewardLock, ""lock"");

        TokenStream storage ts = tokensNotYetStreamed[msg.sender];
        
        cumulativeRewardPerToken = rewardPerToken();

        
        ts.rewards = earned(ts, cumulativeRewardPerToken);
        
        ts.lastCumulativeRewardPerToken = cumulativeRewardPerToken;

        lastUpdate = lastApplicableTime();

        uint256 rewardAmt = ts.rewards;
        ts.rewards = 0;

        require(rewardAmt > 0, ""amt"");

        
        ERC20(rewardToken).safeTransfer(msg.sender, rewardAmt);

        emit RewardsClaimed(msg.sender, rewardAmt);
    }

     
    function creatorClaimSoldTokens(address destination) public lock {
        
        require(isSale, ""!sale"");

        
        require(!claimedDepositTokens, ""claimed"");
        
        require(msg.sender == streamCreator, ""!creator"");
        
        require(block.timestamp >= endStream, ""stream"");
        
        uint112 amount = depositTokenAmount;
        claimedDepositTokens = true;

        ERC20(depositToken).safeTransfer(destination, amount);

        emit SoldTokensClaimed(destination, amount);
    }

     
    function claimFees(address destination) public lock externallyGoverned {
        
        require(block.timestamp >= endStream, ""stream"");

        
        uint112 fees = rewardTokenFeeAmount;
        if (fees > 0) {
            rewardTokenFeeAmount = 0;

            
            ERC20(rewardToken).safeTransfer(destination, fees);
            emit FeesClaimed(rewardToken, destination, fees);
        }

        fees = depositTokenFlashloanFeeAmount;
        if (fees > 0) {
            depositTokenFlashloanFeeAmount = 0;

            
            ERC20(depositToken).safeTransfer(destination, fees);

            emit FeesClaimed(depositToken, destination, fees);
        }
        
    }

    

     
    function recoverTokens(address token, address recipient) public lock {
        
        
        require(msg.sender == streamCreator, ""!creator"");
        if (token == depositToken) {
            require(block.timestamp > endDepositLock, ""time"");
            
            
            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);
            
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }
        
        if (token == rewardToken) {
            require(block.timestamp > endRewardLock, ""time"");
            
            
            
            
            
            

            
            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);
            ERC20(token).safeTransfer(recipient, excess);

            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        if (incentives[token] > 0) {
            require(block.timestamp >= endStream, ""stream"");
            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];
            ERC20(token).safeTransfer(recipient, excess);
            emit RecoveredTokens(token, recipient, excess);
            return;
        }

        
        uint256 bal = ERC20(token).balanceOf(address(this));
        ERC20(token).safeTransfer(recipient, bal);
        emit RecoveredTokens(token, recipient, bal);
    }

    
    function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {
        require(token == depositToken || token == rewardToken, ""erc"");

        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        ERC20(token).safeTransfer(to, amount);

        
        
        LockeCallee(to).lockeCall(msg.sender, token, amount, data);

        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        uint112 feeAmt = amount * 10 / 10000; 

        if (token == depositToken) {
            depositTokenFlashloanFeeAmount += feeAmt;
            require(preDepositTokenBalance + feeAmt <= postDepositTokenBalance, ""f1"");
            require(preRewardTokenBalance <= postRewardTokenBalance, ""f2"");
        } else {
            rewardTokenFeeAmount += feeAmt;
            require(preDepositTokenBalance <= postDepositTokenBalance, ""f3"");
            require(preRewardTokenBalance + feeAmt <= postRewardTokenBalance, ""f4"");
        }

        emit Flashloaned(token, msg.sender, amount, feeAmt);
    }

    
    function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {
        
        require(incentives[who] == 0, ""inc"");
        
        require(who != depositToken && who != rewardToken, ""erc"");

        
        uint256 preDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 preRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));

        (bool success, bytes memory _ret) = who.call(data);
        require(success);

        
        uint256 postDepositTokenBalance = ERC20(depositToken).balanceOf(address(this));
        uint256 postRewardTokenBalance = ERC20(rewardToken).balanceOf(address(this));
        require(preDepositTokenBalance == postDepositTokenBalance && preRewardTokenBalance == postRewardTokenBalance, ""erc"");
    }
}

contract StreamFactory is Governed {

    
    struct GovernableStreamParams {
        uint32 maxDepositLockDuration;
        uint32 maxRewardLockDuration;
        uint32 maxStreamDuration;
        uint32 minStreamDuration;
    }

    struct GovernableFeeParams {
        uint16 feePercent;
        bool feeEnabled;
    }

    
    GovernableStreamParams public streamParams;
    GovernableFeeParams public feeParams;
    uint64 public currStreamId; 

    uint16 constant MAX_FEE_PERCENT = 500; 

    
    event StreamCreated(uint256 indexed stream_id, address stream_addr);
    event StreamParametersUpdated(GovernableStreamParams oldParams, GovernableStreamParams newParams);
    event FeeParametersUpdated(GovernableFeeParams oldParams, GovernableFeeParams newParams);

    constructor(address _governor, address _emergency_governor) public Governed(_governor, _emergency_governor) {
        streamParams = GovernableStreamParams({
            maxDepositLockDuration: 52 weeks,
            maxRewardLockDuration: 52 weeks,
            maxStreamDuration: 2 weeks,
            minStreamDuration: 1 hours
        });
    }

    
    function createStream(
        address rewardToken,
        address depositToken,
        uint32 startTime,
        uint32 streamDuration,
        uint32 depositLockDuration,
        uint32 rewardLockDuration,
        bool isSale
    )
        public
        returns (Stream)
    {
        

        {
            require(startTime >= block.timestamp, ""past"");
            require(streamDuration >= streamParams.minStreamDuration && streamDuration <= streamParams.maxStreamDuration, ""stream"");
            require(depositLockDuration <= streamParams.maxDepositLockDuration, ""lock"");
            require(rewardLockDuration <= streamParams.maxRewardLockDuration, ""reward"");
        }
        

        
        uint64 that_stream = currStreamId;
        currStreamId += 1;
        bytes32 salt = bytes32(uint256(that_stream));

        Stream stream = new Stream{salt: salt}(
            that_stream,
            msg.sender,
            isSale,
            rewardToken,
            depositToken,
            startTime,
            streamDuration,
            depositLockDuration,
            rewardLockDuration,
            feeParams.feePercent,
            feeParams.feeEnabled
        );

        emit StreamCreated(that_stream, address(stream));

        return stream;
    }

    function updateStreamParams(GovernableStreamParams memory newParams) public governed {
        
        
        
        GovernableStreamParams memory old = streamParams;
        streamParams = newParams;
        emit StreamParametersUpdated(old, newParams);
    }

    function updateFeeParams(GovernableFeeParams memory newFeeParams) public governed {
        require(newFeeParams.feePercent <= MAX_FEE_PERCENT, ""fee"");
        GovernableFeeParams memory old = feeParams;
        feeParams = newFeeParams;
        emit FeeParametersUpdated(old, newFeeParams);
    }
}",4772,10,2,"The provided Solidity code is a complex smart contract implementation related to token streaming, governance, and fund handling. Below is a list of **key vulnerabilities and issues** related to the contract. Each issue is categorized by severity and explained with potential exploits or risks.

---

### **1. Centralization of Power and Privileges**
- **Governance Centralization Risk**:
  - The `gov` (governor) role has significant control over the contract, including updating parameters, abdicating governance (`__abdicate`), and distributing fees via `claimFees`.
  - Misuse of the `gov` or `emergency_gov` role (or compromise of the corresponding private key) could lead to malicious activity, such as setting arbitrary values for sensitive parameters (`setEmergencyGov`, `updateStreamParams`, etc.).
  - No multisig enforced for critical operations—single-point failure for the governor's wallet is a risk.
- **Missing Governor Revocation Checks** (Low Severity):
  - The emergency governor (`emergency_gov`) or `gov` roles could act maliciously or accidentally disable the contract through improper parameter settings.

---

### **2. Reentrancy Risks**
- **Inadequate Reentrancy Protections**:
  - While the `lock` modifier is present and attempts to prevent reentrancy (via the `unlocked` state variable), **state updates in certain functions occur after external calls**, making these functions vulnerable to reentrancy attacks:
    - `withdraw`
    - `claimReward`
    - `recoverTokens`
    - `flashloan`
  - For example, in `withdraw`, tokens are transferred to the user **before updating state variables**, allowing a reentrancy attack to withdraw multiple times.

---

### **3. Lack of Access Control for Certain Functions**
- **Unprotected Sensitive Functions**:
  - The `recoverTokens` function allows a malicious creator (`streamCreator`) to recover tokens erroneously or unexpectedly. This function lacks checks for its potential impact on incentive or reward calculations.
  - `lockeCall` (via `flashloan`) does not directly ensure additional trust validation (e.g., only trusted callee addresses). A malicious actor could exploit this for unintended actions.

---

### **4. Arithmetic Vulnerabilities**
- **Unchecked Arithmetic in `fundStream`**:
  - The function **does not properly validate fee calculations** or handle cases where the calculated fee exceeds `uint112` limits. While Solidity 0.8+ has checked arithmetic, the unchecked block (e.g., fee calculation) could still behave incorrectly when large token values are used.

---

### **5. Mismanagement of Fees**
- **Fee Leakage Risks**:
  - The `claimFees` function does not impose any restrictions on when and how fees can be claimed, aside from being callable by the governor. If fees are set incorrectly or manipulated, users may receive far lower rewards than expected.

---

### **6. Oracle or External Dependency Exploits**
- **External Token Assumptions Without Validation**:
  - The contract assumes standard ERC-20 token behavior (e.g., transfers returning `true`), but some tokens (non-standard ERC20) do not adhere to this behavior, which could potentially result in token loss or incorrect state.
  - For example, contracts like `Tether` (USDT) have ERC20 compliance deficiencies.

---

### **7. Flashloan Arbitrage Opportunities**
- **Weak Flashloan Fee Calculation**:
  - Flashloan fees are calculated as `amount * 10 / 10000`, i.e., 0.1%. This is an **extremely low fee rate** and could be exploited via repeated flashloans arbitrage if the rewards for holding a significant amount of tokens outweigh the cost of the flashloan fee.

---

### **8. Incorrect State Updates**
- **State Update Errors in Token Stream Handling**:
  - The contract uses a combination of `depositTokenAmount`, `totalVirtualBalance`, and `tokensNotYetStreamed[msg.sender].tokens` but does not **validate all states when performing updates**. A malicious user (or unintended state corruption) could cause inconsistencies during the staking, withdrawing, or claiming rewards.

---

### **9. Potential Denial-of-Service (DoS) Scenarios**
- **Denial of Service on Rewards/Deposits**:
  - If the reward or deposit tokens are deliberately transferred (or blocked) by the `streamCreator` or another user, the system could be rendered unusable (e.g., `rewardPerToken` depends on token balances in the contract).
  - Also, failure to handle unexpected ERC-20 token behaviors (e.g., faulty balances) can cause DoS.

---

### **10. Timestamp Manipulation (Minor Risk)**
- Dependency on `block.timestamp` for conditions such as:
  - `startTime`, `endStream`, or calculating time deltas in functions like `updateStreamInternal`, `claimReward`, and `withdraw`.
  - While miner manipulation of timestamps is limited, small manipulations could impact calculations, particularly in time-sensitive functions (e.g., short-duration streams).

---

### **11. Misaligned Assumptions: Decimal Precision**
- Hardcoded precision issues for token decimals (e.g., `depositDecimalsOne = 10**ERC20(depositToken).decimals()`) rely on assumptions regarding how token decimals work. Tokens with unexpected decimal configurations may cause unforeseen behavior in calculations like `rewardPerToken`.

---

### **12. Insufficient Validation on New Stream Creation**
- **No Restrictions on `createStream` Parameters**:
  - Users may create streams with extremely short durations (`1 hour minimum`) or fraudulent parameters (e.g., future timestamps far into the future).
  - There is no restriction to limit spamming or abuse of the `createStream` function, which could lead to excessive gas usage by deploying many unused/empty streams.

---

### **13. Mismanagement of Incentives**
- **Create and Claim Incentive Exploits**:
  - Improper parameter validation and missing access controls allow the `streamCreator` to manipulate incentives in the system to their benefit (`createIncentive`, `claimIncentive`). 
  - Contract behavior when multiple users compete for incentives is unclear.

---

### **14. Contract Deployment via Factory Exploits**
- **Replay Exploits with Predictable Salt**:
  - The `StreamFactory` contract deploys streams using a predictable salt (`bytes32(uint256(that_stream))`). This makes streams susceptible to replay attacks, where malicious actors can precompute stream addresses and claim ownership of certain resources.

---

### Summary Table of Vulnerabilities

| **#** | **Type**                             | **Severity**  |
|-------|--------------------------------------|---------------|
|  1    | Centralized governor control         | High          |
|  2    | Reentrancy vulnerabilities           | High          |
|  3    | Sensitive functions without access control | High    |
|  4    | Arithmetic issues in fee handling    | Medium        |
|  5    | Mismanagement of fee claims          | Medium        |
|  6    | ERC20 token assumptions              | Medium        |
|  7    | Flashloan fee arbitrage              | Medium        |
|  8    | Inconsistent state updates           | Medium        |
|  9    | DoS in rewards or deposits           | Medium        |
| 10    | Timestamp manipulation               | Low           |
| 11    | Token decimal mismatches             | Low           |
| 12    | Weak stream creation validation      | Low           |
| 13    | Incentive system exploits            | Low/Medium    |
| 14    | Predictable salt for deployments     | Low           |

### Remediation Recommendations:
- Use proper **ReentrancyGuard** for preventing reentrancy attacks.
- Introduce **multi-signature governance** for all sensitive roles and operations (`gov`, `emergency_gov`).
- Thoroughly validate **external calls** and **token decimals**.
- Enhance input checks for parameters, `createStream`, `flashloan` fees, and timestamps.
- Implement ERC20 token safety handling libraries (e.g., check token behaviors precisely).","---

### **Analysis of the Alignment Between `issue` and `response_list`**

Given the `issue` and `response_list`, I will analyze each issue for alignment and appropriateness of response. For issues not addressed, those will be explicitly categorized as ""No match found."" Issues in `response_list` that do not correspond to any in `issue` but provide valid or invalid concerns will similarly be analyzed. Each issue from the `issue` report will be evaluated against the provided standardized response list.

---

### **Analyzed Issues**

#### **[H-01] Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`**
**Report Description**:
When calculating `excess` deposit tokens, the `depositTokenFlashloanFeeAmount` is not excluded, enabling the stream creator to retrieve extra tokens mistakenly or maliciously. This potentially causes user fund loss.

**Match in Response List**:
No match found.

**Validation**:
No corresponding remediation or discussion in the `response_list`. This critical issue involving logical correctness and user funds should have ideally been addressed, as it aligns with best practices of ensuring that fee-based calculations are accurate and unintended accesses are avoided.

**Suggestions**:
- Validate calculations of `excess` to exclude `depositTokenFlashloanFeeAmount`.
- Add integration/unit tests to ensure appropriate behavior under a variety of scenarios.

---

#### **[H-02] Tokens can be stolen when `depositToken == rewardToken`**
**Report Description**:
If `depositToken` and `rewardToken` are the same token, the token is recovered twice (once for deposits and once for rewards), leading to potential token theft.

**Match in Response List**:
Partially matches with ""Sensitive functions without access control"" and ""Mismanagement of fee claims"" (Point 3 and Point 5 in the response list).

**Validation**:
Partially correct. The `response_list` mentions `recoverTokens` as a function lacking robust access control, but it does not specifically address the situation where `depositToken == rewardToken`. This oversight is significant and leaves the vulnerability partially unaddressed. Mismanaging token recovery could lead to theft, as highlighted in the report.

**Suggestions**:
- Introduce checks in `recoverTokens` to ensure `depositToken` and `rewardToken` are treated as independent tokens in all logic and that no accidental or malicious recovery occurs.

---

#### **[H-03] Reward token not correctly recovered**
**Report Description**:
The `recoverTokens` function incorrectly computes excess rewards, as the formula does not account for proper reward token calculations.

**Match in Response List**:
Partially matches with ""Incorrect state updates"" (Point 8 in the response list).

**Validation**:
Partially correct. While state inconsistency and mismanagement of tokens are noted in the `response_list`, it does not specifically address this issue's root cause or the associated miscalculation. This logical flaw within a core function such as `recoverTokens` remains unresolved.

**Suggestions**:
- Correct the formula for excess calculation for reward tokens.
- Implement regression testing to ensure correct behavior.

---

#### **[H-04] Improper implementation of `arbitraryCall()` allows protocol gov to steal funds from users' wallets**
**Report Description**:
`arbitraryCall()` enables protocol governance (`gov`) to execute arbitrary calls, which could be used maliciously to steal user funds via token allowances (`transferFrom`).

**Match in Response List**:
Matches with ""Centralized governor control"" and ""Sensitive functions without access control"" (Points 1 and 3 in the response list).

**Validation**:
Correct. The `response_list` captures the centralization risk and lack of constraints, which could indeed allow protocol governance to misuse `arbitraryCall()`. It correctly identifies the primary issue: centralization without sufficient safeguards.

**Suggestions**:
- Implement access controls or explicit restrictions on `arbitraryCall()` capability to limit potential misuse (e.g., allow only preapproved contracts).

---

#### **[H-05] Possible incentive theft through the `arbitraryCall` function**
**Report Description**:
`arbitraryCall()` can set allowances on an incentive token before any incentive is created, enabling potential theft before the contract has received the tokens.

**Match in Response List**:
No match found.

**Validation**:
No corresponding discussion or remediation of this nuanced vulnerability within `response_list`. This is a serious oversight since it relates directly to user funds and potential malicious exploitation of allowances.

**Suggestions**:
- Restrict token allowances in `arbitraryCall()` for tokens not yet created as incentives.
- Introduce robust safeguards for token interaction logic.

---

#### **[H-06] Creating rewardTokens without streaming depositTokens**
**Report Description**:
Logical flaws in `stake` and `withdraw` functions allow reward generation without deposit tokens, violating contract assumptions.

**Match in Response List**:
Partially matches with ""Incorrect state updates"" (Point 8 in the response list).

**Validation**:
Partially correct. While the response highlights generic state update errors, it does not address this specific issue of decoupling deposit tokens from reward tokens, which is critical for maintaining contract integrity.

**Suggestions**:
- Validate that rewards can only be generated if corresponding deposits exist.
- Add proper state validations in `stake` and `withdraw`.

---

#### **[H-07] Business logic bug in `_abdicate()` function - 2 Bugs**
**Report Description**:
The `_abdicate()` function does not account for emergency or pending governors, leaving a backdoor where pending governors can claim governance post-abdication.

**Match in Response List**:
Matches with ""Centralized governor control"" (Point 1 in the response list).

**Validation**:
Correct. The `response_list` highlights centralization risks, correctly emphasizing the importance of handling sensitive operations like `abdicate()` with strict checks and safeguards.

**Suggestions**:
- Modify `_abdicate()` to reset or appropriately handle pending governor and emergency governor roles.

---

#### **[H-08] ts.tokens sometimes calculated incorrectly**
**Report Description**:
State inconsistency in `updateStream()`, particularly when tokens are staked and withdrawn, leads to improper calculation of `ts.tokens`.

**Match in Response List**:
Matches with ""Incorrect state updates"" (Point 8 in the response list).

**Validation**:
Correct. The issue of state inconsistency aligns with point 8 of the `response_list`, which covers inadequate validation of state variables during staking, withdrawing, and claiming rewards.

---

#### **[H-09] DoS while dealing with ERC20 when `value` exceeds `type(uint112).max`**
**Report Description**:
Large token values (close to `type(uint112).max`) cause reversion and effectively lock funds for withdrawing users.

**Match in Response List**:
Partially matches with ""Arithmetic issues in fee handling"" and ""DoS in rewards or deposits"" (Points 4 and 9 in the response list).

**Validation**:
Partially correct. While both arithmetic flaws and DoS concerns are mentioned, the specific issue of exceeding `uint112` maximum values with ERC20 tokens is not explicitly noted. This remains a critical gap, as locked funds equate to a total loss for affected users.

**Suggestions**:
- Validate token values prior to arithmetic operations.
- Introduce limits or constraints to prevent excessive token values.

---

#### **[H-10] recoverTokens doesn't work when `isSale` is true**
**Report Description**:
The `recoverTokens` function breaks when `isSale` is true, as it incorrectly calculates token excess balances.

**Match in Response List**:
Partially matches with ""Mismanagement of fee claims"" (Point 5 in the response list).

**Validation**:
Partially correct. The response mentions general mismanagement of fees, but it does not address this specific functionality breakdown when `isSale` is enabled.

**Suggestions**:
- Add condition checks in `recoverTokens` to ensure correct calculations of token excess based on `isSale` status.
- Deploy additional test cases for `isSale` conditions.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **Recommendation to Integrate Circuit Breaker**
While not mentioned in `issue`, adding a circuit breaker pattern could mitigate severe risks and allow emergency stop capabilities.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- [H-04] Improper implementation of `arbitraryCall()` allows protocol gov to steal funds from users' wallets.
- [H-07] Business logic bug in `_abdicate()` function - 2 Bugs.
- [H-08] ts.tokens sometimes calculated incorrectly.

#### **Partially Correct Matches**:
- [H-02], [H-03], [H-06], [H-09], [H-10] (specific gaps noted).

#### **Missed Issues from Issue Report**:
- [H-01], [H-05], [M-02], [M-04].",3,5,4,14,"```
1. Centralized governor control
2. Sensitive functions without access control
3. Incorrect state updates
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Centralized governor control** appears at rank 1.
   - **Sensitive functions without access control** appears at rank 3.
   - **Incorrect state updates** appears at rank 8.

2. **Calculate the precision at each rank where a true positive appears**:
   - **Precision at rank 1 (P@1)**: \( \frac{1}{1} = 1.0 \)
   - **Precision at rank 3 (P@3)**: \( \frac{2}{3} \approx 0.6667 \)
   - **Precision at rank 8 (P@8)**: \( \frac{3}{8} = 0.375 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 0.6667 + 0.375}{3} = \frac{2.0417}{3} \approx 0.6806
   \]

**Output**:
```
0.6806
```"
