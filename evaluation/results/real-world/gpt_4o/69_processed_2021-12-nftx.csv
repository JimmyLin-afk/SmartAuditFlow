nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",5808.0,615.0,"[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets
In the NFTXMarketplaceZap.sol contract, the `buyAndSwap1155WETH` function uses the WETH provided by the user to exchange VaultToken, but when executing the `_buyVaultToken` method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail

[H-03] A vault can be locked from MarketplaceZap and StakingZap
Any user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.
Every operation performed by the marketplace, that deals with vToken minting, performs this check:
“require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance”);""
A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace

[M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..

[M-03] NFTXMarketplaceZap.sol#buyAndSwap721WETH() should return unused weth/eth back to `msg.sender` instead of `to`
function `buyAndSwap721WETH`[M-04] NFTXStakingZap and NFTXMarketplaceZap transferFromERC721 transfer Cryptokitties to the wrong address
`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).

[M-12] `buyAndSwap1155WETH` Does Not Work As Intended
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.",6.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}


abstract contract ReentrancyGuard {
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",4873.0,2,4,"The provided Solidity smart contract, **NFTXMarketplaceZap**, has various functionalities, including swapping/buying/selling NFTs using different external protocols. However, it also contains several potential vulnerabilities or weaknesses:

---

### **1. Improper Input Validation**
- Functions such as `mintAndSell721`, `mintAndSell721WETH`, etc., check that the `to` address is not `0` and that the `ids` array is not empty, but there might be other improper validation or assumptions about other inputs (e.g., fees, paths, or vault IDs). Specifically:
  - Input data like `vaultId` assumes a valid vault exists but does not fully validate the inputs.
  - Certain array inputs (`path`, `idsIn`, etc.) are not rigorously validated for length compatibility between inputs.

---

### **2. Lack of Checks for External Contract Return Data:**
- When calling external contracts (like `transferFromERC721`, `approveERC721`, `IERC1155Upgradeable.safeBatchTransferFrom`), the return data is not always correctly checked. For example:
  ```solidity
  (bool success, bytes memory resultData) = address(assetAddr).call(data);
  require(success, string(resultData)); // Uses `resultData` directly, which can be unsafe.
  ```
  - If `resultData` contains malicious or misleading data, the error message could leak unintended details or be exploited.

---

### **3. Reentrancy Risks in External Calls**
- Although the contract uses `nonReentrant` modifiers (via `ReentrancyGuard`), there are still potential reentrancy risks:
    - Calls like `INFTXVault(vault).swapTo`, `INFTXVault(vault).redeemTo`, or any function calling `external` Uniswap contracts (`sushiRouter.swapExactTokensForETH`, etc.) might trigger reentrancy in the target contracts if they are compromised.
    - Receiving ETH in fallback functions or during WETH withdrawals could also trigger reentrant behavior.

---

### **4. Centralization and Single Point of Failure (Ownable)**
- The `Ownable` implementation allows the owner of the contract to execute privileged operations (e.g., transferring ownership). This introduces centralization risks. If the owner’s account is compromised, malicious activities could ensue.

---

### **5. Vault Fee Calculations**
- The calculations for redeem/mint fees (e.g., in `_buyVaultToken` and `_redeem`) rely on external fee structures provided by `INFTXVault`. These fee values could potentially be manipulated by malicious vault contracts deployed on NFTX.

---

### **6. Use of Hardcoded Addresses**
- The contract includes hardcoded addresses for `CryptoKitties` and `CryptoPunks`:
  ```solidity
  address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
  address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
  ```
  - These hardcodes assume the protocol for these projects doesn't change or upgrade. If the addresses become invalid or these assets are bridged to new networks or standards, the contract may break.

---

### **7. Use of an Arbitrary Path in Uniswap Calls**
- Functions like `_buyVaultToken`, `_sellVaultTokenWETH`, and `_sellVaultTokenETH` allow arbitrary swap paths via:
  ```solidity
  sushiRouter.swapTokensForExactTokens(minTokenOut, maxWethIn, path, ...);
  ```
  - An attacker could pass an invalid or inefficient `path` to manipulate the behavior of swap operations or drain funds.

---

### **8. Overflow Potential in Fee Calculations**
- The fees referenced in calls such as:
  ```solidity
  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) ...
  uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) ...
  ```
  - If `specificIds` is extremely large or fees are misconfigured in the `vault`, this could lead to integer overflow behavior (though less likely in Solidity 0.8+ due to built-in overflow checks).

---

### **9. Lack of Comprehensive Validation for Fallbacks**
- The contract’s `receive` function does not handle edge cases where ETH is mistakenly sent without context. This might lead to unexpected behavior, especially with WETH operations.

---

### **10. Gas Estimation and Denial of Service Risks**
- Complex, nested loops in functions like `_mint1155` and `_swap1155` make them susceptible to gas limit issues:
  ```solidity
  for (uint256 i = 0; i < idsIn.length; i++) {
      uint256 amount = amounts[i];
      require(amount > 0, ""Transferring < 1"");
      count += amount;
  }
  ```
  - If extremely large arrays are passed to these functions, they might fail due to high gas usage, possibly creating a denial of service (DoS) risk.

---

### **11. Unsafe WETH Withdrawal Logic**
- WETH withdrawal operations use `call` to send ETH back to the user:
  ```solidity
  WETH.withdraw(remaining);
  (bool success, ) = payable(to).call{value: remaining}("""");
  require(success, ""Address: unable to send value, recipient may have reverted"");
  ```
  - The `call` operation may allow reentrancy if the `to` recipient is malicious or misconfigured. While `nonReentrant` reduces this risk, combined external calls could still introduce attack vectors.

---

### **12. Unchecked `transferFrom` In External ERC20 Transfers**
- Calls to `IERC20Upgradeable.transferFrom` (e.g., in `buyAndSwap721WETH`) do not handle scenarios where tokens lack proper implementations of `transferFrom` or return false.

---

### **13. Message Sender Assumptions in `safeBatchTransferFrom`**
- Calls to `IERC1155Upgradeable.safeBatchTransferFrom` make implicit assumptions that `msg.sender` is the owner of provided NFTs. Misconfigurations could cause unexpected behavior.

---

### **14. Approvals Not Revoked**
- The contract uses unlimited approvals for token transfers (i.e., `IERC20Upgradeable.approve`) without revoking these approvals after their usage, increasing the risk of accidental or malicious misuse.

---

### **15. Potential Front-Running Vulnerability**
- The contract relies on Uniswap/SushiSwap price data for token swaps. However, these operations can be front-run based on the `path` or expected outputs (`minWethOut`, etc.), resulting in suboptimal results for the user.

---

### **16. Missing Events for Critical Internal State Changes**
- Events are only emitted for swapping, buying, and selling NFTs in public functions (`Swap`, `Buy`, `Sell`). Internal operations (e.g., `_mint1155`, `_redeem`) involving significant state changes lack logging, making it challenging to trace issues during audits or debugging.

---

### **17. Code Complexity of `_mint721`**
- The `_mint721` function includes overly complex logic combining asset approvals, transfers, and fee balances, leading to difficulty in understanding, testing, and identifying edge cases.

---

Overall, while the contract incorporates several safeguards like `ReentrancyGuard`, there are still numerous areas where its design and implementation could be improved to ensure greater security and robustness.","---

### **Analysis of Issues and Responses**

---

#### **[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets**

**Report Description**:  
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap.sol` uses `msg.value` instead of `maxWethIn` when calling `_buyVaultToken`. Since `msg.value` is `0`, the call will fail, causing the function to not work as intended and potentially leading to user asset loss.

**Match in Response List**:  
Matches with **[12. Unchecked `transferFrom` In External ERC20 Transfers]** and **[11. Unsafe WETH Withdrawal Logic]**.

**Validation**:  
**Partially Correct**.  
The response mentions issues with unchecked external calls and unsafe WETH withdrawal logic, which are related to the problem described in the issue. However, it does not explicitly address the root cause of the issue: the incorrect use of `msg.value` instead of `maxWethIn` in the `_buyVaultToken` call. This oversight means the response does not fully resolve the issue.

**Suggestions**:  
- Explicitly address the incorrect use of `msg.value` in the `_buyVaultToken` call and recommend replacing it with `maxWethIn` to ensure the function works as intended.
- Add a test case to verify the behavior of `buyAndSwap1155WETH` when only WETH is supplied.

---

#### **[H-03] A vault can be locked from MarketplaceZap and StakingZap**

**Report Description**:  
A malicious user can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` by transferring a small amount of `vToken` to the zap contracts. This triggers a balance mismatch in the `require` statement, effectively locking the vault for all users.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**.  
The response list does not address this issue. The vulnerability is critical as it allows a malicious user to perform a denial-of-service (DoS) attack on the vault, rendering it unusable for all users.

**Suggestions**:  
- Modify the `require` statement to account for small, unexpected token transfers. For example, use a whitelist or a specific mechanism to validate legitimate transfers.
- Add a mechanism to handle unexpected token balances gracefully, such as allowing the owner to reset the balance check.

---

#### **[M-01] Missing non-reentrancy modifier**

**Report Description**:  
Some functions lack the `nonReentrant` modifier, even though other similar functions use it. While no exploit has been identified, it is recommended to add the modifier for consistency and to prevent potential reentrancy attacks.

**Match in Response List**:  
Matches with **[3. Reentrancy Risks in External Calls]**.

**Validation**:  
**Correct**.  
The response identifies potential reentrancy risks in external calls and acknowledges the use of `nonReentrant` modifiers in some functions. It also highlights the need to ensure all relevant functions are protected against reentrancy.

**Suggestions**:  
- Conduct a thorough review of all public and external functions to ensure that `nonReentrant` is applied where necessary.
- Add tests to simulate reentrancy attacks and verify the effectiveness of the `nonReentrant` modifier.

---

#### **[M-03] `buyAndSwap721WETH()` should return unused WETH/ETH back to `msg.sender` instead of `to`**

**Report Description**:  
The `buyAndSwap721WETH` function returns unused WETH/ETH to the `to` address instead of the `msg.sender`. This behavior is unexpected and could lead to user confusion or loss of funds if the `to` address is not controlled by the user.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**.  
The response list does not address this issue. Returning unused funds to the `to` address instead of the `msg.sender` is a logical error that violates user expectations and could lead to asset mismanagement.

**Suggestions**:  
- Update the function to return unused WETH/ETH to the `msg.sender` instead of the `to` address.
- Add a test case to verify that unused funds are correctly returned to the `msg.sender`.

---

#### **[M-04] `transferFromERC721` transfers CryptoKitties to the wrong address**

**Report Description**:  
The `transferFromERC721` function transfers CryptoKitties to `address(this)` instead of the `to` address. This results in incorrect NFT accounting and could lead to NFTs being locked in the contract.

**Match in Response List**:  
Matches with **[6. Use of Hardcoded Addresses]**.

**Validation**:  
**Partially Correct**.  
The response mentions the use of hardcoded addresses for CryptoKitties and CryptoPunks, which is related to the issue. However, it does not explicitly address the incorrect transfer logic for CryptoKitties in the `transferFromERC721` function.

**Suggestions**:  
- Fix the transfer logic in `transferFromERC721` to ensure that CryptoKitties are transferred to the `to` address.
- Remove hardcoded addresses and replace them with configurable parameters to improve flexibility and maintainability.

---

#### **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

**Report Description**:  
The `buyAndSwap1155WETH` function uses `msg.value` instead of `maxWethIn` in the `_buyVaultToken` call. This causes the function to fail unless the user supplies both WETH and ETH, which is not the intended behavior.

**Match in Response List**:  
Matches with **[1. Improper Input Validation]**.

**Validation**:  
**Partially Correct**.  
The response mentions improper input validation but does not specifically address the incorrect use of `msg.value` in the `_buyVaultToken` call. This means the response does not fully resolve the issue.

**Suggestions**:  
- Explicitly address the incorrect use of `msg.value` in the `_buyVaultToken` call and recommend replacing it with `maxWethIn`.
- Add input validation to ensure that the function behaves as expected when only WETH is supplied.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Lack of Comprehensive Validation for Fallbacks**

**Response Description**:  
The contract’s `receive` function does not handle edge cases where ETH is mistakenly sent without context. This might lead to unexpected behavior, especially with WETH operations.

**Assessment**:  
**Valid Concern**.  
While this issue was not mentioned in the original `issue` report, it highlights a potential risk of unexpected ETH transfers. Adding validation or logging to the `receive` function would improve the contract's robustness.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-01] Missing non-reentrancy modifier**

**Partially Correct Matches**:  
- **[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets**  
- **[M-04] `transferFromERC721` transfers CryptoKitties to the wrong address**  
- **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

**Missed Issues from Issue Report**:  
- **[H-03] A vault can be locked from MarketplaceZap and StakingZap**  
- **[M-03] `buyAndSwap721WETH()` should return unused WETH/ETH back to `msg.sender` instead of `to`**

---",1,3,2,17,"```
1. Reentrancy Risks in External Calls
```","To calculate the **Average Precision (AP)** for the given query, we follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Reentrancy Risks in External Calls"".
   - This appears at rank **3** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 3 (\( P@3 \)) is calculated as the number of true positives up to rank 3 divided by the rank itself.
   - Since there is only one true positive up to rank 3, \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Average the precision values**:
   - Since there is only one true positive, the **Average Precision (AP)** is simply the precision at rank 3.

**Output**:
```
0.333
```"
NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1672.0,172.0,"[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees
In the NFTXSimpleFeeDistributor.sol contract, the `distribute` function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the `_sendForReceiver` function.
In the `_sendForReceiver` function, when `_receiver` is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.

[M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..

[M-02] `addReceiver()`: Failure to check for existing receiver
The `addReceiver()` function fails to check if the `_receiver` already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.
The receiver would receive more than expected (until the duplicate entry has been removed).

[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract
Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.

[M-14] Return variable can remain unassigned in `_sendForReceiver`
The `_sendForReceiver()` function only sets a return function in the ""if"" code block, not the ""else"" case. If the ""else"" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover > 0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.
This problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.

[M-16] Malicious receiver can make `distribute` function denial of service
`distribute` function
In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the `_sendForReceiver` function to distribute the feeIn the `_sendForReceiver` function, when the `_receiver` is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.",6.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1605.0,1,5,"Below is a detailed list of potential vulnerabilities and issues in the given Solidity smart contract. These vulnerabilities can be categorized as logical, security-related, or implementation/design issues:

### 1. **Reentrancy Vulnerability in `_sendForReceiver`**
   - The `_sendForReceiver` function calls an external contract using `address(_receiver.receiver).call(payload);`. This introduces potential **reentrancy vulnerabilities**.
   - The external contract (`_receiver.receiver`) might call back into this contract in an unexpected state and potentially manipulate contract logic before execution completes.

   **Recommendation**: 
     - Ensure that the state of the contract is updated before any external call.
     - Validate and tightly control the external interactions (e.g., avoid unnecessary approval setting and relying on allowance checks).

---

### 2. **Unchecked Return Value from External Call**
   - In `_sendForReceiver`, the result of the external `call()` is only partially checked with `success`. However:
     - The external contract could return a **false success flag** or manipulate the state in a different way.
     - The `IERC20Upgradeable.approve()` might leave the contract in an inconsistent state with leftover allowances.

   **Recommendation**:
     - Use `require(success, ""External call failed"")` or similar error-handling logic.
     - Carefully review and sanitize interaction with external receivers.

---

### 3. **Infinite Allowance Approval for External Contract**
   - Within `_sendForReceiver`, the function calls `IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);`. 
     - If the call fails or is exploited, it could leave an unchecked allowance for `_receiver.receiver`.

   **Recommendation**:
     - Use `safeApprove` methods with a custom allowance-reset pattern to mitigate risks of leftover approvals.

---

### 4. **Lack of Input Validation in Address-Setting Functions**
   - Functions like `setTreasuryAddress`, `setLPStakingAddress`, and `setNFTXVaultFactory` allow updating key addresses without validating the new address (besides avoiding `address(0)`):
     - If a malicious or incorrect address is set, it could result in critical mismanagement of the funds and contract behavior.

   **Recommendation**:
     - Implement stricter validation for sensitive address updates (e.g., ensuring the new address is a contract and adheres to the expected interface).
     - Implement mechanisms to temporarily revert or audit changes.

---

### 5. **FeeReceiver Data Manipulation by `onlyOwner`**
   - The `onlyOwner` protectable functions (`changeReceiverAddress`, `changeReceiverAlloc`, `removeReceiver`) allow the contract owner to arbitrarily modify `feeReceivers`. This could manipulate how rewards are distributed:
     - The owner could add malicious contracts or increase allocation weights unfairly, potentially leading to fund mismanagement.

   **Recommendation**:
     - Reintroduce governance mechanisms (e.g., multi-signature setups or time-delay proposals) to prevent unilateral modifications by the owner.

---

### 6. **Failure to Check Division by Zero in Calculations**
   - The `distribute` function calculates reward splits proportionally using `(tokenBalance * _feeReceiver.allocPoint) / allocTotal`. If `allocTotal == 0`, this will **revert with a division-by-zero error**.
   - Although there’s a loosely implemented check for `allocTotal == 0`, there could still be edge cases for incorrect assignments.

   **Recommendation**:
     - Ensure robust input validation before performing division operations.
     - Add explicit error handling for `allocTotal == 0`.

---

### 7. **Unclaimed Leftovers Can Be Sent to Treasury**
   - In the `distribute` function, leftover tokens are sent to the `treasury` in specific cases.
     - If there are leftover tokens due to receiver failures, this could lead to unintended profits for the treasury or permanent loss of tokens if the destination treasury is not well managed.

   **Recommendation**:
     - Log the amounts sent to the treasury in case of leftovers.
     - Check for reasons why leftover tokens cannot be sent and handle them appropriately based on business logic.

---

### 8. **Potential Spoofing of `_receiver.isContract` Parameter**
   - The `_addReceiver` function allows an arbitrary `_isContract` parameter to be passed without verification.
     - This could result in incorrect classification of a receiver, bypassing logic that expects certain behaviors (e.g., payload handling for contracts).

   **Recommendation**:
     - Enforce stricter checks for `_isContract` (e.g., using `AddressUpgradeable.isContract(address)` from OpenZeppelin).

---

### 9. **Centralized Ownership Privileges**
   - The contract heavily relies on the `onlyOwner` modifier for managing sensitive parameters like treasury, receivers, and allocations.
     - This introduces a **centralization risk**, where a single entity could mismanage the contract or act maliciously.

   **Recommendation**:
     - Incorporate decentralization mechanisms like a **multi-signature wallet** or **DAO governance model** to manage sensitive functions.
     - Introduce safeguards against potential abuse by the owner.

---

### 10. **Funds Lock Risk in `rescueTokens`**
   - The `rescueTokens` function allows the owner to withdraw arbitrary tokens from the contract.
     - This could be abused to drain tokens or lead to accidental loss of reserved funds if used improperly.

   **Recommendation**:
     - Apply restrictions to prevent arbitrary withdrawals (e.g., only allow rescue for specific tokens that don’t belong to the contract’s core operations).
     - Log all token rescue actions with the reason and recipient.

---

### 11. **Lack of Fallback and Receive Functions**
   - The contract does not implement `fallback` or `receive` functions.
     - If Ether is transferred directly to this contract, it will **get stuck** since only ERC20 tokens are handled correctly.

   **Recommendation**:
     - Implement either a `fallback` or `receive` function to safely handle unexpected Ether transfers (even if not critical).

---

### 12. **Event Logging Deficiency**
   - Certain potentially critical state changes (e.g., `_addReceiver`, `_sendForReceiver` failures, or leftover transfers) are not logged adequately.
     - This could make it difficult to audit or debug issues that arise in the system.

   **Recommendation**:
     - Add event logs for all state-changing operations to ensure traceability.

---

### Summary
To effectively secure and optimize this contract, you should:
1. Address reentrancy and unchecked call vulnerabilities.
2. Validate inputs rigorously (e.g., addresses, allocations).
3. Decentralize privileged roles using governance mechanisms.
4. Add stricter logging and error handling practices.
5. Minimize risks of mismanagement by the contract owner.

Although the contract uses Solidity 0.8.0 (which has built-in overflow protection), thorough audits should still be performed to mitigate complex vulnerabilities.","---

### **Analysis of Issues and Responses**

---

#### **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**

**Report Description**:  
The `_sendForReceiver` function does not return a value when `_receiver` is not a contract. By default, this results in a `false` return value, which causes the `distribute` function to assume the fee transfer failed. Consequently, the `distribute` function sends additional fees in subsequent calls, leading to overpayment.

**Match in Response List**:  
Matches with **""Unchecked Return Value from External Call""** in the response list.

**Validation**:  
**Partially Correct**.  
The response identifies the issue of unchecked return values from external calls and recommends using `require(success, ""External call failed"")` or similar error-handling logic. However, it does not explicitly address the specific scenario where `_sendForReceiver` defaults to `false` when `_receiver` is not a contract. The response should have included a recommendation to explicitly handle the case where `_receiver` is an externally owned account (EOA) and ensure that the return value is correctly set.

**Suggestions**:  
- Modify `_sendForReceiver` to explicitly return `true` for EOAs after a successful transfer.  
- Add a test case to verify that the `distribute` function behaves correctly for both contracts and EOAs.

---

#### **[M-01] Missing non-reentrancy modifier**

**Report Description**:  
Certain public/external functions lack the `nonReentrant` modifier, even though other functions in the contract use it. While no exploit was identified, the absence of the modifier could expose the contract to reentrancy risks.

**Match in Response List**:  
Matches with **""Reentrancy Vulnerability in `_sendForReceiver`""** in the response list.

**Validation**:  
**Partially Correct**.  
The response highlights the potential for reentrancy vulnerabilities in `_sendForReceiver` due to external calls. It recommends updating the contract state before making external calls and validating interactions. However, it does not explicitly address the absence of the `nonReentrant` modifier in other functions, nor does it recommend adding the modifier to the affected functions.

**Suggestions**:  
- Add the `nonReentrant` modifier to all functions that modify state and interact with external contracts.  
- Review the contract for other potential reentrancy risks and ensure consistent use of the modifier.

---

#### **[M-02] `addReceiver()`: Failure to check for existing receiver**

**Report Description**:  
The `addReceiver()` function does not check if the `_receiver` already exists in the `feeReceivers` list. This could result in duplicate entries, leading to overpayment of fees to the same receiver.

**Match in Response List**:  
No match found.

**Validation**:  
**Unaddressed**.  
The response list does not mention the issue of duplicate receivers in the `addReceiver()` function. This is a significant oversight, as it directly impacts the correctness of fee distribution.

**Suggestions**:  
- Add a check in `addReceiver()` to ensure that `_receiver` is not already in the `feeReceivers` list.  
- Include a test case to verify that duplicate receivers cannot be added.

---

#### **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**

**Report Description**:  
When `_sendForReceiver` is called for an EOA, it does not return `true` after a successful transfer. This causes the `distribute` function to send the same fee amount to the next receiver in the list, leading to double payments for some receivers and missed payments for others.

**Match in Response List**:  
Matches with **""Unchecked Return Value from External Call""** in the response list.

**Validation**:  
**Partially Correct**.  
The response addresses the general issue of unchecked return values but does not specifically discuss the scenario where `_sendForReceiver` fails to return `true` for EOAs. This omission leaves the root cause of the issue unresolved.

**Suggestions**:  
- Update `_sendForReceiver` to explicitly return `true` for EOAs after a successful transfer.  
- Add a test case to ensure that the `distribute` function handles EOAs and contracts correctly.

---

#### **[M-14] Return variable can remain unassigned in `_sendForReceiver`**

**Report Description**:  
The `_sendForReceiver` function only sets a return value in the `if` block but not in the `else` block. If the `else` block is executed, the function implicitly returns `false`, which can cause the `distribute` function to behave incorrectly.

**Match in Response List**:  
Matches with **""Unchecked Return Value from External Call""** in the response list.

**Validation**:  
**Partially Correct**.  
The response identifies the issue of unchecked return values but does not address the specific problem of unassigned return variables in `_sendForReceiver`. This oversight could lead to unintended behavior in the `distribute` function.

**Suggestions**:  
- Ensure that `_sendForReceiver` explicitly returns a value in all code paths.  
- Add a test case to verify that the `distribute` function behaves correctly for all scenarios.

---

#### **[M-16] Malicious receiver can make `distribute` function denial of service**

**Report Description**:  
A malicious receiver contract can revert in its `receiveRewards` function, causing the `distribute` function to fail and resulting in a denial of service (DoS).

**Match in Response List**:  
No match found.

**Validation**:  
**Unaddressed**.  
The response list does not mention the potential for a DoS attack caused by malicious receivers. This is a critical oversight, as it directly impacts the availability of the `distribute` function.

**Suggestions**:  
- Use a `try/catch` block to handle failures in external calls to `receiveRewards`.  
- Log failed transfers and allow the `distribute` function to continue processing other receivers.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Lack of Input Validation in Address-Setting Functions**

**Response Description**:  
The response highlights that functions like `setTreasuryAddress` and `setLPStakingAddress` do not validate the new address beyond checking for `address(0)`.

**Assessment**:  
**Valid Concern**.  
This issue was not mentioned in the original `issue` report but is a valid concern. Address-setting functions should include stricter validation to prevent mismanagement.

---

#### **[R-02] Centralized Ownership Privileges**

**Response Description**:  
The response notes that the contract relies heavily on the `onlyOwner` modifier, introducing centralization risks.

**Assessment**:  
**Valid Concern**.  
This issue was not mentioned in the original `issue` report but is a valid concern. Decentralization mechanisms should be considered to mitigate risks.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- None.

**Partially Correct Matches**:  
- **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**  
- **[M-01] Missing non-reentrancy modifier**  
- **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**  
- **[M-14] Return variable can remain unassigned in `_sendForReceiver`**

**Missed Issues from Issue Report**:  
- **[M-02] `addReceiver()`: Failure to check for existing receiver**  
- **[M-16] Malicious receiver can make `distribute` function denial of service**

**GPT-Generated Potential Issues (May Be Incorrect)**:  
- **[R-01] Lack of Input Validation in Address-Setting Functions**  
- **[R-02] Centralized Ownership Privileges**

---",0,4,2,12,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. 

Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and the average of these values is also 0."
NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

// Authors: @0xKiwi_ and @alexgausman.

contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    // Added in v1.0.3.
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    // // This function allows for the manager to set their own arbitrary eligibility contract.
    // // Once eligiblity is set, it cannot be unset or changed.
    // Disabled for launch.
    // function setEligibilityStorage(address _newEligibility) public virtual {
    //     onlyPrivileged();
    //     require(
    //         address(eligibilityStorage) == address(0),
    //         ""NFTXVault: eligibility already set""
    //     );
    //     eligibilityStorage = INFTXEligibility(_newEligibility);
    //     // Toggle this to let the contract know to check eligibility now.
    //     allowAllItems = false;
    //     emit CustomEligibilityDeployed(address(_newEligibility));
    // }

    // The manager has control over options like fees and features
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        // Take the NFTs.
        uint256 count = receiveNFTs(tokenIds, amounts);

        // Mint to the user.
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burn(msg.sender, base * amount);

        // Pay the tokens + toll.
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        // Withdraw from vault.
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        // Give the NFTs first, so the user wont get the same thing back, just to be nice. 
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    // Added in v1.0.3.
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    // Added in v1.0.3.
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    // Added in v1.0.3.
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                // We may already own the NFT here so we check in order:
                // Does the vault own it?
                //   - If so, check if its in holdings list
                //      - If so, we reject. This means the NFT has already been claimed for.
                //      - If not, it means we have not yet accounted for this NFT, so we continue.
                //   -If not, we ""pull"" it from the msg.sender and add to holdings.
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            // This will always be fine considering the validations made above. 
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        // Do not charge fees if the zap contract is calling
        // Added in v1.0.3. Changed to mapping in v1.0.5.
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            // Changed to a _transfer() in v1.0.3.
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Changed in v1.0.4.
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            // Default.
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Cryptokitties.
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            // Fix here for frontrun attack. Added in v1.0.2.
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            // Default.
            // Allow other contracts to ""push"" into the vault, safely.
            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4750.0,561.0,"[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users
Pool Manager can front-run entry fee to 100% and users could lose all their deposits.
Anyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10**18 (100% as this is a per token fee).

[M-09] Bypass zap timelock
The default value of `inventoryLockTime` in NFTXStakingZap is 7 days while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in XTokenUpgradeable.
The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in NFTXInventoryStaking`",2.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";



contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true , true , true , true , true );
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    
    
    
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        
        uint256 count = receiveNFTs(tokenIds, amounts);

        
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        
        _burn(msg.sender, base * amount);

        
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                
                
                
                
                
                
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        
        
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            
            
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            
            
            
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4033.0,0,2,"The provided smart contract (`NFTXVaultUpgradeable`) contains multiple potential vulnerabilities and issues that could compromise the contract or its intended functionality. Below is a list of the vulnerabilities, grouped into different categories based on their nature:

---

### **General Security Issues**
1. **Reentrancy Attack Risk**:
   - The reentrancy guard (`nonReentrant`) is applied inconsistently, making the contract vulnerable to reentrancy attacks in several scenarios.
   - Functions like `transferFromERC721` and `transferERC721` internally perform external `call` operations without proper handling, which could be exploited during mint or redeem workflows.

2. **Unchecked Call Success**:
   - The contract uses low-level `call` (e.g., in `transferERC721`, `transferFromERC721`) without proper checks for return values. This could lead to unexpected failures that are difficult to debug or could allow attackers to exploit unchecked call behaviors.

---

### **Randomness Issues**
3. **Unsecure Randomness Generation**:
   - The `getRandomTokenIdFromVault` function generates randomness using block attributes (e.g., `blockhash`, `block.timestamp`, `block.difficulty`, etc.), which are predictable and can be manipulated by miners.
   - This could allow attackers or miners to control the process of random token redemption or swaps.

---

### **Privileges and Access Control**
4. **Inadequate Privileged Access Control**:
   - The `setVaultFeatures`, `setManager`, `setFees`, `disableVaultFees`, and similar administrative functions rely on `onlyPrivileged`, which only validates `msg.sender` as either the owner or the manager. If the manager is accidentally set to a malicious address or an untrusted user, they could exploit these functions to manipulate the vault's configuration.

5. **Hard-Coded Address in `assignDefaultFeatures`**:
   - The function `assignDefaultFeatures` hardcodes an address (`0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a`) for privileged access, creating a centralization risk. If that address is compromised or misused, it could lead to malicious control over the contract.

---

### **Fee Manipulation**
6. **Fee Bypass for Certain Addresses**:
   - The `_chargeAndDistributeFees` function allows a fee bypass for any address that the `vaultFactory` deems ""excludedFromFees."" If this feature is not managed carefully, it could be abused to avoid paying fees.

7. **Potential Fee-Mismanagement Loophole**:
   - The `_chargeAndDistributeFees` function assumes that the fee amount is always accurate and doesn't perform additional security checks, opening the possibility for exploitation if fee calculations are manipulated elsewhere.

---

### **Input Validation**
8. **Insufficient Input Validation in ERC-1155 Transfers**:
   - `receiveNFTs` does not adequately validate or sanitize `amounts` input, allowing attackers to send zero-value transfers or exploit underflow/overflow issues related to quantities.

9. **Insufficient Validation for `redeem` Functions**:
   - The `redeem` and `redeemTo` functions assume the validity of `specificIds`, but there is no thorough validation to confirm whether the provided NFTs exist within the vault.
   - This could be used to execute unintended behavior during specific redeems.

---

### **Token Handling Risks**
10. **ERC-721 Transfer Vulnerabilities**:
    - `transferFromERC721` and `transferERC721` handle ERC-721 token transfers in a highly permissive way (e.g., allowing `transferFrom` calls or Punk transfers). This creates unnecessary bridges for attackers to intercept or manipulate token ownership.

11. **Problematic Handling of Kitties and Punks**:
    - Special case handling for CryptoKitties and CryptoPunks bypasses standard ERC-721 mechanisms, which could create exploitable inconsistencies.

12. **Missing NFT Validations**:
    - The `allValidNFTs` function only checks eligibility against `eligibilityStorage` (if set), but fails to verify whether the transfer/mint is valid outside other conditions (e.g., could allow invalid NFT transfers).

13. **Held NFT Reuse**:
    - Insufficient checks in `transferFromERC721` (`if ownerOf == address(this)` logic) provide avenues for attackers to manipulate logic and reuse previously held NFTs.

---

### **Ownership and Manager Design Flaws**
14. **Set Manager to Zero Address**:
    - The `finalizeVault` function sets the manager to the zero address (`address(0)`) without restrictions or safeguards. This could remove important functionality for the vault.

15. **Unintended Manager/Owner Privileges**:
    - If `manager` is assigned to an unintended address, they could manipulate vault fees/features. Similarly, there are no delegation mechanisms for the owner role, reducing flexibility.

---

### **Inconsistencies in Token Accounting**
16. **Incorrect Token Count Tracking for ERC-1155**:
    - The `quantity1155` mapping and its associated logic could become mismatched due to improper handling in some scenarios (e.g., failed `safeBatchTransferFrom` calls) or external, malicious contract interactions. This could corrupt token counts.

17. **ERC-1155 Quantity Underflow Risk**:
    - The `quantity1155` mapping blindly decreases values on redemption, which could cause underflows if corrupted previously by a malicious user.

---

### **Compatibility and Upgradeability Problems**
18. **Upgradeable Contract Risks**:
    - Improper or missing upgradeability checks (e.g., versioning, reinitialization protection) could allow accidental or malicious re-initialization of the contract, disrupting its functionality.

19. **Dependency on External Factory**:
    - Over-dependence on external contracts like the `vaultFactory` introduces additional risks. If these contracts are malicious or compromised, they could manipulate fees, lock vault functionality, or introduce invalid eligibility modules.

20. **Unused Variables (`UNUSED_FEE1`, etc.)**:
    - The presence of unused state variables (`UNUSED_FEE1`, etc.) increases storage risks and hints at potential for feature abuse in future implementations.

---

### **Gas and Efficiency Problems**
21. **Gas-Heavy Functions Without Limits**:
    - Total NFT holdings (`allHoldings`) and other similar loops do not address gas limitations, potentially leading to out-of-gas failures when the vault becomes extremely large.
    
22. **Use of EnumerableSetUpgradeable**:
    - While offering convenience for managing collections, `EnumerableSetUpgradeable` increases gas costs for operations over large collections. Additionally, improper input handling can corrupt the set.

---

### **Flash Loan Risks**
23. **Under-Validated `flashLoan` Function**:
    - The flash loan functionality introduces additional risk if the `flashLoan` function is misused by malicious borrowers. Lack of proper validation and limits could drain funds or disrupt token balances.

---

### **Additional Observations**
24. **Events Missing in Critical Places**:
    - Critical updates (e.g., eligibilityStorage assignment) do not emit events, making it difficult to track state changes for off-chain monitoring.

---

### **Conclusion**
This contract exhibits a wide range of flaws, from minor inefficiencies to critical security vulnerabilities. Enhanced testing, auditing, and design improvements are highly recommended to secure the contract and make it production-ready.","---

### **Analysis of Issues and Responses**

---

#### **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Report Description**:  
The Pool Manager can front-run entry fees to 100%, causing users to lose all their deposits. This is possible because anyone can create a pool and set the fee to the maximum value (`uint(1 ether)` = 100%) before a large deposit is made. This creates a significant risk of malicious behavior by pool creators.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Unaddressed.** The response list does not mention this issue or provide any mitigation strategies for the fee manipulation vulnerability. This is a critical oversight, as fee manipulation is a significant risk that could lead to user funds being stolen. The response list should have included measures such as:
- Imposing limits on fee changes (e.g., a maximum percentage increase per block or time period).
- Implementing a timelock for fee changes to prevent immediate exploitation.
- Requiring user consent for fee changes that exceed a certain threshold.

**Suggestions**:  
- Introduce a timelock mechanism for fee changes to prevent immediate exploitation.
- Cap the maximum allowable fee to a reasonable percentage (e.g., 10%).
- Require user approval for fee changes that exceed a predefined threshold.

---

#### **[M-09] Bypass zap timelock**

**Report Description**:  
The default value of `inventoryLockTime` in `NFTXStakingZap` is 7 days, while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. This discrepancy allows users to bypass the intended 7-day timelock by calling `deposit` in `NFTXInventoryStaking`, which calculates the timelock as `block.timestamp + timelockLength`. This effectively reduces the timelock to 2 ms, enabling users to bypass the intended locking period.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Unaddressed.** The response list does not mention this issue or provide any mitigation strategies for the timelock bypass vulnerability. This is a critical oversight, as the timelock mechanism is essential for ensuring fair staking behavior and preventing abuse. The response list should have included measures such as:
- Ensuring consistent timelock values across all related contracts.
- Validating the timelock length before applying it to prevent unintended reductions.

**Suggestions**:  
- Standardize the timelock values across all contracts to avoid discrepancies.
- Add a validation check to ensure that the timelock length is not less than the intended minimum (e.g., 7 days).
- Emit an event whenever the timelock is updated to improve transparency.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Reentrancy Attack Risk**

**Response Description**:  
The response highlights inconsistent application of the `nonReentrant` modifier, making the contract vulnerable to reentrancy attacks. Functions like `transferFromERC721` and `transferERC721` perform external calls without proper handling, which could be exploited during mint or redeem workflows.

**Assessment**:  
**Valid Concern.** While this issue was not explicitly mentioned in the original `issue` report, it is a valid security concern. Reentrancy attacks are a common vulnerability in Solidity contracts, and inconsistent application of the `nonReentrant` modifier could lead to severe exploits. The response appropriately identifies the risk and suggests the need for consistent application of reentrancy guards.

---

#### **[R-02] Unchecked Call Success**

**Response Description**:  
The response identifies the use of low-level `call` without proper checks for return values in functions like `transferERC721` and `transferFromERC721`. This could lead to unexpected failures or allow attackers to exploit unchecked call behaviors.

**Assessment**:  
**Valid Concern.** This issue was not mentioned in the original `issue` report but is a valid security concern. Unchecked low-level calls can lead to silent failures or unexpected behavior, which could be exploited by attackers. The response appropriately highlights the need to check return values for low-level calls.

---

#### **[R-03] Unsecure Randomness Generation**

**Response Description**:  
The response points out that the `getRandomTokenIdFromVault` function generates randomness using block attributes (e.g., `blockhash`, `block.timestamp`, `block.difficulty`), which are predictable and can be manipulated by miners.

**Assessment**:  
**Valid Concern.** This issue was not mentioned in the original `issue` report but is a valid security concern. Using block attributes for randomness is a well-known anti-pattern in Solidity, as these values can be influenced by miners. The response appropriately identifies the risk and suggests the need for a more secure randomness generation mechanism.

---

#### **[R-04] Inadequate Privileged Access Control**

**Response Description**:  
The response highlights that administrative functions rely on `onlyPrivileged`, which only validates `msg.sender` as either the owner or the manager. If the manager is set to a malicious address, they could exploit these functions to manipulate the vault's configuration.

**Assessment**:  
**Valid Concern.** This issue was not mentioned in the original `issue` report but is a valid security concern. Improper access control can lead to unauthorized manipulation of critical contract functions. The response appropriately identifies the risk and suggests the need for stricter access control mechanisms.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None.

#### **Partially Correct Matches**:
- None.

#### **Missed Issues from Issue Report**:
1. **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**: Not addressed in the response list.
2. **[M-09] Bypass zap timelock**: Not addressed in the response list.

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
1. **[R-01] Reentrancy Attack Risk**: Valid concern.
2. **[R-02] Unchecked Call Success**: Valid concern.
3. **[R-03] Unsecure Randomness Generation**: Valid concern.
4. **[R-04] Inadequate Privileged Access Control**: Valid concern.

---

### **Conclusion**

The response list fails to address the two critical issues identified in the `issue` report: **fee manipulation by the Pool Manager** and **timelock bypass in NFTXStakingZap**. These are significant vulnerabilities that require immediate attention. However, the response list does highlight additional valid concerns, such as reentrancy risks, unchecked call success, insecure randomness generation, and inadequate access control, which were not mentioned in the original `issue` report. These additional concerns should also be addressed to improve the overall security of the contract.",0,0,2,24,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these values is also 0."
NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",4828.0,479.0,"***[M-08] Low-level call return value not checked***
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.",1.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,0,1,"Analyzing your smart contract, here is a list of potential vulnerabilities and issues:

### **Functional and Security Vulnerabilities**

1. **Reentrancy Vulnerability (`payable` calls)**:
   - Functions such as `addLiquidity721ETHTo` and `addLiquidity1155ETHTo` use `call` to transfer `msg.value - amountEth` back to the user:
     ```solidity
     payable(to).call{value: msg.value-amountEth};
     ```
     The use of `call` without stringent checks can result in reentrancy attacks. Even though the `nonReentrant` modifier is used, the external contract `to` could still exploit vulnerabilities elsewhere in the contract.

    **Mitigation**: Carefully audit external calls and ensure they don't interact with contract state further or create unintended side effects. Use `send` or `transfer` which enforce strict gas limits or explicitly check for return values.

2. **Inheritance Order (Upgradeable Contracts)**:
   - The contract inherits both `Ownable` and `ReentrancyGuard` as abstract base classes. The order of inheritance could have subtle issues if misunderstood in an upgradeable proxy contract. Misalignment between the inherited base classes could result in storage layout conflicts during upgrades.

    **Mitigation**: Ensure careful auditing of upgradeable contracts and layout alignment.

3. **Lack of Validation for External Calls (e.g., Punk and CryptoKitty logic)**:
   - The `transferFromERC721` and `approveERC721` functions handle multiple token standards (`CryptoKitties`, `Punks`, and standard ERC-721). These include custom logic based on `staticcall` and `call`:
     ```solidity
     (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
     ...
     (bool success, bytes memory resultData) = address(assetAddr).call(data);
     ```
     These calls rely heavily on correct and external behavior of third-party contracts. If token implementations change, this could introduce potential vulnerabilities (e.g., the function may inadvertently allow transferring Non-Fungible Tokens (NFTs) a user doesn’t own).

    **Mitigation**: Validate ownership and token legitimacy explicitly before executing any cross-contract call.

4. **Unchecked Function Return Values**:
   - Many functions use unchecked `call` or `safeBatchTransferFrom` calls, assuming success:
     ```solidity
     (bool success, bytes memory resultData) = address(assetAddr).call(data);
     require(success, string(resultData));
     ```
     If the function fails, the error message is passed via `resultData`. This is risky as the actual error message might not always be meaningful or could be manipulated if the external contract is malicious.

     **Mitigation**: Check success conditions explicitly and avoid relying solely on requiring a revert message.

5. **Hardcoded Third-party Addresses (e.g., Cryptokitties and CryptoPunks)**:
   - Hardcoding contract addresses for collectibles like CryptoKitties and CryptoPunks in `approveERC721` and `transferFromERC721` exposes the contract to risks, especially if these addresses or implementations ever change:
     ```solidity
     address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
     address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
     ```
     **Mitigation**: Avoid hardcoding addresses. Instead, allow dynamic configuration via a `mapping` or external administration mechanism.

6. **Token Approvals Have Potential for Exploitation**:
   - In the `provideInventory721` and other functions, approvals are set broadly (e.g., `approveERC721` calls or `IERC1155Upgradeable.setApprovalForAll`), temporarily leaving NFTs or tokens vulnerable to misuse if the vault logic is compromised.

    **Mitigation**: Limit token approval timeframes and ensure approvals are quickly revoked whenever possible.

7. **ERC-20 Transfers Do Not Check Return Values**:
   - Functions such as `rescue` and `addLiquidity721` perform ERC-20 transfers without validating their success:
     ```solidity
     IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
     ```
     Some ERC-20 implementations (non-compliant ones) do not revert on failure but instead return `false`.

    **Mitigation**: Explicitly check return values of such transfer calls and ensure compliance with the token standard.

8. **Lack of Input Validation**:
   - Critical functions such as `provideInventory721`, `provideInventory1155`, and liquidity functions fail to perform adequate validation on user-provided inputs. For instance:
     - The length of arrays like `tokenIds` and `amounts` is not validated adequately in some cases.
     - `vaultId` and other user inputs aren’t always checked against valid ranges.

     **Mitigation**: Add stronger input validation checks.

9. **Potential for Front-running Attacks**:
   - Users stake liquidity tokens and other assets using functions like `_addLiquidityAndLock`. However, users may face front-running issues where an attacker could anticipate transactions and manipulate asset prices or intercept rewards.

    **Mitigation**: Consider using anti-front-running measures like EIP-1559 or a private transaction relay.

### **Gas Optimization and Best Practices**

10. **Lack of Gas-efficient Approvals**:
    - ERC-20 approvals use `approve` instead of `increaseAllowance` or `permit`. This results in inefficiencies if allowances need to be updated repeatedly.

    **Mitigation**: Use gas-efficient patterns like `increaseAllowance` or `permit` (EIP-2612).

11. **Redundant State Updates**:
    - Some functions perform duplicate state updates or unnecessary actions to reset variables, which can waste gas. E.g.:
      ```solidity
      _status = _NOT_ENTERED;
      ```

    **Mitigation**: Minimize repetitive writes or unnecessary state updates.

12. **No Check for Address Zero**:
    - Some functions (e.g., `provideInventory1155`) assume that vault or asset addresses cannot be zero:
      ```solidity
      INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
      ```
      Without explicit validation, interaction with invalid contracts (or the zero address) could lead to silent failures or unintended behavior.

    **Mitigation**: Validate all critical addresses, particularly those involved in token transfers.

### **Centralization Risks**

13. **Owner Can Set Arbitrary Lock Times**:
    - The `setLPLockTime` and `setInventoryLockTime` functions allow the owner to modify lock times arbitrarily (up to 14 days). This might disadvantage users.

    **Mitigation**: Utilize community or multisig governance mechanisms for critical parameter changes.

14. **Owner Can Drain User Assets**:
    - The `rescue` function allows the owner to withdraw any ERC-20 tokens held in the contract. There is no restriction ensuring only misplaced tokens are retrieved, leading to potential misuse of user funds.

    **Mitigation**: Restrict `rescue` function usage to non-core tokens or limit access.

---

### Summary:
The contract has several functional and security risks, including reentrancy issues, lack of input validation, unchecked external call vulnerabilities, and potential misuse of permissions. Proper audits, additional validation, and best practices such as avoiding hardcoded addresses or unchecked approvals should be implemented to secure the contract.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[M-08] Low-level call return value not checked**

**Report Description**:  
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value to confirm if the call succeeded. This oversight can lead to silent failures, where the contract assumes the call succeeded even if it did not. This could result in loss of funds or unexpected behavior, especially when interacting with untrusted external contracts.

**Match in Response List**:  
Matches with **""Unchecked Function Return Values""** in the `response_list`.

**Validation**:  
**Partially Correct**.  
The response in `response_list` identifies the issue of unchecked return values in external calls, including the use of `call` and `safeBatchTransferFrom`. It correctly highlights the risks of assuming success without explicitly checking the return value. However, the response does not specifically address the `addLiquidity721ETHTo` function or the exact low-level `.call` mentioned in the `issue`. While the general mitigation advice to ""check success conditions explicitly"" is valid, the response could be improved by directly referencing the specific function and providing a concrete example of how to handle the return value properly.

**Suggestions**:  
- The response should explicitly mention the `addLiquidity721ETHTo` function and the specific `.call` usage.  
- Provide a code snippet demonstrating how to check the return value of the `.call` and handle failures appropriately. For example:
  ```solidity
  (bool success, ) = payable(to).call{value: msg.value - amountEth}("""");
  require(success, ""ETH transfer failed"");
  ```

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Reentrancy Vulnerability in `addLiquidity721ETHTo`**

**Response Description**:  
The response highlights a potential reentrancy vulnerability in the `addLiquidity721ETHTo` function due to the use of `call` for transferring ETH. While the `nonReentrant` modifier is used, the response notes that external contracts could still exploit vulnerabilities elsewhere in the contract.

**Assessment**:  
**Valid Concern**.  
Although the `issue` report does not explicitly mention reentrancy, the use of `call` in `addLiquidity721ETHTo` could indeed introduce reentrancy risks if the external contract (`to`) interacts with the calling contract's state. The `nonReentrant` modifier mitigates this risk to some extent, but it is still a valid concern to audit the entire contract for potential state changes during external calls.

---

#### **[R-02] Lack of Input Validation for `to` Address**

**Response Description**:  
The response mentions that critical addresses, such as the `to` address in `addLiquidity721ETHTo`, are not validated. This could lead to silent failures or unintended behavior if the `to` address is invalid (e.g., the zero address).

**Assessment**:  
**Valid Concern**.  
The `issue` report does not mention input validation for the `to` address, but this is a valid concern. Ensuring that the `to` address is not the zero address or an invalid contract address is a best practice in Solidity. Adding a check like `require(to != address(0), ""Invalid address"")` would enhance the contract's robustness.

---

#### **[R-03] Hardcoded Gas Limit in `.call`**

**Response Description**:  
The response does not explicitly mention this, but `.call` without a gas limit can lead to unpredictable behavior, especially if the external contract consumes excessive gas.

**Assessment**:  
**Valid Concern**.  
While not mentioned in the `issue` report, specifying a gas limit in `.call` is a best practice to prevent external contracts from consuming all available gas and causing the transaction to fail. For example:
```solidity
(bool success, ) = payable(to).call{value: msg.value - amountEth, gas: 2300}("""");
require(success, ""ETH transfer failed"");
```

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None.

#### **Partially Correct Matches**:
- **[M-08] Low-level call return value not checked**: The response identifies the general issue of unchecked return values but does not specifically address the `addLiquidity721ETHTo` function or provide a concrete solution.

#### **Missed Issues from Issue Report**:
- None.

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
1. **[R-01] Reentrancy Vulnerability in `addLiquidity721ETHTo`**: Valid concern, as reentrancy risks exist even with the `nonReentrant` modifier if external contracts interact with the calling contract's state.
2. **[R-02] Lack of Input Validation for `to` Address**: Valid concern, as the `to` address should be validated to prevent silent failures or unintended behavior.
3. **[R-03] Hardcoded Gas Limit in `.call`**: Valid concern, as specifying a gas limit in `.call` is a best practice to prevent excessive gas consumption by external contracts.

---

### **Recommendations**

1. **Enhance Response Specificity**:  
   The response should directly address the `addLiquidity721ETHTo` function and provide a concrete example of how to handle the return value of `.call`.

2. **Address Additional Concerns**:  
   Consider incorporating the following best practices into the contract:
   - Validate the `to` address to ensure it is not the zero address.
   - Specify a gas limit in `.call` to prevent excessive gas consumption by external contracts.
   - Audit the contract for potential reentrancy risks, even with the `nonReentrant` modifier.

3. **Improve Documentation**:  
   Clearly document the risks and mitigations associated with external calls, including the use of `.call`, to ensure developers and auditors are aware of potential vulnerabilities.

---",0,1,0,14,"```
None.
```",0.0
,,,,,,,,3,12,,,1,8,6,67,,
