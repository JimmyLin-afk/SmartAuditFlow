nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
RCOrderbook.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";

/// @title Reality Cards Orderbook
/// @author Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    /// @dev a record of a users single bid.
    /// @dev now declared in the interface, left here for reference
    // struct Bid {
    //     address market;
    //     address next;
    //     address prev;
    //     uint64 card;
    //     uint128 price;
    //     uint64 timeHeldLimit;
    // }

    /// @dev maps a user address to an array of their bids
    mapping(address => Bid[]) public user;
    /// @dev index of a bid record in the user array, User|Market|Token->Index
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    /// @dev record of market specific variables
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    /// @dev map a market address to a market record
    mapping(address => Market) public market;
    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    /// @dev an array of closed markets, used to reduce user bid rates
    address[] public override closedMarkets;
    /// @dev how far through the array a given user is, saves iterating the whole array every time.
    mapping(address => uint256) public override userClosedMarketIndex;

    ///// GOVERNANCE VARIABLES /////
    /// @dev the current treasury
    IRCTreasury public override treasury;
    /// @dev max number of searches to place an order in the book
    /// @dev current estimates place limit around 2000 but 1000 is sufficient
    uint256 public override maxSearchIterations = 1000;
    /// @dev max number of records to delete in one transaction
    uint256 public override maxDeletions = 70;
    /// @dev number of bids a user should clean when placing a new bid
    uint256 public override cleaningLoops = 2;
    /// @dev max number of market records to put into the waste pile in one go
    uint256 public override marketCloseLimit = 70;
    /// @dev nonce emitted with orderbook insertions, for frontend sorting
    uint256 public override nonce;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    /*╔═════════════════════════════════╗
      ║          MODIFIERS              ║
      ╚═════════════════════════════════╝*/

    /// @notice only allow markets to call certain functions
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    /// @dev emitted every time an order is added to the orderbook
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    /// @dev emitted when an order is removed from the orderbook
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    /*╔═════════════════════════════════╗
      ║         CONSTRUCTOR             ║
      ╚═════════════════════════════════╝*/

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    /*╔═════════════════════════════════╗
      ║         GOVERNANCE              ║
      ╚═════════════════════════════════╝*/

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    /*╔═════════════════════════════════════╗
      ║             INSERTIONS              ║
      ║ functions that add to the orderbook ║
      ╚═════════════════════════════════════╝*/

    /// @notice adds a new market to the orderbook
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            // create new record for each card that becomes the head&tail of the linked list
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    /// @notice adds or updates a bid in the orderbook
    /// @param _user the user placing the bid
    /// @param _card the card to place the bid on
    /// @param _price the price of the new bid
    /// @param _timeHeldLimit an optional time limit for the bid
    /// @param _prevUserAddress to help find where to insert the bid
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        // each new bid can help clean up some junk
        cleanWastePile();

        if (user[_user].length == 0) {
            //users first bid, skip already closed markets
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            // old bid exists, update it
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            // new bid, add it
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    /// @dev finds the correct location in the orderbook for a given bid
    /// @dev returns an adjusted (lowered) bid price if necessary.
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            // break loop if match price above AND above price below (so if either is false, continue, hence OR )
            // if match previous then must be greater than next to continue
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            // break loop if price x% above below
            _price < _requiredPrice &&
            // break loop if hits max iterations
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        // if previous price is zero it must be the market and this is a new owner
        // .. then don't reduce their price, we already checked they are 10% higher
        // .. than the previous owner.
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    /// @dev add a new bid to the orderbook
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // create new record
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // insert in linked list
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link
        user[_user].push(_newBid);

        // update the index to help find the record later
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    /// @dev updates a bid that is already in the orderbook
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        // TODO no need to unlink and relink if bid doesn't change position in orderbook
        // unlink current bid
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        // find new position
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        // update price, save old price for rental rate adjustment later
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        // relink bid
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; // next record update prev link
        _prevUser.next = _user; // prev record update next link

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        // update treasury values and transfer ownership if required
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            // if owner before and after, update the price difference
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            // if owner before and not after, remove the old price
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            // if not owner before but is owner after, add new price
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    /*╔══════════════════════════════════════════╗
      ║                DELETIONS                 ║      
      ║ functions that remove from the orderbook ║
      ╚══════════════════════════════════════════╝*/

    /// @notice removes a single bid from the orderbook - onlyMarkets
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    /// @dev removes a single bid from the orderbook, doesn't update ownership
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        // extract from linked list
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        // return next users price to check they're eligible later
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        // update rate
        treasury.decreaseBidRate(_user, _currUser.price);

        // overwrite array element
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        // no point overwriting itself
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        // update the index to help find the record later
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    /// @notice find the next valid owner of a given card - onlyMarkets
    /// @param _card the card to remove
    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        // the market is the head of the list, the next bid is therefore the owner
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        // delete current owner
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            // delete next bid if foreclosed
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            // the old owner is dead, long live the new owner
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            // we hit the limit, save the old owner, we'll try again next time
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards
    /// @notice .. as the markets will need to finish the accounting for them first.
    /// @param _user the user whose bids to start deleting
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                // If the prev record isn't the market, this is only a bid (not owned) so we can delete
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    /// @notice reduces the rentalRates of the card owners when a market closes
    /// @dev too many bidders to reduce all bid rates also
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        // check if the market was ever added to the orderbook
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; // start on the last record so we can easily pop()
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    // store last bid for later
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    // detach market from rest of list
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    // insert bids in the waste pile
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    // reduce owners rental rate
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                // remove the market record
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    /// @notice Remove bids in closed markets for a given user
    /// @notice this can reduce the users bidRate and chance to foreclose
    /// @param _user the address of the users bids to remove
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                // Just do the whole market at once
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        // reduce bidRate
                        uint256 _price = user[_user][_index].price;

                        // preserve linked list
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        // no point overwriting itself
                        if (_index != _lastRecord) {
                            // overwrite array element
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        // update the index to help find the record later
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        // count deletions
                        _loopCounter++;
                    } else {
                        // iterations cost gas also
                        // after enough increment the loopCounter
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    /// @dev remove bids in closed markets, not user specific
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                // extract from linked list
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                // overwrite array element
                uint256 _lastRecord = user[_user].length - 1;
                // no point overwriting itself
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                // update the index to help find the record later
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    /*╔═════════════════════════════════╗
      ║        HELPER FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice check if a bid exists
    /// @param _user the address of the user
    /// @param _market the address of the market
    /// @param _card the card index
    /// @return if the bid exists or not
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            //some bids exist
            if (index[_user][_market][_card] != 0) {
                // this bid exists
                return true;
            } else {
                // check bid isn't index 0
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    /// @dev just to pass old tests, not needed otherwise
    /// @dev but also useful to have so probably will stay
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",7831.0,933.0,"[H-01] findNewOwner edgecase
In the function `findNewOwner()` of `RCOrderbook`, as loop is done which included the check `_loopCounter < maxDeletions` Afterwards, a check is done for ""(_loopCounter != maxDeletions)"" to determine if the processing is finished. If `_loopCounter == maxDeletions` then the conclusion is that it isn't finished yet.
However, there is the edgecase that the processing might just be finished at the same time as `_loopCounter == maxDeletions`.
You can see this the best if you assume `maxDeletions==1`, in that case it will never draw the conclusion it is finished. Of course having maxDeletions==1 is very unlikely in practice.",1.0,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";


contract RCOrderbook is NativeMetaTransaction, IRCOrderbook {
    
    
    mapping(address => Bid[]) public user;
    
    mapping(address => mapping(address => mapping(uint256 => uint256)))
        public
        override index;

    
    struct Market {
        uint64 mode;
        uint64 cardCount;
        uint64 minimumPriceIncreasePercent;
        uint64 minimumRentalDuration;
    }
    
    mapping(address => Market) public market;
    
    mapping(address => mapping(uint256 => address)) public override ownerOf;
    
    mapping(address => mapping(uint256 => address)) public oldOwner;
    mapping(address => mapping(uint256 => uint256)) public oldPrice;
    
    address[] public override closedMarkets;
    
    mapping(address => uint256) public override userClosedMarketIndex;

    
    
    IRCTreasury public override treasury;
    
    
    uint256 public override maxSearchIterations = 1000;
    
    uint256 public override maxDeletions = 70;
    
    uint256 public override cleaningLoops = 2;
    
    uint256 public override marketCloseLimit = 70;
    
    uint256 public override nonce;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");

    

    
    modifier onlyMarkets() {
        require(
            treasury.checkPermission(MARKET, msgSender()),
            ""Not authorised""
        );
        _;
    }

    modifier onlyUberOwner() {
        require(
            treasury.checkPermission(UBER_OWNER, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    modifier onlyFactory() {
        require(
            treasury.checkPermission(FACTORY, msgSender()),
            ""Extremely Verboten""
        );
        _;
    }

    

    
    event LogAddToOrderbook(
        address indexed newOwner,
        uint256 indexed newPrice,
        uint256 timeHeldLimit,
        uint256 nonce,
        uint256 indexed tokenId,
        address market
    );
    
    event LogRemoveFromOrderbook(
        address indexed owner,
        address indexed market,
        uint256 indexed tokenId
    );

    

    constructor(IRCTreasury _treasury) {
        treasury = _treasury;
    }

    

    function setTreasuryAddress(address _newTreasury)
        external
        override
        onlyUberOwner
    {
        require(_newTreasury != address(0));
        treasury = IRCTreasury(_newTreasury);
    }

    function setDeletionLimit(uint256 _deletionLimit)
        external
        override
        onlyUberOwner
    {
        maxDeletions = _deletionLimit;
    }

    function setCleaningLimit(uint256 _cleaningLimit)
        external
        override
        onlyUberOwner
    {
        cleaningLoops = _cleaningLimit;
    }

    function setSearchLimit(uint256 _searchLimit)
        external
        override
        onlyUberOwner
    {
        maxSearchIterations = _searchLimit;
    }

    function setMarketCloseLimit(uint256 _marketCloseLimit)
        external
        override
        onlyUberOwner
    {
        marketCloseLimit = _marketCloseLimit;
    }

    

    
    function addMarket(
        address _market,
        uint256 _cardCount,
        uint256 _minIncrease
    ) internal {
        market[_market].cardCount = SafeCast.toUint64(_cardCount);
        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(
            _minIncrease
        );
        market[_market].minimumRentalDuration = SafeCast.toUint64(
            1 days / IRCMarket(_market).minRentalDayDivisor()
        );
        for (uint64 i = 0; i < _cardCount; i++) {
            
            Bid memory _newBid;
            _newBid.market = _market;
            _newBid.card = i;
            _newBid.prev = _market;
            _newBid.next = _market;
            _newBid.price = 0;
            _newBid.timeHeldLimit = type(uint64).max;
            index[_market][_market][i] = user[_market].length;
            user[_market].push(_newBid);
        }
    }

    
    
    
    
    
    
    function addBidToOrderbook(
        address _user,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        address _prevUserAddress
    ) external override onlyMarkets {
        address _market = msgSender();
        if (!bidExists(_market, _market, _card)) {
            uint256 _cardCount = IRCMarket(_market).numberOfCards();
            uint256 _minIncrease = IRCMarket(_market)
                .minimumPriceIncreasePercent();
            addMarket(_market, _cardCount, _minIncrease);
        }
        
        cleanWastePile();

        if (user[_user].length == 0) {
            
            userClosedMarketIndex[_user] = closedMarkets.length;
        }

        if (_prevUserAddress == address(0)) {
            _prevUserAddress = _market;
        } else {
            require(
                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]
                    .price >= _price,
                ""Location too low""
            );
        }
        require(
            bidExists(_prevUserAddress, _market, _card),
            ""Invalid starting location""
        );
        Bid storage _prevUser = user[_prevUserAddress][
            index[_prevUserAddress][_market][_card]
        ];

        if (bidExists(_user, _market, _card)) {
            
            _updateBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        } else {
            
            _newBidInOrderbook(
                _user,
                _market,
                _card,
                _price,
                _timeHeldLimit,
                _prevUser
            );
        }
    }

    
    
    function _searchOrderbook(
        Bid storage _prevUser,
        address _market,
        uint256 _card,
        uint256 _price
    ) internal view returns (Bid storage, uint256) {
        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];
        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /
            (100);

        uint256 i = 0;
        while (
            
            
            (_price != _prevUser.price || _price <= _nextUser.price) &&
            
            _price < _requiredPrice &&
            
            i < maxSearchIterations
        ) {
            _prevUser = _nextUser;
            _nextUser = user[_prevUser.next][
                index[_prevUser.next][_market][_card]
            ];
            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);
            i++;
        }
        require(i < maxSearchIterations, ""Position not found"");

        
        
        
        if (_prevUser.price != 0 && _prevUser.price < _price) {
            _price = _prevUser.price;
        }
        return (_prevUser, _price);
    }

    
    function _newBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        if (ownerOf[_market][_card] != _market) {
            (_prevUser, _price) = _searchOrderbook(
                _prevUser,
                _market,
                _card,
                _price
            );
        }

        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        
        Bid memory _newBid;
        _newBid.market = _market;
        _newBid.card = SafeCast.toUint64(_card);
        _newBid.prev = _nextUser.prev;
        _newBid.next = _prevUser.next;
        _newBid.price = SafeCast.toUint128(_price);
        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        
        _nextUser.prev = _user; 
        _prevUser.next = _user; 
        user[_user].push(_newBid);

        
        index[_user][_market][_card] = user[_user].length - (1);

        emit LogAddToOrderbook(
            _user,
            _price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        
        treasury.increaseBidRate(_user, _price);
        if (user[_user][index[_user][_market][_card]].prev == _market) {
            address _oldOwner = user[_user][index[_user][_market][_card]].next;
            transferCard(_market, _card, _oldOwner, _user, _price);
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                user[_oldOwner][index[_oldOwner][_market][_card]].price,
                _price,
                block.timestamp
            );
        }
    }

    
    function _updateBidInOrderbook(
        address _user,
        address _market,
        uint256 _card,
        uint256 _price,
        uint256 _timeHeldLimit,
        Bid storage _prevUser
    ) internal {
        
        
        Bid storage _currUser = user[_user][index[_user][_market][_card]];
        user[_currUser.next][index[_currUser.next][_market][_card]]
            .prev = _currUser.prev;
        user[_currUser.prev][index[_currUser.prev][_market][_card]]
            .next = _currUser.next;
        bool _wasOwner = _currUser.prev == _market;

        
        (_prevUser, _price) = _searchOrderbook(
            _prevUser,
            _market,
            _card,
            _price
        );
        Bid storage _nextUser = user[_prevUser.next][
            index[_prevUser.next][_market][_card]
        ];

        
        (_currUser.price, _price) = (
            SafeCast.toUint128(_price),
            uint256(_currUser.price)
        );
        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);

        
        _currUser.next = _prevUser.next;
        _currUser.prev = _nextUser.prev;
        _nextUser.prev = _user; 
        _prevUser.next = _user; 

        emit LogAddToOrderbook(
            _user,
            _currUser.price,
            _timeHeldLimit,
            nonce,
            _card,
            _market
        );
        nonce++;

        
        treasury.increaseBidRate(_user, _currUser.price);
        treasury.decreaseBidRate(_user, _price);
        if (_wasOwner && _currUser.prev == _market) {
            
            transferCard(_market, _card, _user, _user, _currUser.price);
            treasury.updateRentalRate(
                _user,
                _user,
                _price,
                _currUser.price,
                block.timestamp
            );
        } else if (_wasOwner && _currUser.prev != _market) {
            
            address _newOwner = user[_market][index[_market][_market][_card]]
                .next;
            uint256 _newPrice = user[_newOwner][
                index[_newOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _user,
                _newOwner,
                _price,
                _newPrice,
                block.timestamp
            );
            transferCard(_market, _card, _user, _newOwner, _newPrice);
        } else if (!_wasOwner && _currUser.prev == _market) {
            
            address _oldOwner = _currUser.next;
            uint256 _oldPrice = user[_oldOwner][
                index[_oldOwner][_market][_card]
            ].price;
            treasury.updateRentalRate(
                _oldOwner,
                _user,
                _oldPrice,
                _currUser.price,
                block.timestamp
            );
            transferCard(_market, _card, _oldOwner, _user, _currUser.price);
        }
    }

    

    
    function removeBidFromOrderbook(address _user, uint256 _card)
        external
        override
        onlyMarkets
    {
        address _market = msgSender();
        assert(_user != ownerOf[_market][_card]);
        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
    }

    
    function _removeBidFromOrderbookIgnoreOwner(
        address _user,
        address _market,
        uint256 _card
    ) internal returns (uint256 _newPrice) {
        Bid storage _currUser = user[_user][index[_user][_market][_card]];

        
        address _tempNext = _currUser.next;
        address _tempPrev = _currUser.prev;
        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;
        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;

        
        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;

        
        treasury.decreaseBidRate(_user, _currUser.price);

        
        uint256 _index = index[_user][_market][_card];
        uint256 _lastRecord = user[_user].length - 1;
        
        if (_index != _lastRecord) {
            user[_user][_index] = user[_user][_lastRecord];
        }
        user[_user].pop();

        
        index[_user][_market][_card] = 0;
        if (user[_user].length != 0 && _index != _lastRecord) {
            index[_user][user[_user][_index].market][
                user[_user][_index].card
            ] = _index;
        }

        assert(!bidExists(_user, _market, _card));
        emit LogRemoveFromOrderbook(_user, _market, _card);
    }

    
    
    
    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)
        external
        override
        onlyMarkets
    {
        address _newOwner = address(0);
        address _market = msgSender();
        
        Bid storage _head = user[_market][index[_market][_market][_card]];
        address _oldOwner = address(0);
        uint256 _oldPrice = 0;
        if (oldOwner[_market][_card] != address(0)) {
            _oldOwner = oldOwner[_market][_card];
            _oldPrice = oldPrice[_market][_card];
            oldOwner[_market][_card] = address(0);
            oldPrice[_market][_card] = 0;
        } else {
            _oldOwner = ownerOf[_market][_card];
            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;
        }
        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +
            market[_market].minimumRentalDuration;
        uint256 _newPrice;
        uint256 _loopCounter = 0;

        
        do {
            _newPrice = _removeBidFromOrderbookIgnoreOwner(
                _head.next,
                _market,
                _card
            );
            _loopCounter++;
            
        } while (
            treasury.foreclosureTimeUser(
                _head.next,
                _newPrice,
                _timeOwnershipChanged
            ) <
                minimumTimeToOwnTo &&
                _loopCounter < maxDeletions
        );

        if (_loopCounter != maxDeletions) {
            
            _newOwner = user[_market][index[_market][_market][_card]].next;
            treasury.updateRentalRate(
                _oldOwner,
                _newOwner,
                _oldPrice,
                _newPrice,
                _timeOwnershipChanged
            );
            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);
        } else {
            
            oldOwner[_market][_card] = _oldOwner;
            oldPrice[_market][_card] = _oldPrice;
        }
    }

    
    
    
    function removeUserFromOrderbook(address _user) external override {
        require(treasury.isForeclosed(_user), ""User must be foreclosed"");
        uint256 i = user[_user].length;
        if (i != 0) {
            uint256 _limit = 0;
            if (i > maxDeletions) {
                _limit = i - maxDeletions;
            }

            do {
                i--;

                
                if (user[_user][i].prev != user[_user][i].market) {
                    address _market = user[_user][i].market;
                    uint256 _card = user[_user][i].card;
                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);
                }
            } while (user[_user].length > _limit && i > 0);
        }
        treasury.assessForeclosure(_user);
    }

    
    
    function closeMarket() external override onlyMarkets returns (bool) {
        address _market = msgSender();
        
        if (bidExists(_market, _market, 0)) {
            closedMarkets.push(_market);
            uint256 i = user[_market].length; 
            uint256 _limit = 0;
            if (marketCloseLimit < user[_market].length) {
                _limit = user[_market].length - marketCloseLimit;
            } else {
                _limit = 0;
            }
            do {
                i--;
                address _lastOwner = user[_market][index[_market][_market][i]]
                    .next;
                if (_lastOwner != _market) {
                    uint256 _price = user[_lastOwner][
                        index[_lastOwner][_market][i]
                    ].price;

                    
                    address _lastBid = user[_market][index[_market][_market][i]]
                        .prev;

                    
                    user[_market][index[_market][_market][i]].prev = _market;
                    user[_market][index[_market][_market][i]].next = _market;
                    user[_lastOwner][index[_lastOwner][_market][i]]
                        .prev = address(this);
                    user[_lastBid][index[_lastBid][_market][i]].next = address(
                        this
                    );

                    index[address(this)][_market][i] = user[address(this)]
                        .length;

                    
                    Bid memory _newBid;
                    _newBid.market = _market;
                    _newBid.card = SafeCast.toUint64(i);
                    _newBid.prev = _lastBid;
                    _newBid.next = _lastOwner;
                    _newBid.price = 0;
                    _newBid.timeHeldLimit = 0;
                    user[address(this)].push(_newBid);

                    
                    treasury.updateRentalRate(
                        _lastOwner,
                        _market,
                        _price,
                        0,
                        block.timestamp
                    );
                }
                
                user[_market].pop();
            } while (i > _limit);
        }
        if (user[_market].length == 0) {
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function removeOldBids(address _user) external override {
        if (user[_user].length != 0) {
            address _market = address(0);
            uint256 _cardCount = 0;
            uint256 _loopCounter = 0;
            uint256 _subLoopCounter = 0;
            while (
                userClosedMarketIndex[_user] < closedMarkets.length &&
                _loopCounter + _cardCount < maxDeletions
            ) {
                _market = closedMarkets[userClosedMarketIndex[_user]];
                
                _cardCount = market[_market].cardCount;
                uint256 i = _cardCount;
                do {
                    i--;
                    if (bidExists(_user, _market, i)) {
                        uint256 _index = index[_user][_market][i];
                        
                        uint256 _price = user[_user][_index].price;

                        
                        address _tempPrev = user[_user][_index].prev;
                        address _tempNext = user[_user][_index].next;

                        user[_tempNext][index[_tempNext][_market][i]]
                            .prev = _tempPrev;
                        user[_tempPrev][index[_tempPrev][_market][i]]
                            .next = _tempNext;

                        uint256 _lastRecord = user[_user].length - 1;
                        
                        if (_index != _lastRecord) {
                            
                            user[_user][_index] = user[_user][_lastRecord];
                        }
                        user[_user].pop();

                        
                        index[_user][_market][i] = 0;
                        if (user[_user].length != 0 && _index != _lastRecord) {
                            index[_user][user[_user][_index].market][
                                user[_user][_index].card
                            ] = _index;
                        }

                        treasury.decreaseBidRate(_user, _price);
                        
                        _loopCounter++;
                    } else {
                        
                        
                        _subLoopCounter++;
                        if (_subLoopCounter > 100) {
                            _subLoopCounter = 0;
                            _loopCounter++;
                        }
                    }
                } while (i > 0);
                userClosedMarketIndex[_user]++;
            }
        }
    }

    
    function cleanWastePile() public override {
        uint256 i = 0;
        while (i < cleaningLoops && user[address(this)].length > 0) {
            uint256 _pileHeight = user[address(this)].length - 1;
            address _market = user[address(this)][_pileHeight].market;
            uint256 _card = user[address(this)][_pileHeight].card;
            address _user = user[address(this)][_pileHeight].next;

            if (user[address(this)][_pileHeight].next == address(this)) {
                index[address(this)][_market][_card] = 0;
                user[address(this)].pop();
            } else {
                uint256 _index = index[_user][_market][_card];
                address _tempNext = user[_user][_index].next;

                treasury.decreaseBidRate(_user, user[_user][_index].price);

                
                user[address(this)][_pileHeight].next = _tempNext;
                user[_tempNext][index[_tempNext][_market][_card]]
                    .prev = address(this);

                
                uint256 _lastRecord = user[_user].length - 1;
                
                if (_index != _lastRecord) {
                    user[_user][_index] = user[_user][_lastRecord];
                }
                user[_user].pop();

                
                index[_user][_market][_card] = 0;
                if (user[_user].length != 0 && _index != _lastRecord) {
                    index[_user][user[_user][_index].market][
                        user[_user][_index].card
                    ] = _index;
                }
            }
            i++;
        }
    }

    

    
    
    
    
    
    function bidExists(
        address _user,
        address _market,
        uint256 _card
    ) public view override returns (bool) {
        if (user[_user].length != 0) {
            
            if (index[_user][_market][_card] != 0) {
                
                return true;
            } else {
                
                if (
                    user[_user][0].market == _market &&
                    user[_user][0].card == _card
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    function getBidValue(address _user, uint256 _card)
        external
        view
        override
        returns (uint256)
    {
        address _market = msgSender();
        if (bidExists(_user, _market, _card)) {
            return user[_user][index[_user][_market][_card]].price;
        } else {
            return 0;
        }
    }

    
    
    function getBid(
        address _market,
        address _user,
        uint256 _card
    ) external view override returns (Bid memory) {
        if (bidExists(_user, _market, _card)) {
            Bid memory _bid = user[_user][index[_user][_market][_card]];
            return _bid;
        } else {
            Bid memory _newBid;
            _newBid.market = address(0);
            _newBid.card = SafeCast.toUint64(_card);
            _newBid.prev = address(0);
            _newBid.next = address(0);
            _newBid.price = 0;
            _newBid.timeHeldLimit = 0;
            return _newBid;
        }
    }

    function getTimeHeldlimit(address _user, uint256 _card)
        external
        view
        override
        onlyMarkets
        returns (uint256)
    {
        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;
    }

    function setTimeHeldlimit(
        address _user,
        uint256 _card,
        uint256 _timeHeldLimit
    ) external override onlyMarkets {
        address _market = msgSender();
        require(bidExists(_user, _market, _card), ""Bid doesn't exist"");
        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast
            .toUint64(_timeHeldLimit);
    }

    function reduceTimeHeldLimit(
        address _user,
        uint256 _card,
        uint256 _timeToReduce
    ) external override onlyMarkets {
        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast
            .toUint64(_timeToReduce);
    }

    function transferCard(
        address _market,
        uint256 _card,
        address _oldOwner,
        address _newOwner,
        uint256 _price
    ) internal {
        ownerOf[_market][_card] = _newOwner;
        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]
            .timeHeldLimit;
        IRCMarket _rcmarket = IRCMarket(_market);
        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);
    }
    
}",5819.0,1,0,"] [0]
                }
            }
            i++;
        }
    }

    function transferCard(address _market, uint256 _card, address _from, address _to, uint256 _price) internal {
        require(ownerOf[_market][_card] == _from, ""Not owner"");
        ownerOf[_market][_card] = _to;
        emit LogCardTransfer(_market, _from, _to, _card, _price);
    }

    function bidExists(address _user, address _market, uint256 _card) internal view returns (bool) {
        if (index[_user][_market][_card] == 0) {
            return false;
        } else {
            return true;
        }
    }
    
    function getBid(
        address _user,
        address _market,
        uint256 _card
    ) public view returns (Bid memory) {
        return user[_user][index[_user][_market][_card]];
    }
    
    function getBidPrice(
        address _user,
        address _market,
        uint256 _card
    ) public view returns (uint256) {
        return user[_user][index[_user][_market][_card]].price;
    }

    function getCardOwner(
        address _market,
        uint256 _card
    ) public view returns (address) {
        return ownerOf[_market][_card];
    }
    
    function getCardPrice(
        address _market,
        uint256 _card
    ) public view returns (uint256) {
        return user[ownerOf[_market][_card]][index[ownerOf[_market][_card]][_market][_card]].price;
    }
    
    function getMarketCardCount(
        address _market
    ) public view returns (uint64) {
        return market[_market].cardCount;
    }
    
    function getMarketMinimumPriceIncrease(
        address _market
    ) public view returns (uint64) {
        return market[_market].minimumPriceIncreasePercent;
    }
    
    function getMarketMinimumRentalDuration(
        address _market
    ) public view returns (uint64) {
        return market[_market].minimumRentalDuration;
    }
    
    function getMarketAddress(
        uint256 _marketId
    ) public view returns (address) {
        return closedMarkets[_marketId];
    }
    
    function getCardIndex(
        address _user,
        address _market,
        uint256 _card
    ) public view returns (uint256) {
        return index[_user][_market][_card];
    }
    
    function getCardIndex(
        address _market,
        uint256 _card
    ) public view returns (uint256) {
        return index[ownerOf[_market][_card]][_market][_card];
    }
    
    function getCardIndex(
        address _user,
        address _market
    ) public view returns (uint256) {
        return user[_user].length - 1;
    }
    
    function getCardIndex(
        address _market
    ) public view returns (uint256) {
        return user[ownerOf[_market][0]].length - 1;
    }
    
    function getCardIndex(
        address _user
    ) public view returns (uint256) {
        return user[_user].length - 1;
    }
    
    function getCardIndex(
        address _user,
        uint256 _card
    ) public view returns (uint256) {
        return index[_user][address(this)][_card];
    }
    
    function getCardIndex(
        address _market,
        uint256 _card
    ) public view returns (uint256) {
        return index[ownerOf[_market][_card]][_market][_card];
    }
    
    function getCardIndex(
        uint256 _card
    ) public view returns (uint256) {
        return index[ownerOf[address(this)][_card]][address(this)][_card];
    }
    
    function getCardIndex(
        address _market,
        uint256 _card,
        uint256 _index
    ) public view returns (uint256) {
        require(_index < user[ownerOf[_market][_card]].length, ""Index out of bounds"");
        return _index;
    }
    
    function getCardIndex(
        address _user,
        address _market,
        uint256 _card,
        uint256 _index
    ) public view returns (uint256) {
        require(_index < user[_user].length, ""Index out of bounds"");
        return _index;
    }
    
    function getCardIndex(
        address _market,
        uint256 _card,
        uint256 _index
    ) public view returns (uint256) {
        require(_index < user[ownerOf[_market][_card]].length,","### **[H-01] findNewOwner edgecase**

**Report Description**:  
In the function `findNewOwner()` of `RCOrderbook`, a loop is executed with the condition `_loopCounter < maxDeletions`. After the loop, a check is performed to determine if processing is finished by verifying `_loopCounter != maxDeletions`. If `_loopCounter == maxDeletions`, the function concludes that processing is not finished. However, there is an edge case where processing might be completed exactly when `_loopCounter == maxDeletions`. This issue is most evident when `maxDeletions == 1`, as the function will never conclude that processing is finished. While `maxDeletions == 1` is unlikely in practice, this edge case could lead to incorrect behavior in the contract.

**Match in Response List**:  
**No match found**. The `response_list` does not address the edge case in the `findNewOwner()` function or any related logic involving loop counters and termination conditions.

**Validation**:  
**Incorrect**. The `response_list` does not address the issue described in the report. The edge case in `findNewOwner()` is entirely missed, and there is no discussion of loop termination conditions or potential logical flaws in the function. This omission represents a significant gap in the response.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] findNewOwner edgecase**

---

### **Conclusion**  
The `response_list` does not address the edge case described in the issue report. This represents a critical gap in the response, as the issue could lead to incorrect contract behavior under specific conditions. The response should be updated to include a discussion of loop termination conditions and edge cases in functions like `findNewOwner()`.",0,0,1,20,"```
None.
```",0.0
RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;

    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public override orderbook;
    /// @dev leaderboard instance
    IRCLeaderboard public override leaderboard;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev the Factory so only the Factory can add new markets
    IRCFactory public override factory;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public override marketBalance;
    /// @dev a quick check if a user is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 public override marketBalanceTopup;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    /// @dev intended for beta use only, will be disabled after launch
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    /// @dev allow markets to be restricted to a certain role
    mapping(address => bytes32) public marketWhitelist;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent, claim or upgrade any cards for specific market
    mapping(address => bool) public override marketPaused;
    /// @dev if true, owner has locked the market pause (Governors are locked out)
    mapping(address => bool) public override lockMarketPaused;

    /*╔═════════════════════════════════╗
      ║          Access Control         ║
      ╚═════════════════════════════════╝*/
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        /* setup AccessControl

                         UBER_OWNER
            ┌───────────┬────┴─────┬────────────┬─────────┐
            │           │          │            │         │
          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD
            │           │
         GOVERNOR     MARKET
            │
         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE
        */
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1_000_000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks() {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyRole(OWNER)
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUCTOR - PUBLIC │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @dev this is only a soft check, it is possible to exceed this limit
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add/Remove multiple users to the whitelist
    /// @param _users an array of users to add or remove
    /// @param add true to add the users
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    /// @notice Some markets may be restricted to certain roles,
    /// @notice This function checks if the user has the role requried for a given market
    /// @dev Used for the markets to check themselves
    /// @param _user The user to check
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governance functions

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        // factory is also an OWNER and GOVERNOR to use the proxy functions
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised
        erc20.safeTransfer(msg.sender, _balance);
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        assessForeclosure(_user);
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // step 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        // do some cleaning up first, it might help avoid their foreclosure
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            // foreclose user, this is requred to remove them from the orderbook
            isForeclosed[_msgSender] = true;
            // remove them from the orderbook
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        /// @dev return the amount just incase it was adjusted
        return _amount;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        // update the last rental time
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        // check if this is their first rental (no previous rental calculation)
        if (user[_user].lastRentCalc == 0) {
            // we need to start their clock ticking, update their last rental calculation time
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /// @notice provides the sum total of a users bids across all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                // they have enough funds, just collect the extra
                // we can be sure of this because it was checked they can cover the minimum rental
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    // send an event for the UI to have a timestamp
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calculation and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calculates the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                // calculate how long they can own the new card for
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    // new bid is after user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    // new bid is before user rent calculation
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    // The user couldn't afford to own the new card up to their last
                    // .. rent calculation, we can't rewind their rent calculation because
                    // .. of gas limits (there could be many markets having taken rent).
                    // Therefore unfortunately we can't give any ownership to this user as
                    // .. this could mean getting caught in a loop we may not be able to
                    // .. exit because of gas limits (there could be many users in this
                    // .. situation and we can't leave any unaccounted for).
                    // This means we return 0 to signify that the user can't afford this
                    // .. new ownership.
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                // if no rentals they'll foreclose after the heat death of the universe
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepositLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets available balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    /// @notice checks if the user should still be foreclosed
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            // need to emit old event until frontend catches up
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    /*
         ▲  
        ▲ ▲ 
              */
}",8609.0,920.0,"[H-02] UberOwner has too much power
The`Uber_Owner` has too much power within the system. This makes the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner. See issue page for referenced code
The above functions can be used by the Uber Owner to completely change the functionality of the system. This goes well beyond simple setting new constants and fees, the Uber Owner can basically reprogram how the entire protocol works. Not to mention if the address falls into the wrong hands.
Recommend limiting the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required they can be done through a proxy instead, in the standard way.
  [M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol
The variable, `marketWhitelist`, is never initialized in the contract RCTreasury.sol. As a result, the function `marketWhitelistCheck()` does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return true, even if a market wishes to restrict its users to a specific role.
The initial state variable is defined in RCTreasury.sol L75.
The state variable `marketWhitelist` is accessed in the function RCTreasury.marketWhitelistCheck() at RCTreasury.sol L269-L281.
The function RCTreasury.marketWhitelistCheck() is called in RCMarket.newRental() at RCMarket.sol L758-L761. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in RCTreasury that allow a market creator to enable this functionality.
Recommend ensuring this behavior is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.
  [M-03] Deposits don't work with fee-on transfer tokens
There are ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`. Others are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).
The `deposit()` function will credit more deposits than the contract actually received:
``` erc20.safeTransferFrom(msgSender(), address(this), _amount);
user[_user].deposit += SafeCast.toUint128(_amount); ```",3.0,"pragma solidity 0.8.7;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";



contract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {
    using SafeERC20 for IERC20;
 
    IRCOrderbook public override orderbook;
    
    IRCLeaderboard public override leaderboard;
    
    IERC20 public override erc20;
    
    address public override bridgeAddress;
    
    IRCFactory public override factory;
    
    uint256 public override totalDeposits;
    
    mapping(address => uint256) public override marketPot;
    
    uint256 public override totalMarketPots;
    
    uint256 public override marketBalance;
    
    mapping(address => bool) public override isForeclosed;
    
    uint256 public override marketBalanceTopup;

    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;


    uint256 public override minRentalDayDivisor;
    
    uint256 public override maxContractBalance;
    
    
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;
    
    mapping(address => bytes32) public marketWhitelist;

    
    
    bool public override globalPause;
    
    mapping(address => bool) public override marketPaused;
    
    mapping(address => bool) public override lockMarketPaused;

    
    bytes32 public constant UBER_OWNER = keccak256(""UBER_OWNER"");
    bytes32 public constant OWNER = keccak256(""OWNER"");
    bytes32 public constant GOVERNOR = keccak256(""GOVERNOR"");
    bytes32 public constant FACTORY = keccak256(""FACTORY"");
    bytes32 public constant MARKET = keccak256(""MARKET"");
    bytes32 public constant TREASURY = keccak256(""TREASURY"");
    bytes32 public constant ORDERBOOK = keccak256(""ORDERBOOK"");
    bytes32 public constant WHITELIST = keccak256(""WHITELIST"");
    bytes32 public constant ARTIST = keccak256(""ARTIST"");
    bytes32 public constant AFFILIATE = keccak256(""AFFILIATE"");
    bytes32 public constant CARD_AFFILIATE = keccak256(""CARD_AFFILIATE"");

    

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);
    event LogWhitelistUser(address user, bool allowed);

    

    constructor(address _tokenAddress) {
        
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(UBER_OWNER, _msgSender());
        _setupRole(OWNER, _msgSender());
        _setupRole(GOVERNOR, _msgSender());
        _setupRole(WHITELIST, _msgSender());
        _setupRole(TREASURY, address(this));
        _setRoleAdmin(UBER_OWNER, UBER_OWNER);
        _setRoleAdmin(OWNER, UBER_OWNER);
        _setRoleAdmin(FACTORY, UBER_OWNER);
        _setRoleAdmin(ORDERBOOK, UBER_OWNER);
        _setRoleAdmin(TREASURY, UBER_OWNER);
        _setRoleAdmin(GOVERNOR, OWNER);
        _setRoleAdmin(WHITELIST, GOVERNOR);
        _setRoleAdmin(ARTIST, GOVERNOR);
        _setRoleAdmin(AFFILIATE, GOVERNOR);
        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);
        _setRoleAdmin(MARKET, FACTORY);

        
        setMinRental(24 * 6); 
        setMaxContractBalance(1_000_000 ether); 
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    
    modifier balancedBooks() {
        _;
        
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
        minRentalDayDivisor = _newDivisor;
    }

    
    
    
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyRole(OWNER)
    {
        maxContractBalance = _newBalanceLimit;
    }

   
    
    function changeGlobalPause() external override onlyRole(OWNER) {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    
    function changePauseMarket(address _market, bool _paused)
        external
        override
        onlyRole(OWNER)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        marketPaused[_market] = _paused;
        lockMarketPaused[_market] = marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    
    function unPauseMarket(address _market)
        external
        override
        onlyRole(FACTORY)
    {
        require(hasRole(MARKET, _market), ""This isn't a market"");
        require(!lockMarketPaused[_market], ""Owner has paused market"");
        marketPaused[_market] = false;
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    

    
    function toggleWhitelist() external override onlyRole(OWNER) {
        whitelistEnabled = !whitelistEnabled;
    }

    
    
    
    function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }

    
    
    
    
    function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }

    
    
    
    
    

    function setFactoryAddress(address _newFactory)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newFactory != address(0), ""Must set an address"");
        
        revokeRole(FACTORY, address(factory));
        revokeRole(OWNER, address(factory));
        revokeRole(GOVERNOR, address(factory));
        factory = IRCFactory(_newFactory);
        grantRole(FACTORY, address(factory));
        grantRole(OWNER, address(factory));
        grantRole(GOVERNOR, address(factory));
    }

    function setOrderbookAddress(address _newOrderbook)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newOrderbook != address(0), ""Must set an address"");
        revokeRole(ORDERBOOK, address(orderbook));
        orderbook = IRCOrderbook(_newOrderbook);
        grantRole(ORDERBOOK, address(orderbook));
        factory.setOrderbookAddress(orderbook);
    }

    function setLeaderboardAddress(address _newLeaderboard)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newLeaderboard != address(0), ""Must set an address"");
        leaderboard = IRCLeaderboard(_newLeaderboard);
        factory.setLeaderboardAddress(leaderboard);
    }

    function setTokenAddress(address _newToken)
        public
        override
        onlyRole(UBER_OWNER)
    {
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge)
        external
        override
        onlyRole(UBER_OWNER)
    {
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    
    function globalExit() external onlyRole(UBER_OWNER) {
        uint256 _balance = erc20.balanceOf(address(this));
        
        erc20.safeTransfer(msg.sender, _balance);
    }

    

    
    
    
    
    
    function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        
        assessForeclosure(_user);
        return true;
    }

    
    
    
    
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        
        
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        
        collectRentUser(_msgSender, block.timestamp);

        
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.safeTransfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        
        
        orderbook.removeOldBids(_msgSender);
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            
            isForeclosed[_msgSender] = true;
            
            orderbook.removeUserFromOrderbook(_msgSender);
        }
    }

    
    
    function topupMarketBalance(uint256 _amount)
        external
        override
        balancedBooks
    {
        erc20.safeTransferFrom(msgSender(), address(this), _amount);
        marketBalanceTopup += _amount;
        marketBalance += _amount;
    }

    

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    
    

    
    
    
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (uint256)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            uint256 discrepancy = _amount - marketBalance;
            if (discrepancy > marketBalanceTopup) {
                marketBalanceTopup = 0;
            } else {
                marketBalanceTopup -= discrepancy;
            }
            _amount = marketBalance;
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;
        
        return _amount;
    }

    
    
    
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        assessForeclosure(_user);
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    
    function refundUser(address _user, uint256 _refund)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        assessForeclosure(_user);
    }

    
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyRole(MARKET)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        address _msgSender = msgSender();
        require(!lockMarketPaused[_msgSender], ""Market is paused"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.safeTransferFrom(_sponsor, address(this), _amount);
        marketPot[_msgSender] += _amount;
        totalMarketPots += _amount;
    }

    
    
    
    function updateLastRentalTime(address _user)
        external
        override
        onlyRole(MARKET)
    {
        
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        
        if (user[_user].lastRentCalc == 0) {
            
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
    }

    

    function addMarket(address _market, bool _paused) external override {
        require(hasRole(FACTORY, msgSender()), ""Not Authorised"");
        marketPaused[_market] = _paused;
        AccessControl.grantRole(MARKET, _market);
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    
    
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    
    
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    

    
    
    
    
    
    
    
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyRole(ORDERBOOK) {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !hasRole(MARKET, _newOwner)
        ) {
            
            
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                

                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(
                    user[_newOwner].lastRentCalc,
                    _timeOwnershipChanged,
                    _newPrice
                );

                
                
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);
            } else {
                
                if (user[_newOwner].rentalRate != 0) {
                    
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                    
                    emit LogAdjustDeposit(_newOwner, 0, false);
                }
            }
        }
        
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyRole(ORDERBOOK)
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    

    
    
    
    
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    
    
    
    
    
    
    function rentOwedBetweenTimestamps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    
    
    
    
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /
                totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +
                timeLeftOfDeposit;

            if (
                foreclosureTimeWithoutNewCard > _timeOfNewBid &&
                _timeOfNewBid != 0
            ) {
                
                uint256 _rentDifference = rentOwedBetweenTimestamps(
                    user[_user].lastRentCalc,
                    _timeOfNewBid,
                    totalUserDailyRent
                );
                uint256 _depositAtTimeOfNewBid = 0;

                if (user[_user].lastRentCalc < _timeOfNewBid) {
                    
                    _depositAtTimeOfNewBid =
                        user[_user].deposit -
                        _rentDifference;
                } else {
                    
                    _depositAtTimeOfNewBid =
                        user[_user].deposit +
                        _rentDifference;
                }

                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *
                    1 days) / (totalUserDailyRent + _newBid);

                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +
                    _timeLeftOfDepositWithNewBid;
                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {
                    return _foreclosureTimeWithNewCard;
                } else {
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    return 0;
                }
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            if (_newBid == 0) {
                
                return type(uint256).max;
            } else {
                return
                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);
            }
        }
    }

    
    
    
    
    
    
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        require(_timeToCollectTo != 0, ""Must set collection time"");
        require(
            _timeToCollectTo <= block.timestamp,
            ""Can't collect future rent""
        );
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                
                uint256 timeUsersDepositLasts = ((_timeToCollectTo -
                    previousCollectionTime) * uint256(user[_user].deposit)) /
                    rentOwedByUser;
                
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }

    
    function assessForeclosure(address _user) public override {
        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        } else {
            isForeclosed[_user] = true;
            emit LogUserForeclosed(_user, true);
        }
    }

    
    function checkPermission(bytes32 role, address account)
        external
        view
        override
        returns (bool)
    {
        return AccessControl.hasRole(role, account);
    }

    function grantRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.grantRole(_role, account);
    }

    function grantRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            
            emit LogWhitelistUser(account, true);
        }
        AccessControl.grantRole(role, account);
    }

    function revokeRole(string memory role, address account) external override {
        bytes32 _role = keccak256(abi.encodePacked(role));
        RCTreasury.revokeRole(_role, account);
    }

    function revokeRole(bytes32 role, address account)
        public
        override(AccessControl, IRCTreasury)
    {
        if (role == WHITELIST) {
            
            emit LogWhitelistUser(account, false);
        }
        AccessControl.revokeRole(role, account);
    }

    
}",5177.0,1,2,"Identified vulnerabilities:
1. **Reentrancy Risk** *(Medium)*:  
   **Description:**  
   The `withdrawDeposit` function uses `ERC20.safeTransfer` to send tokens to the user. If the recipient is a contract, it could potentially call back into the `withdrawDeposit` function before the state is updated, leading to reentrancy.  While `safeTransfer` includes a 200 gas stipend which can prevent reentrancy, this pattern is still considered risky.

   **Impact:**  
   An attacker could potentially drain more tokens than they are entitled to by repeatedly calling the `withdrawDeposit` function before the state is updated.

   **Mitigation:**  
   ```solidity
   // Use the Checks-Effects-Interactions pattern to prevent reentrancy
   function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
       external
       override
       balancedBooks
   {
       require(!globalPause, ""Withdrawals are disabled"");
       address _msgSender = msgSender();
       require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
       
       // Effects
       collectRentUser(_msgSender, block.timestamp);

       if (_amount > user[_msgSender].deposit) {
           _amount = user[_msgSender].deposit;
       }
       emit LogAdjustDeposit(_msgSender, _amount, false);
       user[_msgSender].deposit -= SafeCast.toUint128(_amount);
       totalDeposits -= _amount;

       // Interaction
       if (_localWithdrawal) {
           erc20.safeTransfer(_msgSender, _amount);
       } else {
           IRCBridge bridge = IRCBridge(bridgeAddress);
           bridge.withdrawToMainnet(_msgSender, _amount);
       }

       if (
           user[_msgSender].bidRate!= 0 &&
           user[_msgSender].bidRate / (minRentalDayDivisor) >
           user[_msgSender].deposit
       ) {
           isForeclosed[_msgSender] = true;
           orderbook.removeUserFromOrderbook(_msgSender);
       }
   }
   ```

2. **Missing Input Validation** *(Low)*:  
   **Description:**  
   The `setMinRental` function does not validate that the new divisor is greater than zero.  This could lead to a situation where the rental calculation becomes nonsensical.

   **Impact:**  
   If the `minRentalDayDivisor` is set to 0, the rental calculation becomes invalid, potentially leading to incorrect rent calculations and unexpected behavior.

   **Mitigation:**  
   ```solidity
   function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {
       require(_newDivisor > 0, ""Divisor must be greater than zero"");
       minRentalDayDivisor = _newDivisor;
   }
   ```

3. **Lack of Access Control on Critical Functions** *(High)*:  
   **Description:**  
   The `setOrderbookAddress` and `setLeaderboardAddress` functions lack proper access control. While they are restricted to the `UBER_OWNER` role, the `setFactoryAddress` function is restricted to the `UBER_OWNER` role, but the `setOrderbookAddress` and `setLeaderboardAddress` functions are not properly secured.  Additionally, the `setOrderbookAddress` function does not check if the new address is a valid contract.

   **Impact:**  
   An attacker could potentially set the orderbook or leaderboard addresses to malicious contracts, leading to unexpected behavior or loss of funds.

   **Mitigation:**  
   ```solidity
   function setOrderbookAddress(address _newOrderbook) external override onlyRole(UBER_OWNER) {
       require(_newOrderbook!= address(0), ""Must set an address"");
       require(_newOrderbook!= address(0), ""Must set a valid contract"");
       revokeRole(ORDERBOOK, address(orderbook));
       orderbook = IRCOrderbook(_newOrderbook);
       grantRole(ORDERBOOK, address(orderbook));
       factory.setOrderbookAddress(orderbook);
   }
   ```

4. **Integer Overflow/Underflow** *(Medium)*:  
   **Description:**  
   The contract uses SafeMath to","### **Output**

---

### **[H-02] UberOwner has too much power**

**Report Description**:  
The `Uber_Owner` has excessive control over the system, making the protocol resemble a centralized prediction market. The `Uber_Owner` can completely alter the system's functionality, going beyond simple parameter adjustments. This poses a significant risk if the `Uber_Owner` address is compromised. The recommendation is to limit the `Uber_Owner`'s permissions and use a proxy for upgrades.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of improper access control but focuses on specific functions (`setOrderbookAddress` and `setLeaderboardAddress`) rather than the broader concern of the `Uber_Owner`'s excessive power. While the response correctly highlights the risk of setting critical addresses, it does not address the systemic issue of the `Uber_Owner`'s ability to reprogram the entire protocol.

---

### **[M-01] Uninitialized Variable `marketWhitelist` in `RCTreasury.sol`**

**Report Description**:  
The variable `marketWhitelist` is never initialized in `RCTreasury.sol`, causing the function `marketWhitelistCheck()` to always return `true`. This prevents the intended functionality of restricting markets to specific whitelists. The recommendation is to ensure the behavior is intentional or add a function to enable whitelisting.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of uninitialized variables or the specific problem with `marketWhitelist`. This is a missed issue.

---

### **[M-03] Deposits don't work with fee-on-transfer tokens**

**Report Description**:  
The `deposit()` function does not account for fee-on-transfer or rebasing tokens, leading to discrepancies between the actual received amount and the credited deposit. This can result in incorrect accounting and potential vulnerabilities.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens or the specific problem with the `deposit()` function. This is a missed issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-02] UberOwner has too much power**

**Missed Issues from Issue Report**:  
- **[M-01] Uninitialized Variable `marketWhitelist` in `RCTreasury.sol`**  
- **[M-03] Deposits don't work with fee-on-transfer tokens**

---

### **Conclusion**

The `response_list` partially addresses one issue ([H-02]) but misses two critical vulnerabilities ([M-01] and [M-03]). The responses focus on reentrancy, input validation, and access control but fail to cover uninitialized variables and fee-on-transfer token handling. To improve coverage, the response list should include these issues and provide specific mitigations.",2,1,0,18,"```
None.
```",0.0
,,,,,,,,2,2,,,2,1,1,38,,
