nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
synthVault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";

contract SynthVault {
    address public BASE;
    address public DEPLOYER;

    uint256 public minimumDepositTime;  // Withdrawal & Harvest lockout period; intended to be 1 hour
    uint256 public totalWeight;         // Total weight of the whole SynthVault
    uint256 public erasToEarn;          // Amount of eras that make up the targeted RESERVE depletion; regulates incentives
    uint256 public vaultClaim;          // The SynthVaults's portion of rewards; intended to be ~10% initially
    address [] public stakedSynthAssets; // Array of all synth assets that have ever been staked in (scope: vault)
    uint private lastMonth;             // Timestamp of the start of current metric period (For UI)
    uint public genesis;                // Timestamp from when the synth was first deployed (For UI)

    uint256 public map30DVaultRevenue; // Tally of revenue during current incomplete metric period (for UI)
    uint256 public mapPast30DVaultRevenue; // Tally of revenue from last full metric period (for UI)
    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor(address _base) {
        BASE = _base;
        DEPLOYER = msg.sender;
        erasToEarn = 30;
        minimumDepositTime = 3600; // 1 hour
        vaultClaim = 1000;
        genesis = block.timestamp;
        lastMonth = 0;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;
    mapping(address => uint256) private mapMemberTotal_weight;
    mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;

    mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;
    mapping(address => uint256) private mapMember_depositTime;
    mapping(address => uint256) public lastBlock;
    mapping(address => bool) private isStakedSynth;
    mapping(address => mapping(address => bool)) private isSynthMember;

    event MemberDeposits(
        address indexed synth,
        address indexed member,
        uint256 newDeposit,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberWithdraws(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberHarvests(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );

    function setParams(uint256 one, uint256 two, uint256 three) external onlyDAO {
        erasToEarn = one;
        minimumDepositTime = two;
        vaultClaim = three;
    }

    //====================================== DEPOSIT ========================================//

    // User deposits Synths in the SynthVault
    function deposit(address synth, uint256 amount) external {
        depositForMember(synth, msg.sender, amount);
    }

    // Contract deposits Synths in the SynthVault for user
    function depositForMember(address synth, address member, uint256 amount) public {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); // Must be a valid synth
        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in
        _deposit(synth, member, amount); // Assess and record the deposit
    }

    // Check and record the deposit
    function _deposit(address _synth, address _member, uint256 _amount) internal {
        if(!isStakedSynth[_synth]){
            isStakedSynth[_synth] = true; // Record as a staked synth
            stakedSynthAssets.push(_synth); // Add to staked synth array
        }
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth)
        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member)
        mapMemberSynth_deposit[_member][_synth] += _amount; // Record balance for member
        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); // Get the SPARTA weight of the deposit
        mapMemberSynth_weight[_member][_synth] += _weight; // Add the weight to the user (scope: member -> synth)
        mapMemberTotal_weight[_member] += _weight; // Add to the user's total weight (scope: member)
        totalWeight += _weight; // Add to the total weight (scope: vault)
        isSynthMember[_member][_synth] = true; // Record user as a member
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    //====================================== HARVEST ========================================//

    // User harvests all of their available rewards
    function harvestAll() external returns (bool) {
        for(uint i = 0; i < stakedSynthAssets.length; i++){
            if((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){
                uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);
                if(reward > 0){
                    harvestSingle(stakedSynthAssets[i]);
                }
            }
            
        }
        return true;
    }

    // User harvests available rewards of the chosen asset
    function harvestSingle(address synth) public returns (bool) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); // Must be valid synth
        require(iRESERVE(_DAO().RESERVE()).emissions(), ""!emissions""); // RESERVE emissions must be on
        uint256 _weight;
        uint256 reward = calcCurrentReward(synth, msg.sender); // Calc user's current SPARTA reward
        mapMemberSynth_lastTime[msg.sender][synth] = block.timestamp; // Set last harvest time as now
        address _poolOUT = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(iSYNTH(synth).LayerONE()); // Get pool address
        iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT); // Send the SPARTA from RESERVE to POOL
        (uint synthReward,) = iPOOL(_poolOUT).mintSynth(synth, address(this)); // Mint synths & tsf to SynthVault
        _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(synth).LayerONE(), synthReward); // Calc reward's SPARTA value
        mapMemberSynth_deposit[msg.sender][synth] += synthReward; // Record deposit for the user (scope: member -> synth)
        mapMemberSynth_weight[msg.sender][synth] += _weight; // Add the weight to the user (scope: member -> synth)
        mapMemberTotal_weight[msg.sender] += _weight; // Add to the user's total weight (scope: member)
        totalWeight += _weight; // Add to the total weight (scope: vault)
        _addVaultMetrics(reward); // Add to the revenue metrics (for UI)
        iSYNTH(synth).realise(_poolOUT); // Check synth-held LP value for premium; burn if so
        emit MemberHarvests(synth, msg.sender, reward, _weight, totalWeight);
        return true;
    }

    // Calculate the user's current incentive-claim per era based on selected asset
    function calcCurrentReward(address synth, address member) public view returns (uint256 reward){
        require((block.timestamp > mapMemberSynth_lastTime[member][synth]), ""!unlocked""); // Must not harvest before lockup period passed
        uint256 _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]; // Get seconds passed since last claim
        uint256 _share = calcReward(synth, member); // Get member's share of RESERVE incentives
        reward = (_share * _secondsSinceClaim) / iBASE(BASE).secondsPerEra(); // User's share times eras since they last claimed
        return reward;
    }

    // Calculate the user's current total claimable incentive
    function calcReward(address synth, address member) public view returns (uint256) {
        uint256 _weight = mapMemberSynth_weight[member][synth]; // Get user's weight (scope: member -> synth)
        uint256 _reserve = reserveBASE() / erasToEarn; // Aim to deplete reserve over a number of days
        uint256 _vaultReward = (_reserve * vaultClaim) / 10000; // Get the SynthVault's share of that
        return iUTILS(_DAO().UTILS()).calcShare(_weight, totalWeight, _vaultReward); // Get member's share of that
    }

    //====================================== WITHDRAW ========================================//

    // User withdraws a percentage of their synths from the vault
    function withdraw(address synth, uint256 basisPoints) external returns (uint256 redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints); // Perform the withdrawal
        require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user
        return redeemedAmount;
    }

    // Contract withdraws a percentage of user's synths from the vault
    function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {
        require((block.timestamp > mapMember_depositTime[_member]), ""lockout""); // Must not withdraw before lockup period passed
        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Calc amount to withdraw
        mapMemberSynth_deposit[_member][_synth] -= _principle; // Remove from user's recorded vault holdings
        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); // Calc SPARTA value of amount
        mapMemberTotal_weight[_member] -= _weight; // Remove from member's total weight (scope: member)
        mapMemberSynth_weight[_member][_synth] -= _weight; // Remove from member's synth weight (scope: member -> synth)
        totalWeight -= _weight; // Remove from total weight (scope: vault)
        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);
        return (_principle + synthReward);
    }

    //================================ Helper Functions ===============================//

    function reserveBASE() public view returns (uint256) {
        return iBEP20(BASE).balanceOf(_DAO().RESERVE());
    }

    function getMemberDeposit(address synth, address member) external view returns (uint256){
        return mapMemberSynth_deposit[member][synth];
    }

    function getMemberWeight(address member) external view returns (uint256) {
        return mapMemberTotal_weight[member];
    }

    function getStakeSynthLength() external view returns (uint256) {
        return stakedSynthAssets.length;
    }

    function getMemberLastTime(address member) external view returns (uint256) {
        return mapMember_depositTime[member];
    }

    function getMemberLastSynthTime(address synth, address member) external view returns (uint256){
        return mapMemberSynth_lastTime[member][synth];
    }

    function getMemberSynthWeight(address synth, address member) external view returns (uint256) {
        return mapMemberSynth_weight[member][synth];
    }

    //=============================== SynthVault Metrics =================================//

    function _addVaultMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ // 30 days
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        } else {
            lastMonth = block.timestamp;
            mapPast30DVaultRevenue = map30DVaultRevenue;
            addRevenue(mapPast30DVaultRevenue);
            map30DVaultRevenue = 0;
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; // 2
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",2956.0,258.0,"[H-01] SynthVault withdraw forfeits rewards
The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.
Usually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.
Recommend claiming the rewards with the user's deposited balance first in withdraw.
  [H-06] SynthVault rewards can be gamed The `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`.
This spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity. However, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool. Therefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:
(1) Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of BASE into it repeatedly (sending lots of smaller trades is less costly due to the path-independence of the continuous liquidity model). This increases the BASE per token price.
(2) Call `SynthVault.depositForMember` and deposit a small amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price.
(3) Optionally drip more `BASE` into the pool and repeat the deposits
(4) Drip back `token` to the pool to rebalance it
The user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.
  [M-04] `_deposit` resetting user rewards can be used to grief them and make them loose rewards via depositForMember The function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future in `synthVault.sol` L107.
`mapMemberSynth_lastTime` is also used to calculate rewards earned. `depositForMember` allows anyone, to ""make a donation"" for the member and cause that member to lose all their accrued rewards. This can't be used for personal gain, but can be used to bring misery to others.` depositForMember (in synthVault.sol on L95 can be called by anyone.
This will set the member and can be continuously exploited to make members never earn any reward.",3.0,"pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";

contract SynthVault {
    address public BASE;
    address public DEPLOYER;

    uint256 public minimumDepositTime;  
    uint256 public totalWeight;         
    uint256 public erasToEarn;          
    uint256 public vaultClaim;          
    address [] public stakedSynthAssets; 
    uint private lastMonth;             
    uint public genesis;                

    uint256 public map30DVaultRevenue; 
    uint256 public mapPast30DVaultRevenue; 
    uint256 [] public revenueArray; 

    
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor(address _base) {
        BASE = _base;
        DEPLOYER = msg.sender;
        erasToEarn = 30;
        minimumDepositTime = 3600; 
        vaultClaim = 1000;
        genesis = block.timestamp;
        lastMonth = 0;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;
    mapping(address => uint256) private mapMemberTotal_weight;
    mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;

    mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;
    mapping(address => uint256) private mapMember_depositTime;
    mapping(address => uint256) public lastBlock;
    mapping(address => bool) private isStakedSynth;
    mapping(address => mapping(address => bool)) private isSynthMember;

    event MemberDeposits(
        address indexed synth,
        address indexed member,
        uint256 newDeposit,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberWithdraws(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberHarvests(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );

    function setParams(uint256 one, uint256 two, uint256 three) external onlyDAO {
        erasToEarn = one;
        minimumDepositTime = two;
        vaultClaim = three;
    }

    

    
    function deposit(address synth, uint256 amount) external {
        depositForMember(synth, msg.sender, amount);
    }

    
    function depositForMember(address synth, address member, uint256 amount) public {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); 
        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); 
        _deposit(synth, member, amount); 
    }

    
    function _deposit(address _synth, address _member, uint256 _amount) internal {
        if(!isStakedSynth[_synth]){
            isStakedSynth[_synth] = true; 
            stakedSynthAssets.push(_synth); 
        }
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; 
        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; 
        mapMemberSynth_deposit[_member][_synth] += _amount; 
        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); 
        mapMemberSynth_weight[_member][_synth] += _weight; 
        mapMemberTotal_weight[_member] += _weight; 
        totalWeight += _weight; 
        isSynthMember[_member][_synth] = true; 
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    

    
    function harvestAll() external returns (bool) {
        for(uint i = 0; i < stakedSynthAssets.length; i++){
            if((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){
                uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);
                if(reward > 0){
                    harvestSingle(stakedSynthAssets[i]);
                }
            }
            
        }
        return true;
    }

    
    function harvestSingle(address synth) public returns (bool) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); 
        require(iRESERVE(_DAO().RESERVE()).emissions(), ""!emissions""); 
        uint256 _weight;
        uint256 reward = calcCurrentReward(synth, msg.sender); 
        mapMemberSynth_lastTime[msg.sender][synth] = block.timestamp; 
        address _poolOUT = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(iSYNTH(synth).LayerONE()); 
        iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT); 
        (uint synthReward,) = iPOOL(_poolOUT).mintSynth(synth, address(this)); 
        _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(synth).LayerONE(), synthReward); 
        mapMemberSynth_deposit[msg.sender][synth] += synthReward; 
        mapMemberSynth_weight[msg.sender][synth] += _weight; 
        mapMemberTotal_weight[msg.sender] += _weight; 
        totalWeight += _weight; 
        _addVaultMetrics(reward); 
        iSYNTH(synth).realise(_poolOUT); 
        emit MemberHarvests(synth, msg.sender, reward, _weight, totalWeight);
        return true;
    }

    
    function calcCurrentReward(address synth, address member) public view returns (uint256 reward){
        require((block.timestamp > mapMemberSynth_lastTime[member][synth]), ""!unlocked""); 
        uint256 _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]; 
        uint256 _share = calcReward(synth, member); 
        reward = (_share * _secondsSinceClaim) / iBASE(BASE).secondsPerEra(); 
        return reward;
    }

    
    function calcReward(address synth, address member) public view returns (uint256) {
        uint256 _weight = mapMemberSynth_weight[member][synth]; 
        uint256 _reserve = reserveBASE() / erasToEarn; 
        uint256 _vaultReward = (_reserve * vaultClaim) / 10000; 
        return iUTILS(_DAO().UTILS()).calcShare(_weight, totalWeight, _vaultReward); 
    }

    

    
    function withdraw(address synth, uint256 basisPoints) external returns (uint256 redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints); 
        require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); 
        return redeemedAmount;
    }

    
    function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {
        require((block.timestamp > mapMember_depositTime[_member]), ""lockout""); 
        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); 
        mapMemberSynth_deposit[_member][_synth] -= _principle; 
        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); 
        mapMemberTotal_weight[_member] -= _weight; 
        mapMemberSynth_weight[_member][_synth] -= _weight; 
        totalWeight -= _weight; 
        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);
        return (_principle + synthReward);
    }

    

    function reserveBASE() public view returns (uint256) {
        return iBEP20(BASE).balanceOf(_DAO().RESERVE());
    }

    function getMemberDeposit(address synth, address member) external view returns (uint256){
        return mapMemberSynth_deposit[member][synth];
    }

    function getMemberWeight(address member) external view returns (uint256) {
        return mapMemberTotal_weight[member];
    }

    function getStakeSynthLength() external view returns (uint256) {
        return stakedSynthAssets.length;
    }

    function getMemberLastTime(address member) external view returns (uint256) {
        return mapMember_depositTime[member];
    }

    function getMemberLastSynthTime(address synth, address member) external view returns (uint256){
        return mapMemberSynth_lastTime[member][synth];
    }

    function getMemberSynthWeight(address synth, address member) external view returns (uint256) {
        return mapMemberSynth_weight[member][synth];
    }

    

    function _addVaultMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ 
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        } else {
            lastMonth = block.timestamp;
            mapPast30DVaultRevenue = map30DVaultRevenue;
            addRevenue(mapPast30DVaultRevenue);
            map30DVaultRevenue = 0;
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; 
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",2254.0,2,1,"The vulnerabilities in the given solidity code are:

1.  **Reentrancy**: The contract is vulnerable to reentrancy attacks. In the `deposit` function, the contract calls the `transferFrom` function of the BEP20 token, which can lead to a reentrancy attack if the token's `transferFrom` function calls another contract that modifies the state of the current contract.

2.  **Unprotected Functions**: The contract has several functions that are not protected with the `onlyDAO` modifier, which means that anyone can call these functions. This could lead to unintended behavior or security vulnerabilities if these functions are modified in the future.

3.  **Uninitialized Variables**: The contract has several variables that are not initialized before they are used. For example, the `stakedSynthAssets` array is not initialized before it is used in the `deposit` function.

4.  **Missing Error Handling**: The contract does not have proper error handling mechanisms in place. For example, the `deposit` function does not check if the `transferFrom` function call was successful before proceeding with the deposit.

5.  **Unprotected Views**: The contract has several view functions that are not protected with the `onlyDAO` modifier, which means that anyone can call these functions. This could lead to unintended behavior or security vulnerabilities if these functions are modified in the future.

6.  **Use of `transfer` Function**: The contract uses the `transfer` function to transfer BEP20 tokens, which can be vulnerable to reentrancy attacks if the token's `transfer` function calls another contract that modifies the state of the current contract.

7.  **Use of `transferFrom` Function**: The contract uses the `transferFrom` function to transfer BEP20 tokens, which can be vulnerable to reentrancy attacks if the token's `transferFrom` function calls another contract that modifies the state of the current contract.

8.  **Missing Input Validation**: The contract does not validate the inputs to its functions properly. For example, the `deposit` function does not check if the `amount` parameter is valid before proceeding with the deposit.

9.  **Use of `require` Statements**: The contract uses `require` statements to check if certain conditions are met before proceeding with a function. However, these statements are not always used correctly. For example, the `require` statement in the `deposit` function checks if the `transferFrom` function call was successful, but it does not check if the `amount` parameter is valid.

10. **Missing Event Emissions**: The contract does not emit events for certain functions, which can make it difficult to track the state of the contract. For example, the `deposit` function does not emit an event when a deposit is made.

11. **Use of `internal` Functions**: The contract uses `internal` functions, which are not visible to external contracts. However, these functions can still be called by other contracts if they are not properly protected.

12. **Missing Function Modifiers**: The contract does not use function modifiers to restrict access to certain functions. For example, the `deposit` function does not have a modifier that restricts access to the `DAO` contract.

13. **Use of `view` Functions**: The contract uses `view` functions, which are read-only functions that do not modify the state of the contract. However, these functions can still be vulnerable to certain types of attacks if they are not properly protected.

14. **Missing Function Input Validation**: The contract does not validate the inputs to its functions properly. For example, the `deposit` function does not check if the `amount` parameter is valid before proceeding with the deposit.

15. **Use of `transfer` Function with Unchecked Parameters**: The contract uses the `transfer` function with unchecked parameters, which can lead to security vulnerabilities if the parameters are not properly validated.

16. **Missing Function Output Validation**: The contract does not validate the outputs of its functions properly. For example, the `deposit` function does not check if the `transfer` function call was successful before proceeding with the deposit.

17. **Use of `transferFrom` Function with Unchecked Parameters**: The contract uses the `transferFrom` function with unchecked parameters, which can lead to security vulnerabilities if the parameters are not properly validated.

18. **Missing Function Error Handling**: The contract does not have proper error handling mechanisms in place. For example, the `deposit` function does not check if the `transferFrom` function call was successful before proceeding with the deposit.

19. **Use of `transfer` Function with Unchecked Parameters**: The contract uses the `transfer` function with unchecked parameters, which can lead to security vulnerabilities if the parameters are not properly validated.

20. **Missing Function Input Validation**: The contract does not validate the inputs to its functions properly. For example, the `deposit` function","### **Comparison of Issue Report and Response List**

---

#### **[H-01] SynthVault withdraw forfeits rewards**

**Report Description**:
The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight, causing them to forfeit their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also unused, likely intended to capture claimed rewards. Typically, withdrawal functions claim rewards first, but this one does not, resulting in users losing all accumulated rewards. The recommendation is to claim rewards with the user's deposited balance first in `withdraw`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of forfeiting rewards during withdrawal. This is a critical oversight, as it directly impacts user rewards and contract functionality. The response list focuses on unrelated vulnerabilities like reentrancy and unprotected functions, which do not align with this issue.

---

#### **[H-06] SynthVault rewards can be gamed**

**Report Description**:
The `SynthVault._deposit` function adds `weight` for the user based on the spot value of the deposit synth amount in `BASE`. This spot price can be manipulated, especially in low-liquidity pools, allowing attackers to inflate their `weight` and claim a disproportionate share of rewards. The attack involves manipulating the pool spot price, depositing a small amount of synth token, and rebalancing the pool. The cost of the attack depends on the pool's liquidity, and the profit depends on the reward reserve, making it potentially profitable under certain conditions.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of reward manipulation through spot price exploitation. This is a significant vulnerability, as it allows attackers to game the system and claim excessive rewards. The response list focuses on unrelated issues like reentrancy and unprotected functions, which do not align with this issue.

---

#### **[M-04] `_deposit` resetting user rewards can be used to grief them and make them lose rewards via `depositForMember`**

**Report Description**:
The `_deposit` function sets `mapMemberSynth_lastTime` to a future date, which is also used to calculate rewards. The `depositForMember` function allows anyone to ""make a donation"" for a member, resetting their `mapMemberSynth_lastTime` and causing them to lose all accrued rewards. This can be continuously exploited to prevent members from earning any rewards, effectively griefing them.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of griefing through `depositForMember`. This is a critical vulnerability, as it allows malicious actors to disrupt the reward system and harm legitimate users. The response list focuses on unrelated issues like reentrancy and unprotected functions, which do not align with this issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] SynthVault withdraw forfeits rewards**
- **[H-06] SynthVault rewards can be gamed**
- **[M-04] `_deposit` resetting user rewards can be used to grief them and make them lose rewards via `depositForMember`**

---

### **Conclusion**
The `response_list` does not adequately address the issues raised in the `issue` report. It focuses on generic vulnerabilities like reentrancy and unprotected functions, which are unrelated to the specific problems identified in the report. The response list fails to cover critical issues such as forfeiting rewards, reward manipulation, and griefing, highlighting significant gaps in its coverage and accuracy.",1,0,2,15,"```
None.
```",0.0
Pool.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iSYNTH.sol""; 
import ""./interfaces/iSYNTHFACTORY.sol""; 
import ""./interfaces/iBEP677.sol""; 

contract Pool is iBEP20 {  
    address public BASE;
    address public TOKEN;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    uint256 public baseAmount; // SPARTA amount that should be in the pool
    uint256 public tokenAmount; // TOKEN amount that should be in the pool

    uint private lastMonth; // Timestamp of the start of current metric period (For UI)
    uint public genesis; // Timestamp from when the pool was first deployed (For UI)

    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)
    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)
    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)

    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);
    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);
    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);
    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);
    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    constructor (address _base, address _token) {
        BASE = _base;
        TOKEN = _token;
        string memory poolName = ""-SpartanProtocolPool"";
        string memory poolSymbol = ""-SPP"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));
        decimals = 18;
        genesis = block.timestamp;
        DEPLOYER = msg.sender;
        lastMonth = 0;
    }

    //========================================iBEP20=========================================//

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }

    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        // Max approval (saves an SSTORE)
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    //iBEP677 approveAndCall
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval
      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient
      return true;
    }

    //iBEP677 transferAndCall
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _transfer(msg.sender, recipient, amount);
      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient 
      return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //====================================POOL FUNCTIONS =================================//

    // User adds liquidity to the pool
    function add() external returns(uint liquidityUnits){
        liquidityUnits = addForMember(msg.sender);
        return liquidityUnits;
    }

    // Contract adds liquidity for user 
    function addForMember(address member) public returns(uint liquidityUnits){
        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount
        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount
        if(baseAmount == 0 || tokenAmount == 0){
        require(_actualInputBase != 0 && _actualInputToken != 0, ""!Balanced"");
        }
        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint
        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts
        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user
        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);
        return liquidityUnits;
    }
    
    // User removes liquidity from the pool 
    function remove() external returns (uint outputBase, uint outputToken) {
        return removeForMember(msg.sender);
    } 

    // Contract removes liquidity for the user
    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {
        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount
        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units
        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units
        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts
        _burn(address(this), _actualInputUnits); // Burn the LP tokens
        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user
        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user
        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);
        return (outputBase, outputToken);
    }

    // Caller swaps tokens
    function swap(address token) external returns (uint outputAmount, uint fee){
        (outputAmount, fee) = swapTo(token, msg.sender);
        return (outputAmount, fee);
    }

    // Contract swaps tokens for the member
    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {
        require((token == BASE || token == TOKEN), ""!BASE||TOKEN""); // Must be SPARTA or the pool's relevant TOKEN
        address _fromToken; uint _amount;
        if(token == BASE){
            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN
            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount
            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap
        } else {
            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA
            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount
            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap
        }
        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);
        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user
        return (outputAmount, fee);
    }

    // Swap SPARTA for Synths
    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, ""!synth""); // Must be a valid Synth
        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount
        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN
        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted
        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount
        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN
        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA
        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold
        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user
        _addPoolMetrics(fee); // Add slip fee to the revenue metrics
        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);
      return (output, fee);
    }
    
    // Swap Synths for SPARTA
    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, ""!synth""); // Must be a valid Synth
        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount
        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA
        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA
        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract
        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units
        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount
        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user
        _addPoolMetrics(fee); // Add slip fee to the revenue metrics
        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);
      return (outputBase, fee);
    }

    //=======================================INTERNAL MATHS======================================//

    // Check the SPARTA amount received by this Pool
    function _getAddedBaseAmount() internal view returns(uint256 _actual){
        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); 
        if(_baseBalance > baseAmount){
            _actual = _baseBalance-(baseAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }
  
    // Check the TOKEN amount received by this Pool
    function _getAddedTokenAmount() internal view returns(uint256 _actual){
        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); 
        if(_tokenBalance > tokenAmount){
            _actual = _tokenBalance-(tokenAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }

    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts
    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = baseAmount;
        uint256 _Y = tokenAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output
        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee
        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA
        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts
        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics
        return (_y, _fee);
    }

    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts
    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = tokenAmount;
        uint256 _Y = baseAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output
        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee
        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts
        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics
        return (_y, _fee);
    }

    //=======================================BALANCES=========================================//

    // Sync internal balances to actual
    function sync() external {
        baseAmount = iBEP20(BASE).balanceOf(address(this));
        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));
    }

    // Increment internal balances
    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount += _baseAmount;
        tokenAmount += _tokenAmount;
    }

    // Set internal balances
    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {
        baseAmount = _baseAmount;
        tokenAmount = _tokenAmount; 
    }

    // Decrement internal balances
    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount -= _baseAmount;
        tokenAmount -= _tokenAmount; 
    }

    //===========================================POOL FEE ROI=================================//

    function _addPoolMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ // 30Days
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        } else {
            lastMonth = block.timestamp;
            mapPast30DPoolRevenue = map30DPoolRevenue;
            addRevenue(mapPast30DPoolRevenue);
            map30DPoolRevenue = 0;
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; // 2
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",4053.0,366.0,"[H-02] Pool.sol & Synth.sol: Failing Max Value Allowance
In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.
This also makes the comment // No need to re-approve if already max misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.
This affects the `approveAndCall` implementation since it uses type(uint256).max as the allowance amount, but the resulting allowance set is zero.
  [H-07] Missing slippage checks
There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.
Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.
  [H-09] arbitrary synth mint/burn from pool function `mintSynth`, L229-L242
`Pool` can mint arbitrary `Synth` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs. Pool's mintSynth logic, Synth's mintSynth logic, and Synth's authorization logic.
The price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool
  [H-11] Misuse of AMM model on minting `Synth` (resubmit to add more detail)
`Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the Pool. However, since `token_amount` in the pool would not decrease when users mint Synth, it's always cheaper to mint synth than swap the tokens.
The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.
In Pool's mint synth, The synth amount is calculated at L:232 `uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount);`
which is the same as swapping base to token at L:287   [M-06] Pool: `approveAndCall` sets unnecessary approval
The `Pool.approveAndCall` function approves the recipient contract with the max value instead of only the required `amount`.
For safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, like this is the case for `approveAndCall`.",5.0,"pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iSYNTH.sol""; 
import ""./interfaces/iSYNTHFACTORY.sol""; 
import ""./interfaces/iBEP677.sol""; 

contract Pool is iBEP20 {  
    address public BASE;
    address public TOKEN;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    uint256 public baseAmount; 
    uint256 public tokenAmount; 

    uint private lastMonth; 
    uint public genesis; 

    uint256 public map30DPoolRevenue; 
    uint256 public mapPast30DPoolRevenue; 
    uint256 [] public revenueArray; 

    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);
    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);
    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);
    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);
    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    constructor (address _base, address _token) {
        BASE = _base;
        TOKEN = _token;
        string memory poolName = ""-SpartanProtocolPool"";
        string memory poolSymbol = ""-SPP"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));
        decimals = 18;
        genesis = block.timestamp;
        DEPLOYER = msg.sender;
        lastMonth = 0;
    }

    

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { 
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }

    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _approve(msg.sender, recipient, type(uint256).max); 
      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); 
      return true;
    }

    
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _transfer(msg.sender, recipient, amount);
      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); 
      return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    

    
    function add() external returns(uint liquidityUnits){
        liquidityUnits = addForMember(msg.sender);
        return liquidityUnits;
    }

    
    function addForMember(address member) public returns(uint liquidityUnits){
        uint256 _actualInputBase = _getAddedBaseAmount(); 
        uint256 _actualInputToken = _getAddedTokenAmount(); 
        if(baseAmount == 0 || tokenAmount == 0){
        require(_actualInputBase != 0 && _actualInputToken != 0, ""!Balanced"");
        }
        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); 
        _incrementPoolBalances(_actualInputBase, _actualInputToken); 
        _mint(member, liquidityUnits); 
        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);
        return liquidityUnits;
    }
    
    
    function remove() external returns (uint outputBase, uint outputToken) {
        return removeForMember(msg.sender);
    } 

    
    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {
        uint256 _actualInputUnits = balanceOf(address(this)); 
        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); 
        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); 
        _decrementPoolBalances(outputBase, outputToken); 
        _burn(address(this), _actualInputUnits); 
        iBEP20(BASE).transfer(member, outputBase); 
        iBEP20(TOKEN).transfer(member, outputToken); 
        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);
        return (outputBase, outputToken);
    }

    
    function swap(address token) external returns (uint outputAmount, uint fee){
        (outputAmount, fee) = swapTo(token, msg.sender);
        return (outputAmount, fee);
    }

    
    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {
        require((token == BASE || token == TOKEN), ""!BASE||TOKEN""); 
        address _fromToken; uint _amount;
        if(token == BASE){
            _fromToken = TOKEN; 
            _amount = _getAddedTokenAmount(); 
            (outputAmount, fee) = _swapTokenToBase(_amount); 
        } else {
            _fromToken = BASE; 
            _amount = _getAddedBaseAmount(); 
            (outputAmount, fee) = _swapBaseToToken(_amount); 
        }
        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);
        iBEP20(token).transfer(member, outputAmount); 
        return (outputAmount, fee);
    }

    
    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, ""!synth""); 
        uint256 _actualInputBase = _getAddedBaseAmount(); 
        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); 
        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); 
        _incrementPoolBalances(_actualInputBase, 0); 
        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); 
        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); 
        _mint(synthOut, _liquidityUnits); 
        iSYNTH(synthOut).mintSynth(member, output); 
        _addPoolMetrics(fee); 
        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);
      return (output, fee);
    }
    
    
    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, ""!synth""); 
        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); 
        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); 
        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); 
        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); 
        iSYNTH(synthIN).burnSynth(); 
        _decrementPoolBalances(outputBase, 0); 
        iBEP20(BASE).transfer(member, outputBase); 
        _addPoolMetrics(fee); 
        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);
      return (outputBase, fee);
    }

    

    
    function _getAddedBaseAmount() internal view returns(uint256 _actual){
        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); 
        if(_baseBalance > baseAmount){
            _actual = _baseBalance-(baseAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }
  
    
    function _getAddedTokenAmount() internal view returns(uint256 _actual){
        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); 
        if(_tokenBalance > tokenAmount){
            _actual = _tokenBalance-(tokenAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }

    
    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = baseAmount;
        uint256 _Y = tokenAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); 
        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); 
        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); 
        _setPoolAmounts(_X + _x, _Y - _y); 
        _addPoolMetrics(_fee); 
        return (_y, _fee);
    }

    
    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = tokenAmount;
        uint256 _Y = baseAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); 
        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); 
        _setPoolAmounts(_Y - _y, _X + _x); 
        _addPoolMetrics(_fee); 
        return (_y, _fee);
    }

    

    
    function sync() external {
        baseAmount = iBEP20(BASE).balanceOf(address(this));
        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));
    }

    
    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount += _baseAmount;
        tokenAmount += _tokenAmount;
    }

    
    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {
        baseAmount = _baseAmount;
        tokenAmount = _tokenAmount; 
    }

    
    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount -= _baseAmount;
        tokenAmount -= _tokenAmount; 
    }

    

    function _addPoolMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ 
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        } else {
            lastMonth = block.timestamp;
            mapPast30DPoolRevenue = map30DPoolRevenue;
            addRevenue(mapPast30DPoolRevenue);
            map30DPoolRevenue = 0;
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; 
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",3337.0,4,1,"The following are the vulnerabilities found in the given solidity code:

1. **Reentrancy vulnerability**: The contract is vulnerable to reentrancy attacks due to the lack of a reentrancy guard. An attacker can repeatedly call the `transfer` function, causing the contract to repeatedly transfer funds to the attacker's account, resulting in a loss of funds for the contract.

2. **Front-running vulnerability**: The contract is vulnerable to front-running attacks due to the lack of a time-lock mechanism. An attacker can place a bet on the outcome of a transaction and then execute the transaction before the original sender, resulting in a loss of funds for the contract.

3. **Denial-of-Service (DoS) vulnerability**: The contract is vulnerable to DoS attacks due to the lack of a rate limiting mechanism. An attacker can repeatedly call the `transfer` function, causing the contract to repeatedly transfer funds to the attacker's account, resulting in a loss of funds for the contract.

4. **Uncontrolled gas costs**: The contract has uncontrolled gas costs due to the use of the `iBEP20` interface, which does not provide a way to estimate the gas costs of a transaction. This can result in a denial-of-service attack if the contract is executed repeatedly.

5. **Missing input validation**: The contract does not validate the input parameters of the `transfer` function, which can result in a denial-of-service attack if the contract is executed repeatedly.

6. **Missing error handling**: The contract does not handle errors properly, which can result in a denial-of-service attack if the contract is executed repeatedly.

7. **Unsecured sensitive data**: The contract stores sensitive data, such as the `baseAmount` and `tokenAmount`, in public variables. This can result in a security breach if the contract is executed repeatedly.

8. **Uncontrolled external dependencies**: The contract uses external dependencies, such as the `iBEP20` interface, which can result in a security breach if the contract is executed repeatedly.

9. **Uncontrolled external interactions**: The contract interacts with external contracts, such as the `iDAO` contract, which can result in a security breach if the contract is executed repeatedly.

10. **Uncontrolled external calls**: The contract makes external calls to other contracts, such as the `iSYNTH` contract, which can result in a security breach if the contract is executed repeatedly.

To fix these vulnerabilities, the following changes should be made:

1. Add a reentrancy guard to the `transfer` function to prevent reentrancy attacks.

2. Add a time-lock mechanism to the `transfer` function to prevent front-running attacks.

3. Add a rate limiting mechanism to the `transfer` function to prevent DoS attacks.

4. Use the `iBEP20` interface to estimate the gas costs of a transaction.

5. Validate the input parameters of the `transfer` function to prevent denial-of-service attacks.

6. Handle errors properly to prevent denial-of-service attacks.

7. Secure sensitive data by using private variables.

8. Use secure external dependencies, such as the `iBEP20` interface.

9. Interact with external contracts securely, such as the `iDAO` contract.

10. Make external calls to other contracts securely, such as the `iSYNTH` contract.```

Please note that the above response is a general analysis of the given solidity code and may not cover all possible vulnerabilities. It's always recommended to consult with a security expert or a professional solidity developer to identify and fix potential vulnerabilities in a smart contract.```

The following are the vulnerabilities found in the given solidity code:

1. **Reentrancy vulnerability**: The contract is vulnerable to reentrancy attacks due to the lack of a reentrancy guard. An attacker can repeatedly call the `transfer` function, causing the contract to repeatedly transfer funds to the attacker's account, resulting in a loss of funds for the contract.

2. **Front-running vulnerability**: The contract is vulnerable to front-running attacks due to the lack of a time-lock mechanism. An attacker can place a bet on the outcome of a transaction and then execute the transaction before the original sender, resulting in a loss of funds for the contract.

3. **Denial-of-Service (DoS) vulnerability**: The contract is vulnerable to DoS attacks due to the lack of a rate limiting mechanism. An attacker can repeatedly call the `transfer` function, causing the contract to repeatedly transfer funds to the attacker's account, resulting in a loss of funds for the contract.

4. **Uncontrolled gas costs**: The contract has uncontrolled gas costs due to the use of the `iBEP20` interface, which does not provide a way to estimate the gas costs of a transaction. This can result in a denial-of-service attack if the contract is executed repeatedly.

5. **Missing input validation**: The contract does not validate","### **Comparison of Issue Report and Response List**

---

#### **[H-02] Pool.sol & Synth.sol: Failing Max Value Allowance**

**Report Description**:
The `_approve` function does not handle the case where the allowance passed in is `type(uint256).max`. This results in the allowance remaining at its previous value, which is problematic for integrations (e.g., DEXes) that hardcode this value to set maximum allowance. The comment `// No need to re-approve if already max` is misleading because the max attainable allowance is `type(uint256).max - 1`. This issue also affects the `approveAndCall` implementation, which uses `type(uint256).max` as the allowance amount but results in zero allowance.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The problem is specific to the handling of `type(uint256).max` in the `_approve` function and its implications for contract integrations. This is a critical oversight that could lead to unintended behavior in token approvals.

---

#### **[H-07] Missing Slippage Checks**

**Report Description**:
The contract lacks minimum amount out checks or mechanisms to mitigate frontrunning/slippage. This allows attackers with sufficient capital to force arbitrarily large slippage by sandwiching transactions, potentially resulting in losses close to 100%. The recommendation is to add a minimum amount out parameter and revert the transaction if the minimum amount is not obtained.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of missing slippage checks or frontrunning mitigation. This is a significant vulnerability in decentralized finance (DeFi) applications, and its omission in the response list is a critical gap.

---

#### **[H-09] Arbitrary Synth Mint/Burn from Pool**

**Report Description**:
The `mintSynth` function allows the `Pool` to mint arbitrary `Synth` tokens as long as they are valid. This can be exploited by attackers to mint expensive synthetics from cheaper AMM pools, burn them at expensive pools, and profit from arbitrage. The arbitrage profit can be amplified using flash loans, potentially breaking all pegs. The issue arises from the `Pool`'s minting logic, `Synth`'s minting logic, and `Synth`'s authorization logic.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of arbitrary minting and burning of `Synth` tokens or the associated arbitrage risks. This is a critical vulnerability that could destabilize the protocol's token pegs.

---

#### **[H-11] Misuse of AMM Model on Minting Synth**

**Report Description**:
The `Pool` calculates the amount of `Synth` to be minted based on `token_amount` and `sparta_amount` in the pool. However, since `token_amount` does not decrease when users mint `Synth`, it is always cheaper to mint `Synth` than to swap tokens. This makes it difficult to maintain the peg of synthetics and creates opportunities for flash loan attackers to exploit arbitrage.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the misuse of the AMM model in minting `Synth` tokens or the associated arbitrage risks. This is a critical vulnerability that could destabilize the protocol's token pegs.

---

#### **[M-06] Pool: `approveAndCall` Sets Unnecessary Approval**

**Report Description**:
The `Pool.approveAndCall` function approves the recipient contract with the max value instead of only the required `amount`. This is unnecessary and unsafe, especially when the amount that the contract may use is already known in this call.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unnecessary max approvals in the `approveAndCall` function. This is a security best practice issue that could lead to unintended token approvals.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-02] Pool.sol & Synth.sol: Failing Max Value Allowance**
- **[H-07] Missing Slippage Checks**
- **[H-09] Arbitrary Synth Mint/Burn from Pool**
- **[H-11] Misuse of AMM Model on Minting Synth**
- **[M-06] Pool: `approveAndCall` Sets Unnecessary Approval**

---

### **Conclusion**
The `response_list` does not adequately address the issues raised in the `issue` report. The response list focuses on general vulnerabilities (e.g., reentrancy, front-running, DoS) but fails to cover the specific issues related to token approvals, slippage checks, and arbitrage risks in the protocol. This represents a significant gap in the analysis and highlights the need for a more detailed and targeted review of the smart contract code.",3,0,2,18,"```
None.
```",0.0
DAO.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)
    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised
    uint256 public proposalCount;   // Count of proposals
    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3
    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives
    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially
    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially
    uint256 public currentProposal; // The most recent proposal; should be === proposalCount
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets
    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    //==================================== PROTOCOL CONTRACTs SETTER =================================//

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    // Can purge deployer once DAO is stable and final
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    // Can change vesting period for bonders
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    //============================== USER - DEPOSIT/WITHDRAW ================================//

    // User deposits LP tokens in the DAOVault
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    // Contract deposits LP tokens for member
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); // Pool must be Curated
        require(amount > 0, ""!amount""); // Deposit amount must be valid
        if (isMember[member] != true) {
            arrayMembers.push(member); // If not a member; add user to member array
            isMember[member] = true; // If not a member; register the user as member
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); // Send user's deposit to the DAOVault
        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight
        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time
        emit MemberDeposits(member, pool, amount);
    }
    
    // User withdraws all of their selected asset from the DAOVault
    function withdraw(address pool) external {
        removeVote(); // Users weight is removed from the current open DAO proposal
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); // User receives their withdrawal
    }

    //============================== REWARDS ================================//
    
    // User claims their DAOVault incentives
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); // Reserve must have emissions turned on
        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE
        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)
        if(reward > daoReward){
            reward = daoReward; // User cannot claim more than the daoReward limit
        }
        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user
    }

    // Calculate the user's current incentive-claim per era
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim
        uint share = calcReward(member); // Get share of rewards for user
        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed
        return reward;
    }

    // Calculate the user's current total claimable incentive
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days
        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that
        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)
    }

    //================================ BOND Feature ==================================//

    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    // List an asset to be enabled for Bonding
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; // Register as a currently enabled asset
            listedBondAssets.push(asset); // Add to historical record of past Bond assets
        }
        emit ListedAsset(msg.sender, asset);
    }

    // Delist an asset from the Bond program
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; // Unregister as a currently enabled asset
        emit DelistedAsset(msg.sender, asset);
    }

    // User deposits assets to be Bonded
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); // Amount must be valid
        require(isListed[asset], '!listed'); // Asset must be listed for Bond
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array
            isMember[msg.sender] = true; // Register user as a member
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    // Add Bonded assets as liquidity and calculate LP units
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens
        } 
    }

    // User claims all of their unlocked Bonded LPs
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; // Get array of bond assets
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked
            }
        }
        return true;
    }

    // User claims unlocked Bond units of a selected asset
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked
        }
        return true;
    }
    
    // Calculate user's unlocked Bond units of a selected asset
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs
        return claimAmount;
    }

    //============================== CREATE PROPOSALS ================================//

    // New ID, but specify type, one type for each function call
    // Votes counted to IDs
    // IDs are finalised
    // IDs are executed, but type specifies unique logic

    // New DAO proposal: Simple action
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: uint parameter
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_param[currentProposal] = param; // Set the proposed parameter
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Address parameter
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Grant SPARTA to wallet
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient
        mapPID_param[currentProposal] = amount; // Set the proposed grant amount
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // If no existing open DAO proposal; register a new one
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal
        proposalCount += 1; // Increase proposal count
        currentProposal = proposalCount; // Set current proposal to the new count
        mapPID_open[currentProposal] = true; // Set new proposal as open status
        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now
    }
    
    // Pay the fee for a new DAO proposal
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee
        return true;
    } 

    //============================== VOTE && FINALISE ================================//

    // Vote for a proposal
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); // Proposal must be open status
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeight = countVotes(); // Vote for proposal and recount
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase
                }
            } else {
                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    // Remove vote from a proposal
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    // Push the proposal into 'finalising' status
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        mapPID_finalising[currentProposal] = true; // Set finalising status to true
        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    // Attempt to cancel the open proposal
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); // Proposal must not be new
        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal
        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)
        emit CancelProposal(msg.sender, currentProposal);
    }

    // A finalising-stage proposal can be finalised after the cool off period
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); // Must be past cooloff period
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); // Must be in finalising stage
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    // Change the DAO to a new contract address
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        DAO = _proposedAddress; // Change the DAO to point to the new DAO address
        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address
        daoHasMoved = true; // Set status of this old DAO
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the ROUTER to a new contract address
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the UTILS to a new contract address
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the RESERVE to a new contract address
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Flip the BASE emissions on/off
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change cool off period (Period of time until a finalising proposal can be finalised)
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        coolOffPeriod = _proposedParam; // Change coolOffPeriod
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change erasToEarn (Used to regulate the incentives flow)
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        erasToEarn = _proposedParam; // Change erasToEarn
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Grant SPARTA to the proposed recipient
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient
        require(_proposedAmount != 0, ""!param""); // Proposed grant amount must be valid
        require(_proposedAddress != address(0), ""!address""); // Proposed recipient must be valid
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Mint a 2.5M SPARTA allocation for the Bond program
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold
        completeProposal(_proposalID); // Finalise the proposal
    }

    // List an asset to be enabled for Bonding
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; // Register asset as listed for Bond
            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets
        }
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Delist an asset from being allowed to Bond
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Add a pool as 'Curated' to enable synths, weight and incentives
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Remove a pool from Curated status
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal
        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }
    
    // After completing the proposal's action; close it
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0
        mapPID_finalised[_proposalID] = true; // Finalise the proposal
        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage
        mapPID_open[_proposalID] = false; // Close the proposal
    }

    //============================== CONSENSUS ================================//
    
    // Add user's total weight to proposal and recount
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights
        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)
        return voteWeight;
    }

    // Check if a proposal has Majority consensus
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Quorum consensus
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 2; // Quorum > 50%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Minority consensus
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 6; // Minority > 16.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    //======================================PROTOCOL CONTRACTs GETTER=================================//
    
    // Get the ROUTER address that the DAO currently points to
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    // Get the UTILS address that the DAO currently points to
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    // Get the BONDVAULT address that the DAO currently points to
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    // Get the DAOVAULT address that the DAO currently points to
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    // Get the POOLFACTORY address that the DAO currently points to
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    // Get the SYNTHFACTORY address that the DAO currently points to
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    // Get the RESERVE address that the DAO currently points to
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    // Get the SYNTHVAULT address that the DAO currently points to
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    //============================== HELPERS ================================//
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }
    }
}",8040.0,725.0,"[H-03] Result of transfer / transferFrom not checked
A call to `transferFrom` or `transfer` is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of ""false"" is returned. It's important to check this. If you don't, you could mint tokens without have received sufficient tokens to do so and could loose funds. Its also a best practice to check this.   [M-01] Dao.sol: Insufficient validation for proposal creation
In general, creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions.
- The `typeStr` is not validated at all. For example, one can call `newActionProposal()` with `typeStr = ROUTER` or `typeStr = BAD_STRING`, both of which will pass. The first will cause `finaliseProposal()` to fail because the proposed address is null, preventing `completeProposal()` from executing. The second does nothing because it does not equate to any of the check typeStr, and so completeProposal() isn't executed at all.
- Not checking the proposed values are null. The checks only happen in `finaliseProposal()` when the relevant sub-functions are called, like the `move*()` functions.
  [M-02] Missleading onlyDAO modifiers Several contracts implement an `onlyDAO` modifier which, as the name suggests, should only authorize the function to be executed by the DAO. However, some implementations are wrong and either allow the DAO or the deployer to execute, or even only the deployer: The deployer may execute the function as well which is a centralization risk. The deployer can only sometimes be purged, as in synthFactory, in which case nobody can execute these functions anymore.   [M-03] Improper access control of claimAllForMember allows anyone to reduce the weight of a member
The `claimAllForMember` function of `Dao` is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member's LP tokens could decrease the member's weight in the `BondVault`, thus affecting the member's votes and rewards in the `Dao` contract.   [M-10] `grantFunds` will revert after a DAO upgrade.
When the DAO is upgraded via `moveDao`, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract. This could be done with the function setIncentiveAddresses(..)
Now the next time `grantFunds` of DAO.sol is called, its tries to call `_RESERVE.grantFunds(...)`
The grantFunds of Reserve.sol has the modifier onlyGrantor(), which checks the `msg.sender` == DAO. However in the mean time, the DAO has been updated and Reserve.sol doesn't know about it and thus the modifier will not allow access to the function. Thus grantFunds will revert.",5.0,"pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   
    uint256 public coolOffPeriod;   
    uint256 public proposalCount;   
    uint256 public majorityFactor;  
    uint256 public erasToEarn;      
    uint256 public daoClaim;        
    uint256 public daoFee;          
    uint256 public currentProposal; 
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; 
    uint256 public bondingPeriodSeconds = 15552000; 
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; 
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    

    
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); 
        require(amount > 0, ""!amount""); 
        if (isMember[member] != true) {
            arrayMembers.push(member); 
            isMember[member] = true; 
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); 
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); 
        _DAOVAULT.depositLP(pool, amount, member); 
        mapMember_lastTime[member] = block.timestamp; 
        emit MemberDeposits(member, pool, amount);
    }
    
    
    function withdraw(address pool) external {
        removeVote(); 
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); 
    }

    
    
    
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); 
        uint reward = calcCurrentReward(msg.sender); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); 
        uint daoReward = (reserve * daoClaim) / 10000; 
        if(reward > daoReward){
            reward = daoReward; 
        }
        _RESERVE.grantFunds(reward, msg.sender); 
    }

    
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; 
        uint share = calcReward(member); 
        uint reward = (share * secondsSinceClaim) / secondsPerEra; 
        return reward;
    }

    
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; 
        uint daoReward = (reserve * daoClaim) / 10000; 
        return _UTILS.calcShare(weight, _totalWeight, daoReward); 
    }

    

    
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; 
            listedBondAssets.push(asset); 
        }
        emit ListedAsset(msg.sender, asset);
    }

    
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; 
        emit DelistedAsset(msg.sender, asset);
    }

    
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); 
        require(isListed[asset], '!listed'); 
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); 
            isMember[msg.sender] = true; 
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); 
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); 
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); 
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); 
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); 
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); 
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } 
    }

    
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; 
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); 
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); 
            }
        }
        return true;
    }

    
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); 
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); 
        }
        return true;
    }
    
    
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); 
        return claimAmount;
    }

    

    
    
    
    

    
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_param[currentProposal] = param; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_address[currentProposal] = proposedAddress; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); 
        payFee(); 
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; 
        mapPID_address[currentProposal] = recipient; 
        mapPID_param[currentProposal] = amount; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); 
        proposalCount += 1; 
        currentProposal = proposalCount; 
        mapPID_open[currentProposal] = true; 
        mapPID_startTime[currentProposal] = block.timestamp; 
    }
    
    
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); 
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); 
        return true;
    } 

    

    
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); 
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeight = countVotes(); 
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); 
                }
            } else {
                _finalise(); 
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; 
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; 
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; 
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        mapPID_finalising[currentProposal] = true; 
        mapPID_coolOffTime[currentProposal] = block.timestamp; 
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); 
        mapPID_votes[currentProposal] = 0; 
        mapPID_open[currentProposal] = false; 
        emit CancelProposal(msg.sender, currentProposal);
    }

    
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); 
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); 
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; 
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); 
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        DAO = _proposedAddress; 
        iBASE(BASE).changeDAO(_proposedAddress); 
        daoHasMoved = true; 
        completeProposal(_proposalID); 
    }

    
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _ROUTER = iROUTER(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _UTILS = iUTILS(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE = iRESERVE(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); 
        completeProposal(_proposalID); 
    }

    
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        coolOffPeriod = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        erasToEarn = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; 
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAmount != 0, ""!param""); 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; 
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); 
        completeProposal(_proposalID); 
    }

    
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; 
            listedBondAssets.push(_proposedAddress); 
        }
        completeProposal(_proposalID); 
    }

    
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        isListed[_proposedAddress] = false; 
        completeProposal(_proposalID); 
    }

    
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.addCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.removeCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }
    
    
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; 
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; 
        mapPID_finalised[_proposalID] = true; 
        mapPID_finalising[_proposalID] = false; 
        mapPID_open[_proposalID] = false; 
    }

    
    
    
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; 
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); 
        mapPID_votes[currentProposal] += voteWeight; 
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; 
        return voteWeight;
    }

    
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight * majorityFactor / 10000; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 2; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 6; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }
    }
}",5823.0,1,4,"The following vulnerabilities were found in the given smart contract:

1. **Reentrancy**: The contract uses a modifier `onlyDAO()` to restrict certain functions to be called only by the DAO. However, this modifier is not used consistently throughout the contract. In some places, it is used as a function modifier, while in others, it is used as a variable. This inconsistency can lead to reentrancy vulnerabilities if not handled properly.

2. **Missing Input Validation**: The contract uses various functions to transfer tokens and interact with other contracts. However, it does not validate the inputs to these functions properly. For example, the `handleTransferIn()` function does not check if the transfer amount is zero before attempting to transfer tokens. This can lead to unexpected behavior and potential security issues.

3. **Inconsistent Error Handling**: The contract uses different error handling mechanisms throughout its code. In some places, it uses the `require()` function to check for errors, while in others, it uses the `assert()` function. This inconsistency can make it difficult to diagnose and handle errors properly.

4. **Missing Event Emissions**: The contract uses events to notify external observers about certain actions. However, it does not emit events consistently throughout its code. For example, the `completeProposal()` function does not emit an event when a proposal is completed. This can make it difficult for external observers to track the progress of proposals.

5. **Inconsistent Function Signatures**: The contract uses different function signatures throughout its code. In some places, functions are declared with a specific return type, while in others, they are declared with a variable return type. This inconsistency can make it difficult to understand the expected behavior of functions.

6. **Missing Documentation**: The contract does not provide adequate documentation to explain its functionality and behavior. This can make it difficult for developers to understand and maintain the contract.

7. **Inconsistent Variable Naming**: The contract uses different variable naming conventions throughout its code. In some places, variables are named using camelCase, while in others, they are named using underscore notation. This inconsistency can make it difficult to understand the purpose and behavior of variables.

8. **Missing Type Hints**: The contract does not provide type hints for variables and function parameters. This can make it difficult to understand the expected data types and behavior of variables and functions.

9. **Inconsistent Function Ordering**: The contract uses different function ordering conventions throughout its code. In some places, functions are ordered alphabetically, while in others, they are ordered by their purpose. This inconsistency can make it difficult to understand the expected behavior of functions.

10. **Missing Security Considerations**: The contract does not consider security implications of certain actions. For example, the `handleTransferIn()` function does not check if the transfer amount is greater than the balance of the sender. This can lead to unexpected behavior and potential security issues.

To address these vulnerabilities, the contract should be thoroughly reviewed and refactored to ensure consistency in its code, documentation, and error handling mechanisms. Additionally, the contract should be tested thoroughly to ensure its expected behavior and security implications are properly addressed. 

Here are some specific suggestions to address the vulnerabilities:

1.  **Use a consistent naming convention**: Use a consistent naming convention throughout the contract to make it easier to understand and maintain.
2.  **Use type hints**: Use type hints for variables and function parameters to make it easier to understand the expected data types and behavior of variables and functions.
3.  **Use a consistent error handling mechanism**: Use a consistent error handling mechanism throughout the contract to make it easier to diagnose and handle errors.
4.  **Emit events consistently**: Emit events consistently throughout the contract to make it easier for external observers to track the progress of proposals.
5.  **Document the contract**: Provide adequate documentation to explain the functionality and behavior of the contract.
6.  **Use a consistent function ordering convention**: Use a consistent function ordering convention throughout the contract to make it easier to understand the expected behavior of functions.
7.  **Consider security implications**: Consider security implications of certain actions throughout the contract to make it easier to understand and maintain.
8.  **Refactor the contract**: Refactor the contract to ensure consistency in its code, documentation, and error handling mechanisms.
9.  **Test the contract thoroughly**: Test the contract thoroughly to ensure its expected behavior and security implications are properly addressed. 

By addressing these vulnerabilities and suggestions, the contract can be made more secure, maintainable, and understandable. 

Here is the refactored contract:

```pragma solidity 0.8.3;

import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACT","### **Comparison of Issue Report and Response List**

---

#### **[H-03] Result of transfer / transferFrom not checked**

**Report Description**:  
The issue highlights that calls to `transfer` or `transferFrom` are frequently made without checking the return value. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs, but a result of ""false"" is returned. Failing to check this could lead to minting tokens without receiving sufficient funds, resulting in financial losses. This is also a best practice in Solidity.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unchecked return values from `transfer` or `transferFrom` calls. This is a critical security concern that is entirely missed in the response list.

---

#### **[M-01] Dao.sol: Insufficient validation for proposal creation**

**Report Description**:  
The issue describes insufficient validation in the `new*Proposal()` functions in `Dao.sol`. Specifically:
- The `typeStr` is not validated, allowing invalid values like `ROUTER` or `BAD_STRING` to pass, which can cause `finaliseProposal()` to fail or do nothing.
- Proposed values are not checked for null, and validation only occurs in `finaliseProposal()` when sub-functions are called.

**Match in Response List**:  
Partially matches with **""Missing Input Validation""**.

**Validation**:  
**Partially Correct**. The response identifies the general issue of missing input validation but does not specifically address the problems with `typeStr` validation or null checks in proposal creation. The response is too generic and misses critical details.

---

#### **[M-02] Misleading onlyDAO modifiers**

**Report Description**:  
The issue points out that the `onlyDAO` modifier is implemented incorrectly in some contracts, allowing the deployer to execute functions instead of restricting access to the DAO. This creates a centralization risk, especially in cases where the deployer cannot be purged, potentially locking out functionality.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect `onlyDAO` modifiers or the associated centralization risks. This is a significant oversight.

---

#### **[M-03] Improper access control of claimAllForMember allows anyone to reduce the weight of a member**

**Report Description**:  
The `claimAllForMember` function in `Dao` is permissionless, allowing anyone to claim unlocked bonded LP tokens for any member. This can reduce the member's weight in the `BondVault`, affecting their votes and rewards in the `Dao` contract.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the improper access control in `claimAllForMember` or its impact on member weight and voting power. This is a critical security issue that is entirely missed.

---

#### **[M-10] grantFunds will revert after a DAO upgrade**

**Report Description**:  
When the DAO is upgraded via `moveDao`, the DAO address in `Reserve.sol` is not updated. This causes the `grantFunds` function to revert because the `onlyGrantor()` modifier in `Reserve.sol` checks the `msg.sender` against the outdated DAO address.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of outdated DAO addresses in `Reserve.sol` or the resulting reversion of `grantFunds`. This is a significant oversight.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] Dao.sol: Insufficient validation for proposal creation**

**Missed Issues from Issue Report**:  
- **[H-03] Result of transfer / transferFrom not checked**  
- **[M-02] Misleading onlyDAO modifiers**  
- **[M-03] Improper access control of claimAllForMember allows anyone to reduce the weight of a member**  
- **[M-10] grantFunds will revert after a DAO upgrade**

---

### **Conclusion**  
The response list fails to address most of the critical issues in the issue report. While it identifies some general problems like missing input validation, it lacks specificity and misses key vulnerabilities such as unchecked return values, improper access control, and centralization risks. The response list needs significant improvement to adequately address the security concerns outlined in the issue report.",3,0,2,13,"```
None.
```",0.0
Router.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./Pool.sol"";
import ""./interfaces/iRESERVE.sol""; 
import ""./interfaces/iPOOLFACTORY.sol"";  
import ""./interfaces/iWBNB.sol"";

contract Router {
    address public BASE;
    address public WBNB;
    address public DEPLOYER;

    uint private maxTrades;         // Amount of dividend events per era
    uint private eraLength;         // Dividend factor to regulate the max percentage of RESERVE balance
    uint public normalAverageFee;   // The average fee size (dividend smoothing)
    uint private arrayFeeSize;      // The size of the average window used for normalAverageFee
    uint [] private feeArray;       // The array used to calc normalAverageFee
    uint private lastMonth;         // Timestamp of the start of current metric period (For UI)

    mapping(address=> uint) public mapAddress_30DayDividends;
    mapping(address=> uint) public mapAddress_Past30DayPoolDividends;

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base, address _wbnb) {
        BASE = _base;
        WBNB = _wbnb;
        arrayFeeSize = 20;
        eraLength = 30;
        maxTrades = 100;
        lastMonth = 0;
        DEPLOYER = msg.sender;
    }

    receive() external payable {}

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    // User adds liquidity
    function addLiquidity(uint inputBase, uint inputToken, address token) external payable{
        addLiquidityForMember(inputBase, inputToken, token, msg.sender);
    }

    // Contract adds liquidity for user
    function addLiquidityForMember(uint inputBase, uint inputToken, address token, address member) public payable{
        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);  // Get pool address
        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA to pool
        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN to pool
        Pool(pool).addForMember(member); // Add liquidity to pool for user
    }

    // Trade LP tokens for another type of LP tokens
    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(fromPool) == true); // FromPool must be a valid pool
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(toPool) == true); // ToPool must be a valid pool
        address _fromToken = Pool(fromPool).TOKEN(); // Get token underlying the fromPool
        address _member = msg.sender; // Get user's address
        require(unitsInput <= iBEP20(fromPool).totalSupply()); // Input must be valid
        iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool
        Pool(fromPool).remove(); // Remove liquidity to ROUTER
        iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool
        Pool(fromPool).swapTo(BASE, toPool); // Swap the received TOKENs for SPARTA then transfer to the toPool
        iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool
        Pool(toPool).addForMember(_member); // Add liquidity and send the LPs to user
    }

    // User adds liquidity asymetrically (one asset)
    function addLiquiditySingle(uint inputToken, bool fromBase, address token) external payable{
        addLiquiditySingleForMember(inputToken, fromBase, token, msg.sender);
    }

    // Contract adds liquidity asymetrically for user (one asset)
    function addLiquiditySingleForMember(uint inputToken, bool fromBase, address token, address member) public payable{
        require(inputToken > 0); // Must be valid input amount
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address
        address _token = token;
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        if(fromBase){
            _handleTransferIn(BASE, inputToken, _pool); // Transfer SPARTA into pool
            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user
        } else {
            _handleTransferIn(token, inputToken, _pool); // Transfer TOKEN into pool
            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user
        }
    }

    // User removes liquidity - redeems a percentage of their balance
    function removeLiquidity(uint basisPoints, address token) external{
        require((basisPoints > 0 && basisPoints <= 10000)); // Must be valid basis points
        uint _units = iUTILS(_DAO().UTILS()).calcPart(basisPoints, iBEP20(iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token)).balanceOf(msg.sender));
        removeLiquidityExact(_units, token);
    }

    // User removes liquidity - redeems exact qty of LP tokens
    function removeLiquidityExact(uint units, address token) public {
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address
        address _member = msg.sender; // The the user's address
        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool
        if(token != address(0)){
            Pool(_pool).removeForMember(_member); // Remove liquidity and send assets directly to user
        } else {
            Pool(_pool).remove(); // If BNB; remove liquidity and send to ROUTER instead
            uint outputBase = iBEP20(BASE).balanceOf(address(this)); // Get the received SPARTA amount
            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); // Get the received WBNB amount
            _handleTransferOut(token, outputToken, _member); // Unwrap to BNB & tsf it to user
            _handleTransferOut(BASE, outputBase, _member); // Transfer SPARTA to user
        }
    }

    // User removes liquidity asymetrically (one asset)
    function removeLiquiditySingle(uint units, bool toBase, address token) external{
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true); // Pool must be valid
        address _member = msg.sender; // Get user's address
        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool
        Pool(_pool).remove(); // Remove liquidity & tsf to ROUTER
        address _token = token; // Get token address
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        if(toBase){
            iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool
            Pool(_pool).swapTo(BASE, _member); // Swap TOKEN for SPARTA & tsf to user
        } else {
            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool
            Pool(_pool).swap(_token); // Swap SPARTA for TOKEN & transfer to ROUTER
            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); // Send TOKEN to user
        } 
    }

    //============================== Swapping Functions ====================================//
    
    // Swap SPARTA for TOKEN
    function buyTo(uint amount, address token, address member) public {
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address
        _handleTransferIn(BASE, amount, _pool); // Transfer SPARTA to pool
        uint fee;
        if(token != address(0)){
            (, uint feey) = Pool(_pool).swapTo(token, member); // Swap SPARTA to TOKEN & tsf to user
            fee = feey;
        } else {
            (uint outputAmount, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB
            _handleTransferOut(token, outputAmount, member); // Unwrap to BNB & tsf to user
            fee = feez;
        }
        getsDividend(_pool, fee); // Check for dividend & tsf it to pool
    }

    // Swap TOKEN for SPARTA
    function sellTo(uint amount, address token, address member) public payable returns (uint){
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address
        _handleTransferIn(token, amount, _pool); // Transfer TOKEN to pool
        (, uint fee) = Pool(_pool).swapTo(BASE, member); // Swap TOKEN to SPARTA & transfer to user
        getsDividend(_pool, fee); // Check for dividend & tsf it to pool
        return fee;
    }

    // User performs a simple swap (to -> from)
    function swap(uint256 inputAmount, address fromToken, address toToken) external payable{
        swapTo(inputAmount, fromToken, toToken, msg.sender);
    }

    // Contract checks which swap function the user will require
    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member) public payable{
        require(fromToken != toToken); // Tokens must not be the same
        if(fromToken == BASE){
            buyTo(inputAmount, toToken, member); // Swap SPARTA to TOKEN & tsf to user
        } else if(toToken == BASE) {
            sellTo(inputAmount, fromToken, member); // Swap TOKEN to SPARTA & tsf to user
        } else {
            address _poolTo = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get pool address
            uint feey = sellTo(inputAmount, fromToken, _poolTo); // Swap TOKEN to SPARTA & tsf to pool
            address _toToken = toToken;
            if(toToken == address(0)){_toToken = WBNB;} // Handle BNB -> WBNB
            (uint _zz, uint _feez) = Pool(_poolTo).swap(_toToken); // Swap SPARTA to TOKEN & tsf to ROUTER
            uint fee = feey+(_feez); // Get total slip fees
            getsDividend(_poolTo, fee); // Check for dividend & tsf it to pool
            _handleTransferOut(toToken, _zz, member); // Transfer TOKEN to user
        }
    }

    // Check if fee should generate a dividend & send it to the pool
    function getsDividend(address _pool, uint fee) internal {
        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){
            addTradeFee(fee); // Add fee to array for avgFee calcs etc
            addDividend(_pool, fee); // Check and tsf dividend to pool
        }
    }

    //============================== Token Transfer Functions ======================================//
    
    // Handle the transfer of assets into the pool
    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){
        if(_amount > 0) {
            if(_token == address(0)){
                require((_amount == msg.value));
                (bool success, ) = payable(WBNB).call{value: _amount}(""""); // Wrap BNB
                require(success, ""!send"");
                iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool
                actual = _amount;
            } else {
                uint startBal = iBEP20(_token).balanceOf(_pool); // Get prior TOKEN balance of pool
                iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool
                actual = iBEP20(_token).balanceOf(_pool)-(startBal); // Get received TOKEN amount
            }
        }
    }

    // Handle the transfer of assets out of the ROUTER
    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal {
        if(_amount > 0) {
            if (_token == address(0)) {
                iWBNB(WBNB).withdraw(_amount); // Unwrap WBNB to BNB
                (bool success, ) = payable(_recipient).call{value:_amount}("""");  // Send BNB to recipient
                require(success, ""!send"");
            } else {
                iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient
            }
        }
    }

    //================================ Swap Synths ========================================//
    
    // Swap TOKEN to Synth
    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {
        require(fromToken != toSynth); // Tokens must not be the same
        address _synthLayer1 = iSYNTH(toSynth).LayerONE(); // Get underlying token's address
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthLayer1); // Get relevant pool address
        if(fromToken != BASE){
            sellTo(inputAmount, fromToken, address(this)); // Swap TOKEN to SPARTA & tsf to ROUTER
            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool
        } else {
            iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool
        }
        (, uint fee) = Pool(_pool).mintSynth(toSynth, msg.sender); // Mint synths & tsf to user
        getsDividend(_pool, fee); // Check and tsf dividend to pool
    }
   
    // Swap Synth to TOKEN
    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {
        require(fromSynth != toToken); // Tokens must not be the same
        address _synthINLayer1 = iSYNTH(fromSynth).LayerONE(); // Get synth's underlying token's address
        address _poolIN = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthINLayer1); // Get synth's relevant pool address
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get TOKEN's relevant pool address
        iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool
        uint outputAmount; uint fee;
        if(toToken == BASE){
            Pool(_poolIN).burnSynth(fromSynth, msg.sender); // Swap Synths for SPARTA & tsf to user
        } else {
            (outputAmount,fee) = Pool(_poolIN).burnSynth(fromSynth, address(this)); // Swap Synths to SPARTA & tsf to ROUTER
            if(toToken != address(0)){
                (, uint feey) = Pool(_pool).swapTo(toToken, msg.sender); // Swap SPARTA to TOKEN & transfer to user
                fee = feey + fee;
            } else {
                (uint outputAmountY, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB & tsf to ROUTER
                _handleTransferOut(toToken, outputAmountY, msg.sender); // Unwrap to BNB & tsf to user
                fee = feez + fee;
            }
        }
        getsDividend(_pool, fee); // Check and tsf dividend to pool
    }
    
    //============================= Token Dividends / Curated Pools =================================//
    
    // Calculate the Dividend and transfer it to the pool
    function addDividend(address _pool, uint256 _fees) internal {
        if(!(normalAverageFee == 0)){
            uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); // Get SPARTA balance in the RESERVE contract
            if(!(reserve == 0)){
                uint dailyAllocation = (reserve / eraLength) / maxTrades; // Calculate max dividend
                uint numerator = _fees * dailyAllocation;
                uint feeDividend = numerator / (_fees + normalAverageFee); // Calculate actual dividend
                revenueDetails(feeDividend, _pool); // Add to revenue metrics
                iRESERVE(_DAO().RESERVE()).grantFunds(feeDividend, _pool); // Transfer dividend from RESERVE to POOL
                Pool(_pool).sync(); // Sync the pool balances to attribute the dividend to the existing LPers
            }
        }
    }

    // Add fee to feeArray, used to calculate normalAverageFee
    function addTradeFee(uint _fee) internal {
        uint totalTradeFees = 0;
        uint arrayFeeLength = feeArray.length;
        if(arrayFeeLength < arrayFeeSize){
            feeArray.push(_fee); // Build array until it is == arrayFeeSize
        } else {
            addFee(_fee); // If array is required length; shift in place of oldest item
            for(uint i = 0; i < arrayFeeSize; i++){
                totalTradeFees = totalTradeFees + feeArray[i]; // NET sum of feeArray
            }
        }
        normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee
    }

    // Shift out oldest fee item and add newest
    function addFee(uint _fee) internal {
        uint n = feeArray.length; // 20
        for (uint i = n - 1; i > 0; i--) {
            feeArray[i] = feeArray[i - 1];
        }
        feeArray[0] = _fee;
    }

    function revenueDetails(uint _fees, address _pool) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ // 30 days
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        } else {
            lastMonth = block.timestamp;
            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];
            mapAddress_30DayDividends[_pool] = 0;
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        }
    }

    function stringToBytes(string memory s) external pure returns (bytes memory){
        return bytes(s);
    }

    function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){
        if(sha256(part1) == sha256(part2)){
            return true;
        }
    }
    
    //======================= Change Dividend Variables ===========================//

    function changeArrayFeeSize(uint _size) external onlyDAO {
        arrayFeeSize = _size;
        delete feeArray;
    }

    function changeMaxTrades(uint _maxtrades) external onlyDAO {
        maxTrades = _maxtrades;
    }

    function changeEraLength(uint _eraLength) external onlyDAO {    
        eraLength = _eraLength; 
    }

    //================================== Helpers =================================//

    function currentPoolRevenue(address pool) external view returns(uint256) {
        return mapAddress_30DayDividends[pool];
    }

    function pastPoolRevenue(address pool) external view returns(uint256) {
        return mapAddress_Past30DayPoolDividends[pool];
    }
}",4449.0,357.0,"[H-04] Members lose SPARTA tokens in removeLiquiditySingle() When a member calls `removeLiquiditySingle()` requesting only SPARTA in return, i.e. `toBASE = true`, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.
In other words, the `_member`'s BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the _member because the _token's transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via swapTo().
This effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.   [H-07] Missing slippage checks
There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.
Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.
  [H-08] Dividend reward can be gamed The `Router.addDividend` function tells the reserve to send dividends to the pool depending on the fees. 	- The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent.
	- The normalAverageFee variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool arrayFeeSize (20) times (use buyTo). The fees of the single wei trades will be zero and thus the normalAverageFee will also be zero as, see addTradeFee.
	- The attacker then does a trade that generates some non-zero fees, setting the normalAverageFee to this trade's fee. The feeDividend is then computed as _fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2. Half of the dailyAllocation is sent to the pool.
	- The attacker repeats the above steps until the reserve is almost empty. Each time the dailyAllocation gets smaller but it's still possible to withdraw almost all of it.
	- They redeem their LP tokens and gain a share of the profits The reserve can be emptied by the attacker.",3.0,"pragma solidity 0.8.3;
import ""./Pool.sol"";
import ""./interfaces/iRESERVE.sol""; 
import ""./interfaces/iPOOLFACTORY.sol"";  
import ""./interfaces/iWBNB.sol"";

contract Router {
    address public BASE;
    address public WBNB;
    address public DEPLOYER;

    uint private maxTrades;         
    uint private eraLength;         
    uint public normalAverageFee;   
    uint private arrayFeeSize;      
    uint [] private feeArray;       
    uint private lastMonth;         

    mapping(address=> uint) public mapAddress_30DayDividends;
    mapping(address=> uint) public mapAddress_Past30DayPoolDividends;

    
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base, address _wbnb) {
        BASE = _base;
        WBNB = _wbnb;
        arrayFeeSize = 20;
        eraLength = 30;
        maxTrades = 100;
        lastMonth = 0;
        DEPLOYER = msg.sender;
    }

    receive() external payable {}

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    
    function addLiquidity(uint inputBase, uint inputToken, address token) external payable{
        addLiquidityForMember(inputBase, inputToken, token, msg.sender);
    }

    
    function addLiquidityForMember(uint inputBase, uint inputToken, address token, address member) public payable{
        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);  
        _handleTransferIn(BASE, inputBase, pool); 
        _handleTransferIn(token, inputToken, pool); 
        Pool(pool).addForMember(member); 
    }

    
    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(fromPool) == true); 
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(toPool) == true); 
        address _fromToken = Pool(fromPool).TOKEN(); 
        address _member = msg.sender; 
        require(unitsInput <= iBEP20(fromPool).totalSupply()); 
        iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); 
        Pool(fromPool).remove(); 
        iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); 
        Pool(fromPool).swapTo(BASE, toPool); 
        iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); 
        Pool(toPool).addForMember(_member); 
    }

    
    function addLiquiditySingle(uint inputToken, bool fromBase, address token) external payable{
        addLiquiditySingleForMember(inputToken, fromBase, token, msg.sender);
    }

    
    function addLiquiditySingleForMember(uint inputToken, bool fromBase, address token, address member) public payable{
        require(inputToken > 0); 
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        address _token = token;
        if(token == address(0)){_token = WBNB;} 
        if(fromBase){
            _handleTransferIn(BASE, inputToken, _pool); 
            Pool(_pool).addForMember(member); 
        } else {
            _handleTransferIn(token, inputToken, _pool); 
            Pool(_pool).addForMember(member); 
        }
    }

    
    function removeLiquidity(uint basisPoints, address token) external{
        require((basisPoints > 0 && basisPoints <= 10000)); 
        uint _units = iUTILS(_DAO().UTILS()).calcPart(basisPoints, iBEP20(iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token)).balanceOf(msg.sender));
        removeLiquidityExact(_units, token);
    }

    
    function removeLiquidityExact(uint units, address token) public {
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        address _member = msg.sender; 
        iBEP20(_pool).transferFrom(_member, _pool, units); 
        if(token != address(0)){
            Pool(_pool).removeForMember(_member); 
        } else {
            Pool(_pool).remove(); 
            uint outputBase = iBEP20(BASE).balanceOf(address(this)); 
            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); 
            _handleTransferOut(token, outputToken, _member); 
            _handleTransferOut(BASE, outputBase, _member); 
        }
    }

    
    function removeLiquiditySingle(uint units, bool toBase, address token) external{
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true); 
        address _member = msg.sender; 
        iBEP20(_pool).transferFrom(_member, _pool, units); 
        Pool(_pool).remove(); 
        address _token = token; 
        if(token == address(0)){_token = WBNB;} 
        if(toBase){
            iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); 
            Pool(_pool).swapTo(BASE, _member); 
        } else {
            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); 
            Pool(_pool).swap(_token); 
            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); 
        } 
    }

    
    
    
    function buyTo(uint amount, address token, address member) public {
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        _handleTransferIn(BASE, amount, _pool); 
        uint fee;
        if(token != address(0)){
            (, uint feey) = Pool(_pool).swapTo(token, member); 
            fee = feey;
        } else {
            (uint outputAmount, uint feez) = Pool(_pool).swap(WBNB); 
            _handleTransferOut(token, outputAmount, member); 
            fee = feez;
        }
        getsDividend(_pool, fee); 
    }

    
    function sellTo(uint amount, address token, address member) public payable returns (uint){
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        _handleTransferIn(token, amount, _pool); 
        (, uint fee) = Pool(_pool).swapTo(BASE, member); 
        getsDividend(_pool, fee); 
        return fee;
    }

    
    function swap(uint256 inputAmount, address fromToken, address toToken) external payable{
        swapTo(inputAmount, fromToken, toToken, msg.sender);
    }

    
    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member) public payable{
        require(fromToken != toToken); 
        if(fromToken == BASE){
            buyTo(inputAmount, toToken, member); 
        } else if(toToken == BASE) {
            sellTo(inputAmount, fromToken, member); 
        } else {
            address _poolTo = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); 
            uint feey = sellTo(inputAmount, fromToken, _poolTo); 
            address _toToken = toToken;
            if(toToken == address(0)){_toToken = WBNB;} 
            (uint _zz, uint _feez) = Pool(_poolTo).swap(_toToken); 
            uint fee = feey+(_feez); 
            getsDividend(_poolTo, fee); 
            _handleTransferOut(toToken, _zz, member); 
        }
    }

    
    function getsDividend(address _pool, uint fee) internal {
        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){
            addTradeFee(fee); 
            addDividend(_pool, fee); 
        }
    }

    
    
    
    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){
        if(_amount > 0) {
            if(_token == address(0)){
                require((_amount == msg.value));
                (bool success, ) = payable(WBNB).call{value: _amount}(""""); 
                require(success, ""!send"");
                iBEP20(WBNB).transfer(_pool, _amount); 
                actual = _amount;
            } else {
                uint startBal = iBEP20(_token).balanceOf(_pool); 
                iBEP20(_token).transferFrom(msg.sender, _pool, _amount); 
                actual = iBEP20(_token).balanceOf(_pool)-(startBal); 
            }
        }
    }

    
    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal {
        if(_amount > 0) {
            if (_token == address(0)) {
                iWBNB(WBNB).withdraw(_amount); 
                (bool success, ) = payable(_recipient).call{value:_amount}("""");  
                require(success, ""!send"");
            } else {
                iBEP20(_token).transfer(_recipient, _amount); 
            }
        }
    }

    
    
    
    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {
        require(fromToken != toSynth); 
        address _synthLayer1 = iSYNTH(toSynth).LayerONE(); 
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthLayer1); 
        if(fromToken != BASE){
            sellTo(inputAmount, fromToken, address(this)); 
            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); 
        } else {
            iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); 
        }
        (, uint fee) = Pool(_pool).mintSynth(toSynth, msg.sender); 
        getsDividend(_pool, fee); 
    }
   
    
    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {
        require(fromSynth != toToken); 
        address _synthINLayer1 = iSYNTH(fromSynth).LayerONE(); 
        address _poolIN = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthINLayer1); 
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); 
        iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); 
        uint outputAmount; uint fee;
        if(toToken == BASE){
            Pool(_poolIN).burnSynth(fromSynth, msg.sender); 
        } else {
            (outputAmount,fee) = Pool(_poolIN).burnSynth(fromSynth, address(this)); 
            if(toToken != address(0)){
                (, uint feey) = Pool(_pool).swapTo(toToken, msg.sender); 
                fee = feey + fee;
            } else {
                (uint outputAmountY, uint feez) = Pool(_pool).swap(WBNB); 
                _handleTransferOut(toToken, outputAmountY, msg.sender); 
                fee = feez + fee;
            }
        }
        getsDividend(_pool, fee); 
    }
    
    
    
    
    function addDividend(address _pool, uint256 _fees) internal {
        if(!(normalAverageFee == 0)){
            uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); 
            if(!(reserve == 0)){
                uint dailyAllocation = (reserve / eraLength) / maxTrades; 
                uint numerator = _fees * dailyAllocation;
                uint feeDividend = numerator / (_fees + normalAverageFee); 
                revenueDetails(feeDividend, _pool); 
                iRESERVE(_DAO().RESERVE()).grantFunds(feeDividend, _pool); 
                Pool(_pool).sync(); 
            }
        }
    }

    
    function addTradeFee(uint _fee) internal {
        uint totalTradeFees = 0;
        uint arrayFeeLength = feeArray.length;
        if(arrayFeeLength < arrayFeeSize){
            feeArray.push(_fee); 
        } else {
            addFee(_fee); 
            for(uint i = 0; i < arrayFeeSize; i++){
                totalTradeFees = totalTradeFees + feeArray[i]; 
            }
        }
        normalAverageFee = totalTradeFees / arrayFeeSize; 
    }

    
    function addFee(uint _fee) internal {
        uint n = feeArray.length; 
        for (uint i = n - 1; i > 0; i--) {
            feeArray[i] = feeArray[i - 1];
        }
        feeArray[0] = _fee;
    }

    function revenueDetails(uint _fees, address _pool) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ 
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        } else {
            lastMonth = block.timestamp;
            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];
            mapAddress_30DayDividends[_pool] = 0;
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        }
    }

    function stringToBytes(string memory s) external pure returns (bytes memory){
        return bytes(s);
    }

    function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){
        if(sha256(part1) == sha256(part2)){
            return true;
        }
    }
    
    

    function changeArrayFeeSize(uint _size) external onlyDAO {
        arrayFeeSize = _size;
        delete feeArray;
    }

    function changeMaxTrades(uint _maxtrades) external onlyDAO {
        maxTrades = _maxtrades;
    }

    function changeEraLength(uint _eraLength) external onlyDAO {    
        eraLength = _eraLength; 
    }

    

    function currentPoolRevenue(address pool) external view returns(uint256) {
        return mapAddress_30DayDividends[pool];
    }

    function pastPoolRevenue(address pool) external view returns(uint256) {
        return mapAddress_Past30DayPoolDividends[pool];
    }
}",3257.0,3,0,"The following vulnerabilities were identified in the given solidity code of the smart contract:

1.  **Reentrancy Attack**: The contract is vulnerable to reentrancy attacks due to the lack of a reentrancy guard. The `addLiquidity` and `removeLiquidity` functions modify the state of the contract by transferring funds, but they do not check if the call is a reentrancy attack. This allows an attacker to repeatedly call these functions, causing the contract to transfer funds multiple times and resulting in a loss of funds.

2.  **Denial of Service (DoS) Attack**: The `addLiquidity` and `removeLiquidity` functions do not check if the sender has sufficient balance before transferring funds. This allows an attacker to call these functions repeatedly, causing the contract to run out of funds and resulting in a denial of service.

3.  **Front-Running Attack**: The contract uses the `iBEP20` and `iWBNB` interfaces to interact with other contracts. However, these interfaces do not provide any protection against front-running attacks. An attacker can front-run the contract by calling the `iBEP20` or `iWBNB` function before the contract has a chance to execute its logic, causing the contract to execute the wrong logic and resulting in a loss of funds.

4.  **Unprotected External Calls**: The contract makes external calls to other contracts using the `iBEP20` and `iWBNB` interfaces. However, these external calls are not protected against unexpected behavior or malicious contracts. An attacker can create a malicious contract that causes the contract to execute unexpected behavior or lose funds.

5.  **Use of Unchecked Variables**: The contract uses variables such as `lastMonth` and `normalAverageFee` without checking if they are valid before using them. This can cause the contract to execute unexpected behavior or lose funds.

6.  **Use of Unchecked Functions**: The contract uses functions such as `addLiquidity` and `removeLiquidity` without checking if the sender has sufficient balance before transferring funds. This can cause the contract to execute unexpected behavior or lose funds.

7.  **Lack of Access Control**: The contract does not have proper access control in place. The `onlyDAO` modifier is used to restrict access to certain functions, but it is not used consistently throughout the contract. This can cause the contract to execute unexpected behavior or lose funds.

8.  **Use of Outdated Functions**: The contract uses functions such as `iBEP20` and `iWBNB` that are outdated and may cause unexpected behavior or loss of funds.

9.  **Lack of Error Handling**: The contract does not have proper error handling in place. If an error occurs during the execution of a function, the contract may execute unexpected behavior or lose funds.

10. **Use of Unsecure Data Types**: The contract uses data types such as `string` and `bytes` that are not secure and may cause unexpected behavior or loss of funds.

To fix these vulnerabilities, the contract should be reviewed and updated to include proper reentrancy guards, access control, and error handling. Additionally, the contract should be tested thoroughly to ensure that it executes the correct logic and does not lose funds. Finally, the contract should be deployed on a secure and reliable blockchain platform.<|eot_id|>","### **Output**

---

**[H-04] Members lose SPARTA tokens in removeLiquiditySingle()**

**Report Description**:  
When a member calls `removeLiquiditySingle()` requesting only SPARTA in return (`toBASE = true`), the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA tokens are left behind in the Router instead of being returned along with the converted SPARTA from the Pool. This results in the member losing the SPARTA component of their Pool LP tokens, which remain in the Router and could be claimed by future transactions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves a logical flaw in the token transfer mechanism, specifically the failure to return the SPARTA tokens to the member. This is not covered by any of the responses, which focus on general vulnerabilities like reentrancy, denial of service, and unprotected external calls.

---

**[H-07] Missing slippage checks**

**Report Description**:  
There are no minimum amounts out or checks to mitigate frontrunning/slippage. This allows anyone with sufficient capital to force arbitrarily large slippage by sandwiching transactions, potentially causing losses close to 100%. The recommendation is to add a minimum amount out parameter and revert if the minimum amount is not obtained.

**Match in Response List**:  
Matches with the issue titled **""Front-Running Attack""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of front-running attacks, which is related to the issue of missing slippage checks. However, it does not explicitly mention the need for minimum amount out parameters or the specific mitigation strategy. The response focuses on the general risk of front-running but misses the critical detail of implementing slippage checks.

---

**[H-08] Dividend reward can be gamed**

**Report Description**:  
The `Router.addDividend` function sends dividends to the pool based on fees. An attacker can manipulate the `normalAverageFee` variable by conducting small trades to set it to zero, then perform a larger trade to capture half of the `dailyAllocation`. By repeating this process, the attacker can drain the reserve almost entirely. The attacker can then redeem their LP tokens to gain a share of the profits.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves a manipulation of the `normalAverageFee` variable and the exploitation of the dividend distribution mechanism. This is not covered by any of the responses, which focus on general vulnerabilities like reentrancy, denial of service, and unprotected external calls.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-07] Missing slippage checks**

**Missed Issues from Issue Report**:  
- **[H-04] Members lose SPARTA tokens in removeLiquiditySingle()**  
- **[H-08] Dividend reward can be gamed**

---

### **Conclusion**  
The response list covers general vulnerabilities but fails to address specific issues like the loss of SPARTA tokens in `removeLiquiditySingle()` and the manipulation of dividend rewards. The response to the missing slippage checks is partially correct but lacks detailed mitigation strategies. To improve, the response list should include specific fixes for the identified issues and address the unique vulnerabilities described in the issue report.",0,1,2,16,"```
None.
```",0.0
Synth.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./Pool.sol"";  
import ""./interfaces/iPOOLFACTORY.sol"";

contract Synth is iBEP20 {
    address public BASE;
    address public LayerONE; // Underlying relevant layer1 token
    uint public genesis;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;

    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    mapping(address => uint) public mapSynth_LPBalance;
    mapping(address => uint) public mapSynth_LPDebt;
   
    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }
    
    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER, ""!DAO"");
        _;
    }

    // Restrict access
    modifier onlyPool() {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, ""!curated"");
        _;
    }
    
    constructor (address _base, address _token) {
        BASE = _base;
        LayerONE = _token;
        string memory synthName = ""-SpartanProtocolSynthetic"";
        string memory synthSymbol = ""-SPS"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));
        decimals = iBEP20(_token).decimals();
        DEPLOYER = msg.sender;
        genesis = block.timestamp;
    }

    //========================================iBEP20=========================================//

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    // iBEP20 Transfer function
    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    // iBEP20 Approve, change allowance functions
    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }
    
    // iBEP20 TransferFrom function
    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        // Unlimited approval (saves an SSTORE)
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    //iBEP677 approveAndCall
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval
        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient
        return true;
    }

    //iBEP677 transferAndCall
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _transfer(msg.sender, recipient, amount);
        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient 
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    // Burn supply
    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //==================================== SYNTH FUNCTIONS =================================//

    // Handle received LP tokens and mint Synths
    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){
        uint lpUnits = _getAddedLPAmount(msg.sender); // Get the received LP units
        mapSynth_LPDebt[msg.sender] += amount; // Increase debt by synth amount
        mapSynth_LPBalance[msg.sender] += lpUnits; // Increase lp balance by LPs received
        _mint(member, amount); // Mint the synths & tsf to user
        return amount;
    }
    
    // Handle received Synths and burn the LPs and Synths
    function burnSynth() external returns (bool){
        uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units
        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total
        mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance
        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt
        if(_amountUnits > 0){
            _burn(address(this), _syntheticAmount); // Burn the synths
            Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens
        }
        return true;
    }

    // Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)
    function realise(address pool) external {
        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); // Get the SPARTA value of the LP tokens
        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); // Get the SPARTA value of the synths
        if(baseValueLP > baseValueSynth){
            uint premium = baseValueLP - baseValueSynth; // Get the premium between the two values
            if(premium > 10**18){
                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); // Get the LP value of the premium
                mapSynth_LPBalance[pool] -= premiumLP; // Reduce the LP balance
                Pool(pool).burn(premiumLP); // Burn the premium of the LP tokens
            }
        }
    }

    // Check the received token amount
    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){
        if(_amount > 0) {
            uint startBal = iBEP20(_token).balanceOf(address(this)); // Get existing balance
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in
            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; // Calculate received amount
        }
        return _actual;
    }

    // Check the received LP tokens amount
    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){
        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); // Get total balance held
        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){
            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; // Get received amount
        } else {
            _actual = 0;
        }
        return _actual;
    }

    function getmapAddress_LPBalance(address pool) external view returns (uint){
        return mapSynth_LPBalance[pool];
    }

    function getmapAddress_LPDebt(address pool) external view returns (uint){
        return mapSynth_LPDebt[pool];
    }
}",2196.0,230.0,"[H-05] Synth `realise` is vulnerable to flash loan attacks
Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. `Synth`'s lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.
The attack does not necessarily require a flash loan. A big whale of the lp token holders could keep calling `realise` by shifting token ratio of AMM pool back and forth.
The vulnerability is located at Synth.sol L187-L199. Where the formula here is dangerous.
  [H-09] arbitrary synth `mint`/`burn` from pool
`Pool` can mint arbitrary `Synth` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.   [M-07] Synth: approveAndCall sets unnecessary approval
The `Synth.approveAndCall` function approves the `recipient` contract with the max value instead of only the required `amount`.
For safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, like this is the case for `approveAndCall`.",3.0,"pragma solidity 0.8.3;
import ""./Pool.sol"";  
import ""./interfaces/iPOOLFACTORY.sol"";

contract Synth is iBEP20 {
    address public BASE;
    address public LayerONE; 
    uint public genesis;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;

    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    mapping(address => uint) public mapSynth_LPBalance;
    mapping(address => uint) public mapSynth_LPDebt;
   
    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }
    
    
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER, ""!DAO"");
        _;
    }

    
    modifier onlyPool() {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, ""!curated"");
        _;
    }
    
    constructor (address _base, address _token) {
        BASE = _base;
        LayerONE = _token;
        string memory synthName = ""-SpartanProtocolSynthetic"";
        string memory synthSymbol = ""-SPS"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));
        decimals = iBEP20(_token).decimals();
        DEPLOYER = msg.sender;
        genesis = block.timestamp;
    }

    

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    
    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { 
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }
    
    
    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _approve(msg.sender, recipient, type(uint256).max); 
        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); 
        return true;
    }

    
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _transfer(msg.sender, recipient, amount);
        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); 
        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    
    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    

    
    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){
        uint lpUnits = _getAddedLPAmount(msg.sender); 
        mapSynth_LPDebt[msg.sender] += amount; 
        mapSynth_LPBalance[msg.sender] += lpUnits; 
        _mint(member, amount); 
        return amount;
    }
    
    
    function burnSynth() external returns (bool){
        uint _syntheticAmount = balanceOf(address(this)); 
        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; 
        mapSynth_LPBalance[msg.sender] -= _amountUnits; 
        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; 
        if(_amountUnits > 0){
            _burn(address(this), _syntheticAmount); 
            Pool(msg.sender).burn(_amountUnits); 
        }
        return true;
    }

    
    function realise(address pool) external {
        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); 
        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); 
        if(baseValueLP > baseValueSynth){
            uint premium = baseValueLP - baseValueSynth; 
            if(premium > 10**18){
                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); 
                mapSynth_LPBalance[pool] -= premiumLP; 
                Pool(pool).burn(premiumLP); 
            }
        }
    }

    
    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){
        if(_amount > 0) {
            uint startBal = iBEP20(_token).balanceOf(address(this)); 
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); 
            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; 
        }
        return _actual;
    }

    
    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){
        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); 
        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){
            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; 
        } else {
            _actual = 0;
        }
        return _actual;
    }

    function getmapAddress_LPBalance(address pool) external view returns (uint){
        return mapSynth_LPBalance[pool];
    }

    function getmapAddress_LPDebt(address pool) external view returns (uint){
        return mapSynth_LPDebt[pool];
    }
}",1840.0,2,1,"The code provided is a smart contract written in Solidity, which implements a BEP20 token standard. Below are the vulnerabilities identified in the code:

1. **Reentrancy Vulnerability**: The contract uses the `transferFrom` function, which can lead to reentrancy attacks. The attacker can repeatedly call the `transferFrom` function, causing the contract to execute the same code multiple times, leading to unexpected behavior.

2. **Unprotected Functions**: The contract has several functions that are not protected by any modifier, such as `mintSynth` and `burnSynth`. These functions can be called by anyone, potentially leading to unintended behavior.

3. **Unvalidated Inputs**: The contract does not validate the inputs to some of its functions, such as `mintSynth` and `burnSynth`. This can lead to unexpected behavior if the inputs are not correctly formatted.

4. **Insufficient Error Handling**: The contract does not handle errors properly. For example, in the `mintSynth` function, if the `allowance` check fails, the function will revert without providing any information about the error.

5. **Potential Front-Running**: The contract's `realise` function can be vulnerable to front-running attacks. An attacker can call the `realise` function before the actual calculation is performed, leading to unexpected behavior.

6. **Unprotected Variables**: The contract has several variables that are not protected by any modifier, such as `mapSynth_LPBalance` and `mapSynth_LPDebt`. These variables can be modified by anyone, potentially leading to unintended behavior.

7. **Missing Checks**: The contract does not perform any checks on the `msg.sender` in some of its functions, such as `mintSynth` and `burnSynth`. This can lead to unexpected behavior if the `msg.sender` is not correctly validated.

8. **Potential Denial of Service (DoS) Attack**: The contract's `realise` function can be vulnerable to DoS attacks. An attacker can repeatedly call the `realise` function, causing the contract to perform unnecessary calculations and leading to a denial of service.

To address these vulnerabilities, the contract should be reviewed and modified to include proper error handling, input validation, and protection of sensitive variables and functions. Additionally, the contract should be audited to ensure that it is secure and compliant with the relevant standards. 9. **Missing Checks**: The contract does not perform any checks on the `msg.sender` in some of its functions, such as `mintSynth` and `burnSynth`. This can lead to unexpected behavior if the `msg.sender` is not correctly validated.

10. **Potential Denial of Service (DoS) Attack**: The contract's `realise` function can be vulnerable to DoS attacks. An attacker can repeatedly call the `realise` function, causing the contract to perform unnecessary calculations and leading to a denial of service.

To address these vulnerabilities, the contract should be reviewed and modified to include proper error handling, input validation, and protection of sensitive variables and functions. Additionally, the contract should be audited to ensure that it is secure and compliant with the relevant standards. 9. **Missing Checks**: The contract does not perform any checks on the `msg.sender` in some of its functions, such as `mintSynth` and `burnSynth`. This can lead to unexpected behavior if the `msg.sender` is not correctly validated.

10. **Potential Denial of Service (DoS) Attack**: The contract's `realise` function can be vulnerable to DoS attacks. An attacker can repeatedly call the `realise` function, causing the contract to perform unnecessary calculations and leading to a denial of service. 11. **Missing Checks**: The contract does not perform any checks on the `msg.sender` in some of its functions, such as `mintSynth` and `burnSynth`. This can lead to unexpected behavior if the `msg.sender` is not correctly validated.

12. **Potential Denial of Service (DoS) Attack**: The contract's `realise` function can be vulnerable to DoS attacks. An attacker can repeatedly call the `realise` function, causing the contract to perform unnecessary calculations and leading to a denial of service.

To address these vulnerabilities, the contract should be reviewed and modified to include proper error handling, input validation, and protection of sensitive variables and functions. Additionally, the contract should be audited to ensure that it is secure and compliant with the relevant standards. 13. **Missing Checks**: The contract does not perform any checks on the `msg.sender` in some of its functions, such as `mintSynth` and `burnSynth`. This can lead to unexpected behavior if the `msg.sender` is not correctly validated.

14. **Potential Denial of Service (DoS) Attack**: The contract","### **Comparison of Issue Report and Response List**

---

#### **[H-05] Synth `realise` is vulnerable to flash loan attacks**

**Report Description**:  
The `realise` function in `Synth` calculates `baseValueLP` and `baseValueSynth` based on the AMM spot price, making it vulnerable to flash loan attacks. The attack does not necessarily require a flash loan; a large LP token holder could repeatedly call `realise` by manipulating the AMM pool's token ratio. This vulnerability is located in `Synth.sol` (lines 187–199), where the formula used is dangerous.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running""** and **""Potential Denial of Service (DoS) Attack""**.

**Validation**:  
**Partially Correct**. The response identifies the `realise` function as vulnerable to front-running and DoS attacks, which partially aligns with the issue. However, it misses the core vulnerability: the reliance on AMM spot prices, which can be manipulated via flash loans or large LP token holders. The response does not address the specific risks of price manipulation or the dangerous formula in `Synth.sol`.

---

#### **[H-09] Arbitrary Synth `mint`/`burn` from pool**

**Report Description**:  
The `Pool` can mint arbitrary `Synth` tokens as long as they are valid. When multiple curated pools and synths exist, attackers can mint expensive synthetics from cheaper AMM pools, burn them in expensive pools, and profit. This arbitrage can be amplified with flash loans, potentially breaking all pegs.

**Match in Response List**:  
Matches with the issue titled **""Unprotected Functions""** and **""Unvalidated Inputs""**.

**Validation**:  
**Partially Correct**. The response identifies that `mintSynth` and `burnSynth` functions are unprotected and lack input validation, which is relevant. However, it does not address the specific arbitrage risk or the potential for breaking pegs through flash loan amplification. The response misses the broader economic impact of the vulnerability.

---

#### **[M-07] Synth: `approveAndCall` sets unnecessary approval**

**Report Description**:  
The `approveAndCall` function in `Synth` approves the `recipient` contract with the max value instead of only the required `amount`. This is unsafe, especially when the required amount is already known in the call. Excessive approval increases the risk of misuse by the recipient contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The unnecessary approval of max value in `approveAndCall` is a critical security concern that is entirely missed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-05] Synth `realise` is vulnerable to flash loan attacks**  
- **[H-09] Arbitrary Synth `mint`/`burn` from pool**

**Missed Issues from Issue Report**:  
- **[M-07] Synth: `approveAndCall` sets unnecessary approval**

---

### **Conclusion**  
The `response_list` partially addresses some issues but misses critical details and fails to identify specific vulnerabilities like the unnecessary approval in `approveAndCall`. The responses are often generic and do not fully align with the nuanced risks described in the `issue` report. A more detailed and specific analysis is required to address all identified vulnerabilities effectively.",2,1,0,17,"```
None.
```",0.0
Utils.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iBEP20.sol"";

contract Utils {
    address public BASE;
    uint public one = 10**18;

    constructor (address _base) {
        BASE = _base;
    }

    struct PoolDataStruct {
        address tokenAddress;
        address poolAddress;
        uint genesis;
        uint baseAmount;
        uint tokenAmount;
        uint fees;
        uint volume;
        uint txCount;
        uint poolUnits;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    //================================== HELPERS ================================//

    function getPoolData(address token) external view returns(PoolDataStruct memory poolData){
        address pool = getPool(token);
        poolData.poolAddress = pool;
        poolData.tokenAddress = token;
        poolData.genesis = iPOOL(pool).genesis();
        poolData.baseAmount = iPOOL(pool).baseAmount();
        poolData.tokenAmount = iPOOL(pool).tokenAmount();
        poolData.poolUnits = iBEP20(pool).totalSupply();
        return poolData;
    }

    function getPoolShareWeight(address token, uint units) external view returns(uint weight){
        address pool = getPool(token);
        weight = calcShare(units, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());
        return (weight);
    }

    function getPool(address token) public view returns(address pool){
        return iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);
    }

    //================================== CORE-MATH ==================================//
    
    // Calculate the feeBurn's feeOnTransfer based on total supply
    function getFeeOnTransfer(uint256 totalSupply, uint256 maxSupply) external pure returns (uint256) {
        return calcShare(totalSupply, maxSupply, 100); // 0 -> 100bp
    }

    // Calculate 'part' of a total using basis points | 10,000 basis points = 100.00%
    function calcPart(uint256 bp, uint256 total) external pure returns (uint256) {
        require(bp <= 10000, ""!bp""); // basis points must be valid
        return calcShare(bp, 10000, total);
    }

    // Calc share | share = amount * part / total
    function calcShare(uint256 part, uint256 total, uint256 amount) public pure returns (uint256 share) {
        if (part > total) {
            part = total; // Part cant be greater than the total
        }
        if (total > 0) {
            share = (amount * part) / total;
        }
    }

    // Calculate liquidity units
    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint units){
        if(P == 0){
            return b; // If pool is empty; use b as initial units
        } else {
            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment
            // P * (part1 + part2) / (part3) * slipAdjustment
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = t*(B);
            uint part2 = T*(b);
            uint part3 = T*(B)*(2);
            uint _units = (P * (part1 + (part2))) / (part3);
            return _units * slipAdjustment / one;  // Divide by 10**18
        }
    }

    // Get slip adjustment
    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint slipAdjustment){
        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))
        // 1 - ABS(part1 - part2)/(part3 * part4))
        uint part1 = B * (t);
        uint part2 = b * (T);
        uint part3 = b * (2) + (B);
        uint part4 = t + (T);
        uint numerator;
        if(part1 > part2){
            numerator = part1 - (part2);
        } else {
            numerator = part2 - (part1);
        }
        uint denominator = part3 * (part4);
        return one - ((numerator * (one)) / (denominator)); // Multiply by 10**18
    }

    // Calculate symmetrical redemption value of LP tokens (per side)
    function calcLiquidityHoldings(uint units, address token, address pool) external view returns (uint share){
        // share = amount * part / total
        // address pool = getPool(token);
        uint amount;
        if(token == BASE){
            amount = iPOOL(pool).baseAmount();
        } else {
            amount = iPOOL(pool).tokenAmount();
        }
        uint totalSupply = iBEP20(pool).totalSupply();
        return(amount*(units))/(totalSupply);
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint output){
        // y = (x * X * Y )/(x + X)^2
        uint numerator = x * (X * (Y));
        uint denominator = (x + (X)) * (x + (X));
        return numerator / (denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint output){
        // y = (x * x * Y) / (x + X)^2
        uint numerator = x * (x * (Y));
        uint denominator = (x + (X)) * (x + (X));
        return numerator / (denominator);
    }

    // Calculate asymmetrical redemption value of LP tokens (remove all to TOKEN)
    function calcAsymmetricValueToken(address pool, uint amount) external view returns (uint tokenValue){
        uint baseAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());
        uint tokenAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).tokenAmount());
        uint baseSwapped = calcSwapValueInTokenWithPool(pool, baseAmount);
        tokenValue = tokenAmount + baseSwapped;
        return tokenValue;
    }

    function calcLiquidityUnitsAsym(uint amount, address pool) external view returns (uint units){
        // synthUnits += (P b)/(2 (b + B))
        uint baseAmount = iPOOL(pool).baseAmount();
        uint totalSupply = iBEP20(pool).totalSupply();
        uint two = 2;
        return (totalSupply * amount) / (two * (amount + baseAmount));
    }

    //==================================== PRICING ====================================//

    function calcSpotValueInBase(address token, uint amount) external view returns (uint value){
        address pool = getPool(token);
        return calcSpotValueInBaseWithPool(pool, amount);
    }

    function calcSpotValueInToken(address token, uint amount) external view returns (uint value){
        address pool = getPool(token);
        return calcSpotValueInTokenWithPool(pool, amount);
    }

    function calcSwapValueInBase(address token, uint amount) external view returns (uint _output){
        address pool = getPool(token);
        return  calcSwapValueInBaseWithPool(pool, amount);
    }

    function calcSwapValueInBaseWithSYNTH(address synth, uint amount) external view returns (uint _output){
        address token = iSYNTH(synth).LayerONE();
        address pool = getPool(token);
        return  calcSwapValueInBaseWithPool(pool, amount);
    }

    function calcSwapValueInToken(address token, uint amount) external view returns (uint _output){
        address pool = getPool(token);
        return  calcSwapValueInTokenWithPool(pool, amount);
    }

    function calcSpotValueInBaseWithPool(address pool, uint amount) public view returns (uint value){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return (amount*(_baseAmount))/(_tokenAmount);
    }

    function calcSpotValueInTokenWithPool(address pool, uint amount) public view returns (uint value){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return (amount*(_tokenAmount))/(_baseAmount);
    }

    function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return  calcSwapOutput(amount, _tokenAmount, _baseAmount);
    }

    function calcSwapValueInTokenWithPool(address pool, uint amount) public view returns (uint _output){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return  calcSwapOutput(amount, _baseAmount, _tokenAmount);
    }

    function calcActualSynthUnits(uint amount, address synth) external view returns (uint _output) {
        address token = iSYNTH(synth).LayerONE();
        address pool = getPool(token);
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return ((amount * _baseAmount) / (2 * _tokenAmount));
    }
}",2087.0,218.0,"[H-13] Flash loan manipulation on `getPoolShareWeight` of `Utils`
The `getPoolShareWeight` function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.
According to the implementation of `getPoolShareWeight`, a user's pool share weight is calculated by `uints * baseAmount / totalSupply`, where uints is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool.",1.0,"pragma solidity 0.8.3;
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iBEP20.sol"";

contract Utils {
    address public BASE;
    uint public one = 10**18;

    constructor (address _base) {
        BASE = _base;
    }

    struct PoolDataStruct {
        address tokenAddress;
        address poolAddress;
        uint genesis;
        uint baseAmount;
        uint tokenAmount;
        uint fees;
        uint volume;
        uint txCount;
        uint poolUnits;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    

    function getPoolData(address token) external view returns(PoolDataStruct memory poolData){
        address pool = getPool(token);
        poolData.poolAddress = pool;
        poolData.tokenAddress = token;
        poolData.genesis = iPOOL(pool).genesis();
        poolData.baseAmount = iPOOL(pool).baseAmount();
        poolData.tokenAmount = iPOOL(pool).tokenAmount();
        poolData.poolUnits = iBEP20(pool).totalSupply();
        return poolData;
    }

    function getPoolShareWeight(address token, uint units) external view returns(uint weight){
        address pool = getPool(token);
        weight = calcShare(units, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());
        return (weight);
    }

    function getPool(address token) public view returns(address pool){
        return iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);
    }

    
    
    
    function getFeeOnTransfer(uint256 totalSupply, uint256 maxSupply) external pure returns (uint256) {
        return calcShare(totalSupply, maxSupply, 100); 
    }

    
    function calcPart(uint256 bp, uint256 total) external pure returns (uint256) {
        require(bp <= 10000, ""!bp""); 
        return calcShare(bp, 10000, total);
    }

    
    function calcShare(uint256 part, uint256 total, uint256 amount) public pure returns (uint256 share) {
        if (part > total) {
            part = total; 
        }
        if (total > 0) {
            share = (amount * part) / total;
        }
    }

    
    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint units){
        if(P == 0){
            return b; 
        } else {
            
            
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = t*(B);
            uint part2 = T*(b);
            uint part3 = T*(B)*(2);
            uint _units = (P * (part1 + (part2))) / (part3);
            return _units * slipAdjustment / one;  
        }
    }

    
    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint slipAdjustment){
        
        
        uint part1 = B * (t);
        uint part2 = b * (T);
        uint part3 = b * (2) + (B);
        uint part4 = t + (T);
        uint numerator;
        if(part1 > part2){
            numerator = part1 - (part2);
        } else {
            numerator = part2 - (part1);
        }
        uint denominator = part3 * (part4);
        return one - ((numerator * (one)) / (denominator)); 
    }

    
    function calcLiquidityHoldings(uint units, address token, address pool) external view returns (uint share){
        
        
        uint amount;
        if(token == BASE){
            amount = iPOOL(pool).baseAmount();
        } else {
            amount = iPOOL(pool).tokenAmount();
        }
        uint totalSupply = iBEP20(pool).totalSupply();
        return(amount*(units))/(totalSupply);
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint output){
        
        uint numerator = x * (X * (Y));
        uint denominator = (x + (X)) * (x + (X));
        return numerator / (denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint output){
        
        uint numerator = x * (x * (Y));
        uint denominator = (x + (X)) * (x + (X));
        return numerator / (denominator);
    }

    
    function calcAsymmetricValueToken(address pool, uint amount) external view returns (uint tokenValue){
        uint baseAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());
        uint tokenAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).tokenAmount());
        uint baseSwapped = calcSwapValueInTokenWithPool(pool, baseAmount);
        tokenValue = tokenAmount + baseSwapped;
        return tokenValue;
    }

    function calcLiquidityUnitsAsym(uint amount, address pool) external view returns (uint units){
        
        uint baseAmount = iPOOL(pool).baseAmount();
        uint totalSupply = iBEP20(pool).totalSupply();
        uint two = 2;
        return (totalSupply * amount) / (two * (amount + baseAmount));
    }

    

    function calcSpotValueInBase(address token, uint amount) external view returns (uint value){
        address pool = getPool(token);
        return calcSpotValueInBaseWithPool(pool, amount);
    }

    function calcSpotValueInToken(address token, uint amount) external view returns (uint value){
        address pool = getPool(token);
        return calcSpotValueInTokenWithPool(pool, amount);
    }

    function calcSwapValueInBase(address token, uint amount) external view returns (uint _output){
        address pool = getPool(token);
        return  calcSwapValueInBaseWithPool(pool, amount);
    }

    function calcSwapValueInBaseWithSYNTH(address synth, uint amount) external view returns (uint _output){
        address token = iSYNTH(synth).LayerONE();
        address pool = getPool(token);
        return  calcSwapValueInBaseWithPool(pool, amount);
    }

    function calcSwapValueInToken(address token, uint amount) external view returns (uint _output){
        address pool = getPool(token);
        return  calcSwapValueInTokenWithPool(pool, amount);
    }

    function calcSpotValueInBaseWithPool(address pool, uint amount) public view returns (uint value){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return (amount*(_baseAmount))/(_tokenAmount);
    }

    function calcSpotValueInTokenWithPool(address pool, uint amount) public view returns (uint value){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return (amount*(_tokenAmount))/(_baseAmount);
    }

    function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return  calcSwapOutput(amount, _tokenAmount, _baseAmount);
    }

    function calcSwapValueInTokenWithPool(address pool, uint amount) public view returns (uint _output){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return  calcSwapOutput(amount, _baseAmount, _tokenAmount);
    }

    function calcActualSynthUnits(uint amount, address synth) external view returns (uint _output) {
        address token = iSYNTH(synth).LayerONE();
        address pool = getPool(token);
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return ((amount * _baseAmount) / (2 * _tokenAmount));
    }
}",1761.0,1,0,"The given solidity code of smart contract has the following vulnerabilities:

1. **Reentrancy Vulnerability**: The contract uses the `call` function to call another contract, which can lead to reentrancy attacks. The `call` function does not allow for the execution of a contract's functions, only for the execution of a contract's fallback function.

2. **Unprotected Views**: The contract has several functions marked as `view` that are not protected against reentrancy. These functions can be called repeatedly, leading to a denial of service attack.

3. **Unprotected External Functions**: The contract has several external functions that are not protected against reentrancy. These functions can be called repeatedly, leading to a denial of service attack.

4. **Use of `require` Statement**: The contract uses the `require` statement to check if a condition is met. However, the `require` statement can be bypassed by using the `revert` instruction, which can lead to a denial of service attack.

5. **Use of `calcShare` Function**: The contract uses the `calcShare` function to calculate the share of a user. However, the `calcShare` function can be used to manipulate the share of a user, leading to a denial of service attack.

6. **Use of `calcSwapOutput` Function**: The contract uses the `calcSwapOutput` function to calculate the output of a swap. However, the `calcSwapOutput` function can be used to manipulate the output of a swap, leading to a denial of service attack.

7. **Use of `calcSwapFee` Function**: The contract uses the `calcSwapFee` function to calculate the fee of a swap. However, the `calcSwapFee` function can be used to manipulate the fee of a swap, leading to a denial of service attack.

8. **Use of `calcActualSynthUnits` Function**: The contract uses the `calcActualSynthUnits` function to calculate the actual units of a synth. However, the `calcActualSynthUnits` function can be used to manipulate the actual units of a synth, leading to a denial of service attack.

9. **Use of `getSlipAdustment` Function**: The contract uses the `getSlipAdustment` function to calculate the slip adjustment. However, the `getSlipAdustment` function can be used to manipulate the slip adjustment, leading to a denial of service attack.

10. **Use of `calcLiquidityUnitsAsym` Function**: The contract uses the `calcLiquidityUnitsAsym` function to calculate the liquidity units. However, the `calcLiquidityUnitsAsym` function can be used to manipulate the liquidity units, leading to a denial of service attack.

11. **Use of `calcLiquidityHoldings` Function**: The contract uses the `calcLiquidityHoldings` function to calculate the holdings. However, the `calcLiquidityHoldings` function can be used to manipulate the holdings, leading to a denial of service attack.

12. **Use of `calcAsymmetricValueToken` Function**: The contract uses the `calcAsymmetricValueToken` function to calculate the asymmetric value token. However, the `calcAsymmetricValueToken` function can be used to manipulate the asymmetric value token, leading to a denial of service attack.

13. **Use of `calcSpotValueInBase` Function**: The contract uses the `calcSpotValueInBase` function to calculate the spot value in base. However, the `calcSpotValueInBase` function can be used to manipulate the spot value in base, leading to a denial of service attack.

14. **Use of `calcSpotValueInToken` Function**: The contract uses the `calcSpotValueInToken` function to calculate the spot value in token. However, the `calcSpotValueInToken` function can be used to manipulate the spot value in token, leading to a denial of service attack.

15. **Use of `calcSwapValueInBase` Function**: The contract uses the `calcSwapValueInBase` function to calculate the swap value in base. However, the `calcSwapValueInBase` function can be used to manipulate the swap value in base, leading to a denial of service attack.

16. **Use of `calcSwapValueInToken` Function**: The contract uses the `calcSwapValueInToken` function to calculate the swap value in token. However, the `calcSwapValueInToken` function can be used to manipulate the swap value in token, leading to a denial of service attack.

17. **Use of `calcSwapValueInBaseWithPool` Function**: The contract uses the `calcSwapValueInBaseWithPool` function to calculate the swap value in base with pool. However, the `calcSwapValueInBase","---

**[H-13] Flash loan manipulation on `getPoolShareWeight` of `Utils`**

**Report Description**:
The `getPoolShareWeight` function calculates a user's pool share weight based on the number of SPARTAN tokens in the pool. This calculation is vulnerable to flash loan manipulation, as an attacker can temporarily increase the number of SPARTAN tokens in the pool by swapping a large amount of TOKEN to SPARTAN. This manipulation inflates the attacker's pool share weight, allowing them to gain an unfair advantage. The formula `uints * baseAmount / totalSupply` is directly proportional to the number of SPARTAN tokens (`baseAmount`), making it susceptible to such attacks.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of flash loan manipulation in the `getPoolShareWeight` function. While the response list mentions various vulnerabilities related to reentrancy, unprotected views, and manipulation of calculation functions, it does not specifically identify the risk of flash loan attacks or the proportional dependency of pool share weight on SPARTAN tokens. This is a critical oversight, as flash loan manipulation is a significant security concern in DeFi protocols.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-13] Flash loan manipulation on `getPoolShareWeight` of `Utils`**

--- 

**Analysis**:
The response list fails to address the specific issue of flash loan manipulation in the `getPoolShareWeight` function. This is a notable gap, as the issue highlights a critical vulnerability in the protocol's design. The response list focuses on general vulnerabilities like reentrancy and unprotected functions but misses the nuanced risk of flash loan attacks, which are particularly relevant in DeFi contexts. Future responses should include considerations for flash loan vulnerabilities and proportional dependency risks in token calculations.",1,0,0,14,"```
None.
```",0.0
,,,,,,,,13,7,,,10,2,8,93,,
