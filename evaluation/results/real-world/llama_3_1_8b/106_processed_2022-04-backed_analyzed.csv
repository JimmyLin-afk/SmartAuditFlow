nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
NFTLoanFacilitator.sol,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    // ==== constants ====

    /** 
     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     
     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%
     */
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    /// See {INFTLoanFacilitator-SCALAR}.
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    // ==== state variables ====

    /// See {INFTLoanFacilitator-originationFeeRate}.
    /// @dev starts at 1%
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    /// See {INFTLoanFacilitator-requiredImprovementRate}.
    /// @dev starts at 10%
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    /// See {INFTLoanFacilitator-lendTicketContract}.
    address public override lendTicketContract;

    /// See {INFTLoanFacilitator-borrowTicketContract}.
    address public override borrowTicketContract;

    /// See {INFTLoanFacilitator-loanInfo}.
    mapping(uint256 => Loan) public loanInfo;

    /// @dev tracks loan count
    uint256 private _nonce = 1;

    
    // ==== modifiers ====

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    // ==== constructor ====

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    // ==== state changing external functions ====

    /// See {INFTLoanFacilitator-createLoan}.
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    /// See {INFTLoanFacilitator-closeLoan}.
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-lend}.
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            // will underflow if amount < previousAmount
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    /// See {INFTLoanFacilitator-repayAndCloseLoan}.
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-seizeCollateral}.
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    // === owner state changing ===

    /**
     * @notice Sets lendTicketContract to _contract
     * @dev cannot be set if lendTicketContract is already set
     */
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    /**
     * @notice Sets borrowTicketContract to _contract
     * @dev cannot be set if borrowTicketContract is already set
     */
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    /**
     * @notice Updates originationFeeRate the faciliator keeps of each loan amount
     * @dev Cannot be set higher than 5%
     */
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    /**
     * @notice updates the percent improvement required of at least one loan term when buying out lender 
     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount
     * must be 10% higher or interest rate must be 10% lower. 
     * @dev Cannot be 0.
     */
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    // ==== external view ====

    /// See {INFTLoanFacilitator-loanInfoStruct}.
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    /// See {INFTLoanFacilitator-totalOwed}.
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-interestOwed}.
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-loanEndSeconds}.
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    // === private ===

    /// @dev Returns the total interest owed on loan
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 // SCALAR * 1e18
            + accumulatedInterest;
    }
}",3357,388,"[H-01] Can force borrower to pay huge interest
In the function `lend()`, the loan amount is used as a min loan amount. It can be matched as high as possible (realistically up to the collateral NFT's worth to remain in profit) and the borrower has to pay interest on the entire amount instead of just on the desired loan amount when the loan was created.

[H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout
If an attacker already calls `lend()` to lend to a loan, the attacker can manipulate `loanInfo` by reentrancy attack when any lenders try to buyout. The attacker can set bad values of lendInfo (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.

[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy
If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.[M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it

[M-02] Protocol doesn't handle fee on transfer tokens
Since the borrower is able to specify any asset token, it is possible that loans will be created with tokens that support fee on transfer. If a fee on transfer asset token is chosen, the protocol will contain a point of failure on the original `lend()` call.

[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen
The `sendCollateralTo` will receive the collateral NFT when `closeLoan()` is called. However, if `sendCollateralTo` is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract.

[M-04] `requiredImprovementRate` can not work as expected when `previousInterestRate` less than 10 due to precision loss

[M-05] Borrowers lose funds if they call `repayAndCloseLoan` instead of `closeLoan`
The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan (matched with `lend`). Users should use closeLoan in this case but the contract should disallow calling `repayAndCloseLoan` because users can lose funds.
It performs a `ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount)` call where interest will be a high value accumulated from timestamp 0 and the loan.loanAmount is the initially desired min loan amount `minLoanAmount` set in `createLoan`. The user will lose these funds if they ever approved the contract (for example, for another loan).

[M-06] Might not get desired min loan amount if _originationFeeRate changes
Admins can update the origination fee by calling `updateOriginationFeeRate`. Note that a borrower does not receive their `minLoanAmount` set in createLoan, they only receive `(1 - originationFee) * minLoanAmount`, see lend. Therefore, they need to precalculate the `minLoanAmount` using the `current` origination fee to arrive at the post-fee amount that they actually receive. If admins then increase the fee, the borrower receives fewer funds than required to cover their rent and might become homeless.

[M-07] `mintBorrowTicketTo` can be a contract with no `onERC721Received` method, which may cause the `BorrowTicket NFT` to be frozen and put users' funds at risk
“IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);”",10,"pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    

    
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    

    
    
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    
    
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    
    address public override lendTicketContract;

    
    address public override borrowTicketContract;

    
    mapping(uint256 => Loan) public loanInfo;

    
    uint256 private _nonce = 1;

    
    

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    

    
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    

    
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    

    
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    

    
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 
            + accumulatedInterest;
    }
}",2789,3,7,"The code contains several vulnerabilities:

1.  **Reentrancy**: The contract does not use the `nonReentrant` modifier, which allows an attacker to repeatedly call the `closeLoan` function, causing the contract to malfunction.

2.  **Gas Limit**: The `closeLoan` function does not have a gas limit, which could cause the function to fail if the gas limit is exceeded.

3.  **Incorrect Gas Estimation**: The `closeLoan` function does not estimate gas correctly, which could cause the function to fail if the gas limit is exceeded.

4.  **Unprotected Function**: The `closeLoan` function does not have any access control, which allows anyone to close a loan, even if they are not the owner of the loan.

5.  **Unprotected Variable**: The `loanInfo` mapping does not have any access control, which allows anyone to access or modify the loan information.

6.  **Missing Error Handling**: The contract does not handle errors properly, which could cause the contract to malfunction if an error occurs.

7.  **Incorrect Variable Initialization**: The `loanInfo` mapping is not initialized properly, which could cause the contract to malfunction if the mapping is accessed before it is initialized.

8.  **Unprotected Function**: The `seizeCollateral` function does not have any access control, which allows anyone to seize the collateral, even if they are not the owner of the loan.

9.  **Unprotected Variable**: The `lendTicketContract` and `borrowTicketContract` variables do not have any access control, which allows anyone to access or modify these variables.

10. **Missing Event**: The contract does not emit an event when a loan is created, which could cause the contract to malfunction if the event is not handled properly.

11. **Missing Event**: The contract does not emit an event when a loan is repaid, which could cause the contract to malfunction if the event is not handled properly.

12. **Missing Event**: The contract does not emit an event when a loan is closed, which could cause the contract to malfunction if the event is not handled properly.

13. **Missing Event**: The contract does not emit an event when a loan is seized, which could cause the contract to malfunction if the event is not handled properly.

14. **Missing Event**: The contract does not emit an event when the origination fee rate is updated, which could cause the contract to malfunction if the event is not handled properly.

15. **Missing Event**: The contract does not emit an event when the required improvement rate is updated, which could cause the contract to malfunction if the event is not handled properly.

16. **Missing Event**: The contract does not emit an event when the total owed is updated, which could cause the contract to malfunction if the event is not handled properly.

17. **Missing Event**: The contract does not emit an event when the interest owed is updated, which could cause the contract to malfunction if the event is not handled properly.

18. **Missing Event**: The contract does not emit an event when the loan end seconds are updated, which could cause the contract to malfunction if the event is not handled properly.

19. **Missing Event**: The contract does not emit an event when the loan info struct is updated, which could cause the contract to malfunction if the event is not handled properly.

20. **Missing Event**: The contract does not emit an event when the total owed is updated, which could cause the contract to malfunction if the event is not handled properly.

21. **Missing Event**: The contract does not emit an event when the interest owed is updated, which could cause the contract to malfunction if the event is not handled properly.

22. **Missing Event**: The contract does not emit an event when the loan end seconds are updated, which could cause the contract to malfunction if the event is not handled properly.

23. **Missing Event**: The contract does not emit an event when the loan info struct is updated, which could cause the contract to malfunction if the event is not handled properly.

24. **Missing Event**: The contract does not emit an event when the total owed is updated, which could cause the contract to malfunction if the event is not handled properly.

25. **Missing Event**: The contract does not emit an event when the interest owed is updated, which could cause the contract to malfunction if the event is not handled properly.

26. **Missing Event**: The contract does not emit an event when the loan end seconds are updated, which could cause the contract to malfunction if the event is not handled properly.

27. **Missing Event**: The contract does not emit an event when the loan info struct is updated, which could cause the contract to malfunction if the event is not handled properly.

28. **Missing Event**: The contract does not emit an event when the total owed is updated, which could cause the contract to malfunction if the event is","### **Comparison of Issue Report and Response List**

---

#### **[H-01] Can force borrower to pay huge interest**

**Report Description**:  
In the `lend()` function, the loan amount is used as a minimum loan amount. It can be matched as high as possible (up to the collateral NFT's worth), forcing the borrower to pay interest on the entire amount instead of just the desired loan amount when the loan was created.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of borrowers being forced to pay excessive interest due to the loan amount being used as a minimum loan amount. This is a critical oversight in the response list.

---

#### **[H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout**

**Report Description**:  
If an attacker calls `lend()` to lend to a loan, they can manipulate `loanInfo` via a reentrancy attack when lenders try to buyout. The attacker can set unfavorable values (e.g., very long duration, 0 interest rate) that the lender does not expect.

**Match in Response List**:  
**Reentrancy**: The contract does not use the `nonReentrant` modifier, which allows an attacker to repeatedly call the `closeLoan` function, causing the contract to malfunction.

**Validation**:  
**Partially Correct**. The response identifies reentrancy as a vulnerability but does not specifically address the manipulation of `loanInfo` during buyout attempts. The core issue is partially covered but lacks critical details.

---

#### **[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy**

**Report Description**:  
If a borrower lends to their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT, loan amount, and accrued interest.

**Match in Response List**:  
**Reentrancy**: The contract does not use the `nonReentrant` modifier, which allows an attacker to repeatedly call the `closeLoan` function, causing the contract to malfunction.

**Validation**:  
**Partially Correct**. The response identifies reentrancy but does not address the specific scenario where a borrower acts as their own lender to steal funds. The core issue is partially covered but lacks specificity.

---

#### **[M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it**

**Report Description**:  
An attacker can lend to a loan and trigger a Denial of Service (DoS) attack, preventing other lenders from buying out the loan.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the DoS vulnerability caused by an attacker lending to a loan and blocking buyout attempts.

---

#### **[M-02] Protocol doesn't handle fee on transfer tokens**

**Report Description**:  
Since the borrower can specify any asset token, loans can be created with tokens that support fee on transfer. If a fee on transfer token is chosen, the protocol will fail on the original `lend()` call.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee on transfer tokens, which is a critical oversight.

---

#### **[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen**

**Report Description**:  
The `sendCollateralTo` address receives the collateral NFT when `closeLoan()` is called. If `sendCollateralTo` is a contract address that does not support ERC721, the collateral NFT can be frozen.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unchecked `sendCollateralTo` addresses, which can lead to frozen NFTs.

---

#### **[M-04] requiredImprovementRate can not work as expected when previousInterestRate less than 10 due to precision loss**

**Report Description**:  
The `requiredImprovementRate` may not work as expected when `previousInterestRate` is less than 10 due to precision loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the precision loss issue with `requiredImprovementRate`.

---

#### **[M-05] Borrowers lose funds if they call repayAndCloseLoan instead of closeLoan**

**Report Description**:  
The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan. Users should use `closeLoan` in this case, but the contract does not disallow calling `repayAndCloseLoan`, causing users to lose funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of users losing funds due to incorrect function calls.

---

#### **[M-06] Might not get desired min loan amount if _originationFeeRate changes**

**Report Description**:  
Admins can update the origination fee by calling `updateOriginationFeeRate`. Borrowers may receive fewer funds than required if the fee increases after loan creation.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of borrowers receiving fewer funds due to changes in the origination fee.

---

#### **[M-07] mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk**

**Report Description**:  
If `mintBorrowTicketTo` is a contract address that does not support `onERC721Received`, the BorrowTicket NFT can be frozen, putting users' funds at risk.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of frozen BorrowTicket NFTs due to unsupported `onERC721Received` methods.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout**  
- **[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy**

**Missed Issues from Issue Report**:  
- **[H-01] Can force borrower to pay huge interest**  
- **[M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it**  
- **[M-02] Protocol doesn't handle fee on transfer tokens**  
- **[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen**  
- **[M-04] requiredImprovementRate can not work as expected when previousInterestRate less than 10 due to precision loss**  
- **[M-05] Borrowers lose funds if they call repayAndCloseLoan instead of closeLoan**  
- **[M-06] Might not get desired min loan amount if _originationFeeRate changes**  
- **[M-07] mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen and put users' funds at risk**

---

### **Conclusion**  
The response list partially addresses reentrancy issues but fails to cover the majority of the vulnerabilities and risks identified in the issue report. Critical issues such as fee on transfer tokens, frozen NFTs, and precision loss are entirely missed. The response list needs significant improvement to adequately address the security concerns raised in the issue report.",4,2,4,13,"```
None.
```",0.0
