nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
MasterChef.sol,"// SPDX-License-Identifier: MIT


pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

contract MasterChef is Ownable, ReentrancyGuard {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    event Deposit(address indexed _user, uint indexed _pid, uint _amount);
    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);
    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);

    struct UserInfo {
        uint128 amount; // How many tokens the user has provided.
        uint128 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of RADSs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 depositToken; // Address of LP token contract.
        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.
        uint lastRewardBlock; // Last block number that distribution occurs.
        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.
        uint16 depositFeeBP; // Deposit fee in basis points
    }

    PoolInfo[] public poolInfo;
    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.
    mapping(address => bool) public isDepositor;
    mapping(address => uint256) public pid; // pid mapped to token
    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block
    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.
    uint public startBlock;
    uint public endBlock; // The block number when mining starts.
    IERC20 public concur;

    uint private _concurShareMultiplier = 1e18;
    uint private _perMille = 1000; // 100%

    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {
        startBlock = _startBlock;
        endBlock = _endBlock;
        concur = _concur;
        poolInfo.push(
            PoolInfo({
            depositToken: IERC20(address(0)),
            allocPoint : 0,
            lastRewardBlock : _startBlock,
            accConcurPerShare : 0,
            depositFeeBP : 0
        }));
    }

    modifier onlyDepositor() {
        require(isDepositor[msg.sender], ""!depositor"");
        _;
    }

    function addDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = true;
    }

    function removeDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = false;
    }

    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {
        require(_token != address(0), ""zero address"");
        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocationPoints);
        require(pid[_token] == 0, ""already registered""); // pid starts from 0
        poolInfo.push(
            PoolInfo({
                depositToken: IERC20(_token),
                allocPoint: _allocationPoints,
                lastRewardBlock: lastRewardBlock,
                accConcurPerShare: 0,
                depositFeeBP: _depositFee
            })
        );
        pid[_token] = poolInfo.length - 1;
    }

    function poolLength() external view returns (uint) {
        return poolInfo.length;
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint _from, uint _to) public pure returns (uint) {
        return _to.sub(_from);
    }

    // View function to see pending [concur] on frontend.
    function pendingConcur(uint _pid, address _user) external view returns (uint) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint accConcurPerShare = pool.accConcurPerShare;
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        }
        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
    }

    // Update reward variables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint length = poolInfo.length;
        for (uint _pid = 0; _pid < length; ++_pid) {
            updatePool(_pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (lpSupply == 0 || pool.allocPoint == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        if(block.number >= endBlock) {
            pool.lastRewardBlock = block.number;
            return;
        }        

        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        pool.lastRewardBlock = block.number;
    }

    // Deposit tokens for [concur] allocation.  
    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        updatePool(_pid);
       
        if(user.amount > 0) {  
            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
            if (pending > 0) {
                safeConcurTransfer(_recipient, pending);
            }
        }

        if (_amount > 0) {
            if (pool.depositFeeBP > 0) {
                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);
                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);
            } else {
                user.amount = SafeCast.toUint128(user.amount + _amount);
            }
        }     

        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Deposit(_recipient, _pid, _amount);
    }

    // Withdraw tokens
    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        require(user.amount > 0, ""MasterChef: nothing to withdraw"");
        require(user.amount >= _amount, ""MasterChef: withdraw not allowed"");
        updatePool(_pid);

        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
        if(pending > 0) {
            safeConcurTransfer(_recipient, pending);
        }
        if (_amount > 0) {
            user.amount = SafeCast.toUint128(user.amount - _amount);
        }
        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Withdraw(_recipient, _pid, _amount);
    }

    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough
    function safeConcurTransfer(address _to, uint _amount) private {
        uint concurBalance = concur.balanceOf(address(this));
        bool transferSuccess = false;
        if (_amount > concurBalance) {
            transferSuccess = concur.transfer(_to, concurBalance);
        } else {
            transferSuccess = concur.transfer(_to, _amount);
        }
        require(transferSuccess, ""safeConcurTransfer: transfer failed"");
    }
}",2020.0,331.0,"[H-01] Wrong reward token calculation in MasterChef contract
When adding new token pool for staking in MasterChef contract“function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock)”
All other, already added, pools should be updated but currently they are not.Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update.

[H-02] Masterchef: Improper handling of deposit fee
If a pool’s `deposit` function fee is non-zero, it is subtracted from the amount to be credited to the user.
However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).

[H-08] MasterChef.sol Users won't be able to receive the concur rewards
MasterChef is only recording the deposited amount in the states, it's not actually holding the `depositToken`.
`depositToken` won't be transferred from `_msgSender()` to the MasterChef contract.
Therefore, in `updatePool()` L140 `lpSupply = pool.depositToken.balanceOf(address(this))` will always be 0. And the updatePool() will be returned.

[H-09] deposit in ConvexStakingWrapper will most certainly revert
`convexPool[_pid]` is set to `IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;`

[M-02] Unconstrained fee
Token fee in MasterChef can be set to more than 100%, (for example, by accident) causing all `deposit` calls to fail due to underflow on subtraction when reward is lowered by the fee, thus breaking essential mechanics. Note that after the fee has been set to any value, it cannot be undone. A token cannot be removed, added, or added the second time. Thus, mistakenly (or deliberately, maliciously) added fee that is larger than 100% will make the contract impossible to recover from not being able to use the token.

[M-20] MasterChef.updatePool() Fails To Update Reward Variables If `block.number >= endBlock`
The `updatePool` function intends to calculate the accumulated Concur rewards by tracking the number of blocks passed since the last update to correctly determine how many Concur tokens to distribute to each share. The reward distribution has a start and end block which dictates the timeframe by which rewards will be distributed to the underlying pool.
If a pool has not recently updated itself and has reached the `block.number >= endBlock` statement in updatePool, then any rewards that it would normally be entitled to prior to reaching endBlock will not be attributed to the pool. Therefore, once rewards are no longer being distributed, pools who had not recently called updatePool before reaching endBlock are at a disadvantage as compared to more active pools.

[M-14] Owner can steal Concur rewards
Owner can steal Concur rewards by adding a depositor and inflating other depositors' assigned balance of the token within the contract. Thus, the owner-managed depositor can get most (all but one wei) of the created tokens.

[M-15] Owner can lock tokens in MasterChef
Owner can remove a depositor. Since only depositors can deposit and withdraw, the owner may add a contract to the whitelist, let users deposit in the contract and remove the depositor from the whitelist. Depositor's reward cannot be withdrawn then. And takes a share of Concur tokens that will not be distributed.

[M-16] Rewards get diluted because totalAllocPoint can only increase.
There is no functionality for removing pools/setting pool's allocPoints. Therefore totalAllocPoint only increases and rewards for pool decreases.",6.0,"// SPDX-License-Identifier: MIT


pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

contract MasterChef is Ownable, ReentrancyGuard {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    event Deposit(address indexed _user, uint indexed _pid, uint _amount);
    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);
    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);

    struct UserInfo {
        uint128 amount; // How many tokens the user has provided.
        uint128 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of RADSs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 depositToken; // Address of LP token contract.
        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.
        uint lastRewardBlock; // Last block number that distribution occurs.
        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.
        uint16 depositFeeBP; // Deposit fee in basis points
    }

    PoolInfo[] public poolInfo;
    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.
    mapping(address => bool) public isDepositor;
    mapping(address => uint256) public pid; // pid mapped to token
    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block
    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.
    uint public startBlock;
    uint public endBlock; // The block number when mining starts.
    IERC20 public concur;

    uint private _concurShareMultiplier = 1e18;
    uint private _perMille = 1000; // 100%

    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {
        startBlock = _startBlock;
        endBlock = _endBlock;
        concur = _concur;
        poolInfo.push(
            PoolInfo({
            depositToken: IERC20(address(0)),
            allocPoint : 0,
            lastRewardBlock : _startBlock,
            accConcurPerShare : 0,
            depositFeeBP : 0
        }));
    }

    modifier onlyDepositor() {
        require(isDepositor[msg.sender], ""!depositor"");
        _;
    }

    function addDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = true;
    }

    function removeDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = false;
    }

    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {
        require(_token != address(0), ""zero address"");
        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocationPoints);
        require(pid[_token] == 0, ""already registered""); // pid starts from 0
        poolInfo.push(
            PoolInfo({
                depositToken: IERC20(_token),
                allocPoint: _allocationPoints,
                lastRewardBlock: lastRewardBlock,
                accConcurPerShare: 0,
                depositFeeBP: _depositFee
            })
        );
        pid[_token] = poolInfo.length - 1;
    }

    function poolLength() external view returns (uint) {
        return poolInfo.length;
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint _from, uint _to) public pure returns (uint) {
        return _to.sub(_from);
    }

    // View function to see pending [concur] on frontend.
    function pendingConcur(uint _pid, address _user) external view returns (uint) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint accConcurPerShare = pool.accConcurPerShare;
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        }
        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
    }

    // Update reward variables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint length = poolInfo.length;
        for (uint _pid = 0; _pid < length; ++_pid) {
            updatePool(_pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (lpSupply == 0 || pool.allocPoint == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        if(block.number >= endBlock) {
            pool.lastRewardBlock = block.number;
            return;
        }        

        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        pool.lastRewardBlock = block.number;
    }

    // Deposit tokens for [concur] allocation.  
    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        updatePool(_pid);
       
        if(user.amount > 0) {  
            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
            if (pending > 0) {
                safeConcurTransfer(_recipient, pending);
            }
        }

        if (_amount > 0) {
            if (pool.depositFeeBP > 0) {
                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);
                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);
            } else {
                user.amount = SafeCast.toUint128(user.amount + _amount);
            }
        }     

        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Deposit(_recipient, _pid, _amount);
    }

    // Withdraw tokens
    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        require(user.amount > 0, ""MasterChef: nothing to withdraw"");
        require(user.amount >= _amount, ""MasterChef: withdraw not allowed"");
        updatePool(_pid);

        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
        if(pending > 0) {
            safeConcurTransfer(_recipient, pending);
        }
        if (_amount > 0) {
            user.amount = SafeCast.toUint128(user.amount - _amount);
        }
        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Withdraw(_recipient, _pid, _amount);
    }

    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough
    function safeConcurTransfer(address _to, uint _amount) private {
        uint concurBalance = concur.balanceOf(address(this));
        bool transferSuccess = false;
        if (_amount > concurBalance) {
            transferSuccess = concur.transfer(_to, concurBalance);
        } else {
            transferSuccess = concur.transfer(_to, _amount);
        }
        require(transferSuccess, ""safeConcurTransfer: transfer failed"");
    }
}",2020.0,4,5,"1. **Reentrancy Vulnerability**: The `deposit` function does not check if the user has already deposited before calling the `updatePool` function, which may lead to a reentrancy vulnerability. This can be mitigated by using the `checkReentrancy` modifier from OpenZeppelin's ReentrancyGuard contract.
2. **Unprotected Functions**: The `massUpdatePools` and `updatePool` functions are not protected by the `nonReentrant` modifier, which can lead to reentrancy vulnerabilities. These functions should be modified to include the `nonReentrant` modifier.
3. **Potential Arithmetic Overflows**: The `deposit` and `withdraw` functions use the `SafeCast.toUint128` function to convert values to `uint128`. However, if the values exceed the maximum value that can be represented by `uint128`, an arithmetic overflow may occur. This can be mitigated by using the `SafeCast.toUint256` function instead.
4. **Missing Error Handling**: The `deposit` and `withdraw` functions do not check if the user has already deposited before calling the `updatePool` function. If the user has already deposited, the `updatePool` function may be called again, leading to a reentrancy vulnerability. This can be mitigated by adding error handling to check if the user has already deposited.
5. **Potential Division by Zero**: The `updatePool` function calculates the `concurReward` variable by dividing the `multiplier` variable by the `totalAllocPoint` variable. If `totalAllocPoint` is zero, a division by zero error may occur. This can be mitigated by checking if `totalAllocPoint` is zero before calculating the `concurReward` variable.
6. **Missing Input Validation**: The `deposit` and `withdraw` functions do not validate the input values before processing them. This can lead to unexpected behavior or errors if the input values are invalid. This can be mitigated by adding input validation to check if the input values are within the expected range.
7. **Potential Data Corruption**: The `deposit` and `withdraw` functions use the `SafeCast.toUint128` function to convert values to `uint128`. However, if the values exceed the maximum value that can be represented by `uint128`, data corruption may occur. This can be mitigated by using the `SafeCast.toUint256` function instead.
8. **Missing Contract Owner Validation**: The `addDepositor` and `removeDepositor` functions do not validate if the contract owner is calling the function. This can lead to unexpected behavior or errors if the contract owner is not calling the function. This can be mitigated by adding contract owner validation to check if the contract owner is calling the function.
9. **Potential Gas Limit Exceeded**: The `deposit` and `withdraw` functions do not check if the gas limit has been exceeded. If the gas limit is exceeded, the function may not be executed correctly. This can be mitigated by adding gas limit checks to ensure that the function is executed correctly.
10. **Missing Event Emission**: The `deposit` and `withdraw` functions do not emit events to notify the contract users about the changes. This can lead to unexpected behavior or errors if the contract users are not notified about the changes. This can be mitigated by adding event emission to notify the contract users about the changes.````
```python
import json

def parse_contract(contract_str):
    # Parse the contract string into a JSON object
    contract_json = json.loads(contract_str)
    
    # Extract the vulnerabilities from the JSON object
    vulnerabilities = []
    
    # Check for reentrancy vulnerability
    if ""ReentrancyGuard"" not in contract_json:
        vulnerabilities.append(""Reentrancy vulnerability"")
    
    # Check for unprotected functions
    if ""nonReentrant"" not in contract_json:
        vulnerabilities.append(""Unprotected functions"")
    
    # Check for potential arithmetic overflows
    if ""SafeCast"" not in contract_json:
        vulnerabilities.append(""Potential arithmetic overflows"")
    
    # Check for missing error handling
    if ""error handling"" not in contract_json:
        vulnerabilities.append(""Missing error handling"")
    
    # Check for potential division by zero
    if ""division by zero"" not in contract_json:
        vulnerabilities.append(""Potential division by zero"")
    
    # Check for missing input validation
    if ""input validation"" not in contract_json:
        vulnerabilities.append(""Missing input validation"")
    
    # Check for potential data corruption
    if ""data corruption"" not in contract_json:
        vulnerabilities.append(""Potential data corruption"")
    
    # Check for missing contract owner validation
    if ""contract owner validation"" not in contract_json:
        vulnerabilities.append(""Missing contract owner validation"")
    
    # Check for potential gas limit exceeded
    if ""gas","It seems like the code snippet you provided is incomplete and doesn't fully address the task of comparing the `issue` report with the `response_list`. Let me help you structure the comparison and evaluation based on the provided input.

---

### **[H-01] Wrong reward token calculation in MasterChef contract**

**Report Description**:  
When adding a new token pool for staking in the MasterChef contract (`function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock)`), all other already added pools should be updated, but currently, only `totalPoints` is updated. This oversight causes old (and not updated) pools to lose their share during the next update.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves incorrect reward distribution due to missing updates to existing pools, which is not covered in the `response_list`.

---

### **[H-02] Masterchef: Improper handling of deposit fee**

**Report Description**:  
If a pool’s `deposit` function fee is non-zero, it is subtracted from the amount to be credited to the user. However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of deposit fees being permanently locked up. This is a critical oversight in the contract's fee handling mechanism.

---

### **[H-08] MasterChef.sol Users won't be able to receive the concur rewards**

**Report Description**:  
MasterChef only records the deposited amount in the states but does not actually hold the `depositToken`. As a result, `lpSupply = pool.depositToken.balanceOf(address(this))` in `updatePool()` will always be `0`, causing the function to return early and preventing users from receiving rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem lies in the contract's failure to hold `depositToken`, which is not covered in the `response_list`.

---

### **[H-09] deposit in ConvexStakingWrapper will most certainly revert**

**Report Description**:  
`convexPool[_pid]` is set to `IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;`. This setup may cause the `deposit` function to revert due to incorrect or invalid pool information.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves potential reverts due to incorrect pool setup, which is not covered in the `response_list`.

---

### **[M-02] Unconstrained fee**

**Report Description**:  
The token fee in MasterChef can be set to more than 100%, causing all `deposit` calls to fail due to underflow on subtraction when the reward is lowered by the fee. This breaks essential mechanics, and the fee cannot be undone once set.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves unconstrained fee settings leading to underflow, which is not covered in the `response_list`.

---

### **[M-20] MasterChef.updatePool() Fails To Update Reward Variables If `block.number >= endBlock`**

**Report Description**:  
If a pool has not recently updated itself and reaches `block.number >= endBlock`, any rewards it would normally be entitled to prior to reaching `endBlock` will not be attributed to the pool. This disadvantages less active pools.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves reward distribution being halted for inactive pools, which is not covered in the `response_list`.

---

### **[M-14] Owner can steal Concur rewards**

**Report Description**:  
The owner can steal Concur rewards by adding a depositor and inflating other depositors' assigned balance of the token within the contract. This allows the owner-managed depositor to get most (all but one wei) of the created tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves owner manipulation of depositor balances, which is not covered in the `response_list`.

---

### **[M-15] Owner can lock tokens in MasterChef**

**Report Description**:  
The owner can remove a depositor, preventing users from withdrawing their deposits and rewards. This locks tokens in the contract and disrupts reward distribution.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves owner manipulation of depositor whitelisting, which is not covered in the `response_list`.

---

### **[M-16] Rewards get diluted because `totalAllocPoint` can only increase**

**Report Description**:  
There is no functionality for removing pools or setting a pool's `allocPoints`. As a result, `totalAllocPoint` only increases, diluting rewards for existing pools.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves reward dilution due to increasing `totalAllocPoint`, which is not covered in the `response_list`.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Wrong reward token calculation in MasterChef contract**  
- **[H-02] Masterchef: Improper handling of deposit fee**  
- **[H-08] MasterChef.sol Users won't be able to receive the concur rewards**  
- **[H-09] deposit in ConvexStakingWrapper will most certainly revert**  
- **[M-02] Unconstrained fee**  
- **[M-20] MasterChef.updatePool() Fails To Update Reward Variables If `block.number >= endBlock`**  
- **[M-14] Owner can steal Concur rewards**  
- **[M-15] Owner can lock tokens in MasterChef**  
- **[M-16] Rewards get diluted because `totalAllocPoint` can only increase**

---

The `response_list` does not address any of the issues in the `issue` report, resulting in a complete mismatch. The issues in the `issue` report involve critical vulnerabilities and risks that require immediate attention and mitigation.",2,4,3,14,"```
None.
```",0.0
Shelter.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IShelter } from ""./interfaces/IShelter.sol"";
import { IShelterClient } from ""./interfaces/IShelterClient.sol"";

contract Shelter is IShelter {
    using SafeERC20 for IERC20;

    IShelterClient public immutable client;

    uint256 public constant GRACE_PERIOD = 1 weeks;

    mapping(IERC20 => mapping(address => bool)) public override claimed;

    mapping(IERC20 => uint256) public activated;

    mapping(IERC20 => uint256) public savedTokens;

    modifier onlyClient {
        require(msg.sender == address(client), ""!client"");
        _;
    }

    constructor(IShelterClient _client){
        client = _client;
    }

    function donate(IERC20 _token, uint256 _amount) external {
        require(activated[_token] != 0, ""!activated"");
        savedTokens[_token] += _amount;
        _token.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function activate(IERC20 _token) external override onlyClient {
        activated[_token] = block.timestamp;
        savedTokens[_token] = _token.balanceOf(address(this));
        emit ShelterActivated(_token);
    }

    function deactivate(IERC20 _token) external override onlyClient {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, ""too late"");
        activated[_token] = 0;
        savedTokens[_token] = 0;
        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));
        emit ShelterDeactivated(_token);
    }

    function withdraw(IERC20 _token, address _to) external override {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, ""shelter not activated"");
        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);
        claimed[_token][_to] = true;
        emit ExitShelter(_token, msg.sender, _to, amount);
        _token.safeTransfer(_to, amount);
    }
}",511.0,59.0,"[H-03] Repeated Calls to `Shelter.withdraw` Can Drain All Funds in Shelter
Anyone who can call `withdraw` to withdraw their own funds can call it repeatedly to withdraw the funds of others. `withdraw` should only succeed if the user hasn't withdrawn the token already.
The shelter can be used for users to withdraw funds in the event of an emergency. The `withdraw` function allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However, withdraw does not check if a user has already withdrawn their tokens. Thus a user that can withdraw tokens, can call withdraw repeatedly to steal the tokens of others.

[H-07] Shelter `claimed` mapping is set with `_to` address and not `msg.sender`
Any user can `withdraw` all the funds from the shelter. This is done by calling withdraw repeatedly until all funds are drained. You only need to have a small share.
Even if the `claimed` mapping was checked, there would still be a vulnerability. This is because the `claimed` mapping is updated with the `_to` address, not the msg.sender address.

[M-01] Deposits after the grace period should not be allowed
The function `donate` in Shelter shouldn't allow new deposits after the grace period ends, when the claim period begins.Otherwise, it will be possible to increase `savedTokens[_token]`, and thus new user claim amounts will increase after some users might already have withdrawn their shares.

[M-07] Fee-on-transfer token donations in Shelter break withdrawals
The `Sheler.donate` function `transferFroms` `_amount` and adds the entire `_amount` to `savedTokens[_token]`.But the actual received token amount from the transfer can be less for fee-on-transfer tokens.
The last person to withdraw will not be able to as `withdraw` uses a share computation for the entire `savedTokens[_token]` amount.The calculated `amount` will then be higher than the actual contract balance.

[M-08] Donated Tokens Cannot Be Recovered If A Shelter Is Deactivated
The shelter mechanism can be activated and deactivated on a target LP token. The owner of the ConvexStakingWrapper.sol contract can initiate the shelter whereby LP tokens are sent to the Shelter.sol contract. However, if the owner decides to deactivate the shelter before the grace period has passed, all LP tokens are transferred back to the ConvexStakingWrapper.sol contract. Donated tokens are also sent back to the contract. As a result, these tokens do not actually belong to any user and will effectively be lost in the contract.",5.0,"pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IShelter } from ""./interfaces/IShelter.sol"";
import { IShelterClient } from ""./interfaces/IShelterClient.sol"";

contract Shelter is IShelter {
    using SafeERC20 for IERC20;

    IShelterClient public immutable client;

    uint256 public constant GRACE_PERIOD = 1 weeks;

    mapping(IERC20 => mapping(address => bool)) public override claimed;

    mapping(IERC20 => uint256) public activated;

    mapping(IERC20 => uint256) public savedTokens;

    modifier onlyClient {
        require(msg.sender == address(client), ""!client"");
        _;
    }

    constructor(IShelterClient _client){
        client = _client;
    }

    function donate(IERC20 _token, uint256 _amount) external {
        require(activated[_token] != 0, ""!activated"");
        savedTokens[_token] += _amount;
        _token.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function activate(IERC20 _token) external override onlyClient {
        activated[_token] = block.timestamp;
        savedTokens[_token] = _token.balanceOf(address(this));
        emit ShelterActivated(_token);
    }

    function deactivate(IERC20 _token) external override onlyClient {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, ""too late"");
        activated[_token] = 0;
        savedTokens[_token] = 0;
        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));
        emit ShelterDeactivated(_token);
    }

    function withdraw(IERC20 _token, address _to) external override {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, ""shelter not activated"");
        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);
        claimed[_token][_to] = true;
        emit ExitShelter(_token, msg.sender, _to, amount);
        _token.safeTransfer(_to, amount);
    }
}",504.0,2,3,"The given solidity code of smart contract has the following vulnerabilities:

1. **Reentrancy Vulnerability**: The `withdraw` function calls `safeTransfer` which can lead to a reentrancy attack. An attacker can call `withdraw` multiple times in a single transaction, each time transferring a small amount of tokens, thus bypassing the `claimed` mapping and causing the contract to lose funds.

2. **Front Running Vulnerability**: The `activate` and `deactivate` functions have a grace period of 1 week. However, the `withdraw` function does not check if the shelter has been deactivated before allowing the user to withdraw tokens. An attacker can call `deactivate` and then immediately call `withdraw` to steal the tokens.

3. **Unprotected Ether**: The contract does not have a `fallback` function, which means that if the contract receives ether without a valid function call, it will revert. However, if the contract receives ether in a loop (e.g., through a reentrancy attack), it will continue to execute the `fallback` function, leading to a denial-of-service (DoS) attack.

4. **Missing Input Validation**: The `donate` function does not validate the input `amount` to ensure it is a positive value. This could lead to a denial-of-service (DoS) attack if the contract receives a large amount of invalid input.

5. **Lack of Access Control**: The contract does not have proper access control. The `onlyClient` modifier is used in the `activate` and `deactivate` functions, but it does not prevent the client from calling these functions multiple times in a single transaction, leading to potential reentrancy attacks.

6. **Missing Error Handling**: The contract does not handle errors properly. For example, if the `activate` function is called with a token that is not activated, it will revert. However, if the `deactivate` function is called with a token that is not activated, it will not revert and will instead set the `activated` mapping to 0.

7. **Use of Unchecked External Calls**: The `client.shareOf` and `client.totalShare` functions are called without checking their return values. If these functions revert, the contract will also revert. However, if these functions return incorrect values, the contract may behave unexpectedly.

8. **Missing Event Emission**: The contract does not emit events for all functions. For example, the `donate` function does not emit an event when tokens are donated. This can make it difficult to track the activity of the contract.

9. **Use of Unchecked Mapping Access**: The contract uses mappings to store data, but it does not check if the mappings are accessed correctly. For example, the `withdraw` function accesses the `claimed` mapping without checking if the mapping is accessed correctly.

10. **Missing Contract Upgradeability**: The contract does not have a mechanism for upgrading the contract. If the contract needs to be upgraded, the new contract will need to be deployed and the old contract will need to be replaced, which can be a complex and time-consuming process.

These vulnerabilities can be addressed by following best practices for smart contract development, such as using secure coding practices, implementing proper access control, and handling errors properly. Additionally, the contract should be thoroughly tested and audited to ensure that it is secure and functional.  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```  ```","### **Output**

---

**[H-03] Repeated Calls to `Shelter.withdraw` Can Drain All Funds in Shelter**

**Report Description**:  
The `withdraw` function in the `Shelter` contract allows users to withdraw their deposited tokens. However, it does not check if a user has already withdrawn their tokens. This oversight enables a malicious user to repeatedly call `withdraw` and drain the funds of others, leading to a significant loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability""**.

**Validation**:  
**Partially Correct**. The response identifies the reentrancy vulnerability in the `withdraw` function, which is related to the issue of repeated withdrawals. However, it does not explicitly address the lack of a check to prevent users from withdrawing more than their deposited amount. The core issue is partially covered but misses critical details about the specific exploit mechanism.

---

**[H-07] Shelter `claimed` mapping is set with `_to` address and not `msg.sender`**

**Report Description**:  
The `claimed` mapping in the `Shelter` contract is updated with the `_to` address instead of the `msg.sender` address. This allows any user to withdraw funds repeatedly, even if the `claimed` mapping is checked, because the mapping is not tied to the caller's address. This vulnerability can lead to the complete draining of funds from the shelter.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response does not address this issue at all. The vulnerability is related to incorrect mapping updates, which is not covered in the response list.

---

**[M-01] Deposits after the grace period should not be allowed**

**Report Description**:  
The `donate` function in the `Shelter` contract allows new deposits even after the grace period ends. This can lead to an increase in `savedTokens[_token]`, which affects the withdrawal amounts for users who have already claimed their shares. This inconsistency can result in unfair distribution of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response does not address this issue. The vulnerability is related to improper timing of deposits, which is not covered in the response list.

---

**[M-07] Fee-on-transfer token donations in `Shelter` break withdrawals**

**Report Description**:  
The `Shelter.donate` function adds the entire `_amount` to `savedTokens[_token]` without accounting for fee-on-transfer tokens, where the actual received amount may be less. This discrepancy can cause the last user to withdraw more tokens than are available in the contract, leading to a failed withdrawal.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response does not address this issue. The vulnerability is related to fee-on-transfer tokens, which is not covered in the response list.

---

**[M-08] Donated Tokens Cannot Be Recovered If A Shelter Is Deactivated**

**Report Description**:  
When the shelter is deactivated before the grace period ends, donated tokens are transferred back to the `ConvexStakingWrapper.sol` contract. These tokens do not belong to any user and are effectively lost, as there is no mechanism to recover them.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response does not address this issue. The vulnerability is related to the loss of donated tokens upon deactivation, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-03] Repeated Calls to `Shelter.withdraw` Can Drain All Funds in Shelter**

**Missed Issues from Issue Report**:  
- **[H-07] Shelter `claimed` mapping is set with `_to` address and not `msg.sender`**  
- **[M-01] Deposits after the grace period should not be allowed**  
- **[M-07] Fee-on-transfer token donations in `Shelter` break withdrawals**  
- **[M-08] Donated Tokens Cannot Be Recovered If A Shelter Is Deactivated**

---

### **Conclusion**  
The response list partially addresses one issue ([H-03]) but misses or misidentifies the remaining issues. The response focuses on general vulnerabilities like reentrancy and access control but fails to address specific issues such as incorrect mapping updates, timing of deposits, fee-on-transfer tokens, and token recovery upon deactivation. A more comprehensive review is needed to ensure all vulnerabilities are identified and addressed.",1,3,1,10,"```
None.
```",0.0
ConverxStakingWrapper.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""./external/ConvexInterfaces.sol"";
import ""./interfaces/IConcurRewardClaim.sol"";
import ""./MasterChef.sol"";

contract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    struct RewardType {
        address token;
        address pool;
        uint128 integral;
        uint128 remaining;
    }

    struct Reward {
        uint128 integral;
    }

    //constants/immutables
    address public constant convexBooster =
        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv =
        address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx =
        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);

    uint256 public constant CRV_INDEX = 0;
    uint256 public constant CVX_INDEX = 1;
    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000
    MasterChef public immutable masterChef;

    //convex rewards
    mapping(uint256 => address) public convexPool;
    mapping(uint256 => RewardType[]) public rewards;
    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))
        public userReward;
    mapping(uint256 => mapping(address => uint256)) public registeredRewards;

    //management
    address public treasury;
    IConcurRewardClaim public claimContract;

    struct Deposit {
        uint64 epoch;
        uint192 amount;
    }

    struct WithdrawRequest {
        uint64 epoch;
        uint192 amount;
    }

    mapping(address => uint256) public pids;
    mapping(uint256 => mapping(address => Deposit)) public deposits;
    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;

    event Deposited(address indexed _user, uint256 _amount);
    event Withdrawn(address indexed _user, uint256 _amount);

    constructor(address _treasury, MasterChef _masterChef) {
        treasury = _treasury;
        masterChef = _masterChef;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function changeTreasury(address _treasury) external onlyOwner {
        treasury = _treasury;
    }

    function setRewardPool(address _claimContract) external onlyOwner {
        claimContract = IConcurRewardClaim(_claimContract);
    }

    /// @notice function to bootstrap the reward pool and extra rewards of convex booster
    /// @dev should be able to be called more than once
    /// @param _pid pid of the curve lp. same as convex booster pid
    function addRewards(uint256 _pid) public {
        address mainPool = IRewardStaking(convexBooster)
            .poolInfo(_pid)
            .crvRewards;
        if (rewards[_pid].length == 0) {
            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;
            convexPool[_pid] = mainPool;
            rewards[_pid].push(
                RewardType({
                    token: crv,
                    pool: mainPool,
                    integral: 0,
                    remaining: 0
                })
            );
            rewards[_pid].push(
                RewardType({
                    token: cvx,
                    pool: address(0),
                    integral: 0,
                    remaining: 0
                })
            );
            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1
            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        for (uint256 i = 0; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            address extraToken = IRewardStaking(extraPool).rewardToken();
            if (extraToken == cvx) {
                //no-op for cvx, crv rewards
                rewards[_pid][CVX_INDEX].pool = extraPool;
            } else if (registeredRewards[_pid][extraToken] == 0) {
                //add new token to list
                rewards[_pid].push(
                    RewardType({
                        token: IRewardStaking(extraPool).rewardToken(),
                        pool: extraPool,
                        integral: 0,
                        remaining: 0
                    })
                );
                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1
            }
        }
    }

    function rewardLength(uint256 _pid) external view returns (uint256) {
        return rewards[_pid].length;
    }

    function _getDepositedBalance(uint256 _pid, address _account)
        internal
        view
        virtual
        returns (uint256)
    {
        return deposits[_pid][_account].amount;
    }

    function _getTotalSupply(uint256 _pid)
        internal
        view
        virtual
        returns (uint256)
    {
        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));
    }

    function _calcRewardIntegral(
        uint256 _pid,
        uint256 _index,
        address _account,
        uint256 _balance,
        uint256 _supply
    ) internal {
        RewardType memory reward = rewards[_pid][_index];

        //get difference in balance and remaining rewards
        //getReward is unguarded so we use remaining to keep track of how much was actually claimed
        uint256 bal = IERC20(reward.token).balanceOf(address(this));
        uint256 d_reward = bal - reward.remaining;
        // send 20 % of cvx / crv reward to treasury
        if (reward.token == cvx || reward.token == crv) {
            IERC20(reward.token).transfer(treasury, d_reward / 5);
            d_reward = (d_reward * 4) / 5;
        }
        IERC20(reward.token).transfer(address(claimContract), d_reward);

        if (_supply > 0 && d_reward > 0) {
            reward.integral =
                reward.integral +
                uint128((d_reward * 1e20) / _supply);
        }

        //update user integrals
        uint256 userI = userReward[_pid][_index][_account].integral;
        if (userI < reward.integral) {
            userReward[_pid][_index][_account].integral = reward.integral;
            claimContract.pushReward(
                _account,
                reward.token,
                (_balance * (reward.integral - userI)) / 1e20
            );
        }

        //update remaining reward here since balance could have changed if claiming
        if (bal != reward.remaining) {
            reward.remaining = uint128(bal);
        }

        rewards[_pid][_index] = reward;
    }

    function _checkpoint(uint256 _pid, address _account) internal {
        //if shutdown, no longer checkpoint in case there are problems
        if (paused()) return;

        uint256 supply = _getTotalSupply(_pid);
        uint256 depositedBalance = _getDepositedBalance(_pid, _account);

        IRewardStaking(convexPool[_pid]).getReward(address(this), true);

        uint256 rewardCount = rewards[_pid].length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);
        }
    }

    /// @notice deposit curve lp token
    /// @dev should approve curve lp token to this address before calling this function
    /// @param _pid pid to deposit, uses same pid as convex booster
    /// @param _amount amount to withdraw
    function deposit(uint256 _pid, uint256 _amount)
        external
        whenNotPaused
        nonReentrant
    {
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].epoch = currentEpoch();
        deposits[_pid][msg.sender].amount += uint192(_amount);
        if (_amount > 0) {
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );

            lpToken.safeTransferFrom(msg.sender, address(this), _amount);
            lpToken.safeApprove(convexBooster, _amount);
            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);
            lpToken.safeApprove(convexBooster, 0);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.deposit(msg.sender, pid, _amount);
        }

        emit Deposited(msg.sender, _amount);
    }

    /// @notice withdraw curve lp token
    /// @dev should request withdraw before calling this function
    /// @param _pid pid to withdraw, uses same pid as convex booster
    /// @param _amount amount to withdraw
    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {
        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];
        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), ""wait"");
        require(request.amount >= _amount, ""too much"");
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].amount -= uint192(_amount);
        if (_amount > 0) {
            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );
            lpToken.safeTransfer(msg.sender, _amount);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.withdraw(msg.sender, pid, _amount);
        }
        delete withdrawRequest[_pid][msg.sender];
        //events
        emit Withdrawn(msg.sender, _amount);
    }

    /// @notice epoch for voting cycle
    /// @return returns the epoch in uint64 type
    function currentEpoch() public view returns(uint64) {
        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;
    }

    /// @notice request withdraw to be eligible for withdrawal after currentEpoch
    /// @dev prior withdrawal request will be overwritten
    /// @param _pid pid to withdraw
    /// @param _amount amount to request withdrawal
    function requestWithdraw(uint256 _pid, uint256 _amount) external {
        require(_amount <= uint256(deposits[_pid][msg.sender].amount), ""too much"");
        withdrawRequest[_pid][msg.sender] = WithdrawRequest({
            epoch : currentEpoch(),
            amount : uint192(_amount)
        });
    }
}",2477.0,293.0,"[H-04] ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver
ConvexStakingWrapper is using `masterChef.deposit()`, `masterChef.withdraw()`, and these two functions on masterChef will take `_msgSender()` as the user address, which is actually the address of ConvexStakingWrapper and StakingRewards.

[H-06] ConvexStakingWrapper.sol#`_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution
In the function `_calcRewardIntegral()`

[H-10] `ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing
The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. Conversely, the exitShelter function will deactivate the shelter and transfer all LP tokens back to the ConvexStakingWrapper.sol contract.
Unfortunately, LP tokens aren't restaked in the pool, causing LP tokens to be stuck within the contract. Users will be unable to withdraw their LP tokens as the withdraw function attempts to withdrawAndUnwrap LP tokens from the staking pool. As a result, this function will always revert due to insufficient staked balance. If other users decide to deposit their LP tokens, then these tokens can be swiped by users who have had their LP tokens locked in the contract.

[H-11] `ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools
The ConvexStakingWrapper.sol implementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique _pid. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.
However, the interdependence between pools introduces new problems. Because the original implementation uses the contract's reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguarded getReward function to maximise the profit they are able to generate. By calling getReward on multiple pools with the same reward token (i.e. cvx), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. As crv and cvx are reward tokens by default, it is very likely that someone will want to exploit this issue.

[M-11] ConvexStakingWrapper.enterShelter() May Erroneously Overwrite amountInShelter Leading To Locked Tokens
The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. If this function is called again on the same LP token, the amountInShelter value is overwritten, potentially by the zero amount. As a result its possible that the shelter is put in a state where no users can withdraw from it or only a select few users with a finite number of shares are able to. Once the shelter has passed its grace period, these tokens may forever be locked in the shelter contract.",8.0,"pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""./external/ConvexInterfaces.sol"";
import ""./interfaces/IConcurRewardClaim.sol"";
import ""./MasterChef.sol"";

contract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    struct RewardType {
        address token;
        address pool;
        uint128 integral;
        uint128 remaining;
    }

    struct Reward {
        uint128 integral;
    }

    
    address public constant convexBooster =
        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv =
        address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx =
        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);

    uint256 public constant CRV_INDEX = 0;
    uint256 public constant CVX_INDEX = 1;
    uint256 public constant VOTECYCLE_START = 1645002000; 
    MasterChef public immutable masterChef;

    
    mapping(uint256 => address) public convexPool;
    mapping(uint256 => RewardType[]) public rewards;
    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))
        public userReward;
    mapping(uint256 => mapping(address => uint256)) public registeredRewards;

    
    address public treasury;
    IConcurRewardClaim public claimContract;

    struct Deposit {
        uint64 epoch;
        uint192 amount;
    }

    struct WithdrawRequest {
        uint64 epoch;
        uint192 amount;
    }

    mapping(address => uint256) public pids;
    mapping(uint256 => mapping(address => Deposit)) public deposits;
    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;

    event Deposited(address indexed _user, uint256 _amount);
    event Withdrawn(address indexed _user, uint256 _amount);

    constructor(address _treasury, MasterChef _masterChef) {
        treasury = _treasury;
        masterChef = _masterChef;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function changeTreasury(address _treasury) external onlyOwner {
        treasury = _treasury;
    }

    function setRewardPool(address _claimContract) external onlyOwner {
        claimContract = IConcurRewardClaim(_claimContract);
    }

    
    
    
    function addRewards(uint256 _pid) public {
        address mainPool = IRewardStaking(convexBooster)
            .poolInfo(_pid)
            .crvRewards;
        if (rewards[_pid].length == 0) {
            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;
            convexPool[_pid] = mainPool;
            rewards[_pid].push(
                RewardType({
                    token: crv,
                    pool: mainPool,
                    integral: 0,
                    remaining: 0
                })
            );
            rewards[_pid].push(
                RewardType({
                    token: cvx,
                    pool: address(0),
                    integral: 0,
                    remaining: 0
                })
            );
            registeredRewards[_pid][crv] = CRV_INDEX + 1; 
            registeredRewards[_pid][cvx] = CVX_INDEX + 1; 
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        for (uint256 i = 0; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            address extraToken = IRewardStaking(extraPool).rewardToken();
            if (extraToken == cvx) {
                
                rewards[_pid][CVX_INDEX].pool = extraPool;
            } else if (registeredRewards[_pid][extraToken] == 0) {
                
                rewards[_pid].push(
                    RewardType({
                        token: IRewardStaking(extraPool).rewardToken(),
                        pool: extraPool,
                        integral: 0,
                        remaining: 0
                    })
                );
                registeredRewards[_pid][extraToken] = rewards[_pid].length; 
            }
        }
    }

    function rewardLength(uint256 _pid) external view returns (uint256) {
        return rewards[_pid].length;
    }

    function _getDepositedBalance(uint256 _pid, address _account)
        internal
        view
        virtual
        returns (uint256)
    {
        return deposits[_pid][_account].amount;
    }

    function _getTotalSupply(uint256 _pid)
        internal
        view
        virtual
        returns (uint256)
    {
        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));
    }

    function _calcRewardIntegral(
        uint256 _pid,
        uint256 _index,
        address _account,
        uint256 _balance,
        uint256 _supply
    ) internal {
        RewardType memory reward = rewards[_pid][_index];

        
        
        uint256 bal = IERC20(reward.token).balanceOf(address(this));
        uint256 d_reward = bal - reward.remaining;
        
        if (reward.token == cvx || reward.token == crv) {
            IERC20(reward.token).transfer(treasury, d_reward / 5);
            d_reward = (d_reward * 4) / 5;
        }
        IERC20(reward.token).transfer(address(claimContract), d_reward);

        if (_supply > 0 && d_reward > 0) {
            reward.integral =
                reward.integral +
                uint128((d_reward * 1e20) / _supply);
        }

        
        uint256 userI = userReward[_pid][_index][_account].integral;
        if (userI < reward.integral) {
            userReward[_pid][_index][_account].integral = reward.integral;
            claimContract.pushReward(
                _account,
                reward.token,
                (_balance * (reward.integral - userI)) / 1e20
            );
        }

        
        if (bal != reward.remaining) {
            reward.remaining = uint128(bal);
        }

        rewards[_pid][_index] = reward;
    }

    function _checkpoint(uint256 _pid, address _account) internal {
        
        if (paused()) return;

        uint256 supply = _getTotalSupply(_pid);
        uint256 depositedBalance = _getDepositedBalance(_pid, _account);

        IRewardStaking(convexPool[_pid]).getReward(address(this), true);

        uint256 rewardCount = rewards[_pid].length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);
        }
    }

    
    
    
    
    function deposit(uint256 _pid, uint256 _amount)
        external
        whenNotPaused
        nonReentrant
    {
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].epoch = currentEpoch();
        deposits[_pid][msg.sender].amount += uint192(_amount);
        if (_amount > 0) {
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );

            lpToken.safeTransferFrom(msg.sender, address(this), _amount);
            lpToken.safeApprove(convexBooster, _amount);
            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);
            lpToken.safeApprove(convexBooster, 0);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.deposit(msg.sender, pid, _amount);
        }

        emit Deposited(msg.sender, _amount);
    }

    
    
    
    
    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {
        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];
        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), ""wait"");
        require(request.amount >= _amount, ""too much"");
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].amount -= uint192(_amount);
        if (_amount > 0) {
            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );
            lpToken.safeTransfer(msg.sender, _amount);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.withdraw(msg.sender, pid, _amount);
        }
        delete withdrawRequest[_pid][msg.sender];
        
        emit Withdrawn(msg.sender, _amount);
    }

    
    
    function currentEpoch() public view returns(uint64) {
        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;
    }

    
    
    
    
    function requestWithdraw(uint256 _pid, uint256 _amount) external {
        require(_amount <= uint256(deposits[_pid][msg.sender].amount), ""too much"");
        withdrawRequest[_pid][msg.sender] = WithdrawRequest({
            epoch : currentEpoch(),
            amount : uint192(_amount)
        });
    }
}",2107.0,4,1,"The vulnerabilities in the given solidity code are:

1.  **Unprotected Functions:** The contract has several functions that are not protected with `onlyOwner` or `onlyAdmin` modifier. These functions can be called by any user, which might lead to unintended behavior or loss of funds. For example, the `addRewards` function can be called by any user, which might lead to incorrect reward calculations.

2.  **Incorrect Reward Calculations:** The reward calculations in the `addRewards` function are incorrect. The rewards are calculated as a percentage of the total supply, but the percentage is not correctly calculated. This might lead to incorrect reward amounts being transferred.

3.  **Incorrect Use of SafeMath:** The contract uses `SafeMath` for integer arithmetic, but it does not use it consistently. In some places, it uses `uint128` and `uint192` which are not covered by `SafeMath`. This might lead to incorrect results or overflows.

4.  **Missing Error Handling:** The contract does not handle errors correctly. For example, in the `deposit` function, if the `IConvexDeposits` contract fails to deposit the funds, the function will revert, but it will not handle the error correctly. This might lead to the function being called repeatedly, causing a denial-of-service attack.

5.  **Incorrect Use of `paused` Function:** The `paused` function is used to check if the contract is paused, but it is not used correctly. The function `deposit` and `withdraw` are not protected with `whenNotPaused` modifier, which means they can be called even if the contract is paused. This might lead to incorrect behavior or loss of funds.

6.  **Missing Event Emissions:** The contract does not emit events correctly. For example, in the `deposit` function, the event `Deposited` is not emitted correctly. This might lead to incorrect event handling or logging.

7.  **Incorrect Use of `currentEpoch` Function:** The `currentEpoch` function is used to get the current epoch, but it is not used correctly. The function `requestWithdraw` uses the `currentEpoch` function to get the current epoch, but it does not check if the epoch is correct. This might lead to incorrect behavior or loss of funds.

8.  **Missing Input Validation:** The contract does not validate the input correctly. For example, in the `deposit` function, the input `_amount` is not validated correctly. This might lead to incorrect behavior or loss of funds.

9.  **Incorrect Use of `withdrawRequest` Mapping:** The `withdrawRequest` mapping is used to store the withdraw request, but it is not used correctly. The function `withdraw` uses the `withdrawRequest` mapping to get the withdraw request, but it does not check if the request is correct. This might lead to incorrect behavior or loss of funds.

10. **Missing Security Checks:** The contract does not perform security checks correctly. For example, in the `deposit` function, the contract does not check if the user has already deposited the funds. This might lead to incorrect behavior or loss of funds.

These vulnerabilities can be addressed by reviewing the contract code, identifying the issues, and implementing the necessary fixes. It is recommended to use a code review tool or a security auditor to identify and fix the vulnerabilities. Additionally, it is recommended to use a secure coding practice, such as using `SafeMath` consistently, handling errors correctly, and validating input correctly.   ```python
# Example of how to fix the vulnerabilities

# Fix 1: Protect functions with `onlyOwner` modifier
function addRewards(uint256 _pid) public onlyOwner {
    //...
}

# Fix 2: Correct reward calculations
function _calcRewardIntegral(
    uint256 _pid,
    uint256 _index,
    address _account,
    uint256 _balance,
    uint256 _supply
) internal {
    //...
    reward.integral = uint128((d_reward * 1e20) / _supply);
    //...
}

# Fix 3: Use `SafeMath` consistently
function _getDepositedBalance(uint256 _pid, address _account)
    internal
    view
    virtual
    returns (uint256)
{
    //...
    return deposits[_pid][_account].amount;
}

# Fix 4: Handle errors correctly
function deposit(uint256 _pid, uint256 _amount) external whenNotPaused nonReentrant {
    //...
    try IConvexDeposits(convexBooster).deposit(_pid, _amount, true) {
        //...
    } catch {
        // Handle the error correctly
    }
}

# Fix 5: Protect `deposit` and `withdraw` functions with `whenNotPaused` modifier
function deposit(uint256 _pid, uint256 _amount","### **[H-04] ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver**

**Report Description**:  
The `ConvexStakingWrapper` contract uses `masterChef.deposit()` and `masterChef.withdraw()`, which take `_msgSender()` as the user address. However, `_msgSender()` returns the address of `ConvexStakingWrapper` and `StakingRewards`, not the actual user. This misimplementation causes rewards to be sent to the wrong receiver, leading to incorrect reward distribution and potential loss of funds for users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the incorrect use of `_msgSender()` in the context of reward distribution, which is not covered in the response list.

---

### **[H-06] ConvexStakingWrapper.sol#`_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution**

**Report Description**:  
The `_calcRewardIntegral()` function in `ConvexStakingWrapper.sol` has a flawed implementation that can disrupt the calculation and distribution of rewards. This could lead to incorrect reward amounts being distributed to users, potentially causing financial losses or unfair distribution of rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the incorrect implementation of reward calculations, which is not covered in the response list.

---

### **[H-10] `ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing**

**Report Description**:  
The `exitShelter()` function in `ConvexStakingWrapper.sol` does not restake LP tokens back into the pool after transferring them from the shelter contract. This causes LP tokens to be stuck in the contract, preventing users from withdrawing their funds. If other users deposit LP tokens, these tokens can be swiped by users whose tokens are locked, leading to potential loss of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the incorrect handling of LP tokens in the shelter mechanism, which is not covered in the response list.

---

### **[H-11] `ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools**

**Report Description**:  
The `_calcRewardIntegral()` function in `ConvexStakingWrapper.sol` can be manipulated by malicious users to siphon rewards from other pools. By calling `getReward` on multiple pools with the same reward token (e.g., `cvx`), users can maximize their profits at the expense of other users, leading to a loss of rewards for legitimate users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the manipulation of reward calculations across multiple pools, which is not covered in the response list.

---

### **[M-11] ConvexStakingWrapper.enterShelter() May Erroneously Overwrite `amountInShelter` Leading To Locked Tokens**

**Report Description**:  
The `enterShelter()` function in `ConvexStakingWrapper.sol` overwrites the `amountInShelter` value when called multiple times on the same LP token. This can lead to a state where the shelter is activated with incorrect or zero amounts, potentially locking tokens in the shelter contract permanently and preventing users from withdrawing their funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the incorrect handling of `amountInShelter` in the shelter mechanism, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-04] ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver**  
- **[H-06] ConvexStakingWrapper.sol#`_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution**  
- **[H-10] `ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing**  
- **[H-11] `ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools**  
- **[M-11] ConvexStakingWrapper.enterShelter() May Erroneously Overwrite `amountInShelter` Leading To Locked Tokens**

---

### **Conclusion**  
The response list does not address any of the issues in the provided issue report. The issues are specific to the `ConvexStakingWrapper` contract and its interactions with the `masterChef`, `StakingRewards`, and shelter mechanisms. The response list focuses on general vulnerabilities such as unprotected functions, incorrect reward calculations, and missing error handling, which do not align with the specific issues identified in the report. A thorough review of the `ConvexStakingWrapper` contract and its related functions is necessary to address these vulnerabilities.",0,2,3,14,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**.

### Explanation:
- The list of **true positives** is empty (`None`), meaning there are no relevant items in the ranked list of predictions.
- Since there are no true positives, the precision at any rank is undefined, and the **Average Precision (AP)** is **0.0** by definition."
StakingRewards.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./MasterChef.sol"";

contract StakingRewards is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    MasterChef public immutable masterChef;

    /* ========== STATE VARIABLES ========== */

    IERC20 public rewardsToken;
    IERC20 public stakingToken;
    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public rewardsDuration = 7 days;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;

    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    address public rewardsDistribution;

    /* ========== CONSTRUCTOR ========== */

    constructor(
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken,
        MasterChef _masterChef
    ) {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
        masterChef = _masterChef;
    }

    /* ========== VIEWS ========== */

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored +
            (((lastTimeRewardApplicable() - lastUpdateTime) *
                rewardRate *
                1e18) / _totalSupply);
    }

    function earned(address account) public view returns (uint256) {
        return
            (_balances[account] *
                (rewardPerToken() - userRewardPerTokenPaid[account])) /
            1e18 +
            rewards[account];
    }

    function getRewardForDuration() external view returns (uint256) {
        return rewardRate * rewardsDuration;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function stake(uint256 amount)
        external
        nonReentrant
        whenNotPaused
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot stake 0"");
        _totalSupply += amount;
        _balances[msg.sender] += amount;
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.deposit(msg.sender, pid, amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount)
        public
        nonReentrant
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot withdraw 0"");
        _totalSupply -= amount;
        _balances[msg.sender] -= amount;
        stakingToken.safeTransfer(msg.sender, amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.withdraw(msg.sender, pid, amount);
        emit Withdrawn(msg.sender, amount);
    }

    function getReward() public nonReentrant updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function exit() external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function notifyRewardAmount(uint256 reward)
        external
        updateReward(address(0))
    {
        require(
            msg.sender == rewardsDistribution,
            ""Caller is not RewardsDistribution contract""
        );

        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint256 balance = rewardsToken.balanceOf(address(this));
        require(
            rewardRate <= balance / rewardsDuration,
            ""Provided reward too high""
        );

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address tokenAddress, uint256 tokenAmount)
        external
        onlyOwner
    {
        require(
            tokenAddress != address(stakingToken),
            ""Cannot withdraw the staking token""
        );
        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }

    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }

    function setRewardsDistribution(address _rewardsDistribution)
        external
        onlyOwner
    {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDistribution = _rewardsDistribution;
        emit RewardsDistributionUpdated(rewardsDistribution);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    /* ========== EVENTS ========== */

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event RewardsDistributionUpdated(address indexed newDistribution);
    event Recovered(address token, uint256 amount);
}",1501.0,220.0,"[H-04] StakingRewards Wrong implementation will send concur rewards to the wrong receiver
StakingRewards is using `masterChef.deposit()`, `masterChef.withdraw()`, and these two functions on masterChef will take `_msgSender()` as the user address, which is actually the address of ConvexStakingWrapper and StakingRewards.

[M-06] StakingRewards.sol `recoverERC20()` can be used as a backdoor by the owner to retrieve `rewardsToken`
Users can lose all the rewards to the malicious/compromised owner.

[M-09] StakingRewards.sol#`notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards
In the current implementation, the contract only checks if balanceOf `rewardsToken` is greater than or equal to the future rewards.
However, under normal circumstances, since users can not withdraw all their rewards in time, the balance in the contract contains rewards that belong to the users but have not been withdrawn yet. This means the current checks can not be sufficient enough to make sure the contract has enough amount of rewardsToken.
As a result, if the `rewardsDistribution` mistakenly `notifyRewardAmount` with a larger amount, the contract may end up in a wrong state that makes some users unable to claim their rewards.

[M-13] `StakingRewards.recoverERC20` allows owner to rug the `rewardsToken`
StakingRewards.recoverERC20 rightfully checks against the stakingToken being sweeped away.However, there's no check against the rewardsToken which over time will sit in this contract.
This is the case of an admin privilege, which allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors.
Calling `StakingRewards.recoverERC20(rewardsToken, rewardsToken.balanceOf(this))` enables the owner to sweep the token.",4.0,"pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./MasterChef.sol"";

contract StakingRewards is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    MasterChef public immutable masterChef;

    

    IERC20 public rewardsToken;
    IERC20 public stakingToken;
    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public rewardsDuration = 7 days;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;

    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    address public rewardsDistribution;

    

    constructor(
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken,
        MasterChef _masterChef
    ) {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
        masterChef = _masterChef;
    }

    

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored +
            (((lastTimeRewardApplicable() - lastUpdateTime) *
                rewardRate *
                1e18) / _totalSupply);
    }

    function earned(address account) public view returns (uint256) {
        return
            (_balances[account] *
                (rewardPerToken() - userRewardPerTokenPaid[account])) /
            1e18 +
            rewards[account];
    }

    function getRewardForDuration() external view returns (uint256) {
        return rewardRate * rewardsDuration;
    }

    

    function stake(uint256 amount)
        external
        nonReentrant
        whenNotPaused
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot stake 0"");
        _totalSupply += amount;
        _balances[msg.sender] += amount;
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.deposit(msg.sender, pid, amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount)
        public
        nonReentrant
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot withdraw 0"");
        _totalSupply -= amount;
        _balances[msg.sender] -= amount;
        stakingToken.safeTransfer(msg.sender, amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.withdraw(msg.sender, pid, amount);
        emit Withdrawn(msg.sender, amount);
    }

    function getReward() public nonReentrant updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function exit() external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    

    function notifyRewardAmount(uint256 reward)
        external
        updateReward(address(0))
    {
        require(
            msg.sender == rewardsDistribution,
            ""Caller is not RewardsDistribution contract""
        );

        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }

        
        
        
        
        uint256 balance = rewardsToken.balanceOf(address(this));
        require(
            rewardRate <= balance / rewardsDuration,
            ""Provided reward too high""
        );

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }

    
    function recoverERC20(address tokenAddress, uint256 tokenAmount)
        external
        onlyOwner
    {
        require(
            tokenAddress != address(stakingToken),
            ""Cannot withdraw the staking token""
        );
        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }

    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }

    function setRewardsDistribution(address _rewardsDistribution)
        external
        onlyOwner
    {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDistribution = _rewardsDistribution;
        emit RewardsDistributionUpdated(rewardsDistribution);
    }

    

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event RewardsDistributionUpdated(address indexed newDistribution);
    event Recovered(address token, uint256 amount);
}",1358.0,1,3,"The code has the following vulnerabilities:

1.  **Reentrancy vulnerability**: The `stake` and `withdraw` functions modify the contract's state and call external functions (e.g., `masterChef.deposit` and `masterChef.withdraw`). If an attacker reenters the contract during these operations, they can cause the contract to malfunction or perform unintended actions. This can be mitigated by using a reentrancy guard, which is already implemented in the contract.

2.  **Timestamp manipulation**: The `notifyRewardAmount` function checks if the current block timestamp is greater than or equal to the `periodFinish` timestamp. However, an attacker can manipulate the timestamp by submitting a transaction with a forged timestamp, potentially causing the contract to malfunction or perform unintended actions.

3.  **Unvalidated function calls**: The contract calls external functions (e.g., `masterChef.deposit` and `masterChef.withdraw`) without validating their return values. If these functions fail or return incorrect values, the contract may malfunction or perform unintended actions.

4.  **Missing error handling**: The contract does not handle errors that may occur during external function calls (e.g., `masterChef.deposit` and `masterChef.withdraw`). If these functions fail, the contract may malfunction or perform unintended actions.

5.  **Potential overflow**: The `rewardRate` variable is calculated as `reward / rewardsDuration`. If the `reward` value is very large, it may cause an overflow when dividing by `rewardsDuration`, potentially leading to incorrect results.

6.  **Unvalidated address**: The `notifyRewardAmount` function checks if the caller is the `rewardsDistribution` contract, but it does not validate the address. If an attacker provides a fake address, the contract may malfunction or perform unintended actions.

7.  **Missing input validation**: The contract does not validate the inputs to the `stake` and `withdraw` functions. If an attacker provides invalid inputs, the contract may malfunction or perform unintended actions.

8.  **Potential underflow**: The `totalSupply` variable is updated in the `stake` and `withdraw` functions. If the new `totalSupply` value is less than the current `totalSupply` value, it may cause an underflow, potentially leading to incorrect results.

9.  **Unvalidated token balance**: The `notifyRewardAmount` function checks if the `rewardsToken` balance is sufficient to cover the reward. However, it does not validate the balance, which may lead to incorrect results.

10. **Missing event emission**: The contract does not emit events for certain actions (e.g., `recoverERC20` and `setRewardsDuration`). This may make it difficult to track the contract's activities and detect potential issues.

To address these vulnerabilities, you should:

*   Implement additional validation and error handling mechanisms to prevent reentrancy, timestamp manipulation, and other potential issues.
*   Validate the return values of external function calls to ensure they are correct and consistent with the contract's expectations.
*   Handle errors that may occur during external function calls to prevent the contract from malfunctioning or performing unintended actions.
*   Consider using a more robust reentrancy guard or other security mechanisms to prevent reentrancy attacks.
*   Validate the inputs to the `stake` and `withdraw` functions to ensure they are correct and consistent with the contract's expectations.
*   Consider using a more robust validation mechanism to prevent potential overflows and underflows.
*   Validate the `rewardsToken` balance to ensure it is sufficient to cover the reward.
*   Emit events for all actions to facilitate tracking and detection of potential issues.<|eot_id|>","### **Summary of Matches and Gaps**

---

#### **[H-04] StakingRewards Wrong implementation will send concur rewards to the wrong receiver**

**Report Description**:  
The `StakingRewards` contract uses `masterChef.deposit()` and `masterChef.withdraw()`, which take `_msgSender()` as the user address. However, `_msgSender()` returns the address of `ConvexStakingWrapper` and `StakingRewards` instead of the actual user. This misimplementation could result in rewards being sent to the wrong receiver.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the incorrect use of `_msgSender()` in the context of `masterChef` interactions, which is not mentioned in the response list.

---

#### **[M-06] StakingRewards.sol `recoverERC20()` can be used as a backdoor by the owner to retrieve `rewardsToken`**

**Report Description**:  
The `recoverERC20()` function in `StakingRewards.sol` allows the owner to retrieve `rewardsToken`. This can be exploited by a malicious or compromised owner to steal user rewards, leading to a loss of funds for users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `recoverERC20()` being used as a backdoor to retrieve `rewardsToken`. This is a critical oversight, as it directly impacts user funds.

---

#### **[M-09] StakingRewards.sol#`notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards**

**Report Description**:  
The `notifyRewardAmount()` function checks if the balance of `rewardsToken` is greater than or equal to the future rewards. However, it does not account for rewards that belong to users but have not yet been withdrawn. If `rewardsDistribution` mistakenly calls `notifyRewardAmount()` with a larger amount, the contract may enter a state where some users cannot claim their rewards.

**Match in Response List**:  
Matches with the issue titled **""Unvalidated token balance""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unvalidated token balance but does not fully address the specific problem of improper reward balance checks in `notifyRewardAmount()`. The response misses the critical detail that the contract does not account for unclaimed user rewards.

---

#### **[M-13] `StakingRewards.recoverERC20` allows owner to rug the `rewardsToken`**

**Report Description**:  
The `recoverERC20` function in `StakingRewards` checks against the `stakingToken` being swept away but does not check against the `rewardsToken`. This allows the owner to sweep the `rewardsToken`, potentially rugging depositors.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the lack of checks on `rewardsToken` in `recoverERC20`, which is not mentioned in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-09] StakingRewards.sol#`notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards**

**Missed Issues from Issue Report**:  
- **[H-04] StakingRewards Wrong implementation will send concur rewards to the wrong receiver**  
- **[M-06] StakingRewards.sol `recoverERC20()` can be used as a backdoor by the owner to retrieve `rewardsToken`**  
- **[M-13] `StakingRewards.recoverERC20` allows owner to rug the `rewardsToken`**

---

### **Conclusion**  
The response list fails to address several critical issues in the `StakingRewards` contract, particularly those related to improper reward distribution, owner privileges, and misimplementations. While it identifies some general vulnerabilities, it misses the specific risks and impacts outlined in the issue report. Additional focus on these specific issues is necessary to ensure the contract's security and functionality.",3,1,0,8,"```
None.
```",0.0
USDMPegRecovery.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { ICurveMetaPool } from ""./external/CurveInterfaces.sol"";

contract USDMPegRecovery is Ownable {

    using SafeERC20 for IERC20; 

    IERC20 public immutable usdm;

    IERC20 public immutable pool3;

    ICurveMetaPool public immutable usdm3crv;

    address public immutable kpiOracle;

    uint256 public step;

    uint256 public startLiquidity;

    struct Liquidity {
        uint128 usdm;
        uint128 pool3;
    }

    event Deposit(address indexed depositor, Liquidity deposits);

    event Withdraw(address indexed withdrawer, Liquidity withdrawals);

    Liquidity public totalLiquidity;

    mapping(address => Liquidity) public userLiquidity;

    mapping(address => bool) public isGuardian;

    bool public unlockable;

    modifier onlyGuardian() {
        require(isGuardian[msg.sender], ""!guardian"");
        _;
    }

    constructor(
        uint256 _startLiquidity,
        address _kpiOracle
    ) Ownable() {
        startLiquidity = _startLiquidity;
        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);
        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);
        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);
        step = 250000e18;
        kpiOracle = _kpiOracle;
    }

    function addGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = true;
    }

    function removeGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = false;
    }

    function enableUnlock() external {
        require(msg.sender == kpiOracle, ""!oracle"");
        unlockable = true;
    }

    function provide(uint256 _minimumLP) external onlyGuardian {
        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
        // truncate amounts under step
        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;
        // match usdm : pool3 = 1 : 1
        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
        usdm.approve(address(usdm3crv), addingLiquidity);
        pool3.approve(address(usdm3crv), addingLiquidity);
        usdm3crv.add_liquidity(amounts, _minimumLP);
    }

    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {
        uint256 removingLiquidity = _steps * step;
        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];
        usdm3crv.remove_liquidity(_burningLPs, amounts);
    }

    function deposit(Liquidity calldata _deposits) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_deposits.usdm > 0) {
            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));
            total.usdm += _deposits.usdm;
            user.usdm += _deposits.usdm;
        }

        if(_deposits.pool3 > 0) {
            require(totalLiquidity.usdm > 4000000e18, ""usdm low"");
            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));
            total.pool3 += _deposits.pool3;
            user.pool3 += _deposits.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Deposit(msg.sender, _deposits);
    }

    function withdraw(Liquidity calldata _withdrawal) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_withdrawal.usdm > 0) {
            require(unlockable, ""!unlock usdm"");
            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));
            total.usdm -= _withdrawal.usdm;
            user.usdm -= _withdrawal.usdm;
        }

        if(_withdrawal.pool3 > 0) {
            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));
            total.pool3 -= _withdrawal.pool3;
            user.pool3 -= _withdrawal.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Withdraw(msg.sender, _withdrawal);
    }
}",1156.0,129.0,"[H-05] USDMPegRecovery Risk of fund locked, due to discrepancy between curveLP token value against internal contract math
In USDMPegRecovery `deposit` and `withdraw` allow for direct deposits of a specific token (3crv or usdm).
The balances are directly changed and tracked in storage.

[M-03] USDMPegRecovery.sol#`withdraw()` withdraw may often fail
However, because the `withdraw()` function takes funds from the balance of the contract, once the majority of the funds are added to the curve pool via provide(). The withdraw() may often fail due to insufficient funds in the balance.

[M-04] USDMPegRecovery.sol#`provide()` Improper design/implementation make it often unable to add liquidity to the usdm3crv pool
In the current implementation of USDMPegRecovery.sol#`provide()`, `addingLiquidity` is calculated solely based on `usdm` balance (truncate at a step of 250k), and it always uses the same amount of 3pool tokens to add_liquidity with.
Based on other functions of the contract, the balance of usdm can usually be more than the pool3 balance, in that case, usdm3crv.add_liquidity() will fail.

[M-05] USDM locked unless guardian remove liquidity
However, USDM deposits are also locked until guardian remove liquidity because there are no mechanism to remove deposited USDM in `withdraw`.

[M-12] `USDMPegRecovery.provide()` Will Fail If There Is An Excess Of usdm Tokens
The `provide` function does not take a `_steps` argument and will instead calculate `addingLiquidity` by truncating amounts under step. As a result, if there is an excess of usdm such that the truncated amount exceeds the contract's pool3 truncated balance, then the function will revert due to insufficient pool3` collateral.",5.0,"pragma solidity ^0.8.11;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { ICurveMetaPool } from ""./external/CurveInterfaces.sol"";

contract USDMPegRecovery is Ownable {

    using SafeERC20 for IERC20; 

    IERC20 public immutable usdm;

    IERC20 public immutable pool3;

    ICurveMetaPool public immutable usdm3crv;

    address public immutable kpiOracle;

    uint256 public step;

    uint256 public startLiquidity;

    struct Liquidity {
        uint128 usdm;
        uint128 pool3;
    }

    event Deposit(address indexed depositor, Liquidity deposits);

    event Withdraw(address indexed withdrawer, Liquidity withdrawals);

    Liquidity public totalLiquidity;

    mapping(address => Liquidity) public userLiquidity;

    mapping(address => bool) public isGuardian;

    bool public unlockable;

    modifier onlyGuardian() {
        require(isGuardian[msg.sender], ""!guardian"");
        _;
    }

    constructor(
        uint256 _startLiquidity,
        address _kpiOracle
    ) Ownable() {
        startLiquidity = _startLiquidity;
        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);
        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);
        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);
        step = 250000e18;
        kpiOracle = _kpiOracle;
    }

    function addGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = true;
    }

    function removeGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = false;
    }

    function enableUnlock() external {
        require(msg.sender == kpiOracle, ""!oracle"");
        unlockable = true;
    }

    function provide(uint256 _minimumLP) external onlyGuardian {
        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
        
        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;
        
        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
        usdm.approve(address(usdm3crv), addingLiquidity);
        pool3.approve(address(usdm3crv), addingLiquidity);
        usdm3crv.add_liquidity(amounts, _minimumLP);
    }

    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {
        uint256 removingLiquidity = _steps * step;
        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];
        usdm3crv.remove_liquidity(_burningLPs, amounts);
    }

    function deposit(Liquidity calldata _deposits) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_deposits.usdm > 0) {
            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));
            total.usdm += _deposits.usdm;
            user.usdm += _deposits.usdm;
        }

        if(_deposits.pool3 > 0) {
            require(totalLiquidity.usdm > 4000000e18, ""usdm low"");
            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));
            total.pool3 += _deposits.pool3;
            user.pool3 += _deposits.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Deposit(msg.sender, _deposits);
    }

    function withdraw(Liquidity calldata _withdrawal) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_withdrawal.usdm > 0) {
            require(unlockable, ""!unlock usdm"");
            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));
            total.usdm -= _withdrawal.usdm;
            user.usdm -= _withdrawal.usdm;
        }

        if(_withdrawal.pool3 > 0) {
            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));
            total.pool3 -= _withdrawal.pool3;
            user.pool3 -= _withdrawal.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Withdraw(msg.sender, _withdrawal);
    }
}",1129.0,1,4,"The given solidity contract contains several vulnerabilities:

1. **Reentrancy Vulnerability**: The contract is vulnerable to reentrancy attacks. This is because the `deposit` and `withdraw` functions transfer tokens from the user to the contract, and the contract then transfers tokens to the user. However, if the user calls the contract again before the contract has finished executing the current function, the contract will enter an infinite loop of transferring tokens, leading to a denial-of-service (DoS) attack.

2. **Unprotected Function Calls**: The contract has several functions that are not protected by the `onlyGuardian` modifier. These functions include `removeLiquidity` and `provide`. This means that any user can call these functions, potentially leading to unintended behavior.

3. **Insufficient Error Handling**: The contract does not handle errors properly. For example, in the `provide` function, the contract checks if the `usdm` balance is sufficient, but it does not check if the `pool3` balance is sufficient. This could lead to the contract running out of `pool3` tokens.

4. **Lack of Input Validation**: The contract does not validate user inputs properly. For example, in the `deposit` function, the contract checks if the `usdm` balance is sufficient, but it does not check if the `pool3` balance is sufficient.

5. **Unprotected Data**: The contract has several variables that are not protected by the `onlyGuardian` modifier. These variables include `totalLiquidity` and `userLiquidity`. This means that any user can access and modify these variables, potentially leading to unintended behavior.

6. **Use of `safeTransferFrom`**: The contract uses the `safeTransferFrom` function to transfer tokens from the user to the contract. However, this function can be vulnerable to reentrancy attacks if not used properly.

7. **Use of `approve`**: The contract uses the `approve` function to allow the `usdm3crv` contract to spend tokens on behalf of the contract. However, this function can be vulnerable to reentrancy attacks if not used properly.

8. **Use of `add_liquidity` and `remove_liquidity`**: The contract uses the `add_liquidity` and `remove_liquidity` functions to interact with the `usdm3crv` contract. However, these functions can be vulnerable to reentrancy attacks if not used properly.

To fix these vulnerabilities, the contract should be modified to include proper error handling, input validation, and protection of sensitive data and functions. Additionally, the contract should be reviewed and tested to ensure that it is secure and functioning as intended. 

Here are some potential modifications that could be made to the contract:

* Add the `onlyGuardian` modifier to the `removeLiquidity` and `provide` functions to ensure that only authorized users can call these functions.
* Add input validation to the `deposit` and `withdraw` functions to ensure that the user is not attempting to deposit or withdraw an invalid amount of tokens.
* Add error handling to the `provide` function to ensure that the contract does not run out of `pool3` tokens.
* Add protection to the `totalLiquidity` and `userLiquidity` variables to ensure that only authorized users can access and modify these variables.
* Use the `require` function to ensure that the contract has sufficient tokens before attempting to transfer them.
* Use the `revert` function to prevent the contract from continuing to execute if an error occurs. 

These are just some potential modifications that could be made to the contract. The specific modifications that are needed will depend on the specific requirements and constraints of the contract. 

Here is an example of how the `provide` function could be modified to include proper error handling and input validation:

```solidity
function provide(uint256 _minimumLP) external onlyGuardian {
    require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
    
    uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;
    
    require(addingLiquidity <= _minimumLP, ""addingLiquidity too high"");
    
    uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
    usdm.approve(address(usdm3crv), addingLiquidity);
    pool3.approve(address(usdm3crv), addingLiquidity);
    usdm3crv.add_liquidity(amounts, _minimumLP);
}
```

This modified version of the `provide` function includes a `require` statement to ensure that the contract has sufficient tokens before attempting to transfer them. It also includes a `require` statement to ensure that the `addingLiquidity` is not too high.","### **Comparison of Issue Report and Response List**

---

#### **[H-05] USDMPegRecovery Risk of fund locked, due to discrepancy between curveLP token value against internal contract math**

**Report Description**:  
The `deposit` and `withdraw` functions in `USDMPegRecovery` allow direct deposits of specific tokens (3crv or usdm). The balances are directly changed and tracked in storage. However, there is a risk of funds being locked due to discrepancies between the curveLP token value and the internal contract math. This could lead to users being unable to withdraw their funds, especially if the contract's internal calculations do not align with the actual token balances in the curve pool.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of fund locking due to discrepancies between curveLP token values and internal contract math. The response focuses on reentrancy, unprotected function calls, and insufficient error handling, which are unrelated to this issue.

---

#### **[M-03] USDMPegRecovery.sol#`withdraw()` withdraw may often fail**

**Report Description**:  
The `withdraw()` function in `USDMPegRecovery.sol` takes funds from the contract's balance. However, once the majority of the funds are added to the curve pool via `provide()`, the `withdraw()` function may often fail due to insufficient funds in the contract's balance. This could lead to users being unable to withdraw their funds, especially if the contract's balance is depleted.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `withdraw()` failing due to insufficient funds in the contract's balance. The response focuses on reentrancy, unprotected function calls, and insufficient error handling, which are unrelated to this issue.

---

#### **[M-04] USDMPegRecovery.sol#`provide()` Improper design/implementation make it often unable to add liquidity to the usdm3crv pool**

**Report Description**:  
In the current implementation of `USDMPegRecovery.sol#provide()`, `addingLiquidity` is calculated solely based on the `usdm` balance (truncated at a step of 250k), and it always uses the same amount of 3pool tokens to add liquidity. However, the balance of `usdm` can usually be more than the `pool3` balance, causing `usdm3crv.add_liquidity()` to fail. This improper design/implementation often prevents the contract from adding liquidity to the `usdm3crv` pool.

**Match in Response List**:  
**Partially matches** with the issue titled **""Insufficient Error Handling""**.

**Validation**:  
**Partially Correct**. The response identifies insufficient error handling in the `provide` function but does not specifically address the issue of `addingLiquidity` being calculated solely based on the `usdm` balance, leading to failures when the `pool3` balance is insufficient. The response suggests adding error handling to ensure the contract does not run out of `pool3` tokens, which is relevant but does not fully cover the reported issue.

---

#### **[M-05] USDM locked unless guardian remove liquidity**

**Report Description**:  
USDM deposits are locked until the guardian removes liquidity because there is no mechanism to remove deposited USDM in the `withdraw` function. This could lead to users being unable to access their funds unless the guardian intervenes.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of USDM deposits being locked due to the lack of a mechanism to remove deposited USDM in the `withdraw` function. The response focuses on reentrancy, unprotected function calls, and insufficient error handling, which are unrelated to this issue.

---

#### **[M-12] `USDMPegRecovery.provide()` Will Fail If There Is An Excess Of usdm Tokens**

**Report Description**:  
The `provide` function does not take a `_steps` argument and calculates `addingLiquidity` by truncating amounts under `step`. If there is an excess of `usdm` such that the truncated amount exceeds the contract's `pool3` truncated balance, the function will revert due to insufficient `pool3` collateral.

**Match in Response List**:  
**Partially matches** with the issue titled **""Insufficient Error Handling""**.

**Validation**:  
**Partially Correct**. The response identifies insufficient error handling in the `provide` function but does not specifically address the issue of `addingLiquidity` being calculated by truncating amounts under `step`, leading to failures when the `pool3` balance is insufficient. The response suggests adding error handling to ensure the contract does not run out of `pool3` tokens, which is relevant but does not fully cover the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-04] USDMPegRecovery.sol#`provide()` Improper design/implementation make it often unable to add liquidity to the usdm3crv pool**  
- **[M-12] `USDMPegRecovery.provide()` Will Fail If There Is An Excess Of usdm Tokens**

**Missed Issues from Issue Report**:  
- **[H-05] USDMPegRecovery Risk of fund locked, due to discrepancy between curveLP token value against internal contract math**  
- **[M-03] USDMPegRecovery.sol#`withdraw()` withdraw may often fail**  
- **[M-05] USDM locked unless guardian remove liquidity**

---

### **Conclusion**  
The response list partially addresses some issues related to insufficient error handling in the `provide` function but fails to cover the majority of the reported issues, particularly those related to fund locking, `withdraw()` failures, and the lack of a mechanism to remove deposited USDM. The response list focuses on general vulnerabilities like reentrancy and unprotected function calls, which are not directly relevant to the specific issues reported.",2,2,1,13,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. 

Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these precision values is also 0."
,,,,,,,,12,16,,,8,12,8,59,,
