nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,matchList,MAP,Score
LiquidityPool.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    // Gas fee accumulated by token address => executor address
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    // Incentive Pool amount per token address
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    /**
     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.
     * @param toChainId Chain id where funds needs to be transfered
     * @param tokenAddress ERC20 Token address that needs to be transfered
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param amount Amount of token being transfered
     */
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        // Emit (amount + reward amount) in event
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    /**
     * DAI permit and Deposit.
     */
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * EIP2612 and Deposit.
     */
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param toChainId Chain id where funds needs to be transfered
     */
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    /**
     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.
     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.
     * @param initialGas Gas provided initially before any calculations began
     * @param tokenAddress Token address for which calculation needs to be done
     * @param amount Amount of token to be transfered before deducting the fee
     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee
     * @return amountToTransfer Total amount to be transfered after deducting all fees.
     */
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            // Here add some fee to incentive pool also
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        // Fee is represented in basis points * 10 for better accuracy
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4025.0,434.0,"[H-01] Can deposit native token for free and steal funds
The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error.No matter the `amount` chosen, the `SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA, and the low-level calls to EOAs always succeed.Because the safe* version is used, the EOA not returning any data does not revert either.
This allows an attacker to deposit infinite native tokens by not paying anything.The contract will emit the same `Deposit` event as a real `depositNative` call and the attacker receives the native funds on the other chain.

[H-03] Wrong formula when add fee incentivePool can lead to loss of funds.
The `getAmountToTransfer` function of `LiquidityPool` updates `incentivePool[tokenAddress]` by adding some fee to it but the formula is wrong and the value of `incentivePool[tokenAddress]` will be divided by `BASE_DIVISOR (10000000000)` each time. After just a few time, the value of `incentivePool[tokenAddress]` will become zero and that amount of `tokenAddress` token will be locked in contract.

[M-08] Incentive Pool can be drained without rebalancing the pool
`depositErc20()` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.

[M-18] Possible frontrun on `deposits` on LiquidityPool
Rewards are given to a user for depositing either ERC20 tokens or their native token into the LiquidityPool. This reward is used to incentivize users to deposit funds into the liquidity pool when the pool is not in an equilibrium state.
For regular users, this liquidity pool state fluctuates based on the frequency and amount of deposits made to the liquidity pool. If a malicious user can control the state of the liquidity pool before a victim deposits tokens into the liquidity pool, they can gain double rewards.
To gain these double rewards, a malicious user can watch the mempool for transactions that will receive a reward when the deposit occurs. When a malicious user sees that victim deposit, the malicious user can attach a higher fee to their transaction and initiate a deposit. This will allow the malicious user's transaction to front-run before the victim's transaction.",4.0,"pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; 

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; 
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; 

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3573.0,2,2,"Okay, here's a breakdown of potential vulnerabilities in the provided smart contract code, along with explanations and recommendations:

**Vulnerabilities**

1.  **Reentrancy in `withdrawNativeGasFee`:**

    *   **Description:**  The `withdrawNativeGasFee` function sends ETH to the caller using a low-level `call`.  If the recipient is a contract, it can execute arbitrary code upon receiving the ETH. If that code calls back into `withdrawNativeGasFee` before the `gasFeeAccumulated[NATIVE][_msgSender()]` is set to 0, the recipient could withdraw the same fees multiple times.

    *   **Impact:**  Loss of funds from the contract.

    *   **Recommendation:**  Use the ""Checks-Effects-Interactions"" pattern.  Specifically, set `gasFeeAccumulated[NATIVE][_msgSender()] = 0;` *before* making the call to the recipient:

    ```solidity
    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;  // Move this line up

        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }
    ```

2.  **Incomplete Reentrancy Protection in `withdrawErc20GasFee`:**

    *   **Description:** Similar to the `withdrawNativeGasFee` vulnerability, this function is also susceptible to reentrancy.  Although the contract inherits `ReentrancyGuardUpgradeable`, the `withdrawErc20GasFee` function could still be vulnerable if the `safeTransfer` call triggers a callback to this contract, potentially allowing for multiple withdrawals before the state is updated.

    *   **Impact:** Loss of funds from the contract.

    *   **Recommendation:** Apply the `nonReentrant` modifier to prevent recursive calls. While `nonReentrant` is present, it is recommended to double check that the `_gasFeeAccumulated[tokenAddress][_msgSender()] = 0;`  is set before the transfer.
    ```solidity
    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");

        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0; //move this line up

        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }
    ```

3.  **Potential Integer Overflow/Underflow in Fee Calculations:**

    *   **Description:** In the `getAmountToTransfer` function, fee calculations involve multiplication and division.  While Solidity 0.8.0 has built-in overflow/underflow protection, it's still important to be mindful of the order of operations.  If `amount * transferFeePerc` is very large, it *could* potentially lead to an overflow before the division by `BASE_DIVISOR`.  Similarly, `totalGasUsed * tokenGasPrice` could overflow.

    *   **Impact:**  Incorrect fee calculations, potentially leading to loss of funds or unexpected behavior.

    *   **Recommendation:**  Use SafeMath-like operations (even though not strictly necessary in 0.8.0) and carefully consider the order of operations to minimize the risk of large intermediate values.  Specifically, consider using libraries like `SafeCast` to safely convert between `uint256` and smaller types where appropriate to prevent overflows.  Also, add checks on the inputs like `tokenGasPrice` to be within reasonable bounds.

4.  **Lack of Input Validation in `setBaseGas`:**

    *   **Description:** The `setBaseGas` function allows the owner to set the `baseGas` value. There's no validation to ensure that the new `baseGas` value is reasonable.

    *   **Impact:** Setting a very high `baseGas` value could significantly increase the gas cost of transactions, making the contract unusable. Setting a very low value could lead to transaction failures.

    *   **Recommendation:** Add a check to ensure that the new `baseGas` value is within a reasonable range.

    ```solidity
    function setBaseGas(uint128 gas) external onlyOwner {
        require(gas >= 10000 && gas <= 100000, ""Base gas out of range""); // Example range
        baseGas = gas;
    }
    ```

5.  **Division by Zero Risk in `getTransferFee`:**

    *   **Description:** While the code includes a check (`if (denominator == 0)`), the function returns 0 if the denominator is 0.  This might *seem* safe, but it could lead to unexpected behavior in the calling function (`getAmountToTransfer`), which relies on the fee being a reasonable value. A zero fee will result in incorrect calculations.

    *   **Impact:**  Unexpected behavior in `getAmountToTransfer`, potentially leading to incorrect amounts being transferred.

    *   **Recommendation:**  Revert the transaction if the denominator is zero. Returning zero might mask the underlying issue.

    ```solidity
    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;

        uint256 numerator = providedLiquidity * equilibriumFee * maxFee;
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity;

        require(denominator != 0, ""Division by zero""); // Changed from if statement to require

        fee = numerator / denominator;
    }
    ```

6.  **Potential for Griefing in `sendFundsToUser`:**

    *   **Description:** The `sendFundsToUser` function relies on `tokenGasPrice` provided by the caller (executor). If an executor provides a very low `tokenGasPrice`, the `getAmountToTransfer` function will calculate a very low gas fee, resulting in a larger `amountToTransfer` being sent to the user.  However, if the actual gas usage is higher than estimated (due to unforeseen circumstances, changes in gas costs, etc.), the transaction could run out of gas during the `SafeERC20Upgradeable.safeTransfer` or native transfer, reverting *after* the `processedHash` has been set to `true`. This means the funds are effectively locked.

    *   **Impact:** Funds can be locked in the contract.

    *   **Recommendation:**

        *   **Gas Limit:**  Set a reasonable gas limit for the transaction.  This can be done by the caller (executor), but the contract should also enforce a maximum gas limit.
        *   **Minimum Gas Price:**  The contract should enforce a *minimum* `tokenGasPrice` to prevent executors from setting it too low. This minimum could be dynamically adjusted based on network conditions (using an oracle, for example).
        *   **Revert on Low Gas:** Inside the `sendFundsToUser` after `getAmountToTransfer` a check can be performed `require(gasleft() > someSafeThreshold)` so the transaction does not fail.
        *   **Consider Refunding Excess Gas:**  Implement a mechanism to refund excess gas to the caller if the actual gas usage is less than the estimated gas usage. This incentivizes executors to provide accurate gas prices. However, this adds complexity and potential attack vectors (e.g., manipulating gas usage).

7. **Improper Incentive Mechanism:**
    *   **Description:** The incentive mechanism described in the `getRewardAmount` function has issues. Specifically, the code calculates the `rewardAmount` in proportion to the `amount` being deposited only if `currentLiquidity < providedLiquidity`. If the `amount` is greater than or equal to `liquidityDifference` then the `rewardAmount` is set to `incentivePool[tokenAddress]` which seems ok, however the value of `incentivePool[tokenAddress]` is then subtracted from `incentivePool[tokenAddress]` in `depositErc20` function, possibly making it zero. This defeats the whole purpose of the incentive mechanism.
    *   **Impact:** Defeats the purpose of the incentive mechanism.
    *   **Recommendation:** The whole incentive mechanism has to be rethought. Some things to consider:
        *   The comparison `currentLiquidity < providedLiquidity` does not make much sense. `currentLiquidity` will always be less than `providedLiquidity`. What it should be compared to is `targetLiquidity`.
        *   The value `liquidityDifference` is calculated as `providedLiquidity - currentLiquidity`. If the `amount` is greater than or equal to it then the whole `incentivePool` is rewarded. This is not ideal.
        *   The logic of subtracting the reward from `incentivePool` in `depositErc20` function is flawed. If the rewardAmount is equal to `incentivePool[tokenAddress]` then the resulting value will be zero, essentially making the incentive mechanism useless.
        *   Ideally, the `rewardAmount` should be computed based on how much the deposit improves the state of the pool with respect to a target liquidity or liquidity ratio.
8. **Missing Access Control for Critical Parameters:**
    *   **Description:**  The `tokenManager` and `executorManager` addresses are set during initialization and can be changed later by the owner using `setExecutorManager` and the `tokenManager` address is set during initialization only. Changing these addresses can have significant consequences, potentially granting unauthorized control over the liquidity pool.
    *   **Impact:**  Potential for the owner to set malicious or incorrect contract addresses, leading to fund loss or denial of service.
    *   **Recommendation:** Carefully consider whether these addresses should be changeable after initialization. If they must be changeable, implement robust checks to ensure the new addresses point to valid and trusted contracts. Consider using a multi-sig wallet or a more sophisticated governance mechanism to manage these critical parameters. For the `tokenManager`, if it does not need to be updated, remove the setter function to make it immutable after initialization.

9. **Unbounded Loop Risk During Upgrades**
    *   **Description:** As this is an upgradeable contract using OpenZeppelin's upgradeable contracts, there's a potential risk of unbounded loops during upgrades if the storage layout is not carefully managed. If a new version of the contract introduces a large array or mapping without proper initialization, the upgrade process could iterate over a huge number of storage slots, potentially exceeding the gas limit and causing the upgrade to fail.
    *   **Impact:** Failed contract upgrades, potentially bricking the contract.
    *   **Recommendation:** Use the `@openzeppelin/upgrades` plugin to manage contract upgrades. This plugin helps to ensure that storage layouts are compatible between different versions of the contract. Also, when adding new storage variables, consider using lazy initialization patterns to avoid iterating over a large number of storage slots during the upgrade process.

**Additional Considerations:**

*   **Gas Optimization:**  The contract performs several calculations, especially in `getAmountToTransfer` and `getTransferFee`. Consider optimizing these functions for gas efficiency.  Look for opportunities to reduce storage reads/writes and use cheaper arithmetic operations.

*   **Event Logging:**  Ensure that all important state changes are logged via events. This makes it easier to track the contract's behavior and debug issues.

*   **Testing:** Thoroughly test the contract with a variety of inputs and scenarios, including edge cases and boundary conditions. Use fuzzing tools to automatically generate test cases and uncover potential vulnerabilities.

*   **Auditing:**  Have the contract audited by a reputable security firm before deploying it to a production environment.

*   **Centralization of power:** The owner has significant control over the contract. Consider implementing a governance mechanism to distribute control and reduce the risk of malicious behavior by the owner.

By addressing these vulnerabilities and following the recommendations, you can significantly improve the security and reliability of your smart contract. Remember to always prioritize security best practices and conduct thorough testing and auditing before deploying any smart contract to a live environment.","### **Comparison and Evaluation**

---

#### **[H-01] Can deposit native token for free and steal funds**

**Report Description**:  
The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error. The `SafeERC20Upgradeable.safeTransferFrom` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA. This allows an attacker to deposit infinite native tokens without paying anything, leading to fund theft.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability is critical and involves a bypass of the deposit mechanism, allowing attackers to steal funds. This is a significant oversight in the response list.

---

#### **[H-03] Wrong formula when add fee incentivePool can lead to loss of funds**

**Report Description**:  
The `getAmountToTransfer` function in `LiquidityPool` updates `incentivePool[tokenAddress]` using a flawed formula that divides the value by `BASE_DIVISOR` each time. This causes `incentivePool[tokenAddress]` to quickly become zero, locking funds in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The flaw in the formula is a critical vulnerability that leads to fund loss, and it is not covered in the response list.

---

#### **[M-08] Incentive Pool can be drained without rebalancing the pool**

**Report Description**:  
The `depositErc20` function allows an attacker to specify the destination chain as the same as the source chain and the receiver account as the caller account. This enables draining the incentive pool without rebalancing the pool to its equilibrium state.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability allows attackers to drain the incentive pool, which is a significant security concern.

---

#### **[M-18] Possible frontrun on `deposits` on LiquidityPool**

**Report Description**:  
Rewards for depositing tokens into the LiquidityPool can be frontrun by malicious users. By watching the mempool, attackers can attach higher fees to their transactions and frontrun victim deposits, gaining double rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. Frontrunning is a well-known vulnerability in decentralized systems, and the lack of coverage in the response list is a significant gap.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Can deposit native token for free and steal funds**  
- **[H-03] Wrong formula when add fee incentivePool can lead to loss of funds**  
- **[M-08] Incentive Pool can be drained without rebalancing the pool**  
- **[M-18] Possible frontrun on `deposits` on LiquidityPool**

---

### **Conclusion**  
The `response_list` does not adequately address the issues in the `issue` report. Critical vulnerabilities such as fund theft, incorrect fee calculations, incentive pool draining, and frontrunning are entirely missed. The response list focuses on other vulnerabilities (e.g., reentrancy, integer overflow, and access control) but fails to cover the specific issues raised in the report. This indicates a significant gap in the response list's coverage and accuracy.",0,0,4,9,"```
None.
```",0.0,0
LiquidityProviders.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    // LP Fee Distribution
    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated
    mapping(address => uint256) public totalLiquidity; // Include Liquidity only
    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    /**
     * @dev Modifier for checking to validate a NFTId and it's ownership
     * @param _tokenId token id to validate
     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId
     */
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    /**
     * @dev Modifier for checking if msg.sender in liquiditypool
     */
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    /**
     * @dev To be called post initialization, used to set address of NFT Contract
     * @param _lpToken address of lpToken
     */
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    /**
     * Internal method to set LP token contract.
     */
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    /**
     * Public method to set TokenManager contract.
     */
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    /**
     * Internal method to set TokenManager contract.
     */
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    /**
     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract
     * @param _whiteListPeriodManager address of WhiteListPeriodManager
     */
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    /**
     * @dev To be called post initialization, used to set address of LiquidityPool Contract
     * @param _liquidityPool address of LiquidityPool
     */
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    /**
     * @dev Returns price of Base token in terms of LP Shares
     * @param _baseToken address of baseToken
     * @return Price of Base token in terms of LP Shares
     */
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    /**
     * @dev Converts shares to token amount
     */

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    /**
     * @dev Returns the fee accumulated on a given NFT
     * @param _nftId Id of NFT
     * @return accumulated fee
     */
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    /**
     * @dev Records fee being added to total reserve
     * @param _token Address of Token for which LP fee is being added
     * @param _amount Amount being added
     */
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    /**
     * @dev Internal function to add liquidity to a new NFT
     */
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    /**
     * @dev Function to mint a new NFT for a user, add native liquidity and store the
     *      record in the newly minted NFT
     */
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    /**
     * @dev Function to mint a new NFT for a user, add token liquidity and store the
     *      record in the newly minted NFT
     * @param _token Address of token for which liquidity is to be added
     * @param _amount Amount of liquidity added
     */
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    /**
     * @dev Internal helper function to increase liquidity in a given NFT
     */
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        // Adding liquidity in the pool for the first time
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        // Increase the current liquidity
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    /**
     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT
     * @param _nftId ID of NFT for updating the balances
     * @param _amount Token amount to be added
     */
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    /**
     * @dev Function to allow LPs to add native token liquidity to existing NFT
     */
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    /**
     * @dev Function to allow LPs to remove their liquidity from an existing NFT
     *      Also automatically redeems any earned fee
     */
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        // Claculate how much shares represent input amount
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        // Handle round off errors to avoid dust lp token in contract
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    /**
     * @dev Function to allow LPs to claim the fee earned on their NFT
     * @param _nftId ID of NFT where liquidity is recorded
     */
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    /**
     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT
     */
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4555.0,475.0,"[H-02] LiquidityProviders.sol The share price of the LP can be manipulated and making future liquidityProviders unable to `removeLiquidity()`
The share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for `sharesToTokenAmount(totalNFTShares, _tokenAddress)` to overflow in `removeLiquidity()` and therefore freeze users' funds.

[M-01] Unsupported tokens cannot be withdrawnIn the function `addTokenLiquidity`, supported tokens can be turned off again.Users won't be able to withdraw their liquidity anymore because of this check in the function `removeLiquidity`.

[M-11] LiquidityProviders: Setting new liquidity pool will break contract
Owners can change the `liquidityPool` variable any time with the `setLiquidityPool` function.If a liquidity pool was already set and users added liquidity with `addTokenLiquidity`, the tokens are directly transferred to the liquidity pool and not kept in the `LiquidityProviders` contract.Changing the `liquidityPool` to a different contract will make it impossible for the users to withdraw their liquidity using `removeLiquidity` because the tokens are still in the old `liquidityPool` and cannot be retrieved.

[M-12] LiquidityProviders: Setting new LP token will break contract
Owners can change the `lpToken` variable at any time with the `setLpToken` function.If an LP token was already set and users added liquidity with `addTokenLiquidity` and were minted a `lpToken` NFT, changing the `lpToken` to a different contract will make it impossible for the users to withdraw their liquidity using `removeLiquidity`.
All users will lose their funds.

[M-17] wrong condition checking in price calculation
The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return `BASE_DIVISOR` if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.

[M-19] sharesToTokenAmount: Division by zero
The public `sharesToTokenAmount` function does not check if the denominator `totalSharesMinted[_tokenAddress]` is zero.Neither do the callers of this function. The function will revert.Calling functions like `getFeeAccumulatedOnNft` and `sharesToTokenAmount` from another contract should never revert.

[M-20] Liquidity providers unable to remove liquidity when the pool is in deficit state
In the function `removeLiquidity`, LP token holders can not redeem their tokens when the pool is in the deficit state, i.e. `currentLiquidity << providedLiquidity`. This is due to that LP shares are computed based on providedLiquidity and the actual available pool balance is based on currentLiquidity.",7.0,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    
    mapping(address => uint256) public totalReserve; 
    mapping(address => uint256) public totalLiquidity; 
    mapping(address => uint256) public currentLiquidity; 
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",3709.0,1,6,"Okay, here's an analysis of the smart contract code you provided, focusing on potential vulnerabilities:

**Critical/High Severity**

1.  **Reentrancy in `_transferFromLiquidityPool`:**
    *   **Description:** The `_transferFromLiquidityPool` function calls `liquidityPool.transfer()`. If the `liquidityPool` contract is malicious or has a vulnerability that allows reentrancy, this call can be exploited. An attacker could re-enter the `removeLiquidity` or `claimFee` function during the transfer, potentially draining more tokens than they are entitled to. The use of `ReentrancyGuardUpgradeable` in this contract **does not protect against reentrancy vulnerabilities in external contracts like `liquidityPool`**.
    *   **Location:** `_transferFromLiquidityPool` function.
    *   **Impact:**  Loss of funds, potentially draining the entire liquidity pool.
    *   **Mitigation:**
        *   Implement a pull pattern where the user withdraws the tokens instead of the contract pushing them.
        *   Ensure the `liquidityPool` contract is thoroughly audited and trusted.
        *   Implement reentrancy protection in the `liquidityPool` contract itself.

2.  **Integer Overflow/Underflow in `removeLiquidity`:**

    *   **Description:** In the `removeLiquidity` function, there's unchecked arithmetic: `lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;`
        This is now safe due to Solidity 0.8.0 handling underflows. However, there's still potential for denial of service or unexpected behavior due to the amount `lpSharesToBurn` being close to `totalNFTShares` and the conditional statement `if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR)`.

    *   **Location:** `removeLiquidity` function
    *   **Impact:** Potential rounding errors or unexpected behavior when calculating shares to burn.

    *   **Mitigation:** Ensure the logic handles edge cases where `totalNFTShares` and `lpSharesToBurn` are very close in value.

3.  **Rounding Errors in Share Calculations:**

    *   **Description:** The use of integer division (`/`) throughout the contract, especially in the share calculations (e.g., `(_amount * totalSharesMinted[token]) / totalReserve[token]`, `totalSharesMinted[_baseToken] / totalReserve[_baseToken]`, and `(_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress]`) can lead to significant rounding errors. These errors can accumulate over time, causing discrepancies between the actual token amounts and the calculated share values. This is a common issue in DeFi contracts.
    *   **Location:** `_increaseLiquidity`, `getTokenPriceInLPShares`, `sharesToTokenAmount`, `removeLiquidity` and `claimFee` functions.
    *   **Impact:** Loss of value for liquidity providers, inaccurate fee calculations, and potential arbitrage opportunities.
    *   **Mitigation:**
        *   Use more precise calculations with a higher degree of precision (e.g., using more decimal places).
        *   Consider using a library like ""PRBMath"" (if applicable) for safer and more accurate fixed-point arithmetic.
        *   Carefully analyze the potential error margins and ensure they are within acceptable limits.  Consider adding slippage controls.

4. **Potential Manipulation of `getTokenPriceInLPShares`:**

    *   **Description:** The function `getTokenPriceInLPShares` calculates the price based on `totalSharesMinted[_baseToken] / totalReserve[_baseToken]`. If an attacker can manipulate `totalReserve[_baseToken]` to be artificially low (e.g., by temporarily withdrawing liquidity and then adding it back), they could inflate the price. This could then be exploited in subsequent calculations, leading to incorrect share allocations or fee distributions.
    *   **Location:** `getTokenPriceInLPShares`, and any function using it (e.g., `removeLiquidity`, `claimFee`).
    *   **Impact:**  Incorrect share calculations, unfair fee distribution, arbitrage opportunities, and potential manipulation of the system.
    *   **Mitigation:**
        *   Implement safeguards to prevent drastic fluctuations in `totalReserve`. This might involve using a time-weighted average price (TWAP) or other smoothing techniques.
        *   Consider the potential impact of flash loans or other large liquidity movements on the price calculation.

**Medium Severity**

5.  **Lack of Slippage Control in `removeLiquidity`:**

    *   **Description:**  The `removeLiquidity` function calculates the amount of tokens to be returned to the user. However, there is no mechanism for the user to specify a minimum acceptable amount (slippage tolerance). If the price changes significantly between the time the user initiates the transaction and the time it is executed, they may receive fewer tokens than expected.
    *   **Location:** `removeLiquidity` function.
    *   **Impact:**  Users receive less value than expected when removing liquidity.
    *   **Mitigation:**
        *   Allow users to specify a minimum acceptable amount of tokens to receive when removing liquidity. Revert the transaction if the actual amount is below the specified minimum.

6.  **Centralization Risks:**

    *   **Description:** The contract inherits `OwnableUpgradeable` and `Pausable`. The owner has the ability to `setTokenManager`, `setWhiteListPeriodManager`, `setLiquidityPool` and pause the contract. While this provides flexibility for upgrades and emergency situations, it also introduces a centralization risk. If the owner account is compromised, an attacker could potentially drain the pool, modify critical parameters, or permanently disable the contract.
    *   **Location:** Functions using `onlyOwner` modifier and `Pausable` functionality.
    *   **Impact:** Loss of funds, manipulation of the system, denial of service.
    *   **Mitigation:**
        *   Implement multi-signature governance for critical functions.
        *   Consider using a timelock contract for sensitive parameter changes.
        *   Clearly document the owner's responsibilities and the procedures for handling emergencies.

7.  **Missing Input Validation:**

    *   **Description:** While there are some checks, there could be additional input validation to prevent unexpected behavior. For example, when setting addresses, consider verifying that the address is not the zero address or the address of the current contract.
    *   **Location:** `setLpToken`, `setTokenManager`, `setWhiteListPeriodManager`, `setLiquidityPool`.
    *   **Impact:** Potential for misconfiguration or unexpected behavior.
    *   **Mitigation:** Add checks to ensure addresses being set are valid and not obviously incorrect (e.g., not the zero address).

**Low Severity**

8.  **Event for `setLiquidityPool`, `setTokenManager`, `setWhiteListPeriodManager`:**

    *   **Description:**  Adding events when the `liquidityPool`, `tokenManager`, and `whiteListPeriodManager` addresses are updated would improve transparency and auditability.
    *   **Location:** `setLiquidityPool`, `setTokenManager`, `setWhiteListPeriodManager`.
    *   **Impact:** Reduced transparency.
    *   **Mitigation:** Emit events when these addresses are updated.

9.  **Gas Optimization:**

    *   **Description:** There are potential opportunities for gas optimization throughout the contract. For example, caching frequently accessed storage variables in memory can reduce gas costs.
    *   **Location:**  Multiple locations.
    *   **Impact:** Slightly higher gas costs.
    *   **Mitigation:**  Perform a gas audit and optimize code for gas efficiency.

**Summary of Recommendations:**

*   **Address the Reentrancy Vulnerability:** This is the most critical issue and must be resolved immediately.
*   **Mitigate Rounding Errors:** Use more precise calculations or libraries designed for fixed-point arithmetic.
*   **Implement Slippage Control:** Allow users to specify a minimum acceptable amount when removing liquidity.
*   **Reduce Centralization Risks:** Implement multi-signature governance or timelocks for critical functions.
*   **Improve Input Validation:** Add checks to ensure addresses being set are valid.
*   **Add Events:** Emit events when important parameters are changed.
*   **Optimize Gas Costs:** Perform a gas audit and optimize code for gas efficiency.

This analysis provides a comprehensive overview of potential vulnerabilities in the smart contract. It is essential to address these issues to ensure the security and reliability of the system. Remember to thoroughly test any changes you make to the code.  A professional security audit is highly recommended before deploying this contract to a production environment.","### **Output**

---

**[H-02] LiquidityProviders.sol: Share Price Manipulation**

**Report Description**:
The share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for `sharesToTokenAmount(totalNFTShares, _tokenAddress)` to overflow in `removeLiquidity()` and therefore freeze users' funds.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of share price manipulation leading to potential overflow in `sharesToTokenAmount`. This is a critical vulnerability that could result in frozen funds, and it is not covered in the response list.

---

**[M-01] Unsupported Tokens Cannot Be Withdrawn**

**Report Description**:
In the function `addTokenLiquidity`, supported tokens can be turned off again. Users won't be able to withdraw their liquidity anymore because of this check in the function `removeLiquidity`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unsupported tokens being unable to be withdrawn. This is a medium-severity issue that could lead to users being unable to access their funds, and it is not covered in the response list.

---

**[M-11] LiquidityProviders: Setting New Liquidity Pool Will Break Contract**

**Report Description**:
Owners can change the `liquidityPool` variable any time with the `setLiquidityPool` function. If a liquidity pool was already set and users added liquidity with `addTokenLiquidity`, the tokens are directly transferred to the liquidity pool and not kept in the `LiquidityProviders` contract. Changing the `liquidityPool` to a different contract will make it impossible for users to withdraw their liquidity using `removeLiquidity` because the tokens are still in the old `liquidityPool` and cannot be retrieved.

**Match in Response List**:
Matches with the issue titled **""Centralization Risks""**.

**Validation**:
**Partially Correct**. The response identifies the centralization risk associated with the owner's ability to change the `liquidityPool` address. However, it does not specifically address the impact on users' ability to withdraw liquidity, which is a critical aspect of this issue.

---

**[M-12] LiquidityProviders: Setting New LP Token Will Break Contract**

**Report Description**:
Owners can change the `lpToken` variable at any time with the `setLpToken` function. If an LP token was already set and users added liquidity with `addTokenLiquidity` and were minted an `lpToken` NFT, changing the `lpToken` to a different contract will make it impossible for users to withdraw their liquidity using `removeLiquidity`. All users will lose their funds.

**Match in Response List**:
Matches with the issue titled **""Centralization Risks""**.

**Validation**:
**Partially Correct**. The response identifies the centralization risk associated with the owner's ability to change the `lpToken` address. However, it does not specifically address the impact on users' ability to withdraw liquidity, which is a critical aspect of this issue.

---

**[M-17] Wrong Condition Checking in Price Calculation**

**Report Description**:
The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return `BASE_DIVISOR` if the total reserve is zero, not if the total shares minted is zero. This might lead to a case where the price is calculated incorrectly, or a division by zero is happening.

**Match in Response List**:
Matches with the issue titled **""Rounding Errors in Share Calculations""**.

**Validation**:
**Partially Correct**. The response identifies the issue of rounding errors in share calculations, which is related to the incorrect price calculation. However, it does not specifically address the wrong condition check in `getTokenPriceInLPShares`, which is a critical aspect of this issue.

---

**[M-19] sharesToTokenAmount: Division by Zero**

**Report Description**:
The public `sharesToTokenAmount` function does not check if the denominator `totalSharesMinted[_tokenAddress]` is zero. Neither do the callers of this function. The function will revert. Calling functions like `getFeeAccumulatedOnNft` and `sharesToTokenAmount` from another contract should never revert.

**Match in Response List**:
Matches with the issue titled **""Rounding Errors in Share Calculations""**.

**Validation**:
**Partially Correct**. The response identifies the issue of rounding errors in share calculations, which is related to the division by zero in `sharesToTokenAmount`. However, it does not specifically address the lack of a zero-check for `totalSharesMinted[_tokenAddress]`, which is a critical aspect of this issue.

---

**[M-20] Liquidity Providers Unable to Remove Liquidity When the Pool is in Deficit State**

**Report Description**:
In the function `removeLiquidity`, LP token holders cannot redeem their tokens when the pool is in the deficit state, i.e., `currentLiquidity << providedLiquidity`. This is due to that LP shares are computed based on `providedLiquidity` and the actual available pool balance is based on `currentLiquidity`.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of liquidity providers being unable to remove liquidity when the pool is in a deficit state. This is a medium-severity issue that could lead to users being unable to access their funds, and it is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-11] LiquidityProviders: Setting New Liquidity Pool Will Break Contract**
- **[M-12] LiquidityProviders: Setting New LP Token Will Break Contract**
- **[M-17] Wrong Condition Checking in Price Calculation**
- **[M-19] sharesToTokenAmount: Division by Zero**

**Missed Issues from Issue Report**:
- **[H-02] LiquidityProviders.sol: Share Price Manipulation**
- **[M-01] Unsupported Tokens Cannot Be Withdrawn**
- **[M-20] Liquidity Providers Unable to Remove Liquidity When the Pool is in Deficit State**

---

### **Conclusion**
The response list partially addresses some of the issues but misses critical vulnerabilities such as share price manipulation, unsupported token withdrawal, and liquidity removal in a deficit state. Additionally, the responses that do match are only partially correct, as they fail to address specific aspects of the vulnerabilities. A more comprehensive and detailed analysis is required to fully address all the issues in the issue report.",0,4,3,9,"```
None.
```",0.0,0
LiquidityFarming.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    /// @notice Mapping to track the rewarder pool.
    mapping(address => PoolInfo) public poolInfo;

    /// @notice Info of each NFT that is staked.
    mapping(uint256 => NFTInfo) public nftInfo;

    /// @notice Reward rate per base token
    //mapping(address => uint256) public rewardPerSecond;

    /// @notice Reward Token
    mapping(address => address) public rewardTokens;

    /// @notice Staker => NFTs staked
    mapping(address => uint256[]) public nftIdsStaked;

    /// @notice Token => Total Shares Staked
    mapping(address => uint256) public totalSharesStaked;

    /// @notice Token => Reward Rate Updation history
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    /// @notice Initialize the rewarder pool.
    /// @param _baseToken Base token to be used for the rewarder pool.
    /// @param _rewardToken Reward token to be used for the rewarder pool.
    /// @param _rewardPerSecond Reward rate per base token.
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.
    /// @param _nftId NFT ID that is being locked
    /// @param _to Address to which rewards will be credited.
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.
    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract
    /// @param _token Token to reclaim, use 0x00 for Ethereum
    /// @param _amount Amount of tokens to reclaim
    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,
    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,
    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    /// @notice Deposit LP tokens
    /// @param _nftId LP token nftId to deposit.
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    /// @notice Withdraw LP tokens
    /// @param _nftId LP token nftId to withdraw.
    /// @param _to The receiver of `amount` withdraw benefit.
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    /// @notice Extract all rewards without withdrawing LP tokens
    /// @param _nftId LP token nftId for which rewards are to be withdrawn
    /// @param _to The receiver of withdraw benefit.
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    /// @notice Calculates an up to date value of accTokenPerShare
    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        // We know that during all the periods that were included in the current iterations,
        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the
        // updates to the pool that happened after the lastUpdatedTime.
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    /// @notice View function to see pending Token
    /// @param _nftId NFT for which pending tokens are to be viewed
    /// @return pending reward for a given user.
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    /// @notice Update reward variables of the given pool.
    /// @return pool Returns the pool that was updated.
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    /// @notice View function to see the tokens staked by a given user.
    /// @param _user Address of user.
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3691.0,373.0,"[H-04] Deleting `nft` Info can cause users' `nft.unpaidRewards` to be permanently erased
When `withdraw()` is called, `_sendRewardsForNft(_nftId, _to)` will be called to send the rewards.In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.
However, at L244, the whole `nftInfo` is being deleted, so that `nft.unpaidRewards` will also get erased.
There is no way for the user to get back this `unpaidRewards` anymore

[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss
“function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) ”,  the accTokenPerShare is calculated based on the total staked shares.

[M-04] Owners have absolute control over protocol
Owners have full control over the protocol.

[M-06] DoS by gas limit
In `deposit` function it is possible to push to nftIdsStaked of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.

[M-10] Call to non-existing contracts returns success
Low level calls (call, delegate call and static call) return success if the called contract doesn’t exist (not deployed or destructed).
This makes a user be able to send his funds to non-existing addresses.

[M-14] LiquidityFarming.sol Unbounded for loops can potentially freeze users' funds in edge cases
In the current implementation of `withdraw()`, it calls `_sendRewardsForNft()` at L243 which calls `updatePool()` at L129 which calls `getUpdatedAccTokenPerShare()` at L319.
`getUpdatedAccTokenPerShare()` will loop over `rewardRateLog` to calculate an up to date value of accTokenPerShare.",6.0,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    
    mapping(address => PoolInfo) public poolInfo;

    
    mapping(uint256 => NFTInfo) public nftInfo;

    
    

    
    mapping(address => address) public rewardTokens;

    
    mapping(address => uint256[]) public nftIdsStaked;

    
    mapping(address => uint256) public totalSharesStaked;

    
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    
    
    
    
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    
    
    
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    
    
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    
    
    
    
    
    
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    
    
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    
    
    
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    
    
    
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    
    
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        
        
        
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    
    
    
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    
    
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    
    
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3032.0,2,4,"Based on the provided code, here's a breakdown of potential vulnerabilities and areas of concern:

**High Severity**

*   **Incorrect Reward Calculation Logic:** The core of the contract, reward calculation, seems to have flaws in the `getUpdatedAccTokenPerShare` function. Specifically, the while loop logic iterating through `rewardRateLog` and calculating `accumulator` has potential issues.
    *   **Incorrect counter:** The variable `counter` starts with block.timestamp and iterates to lower timestamps by decrementing with `rewardRateLog[_baseToken][i].timestamp`. However, the correct way to calculate accumulated rewards is to start from `lastUpdatedTime` and calculate till `block.timestamp`. So this counter logic seems inverted.
    *   **Potential Underflow:** The line `counter = rewardRateLog[_baseToken][i].timestamp;` could potentially underflow the `counter` variable if the value of `rewardRateLog[_baseToken][i].timestamp` is significantly smaller than what `counter` already is. This is because `counter` is an `uint256` and can lead to unexpected large values, disrupting the loop logic. This is unlikely because `counter` is being assigned values based on timestamps which should be close to `block.timestamp` however it should be still taken into consideration.
    *   **Potential Division by Zero:** While there's a check `totalSharesStaked[_baseToken] > 0`, this doesn't guarantee that `totalSharesStaked[_baseToken]` remains non-zero throughout the `getUpdatedAccTokenPerShare` function's execution.  A carefully timed withdrawal in a separate transaction *during* the execution of `getUpdatedAccTokenPerShare` could potentially reduce `totalSharesStaked[_baseToken]` to zero, leading to a division by zero in the line `accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];`

    *   **Impact:** Incorrect rewards distribution.  Stakers could be unfairly rewarded (or not rewarded enough), leading to loss of funds for some users and potential exploits. The vulnerability in `getUpdatedAccTokenPerShare` directly affects `pendingToken`, `updatePool`, and `_sendRewardsForNft`, all of which contribute to the financial integrity of the contract.

**Medium Severity**

*   **Centralization Risk: Owner Control:**  The contract relies heavily on the owner for crucial functions:
    *   `initalizeRewardPool`: Only the owner can initialize reward pools. If the owner refuses to initialize a pool for a specific `_baseToken`, no one can stake using that token.
    *   `setRewardPerSecond`: Only the owner can adjust the reward rate. A malicious or compromised owner could manipulate the reward rates, favoring certain tokens or draining rewards.
    *   `reclaimTokens`: Only the owner can reclaim tokens. This poses a centralization risk if the owner becomes malicious or loses control of their key.
    *   **Mitigation:** Consider implementing a more decentralized governance mechanism (e.g., a DAO) to manage these crucial parameters.

*   **Rounding Errors:** The calculations involving `amount /= liquidityProviders.BASE_DIVISOR();` could lead to rounding errors.  If `liquidityProviders.BASE_DIVISOR()` is large and `amount` is relatively small, the result could be rounded down to zero.
    *   **Impact:** Stakers with smaller amounts might not receive any rewards.
    *   **Mitigation:** Consider using a larger precision or performing calculations in a different order to minimize rounding errors.  Also, ensure that `liquidityProviders.BASE_DIVISOR()` is reasonably sized.

*   **Potential Front-Running on `setRewardPerSecond`:** An attacker could monitor the mempool for `setRewardPerSecond` transactions and front-run them with a deposit to maximize their rewards during the short period before the new rate takes effect.
    *   **Mitigation:** Implement a time lock mechanism for reward rate changes, delaying the effect of the change by a certain number of blocks.

*   **NFT Transfer Before Rewards Claim:** In the `withdraw` function, `lpToken.safeTransferFrom(address(this), msgSender, _nftId);` occurs *after* `_sendRewardsForNft(_nftId, _to);`.  If the NFT transfer fails (e.g., due to a hook on the NFT contract that reverts), the user will not receive their NFT back, but they *will* have already received their rewards. This creates an inconsistency.
    *   **Mitigation:** Reverse the order: Transfer the NFT back *before* sending rewards.  This ensures that the NFT is returned only if the reward payment is successful.

*   **Missing Checks for Zero Amount in `reclaimTokens`:** While the contract checks for `_to != address(0)`, it doesn't check if `_amount > 0` in the `reclaimTokens` function. If `_amount` is zero, the `safeTransfer` function will still execute, which might be unexpected and could potentially be exploited in some cases.
    *   **Mitigation:** Add a `require(_amount > 0, ""ERR__AMOUNT_IS_ZERO"");` check to ensure that the amount being reclaimed is greater than zero.

*   **Unbounded Loop in `withdraw`:** The loop used to find the index of the NFT being withdrawn (`nftIdsStaked[msgSender]`) could potentially become a DoS vector if the `nftIdsStaked` array grows excessively large. Although this is mitigated by the fact that only the staker can add their NFT ids to the array, it is still a concern. This can also gas limit issues.

    *   **Mitigation:** Reconsider using a mapping to store which NFT Ids are staked by a user or implement a mechanism to limit the array length.

**Low Severity and Informational**

*   **Lack of Input Validation:**  The `initalizeRewardPool` function should validate that `_rewardPerSecond` is greater than zero.  While a zero reward rate is technically valid, it might indicate a configuration error.

*   **Missing Event for Pauses and Unpauses:** While the contract inherits from `Pausable`, it doesn't emit events when the contract is paused or unpaused. Adding these events would improve transparency and auditability.

*   **Code Style and Readability:**
    *   Inconsistent naming conventions: Sometimes `_baseToken` is used, and sometimes `baseToken`.
    *   Missing NatSpec comments: Adding NatSpec comments to public and external functions would improve the contract's documentation.
    *   Consider using more descriptive variable names.

**Recommendations**

1.  **Address High Severity Vulnerability First:** Prioritize fixing the reward calculation logic (`getUpdatedAccTokenPerShare`) to ensure accurate and fair rewards distribution. Thoroughly test this function with various scenarios, including edge cases and potential race conditions.
2.  **Implement Mitigation Strategies:** Apply the mitigation strategies outlined for the medium-severity vulnerabilities to reduce the attack surface and improve the contract's security.
3.  **Enhance Code Quality:** Improve the code style, readability, and documentation for better maintainability and auditability.

**Disclaimer:**  This analysis is based on the provided code snippet. A complete security audit should be performed by experienced security professionals to identify all potential vulnerabilities and assess the overall risk.","### **[H-04] Deleting `nft` Info can cause users' `nft.unpaidRewards` to be permanently erased**

**Report Description**:  
When `withdraw()` is called, `_sendRewardsForNft(_nftId, _to)` is invoked to send rewards. In `_sendRewardsForNft()`, if `address(this).balance` is insufficient, `nft.unpaidRewards = pending - balance` is recorded, allowing users to claim the remaining rewards later. However, at L244, the entire `nftInfo` is deleted, including `nft.unpaidRewards`. This erases the user's unpaid rewards permanently, leaving them with no way to reclaim them.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of deleting `nftInfo` and its impact on `unpaidRewards`. This is a critical oversight, as it directly affects user funds and contract integrity. The response list focuses on other vulnerabilities but misses this high-severity issue entirely.

---

### **[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**

**Report Description**:  
In the function `getUpdatedAccTokenPerShare(address _baseToken)`, `accTokenPerShare` is calculated based on the total staked shares. If the total shares are too large, precision loss can occur, leading to users losing a significant portion or all of their rewards. This is a critical issue as it directly impacts the fairness and accuracy of reward distribution.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Reward Calculation Logic""**.

**Validation**:  
**Partially Correct**. The response identifies issues with the `getUpdatedAccTokenPerShare` function, including potential underflow and division by zero. However, it does not explicitly mention precision loss due to large total shares, which is the core issue in the report. While the response touches on related concerns, it misses the specific precision loss problem.

---

### **[M-04] Owners have absolute control over protocol**

**Report Description**:  
Owners have full control over the protocol, including the ability to initialize reward pools, adjust reward rates, and reclaim tokens. This centralization poses a significant risk if the owner becomes malicious or compromised, as they can manipulate the protocol to their advantage.

**Match in Response List**:  
Matches with the issue titled **""Centralization Risk: Owner Control""**.

**Validation**:  
**Correct**. The response accurately identifies the centralization risk associated with owner control. It details the specific functions where the owner has excessive control and suggests mitigation strategies, such as implementing decentralized governance. This aligns with the issue report and Solidity best practices.

---

### **[M-06] DoS by gas limit**

**Report Description**:  
In the `deposit` function, an attacker can push too many NFTs to another user's `nftIdsStaked` array. When the user attempts to withdraw an NFT at the end of the list, the iteration over the large array may exceed the gas limit, causing the transaction to revert. This can lead to a denial of service (DoS) for the user.

**Match in Response List**:  
Matches with the issue titled **""Unbounded Loop in `withdraw`""**.

**Validation**:  
**Correct**. The response correctly identifies the issue of unbounded loops in the `withdraw` function, which can lead to gas limit issues and DoS. It suggests using a mapping or limiting the array length as mitigation strategies. This aligns with the issue report and addresses the core problem.

---

### **[M-10] Call to non-existing contracts returns success**

**Report Description**:  
Low-level calls (`call`, `delegatecall`, and `staticcall`) return success even if the called contract does not exist (not deployed or destructed). This allows users to send funds to non-existing addresses, leading to permanent loss of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of low-level calls returning success for non-existing contracts. This is a medium-severity issue that can lead to fund loss, and its omission is a significant gap in the response list.

---

### **[M-14] `LiquidityFarming.sol` Unbounded for loops can potentially freeze users' funds in edge cases**

**Report Description**:  
In the `withdraw()` function, `_sendRewardsForNft()` calls `updatePool()`, which in turn calls `getUpdatedAccTokenPerShare()`. The latter function loops over `rewardRateLog` to calculate `accTokenPerShare`. If `rewardRateLog` grows too large, the loop can exceed the gas limit, freezing users' funds.

**Match in Response List**:  
Matches with the issue titled **""Unbounded Loop in `withdraw`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unbounded loops in the `withdraw` function but does not explicitly link it to the `getUpdatedAccTokenPerShare` function and its impact on `rewardRateLog`. While the response touches on the broader concern of unbounded loops, it misses the specific context of this issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[M-04] Owners have absolute control over protocol**
- **[M-06] DoS by gas limit**

**Partially Correct Matches**:
- **[H-05] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss**
- **[M-14] `LiquidityFarming.sol` Unbounded for loops can potentially freeze users' funds in edge cases**

**Missed Issues from Issue Report**:
- **[H-04] Deleting `nft` Info can cause users' `nft.unpaidRewards` to be permanently erased**
- **[M-10] Call to non-existing contracts returns success**

---

**Conclusion**:  
The response list covers several issues but misses critical vulnerabilities like the deletion of `nftInfo` and low-level calls to non-existing contracts. Additionally, some matches are only partially correct, as they do not fully address the specific concerns raised in the issue report. A more comprehensive review is needed to ensure all vulnerabilities are identified and addressed.",2,2,2,9,"```
1. Centralization Risk: Owner Control
2. Unbounded Loop in `withdraw`
```","To calculate the **Average Precision (AP)** for the given query, we follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - **Centralization Risk: Owner Control** appears at rank 2.
   - **Unbounded Loop in `withdraw`** appears at rank 10.

2. **Calculate the precision at each rank**:
   - For **Centralization Risk: Owner Control** at rank 2:
     \[
     P@2 = \frac{1}{2} = 0.5
     \]
   - For **Unbounded Loop in `withdraw`** at rank 10:
     \[
     P@10 = \frac{2}{10} = 0.2
     \]

3. **Average the precision values**:
   \[
   AP = \frac{0.5 + 0.2}{2} = 0.35
   \]

**Output**:
```
0.35
```",0.35
WhitelistPeriodManager.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    /* LP Status */
    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.
    mapping(address => bool) public isExcludedAddress;
    // Token -> TVL
    mapping(address => uint256) private totalLiquidity;
    // Token -> TVL
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    /* Caps */
    // Token Address -> Limit
    mapping(address => uint256) public perTokenTotalCap;
    // Token Address -> Limit
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to add liqudity
     */
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        // Per Token Total Cap or PTTC
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity
     */
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract
     */
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        // Release limit from  _from
        _beforeLiquidityRemoval(_from, _token, _amount);

        // Block limit of _to
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    /**
     * @dev Special care must be taken when calling this function
     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it
     *      should be >= max lp provided by an lp.
     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth
     *      Call the view function getMaxCommunityLpPositon() separately before changing this value
     */
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    /**
     * @dev Enables (or disables) reverts if liquidity exceeds caps.
     *      Even if this is disabled, the contract will continue to track LP's positions
     */
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    /**
     * @dev Returns the maximum amount a single community LP has provided
     */
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    /**
     * @dev returns the value of if (areWhiteListEnabled) then (_cond)
     */
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    /**
     * @dev Meta-Transaction Helper, returns msgSender
     */
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    /**
     * @dev Meta-Transaction Helper, returns msgData
     */
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",2422.0,291.0,"[M-05] Frontrunning of setPerTokenWalletCap edge case
The `setPerTokenWalletCap()` function in WhitelistPeriodManager.sol contains a comment stating:
Special care must be taken when calling this function
There are no checks for `_perTokenWalletCap (since it's onlyOwner)`, but it's essential that it should be >= max lp provided by an lp.
Checking this on chain will probably require implementing a bbst, which needs more bandwidth
Call the view function `getMaxCommunityLpPositon()` separately before changing this value

[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals
The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. While this affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.
In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.

[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions
The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is added to the `isExcludedAddress` mapping. This affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, which implicitly assumes that whitelisted addresses will have 0 liquidity, for addresses with non-zero liquidity at the time of addition to the whitelist.",3.0,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    
    
    mapping(address => bool) public isExcludedAddress;
    
    mapping(address => uint256) private totalLiquidity;
    
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    
    
    mapping(address => uint256) public perTokenTotalCap;
    
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        
        _beforeLiquidityRemoval(_from, _token, _amount);

        
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",1958.0,0,3,"Based on the provided code, here's a breakdown of potential vulnerabilities:

**1. Reentrancy:**

*   **Risk:** Although the contract inherits `ReentrancyGuardUpgradeable`, it isn't being used. Functions that interact with external contracts (especially the `liquidityProviders`, `tokenManager`, and `lpToken` contracts) are potential reentrancy points. Malicious contracts could call back into this contract during those interactions, potentially manipulating state or bypassing checks.
*   **Affected Functions:** `beforeLiquidityAddition`, `beforeLiquidityRemoval`, `beforeLiquidityTransfer`, `setTokenManager`, `setLiquidityProviders`, `setLpToken`, `setTotalCap`, `setPerTokenWalletCap`, `setCap`, `setCaps`
*   **Mitigation:**  Add the `nonReentrant` modifier to all external function calls, especially when interacting with `liquidityProviders`, `tokenManager`, and `lpToken`. Also add `nonReentrant` to internal functions called by these functions.

**2. Lack of Input Validation:**

*   **Risk:** Several functions take addresses as input.  There's no validation to ensure these are actually contract addresses or that they implement the expected interfaces (`ILiquidityProviders`, `ITokenManager`, `ILPToken`).  Passing an incorrect address can lead to unexpected behavior or even bricking the contract.
*   **Affected Functions:** `setTokenManager`, `setLiquidityProviders`, `setLpToken`, `setIsExcludedAddressStatus`, `setTotalCap`, `setPerTokenWalletCap`, `setCap`, `setCaps`
*   **Mitigation:**
    *   When setting addresses for `tokenManager`, `liquidityProviders`, and `lpToken`, check if the given address is a contract using `address(contract).code.length > 0`.
    *   Consider adding interface detection by calling a known function from the interface and handling exceptions if the call fails.

**3. Integer Overflow/Underflow (Mitigated by Solidity 0.8.0):**

*   **Risk:**  Prior to Solidity 0.8.0, integer overflows and underflows were common vulnerabilities. While Solidity 0.8.0 includes built-in overflow/underflow protection, it's crucial to double-check any unchecked arithmetic operations.
*   **Vulnerable Code:** None, since Solidity 0.8.0 is being used.
*   **Mitigation:** N/A (Already handled by Solidity 0.8.0)

**4. Logic Errors and Unexpected Behavior:**

*   **Risk:** The function `getMaxCommunityLpPositon` iterates through all possible LP token IDs, from 1 to `totalSupply()`. This can be extremely inefficient if `totalSupply` is large and if not all token IDs are actually in use. This could lead to a denial-of-service (DoS) if this function is called frequently.
*   **Affected Functions:** `getMaxCommunityLpPositon`
*   **Mitigation:** Avoid loops with potentially unbounded iterations. Consider storing the current max position somewhere and updating the value on transfer or other events.

**5. Potential Denial of Service (DoS):**

*   **Risk:**  If the `tokenManager.getTokensInfo(_token)` call in `_isSupportedToken` reverts for any reason (e.g., the token manager is unavailable or there's a problem with its implementation), it could block updates to the `WhitelistPeriodManager`.  This is a form of DoS.
*   **Affected Functions:** `setTotalCap`, `setPerTokenWalletCap`, `setCap`, `setCaps`
*   **Mitigation:** Implement error handling around the call to `tokenManager.getTokensInfo(_token)`. If the call fails, you could consider allowing the owner to bypass the token check or to temporarily disable the whitelist restrictions.

**6. Access Control Issues:**

*   **Risk:** The `onlyLiquidityPool` and `onlyLpNft` modifiers rely on comparing `_msgSender()` to the addresses of `liquidityProviders` and `lpToken`, respectively. If the contracts at those addresses are compromised, malicious actors can bypass these restrictions.
*   **Affected Functions:** `beforeLiquidityAddition`, `beforeLiquidityRemoval`, `beforeLiquidityTransfer`
*   **Mitigation:** Consider implementing more robust authentication mechanisms, such as requiring these contracts to sign messages with a specific key. Implement checks within `liquidityProviders` and `lpToken` contracts to verify the actions being performed are legitimate, before they call `WhitelistPeriodManager`.

**7. Upgradeability Concerns (OpenZeppelin Upgradeable Contracts):**

*   **Risk:** The contract uses OpenZeppelin's upgradeable contracts. Incorrect usage of these contracts can lead to storage collisions, initialization issues, or other problems during upgrades.
*   **Mitigation:**
    *   Carefully review the OpenZeppelin documentation on upgradeable contracts.
    *   Always use a proxy contract to access the logic contract.
    *   Use the `initializer` modifier in the `initialize` function.
    *   Ensure that storage variables are declared in the correct order to avoid collisions during upgrades.
    *   Consider using OpenZeppelin's upgrade plugins/tools for automated checks.

**8. Centralization Risk**

*   **Risk:** The contract relies heavily on owner-controlled functions for setting crucial parameters like `tokenManager`, `liquidityProviders`, `lpToken`, caps, and whitelist status. A compromised owner key could lead to significant abuse and manipulation of the system.
*   **Affected Functions:** All `onlyOwner` functions
*   **Mitigation:** Implement a multi-signature wallet for owner-controlled functions to reduce the risk of a single point of failure. Consider implementing a timelock mechanism for critical parameter changes.

**Recommendations:**

1.  **Implement Reentrancy Protection:** Add `nonReentrant` modifiers to functions interacting with external contracts.
2.  **Enhance Input Validation:** Add checks to ensure input addresses are valid contract addresses and implement the expected interfaces.
3.  **Optimize Loops:** Avoid potentially unbounded loops in functions like `getMaxCommunityLpPositon`.
4.  **Improve Error Handling:** Handle potential errors from external contract calls in `_isSupportedToken`.
5.  **Strengthen Access Control:** Consider more robust authentication mechanisms for `onlyLiquidityPool` and `onlyLpNft` modifiers.
6.  **Review Upgradeability:** Carefully review OpenZeppelin's documentation on upgradeable contracts and use their tools.
7.  **Reduce Centralization Risk:** Use a multi-signature wallet for owner control and consider a timelock.

By addressing these vulnerabilities, you can significantly improve the security and reliability of your smart contract. Remember to thoroughly test your code after implementing these mitigations.","### **[M-05] Frontrunning of setPerTokenWalletCap edge case**

**Report Description**:
The `setPerTokenWalletCap()` function in `WhitelistPeriodManager.sol` lacks checks for `_perTokenWalletCap`, which should be >= the maximum LP provided by an LP. This could lead to frontrunning attacks where an attacker could exploit the lack of on-chain validation. The function suggests calling `getMaxCommunityLpPositon()` separately before changing this value, but this is not enforced, potentially leading to inconsistencies and vulnerabilities.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of frontrunning or the lack of checks for `_perTokenWalletCap` in `setPerTokenWalletCap()`. The response focuses on reentrancy, input validation, and other issues but misses this critical edge case.

---

### **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**

**Report Description**:
The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. This oversight affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function. The worst impact is that users may be prevented from withdrawing their staked LP tokens due to subtraction overflow, leading to potential denial of service.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the improper state handling of exclusion removals. The issue of state inconsistency and potential subtraction overflow is entirely missed in the response.

---

### **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

**Report Description**:
The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is added to the `isExcludedAddress` mapping. This affects the enforcement of cap limits and the `getMaxCommunityLpPositon()` function, which assumes that whitelisted addresses will have 0 liquidity. This can lead to inconsistencies and vulnerabilities for addresses with non-zero liquidity at the time of addition to the whitelist.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the improper state handling of exclusion additions. The issue of state inconsistency and its impact on cap enforcement is entirely missed in the response.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-05] Frontrunning of setPerTokenWalletCap edge case**
- **[M-15] WhitelistPeriodManager: Improper state handling of exclusion removals**
- **[M-16] WhitelistPeriodManager: Improper state handling of exclusion additions**

---

### **Conclusion**
The response list fails to address several critical issues identified in the issue report, particularly those related to state handling and edge cases in the `WhitelistPeriodManager` contract. While the response list covers general vulnerabilities like reentrancy, input validation, and access control, it misses specific issues that could lead to significant security risks and inconsistencies in the contract's behavior. Addressing these gaps is essential for improving the contract's security and reliability.",0,0,3,8,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. 

Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these precision values is also 0.",0
TokenManager.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    /**
     * First key is toChainId and second key is token address being deposited on current chain
     */
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    /**
     * Store min/max amount of token to transfer based on token address
     */
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        // Empty Constructor
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    /**
     * Set DepositConfig for the given combination of toChainId, tokenAddress.
     * This is used while depositing token in Liquidity Pool. Based on the destination chainid
     * min and max deposit amount is checked.
     */
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1169.0,146.0,"***[M-09] Improper Upper Bound Definition on the Fee***
The `equilibriumFee` and `maxFee` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.",1.0,"pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1066.0,0,1,"Based on the provided smart contract code, here's a breakdown of potential vulnerabilities and areas of concern:

**1. Reentrancy:**

*   **Likelihood:** Low, but needs careful consideration.
*   **Explanation:** The contract itself doesn't directly perform external calls that would immediately trigger reentrancy.  *However*, its purpose as a Token Manager strongly implies it *will* interact with other token contracts (likely ERC20s) in other functions not shown.  If this contract calls another token contract to transfer funds, malicious token contracts could re-enter the `TokenManager` and potentially manipulate state.
*   **Mitigation:**
    *   **Favor Pull over Push:**  Instead of directly sending tokens to users, consider having them *pull* the tokens.  This eliminates the callback and reentrancy window.
    *   **Reentrancy Guards:**  Implement a reentrancy guard (using `ReentrancyGuard` from OpenZeppelin) around any functions that make external calls to token contracts or other potentially untrusted contracts.
    *   **Checks-Effects-Interactions Pattern:**  Always perform state checks *before* making external calls, and perform state updates *after* the calls.  This helps minimize the window of vulnerability.

**2. Front Running:**

*   **Likelihood:** Moderate.
*   **Explanation:**  The `changeFee`, `setTokenTransferOverhead`, `setDepositConfig`, `addSupportedToken`, `removeSupportedToken`, and `updateTokenCap` functions are onlyOwner functions.  If an attacker can observe the transaction in the mempool before it's mined, they could potentially front-run these transactions to their advantage (e.g., by trading on information about upcoming fee changes or supported tokens).
*   **Mitigation:**
    *   **Commit-Reveal Schemes:** For sensitive configuration changes, consider a commit-reveal scheme. The owner commits to a change (e.g., a hash of the new configuration), and then reveals the configuration later. This makes it harder for front-runners to predict the change.
    *   **Acceptable Slippage:** When interacting with other contracts, use an acceptable slippage to avoid front-running.
    *   **Rate Limiting:** If appropriate, limit the frequency with which configuration changes can be made.
    *   **Consider off-chain governance:** Sensitive parameter changes can be governed off-chain before execution.

**3. Denial of Service (DoS):**

*   **Likelihood:** Moderate
*   **Explanation:**
    *   **Unbounded Loops in `setDepositConfig`:** The `setDepositConfig` function iterates through arrays (`toChainId`, `tokenAddresses`, `tokenConfig`).  If the owner accidentally (or maliciously) provides extremely large arrays, this could consume a lot of gas and potentially make the transaction fail (DoS).  Furthermore, constantly changing the `depositConfig` will degrade the contract performance.
    *   **`pause()` function:** The owner can arbitrarily `pause()` the contract using `Pausable`. While this is intended functionality, a malicious or compromised owner could use this to disrupt the contract's operation.
*   **Mitigation:**
    *   **Array Size Limits:** Implement reasonable limits on the size of the arrays passed to `setDepositConfig`.
    *   **Gas Limit Considerations:** Test transactions with large array sizes to ensure they don't exceed gas limits.
    *   **Multi-Sig/Governance for Pausing:** Require multiple parties (e.g., a multi-signature wallet) to authorize pausing the contract, to prevent a single compromised owner from causing a DoS.
    *   **Monitor gas usage:**  Monitor the gas usage of the `setDepositConfig` to prevent unbounded growth.

**4. Integer Overflow/Underflow:**

*   **Likelihood:** Very Low (Solidity 0.8.0+).
*   **Explanation:** Solidity 0.8.0 and later versions have built-in overflow/underflow protection.  Arithmetic operations will revert if they result in an overflow or underflow.
*   **Mitigation:** (Generally not required in 0.8.0+, but good practice)
    *   Consider using SafeMath libraries (though not strictly necessary in 0.8.0+) if there's any risk of dealing with very large numbers or complex arithmetic.

**5. Incorrect Access Control:**

*   **Likelihood:** Moderate.
*   **Explanation:** The contract relies on `Ownable` for access control.  It's crucial to ensure that the initial owner is correctly set and that the owner's address is securely managed.  Also, double-check that *all* functions intended to be owner-only have the `onlyOwner` modifier.
*   **Mitigation:**
    *   **Secure Owner Management:** Use a secure multi-signature wallet or a well-audited governance contract as the owner.
    *   **Auditing:** Thoroughly audit the contract to verify that all access control is correctly implemented.
    *   **Consider Role-Based Access Control:**  If more granular access control is needed (e.g., different roles for managing fees and supported tokens), consider using a role-based access control system (e.g., using `AccessControl` from OpenZeppelin).

**6. Token Configuration Issues:**

*   **Likelihood:** Moderate.
*   **Explanation:**
    *   **Inconsistent State:** The `addSupportedToken` function copies the content of the `transferConfig` map into the `tokensInfo` map (`tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];`). This is problematic because `tokensInfo[tokenAddress].tokenConfig` is a *copy* of `transferConfig[tokenAddress]`, not a reference.  Therefore, any subsequent changes to `transferConfig[tokenAddress]` (e.g., via `updateTokenCap`) *will not* be reflected in `tokensInfo[tokenAddress].tokenConfig`.  This can lead to inconsistent state and unexpected behavior.  The `getTokensInfo` function returns the `transferConfig` instead of the `tokenConfig` stored within `tokensInfo`.  This is also inconsistent.
    *   **Missing Zero Address Check:** The `setDepositConfig` function doesn't validate `tokenAddresses`, leading to issues when address zero is used.
*   **Mitigation:**
    *   **Use a single source of truth:** Decide whether the token configuration should be stored in `transferConfig` or in `tokensInfo`.  Avoid duplicating the data, and ensure that all functions consistently read from the same source.  If the goal is for `tokensInfo` to hold the current configuration, update the `updateTokenCap` function to modify `tokensInfo[tokenAddress].tokenConfig` directly. Alternatively, eliminate `tokensInfo[tokenAddress].tokenConfig` and retrieve the config from `transferConfig[tokenAddress]`
    *   **Add zero address checks:** Add `require(tokenAddresses[index] != address(0), ""Token address cannot be 0"")` in the `setDepositConfig` function.

**7. Trust Forwarder Issues:**

*   **Likelihood:** High if misconfigured.
*   **Explanation:** This contract inherits from `ERC2771Context`, which is used for meta-transactions.  If the `trustedForwarder` address is not correctly set to a *trusted* forwarder contract, attackers could potentially bypass access control or spoof the `msg.sender`.
*   **Mitigation:**
    *   **Careful Forwarder Selection:**  Use a well-audited and trusted forwarder contract.
    *   **Forwarder Verification:**  Implement checks to ensure that the `trustedForwarder` address is valid and hasn't been tampered with.
    *   **Consider Alternatives:**  Evaluate whether meta-transactions are truly necessary.  They add complexity and potential security risks.

**8. Missing Input Validation:**

*   **Likelihood:** Moderate.
*   **Explanation:**
    *   **`changeFee`:** While it checks that `_equilibriumFee` and `_maxFee` are not zero, it does not check if `_equilibriumFee` is greater than `_maxFee`.  This could lead to unexpected behavior.
    *   **`setTokenTransferOverhead`:** Doesn't validate if the `gasOverhead` is too high, which may render contract unusable.
*   **Mitigation:**
    *   **Add validation to `changeFee`:** `require(_equilibriumFee <= _maxFee, ""Equilibrium fee must be less than or equal to max fee"")`.
    *   **Add validation to `setTokenTransferOverhead`:** Establish a reasonable limit to `gasOverhead` to prevent DoS, and validate `require(gasOverhead <= MAX_GAS_OVERHEAD, ""Gas overhead too high"")`.

**Recommendations:**

1.  **Comprehensive Audit:**  Have the contract professionally audited by a reputable security firm.  This is crucial before deploying to a production environment.
2.  **Formal Verification:**  Consider using formal verification tools to mathematically prove the correctness of critical parts of the contract.
3.  **Fuzz Testing:** Use fuzzing tools (like Echidna or Foundry's fuzzer) to automatically generate test cases and uncover unexpected behavior.
4.  **Monitor and Update:**  Continuously monitor the contract's performance and security after deployment.  Be prepared to update the contract if vulnerabilities are discovered (consider using a proxy pattern for upgradeability).
5.  **Use Established Libraries:**  Whenever possible, rely on well-audited and established libraries like OpenZeppelin for common functionalities (access control, safe math, etc.).
6.  **Write Comprehensive Tests:** Implement thorough unit and integration tests to cover all aspects of the contract's functionality, including edge cases and error conditions.

By addressing these potential vulnerabilities and following security best practices, you can significantly improve the security and reliability of your smart contract. Remember that security is an ongoing process, not a one-time fix.","### **[M-09] Improper Upper Bound Definition on the Fee**

**Report Description**:
The `equilibriumFee` and `maxFee` do not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lose all funds when paying the fee. This lack of bounds can result in unintended behavior, such as excessive fees that render the contract unusable or cause financial harm to users.

**Match in Response List**:
Matches with the issue titled **""Missing Input Validation""** under the subpoint **""`changeFee`""**.

**Validation**:
**Partially Correct**. The response identifies the issue with missing input validation in the `changeFee` function, specifically noting that it does not check if `_equilibriumFee` is greater than `_maxFee`. However, the response does not fully address the broader concern of defining upper and lower bounds for `equilibriumFee` and `maxFee`. While the proposed mitigation (`require(_equilibriumFee <= _maxFee, ""Equilibrium fee must be less than or equal to max fee"")`) is a step in the right direction, it does not fully resolve the issue of unbounded fees, which could still lead to reversions or financial harm. A more comprehensive solution would include defining reasonable upper and lower bounds for both fees.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-09] Improper Upper Bound Definition on the Fee**

**Missed Issues from Issue Report**:
- *None*

---

### **Recommendations**
To fully address the issue of improper upper bound definition on the fee, consider the following additional mitigations:
1. **Define Upper and Lower Bounds**: Implement reasonable upper and lower bounds for both `equilibriumFee` and `maxFee` to prevent excessively high or low values that could lead to reversions or financial harm.
2. **Comprehensive Validation**: Ensure that all fee-related functions include validation checks to enforce these bounds.
3. **User Protection**: Consider mechanisms to protect users from sudden or excessive fee changes, such as gradual adjustments or user notifications.

By implementing these additional measures, you can further enhance the security and usability of the smart contract.",0,1,0,8,"```
None.
```",0.0,0
,,,,,,,,5,16,,,2,7,12,43,,,0.35