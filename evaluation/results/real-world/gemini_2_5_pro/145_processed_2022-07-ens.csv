nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,matchList,MAP
NameWrapper.sol,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",7024.0,963.0,"[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper
Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in onERC1155Received right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake ERC1155 NameWrapper token for domain, which is not owned by NameWrapper.

[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy
By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.
When a parent node tries to `setSubnodeOwner / setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.

[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node
By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.
However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage ENSRegistry::setSubnodeOwner to re-set himself as the ENS owner of the subdomain, and thus re-invoking the function `wrap` can rewrite the fuses and wrapper owner of the given subdoamin.

[M-01] wrapETH2LD permissioning is over-extended
Current permissioning for the function `wrapETH2LD` allows `msg.senders` who are not owner to call it if they are EITHER approved for all on the ERC721 registrar or approved on the wrapper. Allowing users who are approved for the ERC721 registrar makes sense. By giving them approval, you are giving them approval to do what they wish with the token.

[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry
There is a general incorrect logic of allowing to burn only `PARENT_CANNOT_CONTROL` fuse without burning `CANNOT_UNWRAP` fuse. If only `PARENT_CANNOT_CONTROL` fuse is burnt, then domain can be unwrapped by its owner and then wrapped again, which clears `PARENT_CANNOT_CONTROL` fuse, making it possible for parent to bypass the limitation of parent control before the expiry.",5.0,"pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    

    

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        
        registrar.transferFrom(registrant, address(this), tokenId);

        
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        
        
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        
        
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",4828.0,3,2,"Based on the smart contract code provided, here's a breakdown of potential vulnerabilities:

**1. Reentrancy:**

*   **Potential Impact:** While the contract uses `transferFrom` for ERC721 and ERC1155 tokens, and it may seem immune, reentrancy can occur in the `onERC721Received` function, specifically when calling `IERC721Receiver(to).onERC721Received.selector;`. A malicious ERC721 contract could re-enter the `NameWrapper` contract, potentially leading to unexpected state changes or denial of service.
*   **Mitigation:** Implement a reentrancy guard using a mutex pattern (e.g., `ReentrancyGuard` from OpenZeppelin) in the `onERC721Received` function. This will prevent recursive calls during the execution of the function.

**2. Incorrect Implementation of `onERC721Received`:**

*   **Potential Impact:** The call to `IERC721Receiver(to).onERC721Received.selector;` is suspicious. The `onERC721Received` function should return a selector (`bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""))`). Calling the selector like a function is incorrect and will lead to unexpected behavior. Also `to` is the address of the wrapper not the original `msg.sender` therefore the wrapped is being incorrectly informed of this transfer.
*   **Mitigation:** Return the correct selector: `return this.onERC721Received.selector;` The `to` address in `IERC721Receiver(to).onERC721Received.selector;` should instead be `msg.sender`.

**3. Centralization and Governance:**

*   **Potential Impact:** The `Ownable` contract gives the owner significant control. A compromised owner account could lead to:
    *   Setting a malicious metadata service (`setMetadataService`).
    *   Setting a malicious upgrade contract (`setUpgradeContract`).
    *   Potentially bricking the contract or stealing assets.
*   **Mitigation:** Consider a more decentralized governance mechanism. Timelocks, multi-signature wallets, or a DAO could be used to limit the owner's immediate power and provide more community control.

**4. Upgrade Contract Vulnerabilities:**

*   **Potential Impact:** The `upgradeContract` is a critical component. If the `upgradeContract` itself has vulnerabilities, they can be exploited through this contract. An attacker could potentially take over the `NameWrapper` by compromising the `upgradeContract`.
*   **Mitigation:**  Thoroughly audit the `upgradeContract` code. Implement robust access controls and security measures in the `upgradeContract` to prevent unauthorized upgrades or malicious behavior.

**5. Lack of Input Validation:**

*   **Potential Impact:** In functions like `setSubnodeOwner` and `setSubnodeRecord`, the `label` input is hashed without proper validation. A malicious user could pass a long or specially crafted label, potentially leading to hash collisions or unexpected behavior in downstream operations.

    *   The renew function does not check if the expiry is a valid expiry.
*   **Mitigation:** Add input validation to check the length and content of the `label` input, especially in functions where it's used to generate a hash. This helps prevent unexpected behavior and potential vulnerabilities related to hash collisions. Validate expiry is in the future.

**6. Denial of Service (DoS):**

*   **Potential Impact:** If the metadata service becomes unavailable, the `uri` function will fail, potentially disrupting the functionality of the NameWrapper.
*   **Mitigation:** Implement error handling and fallback mechanisms for the `uri` function. Consider caching metadata or providing a default URI in case the metadata service is unavailable.

**7. Inconsistent Data Handling in Upgrade Functions:**

*   **Potential Impact:** The `upgradeETH2LD` and `upgrade` functions burn the original token before calling the upgrade contract. If the upgrade fails in the upgrade contract, the token is burned and the name is lost, as this contract doesn't track the upgrade state.
*   **Mitigation:** Implement a mechanism to track the upgrade state. Before burning the original token, record the upgrade request. If the upgrade fails, revert the burn and restore the original state.

**8. Reclaim Logic:**

*   **Potential Impact:** The `reclaim` function is called within `wrapETH2LD` and `onERC721Received`. Reclaiming ownership of the token to this contract might have unintended consequences if the registrar's logic changes or if there are unexpected interactions with the registrar.
*   **Mitigation:** Carefully review the reclaim logic and ensure it aligns with the intended behavior of the `NameWrapper`. Consider the potential impact of reclaiming ownership on the registrar's state and interactions.

**9. Fuse Logic:**

*   **Potential Impact:** The fuse logic is complex, and the interaction between the different fuse flags might lead to unexpected behavior or vulnerabilities. For example, the interaction between `PARENT_CANNOT_CONTROL` and other fuses requires careful analysis.
*   **Mitigation:** Thoroughly test the fuse logic to ensure it behaves as expected. Consider adding more detailed documentation and comments to explain the purpose and behavior of each fuse flag.

**10. Oracle/External Dependency Risk**

*  **Potential Impact:** The contract relies on external contracts (`ENS`, `registrar`, `metadataService`, `upgradeContract`). If any of these contracts are compromised or experience downtime, the `NameWrapper` contract could be affected.
*   **Mitigation:** Implement robust error handling and fallback mechanisms for interacting with external contracts. Monitor the status of external dependencies and have a plan for addressing potential issues.  Consider using more decentralized oracles or data sources to reduce the risk of reliance on a single point of failure.

**Recommendations:**

*   **Formal Verification:** Consider formal verification to mathematically prove the correctness of critical functions and invariants.
*   **Security Audits:** Engage reputable security auditors to conduct a thorough review of the contract code.
*   **Fuzzing:** Use fuzzing tools to automatically test the contract for unexpected behavior and vulnerabilities.
*   **Gas Optimization:** Optimize the contract code to reduce gas costs, making it more efficient and less vulnerable to DoS attacks.

By addressing these vulnerabilities, you can significantly improve the security and reliability of the `NameWrapper` smart contract. Remember that smart contract security is an ongoing process, and it's important to stay informed about new vulnerabilities and best practices.","### **Comparison of Issue Report and Response List**

---

#### **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**

**Report Description**:  
Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to execute malicious code in `onERC1155Received` right after the transfer but before the new owner and fuses are set. This allows unwrapping the subdomain, but the owner and fuses remain set for the unwrapped domain, creating a fake ERC1155 NameWrapper token for a domain not owned by NameWrapper.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy""**.

**Validation**:  
**Correct**. The response identifies the reentrancy vulnerability in the `onERC721Received` function, which aligns with the issue described in the report. The mitigation suggestion to use a reentrancy guard is appropriate and addresses the core problem.

---

#### **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**

**Report Description**:  
By design, the child node's expiry can only be extended up to the parent's current expiry. However, the current implementation does not enforce this restriction, allowing the child node's expiry to exceed the parent's expiry. This violates the guarantee policy, as users must traverse the hierarchy to understand the guarantees.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical design flaw in the expiry logic.

---

#### **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**

**Report Description**:  
If the `PARENT_CANNOT_CONTROL` fuse is burnt for a subdomain, the parent should not be able to burn its fuses or change its owner. However, this constraint can be bypassed if the parent node maliciously unwraps itself. The attacker can then use `ENSRegistry::setSubnodeOwner` to reset themselves as the ENS owner of the subdomain and rewrite the fuses and wrapper owner.

**Match in Response List**:  
Matches with the issue titled **""Fuse Logic""**.

**Validation**:  
**Partially Correct**. The response acknowledges the complexity of the fuse logic but does not specifically address the bypass vulnerability described in the report. The mitigation suggestion to thoroughly test the fuse logic is relevant but insufficient to fully address the issue.

---

#### **[M-01] `wrapETH2LD` permissioning is over-extended**

**Report Description**:  
The `wrapETH2LD` function allows `msg.senders` who are not the owner to call it if they are either approved for all on the ERC721 registrar or approved on the wrapper. This over-extended permissioning could lead to unintended actions by approved users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this permissioning issue, which could lead to unauthorized actions.

---

#### **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner, allowing parent to control it again before the expiry**

**Report Description**:  
If only the `PARENT_CANNOT_CONTROL` fuse is burnt (without burning `CANNOT_UNWRAP`), the subdomain can be unwrapped by its owner and then wrapped again. This clears the `PARENT_CANNOT_CONTROL` fuse, allowing the parent to bypass the control limitation before the expiry.

**Match in Response List**:  
Matches with the issue titled **""Fuse Logic""**.

**Validation**:  
**Partially Correct**. The response mentions the complexity of the fuse logic but does not specifically address the issue of unwrapping and rewrapping to bypass `PARENT_CANNOT_CONTROL`. The mitigation suggestion to thoroughly test the fuse logic is relevant but insufficient to fully address the issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**

**Partially Correct Matches**:

- **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**
- **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner, allowing parent to control it again before the expiry**

**Missed Issues from Issue Report**:

- **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**
- **[M-01] `wrapETH2LD` permissioning is over-extended**

---

### **Conclusion**

The response list addresses some of the issues in the report, particularly reentrancy and fuse logic, but it misses critical issues related to expiry guarantees and permissioning. Additionally, the responses to fuse logic issues are partially correct, as they acknowledge the complexity but do not provide specific mitigations for the described vulnerabilities. To improve the security of the `NameWrapper` contract, the response list should be expanded to address these gaps.",1,2,2,10,"```
1. Reentrancy
```",1.0
ByteUtil.sol,"pragma solidity ^0.8.4;

library BytesUtils {
    /*
    * @dev Returns the keccak-256 hash of a byte range.
    * @param self The byte string to hash.
    * @param offset The position to start hashing at.
    * @param len The number of bytes to hash.
    * @return The hash of the byte range.
    */
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal.
    * @param self The first bytes to compare.
    * @param other The second bytes to compare.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal. Comparison is done per-rune,
    *      on unicode codepoints.
    * @param self The first bytes to compare.
    * @param offset The offset of self.
    * @param len    The length of self.
    * @param other The second bytes to compare.
    * @param otheroffset The offset of the other string.
    * @param otherlen    The length of the other string.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                // Mask out irrelevant bytes and check again
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @param len The number of bytes to compare
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    /*
    * @dev Returns true if the two byte ranges are equal with offsets.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    /*
    * @dev Compares a range of 'self' to all of 'other' and returns True iff
    *      they are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    /*
    * @dev Returns the 8-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 8 bits of the string, interpreted as an integer.
    */
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    /*
    * @dev Returns the 16-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 16 bits of the string, interpreted as an integer.
    */
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    /*
    * @dev Returns the 32-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bits of the string, interpreted as an integer.
    */
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    /*
    * @dev Returns the n byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes.
    * @param len The number of bytes.
    * @return The specified 32 bytes of the string.
    */
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        // Copy word-length chunks while possible
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        // Copy remaining bytes
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    /*
    * @dev Copies a substring into a new byte string.
    * @param self The byte string to copy from.
    * @param offset The offset to start copying at.
    * @param len The number of bytes to copy.
    */
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    // Maps characters from 0x30 to 0x7A to their base32 values.
    // 0xFF represents invalid characters in that range.
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    /**
     * @dev Decodes unpadded base32 data of up to one word in length.
     * @param self The data to decode.
     * @param off Offset into the string to start at.
     * @param len Number of characters to decode.
     * @return The decoded data, left aligned.
     */
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            // Multiple of 8 characters, no padding
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            // Two extra characters - 1 byte
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            // Four extra characters - 2 bytes
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            // Five extra characters - 3 bytes
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            // Seven extra characters - 4 bytes
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    /**
     * @dev Finds the first occurrence of the byte `needle` in `self`.
     * @param self The string to search
     * @param off The offset to start searching at 
     * @param len The number of bytes to search
     * @param needle The byte to search for
     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.
     */
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",2905.0,320.0,"[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters
Due to incorrect condition in `ByteUtil.compare` function, irrelevant characters are masked out only for strings shorter than 32 characters. However, they must be masked out for strings of all lengths in the last pass of the loop (when remainder of the string is 32 characters or less). This leads to incorrect comparision of strings longer than 32 characters where len or otherlen is smaller than string length (characters beyond provided length are still accounted for in the comparision in this case while they should be ignored).

[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths
Compare will return false answer without reverting when the inputs are not valid.

[M-08] Wrong Equals Logic
The function `equals` with offset might return true when equals without offset returns false.",3.0,"pragma solidity ^0.8.4;

library BytesUtils {
    
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    
    
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",1636.0,0,3,"The provided code is a Solidity library `BytesUtils` that provides various utility functions for working with `bytes` data. Here's an analysis of potential vulnerabilities:

**1. `keccak(bytes memory self, uint offset, uint len)`:**

*   **Vulnerability:** Potential out-of-bounds read.
*   **Explanation:** The `require(offset + len <= self.length)` check prevents `offset + len` exceeding the `self.length`.  However, integer overflow on `offset + len` is possible. If `offset + len` overflows to a small value, the require check will pass, but the assembly block will still read out of bounds when `keccak256` is called.
*   **Mitigation:** Use SafeMath or explicitly check for overflow before the `require` statement.  Specifically, check `offset + len >= offset` to confirm no overflow has occurred.

**2. `compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen)`:**

*   **Vulnerability:** Potential out-of-bounds read.
*   **Explanation:**  Similar to the `keccak` function, there are no explicit overflow checks on `offset`, `len`, `otheroffset`, or `otherlen` before they are used to calculate memory addresses. While `shortest` helps to limit the loop, if `selfptr` or `otherptr` are already out of bounds because of a previous overflow calculation, reading from `mload(selfptr)` or `mload(otherptr)` will result in out-of-bounds access.  Specifically, overflow checks are required before calculating these pointers.
*   **Mitigation:**  Add overflow checks before the assembly block, such as ensuring `offset + 32` doesn't overflow, and similarly for other offset/length calculations.

**3. `equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len)` and other `equals` variants:**

*   **Vulnerability:** Integer Overflow in `equals(bytes memory self, uint offset, bytes memory other)`
*   **Explanation:**  `self.length - offset` is used as the length parameter for the `keccak` calls, yet there is no overflow check. If `offset > self.length`, this underflows to a very large number which would likely cause out of memory issues, or an out-of-bounds read.
*   **Mitigation:**  Add an overflow check to ensure that `offset <= self.length` prior to subtraction

**4. `readUint16`, `readUint32`, `readBytes32`, `readBytes20`, `readBytesN`:**

*   **Vulnerability:** Potential out-of-bounds read.
*   **Explanation:** The `require` statements in these functions prevent exceeding the `self.length`. However, integer overflow could occur in `idx + <size>`, for example, in `idx + 2 <= self.length` in the `readUint16` function. If `idx + 2` overflows, the condition might pass even when `idx` is close to `type(uint256).max`, leading to out-of-bounds memory access within the assembly block when `mload` is used.
*   **Mitigation:** Add explicit overflow checks before the `require` statements. For example, in `readUint16`, check `idx + 2 >= idx` before performing the `require` check.
*   **Vulnerability:** Integer Truncation
*   **Explanation:** The type conversion of `mload(add(add(self, 4), idx))` to smaller types (`uint16`, `uint32`, `bytes20`) can lead to data loss (truncation). This is generally expected when reading data smaller than 32 bytes, but it's worth noting as it could potentially lead to unexpected behavior if the caller assumes the full 32 bytes are being returned.
*   **Mitigation:** Clearly document this behavior, or provide functions that return the full 32 bytes with proper zero-padding if necessary.

**5. `memcpy(uint dest, uint src, uint len)`:**

*   **Vulnerability:** Overlapping memory regions.
*   **Explanation:** If `dest` and `src` point to overlapping regions within the same memory space, the `memcpy` operation could lead to data corruption because it reads and writes to the same region concurrently.
*   **Mitigation:** Add a check to ensure that `dest` and `src` do not overlap.  However, determining this programmatically can be complex, so clear documentation that warns against using overlapping memory regions is typically sufficient.
*   **Vulnerability:**  Integer overflow/underflow in mask calculation
*   **Explanation:** In the unchecked block, `uint mask = (256 ** (32 - len)) - 1;` is calculated. When `len` is 0, the expression becomes `256**32 - 1`.  Since `256**32` will result in a number larger than can be stored in a `uint`, this could lead to unexpected behavior when calculating the mask value.
*   **Mitigation:**  Add a conditional to prevent this case.

**6. `substring(bytes memory self, uint offset, uint len)`:**

*   **Vulnerability:** Potential out-of-bounds read.
*   **Explanation:** Similar to the above functions, integer overflow on `offset + len` before the `require` check can bypass the check, leading to out-of-bounds reads.
*   **Mitigation:** Add an explicit overflow check:  `require(offset + len >= offset, ""Integer Overflow"");`

**7. `base32HexDecodeWord(bytes memory self, uint off, uint len)`:**

*   **Vulnerability:** Out-of-bounds read from `base32HexTable`.
*   **Explanation:** The `require(char >= 0x30 && char <= 0x7A)` check aims to ensure that the character being decoded is a valid base32 character.  However, the index `uint(uint8(char)) - 0x30` can still be out of bounds for the `base32HexTable` array if the condition `char >= 0x30 && char <= 0x7A` is not correctly enforced. It's crucial to ensure that all possible byte values of `char` that could potentially reach this line are validated correctly against this range.
*   **Mitigation:**  Double-check the bounds of the character. A more robust approach is to use a lookup table with the expected range of input characters directly.
*   **Vulnerability:**  Input validation weakness.
*   **Explanation:** The function checks for characters between `0x30` and `0x7A`. This includes characters beyond what is defined in base32hex. Some characters evaluate to `0xFF` in the `base32HexTable` array which indicates an invalid base32hex character, but the code doesn't explicitly check for this value, thus potentially leading to unintended interpretations of invalid characters.
*   **Mitigation:** Explicitly check that the value decoded from the lookup table is not `0xFF`.

**8. `find(bytes memory self, uint256 off, uint256 len, bytes1 needle)`:**

*   **Vulnerability:** Potential out-of-bounds read.
*   **Explanation:** The loop condition `idx < off + len` may cause an integer overflow if `off + len` exceeds the maximum value for `uint256`. This can lead to the loop continuing past the intended boundaries, reading beyond the allocated memory for `self`.  Furthermore, the lack of a check to make sure `off + len` is less than `self.length` means that the loop condition could still be true, while `self[idx]` causes an out of bounds read.
*   **Mitigation:** Add an overflow check on `off + len`. Also, make sure `off + len <= self.length`.

**General Recommendations:**

*   **Use SafeMath:** While Solidity 0.8.0+ has built-in overflow/underflow protection for arithmetic operations (except in `unchecked` blocks), it's generally recommended to use a SafeMath library, especially for older Solidity versions. This makes your code more portable and easier to understand. Even in versions with built-in protection, using SafeMath explicitly clarifies your intention to handle arithmetic operations safely.

*   **Thorough Testing:**  Write comprehensive unit tests that cover all edge cases, including large values, zero values, and potential overflow/underflow scenarios. Fuzz testing can also be very valuable.

*   **Static Analysis Tools:** Utilize static analysis tools like Slither, Mythril, and Securify to automatically detect potential vulnerabilities in your code.

*   **Formal Verification:** For critical contracts, consider using formal verification techniques to mathematically prove the absence of certain vulnerabilities.

By addressing these potential vulnerabilities and following the general recommendations, you can significantly improve the security and reliability of your smart contract library. Remember that security is an ongoing process, and it's crucial to stay up-to-date with the latest security best practices.","### **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**

**Report Description**:  
The `ByteUtil.compare` function incorrectly masks irrelevant characters only for strings shorter than 32 characters. For strings longer than 32 characters, the masking should also occur in the last pass of the loop (when the remainder of the string is 32 characters or less). This oversight leads to incorrect comparisons of strings longer than 32 characters, where `len` or `otherlen` is smaller than the string length. Characters beyond the provided length are still accounted for in the comparison, even though they should be ignored.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of incorrect masking in the `compare` function for strings longer than 32 characters. The focus in the response list is on potential out-of-bounds reads and integer overflow issues, which are unrelated to the masking logic described in the issue.

---

### **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**

**Report Description**:  
The `compare` function in `BytesUtils` does not revert when the `offset` and `len` parameters exceed the length of the input bytes. Instead, it returns a false answer, which could lead to incorrect results without proper error handling.

**Match in Response List**:  
Matches with the issue titled **""Potential out-of-bounds read in `compare` function""**.

**Validation**:  
**Partially Correct**. The response identifies the potential for out-of-bounds reads due to missing overflow checks, which is related to the issue. However, it does not explicitly address the lack of reverting behavior when `offset` and `len` exceed the input bytes length. The response focuses on overflow risks rather than the specific failure to revert.

---

### **[M-08] Wrong Equals Logic**

**Report Description**:  
The `equals` function with an offset might return `true` when the `equals` function without an offset returns `false`. This inconsistency in logic could lead to incorrect equality checks, especially when dealing with byte arrays of varying lengths or offsets.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of inconsistent logic in the `equals` function. The focus in the response list is on integer overflow and out-of-bounds reads, which are unrelated to the specific problem of incorrect equality checks.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**

**Missed Issues from Issue Report**:  
- **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**  
- **[M-08] Wrong Equals Logic**

---

### **General Observations**  
The response list focuses heavily on integer overflow and out-of-bounds read vulnerabilities, which are important but do not cover all the issues in the report. Specific issues like incorrect masking in `compare` and inconsistent logic in `equals` are not addressed. To improve coverage, the response list should include a broader range of vulnerabilities, including logic errors and incorrect function behavior. Additionally, the response list could benefit from more detailed explanations and mitigations for the specific issues raised in the report.",0,1,2,8,"```
None.
```",0.0
,,,,,,,,3,5,,,1,3,4,18,,