nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,LLM-generated,matchList,MAP,Score
NFTXStakingZap.sol,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,428.0,"***[H-01] ERC20 transferFrom return values not checked***
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.",1.0,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,1,0,"Based on the smart contract code provided, here's a breakdown of potential vulnerabilities and areas of concern:

**High Severity Vulnerabilities**

*   **Reentrancy Risk in ERC721 and ERC1155 Transfers:**
    *   The `transferFromERC721` and `provideInventory1155` functions directly call external contracts using `assetAddress.call(data)` and `nft.safeBatchTransferFrom`. If the target ERC721 or ERC1155 contract has malicious code in its `transferFrom` or `safeBatchTransferFrom` implementation, it could potentially re-enter the `NFTXStakingZap` contract. Even though `addLiquidity` functions are protected, inventory related functions are not.
    *   **Impact:** This could lead to unauthorized draining of funds or manipulation of the contract state.
    *   **Mitigation:**
        *   Implement a reentrancy guard specifically for the `transferFromERC721` and `provideInventory1155` functions or use pull over push payment flows.
        *   Consider using a more robust and standardized ERC721/ERC1155 library for transfers that includes reentrancy protection.
        *   Carefully audit and whitelist the ERC721/ERC1155 contracts that are allowed to be used with this contract.

*   **Missing Input Validation for `vaultId`:**
    *   The code relies on the `nftxFactory` to validate `vaultId` in most functions. If the `nftxFactory` has a vulnerability (e.g., allows arbitrary `vaultId` creation or manipulation), it could lead to unexpected behavior in the `NFTXStakingZap` contract.
    *   The `_addLiquidity721WETH` and `_addLiquidity1155WETH` functions do have a check:
        ```
        address vault = nftxFactory.vault(vaultId);
        require(vault != address(0), ""NFTXZap: Vault does not exist"");
        ```
    *   However other functions that accept `vaultId` such as `provideInventory721`, `provideInventory1155`, don't have this check.
    *   **Impact:** Potentially interacting with non-existent or malicious vaults, leading to loss of funds or DoS.
    *   **Mitigation:**
        *   Add validation logic to ensure `vaultId` exists and is valid within the `NFTXStakingZap` contract before any operations are performed.
        *   Consider using a mapping to track valid `vaultId`s or relying on the `nftxFactory`'s validation.

**Medium Severity Vulnerabilities**

*   **Rounding Errors in vToken Calculation:**
    *   In `provideInventory721` and `provideInventory1155` the code calculates vTokens to be minted as `count*BASE`. If the `count` (number of NFTs) is very high, this could lead to integer overflow and incorrect vToken minting.
    *   **Impact:** Incorrect amount of vTokens minted, potentially leading to loss of funds or DoS.
    *   **Mitigation:**
        *   Use SafeMath library to prevent integer overflows.
        *   Limit the maximum number of NFTs that can be provided in a single transaction.

*   **Lack of Slippage Control for `addLiquidity`:**
    *   The `addLiquidity` functions rely on the `minWethIn` parameter to control slippage. However, there's no explicit slippage control for the vToken amount. If the price of the vToken is volatile, the user could receive significantly fewer LP tokens than expected.
    *   **Impact:** Users may receive fewer LP tokens than anticipated, leading to loss of funds.
    *   **Mitigation:**
        *   Add a `minTokenIn` parameter to the `addLiquidity` functions to allow users to control slippage for the vToken amount.
        *   Provide users with clear warnings about potential slippage before executing the transaction.

*   **Incorrect ERC1155 Approval:**
    *   In the function `provideInventory1155`, the code calls `nft.setApprovalForAll(address(vault), true);`.
    *   While this may seem ok initially, it is important to note that the `safeBatchTransferFrom` function should ideally have the `NFTXStakingZap` contract being approved by the user rather than `address(this)`.
    *   The same applies for `_addLiquidity1155WETH` as well.

**Low Severity Vulnerabilities and Areas of Concern**

*   **Missing Events:**
    *   The `setLPLockTime` and `setInventoryLockTime` functions do not emit events when the lock times are updated. This makes it difficult to track changes to these important parameters.
    *   **Impact:** Reduced transparency and difficulty in tracking contract state.
    *   **Mitigation:**
        *   Emit events whenever the `lpLockTime` and `inventoryLockTime` parameters are updated.

*   **Lack of Error Handling for External Calls:**
    *   The code uses `.call` to interact with external contracts (e.g., in `transferFromERC721` and `approveERC721`). While the code checks for `success`, it doesn't handle the case where the external call returns an error message.
    *   **Impact:** Difficulty in debugging failed transactions and potential for unexpected behavior.
    *   **Mitigation:**
        *   Decode the `resultData` from the `.call` and revert with the error message if the external call fails.

*   **Hardcoded Addresses:**
    *   The `transferFromERC721` and `approveERC721` functions have hardcoded addresses for CryptoKitties and CryptoPunks. This makes the contract less flexible and harder to maintain.
    *   **Impact:** Reduced flexibility and maintainability.
    *   **Mitigation:**
        *   Store these addresses in a separate configuration file or contract and allow the owner to update them.
        *   Consider using a more generic approach to handle different ERC721 contracts.

*   **Unused `xTokensMinted` variable:**
    *   In functions `provideInventory721` and `provideInventory1155`, the `xTokensMinted` variable is assigned a value but never used.
    *   **Impact:** Wasted gas.
    *   **Mitigation:**
        *   Remove the variable if it's not needed.

*   **Typos:**
    *   In `_addLiquidityAndLock`, `minTokenIn` is passed for `amountToken` when emitting the `UserStaked` event.

**Recommendations**

*   **Thorough Auditing:** Have the contract audited by a reputable security firm.
*   **Formal Verification:** Consider using formal verification tools to mathematically prove the contract's correctness.
*   **Testing:** Write comprehensive unit and integration tests to cover all possible scenarios.
*   **Upgradeability:** If possible, design the contract to be upgradeable to allow for future bug fixes and feature enhancements.
*   **Documentation:** Provide clear and detailed documentation for the contract, including its intended use, limitations, and security considerations.

**Disclaimer:** This analysis is based on the provided code and may not be exhaustive. It is essential to perform a thorough security audit before deploying any smart contract to a production environment.","---

**[H-01] ERC20 transferFrom return values not checked**

**Report Description**:
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked. Failing to check the return value of `transferFrom()` could lead to silent failures, especially when dealing with untrusted ERC20 tokens. This oversight may result in discrepancies in token balances and potential security vulnerabilities if malicious tokens are used.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked `transferFrom()` return values. While it discusses other vulnerabilities such as reentrancy risks, missing input validation, and rounding errors, it fails to mention the critical issue of not validating the return value of `transferFrom()`. This omission is significant as it directly impacts the contract's security and reliability when interacting with ERC20 tokens.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] ERC20 transferFrom return values not checked**

---

This analysis highlights a critical gap in the response list, as it does not address the issue of unchecked `transferFrom()` return values, which is a significant security concern in Solidity smart contracts.",0,0,1,11,"```
None.
```",0.0,0
Splitter.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/**
 * @title Splitter
 * Building on the work from the Uniswap team at Uniswap and mirror.xyz Team
 */
contract Splitter is SplitStorage {
    /**** Mutable variables ****/
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    // The TransferETH event is emitted after each eth transfer in the split is attempted.
    event TransferETH(
        // The account to which the transfer was attempted.
        address account,
        // The amount for transfer that was attempted.
        uint256 amount,
        // Whether or not the transfer succeeded.
        bool success
    );

    // Emits when a window is incremented.
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    /**
     * @dev Claim the funds from the all windows.
     * @param percentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        // Make sure that the user has this allocation granted.
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    /**
     * @dev get Node hash of given data.
     * @param who {address} whitelisted user address
     * @param percentageAllocation {uint256} percentage of allocation
     * @return {bytes32} node hash
     */
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    /**
     * @dev get scaled amount from given amount and percentage.
     * @param amount {uint256} amount
     * @param scaledPercent {uint256} scaled percentage
     * @return scaledAmount {uint256} scaled amount
     */
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        /*
            Example:
                If there is 100 ETH in the account, and someone has 
                an allocation of 2%, we call this with 100 as the amount, and 200
                as the scaled percent.

                To find out the amount we use, for example: (100 * 200) / (100 * 100)
                which returns 2 -- i.e. 2% of the 100 ETH balance.
         */
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    /**
     * @dev claim for the given window.
     * @param window {uint256} Window to claim
     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed
     * @param merkleProof {bytes32} The Merkle proof of the allocation
     */
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            // The absolute amount that's claimable.
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    /**
     * @dev Function which handles increment window and puts amount to current window
     * @param royaltyAmount {uint256} Amount needs to be added in window.
     * @return {bool} Whether or not the window was incremented.
     */
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bool} Whether or not the window has been claimed.
     */
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    /**** Private Functions ****/

    /**
     * @dev Function checks if the given window and tokenId has been claimed.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     */
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    /**
     * @dev Function which returns the hash of the given window, tokenId and membershipContract.
     * @param who {address} whitelisted user address
     * @param window {uint256} Window to check
     * @return {bytes32} Hash of the given window, tokenId and membershipContract.
     */
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    /**
     * @dev Function to convert output amount from percentages.
     * @param amount {uint256} Amount for which percentage is to be calculated.
     * @param percent {uint256} Percentage
     * @return {uint256} Output amount.
     */
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        // Solidity 0.8.0 lets us do this without SafeMath.
        return (amount * percent) / 100;
    }

    /**
     * @dev Function to transfer split asset to the given address.
     * @param to {address} Address to transfer the split asset to.
     * @param value {uint256} Amount to transfer.
     */
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        // Try to transfer ETH to the given recipient.
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    /**
     * @dev transfer given amount of ETH in contract to the given address.
     * @param to {address} Address to transfer asset
     * @param value {uint256} Amount to transfer
     * @return {bool} Whether or not the transfer was successful.
     */
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        // Here increase the gas limit a reasonable amount above the default, and try
        // to send ETH to the recipient.
        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol
    /**
     * @dev Function to verify the given proof.
     * @param proof {bytes32[]} Proof to verify
     * @param root {bytes32} Root of the Merkle tree
     * @param leaf {bytes32} Leaf to verify
     * @return {bool} Whether or not the proof is valid.
     */
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        // Check if the computed hash (root) is equal to the provided root
        return computedHash == root;
    }
}",2162.0,293.0,"[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract
In general, the Splitter contract's `incrementWindow` function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the `incrementWindow` function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or `claimForAllWindows ` functions to steal the tokens in the contract.

[H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker
When the value of currentWindow is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.
currentWindow can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.
Furthermore, an attacker can continually increment currentWindow by calling `incrementWindow()`. An attacker can impersonate a IRoyaltyVault and send 1 WEI worth of WETH to pass the required checks.

[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient
The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the receive() function. As a result the user would be unable to receive funds from this function.",3.0,"pragma solidity ^0.8.4;

import {SplitStorage} from ""./SplitStorage.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";


contract Splitter is SplitStorage {
    
    uint256 public constant PERCENTAGE_SCALE = 10e5;
    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

    
    event TransferETH(
        
        address account,
        
        uint256 amount,
        
        bool success
    );

    
    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);

    
    function claimForAllWindows(
        uint256 percentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        
        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, percentageAllocation)
            ),
            ""Invalid proof""
        );

        uint256 amount = 0;
        for (uint256 i = 0; i < currentWindow; i++) {
            if (!isClaimed(msg.sender, i)) {
                setClaimed(msg.sender, i);

                amount += scaleAmountByPercentage(
                    balanceForWindow[i],
                    percentageAllocation
                );
            }
        }

        transferSplitAsset(msg.sender, amount);
    }

    
    function getNode(
        address who,
        uint256 percentageAllocation
    ) private pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    who,
                    percentageAllocation
                )
            );
    }

    
    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)
        public
        pure
        returns (uint256 scaledAmount)
    {
        
        scaledAmount = (amount * scaledPercent) / (10000);
    }

    
    function claim(
        uint256 window,
        uint256 scaledPercentageAllocation,
        bytes32[] calldata merkleProof
    ) external {
        require(currentWindow > window, ""cannot claim for a future window"");
        require(
            !isClaimed(msg.sender, window),
            ""NFT has already claimed the given window""
        );

        setClaimed(msg.sender, window);

        require(
            verifyProof(
                merkleProof,
                merkleRoot,
                getNode(msg.sender, scaledPercentageAllocation)
            ),
            ""Invalid proof""
        );

        transferSplitAsset(
            msg.sender,
            
            scaleAmountByPercentage(
                balanceForWindow[window],
                scaledPercentageAllocation
            )
        );
    }

    
    function incrementWindow(uint256 royaltyAmount) public returns (bool) {
        uint256 wethBalance;

        require(
            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
            ""Royalty Vault not supported""
        );
        require(
            IRoyaltyVault(msg.sender).getSplitter() == address(this),
            ""Unauthorised to increment window""
        );

        wethBalance = IERC20(splitAsset).balanceOf(address(this));
        require(wethBalance >= royaltyAmount, ""Insufficient funds"");

        require(royaltyAmount > 0, ""No additional funds for window"");
        balanceForWindow.push(royaltyAmount);
        currentWindow += 1;
        emit WindowIncremented(currentWindow, royaltyAmount);
        return true;
    }

    
    function isClaimed(
        address who,
        uint256 window
    ) public view returns (bool) {
        return claimed[getClaimHash(who, window)];
    }

    

    
    function setClaimed(
        address who,
        uint256 window
    ) private {
        claimed[getClaimHash(who, window)] = true;
    }

    
    function getClaimHash(
        address who,
        uint256 window
    ) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(who, window));
    }

    
    function amountFromPercent(uint256 amount, uint32 percent)
        private
        pure
        returns (uint256)
    {
        
        return (amount * percent) / 100;
    }

    
    function transferSplitAsset(address to, uint256 value)
        private
        returns (bool didSucceed)
    {
        
        didSucceed = IERC20(splitAsset).transfer(to, value);
        require(didSucceed, ""Failed to transfer ETH"");

        emit TransferETH(to, value, didSucceed);
    }

    
    function attemptETHTransfer(address to, uint256 value)
        private
        returns (bool)
    {
        
        
        
        (bool success, ) = to.call{value: value, gas: 30000}("""");
        return success;
    }

    
    
    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) private pure returns (bool) {
        bytes32 computedHash = leaf;

        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];

            if (computedHash <= proofElement) {
                
                computedHash = keccak256(
                    abi.encodePacked(computedHash, proofElement)
                );
            } else {
                
                computedHash = keccak256(
                    abi.encodePacked(proofElement, computedHash)
                );
            }
        }

        
        return computedHash == root;
    }
}",1136.0,2,1,"Based on the provided smart contract code, here's a breakdown of potential vulnerabilities and areas of concern:

**1. Integer Overflow/Underflow in `scaleAmountByPercentage`:**

*   **Description:** The `scaleAmountByPercentage` function performs multiplication and division.  While using Solidity 0.8.x and above provides default overflow/underflow protection, the result of `amount * scaledPercent` could still potentially exceed the maximum value of `uint256` *before* the division, leading to unexpected results after the automatic revert.
*   **Impact:** Incorrect calculation of claimable amounts, potentially leading to users receiving less or more than intended. In extreme cases, could lead to denial of service if the revert happens unpredictably.
*   **Mitigation:**
    *   Consider using SafeMath-like libraries even in Solidity 0.8.x for explicit overflow/underflow handling, to control the behaviour in case this happens.

**2. Division by Zero in `scaleAmountByPercentage`:**

*   **Description:** While less likely, if `amount * scaledPercent` leads to a 0 value due to other reasons, the division by `10000` won't pose an issue.
*   **Impact:** None
*   **Mitigation:**
    *   No mitigation required as it does not cause issues.

**3. Reentrancy (Indirect via `transferSplitAsset`)**

*   **Description:** The `transferSplitAsset` function calls `IERC20(splitAsset).transfer(to, value)`.  If the `splitAsset` is a malicious ERC20 token, its `transfer` function could execute arbitrary code, potentially calling back into the `Splitter` contract *before* the `transfer` function returns and the state is fully updated (e.g., before `setClaimed` takes effect). While not immediately apparent, the standard ERC20 `transfer` is generally safe, but malicious or customized implementations can introduce reentrancy vulnerabilities.
*   **Impact:**
    *   Possible double-spending: A malicious ERC20 token could re-trigger the claim logic before the original claim is recorded.
    *   Unexpected state changes.
*   **Mitigation:**
    *   **Checks-Effects-Interactions Pattern:** Strictly adhere to this pattern. Ensure state updates (e.g., updating `claimed` status) happen *before* calling external contracts like `IERC20(splitAsset).transfer`.  In this case, `setClaimed` is already happening before `transferSplitAsset`, mitigating some direct reentrancy risks.
    *   **Reentrancy Guard:** Implement a reentrancy guard using a mutex-like approach (e.g., using a boolean variable) to prevent recursive calls into the critical sections of the contract.  Consider the OpenZeppelin `ReentrancyGuard` contract.
    *   **Consider ""Pull"" Pattern:**  Instead of pushing tokens to the recipient, consider having users *pull* their tokens.  This eliminates the direct call to the recipient's address.  This may not be practical depending on the workflow.
    *   **Limit Gas:**  While potentially affecting legitimate use cases, limiting the gas available for external calls can mitigate reentrancy attacks.  However, this is a less reliable mitigation.
    *   **Trust the ERC20?**  Carefully consider the ERC20 token used as `splitAsset`. If the ERC20 token is not well-audited or has a known malicious implementation, the risks increase significantly.

**4. Inaccurate scaling by percentage:**

*   **Description:** The `scaleAmountByPercentage` function divides by `10000`, while the percentage scale is `10e5` (1000000). This would lead to inaccurate results.
*   **Impact:** Incorrect calculation of claimable amounts, potentially leading to users receiving less or more than intended.
*   **Mitigation:**
    *   Modify the divisor in `scaleAmountByPercentage` from `10000` to `PERCENTAGE_SCALE` or `1000000`.

**5. Potential Gas Limit Issues with Large Merkle Proofs:**

*   **Description:**  The `claim` and `claimForAllWindows` functions take a `merkleProof` as input.  Large Merkle proofs can consume significant gas, potentially exceeding the block gas limit and causing transactions to fail.
*   **Impact:** Denial of service for users with deep Merkle tree paths.
*   **Mitigation:**
    *   **Limit Tree Depth:** Impose a reasonable limit on the maximum depth of the Merkle tree used to generate the proofs.  Document this limitation.
    *   **Gas Optimization:** Carefully optimize the `verifyProof` function to reduce gas consumption.  This might involve using more efficient data structures or algorithms.  However, Merkle proof verification is generally computationally intensive.
    *   **Off-Chain Proof Generation:** Explore alternatives to providing the entire Merkle proof on-chain.  Consider zero-knowledge proofs (zk-SNARKs or zk-STARKs), but these introduce significant complexity.
    *   **Batching:** Allow users to claim for multiple addresses in a single transaction.  This reduces the overhead of the transaction but increases the gas cost for each transaction.

**6. Authorization Issues in `incrementWindow`**

*   **Description:** The `incrementWindow` function checks if the `msg.sender` supports the `IID_IROYALTY` interface and if the `IRoyaltyVault(msg.sender).getSplitter()` is equal to the contract address. However, there's no explicit check to ensure that the `msg.sender` is the intended RoyaltyVault contract. A malicious contract could implement the `IRoyaltyVault` interface and claim to be associated with the `Splitter`.
*   **Impact:** Unauthorized entities can increment the window, potentially disrupting the distribution process.
*   **Mitigation:**
    *   Store the address of the allowed RoyaltyVault contract in a state variable and explicitly check that `msg.sender` is equal to this stored address in `incrementWindow`.

**7. Revert in `transferSplitAsset` can block `claim` and `claimForAllWindows`**

*   **Description:** If the target address of the transfer has a malicious contract and the `transfer` call to it fails, the require statement will revert the entire `claim` or `claimForAllWindows` call. In this case, the user loses the gas but does not receive the claimed amount
*   **Impact:** Loss of gas for the user.
*   **Mitigation:**
    *   Transfer tokens and handle reverts in `transferSplitAsset` using a try/catch statement, then refund the user their percentage amounts in the event of a failure, to ensure that gas is not lost.
    *   Implement a blacklist and prevent transfers to addresses known to revert transfers.

**8. Using block.timestamp for any sort of randomness or time-sensitive logic:**

*   **Description:** The `block.timestamp` is known to be miner manipulatable. If the logic of your code depends on this for proper execution it is vulnerable.
*   **Impact:** Unexpected behaviour.
*   **Mitigation:**
    *   Don't use `block.timestamp`

**9. Potential Rounding Errors in `amountFromPercent`:**

*   **Description:** The `amountFromPercent` function calculates a percentage of an amount using integer division. This can lead to rounding errors, where the result is slightly less than the true percentage due to truncation.
*   **Impact:** Minor inaccuracies in calculations. Users may receive slightly less than the intended percentage.
*   **Mitigation:**
    *   If precision is critical, consider using a library for fixed-point arithmetic to handle fractional values more accurately. Alternatively, you can multiply first and then divide to minimize truncation: `return (amount * percent) / 100;`

**10. Inefficient Gas Usage in `verifyProof`:**

*   **Description:** The `verifyProof` function iterates through the `proof` array and performs hash calculations in each iteration.  The order of the `if` and `else` blocks, which perform hash calculation based on the comparison of `computedHash` and `proofElement`, involves comparing two variables stored in memory and then deciding which hash calculation to perform, making it less gas efficient.
*   **Impact:** Higher gas cost for verifying Merkle proofs, which can impact the overall cost of using the contract.
*   **Mitigation:**
    *   Consider re-arranging the hashing logic to perform one hash calculation and then assign to `computedHash`.

**Important Considerations:**

*   **Formal Verification:** For critical smart contracts, consider formal verification to mathematically prove the absence of certain vulnerabilities.
*   **Audits:** Engage reputable security auditors to thoroughly review the code and identify potential weaknesses.
*   **Testing:** Write comprehensive unit and integration tests to cover all possible scenarios and edge cases.
*   **Immutability:** Once deployed, smart contracts are generally immutable. Thoroughly test and audit before deployment.

Remember that this is not an exhaustive list. A professional security audit is crucial for identifying all potential vulnerabilities.","### **Comparison of Issue Report and Response List**

---

#### **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**

**Report Description**:  
The `incrementWindow` function in the Splitter contract can be called by anyone using a fake RoyaltyVault contract. This allows an attacker to manipulate the `balanceForWindow` value, making it greater than the actual contract balance. Verified users can then exploit this discrepancy to steal tokens by calling the `claim` or `claimForAllWindows` functions.

**Match in Response List**:  
Matches with the issue titled **""Authorization Issues in `incrementWindow`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unauthorized access to the `incrementWindow` function. It correctly explains the risks of a malicious contract impersonating the RoyaltyVault and suggests storing the allowed RoyaltyVault address in a state variable to mitigate the issue. This aligns with Solidity best practices for access control.

---

#### **[H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker**

**Report Description**:  
An attacker can repeatedly call `incrementWindow` to raise the `currentWindow` value, eventually making `claimForAllWindows` unusable due to the block gas limit. This can be achieved by impersonating an `IRoyaltyVault` and sending 1 WEI of WETH to bypass checks.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the specific DoS vulnerability caused by incrementing `currentWindow` to exhaust the block gas limit. This is a critical oversight, as it leaves the contract vulnerable to denial-of-service attacks.

---

#### **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

**Report Description**:  
The `attemptETHTransfer` function sends a fixed amount of gas (30,000) in its call. If the receiver is a contract, this may be insufficient to process the `receive()` function, preventing users from receiving funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of insufficient gas in `attemptETHTransfer`. This oversight could lead to failed transactions and user dissatisfaction, as the contract does not account for varying gas requirements of receiver contracts.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Splitter: Anyone can call incrementWindow to steal the tokens in the contract**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-03] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker**
- **[M-02] Fixed Amount of Gas Sent in Call May Be Insufficient**

---

### **Conclusion**

The response list effectively addresses the **authorization issue in `incrementWindow`** but misses critical vulnerabilities related to **DoS attacks** and **insufficient gas in `attemptETHTransfer`**. These gaps highlight the need for a more comprehensive review of the contract's gas usage and potential attack vectors. A professional security audit is strongly recommended to identify and mitigate these vulnerabilities.",1,0,2,10,"```
1. Authorization Issues in `incrementWindow`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is `Authorization Issues in incrementWindow`.
   - This appears at rank **6** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - At rank 6, there is 1 true positive.
   - \( P@6 = \frac{1}{6} \approx 0.1667 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the AP is simply \( P@6 \).

**Average Precision (AP)**:
```
0.1667
```",0.1667
CoreCollection.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    // ----------------- MODIFIER -----------------

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    // ----------------- EXTERNAL -----------------

    /**
     * @notice Initializes the collection
     * @dev This method is being called from the CoreFactory contract
     * @param _collectionName Name of the collection
     * @param _collectionSymbol Symbol of the collection
     * @param _collectionURI Base URI for the collection
     * @param _maxSupply The maximum number of tokens that can be minted
     * @param _mintFee The price of a token in this collection
     * @param _payableToken The address of the ERC20 this collection uses to settle transactions
     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed
     * @param _splitFactory base URI for the collection
     */
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    /**
     * @notice Allows the collection owner to airdrop tokens
     * @dev The Merkle tree defines for each address how much token can be claimed
     * @dev This method can only be called once
     * @param _root A Merkle root
     */
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    /**
     * @notice Allows the collection owner to change the collection's name and symbol
     * @dev This function is only callable by the collection's owner
     * @param _collectionName A collection name
     * @param _collectionSymbol A collection symbol
     */
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    /**
     * @notice This function is called to mint tokens from this ERC721 collection
     * @dev The collection must be initialized first
     * @param to Token recipient
     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token
     * @param claimableAmount The amount of tokens the user has been airdropped
     * @param amount The amount of tokens the user wants to mint
     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token
     */
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    /**
     * @notice Allows the contract owner to withdraw the funds generated by the token sales
     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner
     */
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    /**
     * @notice Set royalty vault address for collection
     * @dev All revenue (Primary sales + royalties from secondardy sales) 
     * from the collection are transferred to the vault when the vault is initialized
     * @param _royaltyVault The address of the royalty vault
     */
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    /**
     * @notice Set a provenance hash
     * @dev This hash is used to verify the minting ordering of a collection (à la BAYC)
     * This hash is generated off-chain
     * @param _proof The SHA256 generated hash
     */
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    // ----------------- PUBLIC -----------------

    /**
     * @notice Set the mint starting index
     * @dev The starting index can only be generated once
     */
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    // ---------------- VIEW ----------------

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    // ---------------- PRIVATE ----------------

    /**
     * @notice Mint token
     * @dev A starting index is calculated at the time of first mint
     * returns a tokenId
     * @param _to Token recipient
     */
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    /**
     * @notice Mint tokens in batch
     * @param _to Token recipient
     * @param _amount Number of tokens to include in batch
     * @param _isClaim Whether the batch mint is an airdrop or not
     */
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    // ---------------- INTERNAL ----------------

    /**
     * @notice This hook transfers tokens sitting in the royalty vault to the split contract
     * @dev The split contract is a contract that allows a team to share revenue together
     * @param _from Transfer sender
     * @param _to Transfer recipient
     * @param _tokenId TokenId of token being transferred
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",2331.0,310.0,"[H-04] CoreCollection can be reinitialized
Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn't control for it, so the function can be rerun multiple times.
Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.
However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.

[H-07] Duplicate NFTs Can Be Minted if payableToken Has a Callback Attached to it
The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the payableToken is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because totalSupply() has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply check`. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.

[H-08] Funds cannot be withdrawn in CoreCollection.withdraw
The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the msg.sender ( who is the owner of the contract). The usage of transferFrom can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the withdraw function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.",3.0,"pragma solidity ^0.8.0;

import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {ERC721} from ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
import {ERC721Enumerable} from ""@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

import {ERC721Payable} from ""./ERC721Payable.sol"";
import {ERC721Claimable} from ""./ERC721Claimable.sol"";
import {IRoyaltyVault} from ""@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol"";

contract CoreCollection is
    Ownable,
    ERC721Claimable,
    ERC721Enumerable,
    ERC721Payable
{
    bool public initialized;
    string private _name;
    string private _symbol;
    string private _baseUri;
    uint256 public maxSupply;
    uint256 public startingIndex;
    uint256 public startingIndexBlock;
    string public HASHED_PROOF = """";

    event ClaimInitialized(bytes32 root);
    event NewCollectionMeta(string name, string symbol);
    event NewClaim(address claimedBy, address to, uint256 tokenId);
    event StartingIndexSet(uint256 index);
    event RoyaltyVaultInitialized(address royaltyVault);
    event NewHashedProof(string proof);
    event NewWithdrawal(address to, uint256 amount);

    constructor() ERC721("""", """") {}

    

    modifier onlyInitialized() {
        require(initialized, ""CoreCollection: Not initialized"");
        _;
    }

    modifier onlyUnInitialized() {
        require(!initialized, ""CoreCollection: Already initialized"");
        _;
    }

    modifier onlyValidSupply(uint256 _maxSupply) {
        require(
            _maxSupply > 0,
            ""CoreCollection: Max supply should be greater than 0""
        );
        _;
    }

    modifier tokenExists(uint256 _tokenId) {
        require(_exists(_tokenId), ""CoreCollection: Invalid token id"");
        _;
    }

    

    
    function initialize(
        string memory _collectionName,
        string memory _collectionSymbol,
        string memory _collectionURI,
        uint256 _maxSupply,
        uint256 _mintFee,
        address _payableToken,
        bool _isForSale,
        address _splitFactory
    ) external onlyOwner onlyValidSupply(_maxSupply) {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        _baseUri = _collectionURI;
        maxSupply = _maxSupply;
        mintFee = _mintFee;
        payableToken = IERC20(_payableToken);
        isForSale = _isForSale;
        splitFactory = _splitFactory;
        initialized = true;
    }

    
    function initializeClaims(bytes32 _root)
        external
        onlyOwner
        onlyNotClaimableSet
        onlyValidRoot(_root)
    {
        _setMerkelRoot(_root);
        emit ClaimInitialized(_root);
    }

    
    function setCollectionMeta(
        string memory _collectionName,
        string memory _collectionSymbol
    ) external onlyOwner {
        _name = _collectionName;
        _symbol = _collectionSymbol;
        emit NewCollectionMeta(_collectionName, _collectionSymbol);
    }

    
    function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }

    
    function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }

    
    function setRoyaltyVault(address _royaltyVault)
        external
        onlyVaultUninitialized
    {
        require(
            msg.sender == splitFactory || msg.sender == owner(),
            ""CoreCollection: Only Split Factory or owner can initialize vault.""
        );
        royaltyVault = _royaltyVault;
        emit RoyaltyVaultInitialized(_royaltyVault);
    }

    
    function setHashedProof(string calldata _proof) external onlyOwner {
        require(
            bytes(HASHED_PROOF).length == 0,
            ""CoreCollection: Hashed Proof is set""
        );

        HASHED_PROOF = _proof;
        emit NewHashedProof(_proof);
    }

    

    
    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        startingIndex =
            (uint256(
                keccak256(abi.encodePacked(""CoreCollection"", block.number))
            ) % maxSupply) +
            1;
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }

    

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function baseURI() public view returns (string memory) {
        return _baseUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseUri;
    }

    

    
    function mint(address _to) private returns (uint256 tokenId) {
        if (startingIndex == 0) {
            setStartingIndex();
        }
        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;
        _mint(_to, tokenId);
    }

    
    function batchMint(
        address _to,
        uint256 _amount,
        bool _isClaim
    ) private {
        for (uint256 i = 0; i < _amount; i++) {
            uint256 tokenId = mint(_to);
            if (_isClaim) {
                emit NewClaim(msg.sender, _to, tokenId);
            }
        }
    }

    

    
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(_from, _to, _tokenId);

        if (
            royaltyVault != address(0) &&
            IRoyaltyVault(royaltyVault).getVaultBalance() > 0
        ) {
            IRoyaltyVault(royaltyVault).sendToSplitter();
        }
    }
}",1528.0,3,0,"Okay, here's an analysis of potential vulnerabilities in the provided smart contract code, along with explanations and recommendations.

**Critical/High Severity Vulnerabilities**

*   **1. Missing Access Control on `setRoyaltyVault`:**

    *   **Vulnerability:** The `setRoyaltyVault` function is intended to be callable by the `splitFactory` address or the contract owner. However, there's a critical vulnerability:  The modifier `onlyVaultUninitialized` does not check if the `royaltyVault` is the zero address when setting it. This could allow anyone to front-run setting the `royaltyVault` to a malicious address, directing funds to an attacker.
    *   **Impact:** An attacker could potentially set the `royaltyVault` to an address they control, siphoning off royalties intended for the intended recipient.
    *   **Recommendation:**

        ```solidity
        function setRoyaltyVault(address _royaltyVault)
            external
            onlyVaultUninitialized
        {
            require(
                msg.sender == splitFactory || msg.sender == owner(),
                ""CoreCollection: Only Split Factory or owner can initialize vault.""
            );
            require(_royaltyVault != address(0), ""CoreCollection: Royalty vault can't be zero address.""); // Add this check
            royaltyVault = _royaltyVault;
            emit RoyaltyVaultInitialized(_royaltyVault);
        }

        modifier onlyVaultUninitialized {
            require(royaltyVault == address(0), ""CoreCollection: Royalty vault already initialized"");
            _;
        }
        ```

*   **2. `withdraw` Function Missing Safe Transfer:**

    *   **Vulnerability:** The `withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount);`. While it uses `transferFrom`, it doesn't account for the possibility that the `payableToken` might be a token that doesn't properly return a boolean value indicating success or failure (or worse, reverts on failure).  This can lead to stuck funds. `transferFrom` also can be front-run, which could lead to a loss of funds.
    *   **Impact:**  If the `payableToken` is non-standard (e.g., an older ERC20 implementation), the `transferFrom` call might fail without reverting the transaction. This would leave the contract's state inconsistent (the contract's balance is reduced, but the user doesn't receive the funds).
    *   **Recommendation:** Use OpenZeppelin's `SafeERC20` library to ensure safe token transfers.

        ```solidity
        import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

        contract CoreCollection is
            Ownable,
            ERC721Claimable,
            ERC721Enumerable,
            ERC721Payable
        {
            using SafeERC20 for IERC20;

            function withdraw() external onlyOwner {
                uint256 amount = payableToken.balanceOf(address(this));
                payableToken.safeTransferFrom(address(this), msg.sender, amount); // Use safeTransfer
                emit NewWithdrawal(msg.sender, amount);
            }
        }
        ```

**Medium Severity Vulnerabilities**

*   **3. `_beforeTokenTransfer` potential Reentrancy and DoS risk:**

    *   **Vulnerability:** `_beforeTokenTransfer` calls an external contract (`IRoyaltyVault.sendToSplitter()`).  External calls are always a potential source of reentrancy vulnerabilities.  If the `sendToSplitter` function re-enters the `CoreCollection` contract, it could lead to unexpected behavior. If `sendToSplitter` fails, it will revert the transfer, causing a DoS.
    *   **Impact:**  A malicious royalty vault could potentially re-enter and manipulate the contract's state during token transfers.
    *   **Recommendation:**

        *   **Reentrancy Prevention:** Use a reentrancy guard (e.g., OpenZeppelin's `ReentrancyGuard`) around the call to `IRoyaltyVault.sendToSplitter()`.  Alternatively, consider a ""pull"" based approach where the contract initiates the transfer and the user needs to withdraw funds, eliminating the reentrancy point in `_beforeTokenTransfer`.
        *   **Consider Alternatives to sendToSplitter**: Ensure the `sendToSplitter` is implemented in a secure manner.
        *   **Error Handling:** Wrap the `sendToSplitter` call in a `try...catch` block to prevent reverts from breaking token transfers.

        ```solidity
        import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";

        contract CoreCollection is
            Ownable,
            ERC721Claimable,
            ERC721Enumerable,
            ERC721Payable,
            ReentrancyGuard
        {

            function _beforeTokenTransfer(
                address _from,
                address _to,
                uint256 _tokenId
            ) internal virtual override {
                super._beforeTokenTransfer(_from, _to, _tokenId);

                if (
                    royaltyVault != address(0) &&
                    IRoyaltyVault(royaltyVault).getVaultBalance() > 0
                ) {
                    try IRoyaltyVault(royaltyVault).sendToSplitter() nonReentrant {
                        // Success!
                    } catch (bytes memory reason) {
                        // Handle the error.  Log it, emit an event, or revert.
                        // Reverting might be undesirable as it prevents the token transfer.
                        emit RoyaltySplitterFailed(reason); // Emit an event
                        // Optionally, revert with a more informative error message:
                        // revert(""Royalty splitter failed"");
                    }
                }
            }

            event RoyaltySplitterFailed(bytes reason);
        }
        ```

*   **4. Lack of Input Validation on `_maxSupply` During Initialization:**

    *   **Vulnerability:** Although the `onlyValidSupply` modifier checks if `_maxSupply > 0`, it doesn't prevent a very large `_maxSupply` from being set. This could potentially lead to issues later on (e.g., integer overflows when calculating token IDs, or the contract running out of gas during minting operations if the supply is excessively large).
    *   **Impact:** Unpredictable behavior and potential denial-of-service attacks.
    *   **Recommendation:** Add a reasonable upper bound to the `_maxSupply` value in the `initialize` function.

        ```solidity
        function initialize(
            string memory _collectionName,
            string memory _collectionSymbol,
            string memory _collectionURI,
            uint256 _maxSupply,
            uint256 _mintFee,
            address _payableToken,
            bool _isForSale,
            address _splitFactory
        ) external onlyOwner onlyValidSupply(_maxSupply) {
            require(_maxSupply <= 10000, ""CoreCollection: Max supply exceeds limit""); // Example limit
            _name = _collectionName;
            _symbol = _collectionSymbol;
            _baseUri = _collectionURI;
            maxSupply = _maxSupply;
            mintFee = _mintFee;
            payableToken = IERC20(_payableToken);
            isForSale = _isForSale;
            splitFactory = _splitFactory;
            initialized = true;
        }
        ```

*   **5. Starting Index Calculation Vulnerability**

    *   **Vulnerability:** The starting index is calculated using `keccak256(abi.encodePacked(""CoreCollection"", block.number))`. This calculation makes the starting index predictable. An attacker could potentially predict future token IDs.
    *   **Impact:** This lack of randomness in the starting index could be exploited to strategically mint specific token IDs.
    *   **Recommendation:**  Use a more unpredictable source of randomness like Chainlink VRF or a similar solution. Be aware that using `block.timestamp` is also predictable.

    ```solidity
    // Example using Chainlink VRF (simplified)
    // This is a high-level concept; integration requires more detailed code.

    // Assume you have a way to request and receive a random number from VRF

    uint256 private randomNumber;
    bool private randomNumberReceived;

    event RandomNumberReceived(uint256 randomNumber);

    function requestRandomNumber() external onlyOwner {
        // Request a random number from Chainlink VRF
        // (Implementation details depend on the VRF service)
        // ...
    }

    function fulfillRandomness(uint256 _requestId, uint256 _randomNumber) internal {
        require(msg.sender == VRFCoordinatorAddress, ""Only VRF can fulfill"");
        randomNumber = _randomNumber;
        randomNumberReceived = true;
        emit RandomNumberReceived(_randomNumber);
    }

    function setStartingIndex() public {
        require(
            startingIndex == 0,
            ""CoreCollection: Starting index is already set""
        );

        require(randomNumberReceived, ""CoreCollection: Random number not received yet"");

        startingIndex = (randomNumber % maxSupply) + 1;  // Use the random number
        startingIndexBlock = uint256(block.number);
        emit StartingIndexSet(startingIndex);
    }
    ```

**Low Severity/Informational**

*   **6.  `setHashedProof` could be set to empty string:**

    *   **Vulnerability:** The function does not prevent setting `HASHED_PROOF` to an empty string after it has already been set.
    *   **Impact:** This could be confusing or lead to unexpected behavior if the contract logic relies on `HASHED_PROOF` always having a value after initialization.
    *   **Recommendation:** Add a check to ensure the string is not empty.

        ```solidity
        function setHashedProof(string calldata _proof) external onlyOwner {
            require(
                bytes(HASHED_PROOF).length == 0,
                ""CoreCollection: Hashed Proof is set""
            );

            require(bytes(_proof).length > 0, ""CoreCollection: Proof cannot be empty"");

            HASHED_PROOF = _proof;
            emit NewHashedProof(_proof);
        }
        ```

*   **7.  Lack of Input Validation on `mintToken` Amount:**

    *   **Vulnerability:** The `mintToken` function requires `amount > 0`, but it doesn't prevent an extremely large `amount` from being passed (as long as it's within the `maxSupply`).
    *   **Impact:** This could potentially lead to gas limit issues during minting, especially if `batchMint` is called with a very large amount.
    *   **Recommendation:** Add a reasonable upper bound to the `amount` parameter in the `mintToken` function to limit the number of tokens minted in a single transaction.

        ```solidity
        function mintToken(
            address to,
            bool isClaim,
            uint256 claimableAmount,
            uint256 amount,
            bytes32[] calldata merkleProof
        ) external onlyInitialized {
            require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
            require(amount <= 20, ""CoreCollection: Max mint amount is 20""); // Example
            require(
                totalSupply() + amount <= maxSupply,
                ""CoreCollection: Over Max Supply""
            );

            // ... rest of the function
        }
        ```

*   **8.  Missing Events for Important State Changes:**

    *   **Vulnerability:** The contract doesn't emit events for every important state change.
    *   **Impact:** It becomes harder to track the contract's behavior and debug issues off-chain.
    *   **Recommendation:** Emit events whenever key state variables are modified (e.g., when `mintFee` or `isForSale` are changed, assuming these are managed elsewhere).

*   **9.  Unused `onlyUnInitialized` Modifier:**

    *   **Vulnerability:** The `onlyUnInitialized` modifier is defined but never used.
    *   **Impact:** Unnecessary code that could be removed.
    *   **Recommendation:** Remove the `onlyUnInitialized` modifier.

**General Security Best Practices**

*   **Regular Audits:** Have the contract audited by a reputable security firm before deploying to a production environment.
*   **Formal Verification:** Consider using formal verification tools to mathematically prove the correctness of the contract's logic.
*   **Testing:** Write thorough unit tests and integration tests to cover all possible scenarios.  Include tests that specifically target edge cases and potential vulnerabilities.
*   **Gas Optimization:**  Optimize the contract's code to reduce gas consumption.
*   **Dependencies:** Keep all dependencies (e.g., OpenZeppelin contracts) up to date.

By addressing these vulnerabilities and following security best practices, you can significantly improve the security and reliability of your smart contract. Remember that smart contract security is an ongoing process, and continuous monitoring and improvement are essential.","### **Output**

---

### **[H-04] CoreCollection can be reinitialized**

**Report Description**:  
The `initialize` function in `CoreCollection` sets the `initialized` flag but does not check if the contract has already been initialized. This allows the function to be rerun multiple times, potentially resetting critical variables like `payableToken`. While the function is `onlyOwner`, the risk remains that the owner could reset the contract either by mistake or maliciously, leading to system-breaking consequences.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of reinitialization in `CoreCollection`. This is a critical oversight, as reinitialization can lead to severe consequences, including the resetting of core variables and potential fund loss.

---

### **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**

**Report Description**:  
The `mintToken()` function allows users to mint NFTs by either providing a merkle proof or paying a fee in `payableToken`. However, because the `payableToken` is paid before the token is minted, a callback attached to the token transfer could reenter the `mintToken()` function. This bypasses the `totalSupply() + amount <= maxSupply` check, allowing duplicate NFTs to be minted if the user mints the last token.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the reentrancy vulnerability in `mintToken()`. This is a high-severity issue, as it allows for the minting of duplicate NFTs, which could undermine the integrity of the NFT collection.

---

### **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Report Description**:  
The `withdraw` function in `CoreCollection` uses `payableToken.transferFrom(address(this), msg.sender, amount)`. However, this call will revert because the `allowance[CoreCollection][CoreCollection]` is zero. This prevents the owner from withdrawing funds, leaving them locked in the contract indefinitely.

**Match in Response List**:  
Matches with the issue titled **""`withdraw` Function Missing Safe Transfer""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `transferFrom` but focuses on the potential for stuck funds due to non-standard ERC20 tokens. It does not address the core issue of the `allowance` being zero, which prevents the withdrawal from succeeding. The recommendation to use `SafeERC20` is relevant but incomplete, as it does not solve the `allowance` problem.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-08] Funds cannot be withdrawn in `CoreCollection.withdraw`**

**Missed Issues from Issue Report**:  
- **[H-04] CoreCollection can be reinitialized**  
- **[H-07] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it**

---

### **Conclusion**  
The response list partially addresses one issue but misses two critical vulnerabilities. The lack of coverage for reinitialization and reentrancy in `mintToken()` is a significant gap, as these issues can lead to severe consequences, including fund loss and NFT collection integrity breaches. The response list should be expanded to include these vulnerabilities, with specific recommendations to mitigate them.",0,1,2,9,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and the average of these values is also 0.",0
RoyaltyVault.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    /**** Events ****/
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    /**
     * @dev Getting royaltyAsset balance of Vault.
     */
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    /**
     * @dev Send accumulated royalty to splitter.
     */
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    /**
     * @dev Set Platform fee for collection contract.
     * @param _platformFee Platform fee in scaled percentage.
     */
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    /**
     * @dev Set Platform fee recipient for collection.
     * @param _platformFeeRecipient Platform fee recipient address
     */
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    /**
     * @dev Get Splitter address of proxyVault.
     */
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    /**
     * @dev Checks for support of IRoyaltyVault.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",751.0,104.0,"[H-01] ERC20 transferFrom return values not checked
The transferFrom() function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.

[H-05] Centralisation RIsk: Owner Of RoyaltyVault Can Take All Funds
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.
As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.

[H-09] ERC20 tokens with no return value will fail to transfer
Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.",3.0,"pragma solidity ^0.8.4;

import {IRoyaltyVault} from ""../interfaces/IRoyaltyVault.sol"";
import {VaultStorage} from ""./VaultStorage.sol"";
import {ISplitter} from ""../interfaces/ISplitter.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

contract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {
    
    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);
    event FeeSentToPlatform(
        address indexed platformFeeRecipient,
        uint256 amount
    );
    event NewRoyaltyVaultPlatformFee(uint256 platformFee);
    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);

    
    function getVaultBalance() public view override returns (uint256) {
        return IERC20(royaltyAsset).balanceOf(address(this));
    }

    
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }

    
    function setPlatformFee(uint256 _platformFee) external override onlyOwner {
        platformFee = _platformFee;
        emit NewRoyaltyVaultPlatformFee(_platformFee);
    }

    
    function setPlatformFeeRecipient(address _platformFeeRecipient)
        external
        override
        onlyOwner
    {
        platformFeeRecipient = _platformFeeRecipient;
        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);
    }

    
    function getSplitter() public view override returns (address) {
        return splitterProxy;
    }

    
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IRoyaltyVault, ERC165)
        returns (bool)
    {
        return interfaceId == type(IRoyaltyVault).interfaceId;
    }
}",627.0,3,0,"Based on the provided smart contract code, here's a breakdown of potential vulnerabilities and areas of concern:

**1. Reentrancy:**

*   **Vulnerability:**  The `sendToSplitter` function interacts with external contracts (`splitterProxy` and `platformFeeRecipient`) using `transfer` and `incrementWindow`.  If either of these external contracts are malicious, they could potentially re-enter the `sendToSplitter` function before the initial transfer operations are complete. This could lead to unexpected state changes and potential loss of funds.

*   **Mitigation:**
    *   **Checks-Effects-Interactions Pattern:**  Reorder the operations within `sendToSplitter` to follow the Checks-Effects-Interactions pattern.  Specifically:
        1.  Perform all necessary checks (e.g., balance check, splitter address check).
        2.  Update the contract's internal state (e.g., reduce the balance).  In this case, it's difficult as balance is tracked via IERC20.
        3.  Finally, interact with external contracts (the transfers).
    *   **Reentrancy Guard:**  Implement a reentrancy guard using a mutex to prevent re-entrant calls to `sendToSplitter`.  This is the most robust solution.
    *   **Pull over Push:** Consider having the splitter ""pull"" the funds instead of the royalty vault ""pushing"" them.

**2. Integer Overflow/Underflow:**

*   **Vulnerability:** While Solidity 0.8.0 and later versions have built-in overflow/underflow protection, it's still good practice to be aware of the potential and consider explicit checks, especially when dealing with large numbers or external inputs. In this contract the multiplication `(balanceOfVault * platformFee) / 10000` is vulnerable if `balanceOfVault * platformFee` is larger than the maximum `uint256` value.

*   **Mitigation:**
    *   Use SafeMath libraries or perform explicit overflow/underflow checks if you are using a version of Solidity before 0.8.0 or dealing with external data that may not be sanitized.
    *   Consider using `SafeCast` to safely cast between different integer types.
    *   Add checks such as `require(platformFee <= 10000, ""Platform fee cannot exceed 100%"");` to prevent the multiplication result being too large.

**3. Denial of Service (DoS):**

*   **Vulnerability:** The `sendToSplitter` function relies on external calls to `splitterProxy` and `platformFeeRecipient`.  If either of these addresses becomes unresponsive or reverts consistently (e.g., due to an intentional attack or some other error), the `sendToSplitter` function will be blocked, preventing legitimate royalty distribution.

*   **Mitigation:**
    *   **Retry Mechanism (with caution):**  Consider implementing a retry mechanism with a limited number of attempts.  However, be very careful with retries, as they can exacerbate reentrancy issues if not handled correctly.
    *   **Emergency Withdrawal:**  Provide an emergency withdrawal function (only callable by the owner) to withdraw the vault's funds to a safe address in case the splitter or platform fee recipient becomes unusable.
    *   **Address Validation:**  Ensure that the `splitterProxy` and `platformFeeRecipient` addresses are valid and trustworthy before setting them.  Consider allowing the owner to change these addresses if necessary.

**4. Front Running:**

*   **Vulnerability:**  The `setPlatformFee` and `setPlatformFeeRecipient` functions are only callable by the owner, but they are still susceptible to front-running.  A malicious actor could observe a transaction setting a new platform fee and then submit their own transaction with a higher gas price to have their transaction executed first, potentially setting a fee that benefits them.

*   **Mitigation:**
    *   **Two-Step Process with Confirmation:**  Implement a two-step process for critical parameters like the platform fee.  The owner would first propose a change, and then a second transaction would be required to confirm the change after a certain delay.
    *   **Acceptable Deviation:** Allow a small deviation range for the platform fee recipient, so if a small amount is sent to the old address, it's not reverted.

**5. Centralization and Ownership Risks:**

*   **Vulnerability:**  The `Ownable` contract makes the owner a central point of control.  If the owner's account is compromised, the attacker could change the platform fee, platform fee recipient, or potentially drain the vault.

*   **Mitigation:**
    *   **Multi-Sig Wallet:**  Consider using a multi-signature wallet to manage the owner role.  This requires multiple parties to approve changes, reducing the risk of a single point of failure.
    *   **Timelock:** Implement a timelock mechanism for critical owner functions like `setPlatformFee` and `setPlatformFeeRecipient`. This gives users time to react if a malicious change is proposed.
    *   **Consider DAO or Governance:** If the project aims for decentralization, explore transferring ownership to a DAO or implementing a governance system to manage critical parameters.

**6. Transfer Failures:**

*   **Vulnerability:** The code assumes that the `IERC20(royaltyAsset).transfer` calls will always succeed.  However, ERC20 `transfer` functions can return `false` or revert under certain conditions (e.g., if the contract holding the tokens doesn't have enough balance).

*   **Mitigation:**
    *   **Check Return Values:**  Explicitly check the return values of the `transfer` calls using `require(IERC20(royaltyAsset).transfer(...), ""Transfer failed"");`.  This will cause the transaction to revert if the transfer fails.
    *   **TransferHelper Library:** Use a `TransferHelper` library that handles ERC20 transfers safely, including checking return values and handling the case where the transfer reverts.
    *   **Consider Transfer/TransferFrom Differences:** Be aware of the differences between `transfer` and `transferFrom` and choose the appropriate function based on the situation.

**7.  Incorrect Fee Calculation:**

*   **Vulnerability:** The platform share is calculated as `(balanceOfVault * platformFee) / 10000`. If `platformFee` is greater than 10000 (100%), the calculation can lead to unexpected results, potentially draining more than the intended amount.

*   **Mitigation:**
    *   **Input Validation:**  Add a check to `setPlatformFee` to ensure that `_platformFee` is not greater than 10000:  `require(_platformFee <= 10000, ""Platform fee cannot exceed 100%"");`.

**8. Splitter Window Increment Failure:**

*   **Vulnerability:** The code assumes `ISplitter(splitterProxy).incrementWindow(splitterShare)` always returns true. If `incrementWindow` fails, the transaction will revert, and no royalties are distributed. This could be due to issues in the `Splitter` contract.

*   **Mitigation:**
    *   **Error Handling:** Consider what happens if `incrementWindow` fails.  Does the RoyaltyVault retry later? Does it notify the owner?  Add appropriate error handling.  The current `require` statement is a good starting point, but consider the overall flow.
    *   **Trust the Splitter:** The RoyaltyVault depends on the Splitter contract working correctly.  Ensure the Splitter is thoroughly audited.

**9. Missing Access Control on `getVaultBalance`:**

*   **Concern:** While not a vulnerability *per se*, the `getVaultBalance` function is public.  Consider whether this information should be restricted (e.g., only accessible to the owner or specific roles).  If the balance is sensitive information, restrict access.

**10. Missing Event for Splitter Address Change:**

*   **Concern:** There's no function to set the `splitterProxy` address, nor is there an event emitted when a new `splitterProxy` address is set.  While the current code might assume the splitter is set elsewhere (e.g., in the constructor of a deploying contract), consider adding a setter function and an event for clarity and flexibility.
*    This would also increase transparency.

**Code Improvement Suggestions (Beyond Vulnerabilities):**

*   **Gas Optimization:**  Look for opportunities to optimize gas usage.  For example, caching the result of `IERC20(royaltyAsset).balanceOf(address(this))` in a local variable if it's used multiple times within the same function.
*   **Documentation (NatSpec):** Add NatSpec comments to all public and external functions to clearly document their purpose, inputs, outputs, and any potential side effects. This is crucial for maintainability and auditability.
*   **Testing:** Thoroughly test the contract with various scenarios, including edge cases, to ensure it behaves as expected. Use a combination of unit tests and integration tests.
*   **Upgradeability:** If the contract needs to be upgradeable in the future, consider using a proxy pattern (e.g., UUPS or Transparent Proxy).  However, upgradeability adds complexity and potential security risks, so carefully weigh the pros and cons.
*   **Consider Using a Library for Arithmetic:** For calculations such as `(balanceOfVault * platformFee) / 10000`, using a library designed for financial calculations with fixed-point arithmetic can provide more precise and safe results, especially when dealing with percentages.

**Important Notes:**

*   This analysis is based solely on the code provided. A complete security audit would involve a deeper understanding of the project's overall architecture, business logic, and deployment environment.
*   Always consult with experienced smart contract auditors to conduct a thorough security review of your code before deploying it to a live environment.
*   Keep up-to-date with the latest security best practices and known vulnerabilities in the Solidity ecosystem.

By addressing these potential vulnerabilities and following best practices, you can significantly improve the security and reliability of your smart contract.","### **Comparison of Issue Report and Response List**

---

#### **[H-01] ERC20 transferFrom return values not checked**

**Report Description**:  
The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.

**Match in Response List**:  
Matches with the issue titled **""Transfer Failures""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unchecked ERC20 `transfer` calls and suggests checking return values using `require`. While the response focuses on `transfer`, the same logic applies to `transferFrom`, as both functions return boolean values that should be validated. This aligns with Solidity best practices for secure ERC20 interactions.

---

#### **[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**

**Report Description**:  
The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g., 100% = 10000), and that share of the contract's balance and future balances will be set to the `platformFeeRecipient` (which is in the owner's control) rather than the splitter contract. As a result, the owner can steal the entire contract balance and any future balances, avoiding the splitter.

**Match in Response List**:  
Matches with the issue titled **""Centralization and Ownership Risks""**.

**Validation**:  
**Correct**. The response identifies the centralization risk associated with the owner's ability to control critical parameters like `_platformFee` and `platformFeeRecipient`. It suggests mitigations such as using a multi-signature wallet, implementing a timelock, or transferring ownership to a DAO. These recommendations directly address the issue described in the report.

---

#### **[H-09] ERC20 tokens with no return value will fail to transfer**

**Report Description**:  
Although the ERC20 standard suggests that a transfer should return `true` on success, many tokens are non-compliant in this regard (including high-profile tokens like USDT). In that case, the `.transfer()` call here will revert even if the transfer is successful, because Solidity will check that the `RETURNDATASIZE` matches the ERC20 interface.

**Match in Response List**:  
Matches with the issue titled **""Transfer Failures""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the issue with ERC20 `transfer` calls and suggests checking return values. However, it does not explicitly address the specific case of non-compliant tokens (like USDT) that do not return a value, which can cause the transaction to revert. A more comprehensive solution would involve using a `TransferHelper` library or handling non-compliant tokens explicitly.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] ERC20 transferFrom return values not checked**
- **[H-05] Centralisation Risk: Owner Of RoyaltyVault Can Take All Funds**

**Partially Correct Matches**:

- **[H-09] ERC20 tokens with no return value will fail to transfer**

**Missed Issues from Issue Report**:

- *None*

---

### **Overall Assessment**

The `response_list` effectively addresses most of the issues in the `issue` report, particularly those related to centralization risks and unchecked ERC20 return values. However, the response could be improved by explicitly addressing non-compliant ERC20 tokens that do not return a value, as highlighted in **[H-09]**. Overall, the response demonstrates a strong understanding of Solidity security best practices and provides actionable mitigation strategies.",2,1,0,10,"```
1. Transfer Failures
2. Centralization and Ownership Risks
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Transfer Failures** appears at rank 6.
   - **Centralization and Ownership Risks** appears at rank 5.

2. **Calculate the precision at each rank where a true positive appears**:
   - For **Centralization and Ownership Risks** at rank 5:
     \[
     P@5 = \frac{1}{5} = 0.2
     \]
   - For **Transfer Failures** at rank 6:
     \[
     P@6 = \frac{2}{6} \approx 0.333
     \]

3. **Average the precision values**:
   \[
   AP = \frac{0.2 + 0.333}{2} = \frac{0.533}{2} \approx 0.2665
   \]

**Average Precision (AP)**: 0.2665",0.2665
SplitFactory.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  /**** Immutable storage ****/

  address public immutable splitter;
  address public immutable royaltyVault;

  /**** Mmutable storage ****/
  // Gets set within the block, and then deleted.

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  /**** Events ****/

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  // ---------------- MODIFIER ----------------

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  /**
   * @dev Constructor
   * @param _splitter The address of the Splitter contract.
   */
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; // 5%
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  // ---------------- EXTERNAL ----------------

  /**
   * @dev Deploys a new SplitProxy and initializes collection's royalty vault.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _collectionContract The address of the collection contract.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  /**
   * @dev Deploys a new SplitProxy.
   * @param _merkleRoot The merkle root of the asset.
   * @param _splitAsset The address of the asset to split.
   * @param _splitId The split identifier.
   */
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  /**
   * @dev Set Platform fee for collection contract.
   * @param _platformFee Platform fee in scaled percentage. (5% = 200)
   * @param _vault vault address.
   */
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  /**
   * @dev Set Platform fee recipient for collection contract.
   * @param _vault vault address.
   * @param _platformFeeRecipient Platform fee recipient.
   */
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  // ---------------- PRIVATE ----------------

  /**
   * @dev Creates a new SplitProxy.
   */
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",1197.0,175.0,"***[M-01] DoS: Attacker May Front-Run `createSplit()` With A merkleRoot Causing Future Transactions With The Same merkleRoot to Revert***
A merkleRoot may only be used once in `createSplit()` since it is used as salt to the deployment of a SplitProxy.
The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same merkleRoot but changes the other fields such as the `_collectionContract` or `_splitAsset()`. The original transaction will revert and the user will not be able to send any more transaction with this merkleRoot.",1.0,"pragma solidity ^0.8.4;

import {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';
import {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';
import {SplitProxy} from './SplitProxy.sol';
import {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';
import {ICoreCollection} from '../interfaces/ICoreCollection.sol';

contract SplitFactory is Ownable {
  

  address public immutable splitter;
  address public immutable royaltyVault;

  
  

  bytes32 public merkleRoot;
  address public splitAsset;
  address public royaltyAsset;
  address public splitterProxy;
  uint256 public platformFee;
  address public platformFeeRecipient;

  mapping(string => address) public splits;

  

  event SplitCreated(address indexed splitter, string splitId);

  event VaultCreated(
    address indexed vault,
    address indexed splitter,
    uint256 platformFee,
    address platformFeeRecipient
  );

  event VaultAssignedToCollection(
    address indexed vault,
    address indexed splitter,
    address indexed collectionContract
  );

  

  modifier onlyAvailableSplit(string memory _splitId) {
    require(
      splits[_splitId] == address(0),
      'SplitFactory : Split ID already in use'
    );
    _;
  }

  
  constructor(address _splitter, address _royaltyVault) {
    splitter = _splitter;
    royaltyVault = _royaltyVault;
    platformFee = 500; 
    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;
  }

  

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    address _collectionContract,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    require(
      ICoreCollection(_collectionContract).owner() == msg.sender,
      'Transaction sender is not collection owner'
    );
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    address vault = createVaultProxy(splitProxy);

    ICoreCollection(_collectionContract).setRoyaltyVault(vault);
    emit VaultAssignedToCollection(vault, splitter, _collectionContract);
  }

  
  function createSplit(
    bytes32 _merkleRoot,
    address _splitAsset,
    string memory _splitId
  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {
    merkleRoot = _merkleRoot;
    splitAsset = _splitAsset;
    royaltyAsset = _splitAsset;

    splitProxy = createSplitProxy(_splitId);
    createVaultProxy(splitProxy);
  }

  
  function setPlatformFee(address _vault, uint256 _platformFee)
    external
    onlyOwner
  {
    IRoyaltyVault(_vault).setPlatformFee(_platformFee);
  }

  
  function setPlatformFeeRecipient(
    address _vault,
    address _platformFeeRecipient
  ) external onlyOwner {
    require(_vault != address(0), 'Invalid vault');
    require(
      _platformFeeRecipient != address(0),
      'Invalid platform fee recipient'
    );
    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
  }

  

  
  function createSplitProxy(string memory _splitId)
    private
    returns (address splitProxy)
  {
    splitProxy = address(
      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
    );

    splits[_splitId] = splitProxy;

    emit SplitCreated(splitProxy, _splitId);

    delete merkleRoot;
    delete splitAsset;
  }

  function createVaultProxy(address splitProxy)
    private
    returns (address vault)
  {
    splitterProxy = splitProxy;
    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());
    delete splitterProxy;
    delete royaltyAsset;
    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);
  }
}",893.0,0,1,"Based on the provided code, here's a breakdown of potential vulnerabilities and areas of concern:

**High Severity**

*   **Denial of Service (DoS) in `createSplitProxy` and `createVaultProxy` due to `delete` operations:**

    *   **Vulnerability:** The `createSplitProxy` function deletes `merkleRoot` and `splitAsset` after creating the `SplitProxy`. Similarly, `createVaultProxy` deletes `splitterProxy` and `royaltyAsset`.  If a large value of gas is not provided when the function is called, or the storage becomes too expensive, the `delete` operations might revert due to out-of-gas errors.  This will brick the entire transaction.

    *   **Impact:**  The contract's functionality is severely limited if these critical variables cannot be cleared after each `createSplit` call, making further calls impossible.

    *   **Mitigation:**  Instead of `delete`, consider overwriting the variables with zero values. `merkleRoot = 0; splitAsset = address(0); splitterProxy = address(0); royaltyAsset = address(0);`

*   **Lack of Input Validation in `setPlatformFee` and `setPlatformFeeRecipient`:** While the functions have `onlyOwner` modifiers, the lack of proper input validation can lead to unexpected behavior or potential exploits.

    *   **Vulnerability:** The `setPlatformFee` function doesn't check if `_platformFee` is within a reasonable range. Setting an extremely high fee could lock funds or render the platform unusable. The `setPlatformFeeRecipient` function doesn't validate the `_platformFeeRecipient` address beyond checking that it's not the zero address.

    *   **Impact:** Potential for financial loss and/or rendering the platform unusable due to incorrect fee settings.

    *   **Mitigation:**
        *   In `setPlatformFee`, add a check to ensure `_platformFee` is within an acceptable range (e.g., `require(_platformFee <= MAX_PLATFORM_FEE, ""Platform fee too high"");`).
        *   In `setPlatformFeeRecipient`, consider checking if the recipient is a contract or EOA, and if it's a contract, ensure it's a safe contract that won't revert on transfers.

**Medium Severity**

*   **Potential Replay Attack on Proxy Creation:**

    *   **Vulnerability:** The salt used in `SplitProxy` creation is only based on `merkleRoot`. If the same `merkleRoot` is used for multiple splits, the same proxy address can be created, potentially leading to unexpected behavior or exploits. The same is true for `ProxyVault` creation as it uses the `splitProxy` address as salt.

    *   **Impact:** Can cause two different split proxies to resolve to the same address.

    *   **Mitigation:** Include a unique value in the salt, such as `_splitId` or a nonce. For example:

        ```solidity
        splitProxy = address(
          new SplitProxy{salt: keccak256(abi.encode(merkleRoot, _splitId))}()
        );

        vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy, _splitId))}());
        ```

*   **Missing Access Control on `createSplit` function:**

    *   **Vulnerability:** Although one `createSplit` function checks if the sender is the owner of the collection contract, the second overloaded `createSplit` function **does not** have this check. This means anyone can create a split using the second function.

    *   **Impact:** Unauthorized split creation.

    *   **Mitigation:**  Add the same `ICoreCollection(_collectionContract).owner() == msg.sender` check to the second `createSplit` function, or remove the second function entirely if it is not needed.

*   **Lack of Events for Important State Changes:**  While some events are emitted, other important state changes are not logged, making it harder to monitor and debug the contract.

    *   **Vulnerability:** Changes to `merkleRoot`, `splitAsset`, `royaltyAsset`, and `platformFee` within `createSplit` are not explicitly logged.

    *   **Impact:** Difficult to track state changes off-chain, hindering monitoring and debugging.

    *   **Mitigation:**  Emit events whenever these key variables are changed. For example:

        ```solidity
        event MerkleRootUpdated(bytes32 indexed merkleRoot);
        event SplitAssetUpdated(address indexed splitAsset);
        event RoyaltyAssetUpdated(address indexed royaltyAsset);
        ```

        Then, emit these events when you update the variables:

        ```solidity
        merkleRoot = _merkleRoot;
        emit MerkleRootUpdated(_merkleRoot);
        splitAsset = _splitAsset;
        emit SplitAssetUpdated(_splitAsset);
        royaltyAsset = _splitAsset;
        emit RoyaltyAssetUpdated(_splitAsset);
        ```

**Low Severity**

*   **Reliance on `delete` for Security (Incorrect):** The comments mention that variables are being deleted to free storage, and to ""secure against accidental re-use"". Deleting variables does free storage, but it **does not** provide a security benefit in preventing accidental reuse. The zero value is still accessible.

    *   **Vulnerability:** Incorrect understanding of `delete`'s effect.

    *   **Impact:**  Misconception about the security implications of variable deletion.

    *   **Mitigation:**  Understand that `delete` primarily frees storage. If the goal is to prevent accidental reuse, consider implementing a flag to indicate that the variables are no longer valid or explicitly nullify pointers/addresses. However, in this case overwriting is fine as it is cheaper than setting flags.

*   **Magic Number for Platform Fee:** The value `500` for the platform fee is a magic number.

    *   **Vulnerability:**  Makes the code less readable and harder to maintain.

    *   **Impact:** Reduced readability and maintainability.

    *   **Mitigation:**  Define a named constant for the platform fee (e.g., `uint256 public constant DEFAULT_PLATFORM_FEE = 500;`) and use this constant in the constructor.

*   **Missing Input Validation for `_splitId`:** The `onlyAvailableSplit` modifier checks for uniqueness but doesn't perform other validations on `_splitId` itself.

    *   **Vulnerability:** An overly long or specially crafted `_splitId` could potentially cause issues in other parts of the system where it's used (e.g., storage, off-chain lookups).

    *   **Impact:** Potential for denial of service or unexpected behavior if `_splitId` is not properly validated.

    *   **Mitigation:** Add checks to ensure `_splitId` is within a reasonable length and conforms to a specific format (e.g., alphanumeric characters only).

**Recommendations Summary:**

1.  **Replace `delete` with overwriting for storage variables.**
2.  **Add input validation to `setPlatformFee` and `setPlatformFeeRecipient`.**
3.  **Include `_splitId` or a nonce in the salt for proxy creation to prevent replay attacks.**
4.  **Add access control to the second `createSplit` function.**
5.  **Emit events for key state changes in `createSplit`.**
6.  **Use a constant for the default platform fee.**
7.  **Validate the `_splitId` input.**
8.  **Ensure the dependencies `@openzeppelin/contracts/access/Ownable.sol`, `@chestrnft/royalty-vault/contracts/ProxyVault.sol`, `@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol`, and `../interfaces/ICoreCollection.sol` are from a trusted source, and are of a safe version. Be aware of any vulnerabilities with your dependencies**

By addressing these points, the contract's security, reliability, and maintainability can be significantly improved.","### **[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Report Description**:  
The `createSplit()` function uses the `merkleRoot` as a salt for deploying a `SplitProxy`. Since a `merkleRoot` can only be used once, an attacker can front-run a `createSplit()` transaction in the mempool by submitting a transaction with a higher gas price that uses the same `merkleRoot` but changes other fields (e.g., `_collectionContract` or `_splitAsset`). This causes the original transaction to revert, preventing the user from using the same `merkleRoot` in future transactions.

**Match in Response List**:  
Matches with the issue titled **""Potential Replay Attack on Proxy Creation""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of using the same `merkleRoot` for multiple splits, which could lead to unexpected behavior or exploits. However, it does not explicitly address the front-running aspect of the vulnerability, which is a critical detail in the issue report. The proposed mitigation (adding a unique value like `_splitId` or a nonce to the salt) is a valid solution but does not fully capture the risk of front-running attacks.  

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis and Recommendations**

The response list partially addresses the issue by identifying the problem of reusing the same `merkleRoot` for proxy creation. However, it misses the critical aspect of front-running, which is the primary concern in the issue report. To fully mitigate this vulnerability, the response should explicitly mention the risk of front-running and recommend measures to prevent it, such as using a unique nonce or `_splitId` in the salt. Additionally, the response could suggest monitoring the mempool for suspicious transactions or implementing a delay mechanism to reduce the likelihood of front-running.  

Overall, the response is on the right track but needs to be more comprehensive to fully address the issue.",0,1,0,8,"```
None.
```",0.0,0
,,,,,,,,9,2,,,3,3,5,48,,,0.4332