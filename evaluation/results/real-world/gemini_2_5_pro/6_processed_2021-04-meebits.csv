nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
Beebots.sol,"pragma solidity 0.7.6;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface BetaToken {
    function tokenOwner(uint index) external view returns(address);
}

interface ERC721TokenReceiver
{
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);
}

library SafeMath {

    /**
    * @dev Multiplies two numbers, throws on overflow.
    */
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    /**
    * @dev Integer division of two numbers, truncating the quotient.
    */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        // uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return a / b;
    }

    /**
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
    */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    /**
    * @dev Adds two numbers, throws on overflow.
    */
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}

contract Beebots is IERC721 {

    using SafeMath for uint256;

    /**
     * Event emitted when minting a new NFT. ""createdVia"" is the index of the alhpa/beta token that was used to mint, or 0 if not applicable.
     */
    event Mint(uint indexed index, address indexed minter, uint createdVia);

    /**
     * Event emitted when a trade is executed.
     */
    event Trade(bytes32 indexed hash, address indexed maker, address taker, uint makerWei, uint[] makerIds, uint takerWei, uint[] takerIds);

    /**
     * Event emitted when ETH is deposited into the contract.
     */
    event Deposit(address indexed account, uint amount);

    /**
     * Event emitted when ETH is withdrawn from the contract.
     */
    event Withdraw(address indexed account, uint amount);

    /**
     * Event emitted when a trade offer is cancelled.
     */
    event OfferCancelled(bytes32 hash);

    /**
     * Event emitted when the public sale begins.
     */
    event SaleBegins();

    /**
     * Event emitted when the community grant period ends.
     */
    event CommunityGrantEnds();

    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;

    // Hash to the NFT content
    string public contentHash = ""todo"";

    uint public constant TOKEN_LIMIT = 30; // 30 for testing, 22k for prod
    uint public constant SALE_LIMIT = 20; // 20 for testing, ~9K for prod

    mapping (uint => address) private idToCreator;

    mapping(bytes4 => bool) internal supportedInterfaces;

    mapping (uint256 => address) internal idToOwner;

    mapping (uint256 => uint256) public idToCreatorNft;

    mapping (uint256 => uint256) public creatorNftMints;

    mapping (uint256 => address) internal idToApproval;

    mapping (address => mapping (address => bool)) internal ownerToOperators;

    mapping(address => uint256[]) internal ownerToIds;

    mapping(uint256 => uint256) internal idToOwnerIndex;

    string internal nftName = ""Beebots"";
    string internal nftSymbol = unicode""🐝"";

    uint internal numTokens = 0;
    uint internal numSales = 0;

    address internal beta;

    address internal alpha;

    address payable internal deployer;
    address payable internal beneficiary;
    bool public communityGrant = true;
    bool public publicSale = false;
    uint private price;
    uint public saleStartTime;
    uint public saleDuration;

    //// Random index assignment
    uint internal nonce = 0;
    uint[TOKEN_LIMIT] internal indices;

    //// Market
    bool public marketPaused;
    bool public contractSealed;
    mapping (address => uint256) public ethBalance;
    mapping (bytes32 => bool) public cancelledOffers;

    modifier onlyDeployer() {
        require(msg.sender == deployer, ""Only deployer."");
        _;
    }

    bool private reentrancyLock = false;

    /* Prevent a contract function from being reentrant-called. */
    modifier reentrancyGuard {
        if (reentrancyLock) {
            revert();
        }
        reentrancyLock = true;
        _;
        reentrancyLock = false;
    }

    modifier canOperate(uint256 _tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], ""Cannot operate."");
        _;
    }

    modifier canTransfer(uint256 _tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(
            tokenOwner == msg.sender
            || idToApproval[_tokenId] == msg.sender
            || ownerToOperators[tokenOwner][msg.sender], ""Cannot transfer.""
        );
        _;
    }

    modifier validNFToken(uint256 _tokenId) {
        require(idToOwner[_tokenId] != address(0), ""Invalid token."");
        _;
    }

    constructor(address _beta, address _alpha, address payable _beneficiary) {
        supportedInterfaces[0x01ffc9a7] = true; // ERC165
        supportedInterfaces[0x80ac58cd] = true; // ERC721
        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable
        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata
        deployer = msg.sender;
        beta = _beta;
        alpha = _alpha;
        beneficiary = _beneficiary;
    }

    function startSale(uint _price, uint _saleDuration) external onlyDeployer {
        require(!publicSale, ""Sale already started."");
        price = _price;
        saleDuration = _saleDuration;
        saleStartTime = block.timestamp;
        publicSale = true;
        emit SaleBegins();
    }

    function endCommunityGrant() external onlyDeployer {
        require(communityGrant, ""Grant period already ended."");
        communityGrant = false;
        emit CommunityGrantEnds();
    }

    function pauseMarket(bool _paused) external onlyDeployer {
        require(!contractSealed, ""Contract sealed."");
        marketPaused = _paused;
    }

    function sealContract() external onlyDeployer {
        contractSealed = true;
    }

    //////////////////////////
    //// ERC 721 and 165  ////
    //////////////////////////

    function isContract(address _addr) internal view returns (bool addressCheck) {
        uint256 size;
        assembly { size := extcodesize(_addr) } // solhint-disable-line
        addressCheck = size > 0;
    }

    function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {
        return supportedInterfaces[_interfaceID];
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external override {
        _safeTransferFrom(_from, _to, _tokenId, _data);
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {
        _safeTransferFrom(_from, _to, _tokenId, """");
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) external override canTransfer(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == _from, ""Wrong from address."");
        require(_to != address(0), ""Cannot send to 0x0."");
        _transfer(_to, _tokenId);
    }

    function approve(address _approved, uint256 _tokenId) external override canOperate(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(_approved != tokenOwner);
        idToApproval[_tokenId] = _approved;
        emit Approval(tokenOwner, _approved, _tokenId);
    }

    function setApprovalForAll(address _operator, bool _approved) external override {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    function balanceOf(address _owner) external view override returns (uint256) {
        require(_owner != address(0));
        return _getOwnerNFTCount(_owner);
    }

    function ownerOf(uint256 _tokenId) external view override returns (address _owner) {
        _owner = idToOwner[_tokenId];
    }

    function getApproved(uint256 _tokenId) external view override validNFToken(_tokenId) returns (address) {
        return idToApproval[_tokenId];
    }

    function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {
        return ownerToOperators[_owner][_operator];
    }

    function _transfer(address _to, uint256 _tokenId) internal {
        address from = idToOwner[_tokenId];
        _clearApproval(_tokenId);

        _removeNFToken(from, _tokenId);
        _addNFToken(_to, _tokenId);

        emit Transfer(from, _to, _tokenId);
    }

    function randomIndex() internal returns (uint) {
        uint totalSize = TOKEN_LIMIT - numTokens;
        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;
        uint value = 0;
        if (indices[index] != 0) {
            value = indices[index];
        } else {
            value = index;
        }

        // Move last value to selected position
        if (indices[totalSize - 1] == 0) {
            // Array position not initialized, so use position
            indices[index] = totalSize - 1;
        } else {
            // Array position holds a value so use that
            indices[index] = indices[totalSize - 1];
        }
        nonce.add(1);
        // Don't allow a zero index, start counting at 1
        return value.add(1);
    }

    // Calculate the mint price
    function getPrice() public view returns (uint) {
        require(publicSale, ""Sale not started."");
        uint elapsed = block.timestamp.sub(saleStartTime);
        if (elapsed > saleDuration) {
            return 0;
        } else {
            return saleDuration.sub(elapsed).mul(price).div(saleDuration);
        }
    }

    // The deployer can mint in bulk without paying
    function devMint(uint quantity, address recipient) external onlyDeployer {
        for (uint i = 0; i < quantity; i++) {
            _mint(recipient, 0);
        }
    }

    function mintsRemaining() external view returns (uint) {
        return SALE_LIMIT.sub(numSales);
    }

    /**
     * Community grant minting.
     */
    function mintWithAlphaOrBeta(uint _createVia) external reentrancyGuard returns (uint) {
        require(communityGrant);
        require(_createVia > 0 && _createVia <= 600, ""Invalid alpha/beta index."");
        require(creatorNftMints[_createVia] == 0, ""Already minted with this alpha/beta"");
        if (_createVia > 400) {
            // It's an alpha
            // Compute the alpha ID
            uint alphaId = _createVia.sub(400);
            // Make sure the sender owns the alpha
            require(IERC721(alpha).ownerOf(alphaId) == msg.sender, ""Not the owner of this alpha."");
        } else {
            // It's a beta
            // Compute the beta ID, 0-based
            uint betaId = _createVia.sub(1);
            // Make sure the sender owns the beta
            require(BetaToken(beta).tokenOwner(betaId) == msg.sender, ""Not the owner of this beta."");
        }
        creatorNftMints[_createVia]++;
        return _mint(msg.sender, _createVia);
    }

    /**
     * Public sale minting.
     */
    function mint() external payable reentrancyGuard returns (uint) {
        require(publicSale, ""Sale not started."");
        require(numSales < SALE_LIMIT, ""Sale limit reached."");
        uint salePrice = getPrice();
        require(msg.value >= salePrice, ""Insufficient funds to purchase."");
        if (msg.value > salePrice) {
            msg.sender.transfer(msg.value.sub(salePrice));
        }
        beneficiary.transfer(salePrice);
        numSales++;
        return _mint(msg.sender, 0);
    }

    function _mint(address _to, uint createdVia) internal returns (uint) {
        require(_to != address(0), ""Cannot mint to 0x0."");
        require(numTokens < TOKEN_LIMIT, ""Token limit reached."");
        uint id = randomIndex();

        idToCreator[id] = _to;
        idToCreatorNft[id] = createdVia;

        numTokens = numTokens + 1;
        _addNFToken(_to, id);

        emit Mint(id, _to, createdVia);
        emit Transfer(address(0), _to, id);
        return id;
    }

    function _addNFToken(address _to, uint256 _tokenId) internal {
        require(idToOwner[_tokenId] == address(0), ""Cannot add, already owned."");
        idToOwner[_tokenId] = _to;

        ownerToIds[_to].push(_tokenId);
        idToOwnerIndex[_tokenId] = ownerToIds[_to].length.sub(1);
    }

    function _removeNFToken(address _from, uint256 _tokenId) internal {
        require(idToOwner[_tokenId] == _from, ""Incorrect owner."");
        delete idToOwner[_tokenId];

        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];
        uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);

        if (lastTokenIndex != tokenToRemoveIndex) {
            uint256 lastToken = ownerToIds[_from][lastTokenIndex];
            ownerToIds[_from][tokenToRemoveIndex] = lastToken;
            idToOwnerIndex[lastToken] = tokenToRemoveIndex;
        }

        ownerToIds[_from].pop();
    }

    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {
        return ownerToIds[_owner].length;
    }

    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == _from, ""Incorrect owner."");
        require(_to != address(0));

        _transfer(_to, _tokenId);

        if (isContract(_to)) {
            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
            require(retval == MAGIC_ERC721_RECEIVED);
        }
    }

    function _clearApproval(uint256 _tokenId) private {
        if (idToApproval[_tokenId] != address(0)) {
            delete idToApproval[_tokenId];
        }
    }

    //// Enumerable

    function totalSupply() public view returns (uint256) {
        return numTokens;
    }

    function tokenByIndex(uint256 index) public pure returns (uint256) {
        require(index > 0 && index < TOKEN_LIMIT);
        return index;
    }

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {
        require(_index < ownerToIds[_owner].length);
        return ownerToIds[_owner][_index];
    }

    //// Metadata

    /**
      * @dev Converts a `uint256` to its ASCII `string` representation.
      */
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        while (temp != 0) {
            buffer[index--] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(buffer);
    }

    /**
      * @dev Returns a descriptive name for a collection of NFTokens.
      * @return _name Representing name.
      */
    function name() external view returns (string memory _name) {
        _name = nftName;
    }

    /**
     * @dev Returns an abbreviated name for NFTokens.
     * @return _symbol Representing symbol.
     */
    function symbol() external view returns (string memory _symbol) {
        _symbol = nftSymbol;
    }

    /**
     * @dev A distinct URI (RFC 3986) for a given NFT.
     * @param _tokenId Id for which we want uri.
     * @return _tokenId URI of _tokenId.
     */
    function tokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {
        return string(abi.encodePacked(""https://todo/"", toString(_tokenId)));
    }

    //// MARKET

    struct Offer {
        address maker;
        address taker;
        uint256 makerWei;
        uint256[] makerIds;
        uint256 takerWei;
        uint256[] takerIds;
        uint256 expiry;
        uint256 salt;
    }

    function hashOffer(Offer memory offer) private pure returns (bytes32){
        return keccak256(abi.encode(
                    offer.maker,
                    offer.taker,
                    offer.makerWei,
                    keccak256(abi.encodePacked(offer.makerIds)),
                    offer.takerWei,
                    keccak256(abi.encodePacked(offer.takerIds)),
                    offer.expiry,
                    offer.salt
                ));
    }

    function hashToSign(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) public pure returns (bytes32) {
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        return hashOffer(offer);
    }

    function hashToVerify(Offer memory offer) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hashOffer(offer)));
    }

    function verify(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {
        require(signature.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        if (v < 27) {
            v += 27;
        }

        require(v == 27 || v == 28);

        return signer == ecrecover(hash, v, r, s);
    }

    function tradeValid(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) view public returns (bool) {
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        // Check for cancellation
        bytes32 hash = hashOffer(offer);
        require(cancelledOffers[hash] == false, ""Trade offer was cancelled."");
        // Verify signature
        bytes32 verifyHash = hashToVerify(offer);
        require(verify(offer.maker, verifyHash, signature), ""Signature not valid."");
        // Check for expiry
        require(block.timestamp < offer.expiry, ""Trade offer expired."");
        // Only one side should ever have to pay, not both
        require(makerWei == 0 || takerWei == 0, ""Only one side of trade must pay."");
        // At least one side should offer tokens
        require(makerIds.length > 0 || takerIds.length > 0, ""One side must offer tokens."");
        // Make sure the maker has funded the trade
        require(ethBalance[offer.maker] >= offer.makerWei, ""Maker does not have sufficient balance."");
        // Ensure the maker owns the maker tokens
        for (uint i = 0; i < offer.makerIds.length; i++) {
            require(idToOwner[offer.makerIds[i]] == offer.maker, ""At least one maker token doesn't belong to maker."");
        }
        // If the taker can be anybody, then there can be no taker tokens
        if (offer.taker == address(0)) {
            // If taker not specified, then can't specify IDs
            require(offer.takerIds.length == 0, ""If trade is offered to anybody, cannot specify tokens from taker."");
        } else {
            // Ensure the taker owns the taker tokens
            for (uint i = 0; i < offer.takerIds.length; i++) {
                require(idToOwner[offer.takerIds[i]] == offer.taker, ""At least one taker token doesn't belong to taker."");
            }
        }
        return true;
    }

    function cancelOffer(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) external {
        require(maker == msg.sender, ""Only the maker can cancel this offer."");
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        bytes32 hash = hashOffer(offer);
        cancelledOffers[hash] = true;
        emit OfferCancelled(hash);
    }

    function acceptTrade(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) external payable reentrancyGuard {
        require(!marketPaused, ""Market is paused."");
        require(msg.sender != maker, ""Can't accept ones own trade."");
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        ethBalance[msg.sender] += msg.value;
        if (msg.value > 0) {
            emit Deposit(msg.sender, msg.value);
        }
        require(offer.taker == address(0) || offer.taker == msg.sender, ""Not the recipient of this offer."");
        require(tradeValid(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt, signature), ""Trade not valid."");
        require(ethBalance[msg.sender] >= offer.takerWei, ""Insufficient funds to execute trade."");
        // Transfer ETH
        ethBalance[offer.maker] = ethBalance[offer.maker].sub(offer.makerWei);
        ethBalance[msg.sender] = ethBalance[msg.sender].add(offer.makerWei);
        ethBalance[msg.sender] = ethBalance[msg.sender].sub(offer.takerWei);
        ethBalance[offer.maker] = ethBalance[offer.maker].add(offer.takerWei);
        // Transfer maker ids to taker (msg.sender)
        for (uint i = 0; i < makerIds.length; i++) {
            _transfer(msg.sender, makerIds[i]);
        }
        // Transfer taker ids to maker
        for (uint i = 0; i < takerIds.length; i++) {
            _transfer(maker, takerIds[i]);
        }
        // Prevent a replay attack on this offer
        bytes32 hash = hashOffer(offer);
        cancelledOffers[hash] = true;
        emit Trade(hash, offer.maker, msg.sender, offer.makerWei, offer.makerIds, offer.takerWei, offer.takerIds);
    }

    function withdraw(uint amount) external {
        require(amount <= ethBalance[msg.sender]);
        ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);
        msg.sender.transfer(amount);
        emit Withdraw(msg.sender, amount);
    }

    function deposit() external payable {
        ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }

}",5608,661,"[H-01] Signature malleability of EVM's ecrecover in `verify()`
EVM's `ecrecover` is susceptible to signature malleability, which allows replay attacks, but that is mitigated here by tracking accepted offers and canceling them (on L645) specifically to prevent replays. However, if any application logic changes, it might make signature malleability a risk for replay attacks.   [H-02] Arbitrary Transfer of Unowned NFTs
Due to how the market functions are structured, it is possible to arbitrarily transfer any NFT that is not owned by any address.
The function in question is the `tradeValid` function invoked by `acceptTrade` before the trade is performed. It, in turn, validates the signature of a trade via `verify`, which does not account for the behavior of `ecrecover`.
When `ecrecover` is invoked with an invalid signature, the zero-address is returned by it, meaning that `verify` will yield `true` for the zero-address as long as the signature provided is invalid. This can be exploited to transfer any NFT whose idToOwner is zero, including NFTs that have not been minted yet.   [H-03] `Beebots.TradeValid()` Will Erroneously Return True When Maker Is Set To `Address(0)` and makerIds Are Set To The `TokenIds` of Unminted Beebot NFTs Beebots.TradeValid() will erroneously return true when maker is set to address(0) and makerIds are set to the tokenIds of unminted beebot NFTs.
Beebots.verify() returns true no matter what signature is given when signer is set to address(0). This means that BeeBots.tradeValid() will erroneously return true when maker is set to address(0).
Finally, before an NFT has even been minted at all, it is assumed to have an owner of address(0) due to the idToOwner mapping being initialized to zero for all uninitialized slots, so an attacker can call tradeValid() with maker set to address(0) and makerIds set to the tokenIds of any unminted nftIds, and tradeValid() will erroneously return true.   [H-04] function `tokenByIndex` treats last index as invalid
NFT indexes start from 0:
So if there are 30 tokens, indexes would be 1-30. However, function tokenByIndex sets such boundaries:
require(index > 0 && index < TOKEN_LIMIT);   [H-05] NFT can be minted for free after sale ended
The getPrice() function returned 0 after the sale ended and (SALE_LIMIT - numSales) NFT can be minted for free.
Without documentation, it's not clear if this is the expected behavior or not. If it's unexpected, it is recommended to revert instead of returning 0. If it's expected behavior, it's possible to create a smart contract and claim all the remaining NFT front-running the regular users.
 
[M-00] Legacy Function Usage
The withdraw function utilizes the transfer invocation, which has a fixed gas stipend and can fail, especially beyond the Berlin fork, which increased the gas costs for first-time invocations of a transfer.

 [M-01] `randomIndex` is not truly random - possibility of predictably minting a specific token Id
`randomIndex' is not random. Any miner has access to these values:
“uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;”
Non-miner attackers could also test the minting random condition until they get the ID they are looking to access.
The internal variable indices seems to be used to avoid this type of collision.
  [M-02] instead of `call()` , `transfer()` is used to withdraw the ether To withdraw ETH, it uses transfer(), this transaction will fail inevitably when:
The withdrawer smart contract does not implement a payable function.
Withdrawer smart contract does implement a payable fallback which uses more than 2300 gas unit.
The withdrawer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.",8,"pragma solidity 0.7.6;

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface BetaToken {
    function tokenOwner(uint index) external view returns(address);
}

interface ERC721TokenReceiver
{
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);
}

library SafeMath {

    
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
        if (a == 0) {
            return 0;
        }
        c = a * b;
        assert(c / a == b);
        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        return a / b;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        assert(c >= a);
        return c;
    }
}

contract Beebots is IERC721 {

    using SafeMath for uint256;

    
    event Mint(uint indexed index, address indexed minter, uint createdVia);

    
    event Trade(bytes32 indexed hash, address indexed maker, address taker, uint makerWei, uint[] makerIds, uint takerWei, uint[] takerIds);

    
    event Deposit(address indexed account, uint amount);

    
    event Withdraw(address indexed account, uint amount);

    
    event OfferCancelled(bytes32 hash);

    
    event SaleBegins();

    
    event CommunityGrantEnds();

    bytes4 internal constant MAGIC_ERC721_RECEIVED = 0x150b7a02;

    
    string public contentHash = ""todo"";

    uint public constant TOKEN_LIMIT = 30; 
    uint public constant SALE_LIMIT = 20; 

    mapping (uint => address) private idToCreator;

    mapping(bytes4 => bool) internal supportedInterfaces;

    mapping (uint256 => address) internal idToOwner;

    mapping (uint256 => uint256) public idToCreatorNft;

    mapping (uint256 => uint256) public creatorNftMints;

    mapping (uint256 => address) internal idToApproval;

    mapping (address => mapping (address => bool)) internal ownerToOperators;

    mapping(address => uint256[]) internal ownerToIds;

    mapping(uint256 => uint256) internal idToOwnerIndex;

    string internal nftName = ""Beebots"";
    string internal nftSymbol = unicode""🐝"";

    uint internal numTokens = 0;
    uint internal numSales = 0;

    address internal beta;

    address internal alpha;

    address payable internal deployer;
    address payable internal beneficiary;
    bool public communityGrant = true;
    bool public publicSale = false;
    uint private price;
    uint public saleStartTime;
    uint public saleDuration;

    
    uint internal nonce = 0;
    uint[TOKEN_LIMIT] internal indices;

    
    bool public marketPaused;
    bool public contractSealed;
    mapping (address => uint256) public ethBalance;
    mapping (bytes32 => bool) public cancelledOffers;

    modifier onlyDeployer() {
        require(msg.sender == deployer, ""Only deployer."");
        _;
    }

    bool private reentrancyLock = false;

    
    modifier reentrancyGuard {
        if (reentrancyLock) {
            revert();
        }
        reentrancyLock = true;
        _;
        reentrancyLock = false;
    }

    modifier canOperate(uint256 _tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], ""Cannot operate."");
        _;
    }

    modifier canTransfer(uint256 _tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(
            tokenOwner == msg.sender
            || idToApproval[_tokenId] == msg.sender
            || ownerToOperators[tokenOwner][msg.sender], ""Cannot transfer.""
        );
        _;
    }

    modifier validNFToken(uint256 _tokenId) {
        require(idToOwner[_tokenId] != address(0), ""Invalid token."");
        _;
    }

    constructor(address _beta, address _alpha, address payable _beneficiary) {
        supportedInterfaces[0x01ffc9a7] = true; 
        supportedInterfaces[0x80ac58cd] = true; 
        supportedInterfaces[0x780e9d63] = true; 
        supportedInterfaces[0x5b5e139f] = true; 
        deployer = msg.sender;
        beta = _beta;
        alpha = _alpha;
        beneficiary = _beneficiary;
    }

    function startSale(uint _price, uint _saleDuration) external onlyDeployer {
        require(!publicSale, ""Sale already started."");
        price = _price;
        saleDuration = _saleDuration;
        saleStartTime = block.timestamp;
        publicSale = true;
        emit SaleBegins();
    }

    function endCommunityGrant() external onlyDeployer {
        require(communityGrant, ""Grant period already ended."");
        communityGrant = false;
        emit CommunityGrantEnds();
    }

    function pauseMarket(bool _paused) external onlyDeployer {
        require(!contractSealed, ""Contract sealed."");
        marketPaused = _paused;
    }

    function sealContract() external onlyDeployer {
        contractSealed = true;
    }

    
    
    

    function isContract(address _addr) internal view returns (bool addressCheck) {
        uint256 size;
        assembly { size := extcodesize(_addr) } 
        addressCheck = size > 0;
    }

    function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {
        return supportedInterfaces[_interfaceID];
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external override {
        _safeTransferFrom(_from, _to, _tokenId, _data);
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {
        _safeTransferFrom(_from, _to, _tokenId, """");
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) external override canTransfer(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == _from, ""Wrong from address."");
        require(_to != address(0), ""Cannot send to 0x0."");
        _transfer(_to, _tokenId);
    }

    function approve(address _approved, uint256 _tokenId) external override canOperate(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(_approved != tokenOwner);
        idToApproval[_tokenId] = _approved;
        emit Approval(tokenOwner, _approved, _tokenId);
    }

    function setApprovalForAll(address _operator, bool _approved) external override {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    function balanceOf(address _owner) external view override returns (uint256) {
        require(_owner != address(0));
        return _getOwnerNFTCount(_owner);
    }

    function ownerOf(uint256 _tokenId) external view override returns (address _owner) {
        _owner = idToOwner[_tokenId];
    }

    function getApproved(uint256 _tokenId) external view override validNFToken(_tokenId) returns (address) {
        return idToApproval[_tokenId];
    }

    function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {
        return ownerToOperators[_owner][_operator];
    }

    function _transfer(address _to, uint256 _tokenId) internal {
        address from = idToOwner[_tokenId];
        _clearApproval(_tokenId);

        _removeNFToken(from, _tokenId);
        _addNFToken(_to, _tokenId);

        emit Transfer(from, _to, _tokenId);
    }

    function randomIndex() internal returns (uint) {
        uint totalSize = TOKEN_LIMIT - numTokens;
        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;
        uint value = 0;
        if (indices[index] != 0) {
            value = indices[index];
        } else {
            value = index;
        }

        
        if (indices[totalSize - 1] == 0) {
            
            indices[index] = totalSize - 1;
        } else {
            
            indices[index] = indices[totalSize - 1];
        }
        nonce.add(1);
        
        return value.add(1);
    }

    
    function getPrice() public view returns (uint) {
        require(publicSale, ""Sale not started."");
        uint elapsed = block.timestamp.sub(saleStartTime);
        if (elapsed > saleDuration) {
            return 0;
        } else {
            return saleDuration.sub(elapsed).mul(price).div(saleDuration);
        }
    }

    
    function devMint(uint quantity, address recipient) external onlyDeployer {
        for (uint i = 0; i < quantity; i++) {
            _mint(recipient, 0);
        }
    }

    function mintsRemaining() external view returns (uint) {
        return SALE_LIMIT.sub(numSales);
    }

    
    function mintWithAlphaOrBeta(uint _createVia) external reentrancyGuard returns (uint) {
        require(communityGrant);
        require(_createVia > 0 && _createVia <= 600, ""Invalid alpha/beta index."");
        require(creatorNftMints[_createVia] == 0, ""Already minted with this alpha/beta"");
        if (_createVia > 400) {
            
            
            uint alphaId = _createVia.sub(400);
            
            require(IERC721(alpha).ownerOf(alphaId) == msg.sender, ""Not the owner of this alpha."");
        } else {
            
            
            uint betaId = _createVia.sub(1);
            
            require(BetaToken(beta).tokenOwner(betaId) == msg.sender, ""Not the owner of this beta."");
        }
        creatorNftMints[_createVia]++;
        return _mint(msg.sender, _createVia);
    }

    
    function mint() external payable reentrancyGuard returns (uint) {
        require(publicSale, ""Sale not started."");
        require(numSales < SALE_LIMIT, ""Sale limit reached."");
        uint salePrice = getPrice();
        require(msg.value >= salePrice, ""Insufficient funds to purchase."");
        if (msg.value > salePrice) {
            msg.sender.transfer(msg.value.sub(salePrice));
        }
        beneficiary.transfer(salePrice);
        numSales++;
        return _mint(msg.sender, 0);
    }

    function _mint(address _to, uint createdVia) internal returns (uint) {
        require(_to != address(0), ""Cannot mint to 0x0."");
        require(numTokens < TOKEN_LIMIT, ""Token limit reached."");
        uint id = randomIndex();

        idToCreator[id] = _to;
        idToCreatorNft[id] = createdVia;

        numTokens = numTokens + 1;
        _addNFToken(_to, id);

        emit Mint(id, _to, createdVia);
        emit Transfer(address(0), _to, id);
        return id;
    }

    function _addNFToken(address _to, uint256 _tokenId) internal {
        require(idToOwner[_tokenId] == address(0), ""Cannot add, already owned."");
        idToOwner[_tokenId] = _to;

        ownerToIds[_to].push(_tokenId);
        idToOwnerIndex[_tokenId] = ownerToIds[_to].length.sub(1);
    }

    function _removeNFToken(address _from, uint256 _tokenId) internal {
        require(idToOwner[_tokenId] == _from, ""Incorrect owner."");
        delete idToOwner[_tokenId];

        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];
        uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);

        if (lastTokenIndex != tokenToRemoveIndex) {
            uint256 lastToken = ownerToIds[_from][lastTokenIndex];
            ownerToIds[_from][tokenToRemoveIndex] = lastToken;
            idToOwnerIndex[lastToken] = tokenToRemoveIndex;
        }

        ownerToIds[_from].pop();
    }

    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {
        return ownerToIds[_owner].length;
    }

    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {
        address tokenOwner = idToOwner[_tokenId];
        require(tokenOwner == _from, ""Incorrect owner."");
        require(_to != address(0));

        _transfer(_to, _tokenId);

        if (isContract(_to)) {
            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);
            require(retval == MAGIC_ERC721_RECEIVED);
        }
    }

    function _clearApproval(uint256 _tokenId) private {
        if (idToApproval[_tokenId] != address(0)) {
            delete idToApproval[_tokenId];
        }
    }

    

    function totalSupply() public view returns (uint256) {
        return numTokens;
    }

    function tokenByIndex(uint256 index) public pure returns (uint256) {
        require(index > 0 && index < TOKEN_LIMIT);
        return index;
    }

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {
        require(_index < ownerToIds[_owner].length);
        return ownerToIds[_owner][_index];
    }

    

    
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return ""0"";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        uint256 index = digits - 1;
        temp = value;
        while (temp != 0) {
            buffer[index--] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(buffer);
    }

    
    function name() external view returns (string memory _name) {
        _name = nftName;
    }

    
    function symbol() external view returns (string memory _symbol) {
        _symbol = nftSymbol;
    }

    
    function tokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {
        return string(abi.encodePacked(""https:
    }

    

    struct Offer {
        address maker;
        address taker;
        uint256 makerWei;
        uint256[] makerIds;
        uint256 takerWei;
        uint256[] takerIds;
        uint256 expiry;
        uint256 salt;
    }

    function hashOffer(Offer memory offer) private pure returns (bytes32){
        return keccak256(abi.encode(
                    offer.maker,
                    offer.taker,
                    offer.makerWei,
                    keccak256(abi.encodePacked(offer.makerIds)),
                    offer.takerWei,
                    keccak256(abi.encodePacked(offer.takerIds)),
                    offer.expiry,
                    offer.salt
                ));
    }

    function hashToSign(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) public pure returns (bytes32) {
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        return hashOffer(offer);
    }

    function hashToVerify(Offer memory offer) private pure returns (bytes32) {
        return keccak256(abi.encodePacked(""\x19Ethereum Signed Message:\n32"", hashOffer(offer)));
    }

    function verify(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {
        require(signature.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        if (v < 27) {
            v += 27;
        }

        require(v == 27 || v == 28);

        return signer == ecrecover(hash, v, r, s);
    }

    function tradeValid(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) view public returns (bool) {
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        
        bytes32 hash = hashOffer(offer);
        require(cancelledOffers[hash] == false, ""Trade offer was cancelled."");
        
        bytes32 verifyHash = hashToVerify(offer);
        require(verify(offer.maker, verifyHash, signature), ""Signature not valid."");
        
        require(block.timestamp < offer.expiry, ""Trade offer expired."");
        
        require(makerWei == 0 || takerWei == 0, ""Only one side of trade must pay."");
        
        require(makerIds.length > 0 || takerIds.length > 0, ""One side must offer tokens."");
        
        require(ethBalance[offer.maker] >= offer.makerWei, ""Maker does not have sufficient balance."");
        
        for (uint i = 0; i < offer.makerIds.length; i++) {
            require(idToOwner[offer.makerIds[i]] == offer.maker, ""At least one maker token doesn't belong to maker."");
        }
        
        if (offer.taker == address(0)) {
            
            require(offer.takerIds.length == 0, ""If trade is offered to anybody, cannot specify tokens from taker."");
        } else {
            
            for (uint i = 0; i < offer.takerIds.length; i++) {
                require(idToOwner[offer.takerIds[i]] == offer.taker, ""At least one taker token doesn't belong to taker."");
            }
        }
        return true;
    }

    function cancelOffer(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) external {
        require(maker == msg.sender, ""Only the maker can cancel this offer."");
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        bytes32 hash = hashOffer(offer);
        cancelledOffers[hash] = true;
        emit OfferCancelled(hash);
    }

    function acceptTrade(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) external payable reentrancyGuard {
        require(!marketPaused, ""Market is paused."");
        require(msg.sender != maker, ""Can't accept ones own trade."");
        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);
        ethBalance[msg.sender] += msg.value;
        if (msg.value > 0) {
            emit Deposit(msg.sender, msg.value);
        }
        require(offer.taker == address(0) || offer.taker == msg.sender, ""Not the recipient of this offer."");
        require(tradeValid(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt, signature), ""Trade not valid."");
        require(ethBalance[msg.sender] >= offer.takerWei, ""Insufficient funds to execute trade."");
        
        ethBalance[offer.maker] = ethBalance[offer.maker].sub(offer.makerWei);
        ethBalance[msg.sender] = ethBalance[msg.sender].add(offer.makerWei);
        ethBalance[msg.sender] = ethBalance[msg.sender].sub(offer.takerWei);
        ethBalance[offer.maker] = ethBalance[offer.maker].add(offer.takerWei);
        
        for (uint i = 0; i < makerIds.length; i++) {
            _transfer(msg.sender, makerIds[i]);
        }
        
        for (uint i = 0; i < takerIds.length; i++) {
            _transfer(maker, takerIds[i]);
        }
        
        bytes32 hash = hashOffer(offer);
        cancelledOffers[hash] = true;
        emit Trade(hash, offer.maker, msg.sender, offer.makerWei, offer.makerIds, offer.takerWei, offer.takerIds);
    }

    function withdraw(uint amount) external {
        require(amount <= ethBalance[msg.sender]);
        ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);
        msg.sender.transfer(amount);
        emit Withdraw(msg.sender, amount);
    }

    function deposit() external payable {
        ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);
        emit Deposit(msg.sender, msg.value);
    }

}",4868,5,3,"Okay, let's analyze the provided smart contract for potential vulnerabilities.

**High Severity**

1.  **Reentrancy Vulnerability in `withdraw()`:**

    *   **Description:** The `withdraw()` function directly transfers Ether to the caller *after* updating the `ethBalance`. This creates a classic reentrancy vulnerability. A malicious contract could call `withdraw()`, and within the fallback function of the receiving contract, call `withdraw()` again *before* the first withdrawal's `ethBalance` is updated. This allows the attacker to withdraw more Ether than they own.
    *   **Location:** `Beebots.sol:648`
    *   **Mitigation:** Use the ""Checks-Effects-Interactions"" pattern. Update the `ethBalance` *before* calling `msg.sender.transfer(amount)`.
    *   Implement OpenZeppelin's ReentrancyGuard modifier to prevent reentrancy.
2.  **Potential Front Running Vulnerability in `mint()` function:**
    *   **Description:** The `mint()` function does not protect from front running attacks. A malicious user can monitor the mempool and front-run the `mint()` function by increasing the gas price.
    *   **Location:** `Beebots.sol:353`
    *   **Mitigation:** Consider implementing a commit-reveal scheme.

**Medium Severity**

1.  **Integer Overflow/Underflow in `randomIndex()`:**

    *   **Description:** While the `SafeMath` library is used in most arithmetic operations, the `randomIndex()` function uses `nonce.add(1)` which does not take advantage of the `SafeMath` library. An attacker can cause an integer overflow/underflow that would lead to unexpected behavior in the smart contract.
    *   **Location:** `Beebots.sol:280`
    *   **Mitigation:** Use SafeMath library for nonce increment.
2.  **Denial of Service (DoS) in `_removeNFToken()` due to unbounded `ownerToIds` array:**

    *   **Description:**  The `_removeNFToken()` function involves potentially shifting elements in the `ownerToIds` array. If an owner possesses a large number of tokens, removing a token (especially one near the beginning of the array) will require shifting a significant portion of the array. This could consume a large amount of gas, potentially leading to a denial of service if the gas cost exceeds transaction limits.
    *   **Location:** `Beebots.sol:335`
    *   **Mitigation:** Consider using a data structure that is more efficient for removals, such as a linked list or a mapping to track token ownership.
3.  **Improper access control in `devMint()` function:**

    *   **Description:** The `devMint()` function allows the deployer to mint tokens to any recipient.
    *   **Location:** `Beebots.sol:309`
    *   **Mitigation:** Ensure this functionality is intended.

**Low Severity**

1.  **Lack of Input Validation:**
    *   **Description:** Several functions lack sufficient input validation. For example:
        *   `startSale()`: `_price` and `_saleDuration` should be validated to prevent unreasonable values (e.g., zero price, excessively long duration).
        *   `devMint()`: `quantity` should be validated to prevent accidental or malicious minting of a very large number of tokens.
    *   **Mitigation:** Add checks to ensure inputs are within acceptable ranges.
2.  **Missing Zero-Address Checks:** While some functions check for zero addresses, ensure that every function where an address is passed as input, a check is made to prevent `address(0)` from being used.
    * `startSale()`
    * `devMint()`
3.  **Unused `cancelledOffers` Mapping After Trade Execution:** After a trade is executed in `acceptTrade()`, the corresponding offer's hash is marked as cancelled in the `cancelledOffers` mapping.  However, this mapping is never actually cleared or used for any other purpose. This means the storage slot is permanently consumed, even though the offer will never be valid again.
    *   **Mitigation:** If the goal is simply to prevent the same offer from being accepted twice, a simpler approach might be to just track recently executed offer hashes in a temporary data structure (e.g., a list that's cleared periodically) rather than permanently storing them. If the long-term history of cancelled offers is important, consider an event log instead of storage.

**Gas Optimization and Code Style**

1.  **Unnecessary `require` statements**: Some require statements are redundant and unnecessary.
2.  **`getPrice()` function**: This function's logic can be simplified to avoid redundant calculations.
3.  **Use `calldata` instead of `memory` where possible:** The `tradeValid` and `acceptTrade` functions use `memory` for arrays passed as parameters. If these arrays are only used within the function and not modified, using `calldata` can save gas.

**Recommendations:**

*   **Security Audit:**  Given the potential vulnerabilities, a professional security audit is strongly recommended.
*   **Formal Verification:**  For critical logic, consider using formal verification tools to mathematically prove the absence of certain bugs.
*   **Regular Updates:** Keep the Solidity compiler version up to date to benefit from the latest security patches and optimizations.

By addressing these vulnerabilities and following secure coding practices, you can significantly improve the security and reliability of your smart contract. Remember to thoroughly test all changes before deploying to a production environment.","### **Comparison of Issue Report and Response List**

---

#### **[H-01] Signature malleability of EVM's ecrecover in `verify()`**

**Report Description**:  
The `ecrecover` function in the `verify()` function is susceptible to signature malleability, which could allow replay attacks. While the issue is mitigated by tracking accepted offers and canceling them, changes in application logic could reintroduce the risk of replay attacks.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of signature malleability or the potential for replay attacks related to `ecrecover`. This is a critical omission, as signature malleability is a well-known vulnerability in Solidity.

---

#### **[H-02] Arbitrary Transfer of Unowned NFTs**

**Report Description**:  
The `tradeValid` function, invoked by `acceptTrade`, does not properly validate the behavior of `ecrecover`. When `ecrecover` is invoked with an invalid signature, it returns the zero-address, causing `verify` to yield `true` for the zero-address. This allows arbitrary transfer of NFTs whose `idToOwner` is zero, including unminted NFTs.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of arbitrary NFT transfers due to improper validation of `ecrecover` or the zero-address. This is a significant security oversight.

---

#### **[H-03] `Beebots.TradeValid()` Will Erroneously Return True When Maker Is Set To `Address(0)` and `makerIds` Are Set To The `TokenIds` of Unminted Beebot NFTs**

**Report Description**:  
`Beebots.verify()` returns `true` when the signer is set to `address(0)`, regardless of the signature. This causes `tradeValid()` to erroneously return `true` when `maker` is set to `address(0)` and `makerIds` are set to unminted NFT token IDs. This allows attackers to exploit unminted NFTs.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `verify()` returning `true` for `address(0)` or the exploitation of unminted NFTs. This is a critical vulnerability that is entirely missed.

---

#### **[H-04] Function `tokenByIndex` Treats Last Index as Invalid**

**Report Description**:  
The `tokenByIndex` function incorrectly sets boundaries with `require(index > 0 && index < TOKEN_LIMIT)`, treating the last index as invalid. This could lead to incorrect token indexing and potential out-of-bounds errors.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect index boundaries in `tokenByIndex`. This is a logical error that could lead to runtime issues.

---

#### **[H-05] NFT Can Be Minted for Free After Sale Ended**

**Report Description**:  
The `getPrice()` function returns 0 after the sale ends, allowing NFTs to be minted for free. Without documentation, it is unclear if this is expected behavior. If unintended, this could be exploited by attackers to claim remaining NFTs.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of free NFT minting after the sale ends. This is a significant economic vulnerability.

---

#### **[M-00] Legacy Function Usage**

**Report Description**:  
The `withdraw` function uses `transfer`, which has a fixed gas stipend and can fail, especially after the Berlin fork, which increased gas costs for first-time `transfer` invocations.

**Match in Response List**:  
Matches with the issue titled **""Denial of Service (DoS) in `_removeNFToken()` due to unbounded `ownerToIds` array""**.

**Validation**:  
**Partially Correct**. The response list mentions gas-related issues but does not specifically address the use of `transfer` in `withdraw`. The match is not accurate, as the response focuses on a different issue.

---

#### **[M-01] `randomIndex` Is Not Truly Random - Possibility of Predictably Minting a Specific Token Id**

**Report Description**:  
The `randomIndex` function is not truly random, as it relies on predictable values like `block.timestamp` and `block.difficulty`. This allows miners or attackers to predictably mint specific token IDs.

**Match in Response List**:  
Matches with the issue titled **""Integer Overflow/Underflow in `randomIndex()`""**.

**Validation**:  
**Partially Correct**. The response list identifies an issue with `randomIndex` but focuses on integer overflow/underflow rather than the lack of randomness. This is a partial match, as the core issue is not fully addressed.

---

#### **[M-02] Instead of `call()`, `transfer()` Is Used to Withdraw the Ether**

**Report Description**:  
The `withdraw` function uses `transfer()`, which can fail if the recipient is a contract with a payable function that requires more than 2300 gas or is called through a proxy.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in `withdraw()`""**.

**Validation**:  
**Partially Correct**. The response list identifies an issue with `withdraw` but focuses on reentrancy rather than the use of `transfer()`. This is a partial match, as the core issue is not fully addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-00] Legacy Function Usage**  
- **[M-01] `randomIndex` Is Not Truly Random - Possibility of Predictably Minting a Specific Token Id**  
- **[M-02] Instead of `call()`, `transfer()` Is Used to Withdraw the Ether**

**Missed Issues from Issue Report**:  
- **[H-01] Signature malleability of EVM's ecrecover in `verify()`**  
- **[H-02] Arbitrary Transfer of Unowned NFTs**  
- **[H-03] `Beebots.TradeValid()` Will Erroneously Return True When Maker Is Set To `Address(0)` and `makerIds` Are Set To The `TokenIds` of Unminted Beebot NFTs**  
- **[H-04] Function `tokenByIndex` Treats Last Index as Invalid**  
- **[H-05] NFT Can Be Minted for Free After Sale Ended**

---

### **Conclusion**  
The response list fails to address most of the high-severity issues in the issue report, particularly those related to `ecrecover`, NFT transfers, and free minting. While some medium-severity issues are partially addressed, the responses often misidentify the core vulnerabilities. A more comprehensive and accurate analysis is needed to ensure the security of the smart contract.",0,3,5,11,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**.

### Explanation:
Since there are no true positives in the provided list (`true_positives` is empty), there are no ranks at which true positives appear. Therefore, the precision at any rank is undefined, and the **Average Precision (AP)** is **0.0**."