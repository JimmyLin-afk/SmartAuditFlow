nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Detecting aspects,matchList,MAP
Vault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";

/**
 * A vault where other accounts can deposit an underlying token
 * currency and set distribution params for their principal and yield
 *
 * @dev Yield generation strategies not yet implemented
 */

contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    //
    // Constants
    //

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    //
    // State
    //

    /// Underlying ERC20 token accepted by the vault
    /// See {IVault}
    IERC20 public override(IVault) underlying;

    /// See {IVault}
    IStrategy public strategy;

    /// See {IVault}
    uint256 public investPerc;

    /// See {IVault}
    uint256 public immutable override(IVault) minLockPeriod;

    /// See {IVaultSponsoring}
    uint256 public override(IVaultSponsoring) totalSponsored;

    /// Depositors, represented as an NFT per deposit
    Depositors public depositors;

    /// Yield allocation
    Claimers public claimers;

    /// Unique IDs to correlate donations that belong to the same foundation
    Counters.Counter private _depositGroupIds;

    /**
     * @param _underlying Underlying ERC20 token to use.
     */
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    //
    // IVault
    //

    /// See {IVault}
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    /// See {IVault}
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    /// See {IVault}
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    /// See {IVault}
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    /// See {IVault}
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    /// See {IVault}
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    /// See {IVault}
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    /// See {IVault}
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    /// See {IVault}
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    /// See {IVault}
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    /// See {IVault}
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    //
    // IVaultSponsoring

    /// See {IVaultSponsoring}
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    /// See {IVaultSponsoring}
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    /// See {IVaultSponsoring}
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    //
    // Public API
    //

    /**
     * Computes the total amount of principal + yield currently controlled by the
     * vault and the strategy. The principal + yield is the total amount
     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.
     *
     * @return Total amount of principal and yield help by the vault (not including sponsored amount).
     */
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        // TODO no invested amount yet
        return totalUnderlying() - totalSponsored;
    }

    //
    // ERC165
    //

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    //
    // Internal API
    //

    /**
     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    /**
     * Withdraws the sponsored amount for the deposits with the ids provided
     * in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    /**
     * Creates a deposit with the given amount of underlying and claim
     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.
     * @notice This function assumes underlying will be transfered elsewhere in
     * the transaction.
     *
     * @notice Underlying must be transfered *after* this function, in order to
     * correctly calculate shares.
     *
     * @notice claims must add up to 100%.
     *
     * @param _amount Amount of underlying to consider @param claims claim
     * @param _lockedUntil When the depositor can unsponsor the amount.
     * @param claims Claim params
     * params.
     */
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    /**
     * Burns a deposit NFT and reduces the principal and shares of the claimer.
     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.
     *
     * @notice This function doesn't transfer any funds, it only updates the state.
     *
     * @notice Only the owner of the deposit may call this function.
     *
     * @param _tokenId The deposit ID to withdraw from.
     * @param _totalShares The total shares to consider for the withdraw.
     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.
     *
     * @return the amount to withdraw.
     */
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    /**
     * Computes amount of shares that will be received for a given deposit amount
     *
     * @param _amount Amount of deposit to consider.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount of shares the deposit will receive.
     */
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    /**
     * Computes the amount of underlying from a given number of shares
     *
     * @param _shares Number of shares.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount that corresponds to the number of shares.
     */
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            // TODO exclude sponsored assets
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    /**
     * Checks if the given address is a contract implementing IIntegration
     *
     * @param addr Address to check
     * @return true if contract is an IIntegraiont
     */
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",4418.0,652.0,"[H-01] `forceUnsponsor()` may open a window for attackers to manipulate the `_totalShares` and freeze users' funds at a certain deposit amount
function `_unsponsor()`, variables `totalSponsored`
When `sponsorAmount > totalUnderlying()`, the contract will transfer `totalUnderlying()` to `sponsorToTransfer`, even if there are other depositors and `totalShares` > 0.
After that, and before others despoiting into the Vault, the Attacker can send 1 wei underlying token, then cal `deposit()` with 0.1 * 1e18 , since `newShares = (_amount * _totalShares) / _totalUnderlyingMinusSponsored` and `_totalUnderlyingMinusSponsored` is 1, with a tiny amount of underlying token, newShares will become extremly large.
As we stated in issue #166, when the value of totalShares is manipulated precisely, the attacker can plant a bomb, and the contract will not work when the deposit/withdraw amount reaches a certain value, freezing the user's funds.
  [H-02] Withdrawers can get more value returned than expected with reentrant call
The impact of this is that users can get significantly more UST withdrawn than they would be alotted if they had done non-reentrant withdraw calls.
  [H-04] deposit() function is open to reentrancy attacks
In Vault.sol the `deposit()` function is left wide open to reentrancy attacks. The function eventually calls `_createDeposit()` => `_createClaim()` which calls `depositors.mint()` which will then mint an NFT. When the NFT is minted the sender will receive a callback which can then be used to call the `deposit()` function again before execution is finished. An attacker can do this minting multiple NFT's for themselves. claimers.mint() is also called in the same function which can also be used to call back into the deposit function before execution is complete. Since there are several state updates before and after NFT's are minted this can be used to further manipulate the protocol like with newShares which is called before minting. This is not counting what an attacker can do with cross function reentrancy entering into several other protocol functions (like withdraw) before code execution is complete further manipulating the system.
  [H-05] sponsor() function in open to reentrancy attacks
In Vault.sol the `sponsor()` function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender. Since there are state updates after the call to depositors.mint() function this is especially dangerous. An attacker can make it so the totalSponsored amount is only updated once after calling mint() several times since the update takes place after the callback. The same will be true for the Sponsored event that is emitted.
  [M-04] `_unsponsor`, claimYield and withdraw might fail unexpectedly
`totalUnderlying()` includes the invested assets, they are not in the contract balance.
when a user calls withdraw, claimYield or unsponsor, the system might not have enough assets in the balance and the transfer would fail.
especially, force unsponsor will always fail, because it tries to transfer the entire `totalUnderlying()`, which the system doesn't have:
  [M-06] `totalUnderlyingMinusSponsored()` may revert on underflow and malfunction the contract
As a function that many other functions depended on, `totalUnderlyingMinusSponsored()` can revert on underflow when `sponsorAmount > totalUnderlying()` which is possible and has been considered elsewhere in this contract:   [M-07] Vault can't receive deposits if underlying token charges fees on transfer
`function _transferAndCheckUnderlying`
Some ERC20 tokens charge a fee for every transfer. If the underlying token of a vault is such a token any deposit to the protocol will fail.
Some tokens have the possibility of adding fees later on, e.g. USDT. So those have to be covered too.
Generally, the user would also receive fewer tokens on withdrawing in such a scenario but that's not the protocol's fault.
  [M-15] Check `_to` is not empty
functions claimYield, `_withdraw`, and `_unsponsor` should validate that `_to` is not an empty 0x0 address to prevent accidental burns.",8.0,"pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";



contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    
    
    

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; 
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    
    
    

    
    
    IERC20 public override(IVault) underlying;

    
    IStrategy public strategy;

    
    uint256 public investPerc;

    
    uint256 public immutable override(IVault) minLockPeriod;

    
    uint256 public override(IVaultSponsoring) totalSponsored;

    
    Depositors public depositors;

    
    Claimers public claimers;

    
    Counters.Counter private _depositGroupIds;

    
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    
    
    

    
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    
    

    
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    
    
    

    
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        
        return totalUnderlying() - totalSponsored;
    }

    
    
    

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    
    
    

    
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",3364.0,4,4,"{
  ""Findings"": [
    {
      ""Issue"": ""Improper Use of Checks-Effects-Interactions Pattern"",
      ""Severity"": ""High"",
      ""Description"": ""The contract does not consistently follow the checks-effects-interactions pattern, especially in functions like `_withdraw` and `_unsponsor`. External calls are made before the contract's state is fully updated, leading to potential security vulnerabilities such as reentrancy attacks."",
      ""Impact"": ""A reentrancy attack could allow a malicious actor to withdraw more funds than they are entitled to, leading to a loss of assets from the vault."",
      ""Location"": ""Functions `_withdraw` (lines 262, 258) and `_unsponsor` (lines 277, 279)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a critical vulnerability related to the checks-effects-interactions pattern, which is crucial for preventing reentrancy and is directly relevant to the task scope.""
    },
    {
      ""Issue"": ""Improper Use of `requiresTrust` Modifier"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `setStrategy`, `setInvestPerc`, and `updateInvested` functions are correctly protected by the `requiresTrust` modifier, but there is no detailed verification logic regarding how entities gain or lose trust, which could lead to unauthorized access."",
      ""Impact"": ""If the `Trust` mechanism is not correctly implemented, unauthorized users may gain access to privileged functions, potentially leading to financial loss or system instability."",
      ""Location"": ""Functions `setStrategy` (line 59), `setInvestPerc` (line 155), `updateInvested` (line 170)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding addresses the task's objective of ensuring privileged functions are properly secured with the `requiresTrust` modifier, highlighting potential issues if the trust mechanism is not fully implemented.""
    },
    {
      ""Issue"": ""Potential Misconfiguration of Initial Parameters"",
      ""Severity"": ""High"",
      ""Description"": ""The constructor sets critical parameters like `underlying`, `investPerc`, and initializes `Depositors` and `Claimers` contracts. Incorrect configuration could cause unintended operation or vulnerabilities."",
      ""Impact"": ""Incorrect initial configuration could lead to loss of funds, inability to operate correctly, or exposure to vulnerabilities."",
      ""Location"": ""Constructor (lines 49-68)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights the importance of initial parameter configuration, in line with the task's requirement to ensure the contract's secure initial state.""
    },
    {
      ""Issue"": ""Unvalidated External Interfaces"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract makes external calls to interfaces such as `IIntegration` and `IStrategy` without validating expected return values or ensuring interface integrity."",
      ""Impact"": ""If external contracts do not behave as expected, this could lead to unintended behavior or security breaches."",
      ""Location"": ""Functions interacting with `IIntegration` and `IStrategy`, e.g., `setStrategy` (line 84) and `_createClaim` (line 206)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding addresses the security of external interactions, a key aspect in smart contract design, especially since these interfaces can significantly impact contract behavior.""
    },
    {
      ""Issue"": ""Improper Validation of Strategy Address"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `setStrategy` function does not thoroughly validate the provided strategy contract beyond checking the vault address and invested assets. It risks integration with a strategy that may not perform as expected."",
      ""Impact"": ""This could lead to integration with a strategy contract that does not perform as expected, potentially resulting in loss of funds or mismanagement of assets."",
      ""Location"": ""Function `setStrategy` defined at line 80"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding highlights a critical issue in ensuring the safety and correctness of the strategy integration, which could lead to severe consequences such as loss of funds.""
    },
    {
      ""Issue"": ""Potential Division by Zero in _computeAmount"",
      ""Severity"": ""High"",
      ""Description"": ""The `_computeAmount` function divides the product of `_totalUnderlyingMinusSponsored` and `_shares` by `_totalShares`. If `_totalShares` is zero, this would lead to a division by zero error."",
      ""Impact"": ""This can result in a runtime error, halting the contract execution and potentially causing denial of service."",
      ""Location"": ""Function `_computeAmount`, line 361"",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Lack of Access Control on `forceWithdraw` and `forceUnsponsor` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `forceWithdraw` and `forceUnsponsor` functions allow bypassing standard withdrawal constraints without sufficient access control checks."",
      ""Impact"": ""Unauthorized users could potentially withdraw funds or unsponsor deposits, leading to financial discrepancies and potential exploitation."",
      ""Location"": ""Functions `forceWithdraw` (line 140, 129) and `forceUnsponsor` (line 215, 179)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The task involves ensuring proper implementation of functions defined in interfaces. Lack of access control is a critical security issue that aligns with the task's focus on ensuring correct contract behavior.""
    },
    {
      ""Issue"": ""Improper Lock Period Validation in sponsor"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `sponsor` function sets a lock period based on `_lockedUntil`, but it only checks if it is greater than or equal to `MIN_SPONSOR_LOCK_DURATION`, possibly allowing undesirable lock durations."",
      ""Impact"": ""This can lead to funds being locked for undesirable durations, impacting liquidity and user experience."",
      ""Location"": ""Function `sponsor`, lines 170-176"",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Low"",
      ""Description"": ""Certain functions like `sponsor` and `deposit` do not perform thorough validation on input parameters, such as ensuring `_amount` is greater than zero."",
      ""Impact"": ""This could allow users to perform operations with zero or invalid values, potentially leading to logical errors or unexpected behavior."",
      ""Location"": ""Functions `sponsor` (line 208) and `deposit` (line 124)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""While this finding is less severe, input validation is essential to prevent misuse and ensure contract robustness.""
    },
    {
      ""Issue"": ""Unnecessary Balance Check with SafeERC20"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_transferAndCheckUnderlying` function checks the balance before and after a transfer, which may not be necessary if the token follows the ERC20 standard correctly."",
      ""Impact"": ""This can lead to slightly higher gas costs due to additional balance checks."",
      ""Location"": ""Function `_transferAndCheckUnderlying` defined in lines 326-335"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding aligns with the task's focus on optimizing SafeERC20 method usage by suggesting the removal of unnecessary balance checks.""
    }
  ],
  ""FindingNumber"": 10,
  ""AllRelevance"": 33,
  ""RelevanceCount"": 31,
  ""AllValidation"": 33,
  ""ValidationCount"": 31
}","### **Comparison and Evaluation**

---

#### **[H-01] `forceUnsponsor()` may open a window for attackers to manipulate the `_totalShares` and freeze users' funds at a certain deposit amount**

**Report Description**:  
The `forceUnsponsor()` function allows an attacker to manipulate `_totalShares` by depositing a tiny amount of underlying tokens after `sponsorAmount > totalUnderlying()`. This can lead to an extremely large `newShares` value, potentially freezing user funds when the deposit/withdraw amount reaches a certain value.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of `forceUnsponsor()` enabling manipulation of `_totalShares` or the freezing of user funds. This is a critical vulnerability that is entirely missed.

---

#### **[H-02] Withdrawers can get more value returned than expected with reentrant call**

**Report Description**:  
The withdraw function is vulnerable to reentrancy attacks, allowing users to withdraw significantly more UST than they are entitled to by exploiting reentrant calls.

**Match in Response List**:  
Matches with the issue titled **""Improper Use of Checks-Effects-Interactions Pattern""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in the withdraw function, aligning with the issue's description. The impact of reentrancy leading to excessive withdrawals is correctly highlighted.

---

#### **[H-04] `deposit()` function is open to reentrancy attacks**

**Report Description**:  
The `deposit()` function in `Vault.sol` is vulnerable to reentrancy attacks due to state updates occurring after NFT minting callbacks. This allows attackers to manipulate the protocol by reentering the function before execution is complete.

**Match in Response List**:  
Matches with the issue titled **""Improper Use of Checks-Effects-Interactions Pattern""**.

**Validation**:  
**Correct**. The response correctly identifies the reentrancy vulnerability in the `deposit()` function, emphasizing the risks associated with state updates after external calls. This aligns with the issue's description.

---

#### **[H-05] `sponsor()` function is open to reentrancy attacks**

**Report Description**:  
The `sponsor()` function lacks a reentrancy guard, allowing attackers to reenter the function via the `depositors.mint()` callback. This can lead to incorrect updates of `totalSponsored` and other state variables.

**Match in Response List**:  
Matches with the issue titled **""Improper Use of Checks-Effects-Interactions Pattern""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in the `sponsor()` function, highlighting the risks of state updates after external calls. This aligns with the issue's description.

---

#### **[M-04] `_unsponsor`, `claimYield`, and `withdraw` might fail unexpectedly**

**Report Description**:  
These functions may fail unexpectedly because `totalUnderlying()` includes invested assets not in the contract balance. This can lead to transfer failures, especially in `forceUnsponsor`, which attempts to transfer the entire `totalUnderlying()`.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of `totalUnderlying()` including invested assets, leading to potential transfer failures. This is a significant oversight.

---

#### **[M-06] `totalUnderlyingMinusSponsored()` may revert on underflow and malfunction the contract**

**Report Description**:  
The `totalUnderlyingMinusSponsored()` function may revert on underflow when `sponsorAmount > totalUnderlying()`, causing the contract to malfunction.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the underflow vulnerability in `totalUnderlyingMinusSponsored()`. This is a critical issue that is entirely missed.

---

#### **[M-07] Vault can't receive deposits if underlying token charges fees on transfer**

**Report Description**:  
If the underlying token charges fees on transfer, deposits to the protocol will fail. This is particularly problematic for tokens like USDT, which can add fees later.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of deposit failures due to transfer fees on the underlying token. This is a significant oversight.

---

#### **[M-15] Check `_to` is not empty**

**Report Description**:  
Functions like `claimYield`, `_withdraw`, and `_unsponsor` should validate that `_to` is not an empty address to prevent accidental burns.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing validation for the `_to` address in critical functions. This is a significant oversight.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Withdrawers can get more value returned than expected with reentrant call**
- **[H-04] `deposit()` function is open to reentrancy attacks**
- **[H-05] `sponsor()` function is open to reentrancy attacks**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] `forceUnsponsor()` may open a window for attackers to manipulate the `_totalShares` and freeze users' funds at a certain deposit amount**
- **[M-04] `_unsponsor`, `claimYield`, and `withdraw` might fail unexpectedly**
- **[M-06] `totalUnderlyingMinusSponsored()` may revert on underflow and malfunction the contract**
- **[M-07] Vault can't receive deposits if underlying token charges fees on transfer**
- **[M-15] Check `_to` is not empty**

---

### **Conclusion**

The response list effectively addresses reentrancy vulnerabilities but misses several critical issues, including manipulation of `_totalShares`, transfer failures due to invested assets, underflow vulnerabilities, deposit failures due to transfer fees, and missing address validation. These gaps highlight the need for a more comprehensive review of the contract's security posture.",3,0,5,10,31,"```
1. Improper Use of Checks-Effects-Interactions Pattern
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Improper Use of Checks-Effects-Interactions Pattern"".
   - This finding appears at **rank 1** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
NonUSTStrategy.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import ""./curve/ICurve.sol"";
import ""./BaseStrategy.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/**
 * Strategy that handles non-UST tokens, by first converting them to UST via
 * Curve (https://curve.fi/), and only then depositing into EthAnchor
 */
contract NonUSTStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    // address of the Curve pool to use
    ICurve public curvePool;

    // index of the underlying token in the pool
    int128 public underlyingI;

    // index of the UST token in the pool
    int128 public ustI;

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner,
        address _curvePool,
        int128 _underlyingI,
        int128 _ustI
    )
        BaseStrategy(
            _vault,
            _treasury,
            _ethAnchorRouter,
            _exchangeRateFeeder,
            _ustToken,
            _aUstToken,
            _perfFeePct,
            _owner
        )
    {
        require(underlying != _ustToken, ""invalid underlying"");
        require(_curvePool != address(0), ""0x addr"");
        curvePool = ICurve(_curvePool);
        underlyingI = _underlyingI;
        ustI = _ustI;

        ustToken.safeApprove(_curvePool, type(uint256).max);
        underlying.safeApprove(_curvePool, type(uint256).max);
    }

    /**
     * Swaps the underlying currency for UST, and initiates a deposit of all
     * the converted UST into EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the deposit process, but does not finish it.
     */
    function doHardWork() external override(BaseStrategy) restricted {
        _swapUnderlyingToUst();
        _initDepositStable();
    }

    /**
     * Calls Curve to convert the existing underlying balance into UST
     */
    function _swapUnderlyingToUst() internal {
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            // slither-disable-next-line unused-return
            curvePool.exchange_underlying(
                underlyingI,
                ustI,
                underlyingBalance,
                0
            );
        }
    }

    /**
     * Calls Curve to convert the existing UST back into the underlying token
     */
    function _swapUstToUnderlying() internal {
        uint256 ustBalance = _getUstBalance();
        if (ustBalance > 0) {
            // slither-disable-next-line unused-return
            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);
        }
    }

    /**
     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.
     * Once UST is retrieved, convert it back to underlying via Curve
     *
     * @notice Must be called some time after `initRedeemStable()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending redeem operation
     */
    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {
        super.finishRedeemStable(idx);
        _swapUstToUnderlying();
    }

    /**
     * Amount, expressed in the underlying currency, currently in the strategy
     *
     * @notice both held and invested amounts are included here, using the
     * latest known exchange rates to the underlying currency
     *
     * @return The total amount of underlying
     */
    function investedAssets()
        external
        view
        override(BaseStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance();
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(
            address(aUstToken),
            true
        ) * aUstBalance) / 1e18) + pendingDeposits;
        return
            underlyingBalance +
            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);
    }
}",1005.0,137.0,"[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool
In short, the NonUSTStrategy is vulnerable to attacks by flash loans on curve pools.
- Here’s an outline of the attack:
- Assume there is a vault with DAI underlying and a NonUSTStrategy with a DAI / UST curve pool
- Take out a flash loan of DAI
- Exchange a ton of DAI for UST
- The exchange rate from DAI to UST has gone up (!!)
- Withdraw or deposit from vault with more favorable terms than market
- Transfer back UST to DAI
- Repay flash loan
  [M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users
Function `_swapUnderlyingToUst`
NonUSTStrategy will swap the deposited non-UST assets into UST before depositing to EthAnchor. However, the swap fee is not attributed to the depositor correctly like many other yield farming vaults involving swaps (ZapIn).
An attacker can exploit it for the swap fees paid by other users by taking a majority share of the liquidity pool.
  [M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals
The `investedAssets()` function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in `finishRedeemStable()`.",3.0,"pragma solidity ^0.8.10;

import ""./curve/ICurve.sol"";
import ""./BaseStrategy.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";


contract NonUSTStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    
    ICurve public curvePool;

    
    int128 public underlyingI;

    
    int128 public ustI;

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner,
        address _curvePool,
        int128 _underlyingI,
        int128 _ustI
    )
        BaseStrategy(
            _vault,
            _treasury,
            _ethAnchorRouter,
            _exchangeRateFeeder,
            _ustToken,
            _aUstToken,
            _perfFeePct,
            _owner
        )
    {
        require(underlying != _ustToken, ""invalid underlying"");
        require(_curvePool != address(0), ""0x addr"");
        curvePool = ICurve(_curvePool);
        underlyingI = _underlyingI;
        ustI = _ustI;

        ustToken.safeApprove(_curvePool, type(uint256).max);
        underlying.safeApprove(_curvePool, type(uint256).max);
    }

    
    function doHardWork() external override(BaseStrategy) restricted {
        _swapUnderlyingToUst();
        _initDepositStable();
    }

    
    function _swapUnderlyingToUst() internal {
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            
            curvePool.exchange_underlying(
                underlyingI,
                ustI,
                underlyingBalance,
                0
            );
        }
    }

    
    function _swapUstToUnderlying() internal {
        uint256 ustBalance = _getUstBalance();
        if (ustBalance > 0) {
            
            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);
        }
    }

    
    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {
        super.finishRedeemStable(idx);
        _swapUstToUnderlying();
    }

    
    function investedAssets()
        external
        view
        override(BaseStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance();
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(
            address(aUstToken),
            true
        ) * aUstBalance) / 1e18) + pendingDeposits;
        return
            underlyingBalance +
            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);
    }
}",664.0,1,2,"{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy and Access Control Issues"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `doHardWork`, `finishRedeemStable`, `_swapUnderlyingToUst`, and `_swapUstToUnderlying` are vulnerable to reentrancy attacks and lack robust access control mechanisms. These functions interact with external contracts without following the Checks-Effects-Interactions pattern, which could lead to unauthorized fund manipulation."",
      ""Impact"": ""An attacker could exploit these vulnerabilities to manipulate contract states, perform unauthorized actions, and drain funds, leading to financial losses."",
      ""Location"": ""Functions `doHardWork` (lines 52-59), `finishRedeemStable` (lines 84-90), `_swapUnderlyingToUst`, `_swapUstToUnderlying`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding highlights critical security vulnerabilities concerning reentrancy risks and access control issues, directly addressing the task's focus on secure and authorized operations.""
    },
    {
      ""Issue"": ""Use of Zero Minimums and Lack of Return Value Handling in Curve Exchanges"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `exchange_underlying` function is invoked with a minimum return amount of zero and without handling the return value, which can lead to significant slippage, unfavorable exchange rates, and undetected swap failures."",
      ""Impact"": ""This can result in financial losses due to slippage and incorrect balances, affecting the strategy's financial integrity."",
      ""Location"": ""Functions `_swapUnderlyingToUst` and `_swapUstToUnderlying`, lines where `curvePool.exchange_underlying` is called."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""These findings address financial and operational risks associated with exchange operations, relevant for ensuring effective and loss-minimized swaps.""
    },
    {
      ""Issue"": ""Approval and Constructor Initialization Concerns"",
      ""Severity"": ""Medium"",
      ""Description"": ""Using SafeERC20's `safeApprove` function with infinite allowances in the constructor poses risks if the Curve pool is compromised. Additionally, the constructor-based initialization limits upgradeability potential."",
      ""Impact"": ""If the Curve pool is compromised, it could drain all tokens. The lack of upgradeability mechanisms increases future costs and complexity for contract updates."",
      ""Location"": ""Constructor in `NonUSTStrategy` (lines 19-38), `safeApprove` usage lines 37-38."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The findings are relevant in highlighting approval risks and upgradeability limitations, crucial for maintaining secure and adaptable contract operations.""
    },
    {
      ""Issue"": ""Potential Arithmetic Overflow/Underflow and External Dependency Risks"",
      ""Severity"": ""Low"",
      ""Description"": ""Arithmetic operations, especially those involving user inputs, might encounter edge cases despite Solidity 0.8.x's checks. Additionally, reliance on external exchange rates could lead to incorrect asset calculations if the feeder is compromised."",
      ""Impact"": ""Unchecked arithmetic can cause unexpected behavior, and incorrect rates can mislead strategy decisions, affecting user trust and financial accuracy."",
      ""Location"": ""Various contract functions, especially `investedAssets` (lines 76-80, 102)."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""These findings ensure adherence to safe math principles and highlight the importance of cautious external interactions, aligning with the task's focus on reliable contract functionality.""
    }
  ],
  ""FindingNumber"": 4,
  ""AllRelevance"": 20,
  ""RelevanceCount"": 18,
  ""AllValidation"": 20,
  ""ValidationCount"": 18
}","### **[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool**

**Report Description**:  
The `NonUSTStrategy` is vulnerable to flash loan attacks on curve pools. An attacker can exploit this by taking out a flash loan of the underlying asset (e.g., DAI), manipulating the exchange rate between the underlying asset and UST, and then withdrawing or depositing from the vault with more favorable terms than the market. This can lead to financial losses and manipulation of the vault's assets.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific vulnerability of flash loan attacks on curve pools in the `NonUSTStrategy`. While the response list mentions issues like reentrancy and access control, it does not cover the manipulation of exchange rates or the exploitation of flash loans, which are critical to this issue.

---

### **[M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users**

**Report Description**:  
The `_swapUnderlyingToUst` function in `NonUSTStrategy.sol` does not correctly attribute swap fees to the depositor. An attacker can exploit this by taking a majority share of the liquidity pool, allowing them to steal swap fees paid by other users. This misallocation of fees can lead to financial losses for legitimate users.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the improper handling of swap fees in `_swapUnderlyingToUst`. While the response list mentions issues like zero minimums and lack of return value handling in curve exchanges, it does not cover the misallocation of swap fees or the potential for attackers to exploit this vulnerability.

---

### **[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Report Description**:  
The `investedAssets()` function in `BaseStrategy.sol` and `NonUSTStrategy.sol` does not account for the performance fee charged by the treasury during strategy withdrawals. This oversight can lead to incorrect calculations of the vault's investments, affecting financial accuracy and user trust.

**Match in Response List**:  
Matches with the issue titled **""Potential Arithmetic Overflow/Underflow and External Dependency Risks""**.

**Validation**:  
**Correct**. The response list mentions arithmetic overflow/underflow risks and external dependency risks, which are somewhat related to the issue of incorrect calculations in `investedAssets()`. However, it does not specifically address the performance fee omission, which is a critical aspect of this vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool**  
- **[M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users**

---

### **Conclusion**  
The response list partially addresses one issue ([M-12]) but misses two critical vulnerabilities ([H-03] and [M-02]). The responses focus on general security concerns like reentrancy, access control, and arithmetic risks but fail to cover specific exploits like flash loan attacks and swap fee misallocation. To improve coverage, the response list should include findings that directly address these specific vulnerabilities.",1,0,2,4,20,"```
1. Potential Arithmetic Overflow/Underflow and External Dependency Risks
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Potential Arithmetic Overflow/Underflow and External Dependency Risks"".
   - This finding appears at rank 4 in the ranked list of predictions.

2. **Calculate the precision at rank 4 (\( P@4 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 4, \( P@4 = \frac{1}{4} = 0.25 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.25 \).

**Output**:
```
0.25
```"
BaseStrategy.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import ""../lib/PercentMath.sol"";
import ""../vault/IVault.sol"";
import ""./IStrategy.sol"";
import ""./anchor/IEthAnchorRouter.sol"";
import ""./anchor/IExchangeRateFeeder.sol"";

// import ""./Controllable.sol"";

/**
 * Base strategy that handles UST tokens and invests them via the EthAnchor
 * protocol (https://docs.anchorprotocol.com/ethanchor/ethanchor)
 */
abstract contract BaseStrategy is IStrategy, Trust {
    using SafeERC20 for IERC20;
    using PercentMath for uint256;

    event PerfFeeClaimed(uint256 amount);
    event PerfFeePctUpdated(uint256 pct);

    struct Operation {
        address operator;
        uint256 amount;
    }

    IERC20 public override(IStrategy) underlying;
    // Vault address
    address public override(IStrategy) vault;

    // address of the treasury
    address public treasury;

    // address for the UST token
    IERC20 public ustToken;

    // address for the aUST token (wrapped Anchor UST, received to accrue interest for an Anchor deposit)
    IERC20 public aUstToken;

    // performance fee taken by the treasury on profits
    uint16 public perfFeePct;

    // external contract to interact with EthAnchor
    IEthAnchorRouter public ethAnchorRouter;

    // external exchange rate provider
    IExchangeRateFeeder public exchangeRateFeeder;

    // amount currently pending in deposits to EthAnchor
    uint256 public pendingDeposits;

    // amount currently pending redeemption from EthAnchor
    uint256 public pendingRedeems;

    // deposit operations history
    Operation[] public depositOperations;

    // redeem operations history
    Operation[] public redeemOperations;

    // amount of UST converted (used to calculate yield)
    uint256 public convertedUst;

    // restructs a function to be called only by the vault or governance
    modifier restricted() {
        require(msg.sender == vault || isTrusted[msg.sender], ""restricted"");

        _;
    }

    modifier onlyVault() {
        require(msg.sender == vault, ""only vault"");

        _;
    }

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner
    ) Trust(_owner) {
        require(_ethAnchorRouter != address(0), ""0x addr"");
        require(_exchangeRateFeeder != address(0), ""0x addr"");
        require(address(_ustToken) != address(0), ""0x addr"");
        require(address(_aUstToken) != address(0), ""0x addr"");
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");

        treasury = _treasury;
        vault = _vault;
        underlying = IVault(_vault).underlying();
        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);
        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);
        ustToken = _ustToken;
        aUstToken = _aUstToken;
        perfFeePct = _perfFeePct;

        // pre-approve EthAnchor router to transact all UST and aUST
        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);
        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);
    }

    /**
     * Initiates a deposit of all the currently held UST into EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the deposit process, but does not finish it.
     */
    function doHardWork() external virtual override(IStrategy) restricted {
        _initDepositStable();
    }

    function _initDepositStable() internal {
        uint256 ustBalance = _getUstBalance();
        require(ustBalance > 0, ""balance 0"");
        pendingDeposits += ustBalance;
        address _operator = ethAnchorRouter.initDepositStable(ustBalance);
        depositOperations.push(
            Operation({operator: _operator, amount: ustBalance})
        );
    }

    /**
     * Calls EthAnchor with a pending deposit ID, and attempts to finish it.
     *
     * @notice Must be called some time after `doHardWork()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending deposit operation
     */
    function finishDepositStable(uint256 idx) external {
        require(depositOperations.length > idx, ""not running"");
        Operation storage operation = depositOperations[idx];
        ethAnchorRouter.finishDepositStable(operation.operator);

        pendingDeposits -= operation.amount;
        convertedUst += operation.amount;

        operation.operator = depositOperations[depositOperations.length - 1]
            .operator;
        operation.amount = depositOperations[depositOperations.length - 1]
            .amount;
        depositOperations.pop();
    }

    /**
     * Initiates a withdrawal of UST from EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the redeem process, but does not finish it.
     *
     * @param amount Amount of aUST to redeem
     */
    function initRedeemStable(uint256 amount) public restricted {
        uint256 aUstBalance = _getAUstBalance();
        require(amount > 0, ""amount 0"");
        require(aUstBalance >= amount, ""insufficient"");
        pendingRedeems += amount;
        address _operator = ethAnchorRouter.initRedeemStable(amount);
        redeemOperations.push(Operation({operator: _operator, amount: amount}));
    }

    /**
     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.
     *
     * @notice Must be called some time after `initRedeemStable()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending redeem operation
     */
    function finishRedeemStable(uint256 idx) public virtual {
        require(redeemOperations.length > idx, ""not running"");
        Operation storage operation = redeemOperations[idx];
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;
        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;
        uint256 ustBalanceBefore = _getUstBalance();

        ethAnchorRouter.finishRedeemStable(operation.operator);

        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;
        uint256 perfFee = redeemedAmount > originalUst
            ? (redeemedAmount - originalUst).percOf(perfFeePct)
            : 0;
        if (perfFee > 0) {
            ustToken.safeTransfer(treasury, perfFee);
            emit PerfFeeClaimed(perfFee);
        }
        convertedUst -= originalUst;
        pendingRedeems -= operation.amount;

        operation.operator = redeemOperations[redeemOperations.length - 1]
            .operator;
        operation.amount = redeemOperations[redeemOperations.length - 1].amount;
        redeemOperations.pop();
    }

    /**
     * Withdraws the entire amount back to the vault
     *
     * @notice since some of the amount may be deposited into EthAnchor, this
     * call may not withdraw all the funds right away. It will start a redeem
     * process on EthAnchor, but this function must be called again a second
     * time once that is finished.
     */
    function withdrawAllToVault() external override(IStrategy) restricted {
        uint256 aUstBalance = _getAUstBalance();
        if (aUstBalance > 0) {
            initRedeemStable(aUstBalance);
        }
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            underlying.safeTransfer(vault, underlyingBalance);
        }
    }

    /**
     * Withdraws a specified amount back to the vault
     *
     * @notice Unlike `withdrawToVault`, this function only considers the
     * amount currently not invested, but only what is currently held by the
     * strategy
     *
     * @param amount Amount to withdraw
     */
    function withdrawToVault(uint256 amount)
        external
        override(IStrategy)
        restricted
    {
        underlying.safeTransfer(vault, amount);
    }

    /**
     * Updates the performance fee
     *
     * @notice Can only be called by governance
     *
     * @param _perfFeePct The new performance fee %
     */
    function setPerfFeePct(uint16 _perfFeePct) external restricted {
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");
        perfFeePct = _perfFeePct;
        emit PerfFeePctUpdated(_perfFeePct);
    }

    /**
     * Amount, expressed in the underlying currency, currently in the strategy
     *
     * @notice both held and invested amounts are included here, using the
     * latest known exchange rates to the underlying currency
     *
     * @return The total amount of underlying
     */
    function investedAssets()
        external
        view
        virtual
        override(IStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        return
            underlyingBalance +
            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *
                aUstBalance) / 1e18);
    }

    // Amount of underlying tokens in the strategy
    function _getUnderlyingBalance() internal view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    // Amount of UST tokens in the strategy
    function _getUstBalance() internal view returns (uint256) {
        return ustToken.balanceOf(address(this));
    }

    // Amount of aUST tokens in the strategy
    function _getAUstBalance() internal view returns (uint256) {
        return aUstToken.balanceOf(address(this));
    }

    // Amount of pending deposit operations
    function depositOperationLength() external view returns (uint256) {
        return depositOperations.length;
    }

    // Amount of pending redeem operations
    function redeemOperationLength() external view returns (uint256) {
        return redeemOperations.length;
    }
}",2363.0,303.0,"[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys
The current implementation requires trusted key holders (`isTrusted[msg.sender]`) to send transactions (`initRedeemStable()`) to initialize withdrawals from EthAnchor before the users can withdraw funds from the contract.
  [M-05] Add a timelock to BaseStrategy:`setPerfFeePct`
To give more trust to users: functions that set key/critical variables should be put behind a timelock.
 
[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals
The `investedAssets()` function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in `finishRedeemStable()`. Therefore, an attacker could avoid paying their fair share of the performance fee by withdrawing their assets before several calls to finishRedeemStable() are made and reenter the vault once the fee is charged.",3.0,"pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import ""../lib/PercentMath.sol"";
import ""../vault/IVault.sol"";
import ""./IStrategy.sol"";
import ""./anchor/IEthAnchorRouter.sol"";
import ""./anchor/IExchangeRateFeeder.sol"";




abstract contract BaseStrategy is IStrategy, Trust {
    using SafeERC20 for IERC20;
    using PercentMath for uint256;

    event PerfFeeClaimed(uint256 amount);
    event PerfFeePctUpdated(uint256 pct);

    struct Operation {
        address operator;
        uint256 amount;
    }

    IERC20 public override(IStrategy) underlying;
    
    address public override(IStrategy) vault;

    
    address public treasury;

    
    IERC20 public ustToken;

    
    IERC20 public aUstToken;

    
    uint16 public perfFeePct;

    
    IEthAnchorRouter public ethAnchorRouter;

    
    IExchangeRateFeeder public exchangeRateFeeder;

    
    uint256 public pendingDeposits;

    
    uint256 public pendingRedeems;

    
    Operation[] public depositOperations;

    
    Operation[] public redeemOperations;

    
    uint256 public convertedUst;

    
    modifier restricted() {
        require(msg.sender == vault || isTrusted[msg.sender], ""restricted"");

        _;
    }

    modifier onlyVault() {
        require(msg.sender == vault, ""only vault"");

        _;
    }

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner
    ) Trust(_owner) {
        require(_ethAnchorRouter != address(0), ""0x addr"");
        require(_exchangeRateFeeder != address(0), ""0x addr"");
        require(address(_ustToken) != address(0), ""0x addr"");
        require(address(_aUstToken) != address(0), ""0x addr"");
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");

        treasury = _treasury;
        vault = _vault;
        underlying = IVault(_vault).underlying();
        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);
        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);
        ustToken = _ustToken;
        aUstToken = _aUstToken;
        perfFeePct = _perfFeePct;

        
        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);
        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);
    }

    
    function doHardWork() external virtual override(IStrategy) restricted {
        _initDepositStable();
    }

    function _initDepositStable() internal {
        uint256 ustBalance = _getUstBalance();
        require(ustBalance > 0, ""balance 0"");
        pendingDeposits += ustBalance;
        address _operator = ethAnchorRouter.initDepositStable(ustBalance);
        depositOperations.push(
            Operation({operator: _operator, amount: ustBalance})
        );
    }

    
    function finishDepositStable(uint256 idx) external {
        require(depositOperations.length > idx, ""not running"");
        Operation storage operation = depositOperations[idx];
        ethAnchorRouter.finishDepositStable(operation.operator);

        pendingDeposits -= operation.amount;
        convertedUst += operation.amount;

        operation.operator = depositOperations[depositOperations.length - 1]
            .operator;
        operation.amount = depositOperations[depositOperations.length - 1]
            .amount;
        depositOperations.pop();
    }

    
    function initRedeemStable(uint256 amount) public restricted {
        uint256 aUstBalance = _getAUstBalance();
        require(amount > 0, ""amount 0"");
        require(aUstBalance >= amount, ""insufficient"");
        pendingRedeems += amount;
        address _operator = ethAnchorRouter.initRedeemStable(amount);
        redeemOperations.push(Operation({operator: _operator, amount: amount}));
    }

    
    function finishRedeemStable(uint256 idx) public virtual {
        require(redeemOperations.length > idx, ""not running"");
        Operation storage operation = redeemOperations[idx];
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;
        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;
        uint256 ustBalanceBefore = _getUstBalance();

        ethAnchorRouter.finishRedeemStable(operation.operator);

        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;
        uint256 perfFee = redeemedAmount > originalUst
            ? (redeemedAmount - originalUst).percOf(perfFeePct)
            : 0;
        if (perfFee > 0) {
            ustToken.safeTransfer(treasury, perfFee);
            emit PerfFeeClaimed(perfFee);
        }
        convertedUst -= originalUst;
        pendingRedeems -= operation.amount;

        operation.operator = redeemOperations[redeemOperations.length - 1]
            .operator;
        operation.amount = redeemOperations[redeemOperations.length - 1].amount;
        redeemOperations.pop();
    }

    
    function withdrawAllToVault() external override(IStrategy) restricted {
        uint256 aUstBalance = _getAUstBalance();
        if (aUstBalance > 0) {
            initRedeemStable(aUstBalance);
        }
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            underlying.safeTransfer(vault, underlyingBalance);
        }
    }

    
    function withdrawToVault(uint256 amount)
        external
        override(IStrategy)
        restricted
    {
        underlying.safeTransfer(vault, amount);
    }

    
    function setPerfFeePct(uint16 _perfFeePct) external restricted {
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");
        perfFeePct = _perfFeePct;
        emit PerfFeePctUpdated(_perfFeePct);
    }

    
    function investedAssets()
        external
        view
        virtual
        override(IStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        return
            underlyingBalance +
            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *
                aUstBalance) / 1e18);
    }

    
    function _getUnderlyingBalance() internal view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    
    function _getUstBalance() internal view returns (uint256) {
        return ustToken.balanceOf(address(this));
    }

    
    function _getAUstBalance() internal view returns (uint256) {
        return aUstToken.balanceOf(address(this));
    }

    
    function depositOperationLength() external view returns (uint256) {
        return depositOperations.length;
    }

    
    function redeemOperationLength() external view returns (uint256) {
        return redeemOperations.length;
    }
}",1636.0,0,3,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions `finishDepositStable` and `finishRedeemStable` lack proper access control, allowing any user to finalize operations. This can lead to unauthorized manipulation of deposits and redemptions."",
      ""Impact"": ""Unauthorized users could interfere with deposit and redeem processes, potentially causing financial loss or disrupting operations."",
      ""Location"": ""Functions `finishDepositStable` and `finishRedeemStable`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a critical security issue due to the lack of restrictions on sensitive functions, making it directly relevant.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Functions `finishRedeemStable` perform external calls before updating state variables, exposing them to potential reentrancy attacks."",
      ""Impact"": ""An attacker could exploit the function to manipulate state variables, leading to financial losses or incorrect contract states."",
      ""Location"": ""Function `finishRedeemStable`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The lack of reentrancy protection is a critical security flaw, as it can lead to severe exploits like draining contract funds.""
    },
    {
      ""Issue"": ""Unchecked External Call Return Values"",
      ""Severity"": ""High"",
      ""Description"": ""External calls to `ethAnchorRouter` in functions like `finishDepositStable` and `finishRedeemStable` do not check return values, which may lead to unhandled failures."",
      ""Impact"": ""If an external call fails silently, the subsequent logic could still execute, potentially leading to incorrect state changes or financial discrepancies."",
      ""Location"": ""Functions `finishDepositStable` and `finishRedeemStable`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Unchecked return values can lead to silent failures, a common source of bugs and vulnerabilities.""
    },
    {
      ""Issue"": ""Arithmetic Operations Without SafeMath"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations on state variables like `pendingDeposits` and `pendingRedeems` are performed without safe arithmetic checks, potentially leading to overflows or underflows."",
      ""Impact"": ""This could result in incorrect accounting of deposit and redeem amounts, leading to potential financial discrepancies."",
      ""Location"": ""Various functions handling deposits and redeems"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring safe arithmetic operations is crucial for contract integrity.""
    },
    {
      ""Issue"": ""Lack of Event Emission on Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions such as `finishDepositStable` and `finishRedeemStable` do not emit events upon state changes, reducing transparency and traceability."",
      ""Impact"": ""Without event emissions, it becomes difficult to track state changes and operations, reducing transparency and traceability for users and developers."",
      ""Location"": ""Functions `finishDepositStable` and `finishRedeemStable`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Events are important for transparency and auditability, especially for financial transactions.""
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 80,
  ""RelevanceCount"": 72,
  ""AllValidation"": 80,
  ""ValidationCount"": 72
}","### **Comparison of Issue Report and Response List**

---

#### **[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys**

**Report Description**:  
The current implementation requires trusted key holders (`isTrusted[msg.sender]`) to send transactions (`initRedeemStable()`) to initialize withdrawals from EthAnchor before users can withdraw funds from the contract. This creates a centralization risk where funds can be frozen if critical key holders lose access to their keys.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the centralization risk associated with trusted key holders. This issue is critical as it directly impacts the availability of funds and is a significant security concern. The lack of a match indicates a gap in the response list.

---

#### **[M-05] Add a timelock to BaseStrategy:`setPerfFeePct`**

**Report Description**:  
To increase user trust, functions that set key/critical variables (e.g., `setPerfFeePct`) should be put behind a timelock. This ensures that users have time to react to changes in critical parameters, reducing the risk of sudden or malicious modifications.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the need for timelocks on critical functions like `setPerfFeePct`. This is a governance-related security issue that enhances transparency and trust, and its absence in the response list is a notable gap.

---

#### **[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Report Description**:  
The `investedAssets()` function, implemented by the vault's strategy contracts, does not account for the performance fee charged by the treasury (as shown in `finishRedeemStable()`). This oversight allows an attacker to avoid paying their fair share of the performance fee by withdrawing assets before the fee is charged and reentering the vault afterward.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of performance fees being excluded from the `investedAssets()` calculation. This is a financial integrity issue that could lead to unfair fee avoidance, and its absence in the response list is a significant oversight.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
1. **[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys**  
2. **[M-05] Add a timelock to BaseStrategy:`setPerfFeePct`**  
3. **[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

---

### **Conclusion**  
The response list fails to address several critical issues from the issue report, particularly those related to centralization risks, governance (timelocks), and financial integrity (performance fees). These gaps highlight the need for a more comprehensive review of the smart contract's security and governance mechanisms.",0,0,3,5,80,"```
None.
```",0.0
,,,,,,,,5,9,,,4,0,10,19,131,,
