nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Detecting aspects,matchList,MAP
Controller.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IHarvester.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IManager.sol"";

/**
 * @title Controller
 * @notice This controller allows multiple strategies to be used
 * for a single vault supporting multiple tokens.
 */
contract Controller is IController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IManager public immutable override manager;

    bool public globalInvestEnabled;
    uint256 public maxStrategies;

    struct VaultDetail {
        address converter;
        uint256 balance;
        address[] strategies;
        mapping(address => uint256) balances;
        mapping(address => uint256) index;
        mapping(address => uint256) caps;
    }

    // vault => Vault
    mapping(address => VaultDetail) internal _vaultDetails;
    // strategy => vault
    mapping(address => address) internal _vaultStrategies;

    /**
     * @notice Logged when harvest is called for a strategy
     */
    event Harvest(address indexed strategy);

    /**
     * @notice Logged when a strategy is added for a vault
     */
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);

    /**
     * @notice Logged when a strategy is removed for a vault
     */
    event StrategyRemoved(address indexed vault, address indexed strategy);

    /**
     * @notice Logged when strategies are reordered for a vault
     */
    event StrategiesReordered(
        address indexed vault,
        address indexed strategy1,
        address indexed strategy2
    );

    /**
     * @param _manager The address of the manager
     */
    constructor(
        address _manager
    )
        public
    {
        manager = IManager(_manager);
        globalInvestEnabled = true;
        maxStrategies = 10;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Adds a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The cap of the strategy
     * @param _timeout The timeout between harvests
     */
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _cap,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultDetails[_vault].converter != address(0), ""!converter"");
        // checking if strategy is already added
        require(_vaultStrategies[_strategy] == address(0), ""Strategy is already added""); 
        // get the index of the newly added strategy
        uint256 index = _vaultDetails[_vault].strategies.length;
        // ensure we haven't added too many strategies already
        require(index < maxStrategies, ""!maxStrategies"");
        // push the strategy to the array of strategies
        _vaultDetails[_vault].strategies.push(_strategy);
        // set the cap
        _vaultDetails[_vault].caps[_strategy] = _cap;
        // set the index
        _vaultDetails[_vault].index[_strategy] = index;
        // store the mapping of strategy to the vault
        _vaultStrategies[_strategy] = _vault;
        if (_timeout > 0) {
            // add it to the harvester
            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);
        }
        emit StrategyAdded(_vault, _strategy, _cap);
    }

    /**
     * @notice Withdraws token from a strategy to the treasury address as returned by the manager
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     */
    function inCaseStrategyGetStuck(
        address _strategy,
        address _token
    )
        external
        onlyStrategist
    {
        IStrategy(_strategy).withdraw(_token);
        IERC20(_token).safeTransfer(
            manager.treasury(),
            IERC20(_token).balanceOf(address(this))
        );
    }

    /**
     * @notice Withdraws token from the controller to the treasury
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function inCaseTokensGetStuck(
        address _token,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        IERC20(_token).safeTransfer(manager.treasury(), _amount);
    }

    /**
     * @notice Removes a strategy for a given token
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _timeout The timeout between harvests
     */
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the index of the strategy to remove
        uint256 index = vaultDetail.index[_strategy];
        // get the index of the last strategy
        uint256 tail = vaultDetail.strategies.length.sub(1);
        // get the address of the last strategy
        address replace = vaultDetail.strategies[tail];
        // replace the removed strategy with the tail
        vaultDetail.strategies[index] = replace;
        // set the new index for the replaced strategy
        vaultDetail.index[replace] = index;
        // remove the duplicate replaced strategy
        vaultDetail.strategies.pop();
        // remove the strategy's index
        delete vaultDetail.index[_strategy];
        // remove the strategy's cap
        delete vaultDetail.caps[_strategy];
        // remove the strategy's balance
        delete vaultDetail.balances[_strategy];
        // remove the mapping of strategy to the vault
        delete _vaultStrategies[_strategy];
        // pull funds from the removed strategy to the vault
        IStrategy(_strategy).withdrawAll();
        // remove the strategy from the harvester
        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);
        emit StrategyRemoved(_vault, _strategy);
    }

    /**
     * @notice Reorders two strategies for a given vault
     * @param _vault The address of the vault
     * @param _strategy1 The address of the first strategy
     * @param _strategy2 The address of the second strategy
     */
    function reorderStrategies(
        address _vault,
        address _strategy1,
        address _strategy2
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultStrategies[_strategy1] == _vault, ""!_strategy1"");
        require(_vaultStrategies[_strategy2] == _vault, ""!_strategy2"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        // get the indexes of the strategies
        uint256 index1 = vaultDetail.index[_strategy1];
        uint256 index2 = vaultDetail.index[_strategy2];
        // set the new addresses at their indexes
        vaultDetail.strategies[index1] = _strategy2;
        vaultDetail.strategies[index2] = _strategy1;
        // update indexes
        vaultDetail.index[_strategy1] = index2;
        vaultDetail.index[_strategy2] = index1;
        emit StrategiesReordered(_vault, _strategy1, _strategy2);
    }

    /**
     * @notice Sets/updates the cap of a strategy for a vault
     * @dev If the balance of the strategy is greater than the new cap (except if
     * the cap is 0), then withdraw the difference from the strategy to the vault.
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     * @param _cap The new cap of the strategy
     */
    function setCap(
        address _vault,
        address _strategy,
        uint256 _cap,
        address _convert
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        _vaultDetails[_vault].caps[_strategy] = _cap;
        uint256 _balance = IStrategy(_strategy).balanceOf();
        // send excess funds (over cap) back to the vault
        if (_balance > _cap && _cap != 0) {
            uint256 _diff = _balance.sub(_cap);
            IStrategy(_strategy).withdraw(_diff);
            updateBalance(_vault, _strategy);
            _balance = IStrategy(_strategy).balanceOf();
            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);
            address _want = IStrategy(_strategy).want();
            _balance = IERC20(_want).balanceOf(address(this));
            if (_convert != address(0)) {
                IConverter _converter = IConverter(_vaultDetails[_vault].converter);
                IERC20(_want).safeTransfer(address(_converter), _balance);
                _balance = _converter.convert(_want, _convert, _balance, 1);
                IERC20(_convert).safeTransfer(_vault, _balance);
            } else {
                IERC20(_want).safeTransfer(_vault, _balance);
            }
        }
    }

    /**
     * @notice Sets/updates the converter for a given vault
     * @param _vault The address of the vault
     * @param _converter The address of the converter
     */
    function setConverter(
        address _vault,
        address _converter
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedConverters(_converter), ""!allowedConverters"");
        _vaultDetails[_vault].converter = _converter;
    }

    /**
     * @notice Sets/updates the global invest enabled flag
     * @param _investEnabled The new bool of the invest enabled flag
     */
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        notHalted
        onlyStrategist
    {
        globalInvestEnabled = _investEnabled;
    }

    /**
     * @notice Sets/updates the maximum number of strategies for a vault
     * @param _maxStrategies The new value of the maximum strategies
     */
    function setMaxStrategies(
        uint256 _maxStrategies
    )
        external
        notHalted
        onlyStrategist
    {
        maxStrategies = _maxStrategies;
    }

    function skim(
        address _strategy
    )
        external
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).skim();
        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));
    }

    /**
     * @notice Withdraws all funds from a strategy
     * @param _strategy The address of the strategy
     * @param _convert The token address to convert to
     */
    function withdrawAll(
        address _strategy,
        address _convert
    )
        external
        override
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).withdrawAll();
        uint256 _amount = IERC20(_want).balanceOf(address(this));
        address _vault = _vaultStrategies[_strategy];
        updateBalance(_vault, _strategy);
        if (_convert != address(0)) {
            IConverter _converter = IConverter(_vaultDetails[_vault].converter);
            IERC20(_want).safeTransfer(address(_converter), _amount);
            _amount = _converter.convert(_want, _convert, _amount, 1);
            IERC20(_convert).safeTransfer(_vault, _amount);
        } else {
            IERC20(_want).safeTransfer(_vault, _amount);
        }
        uint256 _balance = _vaultDetails[_vault].balance;
        if (_balance >= _amount) {
            _vaultDetails[_vault].balance = _balance.sub(_amount);
        } else {
            _vaultDetails[_vault].balance = 0;
        }
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Harvests the specified strategy
     * @param _strategy The address of the strategy
     */
    function harvestStrategy(
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        notHalted
        onlyHarvester
        onlyStrategy(_strategy)
    {
        uint256 _before = IStrategy(_strategy).balanceOf();
        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);
        uint256 _after = IStrategy(_strategy).balanceOf();
        address _vault = _vaultStrategies[_strategy];
        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));
        _vaultDetails[_vault].balances[_strategy] = _after;
        emit Harvest(_strategy);
    }

    /**
     * VAULT-ONLY FUNCTIONS
     */

    /**
     * @notice Invests funds into a strategy
     * @param _strategy The address of the strategy
     * @param _token The address of the token
     * @param _amount The amount that will be invested
     */
    function earn(
        address _strategy,
        address _token,
        uint256 _amount
    )
        external
        override
        notHalted
        onlyStrategy(_strategy)
        onlyVault(_token)
    {
        // get the want token of the strategy
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);
            IERC20(_token).safeTransfer(address(_converter), _amount);
            // TODO: do estimation for received
            _amount = _converter.convert(_token, _want, _amount, 1);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);
        // call the strategy deposit function
        IStrategy(_strategy).deposit();
        updateBalance(msg.sender, _strategy);
    }

    /**
     * @notice Withdraws funds from a strategy
     * @dev If the withdraw amount is greater than the first strategy given
     * by getBestStrategyWithdraw, this function will loop over strategies
     * until the requested amount is met.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function withdraw(
        address _token,
        uint256 _amount
    )
        external
        override
        onlyVault(_token)
    {
        (
            address[] memory _strategies,
            uint256[] memory _amounts
        ) = getBestStrategyWithdraw(_token, _amount);
        for (uint i = 0; i < _strategies.length; i++) {
            // getBestStrategyWithdraw will return arrays larger than needed
            // if this happens, simply exit the loop
            if (_strategies[i] == address(0)) {
                break;
            }
            IStrategy(_strategies[i]).withdraw(_amounts[i]);
            updateBalance(msg.sender, _strategies[i]);
            address _want = IStrategy(_strategies[i]).want();
            if (_want != _token) {
                address _converter = _vaultDetails[msg.sender].converter;
                IERC20(_want).safeTransfer(_converter, _amounts[i]);
                // TODO: do estimation for received
                IConverter(_converter).convert(_want, _token, _amounts[i], 1);
            }
        }
        _amount = IERC20(_token).balanceOf(address(this));
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns the rough balance of the sum of all strategies for a given vault
     * @dev This function is optimized to prevent looping over all strategy balances,
     * and instead the controller tracks the earn, withdraw, and harvest amounts.
     */
    function balanceOf()
        external
        view
        override
        returns (uint256 _balance)
    {
        return _vaultDetails[msg.sender].balance;
    }

    /**
     * @notice Returns the converter assigned for the given vault
     * @param _vault Address of the vault
     */
    function converter(
        address _vault
    )
        external
        view
        override
        returns (address)
    {
        return _vaultDetails[_vault].converter;
    }

    /**
     * @notice Returns the cap of a strategy for a given vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function getCap(
        address _vault,
        address _strategy
    )
        external
        view
        returns (uint256)
    {
        return _vaultDetails[_vault].caps[_strategy];
    }

    /**
     * @notice Returns whether investing is enabled for the calling vault
     * @dev Should be called by the vault
     */
    function investEnabled()
        external
        view
        override
        returns (bool)
    {
        if (globalInvestEnabled) {
            return _vaultDetails[msg.sender].strategies.length > 0;
        }
        return false;
    }

    /**
     * @notice Returns all the strategies for a given vault
     * @param _vault The address of the vault
     */
    function strategies(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return _vaultDetails[_vault].strategies;
    }

    /**
     * @notice Returns the length of the strategies of the calling vault
     * @dev This function is expected to be called by a vault
     */
    function strategies()
        external
        view
        override
        returns (uint256)
    {
        return _vaultDetails[msg.sender].strategies.length;
    }

    /**
     * INTERNAL FUNCTIONS
     */

    /**
     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from
     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays
     * from this function will always be the same length as the amount of strategies for
     * a token. Check that _strategies[i] != address(0) when consuming to know when to
     * break out of the loop.
     * @param _token The address of the token
     * @param _amount The amount that will be withdrawn
     */
    function getBestStrategyWithdraw(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (
            address[] memory _strategies,
            uint256[] memory _amounts
        )
    {
        // get the length of strategies for a single token
        address _vault = manager.vaults(_token);
        uint256 k = _vaultDetails[_vault].strategies.length;
        // initialize fixed-length memory arrays
        _strategies = new address[](k);
        _amounts = new uint256[](k);
        address _strategy;
        uint256 _balance;
        // scan forward from the the beginning of strategies
        for (uint i = 0; i < k; i++) {
            _strategy = _vaultDetails[_vault].strategies[i];
            _strategies[i] = _strategy;
            // get the balance of the strategy
            _balance = _vaultDetails[_vault].balances[_strategy];
            // if the strategy doesn't have the balance to cover the withdraw
            if (_balance < _amount) {
                // withdraw what we can and add to the _amounts
                _amounts[i] = _balance;
                _amount = _amount.sub(_balance);
            } else {
                // stop scanning if the balance is more than the withdraw amount
                _amounts[i] = _amount;
                break;
            }
        }
    }

    /**
     * @notice Updates the stored balance of a given strategy for a vault
     * @param _vault The address of the vault
     * @param _strategy The address of the strategy
     */
    function updateBalance(
        address _vault,
        address _strategy
    )
        internal
    {
        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();
    }

    /**
     * MODIFIERS
     */

    /**
     * @notice Reverts if the protocol is halted
     */
    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    /**
     * @notice Reverts if the caller is not governance
     */
    modifier onlyGovernance() {
        require(msg.sender == manager.governance(), ""!governance"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the strategist
     */
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    /**
     * @notice Reverts if the strategy is not allowed in the manager
     */
    modifier onlyStrategy(address _strategy) {
        require(manager.allowedStrategies(_strategy), ""!allowedStrategy"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the harvester
     */
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    /**
     * @notice Reverts if the caller is not the vault for the given token
     */
    modifier onlyVault(address _token) {
        require(msg.sender == manager.vaults(_token), ""!vault"");
        _;
    }
}",4847.0,684.0,"[H-01] Controller.setCap sets wrong vault balance
The `Controller.setCap` function sets a cap for a strategy and withdraws any excess amounts (_diff). The vault balance is decreased by the entire strategy balance instead of by this _diff: ```
// @audit why not sub _diff?
_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);
``` The `_vaultDetails[_vault].balance` variable does not correctly track the actual vault balances anymore, it will usually underestimate the vault balance. This variable is used in `Controller.balanceOf()`, which in turn is used in `Vault.balance()`, which in turn is used to determine how many shares to mint / amount to receive when redeeming shares. If the value is less, users will lose money as they can redeem fewer tokens. Also, an attacker can deposit and will receive more shares than they should receive. They can then wait until the balance is correctly updated again and withdraw their shares for a higher amount than they deposited. This leads to the vault losing tokens.   [H-02] set cap breaks vault's Balance
In controller.sol's function setCap, the contract wrongly handles _vaultDetails[_vault].balance. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. See Controller.sol L262-L278. `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);`
This would result in vaultDetails[_vault].balance being far smaller than the strategy's value. A user would trigger the assertion at Controller.sol#475 and the fund would be locked in the strategy.
Though setCap is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.
  [H-04] Controller does not raise an error when there's insufficient liquidity
When a user tries to withdraw the token from the vault, the vault would withdraw the token from the controller if there's insufficient liquidity in the vault. However, the controller does not raise an error when there's insufficient liquidity in the controller/ strategies. The user would lose his shares while getting nothing.
An MEV searcher could apply this attack on any withdrawal. When an attacker found an unconfirmed tx that tries to withdraw 1M dai, he can do such sandwich attack.
- Deposits USDC into the vault.
- Withdraw all dai left in the vault/controller/strategy.
- Place the vitims tx here. The victim would get zero dai while burning 1 M share. This would pump the share price.
- Withdraw all liquidity.
All users would be vulnerable to MEV attackers. I consider this is a high-risk issue.   [H-09] `removeToken` would break the vault/protocol.
There's no safety check in Manager.sol's `removeToken`. Manager.sol#L454-L487`
(1) The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost.
(2) Controller’s `balanceOf` would no longer reflects the real value. Controller.sol#L488-L495 While `_vaultDetails[msg.sender].balance;` remains the same, user can nolonger withdraw those amount.
(3) Share price in the vault would decrease drastically. The share price is calculated as `totalValue / totalSupply` Vault.sol#L217. While the totalSupply of the share remains the same, the total balance has drastically decreased.
Calling removeToken way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.
 
[M-08] Controller.inCaseStrategyGetStuck does not update balance
The `Controller.inCaseStrategyGetStuck` withdraws from a strategy but does not call `updateBalance(_vault, _strategy)` afterwards.
The `_vaultDetails[_vault].balances[_strategy`] variable does not correctly track the actual strategy balance anymore. I'm not sure what exactly this field is used for besides getting the withdraw amounts per strategy in getBestStrategyWithdraw. As the strategy contains a lower amount than stored in the field, Controller.withdraw will attempt to withdraw too much.",5.0,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IConverter.sol"";
import ""../interfaces/IVault.sol"";
import ""../interfaces/IHarvester.sol"";
import ""../interfaces/IStrategy.sol"";
import ""../interfaces/IManager.sol"";


contract Controller is IController {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    IManager public immutable override manager;

    bool public globalInvestEnabled;
    uint256 public maxStrategies;

    struct VaultDetail {
        address converter;
        uint256 balance;
        address[] strategies;
        mapping(address => uint256) balances;
        mapping(address => uint256) index;
        mapping(address => uint256) caps;
    }

    
    mapping(address => VaultDetail) internal _vaultDetails;
    
    mapping(address => address) internal _vaultStrategies;

    
    event Harvest(address indexed strategy);

    
    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);

    
    event StrategyRemoved(address indexed vault, address indexed strategy);

    
    event StrategiesReordered(
        address indexed vault,
        address indexed strategy1,
        address indexed strategy2
    );

    
    constructor(
        address _manager
    )
        public
    {
        manager = IManager(_manager);
        globalInvestEnabled = true;
        maxStrategies = 10;
    }

    

    
    function addStrategy(
        address _vault,
        address _strategy,
        uint256 _cap,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultDetails[_vault].converter != address(0), ""!converter"");
        
        require(_vaultStrategies[_strategy] == address(0), ""Strategy is already added""); 
        
        uint256 index = _vaultDetails[_vault].strategies.length;
        
        require(index < maxStrategies, ""!maxStrategies"");
        
        _vaultDetails[_vault].strategies.push(_strategy);
        
        _vaultDetails[_vault].caps[_strategy] = _cap;
        
        _vaultDetails[_vault].index[_strategy] = index;
        
        _vaultStrategies[_strategy] = _vault;
        if (_timeout > 0) {
            
            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);
        }
        emit StrategyAdded(_vault, _strategy, _cap);
    }

    
    function inCaseStrategyGetStuck(
        address _strategy,
        address _token
    )
        external
        onlyStrategist
    {
        IStrategy(_strategy).withdraw(_token);
        IERC20(_token).safeTransfer(
            manager.treasury(),
            IERC20(_token).balanceOf(address(this))
        );
    }

    
    function inCaseTokensGetStuck(
        address _token,
        uint256 _amount
    )
        external
        onlyStrategist
    {
        IERC20(_token).safeTransfer(manager.treasury(), _amount);
    }

    
    function removeStrategy(
        address _vault,
        address _strategy,
        uint256 _timeout
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        
        uint256 index = vaultDetail.index[_strategy];
        
        uint256 tail = vaultDetail.strategies.length.sub(1);
        
        address replace = vaultDetail.strategies[tail];
        
        vaultDetail.strategies[index] = replace;
        
        vaultDetail.index[replace] = index;
        
        vaultDetail.strategies.pop();
        
        delete vaultDetail.index[_strategy];
        
        delete vaultDetail.caps[_strategy];
        
        delete vaultDetail.balances[_strategy];
        
        delete _vaultStrategies[_strategy];
        
        IStrategy(_strategy).withdrawAll();
        
        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);
        emit StrategyRemoved(_vault, _strategy);
    }

    
    function reorderStrategies(
        address _vault,
        address _strategy1,
        address _strategy2
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedVaults(_vault), ""!_vault"");
        require(_vaultStrategies[_strategy1] == _vault, ""!_strategy1"");
        require(_vaultStrategies[_strategy2] == _vault, ""!_strategy2"");
        VaultDetail storage vaultDetail = _vaultDetails[_vault];
        
        uint256 index1 = vaultDetail.index[_strategy1];
        uint256 index2 = vaultDetail.index[_strategy2];
        
        vaultDetail.strategies[index1] = _strategy2;
        vaultDetail.strategies[index2] = _strategy1;
        
        vaultDetail.index[_strategy1] = index2;
        vaultDetail.index[_strategy2] = index1;
        emit StrategiesReordered(_vault, _strategy1, _strategy2);
    }

    
    function setCap(
        address _vault,
        address _strategy,
        uint256 _cap,
        address _convert
    )
        external
        notHalted
        onlyStrategist
        onlyStrategy(_strategy)
    {
        _vaultDetails[_vault].caps[_strategy] = _cap;
        uint256 _balance = IStrategy(_strategy).balanceOf();
        
        if (_balance > _cap && _cap != 0) {
            uint256 _diff = _balance.sub(_cap);
            IStrategy(_strategy).withdraw(_diff);
            updateBalance(_vault, _strategy);
            _balance = IStrategy(_strategy).balanceOf();
            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);
            address _want = IStrategy(_strategy).want();
            _balance = IERC20(_want).balanceOf(address(this));
            if (_convert != address(0)) {
                IConverter _converter = IConverter(_vaultDetails[_vault].converter);
                IERC20(_want).safeTransfer(address(_converter), _balance);
                _balance = _converter.convert(_want, _convert, _balance, 1);
                IERC20(_convert).safeTransfer(_vault, _balance);
            } else {
                IERC20(_want).safeTransfer(_vault, _balance);
            }
        }
    }

    
    function setConverter(
        address _vault,
        address _converter
    )
        external
        notHalted
        onlyStrategist
    {
        require(manager.allowedConverters(_converter), ""!allowedConverters"");
        _vaultDetails[_vault].converter = _converter;
    }

    
    function setInvestEnabled(
        bool _investEnabled
    )
        external
        notHalted
        onlyStrategist
    {
        globalInvestEnabled = _investEnabled;
    }

    
    function setMaxStrategies(
        uint256 _maxStrategies
    )
        external
        notHalted
        onlyStrategist
    {
        maxStrategies = _maxStrategies;
    }

    function skim(
        address _strategy
    )
        external
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).skim();
        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));
    }

    
    function withdrawAll(
        address _strategy,
        address _convert
    )
        external
        override
        onlyStrategist
        onlyStrategy(_strategy)
    {
        address _want = IStrategy(_strategy).want();
        IStrategy(_strategy).withdrawAll();
        uint256 _amount = IERC20(_want).balanceOf(address(this));
        address _vault = _vaultStrategies[_strategy];
        updateBalance(_vault, _strategy);
        if (_convert != address(0)) {
            IConverter _converter = IConverter(_vaultDetails[_vault].converter);
            IERC20(_want).safeTransfer(address(_converter), _amount);
            _amount = _converter.convert(_want, _convert, _amount, 1);
            IERC20(_convert).safeTransfer(_vault, _amount);
        } else {
            IERC20(_want).safeTransfer(_vault, _amount);
        }
        uint256 _balance = _vaultDetails[_vault].balance;
        if (_balance >= _amount) {
            _vaultDetails[_vault].balance = _balance.sub(_amount);
        } else {
            _vaultDetails[_vault].balance = 0;
        }
    }

    

    
    function harvestStrategy(
        address _strategy,
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        external
        override
        notHalted
        onlyHarvester
        onlyStrategy(_strategy)
    {
        uint256 _before = IStrategy(_strategy).balanceOf();
        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);
        uint256 _after = IStrategy(_strategy).balanceOf();
        address _vault = _vaultStrategies[_strategy];
        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));
        _vaultDetails[_vault].balances[_strategy] = _after;
        emit Harvest(_strategy);
    }

    

    
    function earn(
        address _strategy,
        address _token,
        uint256 _amount
    )
        external
        override
        notHalted
        onlyStrategy(_strategy)
        onlyVault(_token)
    {
        
        address _want = IStrategy(_strategy).want();
        if (_want != _token) {
            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);
            IERC20(_token).safeTransfer(address(_converter), _amount);
            
            _amount = _converter.convert(_token, _want, _amount, 1);
            IERC20(_want).safeTransfer(_strategy, _amount);
        } else {
            IERC20(_token).safeTransfer(_strategy, _amount);
        }
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);
        
        IStrategy(_strategy).deposit();
        updateBalance(msg.sender, _strategy);
    }

    
    function withdraw(
        address _token,
        uint256 _amount
    )
        external
        override
        onlyVault(_token)
    {
        (
            address[] memory _strategies,
            uint256[] memory _amounts
        ) = getBestStrategyWithdraw(_token, _amount);
        for (uint i = 0; i < _strategies.length; i++) {
            
            
            if (_strategies[i] == address(0)) {
                break;
            }
            IStrategy(_strategies[i]).withdraw(_amounts[i]);
            updateBalance(msg.sender, _strategies[i]);
            address _want = IStrategy(_strategies[i]).want();
            if (_want != _token) {
                address _converter = _vaultDetails[msg.sender].converter;
                IERC20(_want).safeTransfer(_converter, _amounts[i]);
                
                IConverter(_converter).convert(_want, _token, _amounts[i], 1);
            }
        }
        _amount = IERC20(_token).balanceOf(address(this));
        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }

    

    
    function balanceOf()
        external
        view
        override
        returns (uint256 _balance)
    {
        return _vaultDetails[msg.sender].balance;
    }

    
    function converter(
        address _vault
    )
        external
        view
        override
        returns (address)
    {
        return _vaultDetails[_vault].converter;
    }

    
    function getCap(
        address _vault,
        address _strategy
    )
        external
        view
        returns (uint256)
    {
        return _vaultDetails[_vault].caps[_strategy];
    }

    
    function investEnabled()
        external
        view
        override
        returns (bool)
    {
        if (globalInvestEnabled) {
            return _vaultDetails[msg.sender].strategies.length > 0;
        }
        return false;
    }

    
    function strategies(
        address _vault
    )
        external
        view
        returns (address[] memory)
    {
        return _vaultDetails[_vault].strategies;
    }

    
    function strategies()
        external
        view
        override
        returns (uint256)
    {
        return _vaultDetails[msg.sender].strategies.length;
    }

    

    
    function getBestStrategyWithdraw(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (
            address[] memory _strategies,
            uint256[] memory _amounts
        )
    {
        
        address _vault = manager.vaults(_token);
        uint256 k = _vaultDetails[_vault].strategies.length;
        
        _strategies = new address[](k);
        _amounts = new uint256[](k);
        address _strategy;
        uint256 _balance;
        
        for (uint i = 0; i < k; i++) {
            _strategy = _vaultDetails[_vault].strategies[i];
            _strategies[i] = _strategy;
            
            _balance = _vaultDetails[_vault].balances[_strategy];
            
            if (_balance < _amount) {
                
                _amounts[i] = _balance;
                _amount = _amount.sub(_balance);
            } else {
                
                _amounts[i] = _amount;
                break;
            }
        }
    }

    
    function updateBalance(
        address _vault,
        address _strategy
    )
        internal
    {
        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();
    }

    

    
    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    
    modifier onlyGovernance() {
        require(msg.sender == manager.governance(), ""!governance"");
        _;
    }

    
    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }

    
    modifier onlyStrategy(address _strategy) {
        require(manager.allowedStrategies(_strategy), ""!allowedStrategy"");
        _;
    }

    
    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    
    modifier onlyVault(address _token) {
        require(msg.sender == manager.vaults(_token), ""!vault"");
        _;
    }
}",3187.0,4,1,"{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `withdraw` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdraw` function transfers tokens before updating the internal balance state, making it vulnerable to reentrancy attacks. This could allow a malicious contract to withdraw more funds than intended."",
      ""Impact"": ""An attacker could drain the contract's funds by exploiting this reentrancy vulnerability."",
      ""Location"": ""Function `withdraw` defined in various lines (e.g., lines 243-283, 288-309)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding accurately identifies a reentrancy issue, which is critical for contract security.""
    },
    {
      ""Issue"": ""Lack of Access Control on Sensitive Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `setCap`, `setConverter`, `setInvestEnabled`, and `addStrategy` can be accessed without adequate access control, risking unauthorized modifications to critical parameters."",
      ""Impact"": ""Malicious actors could manipulate strategies or caps, potentially leading to financial loss or system instability."",
      ""Location"": ""Functions `setCap`, `setConverter`, `setInvestEnabled`, and `addStrategy` defined in various lines."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding highlights the need for robust access control to prevent unauthorized actions.""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions, including `setCap`, `setMaxStrategies`, and `addStrategy`, do not validate input parameters, which could lead to unexpected behaviors if incorrect data is provided."",
      ""Impact"": ""Invalid inputs can lead to incorrect contract state, affecting the performance and security of the contract."",
      ""Location"": ""Functions `setCap`, `setMaxStrategies`, and `addStrategy` defined in various lines."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring input validation is crucial for maintaining expected contract behavior.""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions that perform significant state changes, such as `setCap`, `setConverter`, and `setInvestEnabled`, do not emit events after these changes."",
      ""Impact"": ""Lack of event emissions can hinder monitoring and auditing of contract interactions, potentially obscuring malicious activity."",
      ""Location"": ""Functions `setCap`, `setConverter`, and `setInvestEnabled` defined in various lines."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Event emissions are essential for transparency and auditing in smart contracts.""
    },
    {
      ""Issue"": ""Unchecked External Call in `earn` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `earn` function calls external strategies without checking the success of the operation, leading to potential inconsistencies."",
      ""Impact"": ""Failure in the external call could result in incorrect distribution of funds, impacting contract integrity."",
      ""Location"": ""Function `earn` defined in various lines."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Verifying the success of external calls is crucial for maintaining contract integrity.""
    },
    {
      ""Issue"": ""Use of Deprecated Solidity Pragma"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses an outdated version of Solidity, which may lack support for newer features and optimizations, along with important security fixes."",
      ""Impact"": ""Using deprecated versions can lead to missing performance improvements, language features, and potential security patches."",
      ""Location"": ""Line 1: pragma solidity 0.6.12;"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as using outdated Solidity versions invites potential security risks.""
    },
    {
      ""Issue"": ""Potential Arithmetic Overflow/Underflow"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract may be at risk of arithmetic overflow/underflow in certain operations despite using SafeMath."",
      ""Impact"": ""This could lead to incorrect balance updates and possible vulnerabilities."",
      ""Location"": ""Various functions involving arithmetic operations."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring arithmetic operations are safe is crucial to prevent overflow/underflow errors.""
    },
    {
      ""Issue"": ""Global State Dependency"",
      ""Severity"": ""Low"",
      ""Description"": ""The `globalInvestEnabled` variable affects all vaults and strategies, creating a risk if it is not managed carefully."",
      ""Impact"": ""Improper management could halt investment capabilities across all vaults, affecting performance."",
      ""Location"": ""Variable `globalInvestEnabled` at line 10."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding raises concerns about the management of global state variables.""
    }
  ],
  ""FindingNumber"": 7,
  ""AllRelevance"": 43,
  ""RelevanceCount"": 36,
  ""AllValidation"": 43,
  ""ValidationCount"": 36
}","### **Comparison of Issue Report and Response List**

---

#### **[H-01] Controller.setCap sets wrong vault balance**

**Report Description**:  
The `Controller.setCap` function sets a cap for a strategy and withdraws any excess amounts (`_diff`). However, the vault balance is decreased by the entire strategy balance instead of by `_diff`. This leads to an underestimation of the vault balance, which is used in `Controller.balanceOf()`, `Vault.balance()`, and share minting/redemption calculations. This discrepancy allows attackers to deposit and receive more shares than they should, leading to potential token loss for the vault.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem of incorrect vault balance updates in `setCap` is not covered, and the potential financial impact on users and the vault is entirely missed.

---

#### **[H-02] setCap breaks vault's Balance**

**Report Description**:  
The `setCap` function in `Controller.sol` incorrectly decreases `_vaultDetails[_vault].balance` by the entire strategy balance instead of the difference (`_diff`). This results in `vaultDetails[_vault].balance` being significantly smaller than the actual strategy value, potentially locking funds in the strategy and triggering an assertion failure.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The critical flaw in `setCap` and its potential to lock funds is entirely missed.

---

#### **[H-04] Controller does not raise an error when there's insufficient liquidity**

**Report Description**:  
When a user withdraws tokens from the vault, the controller does not raise an error if there is insufficient liquidity in the controller/strategies. This allows MEV searchers to exploit the system by sandwiching withdrawals, causing users to lose shares without receiving tokens. This is a high-risk issue affecting all users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The lack of error handling for insufficient liquidity and its exploitation by MEV searchers is entirely missed.

---

#### **[H-09] `removeToken` would break the vault/protocol**

**Report Description**:  
The `removeToken` function in `Manager.sol` lacks safety checks, leading to three critical issues:  
1. Tokens locked in the original vault.  
2. `Controller.balanceOf` no longer reflects the real value.  
3. Share price in the vault decreases drastically.  
This could break the entire protocol if the vault has already started.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The catastrophic impact of `removeToken` on the protocol is entirely missed.

---

#### **[M-08] Controller.inCaseStrategyGetStuck does not update balance**

**Report Description**:  
The `inCaseStrategyGetStuck` function withdraws from a strategy but does not call `updateBalance(_vault, _strategy)` afterward. This results in `_vaultDetails[_vault].balances[_strategy]` incorrectly tracking the strategy balance, potentially causing `Controller.withdraw` to attempt to withdraw too much.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The failure to update balances after withdrawing from a strategy is entirely missed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Controller.setCap sets wrong vault balance**  
- **[H-02] setCap breaks vault's Balance**  
- **[H-04] Controller does not raise an error when there's insufficient liquidity**  
- **[H-09] `removeToken` would break the vault/protocol**  
- **[M-08] Controller.inCaseStrategyGetStuck does not update balance**

---

### **Conclusion**  
The `response_list` does not adequately address the issues raised in the `issue` report. Critical vulnerabilities related to incorrect balance updates, insufficient liquidity handling, and protocol-breaking functions are entirely missed. The response list focuses on general issues like reentrancy, access control, and input validation but fails to cover the specific, high-severity problems identified in the `issue` report. This highlights significant gaps in the coverage, accuracy, and sufficiency of the responses.",0.0,0,5,7.0,43.0,"```
None.
```","Given that there are no true positives in the provided list, the **Average Precision (AP)** for the query is:

**0.0**"
Vault.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./VaultToken.sol"";

import ""./interfaces/IManager.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/ExtendedIERC20.sol"";

/**
 * @title Vault
 * @notice The vault is where users deposit and withdraw
 * like-kind assets that have been added by governance.
 */
contract Vault is VaultToken, IVault {
    using Address for address;
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MAX = 10000;

    IManager public immutable override manager;

    // Strategist-updated variables
    address public override gauge;
    uint256 public min;
    uint256 public totalDepositCap;

    event Deposit(address indexed account, uint256 amount);
    event Withdraw(address indexed account, uint256 amount);
    event Earn(address indexed token, uint256 amount);

    /**
     * @param _name The name of the vault token for depositors
     * @param _symbol The symbol of the vault token for depositors
     * @param _manager The address of the vault manager contract
     */
    constructor(
        string memory _name,
        string memory _symbol,
        address _manager
    )
        public
        VaultToken(_name, _symbol)
    {
        manager = IManager(_manager);
        min = 9500;
        totalDepositCap = 10000000 ether;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the value of this vault's gauge
     * @dev Allow to be unset with the zero address
     * @param _gauge The address of the gauge
     */
    function setGauge(
        address _gauge
    )
        external
        notHalted
        onlyStrategist
    {
        gauge = _gauge;
    }

    /**
     * @notice Sets the value for min
     * @dev min is the minimum percent of funds to keep small withdrawals cheap
     * @param _min The new min value
     */
    function setMin(
        uint256 _min
    )
        external
        notHalted
        onlyStrategist
    {
        require(_min <= MAX, ""!_min"");
        min = _min;
    }

    /**
     * @notice Sets the value for the totalDepositCap
     * @dev totalDepositCap is the maximum amount of value that can be deposited
     * to the metavault at a time
     * @param _totalDepositCap The new totalDepositCap value
     */
    function setTotalDepositCap(
        uint256 _totalDepositCap
    )
        external
        notHalted
        onlyStrategist
    {
        totalDepositCap = _totalDepositCap;
    }

    /**
     * @notice Swaps tokens held within the vault
     * @param _token0 The token address to swap out
     * @param _token1 The token address to to
     * @param _expectedAmount The expected amount of _token1 to receive
     */
    function swap(
        address _token0,
        address _token1,
        uint256 _expectedAmount
    )
        external
        override
        notHalted
        onlyStrategist
        returns (uint256 _balance)
    {
        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));
        _balance = IERC20(_token0).balanceOf(address(this));
        IERC20(_token0).safeTransfer(address(_converter), _balance);
        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);
    }

    /**
     * HARVESTER-ONLY FUNCTIONS
     */

    /**
     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies
     */
    function earn(
        address _token,
        address _strategy
    )
        external
        override
        checkToken(_token)
        notHalted
        onlyHarvester
    {
        require(manager.allowedStrategies(_strategy), ""!_strategy"");
        IController _controller = IController(manager.controllers(address(this)));
        if (_controller.investEnabled()) {
            uint256 _balance = available(_token);
            IERC20(_token).safeTransfer(address(_controller), _balance);
            _controller.earn(_strategy, _token, _balance);
            emit Earn(_token, _balance);
        }
    }

    /**
     * USER-FACING FUNCTIONS
     */

    /**
     * @notice Deposits the given token into the vault
     * @param _token The address of the token
     * @param _amount The amount of tokens to deposit
     */
     function deposit(
        address _token,
        uint256 _amount
     )
        public
        override
        checkToken(_token)
        notHalted
        returns (uint256 _shares)
    {
        require(_amount > 0, ""!_amount"");

        uint256 _balance = balance();

        uint256 _before = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);

        if (_amount > 0) {
            _amount = _normalizeDecimals(_token, _amount);

            if (totalSupply() > 0) {
                _amount = (_amount.mul(totalSupply())).div(_balance);
            }

            _shares = _amount;
        }

        if (_shares > 0) {
            _mint(msg.sender, _shares);
            require(totalSupply() <= totalDepositCap, "">totalDepositCap"");
            emit Deposit(msg.sender, _shares);
        }
    }

    /**
     * @notice Deposits multiple tokens simultaneously to the vault
     * @dev Users must approve the vault to spend their stablecoin
     * @param _tokens The addresses of each token being deposited
     * @param _amounts The amounts of each token being deposited
     */
    function depositMultiple(
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
        override
        returns (uint256 _shares)
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i; i < _amounts.length; i++) {
            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));
        }
    }

    /**
     * @notice Withdraws an amount of shares to a given output token
     * @param _shares The amount of shares to withdraw
     * @param _output The address of the token to receive
     */
    function withdraw(
        uint256 _shares,
        address _output
    )
        public
        override
        checkToken(_output)
    {
        uint256 _amount = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();
        if (_withdrawalProtectionFee > 0) {
            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);
            _amount = _amount.sub(_withdrawalProtection);
        }

        uint256 _balance = IERC20(_output).balanceOf(address(this));
        if (_balance < _amount) {
            IController _controller = IController(manager.controllers(address(this)));
            uint256 _toWithdraw = _amount.sub(_balance);
            if (_controller.strategies() > 0) {
                _controller.withdraw(_output, _toWithdraw);
            }
            uint256 _after = IERC20(_output).balanceOf(address(this));
            uint256 _diff = _after.sub(_balance);
            if (_diff < _toWithdraw) {
                _amount = _after;
            }
        }

        IERC20(_output).safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /**
     * @notice Withdraw the entire balance for an account
     * @param _output The address of the desired token to receive
     */
    function withdrawAll(
        address _output
    )
        external
        override
    {
        withdraw(balanceOf(msg.sender), _output);
    }

    /**
     * VIEWS
     */

    /**
     * @notice Returns the amount of tokens available to be sent to strategies
     * @dev Custom logic in here for how much the vault allows to be borrowed
     * @dev Sets minimum required on-hand to keep small withdrawals cheap
     * @param _token The address of the token
     */
    function available(
        address _token
    )
        public
        view
        override
        returns (uint256)
    {
        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);
    }

    /**
     * @notice Returns the total balance of the vault, including strategies
     */
    function balance()
        public
        view
        override
        returns (uint256 _balance)
    {
        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());
    }

    /**
     * @notice Returns the balance of allowed tokens present on the vault only
     */
    function balanceOfThis()
        public
        view
        returns (uint256 _balance)
    {
        address[] memory _tokens = manager.getTokens(address(this));
        for (uint8 i; i < _tokens.length; i++) {
            address _token = _tokens[i];
            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
        }
    }

    /**
     * @notice Returns the rate of vault shares
     */
    function getPricePerFullShare()
        external
        view
        override
        returns (uint256)
    {
        if (totalSupply() > 0) {
            return balance().mul(1e18).div(totalSupply());
        } else {
            return balance();
        }
    }

    /**
     * @notice Returns an array of the tokens for this vault
     */
    function getTokens()
        external
        view
        override
        returns (address[] memory)
    {
        return manager.getTokens(address(this));
    }

    /**
     * @notice Returns the fee for withdrawing the given amount
     * @param _amount The amount to withdraw
     */
    function withdrawFee(
        uint256 _amount
    )
        external
        view
        override
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    function _normalizeDecimals(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (uint256)
    {
        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());
        if (_decimals < 18) {
            _amount = _amount.mul(10**(18-_decimals));
        }
        return _amount;
    }

    /**
     * MODIFIERS
     */

    modifier checkToken(address _token) {
        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), ""!_token"");
        _;
    }

    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",2561.0,408.0,"[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.
The v3 vault treats all valid tokens exactly the same. Depositing 1M DAI would get the same share as depositing 1M USDT. User can withdraw their share in another token. Though there's withdrawalProtectionFee (0.1 percent), the vault is still a no slippage stable coin exchange.
Also, I notice that 3crv_token is added to the vault in the test. Treating 3crv_token and all other stable coins the same would make the vault vulnerable to flashloan attack. 3crv_token is an lp token and at the point of writing, the price of it is 1.01. The arbitrage space is about 0.8 percent and makes the vault vulnerable to flashloan attacks.
Though the team may not add crv_token and dai to the same vault, its design makes the vault vulnerable. Strategies need to be designed with super caution or the vault would be vulnerable to attackers.
Given the possibility of a flashloan attack, I consider this a high-risk issue.
  [H-06] earn results in decreasing share price
For a dai vault that pairs with `NativeStrategyCurve3Crv`, every time `earn()` is called, shareholders would lose money. (about 2%)
There are two issues involved. The Vault contract and the `controller` contract doesn't handle the price difference between the want token and other tokens.
At Vault.sol L293, when a vault calculates its value, it sums up all tokens balance. However, when the controller calculates vaults' value (at Controller.sol L410-L436), it only adds the amount of strategy.want it received. (in this case, it's t3crv).
Under the current design, users who deposit dai to the vault would not get yield. Instead, they would keep losing money.
  [H-07] Vault.balance() mixes normalized and standard amounts
Loops
The `Vault.balance` function uses the balanceOfThis function which scales (""normalizes"") all balances to 18 decimals.
“for (uint8 i; i < _tokens.length; i++) {
    address _token = _tokens[i];
    // everything is padded to 18 decimals
    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
}”
Note that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized. The code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).
  [H-08] Vault.withdraw mixes normalized and standard amounts The `Vault.balance` function uses the balanceOfThis function which scales (""normalizes"") all balances to 18 decimals.
for (uint8 i; i < _tokens.length; i++) {
    address _token = _tokens[i];
    // everything is padded to 18 decimals
    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
}
Note that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized, but it must be.
This leads to many issues through the contracts that use balance but don't treat these values as normalized values. For example, in Vault.withdraw, the computed _amount value is normalized (in 18 decimals). But the uint256 _balance = IERC20(_output).balanceOf(address(this)); value is not normalized but compared to the normalized _amount and even subtracted:
// @audit compares unnormalzied output to normalized output
if (_balance < _amount) {
    IController _controller = IController(manager.controllers(address(this)));
    // @audit cannot directly subtract unnormalized
    uint256 _toWithdraw = _amount.sub(_balance);
    if (_controller.strategies() > 0) {
        _controller.withdraw(_output, _toWithdraw);
    }
    uint256 _after = IERC20(_output).balanceOf(address(this));
    uint256 _diff = _after.sub(_balance);
    if (_diff < _toWithdraw) {
        _amount = _balance.add(_diff);
    }
}
  [M-03] `Vault.withdraw` sometimes burns too many shares
The `Vault.withdraw` function attempts to withdraw funds from the controller if there are not enough in the vault already. In the case the controller could not withdraw enough, i.e., where _diff < _toWithdraw, the user will receive less output tokens than their fair share would entitle them to (the initial _amount).
if (_diff < _toWithdraw) {
    // @audit burns too many shares for a below fair-share amount
    _amount = _balance.add(_diff);
}
The withdrawer receives fewer output tokens than they were entitled to.",5.0,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/GSN/Context.sol"";

import ""./VaultToken.sol"";

import ""./interfaces/IManager.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IVault.sol"";
import ""./interfaces/ExtendedIERC20.sol"";


contract Vault is VaultToken, IVault {
    using Address for address;
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant MAX = 10000;

    IManager public immutable override manager;

    
    address public override gauge;
    uint256 public min;
    uint256 public totalDepositCap;

    event Deposit(address indexed account, uint256 amount);
    event Withdraw(address indexed account, uint256 amount);
    event Earn(address indexed token, uint256 amount);

    
    constructor(
        string memory _name,
        string memory _symbol,
        address _manager
    )
        public
        VaultToken(_name, _symbol)
    {
        manager = IManager(_manager);
        min = 9500;
        totalDepositCap = 10000000 ether;
    }

    

    
    function setGauge(
        address _gauge
    )
        external
        notHalted
        onlyStrategist
    {
        gauge = _gauge;
    }

    
    function setMin(
        uint256 _min
    )
        external
        notHalted
        onlyStrategist
    {
        require(_min <= MAX, ""!_min"");
        min = _min;
    }

    
    function setTotalDepositCap(
        uint256 _totalDepositCap
    )
        external
        notHalted
        onlyStrategist
    {
        totalDepositCap = _totalDepositCap;
    }

    
    function swap(
        address _token0,
        address _token1,
        uint256 _expectedAmount
    )
        external
        override
        notHalted
        onlyStrategist
        returns (uint256 _balance)
    {
        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));
        _balance = IERC20(_token0).balanceOf(address(this));
        IERC20(_token0).safeTransfer(address(_converter), _balance);
        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);
    }

    

    
    function earn(
        address _token,
        address _strategy
    )
        external
        override
        checkToken(_token)
        notHalted
        onlyHarvester
    {
        require(manager.allowedStrategies(_strategy), ""!_strategy"");
        IController _controller = IController(manager.controllers(address(this)));
        if (_controller.investEnabled()) {
            uint256 _balance = available(_token);
            IERC20(_token).safeTransfer(address(_controller), _balance);
            _controller.earn(_strategy, _token, _balance);
            emit Earn(_token, _balance);
        }
    }

    

    
     function deposit(
        address _token,
        uint256 _amount
     )
        public
        override
        checkToken(_token)
        notHalted
        returns (uint256 _shares)
    {
        require(_amount > 0, ""!_amount"");

        uint256 _balance = balance();

        uint256 _before = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);

        if (_amount > 0) {
            _amount = _normalizeDecimals(_token, _amount);

            if (totalSupply() > 0) {
                _amount = (_amount.mul(totalSupply())).div(_balance);
            }

            _shares = _amount;
        }

        if (_shares > 0) {
            _mint(msg.sender, _shares);
            require(totalSupply() <= totalDepositCap, "">totalDepositCap"");
            emit Deposit(msg.sender, _shares);
        }
    }

    
    function depositMultiple(
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
        override
        returns (uint256 _shares)
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i; i < _amounts.length; i++) {
            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));
        }
    }

    
    function withdraw(
        uint256 _shares,
        address _output
    )
        public
        override
        checkToken(_output)
    {
        uint256 _amount = (balance().mul(_shares)).div(totalSupply());
        _burn(msg.sender, _shares);

        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();
        if (_withdrawalProtectionFee > 0) {
            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);
            _amount = _amount.sub(_withdrawalProtection);
        }

        uint256 _balance = IERC20(_output).balanceOf(address(this));
        if (_balance < _amount) {
            IController _controller = IController(manager.controllers(address(this)));
            uint256 _toWithdraw = _amount.sub(_balance);
            if (_controller.strategies() > 0) {
                _controller.withdraw(_output, _toWithdraw);
            }
            uint256 _after = IERC20(_output).balanceOf(address(this));
            uint256 _diff = _after.sub(_balance);
            if (_diff < _toWithdraw) {
                _amount = _after;
            }
        }

        IERC20(_output).safeTransfer(msg.sender, _amount);
        emit Withdraw(msg.sender, _amount);
    }

    
    function withdrawAll(
        address _output
    )
        external
        override
    {
        withdraw(balanceOf(msg.sender), _output);
    }

    

    
    function available(
        address _token
    )
        public
        view
        override
        returns (uint256)
    {
        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);
    }

    
    function balance()
        public
        view
        override
        returns (uint256 _balance)
    {
        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());
    }

    
    function balanceOfThis()
        public
        view
        returns (uint256 _balance)
    {
        address[] memory _tokens = manager.getTokens(address(this));
        for (uint8 i; i < _tokens.length; i++) {
            address _token = _tokens[i];
            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));
        }
    }

    
    function getPricePerFullShare()
        external
        view
        override
        returns (uint256)
    {
        if (totalSupply() > 0) {
            return balance().mul(1e18).div(totalSupply());
        } else {
            return balance();
        }
    }

    
    function getTokens()
        external
        view
        override
        returns (address[] memory)
    {
        return manager.getTokens(address(this));
    }

    
    function withdrawFee(
        uint256 _amount
    )
        external
        view
        override
        returns (uint256)
    {
        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);
    }

    function _normalizeDecimals(
        address _token,
        uint256 _amount
    )
        internal
        view
        returns (uint256)
    {
        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());
        if (_decimals < 18) {
            _amount = _amount.mul(10**(18-_decimals));
        }
        return _amount;
    }

    

    modifier checkToken(address _token) {
        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), ""!_token"");
        _;
    }

    modifier notHalted() {
        require(!manager.halted(), ""halted"");
        _;
    }

    modifier onlyHarvester() {
        require(msg.sender == manager.harvester(), ""!harvester"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == manager.strategist(), ""!strategist"");
        _;
    }
}",1853.0,4,1,"{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in Withdraw Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdraw` function transfers tokens to the user before updating the user's balance, which can potentially allow reentrancy attacks if the receiving contract has a fallback function that calls back into the `withdraw` function."",
      ""Impact"": ""An attacker could exploit this vulnerability to withdraw more funds than they are entitled to, leading to a loss of funds in the vault."",
      ""Location"": ""Function `withdraw`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is crucial as it highlights a critical vulnerability that could lead to significant financial loss and compromise the integrity of the contract.""
    },
    {
      ""Issue"": ""Lack of Access Control on Sensitive Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `setGauge`, `setMin`, and `setTotalDepositCap` are protected only by the `onlyStrategist` modifier. If the strategist's role is compromised, an attacker could manipulate these critical parameters."",
      ""Impact"": ""Unauthorized changes to these parameters could lead to improper vault operations, potentially affecting investments and user deposits."",
      ""Location"": ""Functions `setGauge`, `setMin`, and `setTotalDepositCap`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding correctly identifies a potential security risk if the strategist's role is compromised, which is valid and relevant.""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `setGauge`, `setMin`, and `setTotalDepositCap` modify important state variables but do not emit events to log these changes, reducing transparency and traceability."",
      ""Impact"": ""Without event logs, tracking changes to critical parameters becomes difficult, reducing transparency and making auditing more challenging."",
      ""Location"": ""Functions `setGauge`, `setMin`, and `setTotalDepositCap`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as event emissions are crucial for transparency and tracking changes in smart contracts.""
    },
    {
      ""Issue"": ""Hardcoded Total Deposit Cap"",
      ""Severity"": ""Low"",
      ""Description"": ""The `totalDepositCap` is initialized with a hardcoded value, which might not be flexible enough for different deployment scenarios."",
      ""Impact"": ""This fixed cap can limit the contract's usability in varying environments or require redeployment for adjustments."",
      ""Location"": ""Constructor around line 28"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it affects the contract's flexibility and adaptability to different operational environments.""
    }
  ],
  ""FindingNumber"": 4,
  ""AllRelevance"": 37,
  ""RelevanceCount"": 30,
  ""AllValidation"": 37,
  ""ValidationCount"": 30
}","### **Output**

---

**[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities**

**Report Description**:
The v3 vault treats all valid tokens equally, allowing users to deposit one token and withdraw another, creating arbitrage opportunities. For example, depositing 1M DAI would grant the same share as depositing 1M USDT, and users could withdraw their share in a different token. Although there is a `withdrawalProtectionFee` (0.1%), the vault effectively acts as a no-slippage stablecoin exchange. Additionally, the inclusion of `3crv_token` (an LP token) in the vault makes it vulnerable to flashloan attacks due to its price discrepancy (1.01 at the time of writing). This design flaw exposes the vault to significant risks, especially if strategies are not carefully designed.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of token equality or the associated arbitrage and flashloan risks. This is a critical oversight, as the vulnerability could lead to significant financial losses.

---

**[H-06] earn results in decreasing share price**

**Report Description**:
For a DAI vault paired with `NativeStrategyCurve3Crv`, calling `earn()` results in shareholders losing approximately 2% of their value. This occurs because the `Vault` contract and the `controller` contract do not handle the price difference between the `want` token (t3crv) and other tokens. When the vault calculates its value, it sums up all token balances, but the controller only considers the `strategy.want` amount. This discrepancy causes users who deposit DAI to lose money instead of earning yield.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of share price depreciation or the mismanagement of token price differences. This is a significant oversight, as it directly impacts user funds.

---

**[H-07] Vault.balance() mixes normalized and standard amounts**

**Report Description**:
The `Vault.balance` function uses `balanceOfThis`, which normalizes all balances to 18 decimals. However, the second term in the calculation, `IController(manager.controllers(address(this))).balanceOf()`, is not normalized. This inconsistency leads to incorrect calculations, as normalized and non-normalized amounts are added together. This issue propagates through the contract, causing further inaccuracies.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of mixing normalized and non-normalized amounts. This is a critical oversight, as it affects the accuracy of balance calculations.

---

**[H-08] Vault.withdraw mixes normalized and standard amounts**

**Report Description**:
The `Vault.withdraw` function uses `balanceOfThis`, which normalizes all balances to 18 decimals. However, the `_amount` value is normalized, while the `_balance` value (`IERC20(_output).balanceOf(address(this))`) is not. This inconsistency leads to incorrect comparisons and calculations, such as subtracting unnormalized values from normalized ones. This issue can result in users receiving fewer tokens than they are entitled to.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of mixing normalized and non-normalized amounts in the `withdraw` function. This is a critical oversight, as it directly impacts user withdrawals.

---

**[M-03] Vault.withdraw sometimes burns too many shares**

**Report Description**:
The `Vault.withdraw` function attempts to withdraw funds from the controller if there are insufficient funds in the vault. If the controller cannot withdraw enough (`_diff < _toWithdraw`), the user receives fewer output tokens than their fair share would entitle them to. However, the function still burns the full share amount, leading to an unfair loss for the user.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of burning too many shares during withdrawals. This is a significant oversight, as it directly impacts user funds.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities**
- **[H-06] earn results in decreasing share price**
- **[H-07] Vault.balance() mixes normalized and standard amounts**
- **[H-08] Vault.withdraw mixes normalized and standard amounts**
- **[M-03] Vault.withdraw sometimes burns too many shares**

---

### **Conclusion**
The `response_list` does not address any of the issues raised in the `issue` report. This represents a significant gap in coverage, as the issues identified in the report are critical vulnerabilities that could lead to financial losses and operational failures. The response list should be expanded to include these issues, with detailed explanations and proposed solutions to ensure the security and functionality of the smart contracts.",0.0,0,5,4.0,37.0,"```
None.
```",0.0
VaultHelper.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./interfaces/ILiquidityGaugeV2.sol"";
import ""./interfaces/IVault.sol"";

/**
 * @title VaultHelper
 * @notice The VaultHelper acts as a single contract that users may set
 * token approvals on for any token of any vault.
 * @dev This contract has no state and could be deployed by anyone if
 * they didn't trust the original deployer.
 */
contract VaultHelper {
    using SafeERC20 for IERC20;

    /**
     * @notice Deposits the given token into the specified vault
     * @dev Users must approve the vault helper to spend their token
     * @param _vault The address of the vault
     * @param _token The address of the token
     * @param _amount The amount of tokens to deposit
     */
    function depositVault(
        address _vault,
        address _token,
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_token).safeApprove(_vault, 0);
        IERC20(_token).safeApprove(_vault, _amount);
        uint256 _shares = IVault(_vault).deposit(_token, _amount);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    /**
     * @notice Deposits multiple tokens simultaneously to the specified vault
     * @dev Users must approve the vault helper to spend their tokens
     * @param _vault The address of the vault
     * @param _tokens The addresses of each token being deposited
     * @param _amounts The amounts of each token being deposited
     */
    function depositMultipleVault(
        address _vault,
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i = 0; i < _amounts.length; i++) {
            require(_amounts[i] > 0, ""!_amounts"");
            IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);
            IERC20(_tokens[i]).safeApprove(_vault, 0);
            IERC20(_tokens[i]).safeApprove(_vault, _amounts[i]);
        }
        uint256 _shares = IVault(_vault).depositMultiple(_tokens, _amounts);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    function withdrawVault(
        address _vault,
        address _toToken,
        uint256 _amount
    )
        external
    {
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);
            ILiquidityGaugeV2(_gauge).withdraw(_amount);
            IVault(_vault).withdraw(IERC20(_vault).balanceOf(address(this)), _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        } else {
            IERC20(_vault).safeTransferFrom(msg.sender, address(this), _amount);
            IVault(_vault).withdraw(_amount, _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        }
    }
}",997.0,106.0,"[M-01] VaultHelper deposits don't work with fee-on transfer tokens
There are ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`. Others are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).
The VaultHelper's `depositVault()` and `depositMultipleVault` functions transfer `_amount` to `this` contract using `IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);`. This could have a fee, and less than _amount ends up in the contract. The next actual vault deposit using `IVault(_vault).deposit(_token, _amount);` will then try to transfer more than the this contract actually has and will revert the transaction.",1.0,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";

import ""./interfaces/ILiquidityGaugeV2.sol"";
import ""./interfaces/IVault.sol"";


contract VaultHelper {
    using SafeERC20 for IERC20;

    
    function depositVault(
        address _vault,
        address _token,
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_token).safeApprove(_vault, 0);
        IERC20(_token).safeApprove(_vault, _amount);
        uint256 _shares = IVault(_vault).deposit(_token, _amount);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    
    function depositMultipleVault(
        address _vault,
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i = 0; i < _amounts.length; i++) {
            require(_amounts[i] > 0, ""!_amounts"");
            IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);
            IERC20(_tokens[i]).safeApprove(_vault, 0);
            IERC20(_tokens[i]).safeApprove(_vault, _amounts[i]);
        }
        uint256 _shares = IVault(_vault).depositMultiple(_tokens, _amounts);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

    function withdrawVault(
        address _vault,
        address _toToken,
        uint256 _amount
    )
        external
    {
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);
            ILiquidityGaugeV2(_gauge).withdraw(_amount);
            IVault(_vault).withdraw(IERC20(_vault).balanceOf(address(this)), _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        } else {
            IERC20(_vault).safeTransferFrom(msg.sender, address(this), _amount);
            IVault(_vault).withdraw(_amount, _toToken);
            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));
        }
    }
}",787.0,0,0,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Reentrancy Protection"",
      ""Severity"": ""High"",
      ""Description"": ""The functions `depositVault`, `depositMultipleVault`, and `withdrawVault` lack reentrancy guards, making them vulnerable to reentrancy attacks when interacting with external contracts, leading to potential unauthorized withdrawals."",
      ""Impact"": ""Reentrancy attacks could allow malicious actors to drain funds or manipulate contract state, leading to significant financial loss."",
      ""Location"": ""Functions `depositVault`, `depositMultipleVault`, and `withdrawVault`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is critical as reentrancy attacks are a common vulnerability in Solidity contracts.""
    },
    {
      ""Issue"": ""Approval Race Condition"",
      ""Severity"": ""Medium"",
      ""Description"": ""Setting token allowances to zero before updating them can lead to race conditions. This pattern, while intended to prevent certain attacks, introduces vulnerabilities if the token contract isn't compliant."",
      ""Impact"": ""Attackers could exploit this by front-running transactions, leading to unauthorized token transfers."",
      ""Location"": ""Functions `depositVault` and `depositMultipleVault`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a common issue with token approval patterns that could lead to financial loss.""
    },
    {
      ""Issue"": ""Improper Token Approval Handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract resets token allowances to zero before setting new values. This approach, while common, may not be necessary and can lead to increased gas costs and potential vulnerabilities in non-compliant token contracts."",
      ""Impact"": ""Unnecessary gas costs and potential race conditions if the token contract does not handle this pattern correctly."",
      ""Location"": ""Functions `depositVault` and `depositMultipleVault`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it addresses inefficiencies in token approval handling that can impact user costs.""
    },
    {
      ""Issue"": ""Lack of Input Validation for Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not validate if the provided addresses (_vault, _token) are non-zero before use, which can lead to unexpected behavior if zero addresses are accidentally used."",
      ""Impact"": ""Could cause logic errors or fund loss if zero addresses are passed."",
      ""Location"": ""Functions `depositVault`, `depositMultipleVault`, and `withdrawVault`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring that input addresses are valid is crucial to prevent misconfigurations.""
    },
    {
      ""Issue"": ""Missing Event Emissions"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks event emissions for critical operations like deposits and withdrawals, hindering tracking and auditing efforts."",
      ""Impact"": ""Reduced transparency and difficulty in monitoring contract activity, potentially complicating audits."",
      ""Location"": ""Functions `depositVault`, `depositMultipleVault`, and `withdrawVault`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The absence of event emissions affects the contract's accountability and traceability.""
    },
    {
      ""Issue"": ""Potential Misalignment in Token and Amount Arrays"",
      ""Severity"": ""Low"",
      ""Description"": ""While the contract checks that the `_tokens` and `_amounts` arrays have the same length, it does not validate that corresponding elements match correctly."",
      ""Impact"": ""This could lead to incorrect token transfers or approvals, resulting in unexpected behavior."",
      ""Location"": ""Function `depositMultipleVault`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring that tokens and amounts match as intended is crucial for preventing unexpected behaviors.""
    }
  ],
  ""FindingNumber"": 6,
  ""AllRelevance"": 34,
  ""RelevanceCount"": 34,
  ""AllValidation"": 36,
  ""ValidationCount"": 36
}","---

**[M-01] VaultHelper deposits don't work with fee-on-transfer tokens**

**Report Description**:
The `VaultHelper` contract's `depositVault()` and `depositMultipleVault()` functions do not account for fee-on-transfer tokens or rebasing tokens. These tokens may deduct a fee during transfers or change their balance over time. The functions transfer `_amount` to the contract using `IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);`, but if a fee is deducted, the actual balance received by the contract will be less than `_amount`. When the contract attempts to deposit `_amount` into the vault using `IVault(_vault).deposit(_token, _amount);`, it will try to transfer more than the contract holds, causing the transaction to revert. This issue can disrupt the functionality of the contract when interacting with such tokens.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. None of the responses in the `response_list` address the issue of fee-on-transfer tokens or rebasing tokens. The responses focus on reentrancy protection, approval race conditions, improper token approval handling, input validation, missing event emissions, and potential misalignment in token and amount arrays. These are unrelated to the specific vulnerability described in the issue report. The issue of fee-on-transfer tokens is a distinct problem that requires handling the actual balance received after a transfer, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-01] VaultHelper deposits don't work with fee-on-transfer tokens**

---",0.0,0,1,6.0,34.0,"```
None.
```",0.0
Manger.sol,"// SPDX-License-Identifier: MIT
// solhint-disable max-states-count
// solhint-disable var-name-mixedcase

pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IHarvester.sol"";
import ""./interfaces/IManager.sol"";
import ""./interfaces/IStrategy.sol"";
import ""./interfaces/IVault.sol"";

/**
 * @title Manager
 * @notice This contract serves as the central point for governance-voted
 * variables. Fees and permissioned addresses are stored and referenced in
 * this contract only.
 */
contract Manager is IManager {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;
    uint256 public constant MAX_TOKENS = 256;

    address public immutable override yaxis;

    bool public override halted;

    address public override governance;
    address public override harvester;
    address public override insurancePool;
    address public override stakingPool;
    address public override strategist;
    address public override pendingStrategist;
    address public override treasury;

    // The following fees are all mutable.
    // They are updated by governance (community vote).
    uint256 public override insuranceFee;
    uint256 public override insurancePoolFee;
    uint256 public override stakingPoolShareFee;
    uint256 public override treasuryFee;
    uint256 public override withdrawalProtectionFee;


    uint256 private setPendingStrategistTime;

    // Governance must first allow the following properties before
    // the strategist can make use of them
    mapping(address => bool) public override allowedControllers;
    mapping(address => bool) public override allowedConverters;
    mapping(address => bool) public override allowedStrategies;
    mapping(address => bool) public override allowedTokens;
    mapping(address => bool) public override allowedVaults;

    // vault => controller
    mapping(address => address) public override controllers;
    // vault => tokens[]
    mapping(address => address[]) public override tokens;
    // token => vault
    mapping(address => address) public override vaults;

    event AllowedController(
        address indexed _controller,
        bool _allowed
    );
    event AllowedConverter(
        address indexed _converter,
        bool _allowed
    );
    event AllowedStrategy(
        address indexed _strategy,
        bool _allowed
    );
    event AllowedToken(
        address indexed _token,
        bool _allowed
    );
    event AllowedVault(
        address indexed _vault,
        bool _allowed
    );
    event Halted();
    event SetController(
        address indexed _vault,
        address indexed _controller
    );
    event SetGovernance(
        address indexed _governance
    );
    event SetPendingStrategist(
        address indexed _strategist
    );
    event SetStrategist(
        address indexed _strategist
    );
    event TokenAdded(
        address indexed _vault,
        address indexed _token
    );
    event TokenRemoved(
        address indexed _vault,
        address indexed _token
    );

    /**
     * @param _yaxis The address of the YAX token
     */
    constructor(
        address _yaxis
    )
        public
    {
        require(_yaxis != address(0), ""!_yaxis"");
        yaxis = _yaxis;
        governance = msg.sender;
        strategist = msg.sender;
        harvester = msg.sender;
        treasury = msg.sender;
        stakingPoolShareFee = 2000;
        treasuryFee = 500;
        withdrawalProtectionFee = 10;
    }

    /**
     * GOVERNANCE-ONLY FUNCTIONS
     */

    /**
     * @notice Sets the permission for the given controller
     * @param _controller The address of the controller
     * @param _allowed The status of if it is allowed
     */
    function setAllowedController(
        address _controller,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IController(_controller).manager()) == address(this), ""!manager"");
        allowedControllers[_controller] = _allowed;
        emit AllowedController(_controller, _allowed);
    }

    /**
     * @notice Sets the permission for the given converter
     * @param _converter The address of the converter
     * @param _allowed The status of if it is allowed
     */
    function setAllowedConverter(
        address _converter,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IConverter(_converter).manager()) == address(this), ""!manager"");
        allowedConverters[_converter] = _allowed;
        emit AllowedConverter(_converter, _allowed);
    }

    /**
     * @notice Sets the permission for the given strategy
     * @param _strategy The address of the strategy
     * @param _allowed The status of if it is allowed
     */
    function setAllowedStrategy(
        address _strategy,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IStrategy(_strategy).manager()) == address(this), ""!manager"");
        allowedStrategies[_strategy] = _allowed;
        emit AllowedStrategy(_strategy, _allowed);
    }

    /**
     * @notice Sets the permission for the given token
     * @param _token The address of the token
     * @param _allowed The status of if it is allowed
     */
    function setAllowedToken(
        address _token,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        allowedTokens[_token] = _allowed;
        emit AllowedToken(_token, _allowed);
    }

    /**
     * @notice Sets the permission for the given vault
     * @param _vault The address of the vault
     * @param _allowed The status of if it is allowed
     */
    function setAllowedVault(
        address _vault,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IVault(_vault).manager()) == address(this), ""!manager"");
        allowedVaults[_vault] = _allowed;
        emit AllowedVault(_vault, _allowed);
    }

    /**
     * @notice Sets the governance address
     * @param _governance The address of the governance
     */
    function setGovernance(
        address _governance
    )
        external
        notHalted
        onlyGovernance
    {
        governance = _governance;
        emit SetGovernance(_governance);
    }

    /**
     * @notice Sets the harvester address
     * @param _harvester The address of the harvester
     */
    function setHarvester(
        address _harvester
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IHarvester(_harvester).manager()) == address(this), ""!manager"");
        harvester = _harvester;
    }

    /**
     * @notice Sets the insurance fee
     * @dev Throws if setting fee over 1%
     * @param _insuranceFee The value for the insurance fee
     */
    function setInsuranceFee(
        uint256 _insuranceFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insuranceFee <= 100, ""_insuranceFee over 1%"");
        insuranceFee = _insuranceFee;
    }

    /**
     * @notice Sets the insurance pool address
     * @param _insurancePool The address of the insurance pool
     */
    function setInsurancePool(
        address _insurancePool
    )
        external
        notHalted
        onlyGovernance
    {
        insurancePool = _insurancePool;
    }

    /**
     * @notice Sets the insurance pool fee
     * @dev Throws if setting fee over 20%
     * @param _insurancePoolFee The value for the insurance pool fee
     */
    function setInsurancePoolFee(
        uint256 _insurancePoolFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insurancePoolFee <= 2000, ""_insurancePoolFee over 20%"");
        insurancePoolFee = _insurancePoolFee;
    }

    /**
     * @notice Sets the staking pool address
     * @param _stakingPool The address of the staking pool
     */
    function setStakingPool(
        address _stakingPool
    )
        external
        notHalted
        onlyGovernance
    {
        stakingPool = _stakingPool;
    }

    /**
     * @notice Sets the staking pool share fee
     * @dev Throws if setting fee over 50%
     * @param _stakingPoolShareFee The value for the staking pool fee
     */
    function setStakingPoolShareFee(
        uint256 _stakingPoolShareFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_stakingPoolShareFee <= 5000, ""_stakingPoolShareFee over 50%"");
        stakingPoolShareFee = _stakingPoolShareFee;
    }

    /**
     * @notice Sets the pending strategist and the timestamp
     * @param _strategist The address of the strategist
     */
    function setStrategist(
        address _strategist
    )
        external
        notHalted
        onlyGovernance
    {
        require(_strategist != address(0), ""!_strategist"");
        pendingStrategist = _strategist;
        // solhint-disable-next-line not-rely-on-time
        setPendingStrategistTime = block.timestamp;
        emit SetPendingStrategist(_strategist);
    }

    /**
     * @notice Sets the treasury address
     * @param _treasury The address of the treasury
     */
    function setTreasury(
        address _treasury
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasury != address(0), ""!_treasury"");
        treasury = _treasury;
    }

    /**
     * @notice Sets the treasury fee
     * @dev Throws if setting fee over 20%
     * @param _treasuryFee The value for the treasury fee
     */
    function setTreasuryFee(
        uint256 _treasuryFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasuryFee <= 2000, ""_treasuryFee over 20%"");
        treasuryFee = _treasuryFee;
    }

    /**
     * @notice Sets the withdrawal protection fee
     * @dev Throws if setting fee over 1%
     * @param _withdrawalProtectionFee The value for the withdrawal protection fee
     */
    function setWithdrawalProtectionFee(
        uint256 _withdrawalProtectionFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_withdrawalProtectionFee <= 100, ""_withdrawalProtectionFee over 1%"");
        withdrawalProtectionFee = _withdrawalProtectionFee;
    }

    /**
     * STRATEGIST-ONLY FUNCTIONS
     */

    /**
     * @notice Updates the strategist to the pending strategist
     * @dev This can only be called after the pending strategist timelock (7 days)
     */
    function acceptStrategist()
        external
        notHalted
    {
        require(msg.sender == pendingStrategist, ""!pendingStrategist"");
        // solhint-disable-next-line not-rely-on-time
        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), ""PENDING_STRATEGIST_TIMELOCK"");
        delete pendingStrategist;
        delete setPendingStrategistTime;
        strategist = msg.sender;
        emit SetStrategist(msg.sender);
    }

    /**
     * @notice Adds a token to be able to be deposited for a given vault
     * @param _vault The address of the vault
     * @param _token The address of the token
     */
    function addToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        require(allowedTokens[_token], ""!allowedTokens"");
        require(allowedVaults[_vault], ""!allowedVaults"");
        require(tokens[_vault].length < MAX_TOKENS, "">tokens"");
        require(vaults[_token] == address(0), ""!_token"");
        vaults[_token] = _vault;
        tokens[_vault].push(_token);
        emit TokenAdded(_vault, _token);
    }

    /**
     * @notice Allows the strategist to pull tokens out of this contract
     * @dev This contract should never hold tokens
     * @param _token The address of the token
     * @param _amount The amount to withdraw
     * @param _to The address to send to
     */
    function recoverToken(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        notHalted
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }

    /**
     * @notice Removes a token from being able to be deposited for a given vault
     * @param _vault The address of the vault
     * @param _token The address of the token
     */
    function removeToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        uint256 k = tokens[_vault].length;
        uint256 index;
        bool found;

        for (uint i = 0; i < k; i++) {
            if (tokens[_vault][i] == _token) {
                index = i;
                found = true;
                break;
            }
        }

        // TODO: Verify added check
        if (found) {
            tokens[_vault][index] = tokens[_vault][k-1];
            tokens[_vault].pop();
            delete vaults[_token];
            emit TokenRemoved(_vault, _token);
        }
    }

    /**
     * @notice Sets the vault address for a controller
     * @param _vault The address of the vault
     * @param _controller The address of the controller
     */
    function setController(
        address _vault,
        address _controller
    )
        external
        notHalted
        onlyStrategist
    {
        require(allowedVaults[_vault], ""!_vault"");
        require(allowedControllers[_controller], ""!_controller"");
        controllers[_vault] = _controller;
        emit SetController(_vault, _controller);
    }

    /**
     * @notice Sets the protocol as halted, disallowing all deposits forever
     * @dev Withdraws will still work, allowing users to exit the protocol
     */
    function setHalted()
        external
        notHalted
        onlyStrategist
    {
        halted = true;
        emit Halted();
    }

    /**
     * EXTERNAL VIEW FUNCTIONS
     */

    /**
     * @notice Returns an array of token addresses for a given vault
     * @param _vault The address of the vault
     */
    function getTokens(
        address _vault
    )
        external
        view
        override
        returns (address[] memory)
    {
        return tokens[_vault];
    }

    /**
     * @notice Returns a tuple of:
     *     YAXIS token address,
     *     Treasury address,
     *     Treasury fee
     */
    function getHarvestFeeInfo()
        external
        view
        override
        returns (
            address,
            address,
            uint256
        )
    {
        return (
            yaxis,
            treasury,
            treasuryFee
        );
    }

    modifier notHalted() {
        require(!halted, ""halted"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""!governance"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == strategist, ""!strategist"");
        _;
    }
}",3492.0,583.0,"[M-02] ERC20 return values not checked
The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do not revert if the transfer failed but return `false` instead.
The `Manager.recoverToken` function does not check the return value of this function.
Tokens that don't actually perform the transfer and return false are still counted as a correct transfer. Furthermore, tokens that do not correctly implement the EIP20 standard, like USDT which does not return a success boolean, will revert.
  [M-09] token -> vault mapping can be overwritten
One vault can have many tokens, but each token should only be assigned to a single vault. The Manager contract keeps a mapping of tokens to vaults in the `vaults[_token] => _vault` map, and a mapping of vault to tokens in tokens[vault] => token[].
The `addToken` function can assign any token to a single vault and allows overwriting an existing vaults[_token] map entry with a different vault. This indirectly disassociates the previous vault for the token. Note that the previous vault's tokens[_previousVault] map still contains the token.
  [M-13] `manager.allowedVaults` check missing for add/remove strategy
The `manager.allowedVaults` check is missing for add/remove strategy like how it is used in reorderStrategies(). This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.
Given the critical access control that is missing on vaults here, this is classified as medium severity.",3.0,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/IController.sol"";
import ""./interfaces/IConverter.sol"";
import ""./interfaces/IHarvester.sol"";
import ""./interfaces/IManager.sol"";
import ""./interfaces/IStrategy.sol"";
import ""./interfaces/IVault.sol"";


contract Manager is IManager {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;
    uint256 public constant MAX_TOKENS = 256;

    address public immutable override yaxis;

    bool public override halted;

    address public override governance;
    address public override harvester;
    address public override insurancePool;
    address public override stakingPool;
    address public override strategist;
    address public override pendingStrategist;
    address public override treasury;

    
    
    uint256 public override insuranceFee;
    uint256 public override insurancePoolFee;
    uint256 public override stakingPoolShareFee;
    uint256 public override treasuryFee;
    uint256 public override withdrawalProtectionFee;


    uint256 private setPendingStrategistTime;

    
    
    mapping(address => bool) public override allowedControllers;
    mapping(address => bool) public override allowedConverters;
    mapping(address => bool) public override allowedStrategies;
    mapping(address => bool) public override allowedTokens;
    mapping(address => bool) public override allowedVaults;

    
    mapping(address => address) public override controllers;
    
    mapping(address => address[]) public override tokens;
    
    mapping(address => address) public override vaults;

    event AllowedController(
        address indexed _controller,
        bool _allowed
    );
    event AllowedConverter(
        address indexed _converter,
        bool _allowed
    );
    event AllowedStrategy(
        address indexed _strategy,
        bool _allowed
    );
    event AllowedToken(
        address indexed _token,
        bool _allowed
    );
    event AllowedVault(
        address indexed _vault,
        bool _allowed
    );
    event Halted();
    event SetController(
        address indexed _vault,
        address indexed _controller
    );
    event SetGovernance(
        address indexed _governance
    );
    event SetPendingStrategist(
        address indexed _strategist
    );
    event SetStrategist(
        address indexed _strategist
    );
    event TokenAdded(
        address indexed _vault,
        address indexed _token
    );
    event TokenRemoved(
        address indexed _vault,
        address indexed _token
    );

    
    constructor(
        address _yaxis
    )
        public
    {
        require(_yaxis != address(0), ""!_yaxis"");
        yaxis = _yaxis;
        governance = msg.sender;
        strategist = msg.sender;
        harvester = msg.sender;
        treasury = msg.sender;
        stakingPoolShareFee = 2000;
        treasuryFee = 500;
        withdrawalProtectionFee = 10;
    }

    

    
    function setAllowedController(
        address _controller,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IController(_controller).manager()) == address(this), ""!manager"");
        allowedControllers[_controller] = _allowed;
        emit AllowedController(_controller, _allowed);
    }

    
    function setAllowedConverter(
        address _converter,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IConverter(_converter).manager()) == address(this), ""!manager"");
        allowedConverters[_converter] = _allowed;
        emit AllowedConverter(_converter, _allowed);
    }

    
    function setAllowedStrategy(
        address _strategy,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IStrategy(_strategy).manager()) == address(this), ""!manager"");
        allowedStrategies[_strategy] = _allowed;
        emit AllowedStrategy(_strategy, _allowed);
    }

    
    function setAllowedToken(
        address _token,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        allowedTokens[_token] = _allowed;
        emit AllowedToken(_token, _allowed);
    }

    
    function setAllowedVault(
        address _vault,
        bool _allowed
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IVault(_vault).manager()) == address(this), ""!manager"");
        allowedVaults[_vault] = _allowed;
        emit AllowedVault(_vault, _allowed);
    }

    
    function setGovernance(
        address _governance
    )
        external
        notHalted
        onlyGovernance
    {
        governance = _governance;
        emit SetGovernance(_governance);
    }

    
    function setHarvester(
        address _harvester
    )
        external
        notHalted
        onlyGovernance
    {
        require(address(IHarvester(_harvester).manager()) == address(this), ""!manager"");
        harvester = _harvester;
    }

    
    function setInsuranceFee(
        uint256 _insuranceFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insuranceFee <= 100, ""_insuranceFee over 1%"");
        insuranceFee = _insuranceFee;
    }

    
    function setInsurancePool(
        address _insurancePool
    )
        external
        notHalted
        onlyGovernance
    {
        insurancePool = _insurancePool;
    }

    
    function setInsurancePoolFee(
        uint256 _insurancePoolFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_insurancePoolFee <= 2000, ""_insurancePoolFee over 20%"");
        insurancePoolFee = _insurancePoolFee;
    }

    
    function setStakingPool(
        address _stakingPool
    )
        external
        notHalted
        onlyGovernance
    {
        stakingPool = _stakingPool;
    }

    
    function setStakingPoolShareFee(
        uint256 _stakingPoolShareFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_stakingPoolShareFee <= 5000, ""_stakingPoolShareFee over 50%"");
        stakingPoolShareFee = _stakingPoolShareFee;
    }

    
    function setStrategist(
        address _strategist
    )
        external
        notHalted
        onlyGovernance
    {
        require(_strategist != address(0), ""!_strategist"");
        pendingStrategist = _strategist;
        
        setPendingStrategistTime = block.timestamp;
        emit SetPendingStrategist(_strategist);
    }

    
    function setTreasury(
        address _treasury
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasury != address(0), ""!_treasury"");
        treasury = _treasury;
    }

    
    function setTreasuryFee(
        uint256 _treasuryFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_treasuryFee <= 2000, ""_treasuryFee over 20%"");
        treasuryFee = _treasuryFee;
    }

    
    function setWithdrawalProtectionFee(
        uint256 _withdrawalProtectionFee
    )
        external
        notHalted
        onlyGovernance
    {
        require(_withdrawalProtectionFee <= 100, ""_withdrawalProtectionFee over 1%"");
        withdrawalProtectionFee = _withdrawalProtectionFee;
    }

    

    
    function acceptStrategist()
        external
        notHalted
    {
        require(msg.sender == pendingStrategist, ""!pendingStrategist"");
        
        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), ""PENDING_STRATEGIST_TIMELOCK"");
        delete pendingStrategist;
        delete setPendingStrategistTime;
        strategist = msg.sender;
        emit SetStrategist(msg.sender);
    }

    
    function addToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        require(allowedTokens[_token], ""!allowedTokens"");
        require(allowedVaults[_vault], ""!allowedVaults"");
        require(tokens[_vault].length < MAX_TOKENS, "">tokens"");
        require(vaults[_token] == address(0), ""!_token"");
        vaults[_token] = _vault;
        tokens[_vault].push(_token);
        emit TokenAdded(_vault, _token);
    }

    
    function recoverToken(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        notHalted
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }

    
    function removeToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        uint256 k = tokens[_vault].length;
        uint256 index;
        bool found;

        for (uint i = 0; i < k; i++) {
            if (tokens[_vault][i] == _token) {
                index = i;
                found = true;
                break;
            }
        }

        
        if (found) {
            tokens[_vault][index] = tokens[_vault][k-1];
            tokens[_vault].pop();
            delete vaults[_token];
            emit TokenRemoved(_vault, _token);
        }
    }

    
    function setController(
        address _vault,
        address _controller
    )
        external
        notHalted
        onlyStrategist
    {
        require(allowedVaults[_vault], ""!_vault"");
        require(allowedControllers[_controller], ""!_controller"");
        controllers[_vault] = _controller;
        emit SetController(_vault, _controller);
    }

    
    function setHalted()
        external
        notHalted
        onlyStrategist
    {
        halted = true;
        emit Halted();
    }

    

    
    function getTokens(
        address _vault
    )
        external
        view
        override
        returns (address[] memory)
    {
        return tokens[_vault];
    }

    
    function getHarvestFeeInfo()
        external
        view
        override
        returns (
            address,
            address,
            uint256
        )
    {
        return (
            yaxis,
            treasury,
            treasuryFee
        );
    }

    modifier notHalted() {
        require(!halted, ""halted"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""!governance"");
        _;
    }

    modifier onlyStrategist() {
        require(msg.sender == strategist, ""!strategist"");
        _;
    }
}",2388.0,0,3,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on `recoverToken` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `recoverToken` function allows the strategist to transfer any ERC20 token from the contract to an arbitrary address, which could be exploited if the strategist's address is compromised."",
      ""Impact"": ""A compromised strategist account could drain tokens from the contract, leading to significant financial loss."",
      ""Location"": ""Function `recoverToken` defined around lines 313-319 and various other instances."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding addresses a significant security risk regarding access control on token recovery.""
    },
    {
      ""Issue"": ""Delayed Strategist Role Acceptance and Transfer Mechanisms"",
      ""Severity"": ""High"",
      ""Description"": ""The `setStrategist` function allows setting a pending strategist and the `acceptStrategist` function finalizes this transfer after a 7-day timelock. There is no mechanism to revoke this role if the pending strategist becomes unsuitable during the waiting period."",
      ""Impact"": ""If the pending strategist account is compromised, it could lead to unauthorized control over the strategist functions."",
      ""Location"": ""Functions `setStrategist` and `acceptStrategist` defined in various lines."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a critical governance risk associated with the strategist role assignment.""
    },
    {
      ""Issue"": ""Centralized Control and Governance Risks"",
      ""Severity"": ""High"",
      ""Description"": ""The governance and strategist roles have significant control over contract operations, including the ability to halt operations and manage tokens. If these accounts are compromised, it could lead to malicious actions."",
      ""Impact"": ""Compromised governance or strategist roles could manipulate contract settings, affecting all users and stakeholders."",
      ""Location"": ""Functions with `onlyGovernance` and `onlyStrategist` modifiers applied."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding correctly identifies the centralization risk in contract governance.""
    },
    {
      ""Issue"": ""Potential for High Fees and User Impact"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `setInsuranceFee`, `setTreasuryFee`, and others allow for setting various fees with high potential limits, which could accumulate significantly and deter user participation."",
      ""Impact"": ""Excessive fees can discourage users from participating in the system, reduce liquidity, and create a negative perception of the platform."",
      ""Location"": ""Functions such as `setInsuranceFee`, `setTreasuryFee`, etc."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding emphasizes user concerns regarding fee accumulation.""
    },
    {
      ""Issue"": ""Potential Misuse of `setHalted` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setHalted` function allows the strategist to halt contract operations without a corresponding mechanism to unhalt it, which could lead to a permanent stoppage."",
      ""Impact"": ""Once halted, the contract may not be able to resume normal operations, disrupting services and access to user funds."",
      ""Location"": ""Function `setHalted` defined in various lines."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding identifies the risk of permanent disruption due to excessive control over the halted state.""
    },
    {
      ""Issue"": ""Inadequate Event Emission for Transparency"",
      ""Severity"": ""Low"",
      ""Description"": ""Not all functions emit events when state changes occur, which is crucial for tracking changes and auditing the contract's activity."",
      ""Impact"": ""Without proper event logging, it becomes challenging to trace and verify changes, potentially leading to undetected malicious activities."",
      ""Location"": ""Functions like `setHarvester`, `setInsurancePool`, and others."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding emphasizes the importance of event emissions for transparency in smart contract operations.""
    }
  ],
  ""FindingNumber"": 6,
  ""AllRelevance"": 35,
  ""RelevanceCount"": 35,
  ""AllValidation"": 35,
  ""ValidationCount"": 35
}","### **Comparison and Evaluation**

---

#### **[M-02] ERC20 return values not checked**

**Report Description**:  
The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do not revert if the transfer fails but return `false` instead. The `Manager.recoverToken` function does not check the return value of these functions. Tokens that do not perform the transfer and return `false` are still counted as a correct transfer. Additionally, tokens like USDT, which do not correctly implement the EIP20 standard (e.g., do not return a success boolean), will revert.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unchecked ERC20 return values in the `recoverToken` function. This is a critical oversight, as it could lead to silent failures in token transfers, especially when dealing with non-compliant or malicious tokens. Solidity best practices emphasize the importance of validating return values from external calls to ensure secure contract interactions.

---

#### **[M-09] token -> vault mapping can be overwritten**

**Report Description**:  
One vault can have many tokens, but each token should only be assigned to a single vault. The `Manager` contract maintains a mapping of tokens to vaults (`vaults[_token] => _vault`) and a mapping of vaults to tokens (`tokens[vault] => token[]`). The `addToken` function allows overwriting an existing `vaults[_token]` map entry with a different vault, indirectly disassociating the previous vault for the token. However, the previous vault's `tokens[_previousVault]` map still contains the token, leading to inconsistencies.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of token-to-vault mapping overwrites. This oversight could lead to inconsistencies in the contract's state, where a token is associated with multiple vaults or orphaned in the previous vault's token list. Proper access control and state management are critical to maintaining the integrity of such mappings.

---

#### **[M-13] `manager.allowedVaults` check missing for add/remove strategy**

**Report Description**:  
The `manager.allowedVaults` check is missing for the `addStrategy` and `removeStrategy` functions, unlike in `reorderStrategies()`. This allows a strategist to accidentally or maliciously add/remove strategies on unauthorized vaults. Given the critical access control missing here, this is classified as a medium-severity issue.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the missing `allowedVaults` check for the `addStrategy` and `removeStrategy` functions. This is a significant access control issue, as it could allow unauthorized modifications to vault strategies, potentially leading to financial losses or operational disruptions. Access control mechanisms are essential for ensuring that only authorized entities can modify critical contract components.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-02] ERC20 return values not checked**  
- **[M-09] token -> vault mapping can be overwritten**  
- **[M-13] `manager.allowedVaults` check missing for add/remove strategy**

---

### **Overall Assessment**  
The `response_list` does not adequately address the issues raised in the `issue` report. Specifically, it misses critical vulnerabilities related to unchecked ERC20 return values, token-to-vault mapping overwrites, and missing access control checks for strategy management. These omissions represent significant gaps in the coverage, accuracy, and sufficiency of the responses. Addressing these issues is essential to ensure the security and integrity of the smart contract system.",0.0,0,3,6.0,35.0,"```
None.
```",0.0
,,,,,,,,8,5,,,0.0,0,14,23.0,149.0,,
