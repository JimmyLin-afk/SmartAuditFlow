nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Detecting aspects,matchList,MAP
MasterChef.sol,"// SPDX-License-Identifier: MIT


pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

contract MasterChef is Ownable, ReentrancyGuard {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    event Deposit(address indexed _user, uint indexed _pid, uint _amount);
    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);
    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);

    struct UserInfo {
        uint128 amount; // How many tokens the user has provided.
        uint128 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of RADSs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 depositToken; // Address of LP token contract.
        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.
        uint lastRewardBlock; // Last block number that distribution occurs.
        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.
        uint16 depositFeeBP; // Deposit fee in basis points
    }

    PoolInfo[] public poolInfo;
    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.
    mapping(address => bool) public isDepositor;
    mapping(address => uint256) public pid; // pid mapped to token
    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block
    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.
    uint public startBlock;
    uint public endBlock; // The block number when mining starts.
    IERC20 public concur;

    uint private _concurShareMultiplier = 1e18;
    uint private _perMille = 1000; // 100%

    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {
        startBlock = _startBlock;
        endBlock = _endBlock;
        concur = _concur;
        poolInfo.push(
            PoolInfo({
            depositToken: IERC20(address(0)),
            allocPoint : 0,
            lastRewardBlock : _startBlock,
            accConcurPerShare : 0,
            depositFeeBP : 0
        }));
    }

    modifier onlyDepositor() {
        require(isDepositor[msg.sender], ""!depositor"");
        _;
    }

    function addDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = true;
    }

    function removeDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = false;
    }

    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {
        require(_token != address(0), ""zero address"");
        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocationPoints);
        require(pid[_token] == 0, ""already registered""); // pid starts from 0
        poolInfo.push(
            PoolInfo({
                depositToken: IERC20(_token),
                allocPoint: _allocationPoints,
                lastRewardBlock: lastRewardBlock,
                accConcurPerShare: 0,
                depositFeeBP: _depositFee
            })
        );
        pid[_token] = poolInfo.length - 1;
    }

    function poolLength() external view returns (uint) {
        return poolInfo.length;
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint _from, uint _to) public pure returns (uint) {
        return _to.sub(_from);
    }

    // View function to see pending [concur] on frontend.
    function pendingConcur(uint _pid, address _user) external view returns (uint) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint accConcurPerShare = pool.accConcurPerShare;
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        }
        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
    }

    // Update reward variables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint length = poolInfo.length;
        for (uint _pid = 0; _pid < length; ++_pid) {
            updatePool(_pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (lpSupply == 0 || pool.allocPoint == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        if(block.number >= endBlock) {
            pool.lastRewardBlock = block.number;
            return;
        }        

        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        pool.lastRewardBlock = block.number;
    }

    // Deposit tokens for [concur] allocation.  
    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        updatePool(_pid);
       
        if(user.amount > 0) {  
            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
            if (pending > 0) {
                safeConcurTransfer(_recipient, pending);
            }
        }

        if (_amount > 0) {
            if (pool.depositFeeBP > 0) {
                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);
                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);
            } else {
                user.amount = SafeCast.toUint128(user.amount + _amount);
            }
        }     

        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Deposit(_recipient, _pid, _amount);
    }

    // Withdraw tokens
    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        require(user.amount > 0, ""MasterChef: nothing to withdraw"");
        require(user.amount >= _amount, ""MasterChef: withdraw not allowed"");
        updatePool(_pid);

        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
        if(pending > 0) {
            safeConcurTransfer(_recipient, pending);
        }
        if (_amount > 0) {
            user.amount = SafeCast.toUint128(user.amount - _amount);
        }
        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Withdraw(_recipient, _pid, _amount);
    }

    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough
    function safeConcurTransfer(address _to, uint _amount) private {
        uint concurBalance = concur.balanceOf(address(this));
        bool transferSuccess = false;
        if (_amount > concurBalance) {
            transferSuccess = concur.transfer(_to, concurBalance);
        } else {
            transferSuccess = concur.transfer(_to, _amount);
        }
        require(transferSuccess, ""safeConcurTransfer: transfer failed"");
    }
}",2020.0,331.0,"[H-01] Wrong reward token calculation in MasterChef contract
When adding new token pool for staking in MasterChef contract“function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock)”
All other, already added, pools should be updated but currently they are not.Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update.

[H-02] Masterchef: Improper handling of deposit fee
If a pool’s `deposit` function fee is non-zero, it is subtracted from the amount to be credited to the user.
However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).

[H-08] MasterChef.sol Users won't be able to receive the concur rewards
MasterChef is only recording the deposited amount in the states, it's not actually holding the `depositToken`.
`depositToken` won't be transferred from `_msgSender()` to the MasterChef contract.
Therefore, in `updatePool()` L140 `lpSupply = pool.depositToken.balanceOf(address(this))` will always be 0. And the updatePool() will be returned.

[H-09] deposit in ConvexStakingWrapper will most certainly revert
`convexPool[_pid]` is set to `IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;`

[M-02] Unconstrained fee
Token fee in MasterChef can be set to more than 100%, (for example, by accident) causing all `deposit` calls to fail due to underflow on subtraction when reward is lowered by the fee, thus breaking essential mechanics. Note that after the fee has been set to any value, it cannot be undone. A token cannot be removed, added, or added the second time. Thus, mistakenly (or deliberately, maliciously) added fee that is larger than 100% will make the contract impossible to recover from not being able to use the token.

[M-20] MasterChef.updatePool() Fails To Update Reward Variables If `block.number >= endBlock`
The `updatePool` function intends to calculate the accumulated Concur rewards by tracking the number of blocks passed since the last update to correctly determine how many Concur tokens to distribute to each share. The reward distribution has a start and end block which dictates the timeframe by which rewards will be distributed to the underlying pool.
If a pool has not recently updated itself and has reached the `block.number >= endBlock` statement in updatePool, then any rewards that it would normally be entitled to prior to reaching endBlock will not be attributed to the pool. Therefore, once rewards are no longer being distributed, pools who had not recently called updatePool before reaching endBlock are at a disadvantage as compared to more active pools.

[M-14] Owner can steal Concur rewards
Owner can steal Concur rewards by adding a depositor and inflating other depositors' assigned balance of the token within the contract. Thus, the owner-managed depositor can get most (all but one wei) of the created tokens.

[M-15] Owner can lock tokens in MasterChef
Owner can remove a depositor. Since only depositors can deposit and withdraw, the owner may add a contract to the whitelist, let users deposit in the contract and remove the depositor from the whitelist. Depositor's reward cannot be withdrawn then. And takes a share of Concur tokens that will not be distributed.

[M-16] Rewards get diluted because totalAllocPoint can only increase.
There is no functionality for removing pools/setting pool's allocPoints. Therefore totalAllocPoint only increases and rewards for pool decreases.",6.0,"// SPDX-License-Identifier: MIT


pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

contract MasterChef is Ownable, ReentrancyGuard {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    event Deposit(address indexed _user, uint indexed _pid, uint _amount);
    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);
    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);

    struct UserInfo {
        uint128 amount; // How many tokens the user has provided.
        uint128 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of RADSs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 depositToken; // Address of LP token contract.
        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.
        uint lastRewardBlock; // Last block number that distribution occurs.
        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.
        uint16 depositFeeBP; // Deposit fee in basis points
    }

    PoolInfo[] public poolInfo;
    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.
    mapping(address => bool) public isDepositor;
    mapping(address => uint256) public pid; // pid mapped to token
    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block
    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.
    uint public startBlock;
    uint public endBlock; // The block number when mining starts.
    IERC20 public concur;

    uint private _concurShareMultiplier = 1e18;
    uint private _perMille = 1000; // 100%

    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {
        startBlock = _startBlock;
        endBlock = _endBlock;
        concur = _concur;
        poolInfo.push(
            PoolInfo({
            depositToken: IERC20(address(0)),
            allocPoint : 0,
            lastRewardBlock : _startBlock,
            accConcurPerShare : 0,
            depositFeeBP : 0
        }));
    }

    modifier onlyDepositor() {
        require(isDepositor[msg.sender], ""!depositor"");
        _;
    }

    function addDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = true;
    }

    function removeDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = false;
    }

    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {
        require(_token != address(0), ""zero address"");
        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocationPoints);
        require(pid[_token] == 0, ""already registered""); // pid starts from 0
        poolInfo.push(
            PoolInfo({
                depositToken: IERC20(_token),
                allocPoint: _allocationPoints,
                lastRewardBlock: lastRewardBlock,
                accConcurPerShare: 0,
                depositFeeBP: _depositFee
            })
        );
        pid[_token] = poolInfo.length - 1;
    }

    function poolLength() external view returns (uint) {
        return poolInfo.length;
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint _from, uint _to) public pure returns (uint) {
        return _to.sub(_from);
    }

    // View function to see pending [concur] on frontend.
    function pendingConcur(uint _pid, address _user) external view returns (uint) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint accConcurPerShare = pool.accConcurPerShare;
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        }
        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
    }

    // Update reward variables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint length = poolInfo.length;
        for (uint _pid = 0; _pid < length; ++_pid) {
            updatePool(_pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (lpSupply == 0 || pool.allocPoint == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        if(block.number >= endBlock) {
            pool.lastRewardBlock = block.number;
            return;
        }        

        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        pool.lastRewardBlock = block.number;
    }

    // Deposit tokens for [concur] allocation.  
    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        updatePool(_pid);
       
        if(user.amount > 0) {  
            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
            if (pending > 0) {
                safeConcurTransfer(_recipient, pending);
            }
        }

        if (_amount > 0) {
            if (pool.depositFeeBP > 0) {
                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);
                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);
            } else {
                user.amount = SafeCast.toUint128(user.amount + _amount);
            }
        }     

        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Deposit(_recipient, _pid, _amount);
    }

    // Withdraw tokens
    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        require(user.amount > 0, ""MasterChef: nothing to withdraw"");
        require(user.amount >= _amount, ""MasterChef: withdraw not allowed"");
        updatePool(_pid);

        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
        if(pending > 0) {
            safeConcurTransfer(_recipient, pending);
        }
        if (_amount > 0) {
            user.amount = SafeCast.toUint128(user.amount - _amount);
        }
        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Withdraw(_recipient, _pid, _amount);
    }

    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough
    function safeConcurTransfer(address _to, uint _amount) private {
        uint concurBalance = concur.balanceOf(address(this));
        bool transferSuccess = false;
        if (_amount > concurBalance) {
            transferSuccess = concur.transfer(_to, concurBalance);
        } else {
            transferSuccess = concur.transfer(_to, _amount);
        }
        require(transferSuccess, ""safeConcurTransfer: transfer failed"");
    }
}",2020.0,4,5,"{
  ""Findings"": [
    {
      ""Issue"": ""Missing Access Control on Key Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Key functions such as `deposit`, `withdraw`, and pool management operations are correctly protected using modifiers like `onlyDepositor` and `onlyOwner`, ensuring only authorized roles can execute these functions."",
      ""Impact"": ""Without proper access control, unauthorized parties could alter pool configurations or manipulate deposits and withdrawals, leading to potential fund loss or unauthorized transactions."",
      ""Location"": ""Functions `deposit` (lines 133), `withdraw` (lines 159), `add` (line 76), `addDepositor` (line 65), `removeDepositor` (line 69)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring access control is crucial to prevent unauthorized access and maintain security integrity.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""Despite using `nonReentrant` from `ReentrancyGuard`, functions like `deposit` and `withdraw` could still be vulnerable due to external calls like `safeConcurTransfer`. All external calls should be secured to prevent reentrancy attacks."",
      ""Impact"": ""Reentrancy attacks could allow users to withdraw more funds than deposited, leading to financial loss."",
      ""Location"": ""Functions `deposit` (lines 110-135), `withdraw` (lines 137-154)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding highlights the need for secure handling of external calls to prevent reentrancy issues.""
    },
    {
      ""Issue"": ""Improper Handling of Token Transfers"",
      ""Severity"": ""High"",
      ""Description"": ""The `safeConcurTransfer` function checks balance and transfers available tokens without proper error handling, potentially leading to partial transfers and incorrect fund management."",
      ""Impact"": ""Could cause discrepancies in token distribution, leading to user dissatisfaction and financial inaccuracies."",
      ""Location"": ""Function `safeConcurTransfer` (lines 156-165)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Accurate handling of token transfers is crucial for maintaining correct accounting and user trust.""
    },
    {
      ""Issue"": ""Potential Arithmetic Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions `pendingConcur` and `updatePool` use subtraction without SafeMath, risking underflows if `rewardDebt` exceeds the calculated reward."",
      ""Impact"": ""Underflows could lead to incorrect reward calculations, causing users to receive incorrect reward amounts."",
      ""Location"": ""Functions `pendingConcur` (line 70), `updatePool` (line 94)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Identifying risks of arithmetic underflow aligns with ensuring safe arithmetic operations.""
    },
    {
      ""Issue"": ""Missing Proper Error Handling in External IERC20 Interactions"",
      ""Severity"": ""High"",
      ""Description"": ""The contract doesn't check the return value of `depositToken.transfer`, risking unexpected behavior if transfers fail."",
      ""Impact"": ""Unnoticed token transfer failures could lead to token loss or incorrect state updates."",
      ""Location"": ""Functions interacting with `depositToken` in `deposit` and `withdraw` functions."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Proper error handling is crucial to prevent unexpected behavior and ensure contract reliability.""
    },
    {
      ""Issue"": ""Inefficient Loop in `massUpdatePools` Function"",
      ""Severity"": ""High"",
      ""Description"": ""Iterating over all pools in `massUpdatePools` could consume excessive gas if many pools exist, risking transaction failures."",
      ""Impact"": ""High gas costs and transaction failures due to block gas limits."",
      ""Location"": ""Function `massUpdatePools` (lines 116-119)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Optimizing gas consumption in loops is essential for efficient contract operations.""
    }
  ],
  ""FindingNumber"": 6,
  ""AllRelevance"": 24,
  ""RelevanceCount"": 21,
  ""AllValidation"": 26,
  ""ValidationCount"": 22
}","### **Comparison of Issue Report and Response List**

---

#### **[H-01] Wrong reward token calculation in MasterChef contract**

**Report Description**:  
When adding a new token pool for staking in the MasterChef contract (`function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock)`), all other already added pools should be updated. However, only `totalPoints` is updated, causing old (and not updated) pools to lose their share during the next update.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect reward token calculation or the failure to update existing pools when adding a new pool. This is a critical oversight in the contract's reward distribution mechanism.

---

#### **[H-02] Masterchef: Improper handling of deposit fee**

**Report Description**:  
If a pool’s `deposit` function fee is non-zero, it is subtracted from the amount to be credited to the user. However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of improper handling of deposit fees, which results in permanent lockups of funds. This is a significant financial risk for users.

---

#### **[H-08] MasterChef.sol Users won't be able to receive the concur rewards**

**Report Description**:  
MasterChef only records the deposited amount in the states but does not actually hold the `depositToken`. `depositToken` is not transferred from `_msgSender()` to the MasterChef contract. Therefore, in `updatePool()` (L140), `lpSupply = pool.depositToken.balanceOf(address(this))` will always be `0`, causing `updatePool()` to return prematurely.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `depositToken` not being transferred to the contract, which prevents users from receiving rewards. This is a critical flaw in the contract's reward distribution mechanism.

---

#### **[H-09] deposit in ConvexStakingWrapper will most certainly revert**

**Report Description**:  
`convexPool[_pid]` is set to `IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;`. This setup may cause the `deposit` function in `ConvexStakingWrapper` to revert due to incorrect configuration or external contract interactions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of potential reverts in the `deposit` function due to incorrect external contract interactions. This is a critical issue that could prevent users from depositing funds.

---

#### **[M-02] Unconstrained fee**

**Report Description**:  
The token fee in MasterChef can be set to more than 100% (e.g., by accident), causing all `deposit` calls to fail due to underflow on subtraction when the reward is lowered by the fee. This breaks essential mechanics. Once set, the fee cannot be undone, and the contract cannot recover from this state.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unconstrained fees, which could render the contract unusable. This is a significant design flaw.

---

#### **[M-20] MasterChef.updatePool() Fails To Update Reward Variables If `block.number >= endBlock`**

**Report Description**:  
The `updatePool` function fails to update reward variables if `block.number >= endBlock`. Pools that have not recently called `updatePool` before reaching `endBlock` will not receive their entitled rewards, disadvantaging less active pools.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of reward distribution being halted for pools that reach `endBlock` without a recent update. This is a critical flaw in the reward distribution logic.

---

#### **[M-14] Owner can steal Concur rewards**

**Report Description**:  
The owner can steal Concur rewards by adding a depositor and inflating other depositors' assigned balance of the token within the contract. This allows the owner-managed depositor to get most (all but one wei) of the created tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of the owner being able to manipulate depositor balances to steal rewards. This is a significant security risk.

---

#### **[M-15] Owner can lock tokens in MasterChef**

**Report Description**:  
The owner can remove a depositor, preventing users from withdrawing their tokens. Since only depositors can deposit and withdraw, the owner may add a contract to the whitelist, let users deposit, and then remove the depositor, locking users' tokens and rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of the owner being able to lock users' tokens by removing depositors. This is a significant security risk.

---

#### **[M-16] Rewards get diluted because `totalAllocPoint` can only increase**

**Report Description**:  
There is no functionality for removing pools or setting a pool's `allocPoints`. Therefore, `totalAllocPoint` only increases, diluting rewards for existing pools over time.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of reward dilution due to the inability to remove pools or adjust `allocPoints`. This is a significant design flaw.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Wrong reward token calculation in MasterChef contract**  
- **[H-02] Masterchef: Improper handling of deposit fee**  
- **[H-08] MasterChef.sol Users won't be able to receive the concur rewards**  
- **[H-09] deposit in ConvexStakingWrapper will most certainly revert**  
- **[M-02] Unconstrained fee**  
- **[M-20] MasterChef.updatePool() Fails To Update Reward Variables If `block.number >= endBlock`**  
- **[M-14] Owner can steal Concur rewards**  
- **[M-15] Owner can lock tokens in MasterChef**  
- **[M-16] Rewards get diluted because `totalAllocPoint` can only increase**

---

### **Conclusion**  
The response list does not address any of the critical issues identified in the issue report. This indicates significant gaps in the coverage, accuracy, and sufficiency of the responses. The issues highlighted in the report are critical to the security and functionality of the MasterChef contract and must be addressed to ensure the contract operates as intended and securely.",0,0,9,6,24,"```
None.
```",0.0
Shelter.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IShelter } from ""./interfaces/IShelter.sol"";
import { IShelterClient } from ""./interfaces/IShelterClient.sol"";

contract Shelter is IShelter {
    using SafeERC20 for IERC20;

    IShelterClient public immutable client;

    uint256 public constant GRACE_PERIOD = 1 weeks;

    mapping(IERC20 => mapping(address => bool)) public override claimed;

    mapping(IERC20 => uint256) public activated;

    mapping(IERC20 => uint256) public savedTokens;

    modifier onlyClient {
        require(msg.sender == address(client), ""!client"");
        _;
    }

    constructor(IShelterClient _client){
        client = _client;
    }

    function donate(IERC20 _token, uint256 _amount) external {
        require(activated[_token] != 0, ""!activated"");
        savedTokens[_token] += _amount;
        _token.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function activate(IERC20 _token) external override onlyClient {
        activated[_token] = block.timestamp;
        savedTokens[_token] = _token.balanceOf(address(this));
        emit ShelterActivated(_token);
    }

    function deactivate(IERC20 _token) external override onlyClient {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, ""too late"");
        activated[_token] = 0;
        savedTokens[_token] = 0;
        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));
        emit ShelterDeactivated(_token);
    }

    function withdraw(IERC20 _token, address _to) external override {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, ""shelter not activated"");
        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);
        claimed[_token][_to] = true;
        emit ExitShelter(_token, msg.sender, _to, amount);
        _token.safeTransfer(_to, amount);
    }
}",511.0,59.0,"[H-03] Repeated Calls to `Shelter.withdraw` Can Drain All Funds in Shelter
Anyone who can call `withdraw` to withdraw their own funds can call it repeatedly to withdraw the funds of others. `withdraw` should only succeed if the user hasn't withdrawn the token already.
The shelter can be used for users to withdraw funds in the event of an emergency. The `withdraw` function allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However, withdraw does not check if a user has already withdrawn their tokens. Thus a user that can withdraw tokens, can call withdraw repeatedly to steal the tokens of others.

[H-07] Shelter `claimed` mapping is set with `_to` address and not `msg.sender`
Any user can `withdraw` all the funds from the shelter. This is done by calling withdraw repeatedly until all funds are drained. You only need to have a small share.
Even if the `claimed` mapping was checked, there would still be a vulnerability. This is because the `claimed` mapping is updated with the `_to` address, not the msg.sender address.

[M-01] Deposits after the grace period should not be allowed
The function `donate` in Shelter shouldn't allow new deposits after the grace period ends, when the claim period begins.Otherwise, it will be possible to increase `savedTokens[_token]`, and thus new user claim amounts will increase after some users might already have withdrawn their shares.

[M-07] Fee-on-transfer token donations in Shelter break withdrawals
The `Sheler.donate` function `transferFroms` `_amount` and adds the entire `_amount` to `savedTokens[_token]`.But the actual received token amount from the transfer can be less for fee-on-transfer tokens.
The last person to withdraw will not be able to as `withdraw` uses a share computation for the entire `savedTokens[_token]` amount.The calculated `amount` will then be higher than the actual contract balance.

[M-08] Donated Tokens Cannot Be Recovered If A Shelter Is Deactivated
The shelter mechanism can be activated and deactivated on a target LP token. The owner of the ConvexStakingWrapper.sol contract can initiate the shelter whereby LP tokens are sent to the Shelter.sol contract. However, if the owner decides to deactivate the shelter before the grace period has passed, all LP tokens are transferred back to the ConvexStakingWrapper.sol contract. Donated tokens are also sent back to the contract. As a result, these tokens do not actually belong to any user and will effectively be lost in the contract.",5.0,"pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IShelter } from ""./interfaces/IShelter.sol"";
import { IShelterClient } from ""./interfaces/IShelterClient.sol"";

contract Shelter is IShelter {
    using SafeERC20 for IERC20;

    IShelterClient public immutable client;

    uint256 public constant GRACE_PERIOD = 1 weeks;

    mapping(IERC20 => mapping(address => bool)) public override claimed;

    mapping(IERC20 => uint256) public activated;

    mapping(IERC20 => uint256) public savedTokens;

    modifier onlyClient {
        require(msg.sender == address(client), ""!client"");
        _;
    }

    constructor(IShelterClient _client){
        client = _client;
    }

    function donate(IERC20 _token, uint256 _amount) external {
        require(activated[_token] != 0, ""!activated"");
        savedTokens[_token] += _amount;
        _token.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function activate(IERC20 _token) external override onlyClient {
        activated[_token] = block.timestamp;
        savedTokens[_token] = _token.balanceOf(address(this));
        emit ShelterActivated(_token);
    }

    function deactivate(IERC20 _token) external override onlyClient {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, ""too late"");
        activated[_token] = 0;
        savedTokens[_token] = 0;
        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));
        emit ShelterDeactivated(_token);
    }

    function withdraw(IERC20 _token, address _to) external override {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, ""shelter not activated"");
        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);
        claimed[_token][_to] = true;
        emit ExitShelter(_token, msg.sender, _to, amount);
        _token.safeTransfer(_to, amount);
    }
}",504.0,2,3,"{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in `withdraw` Function"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `withdraw` function transfers tokens before updating the `claimed` mapping, exposing it to reentrancy attacks. This can allow attackers to repeatedly call the `withdraw` function and drain the contract of its funds."",
      ""Impact"": ""Potential for significant fund loss due to repeated unauthorized withdrawals."",
      ""Location"": ""Function `withdraw`, lines 46-50"",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Unchecked Client Permissions"",
      ""Severity"": ""High"",
      ""Description"": ""The contract relies on the `client` contract for share calculations and permissions without verifying if `client` implements appropriate logic. This could lead to improper share distributions or unauthorized access if the `client` contract is not secure or properly implemented."",
      ""Impact"": ""Potential for incorrect share calculations, unauthorized withdrawals, or other unintended behaviors."",
      ""Location"": ""Functions `withdraw` (lines 53-59) and `activate` (lines 36-39)"",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Arithmetic Operations Lack Overflow/Underflow Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The share calculation in the `withdraw` function involves arithmetic operations without safe math libraries, making them vulnerable to overflow and underflow issues."",
      ""Impact"": ""Incorrect token distribution, potentially allowing a user to withdraw more or less than their fair share."",
      ""Location"": ""Function `withdraw`, line 47"",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Grace Period Logic Vulnerabilities"",
      ""Severity"": ""Medium"",
      ""Description"": ""The grace period logic in `deactivate` is flawed, potentially leading to unintended token locking or administrative difficulties due to hardcoded and improper checks."",
      ""Impact"": ""Funds may become inaccessible or tokens may not be deactivated as intended."",
      ""Location"": ""Function `deactivate` (lines 30-36)"",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Lack of Event Emission on Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical state changes, such as updating `savedTokens` and `claimed`, do not emit events. This limits transparency and traceability of important actions within the contract."",
      ""Impact"": ""Challenges in tracking and auditing critical state changes, potentially leading to accountability issues."",
      ""Location"": ""Functions `donate` and `withdraw` at lines 23 and 45"",
      ""Relevance"": true,
      ""Validation"": true
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 19,
  ""RelevanceCount"": 19,
  ""AllValidation"": 19,
  ""ValidationCount"": 19
}","### **Comparison of Issue Report and Response List**

---

#### **[H-03] Repeated Calls to `Shelter.withdraw` Can Drain All Funds in Shelter**

**Report Description**:  
The `withdraw` function allows users to repeatedly call it to withdraw funds, even if they have already withdrawn their tokens. This can lead to draining all funds in the shelter, as the function does not check if a user has already withdrawn their tokens. This vulnerability can be exploited to steal tokens from other users.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in `withdraw` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of repeated withdrawals and fund draining, which aligns with the issue. However, the response focuses on reentrancy as the root cause, while the issue report highlights the lack of a check for prior withdrawals. The proposed solution in the response (reentrancy protection) does not fully address the core issue of missing withdrawal checks.

---

#### **[H-07] Shelter `claimed` Mapping is Set with `_to` Address and Not `msg.sender`**

**Report Description**:  
The `claimed` mapping is updated with the `_to` address instead of `msg.sender`. This allows any user to withdraw funds repeatedly, even if the `claimed` mapping is checked, because the mapping is not tied to the caller's address (`msg.sender`). This vulnerability can lead to draining all funds in the shelter.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The core problem of updating the `claimed` mapping with the wrong address (`_to` instead of `msg.sender`) is not covered.

---

#### **[M-01] Deposits after the Grace Period Should Not Be Allowed**

**Report Description**:  
The `donate` function allows new deposits after the grace period ends, which can increase `savedTokens[_token]` and lead to incorrect claim amounts for users who have already withdrawn their shares. This can result in unfair distributions and potential exploitation.

**Match in Response List**:  
Matches with the issue titled **""Grace Period Logic Vulnerabilities""**.

**Validation**:  
**Correct**. The response identifies flaws in the grace period logic, which aligns with the issue. The response correctly highlights the potential for unintended token locking or administrative difficulties, which covers the issue of allowing deposits after the grace period.

---

#### **[M-07] Fee-on-Transfer Token Donations in Shelter Break Withdrawals**

**Report Description**:  
The `Shelter.donate` function adds the entire `_amount` to `savedTokens[_token]` without accounting for fee-on-transfer tokens, where the actual received amount may be less. This discrepancy can lead to incorrect share calculations, and the last user to withdraw may not receive their full share due to insufficient contract balance.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem of fee-on-transfer tokens breaking withdrawals is not covered.

---

#### **[M-08] Donated Tokens Cannot Be Recovered If a Shelter Is Deactivated**

**Report Description**:  
If the shelter is deactivated before the grace period ends, donated tokens are sent back to the `ConvexStakingWrapper.sol` contract. These tokens do not belong to any user and are effectively lost, as they cannot be recovered.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem of donated tokens being lost upon deactivation is not covered.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
 - **[H-03] Repeated Calls to `Shelter.withdraw` Can Drain All Funds in Shelter**
- **[M-01] Deposits after the Grace Period Should Not Be Allowed**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-07] Shelter `claimed` Mapping is Set with `_to` Address and Not `msg.sender`**
- **[M-07] Fee-on-Transfer Token Donations in Shelter Break Withdrawals**
- **[M-08] Donated Tokens Cannot Be Recovered If a Shelter Is Deactivated**

---

### **Overall Assessment**

The response list covers some issues but misses critical vulnerabilities, such as the incorrect `claimed` mapping update, fee-on-transfer token handling, and the loss of donated tokens upon deactivation. Additionally, the response for the repeated withdrawals issue partially addresses the problem but misidentifies the root cause. Improvements are needed to ensure comprehensive coverage of all vulnerabilities.",2,0,3,5,19,"```
1. Reentrancy Vulnerability in `withdraw` Function 2. Grace Period Logic Vulnerabilities
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Reentrancy Vulnerability in `withdraw` Function"" appears at rank 1.
   - ""Grace Period Logic Vulnerabilities"" appears at rank 4.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 4: \( P@4 = \frac{2}{4} = 0.5 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 0.5}{2} = 0.75 \)

**Output**:
```
0.75
```"
ConverxStakingWrapper.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""./external/ConvexInterfaces.sol"";
import ""./interfaces/IConcurRewardClaim.sol"";
import ""./MasterChef.sol"";

contract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    struct RewardType {
        address token;
        address pool;
        uint128 integral;
        uint128 remaining;
    }

    struct Reward {
        uint128 integral;
    }

    //constants/immutables
    address public constant convexBooster =
        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv =
        address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx =
        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);

    uint256 public constant CRV_INDEX = 0;
    uint256 public constant CVX_INDEX = 1;
    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000
    MasterChef public immutable masterChef;

    //convex rewards
    mapping(uint256 => address) public convexPool;
    mapping(uint256 => RewardType[]) public rewards;
    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))
        public userReward;
    mapping(uint256 => mapping(address => uint256)) public registeredRewards;

    //management
    address public treasury;
    IConcurRewardClaim public claimContract;

    struct Deposit {
        uint64 epoch;
        uint192 amount;
    }

    struct WithdrawRequest {
        uint64 epoch;
        uint192 amount;
    }

    mapping(address => uint256) public pids;
    mapping(uint256 => mapping(address => Deposit)) public deposits;
    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;

    event Deposited(address indexed _user, uint256 _amount);
    event Withdrawn(address indexed _user, uint256 _amount);

    constructor(address _treasury, MasterChef _masterChef) {
        treasury = _treasury;
        masterChef = _masterChef;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function changeTreasury(address _treasury) external onlyOwner {
        treasury = _treasury;
    }

    function setRewardPool(address _claimContract) external onlyOwner {
        claimContract = IConcurRewardClaim(_claimContract);
    }

    /// @notice function to bootstrap the reward pool and extra rewards of convex booster
    /// @dev should be able to be called more than once
    /// @param _pid pid of the curve lp. same as convex booster pid
    function addRewards(uint256 _pid) public {
        address mainPool = IRewardStaking(convexBooster)
            .poolInfo(_pid)
            .crvRewards;
        if (rewards[_pid].length == 0) {
            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;
            convexPool[_pid] = mainPool;
            rewards[_pid].push(
                RewardType({
                    token: crv,
                    pool: mainPool,
                    integral: 0,
                    remaining: 0
                })
            );
            rewards[_pid].push(
                RewardType({
                    token: cvx,
                    pool: address(0),
                    integral: 0,
                    remaining: 0
                })
            );
            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1
            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        for (uint256 i = 0; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            address extraToken = IRewardStaking(extraPool).rewardToken();
            if (extraToken == cvx) {
                //no-op for cvx, crv rewards
                rewards[_pid][CVX_INDEX].pool = extraPool;
            } else if (registeredRewards[_pid][extraToken] == 0) {
                //add new token to list
                rewards[_pid].push(
                    RewardType({
                        token: IRewardStaking(extraPool).rewardToken(),
                        pool: extraPool,
                        integral: 0,
                        remaining: 0
                    })
                );
                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1
            }
        }
    }

    function rewardLength(uint256 _pid) external view returns (uint256) {
        return rewards[_pid].length;
    }

    function _getDepositedBalance(uint256 _pid, address _account)
        internal
        view
        virtual
        returns (uint256)
    {
        return deposits[_pid][_account].amount;
    }

    function _getTotalSupply(uint256 _pid)
        internal
        view
        virtual
        returns (uint256)
    {
        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));
    }

    function _calcRewardIntegral(
        uint256 _pid,
        uint256 _index,
        address _account,
        uint256 _balance,
        uint256 _supply
    ) internal {
        RewardType memory reward = rewards[_pid][_index];

        //get difference in balance and remaining rewards
        //getReward is unguarded so we use remaining to keep track of how much was actually claimed
        uint256 bal = IERC20(reward.token).balanceOf(address(this));
        uint256 d_reward = bal - reward.remaining;
        // send 20 % of cvx / crv reward to treasury
        if (reward.token == cvx || reward.token == crv) {
            IERC20(reward.token).transfer(treasury, d_reward / 5);
            d_reward = (d_reward * 4) / 5;
        }
        IERC20(reward.token).transfer(address(claimContract), d_reward);

        if (_supply > 0 && d_reward > 0) {
            reward.integral =
                reward.integral +
                uint128((d_reward * 1e20) / _supply);
        }

        //update user integrals
        uint256 userI = userReward[_pid][_index][_account].integral;
        if (userI < reward.integral) {
            userReward[_pid][_index][_account].integral = reward.integral;
            claimContract.pushReward(
                _account,
                reward.token,
                (_balance * (reward.integral - userI)) / 1e20
            );
        }

        //update remaining reward here since balance could have changed if claiming
        if (bal != reward.remaining) {
            reward.remaining = uint128(bal);
        }

        rewards[_pid][_index] = reward;
    }

    function _checkpoint(uint256 _pid, address _account) internal {
        //if shutdown, no longer checkpoint in case there are problems
        if (paused()) return;

        uint256 supply = _getTotalSupply(_pid);
        uint256 depositedBalance = _getDepositedBalance(_pid, _account);

        IRewardStaking(convexPool[_pid]).getReward(address(this), true);

        uint256 rewardCount = rewards[_pid].length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);
        }
    }

    /// @notice deposit curve lp token
    /// @dev should approve curve lp token to this address before calling this function
    /// @param _pid pid to deposit, uses same pid as convex booster
    /// @param _amount amount to withdraw
    function deposit(uint256 _pid, uint256 _amount)
        external
        whenNotPaused
        nonReentrant
    {
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].epoch = currentEpoch();
        deposits[_pid][msg.sender].amount += uint192(_amount);
        if (_amount > 0) {
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );

            lpToken.safeTransferFrom(msg.sender, address(this), _amount);
            lpToken.safeApprove(convexBooster, _amount);
            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);
            lpToken.safeApprove(convexBooster, 0);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.deposit(msg.sender, pid, _amount);
        }

        emit Deposited(msg.sender, _amount);
    }

    /// @notice withdraw curve lp token
    /// @dev should request withdraw before calling this function
    /// @param _pid pid to withdraw, uses same pid as convex booster
    /// @param _amount amount to withdraw
    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {
        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];
        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), ""wait"");
        require(request.amount >= _amount, ""too much"");
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].amount -= uint192(_amount);
        if (_amount > 0) {
            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );
            lpToken.safeTransfer(msg.sender, _amount);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.withdraw(msg.sender, pid, _amount);
        }
        delete withdrawRequest[_pid][msg.sender];
        //events
        emit Withdrawn(msg.sender, _amount);
    }

    /// @notice epoch for voting cycle
    /// @return returns the epoch in uint64 type
    function currentEpoch() public view returns(uint64) {
        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;
    }

    /// @notice request withdraw to be eligible for withdrawal after currentEpoch
    /// @dev prior withdrawal request will be overwritten
    /// @param _pid pid to withdraw
    /// @param _amount amount to request withdrawal
    function requestWithdraw(uint256 _pid, uint256 _amount) external {
        require(_amount <= uint256(deposits[_pid][msg.sender].amount), ""too much"");
        withdrawRequest[_pid][msg.sender] = WithdrawRequest({
            epoch : currentEpoch(),
            amount : uint192(_amount)
        });
    }
}",2477.0,293.0,"[H-04] ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver
ConvexStakingWrapper is using `masterChef.deposit()`, `masterChef.withdraw()`, and these two functions on masterChef will take `_msgSender()` as the user address, which is actually the address of ConvexStakingWrapper and StakingRewards.

[H-06] ConvexStakingWrapper.sol#`_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution
In the function `_calcRewardIntegral()`

[H-10] `ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing
The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. Conversely, the exitShelter function will deactivate the shelter and transfer all LP tokens back to the ConvexStakingWrapper.sol contract.
Unfortunately, LP tokens aren't restaked in the pool, causing LP tokens to be stuck within the contract. Users will be unable to withdraw their LP tokens as the withdraw function attempts to withdrawAndUnwrap LP tokens from the staking pool. As a result, this function will always revert due to insufficient staked balance. If other users decide to deposit their LP tokens, then these tokens can be swiped by users who have had their LP tokens locked in the contract.

[H-11] `ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools
The ConvexStakingWrapper.sol implementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique _pid. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.
However, the interdependence between pools introduces new problems. Because the original implementation uses the contract's reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguarded getReward function to maximise the profit they are able to generate. By calling getReward on multiple pools with the same reward token (i.e. cvx), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. As crv and cvx are reward tokens by default, it is very likely that someone will want to exploit this issue.

[M-11] ConvexStakingWrapper.enterShelter() May Erroneously Overwrite amountInShelter Leading To Locked Tokens
The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. If this function is called again on the same LP token, the amountInShelter value is overwritten, potentially by the zero amount. As a result its possible that the shelter is put in a state where no users can withdraw from it or only a select few users with a finite number of shares are able to. Once the shelter has passed its grace period, these tokens may forever be locked in the shelter contract.",8.0,"pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""./external/ConvexInterfaces.sol"";
import ""./interfaces/IConcurRewardClaim.sol"";
import ""./MasterChef.sol"";

contract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    struct RewardType {
        address token;
        address pool;
        uint128 integral;
        uint128 remaining;
    }

    struct Reward {
        uint128 integral;
    }

    
    address public constant convexBooster =
        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv =
        address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx =
        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);

    uint256 public constant CRV_INDEX = 0;
    uint256 public constant CVX_INDEX = 1;
    uint256 public constant VOTECYCLE_START = 1645002000; 
    MasterChef public immutable masterChef;

    
    mapping(uint256 => address) public convexPool;
    mapping(uint256 => RewardType[]) public rewards;
    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))
        public userReward;
    mapping(uint256 => mapping(address => uint256)) public registeredRewards;

    
    address public treasury;
    IConcurRewardClaim public claimContract;

    struct Deposit {
        uint64 epoch;
        uint192 amount;
    }

    struct WithdrawRequest {
        uint64 epoch;
        uint192 amount;
    }

    mapping(address => uint256) public pids;
    mapping(uint256 => mapping(address => Deposit)) public deposits;
    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;

    event Deposited(address indexed _user, uint256 _amount);
    event Withdrawn(address indexed _user, uint256 _amount);

    constructor(address _treasury, MasterChef _masterChef) {
        treasury = _treasury;
        masterChef = _masterChef;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function changeTreasury(address _treasury) external onlyOwner {
        treasury = _treasury;
    }

    function setRewardPool(address _claimContract) external onlyOwner {
        claimContract = IConcurRewardClaim(_claimContract);
    }

    
    
    
    function addRewards(uint256 _pid) public {
        address mainPool = IRewardStaking(convexBooster)
            .poolInfo(_pid)
            .crvRewards;
        if (rewards[_pid].length == 0) {
            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;
            convexPool[_pid] = mainPool;
            rewards[_pid].push(
                RewardType({
                    token: crv,
                    pool: mainPool,
                    integral: 0,
                    remaining: 0
                })
            );
            rewards[_pid].push(
                RewardType({
                    token: cvx,
                    pool: address(0),
                    integral: 0,
                    remaining: 0
                })
            );
            registeredRewards[_pid][crv] = CRV_INDEX + 1; 
            registeredRewards[_pid][cvx] = CVX_INDEX + 1; 
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        for (uint256 i = 0; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            address extraToken = IRewardStaking(extraPool).rewardToken();
            if (extraToken == cvx) {
                
                rewards[_pid][CVX_INDEX].pool = extraPool;
            } else if (registeredRewards[_pid][extraToken] == 0) {
                
                rewards[_pid].push(
                    RewardType({
                        token: IRewardStaking(extraPool).rewardToken(),
                        pool: extraPool,
                        integral: 0,
                        remaining: 0
                    })
                );
                registeredRewards[_pid][extraToken] = rewards[_pid].length; 
            }
        }
    }

    function rewardLength(uint256 _pid) external view returns (uint256) {
        return rewards[_pid].length;
    }

    function _getDepositedBalance(uint256 _pid, address _account)
        internal
        view
        virtual
        returns (uint256)
    {
        return deposits[_pid][_account].amount;
    }

    function _getTotalSupply(uint256 _pid)
        internal
        view
        virtual
        returns (uint256)
    {
        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));
    }

    function _calcRewardIntegral(
        uint256 _pid,
        uint256 _index,
        address _account,
        uint256 _balance,
        uint256 _supply
    ) internal {
        RewardType memory reward = rewards[_pid][_index];

        
        
        uint256 bal = IERC20(reward.token).balanceOf(address(this));
        uint256 d_reward = bal - reward.remaining;
        
        if (reward.token == cvx || reward.token == crv) {
            IERC20(reward.token).transfer(treasury, d_reward / 5);
            d_reward = (d_reward * 4) / 5;
        }
        IERC20(reward.token).transfer(address(claimContract), d_reward);

        if (_supply > 0 && d_reward > 0) {
            reward.integral =
                reward.integral +
                uint128((d_reward * 1e20) / _supply);
        }

        
        uint256 userI = userReward[_pid][_index][_account].integral;
        if (userI < reward.integral) {
            userReward[_pid][_index][_account].integral = reward.integral;
            claimContract.pushReward(
                _account,
                reward.token,
                (_balance * (reward.integral - userI)) / 1e20
            );
        }

        
        if (bal != reward.remaining) {
            reward.remaining = uint128(bal);
        }

        rewards[_pid][_index] = reward;
    }

    function _checkpoint(uint256 _pid, address _account) internal {
        
        if (paused()) return;

        uint256 supply = _getTotalSupply(_pid);
        uint256 depositedBalance = _getDepositedBalance(_pid, _account);

        IRewardStaking(convexPool[_pid]).getReward(address(this), true);

        uint256 rewardCount = rewards[_pid].length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);
        }
    }

    
    
    
    
    function deposit(uint256 _pid, uint256 _amount)
        external
        whenNotPaused
        nonReentrant
    {
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].epoch = currentEpoch();
        deposits[_pid][msg.sender].amount += uint192(_amount);
        if (_amount > 0) {
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );

            lpToken.safeTransferFrom(msg.sender, address(this), _amount);
            lpToken.safeApprove(convexBooster, _amount);
            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);
            lpToken.safeApprove(convexBooster, 0);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.deposit(msg.sender, pid, _amount);
        }

        emit Deposited(msg.sender, _amount);
    }

    
    
    
    
    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {
        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];
        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), ""wait"");
        require(request.amount >= _amount, ""too much"");
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].amount -= uint192(_amount);
        if (_amount > 0) {
            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );
            lpToken.safeTransfer(msg.sender, _amount);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.withdraw(msg.sender, pid, _amount);
        }
        delete withdrawRequest[_pid][msg.sender];
        
        emit Withdrawn(msg.sender, _amount);
    }

    
    
    function currentEpoch() public view returns(uint64) {
        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;
    }

    
    
    
    
    function requestWithdraw(uint256 _pid, uint256 _amount) external {
        require(_amount <= uint256(deposits[_pid][msg.sender].amount), ""too much"");
        withdrawRequest[_pid][msg.sender] = WithdrawRequest({
            epoch : currentEpoch(),
            amount : uint192(_amount)
        });
    }
}",2107.0,4,1,"{
  ""Findings"": [
    {
      ""Issue"": ""Improper Access Control on Functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""State-changing functions such as `pause`, `unpause`, `changeTreasury`, `setRewardPool`, `enterShelter`, and `exitShelter` lack proper access control, allowing unauthorized users to manipulate contract states and funds."",
      ""Impact"": ""Unauthorized users could pause or unpause the contract, change treasury addresses, or set incorrect reward pools, leading to loss of control and potential financial loss."",
      ""Location"": ""Functions `pause`, `unpause`, `changeTreasury`, `setRewardPool`, `enterShelter`, `exitShelter`."",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `withdraw` and `_checkpoint` make external calls without adequate reentrancy protection, potentially allowing reentrancy attacks that could drain funds or manipulate balances."",
      ""Impact"": ""Reentrancy attacks could exploit these functions to withdraw more funds than entitled, leading to significant financial loss."",
      ""Location"": ""Functions `withdraw`, `_checkpoint`."",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Incorrect Reward Integral Calculation"",
      ""Severity"": ""High"",
      ""Description"": ""The `_calcRewardIntegral` function's reward calculation may not account for unexpected balance changes, leading to incorrect reward distributions."",
      ""Impact"": ""Users may receive incorrect reward amounts, resulting in financial discrepancies."",
      ""Location"": ""Function `_calcRewardIntegral`."",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Improper Handling of External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""External calls, including those to `IRewardStaking` and `IERC20`, lack proper error handling, increasing the risk of unexpected behaviors or loss of funds."",
      ""Impact"": ""Failures in external contracts may lead to incorrect state or financial loss."",
      ""Location"": ""Functions like `enterShelter` and `exitShelter`."",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Potential Misconfiguration Risks"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `changeTreasury` can be misconfigured to point to unintended addresses, affecting fund management."",
      ""Impact"": ""Misconfigured addresses could lead to financial loss by redirecting funds."",
      ""Location"": ""Function `changeTreasury`."",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Lack of Event Emission on Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions such as `changeTreasury`, `setRewardPool`, `enterShelter`, and `exitShelter` do not emit events, reducing transparency."",
      ""Impact"": ""Hinders auditing and tracking of state changes."",
      ""Location"": ""Functions `changeTreasury`, `setRewardPool`, `enterShelter`, `exitShelter`."",
      ""Relevance"": true,
      ""Validation"": true
    }
  ],
  ""FindingNumber"": 6,
  ""AllRelevance"": 24,
  ""RelevanceCount"": 24,
  ""AllValidation"": 24,
  ""ValidationCount"": 24
}","### **Comparison of Issue Report and Response List**

---

#### **[H-04] ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver**

**Report Description**:  
The `ConvexStakingWrapper` uses `masterChef.deposit()` and `masterChef.withdraw()`, which take `_msgSender()` as the user address. However, `_msgSender()` returns the address of `ConvexStakingWrapper` and `StakingRewards`, not the actual user. This misimplementation causes rewards to be sent to the wrong receiver, leading to incorrect reward distribution.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect reward distribution due to the misuse of `_msgSender()` in `masterChef` functions. This is a critical oversight, as it directly impacts reward allocation.

---

#### **[H-06] ConvexStakingWrapper.sol#`_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution**

**Report Description**:  
The `_calcRewardIntegral()` function has a flawed implementation that can disrupt reward calculations and distributions. This could lead to incorrect reward allocations, causing financial discrepancies for users.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Reward Integral Calculation""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `_calcRewardIntegral` function, highlighting the potential for incorrect reward distributions. This aligns with the reported vulnerability.

---

#### **[H-10] `ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing**

**Report Description**:  
The `exitShelter` function does not restake LP tokens back into the pool, causing them to be stuck in the contract. This prevents users from withdrawing their LP tokens, as the `withdraw` function attempts to `withdrawAndUnwrap` LP tokens from the staking pool, which will revert due to insufficient staked balance. If other users deposit LP tokens, these tokens can be swiped by users whose LP tokens are locked.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of LP tokens being locked in the contract due to the flawed `exitShelter` implementation. This is a significant oversight, as it directly impacts user withdrawals and fund security.

---

#### **[H-11] `ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools**

**Report Description**:  
The `ConvexStakingWrapper.sol` implementation allows multiple pools to be added, each represented by a unique `_pid`. However, the interdependence between pools introduces vulnerabilities. A malicious user can abuse the unguarded `getReward` function to siphon rewards from other pools, leading to loss of rewards for users in victim pools.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of reward token manipulation across interdependent pools. This is a critical vulnerability, as it allows malicious users to exploit the system for financial gain.

---

#### **[M-11] ConvexStakingWrapper.enterShelter() May Erroneously Overwrite `amountInShelter` Leading To Locked Tokens**

**Report Description**:  
The `enterShelter` function withdraws LP tokens from the pool and transfers them to the shelter contract. If called again on the same LP token, the `amountInShelter` value may be overwritten, potentially by a zero amount. This could lock tokens in the shelter contract, preventing users from withdrawing them.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `amountInShelter` being erroneously overwritten, which could lead to locked tokens. This is a significant oversight, as it directly impacts user fund accessibility.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-06] ConvexStakingWrapper.sol#`_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-04] ConvexStakingWrapper, StakingRewards Wrong implementation will send concur rewards to the wrong receiver**
- **[H-10] `ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing**
- **[H-11] `ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools**
- **[M-11] ConvexStakingWrapper.enterShelter() May Erroneously Overwrite `amountInShelter` Leading To Locked Tokens**

---

### **Conclusion**

The response list partially addresses the issues in the issue report, with only one correct match out of five. Several critical vulnerabilities, such as incorrect reward distribution, locked LP tokens, and reward token manipulation, are entirely missed. The response list should be expanded to cover these gaps to ensure comprehensive security coverage.",1,2,2,6,24,"```
1. Incorrect Reward Integral Calculation
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Reward Integral Calculation"".
   - In the ranked list of predictions, this issue appears at **rank 3**.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Here, there is **1 true positive** up to rank 3.
   - \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.333 \).

**Output**:
```
0.333
```"
StakingRewards.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./MasterChef.sol"";

contract StakingRewards is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    MasterChef public immutable masterChef;

    /* ========== STATE VARIABLES ========== */

    IERC20 public rewardsToken;
    IERC20 public stakingToken;
    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public rewardsDuration = 7 days;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;

    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    address public rewardsDistribution;

    /* ========== CONSTRUCTOR ========== */

    constructor(
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken,
        MasterChef _masterChef
    ) {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
        masterChef = _masterChef;
    }

    /* ========== VIEWS ========== */

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored +
            (((lastTimeRewardApplicable() - lastUpdateTime) *
                rewardRate *
                1e18) / _totalSupply);
    }

    function earned(address account) public view returns (uint256) {
        return
            (_balances[account] *
                (rewardPerToken() - userRewardPerTokenPaid[account])) /
            1e18 +
            rewards[account];
    }

    function getRewardForDuration() external view returns (uint256) {
        return rewardRate * rewardsDuration;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function stake(uint256 amount)
        external
        nonReentrant
        whenNotPaused
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot stake 0"");
        _totalSupply += amount;
        _balances[msg.sender] += amount;
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.deposit(msg.sender, pid, amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount)
        public
        nonReentrant
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot withdraw 0"");
        _totalSupply -= amount;
        _balances[msg.sender] -= amount;
        stakingToken.safeTransfer(msg.sender, amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.withdraw(msg.sender, pid, amount);
        emit Withdrawn(msg.sender, amount);
    }

    function getReward() public nonReentrant updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function exit() external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function notifyRewardAmount(uint256 reward)
        external
        updateReward(address(0))
    {
        require(
            msg.sender == rewardsDistribution,
            ""Caller is not RewardsDistribution contract""
        );

        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint256 balance = rewardsToken.balanceOf(address(this));
        require(
            rewardRate <= balance / rewardsDuration,
            ""Provided reward too high""
        );

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address tokenAddress, uint256 tokenAmount)
        external
        onlyOwner
    {
        require(
            tokenAddress != address(stakingToken),
            ""Cannot withdraw the staking token""
        );
        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }

    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }

    function setRewardsDistribution(address _rewardsDistribution)
        external
        onlyOwner
    {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDistribution = _rewardsDistribution;
        emit RewardsDistributionUpdated(rewardsDistribution);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    /* ========== EVENTS ========== */

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event RewardsDistributionUpdated(address indexed newDistribution);
    event Recovered(address token, uint256 amount);
}",1501.0,220.0,"[H-04] StakingRewards Wrong implementation will send concur rewards to the wrong receiver
StakingRewards is using `masterChef.deposit()`, `masterChef.withdraw()`, and these two functions on masterChef will take `_msgSender()` as the user address, which is actually the address of ConvexStakingWrapper and StakingRewards.

[M-06] StakingRewards.sol `recoverERC20()` can be used as a backdoor by the owner to retrieve `rewardsToken`
Users can lose all the rewards to the malicious/compromised owner.

[M-09] StakingRewards.sol#`notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards
In the current implementation, the contract only checks if balanceOf `rewardsToken` is greater than or equal to the future rewards.
However, under normal circumstances, since users can not withdraw all their rewards in time, the balance in the contract contains rewards that belong to the users but have not been withdrawn yet. This means the current checks can not be sufficient enough to make sure the contract has enough amount of rewardsToken.
As a result, if the `rewardsDistribution` mistakenly `notifyRewardAmount` with a larger amount, the contract may end up in a wrong state that makes some users unable to claim their rewards.

[M-13] `StakingRewards.recoverERC20` allows owner to rug the `rewardsToken`
StakingRewards.recoverERC20 rightfully checks against the stakingToken being sweeped away.However, there's no check against the rewardsToken which over time will sit in this contract.
This is the case of an admin privilege, which allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors.
Calling `StakingRewards.recoverERC20(rewardsToken, rewardsToken.balanceOf(this))` enables the owner to sweep the token.",4.0,"pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./MasterChef.sol"";

contract StakingRewards is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    MasterChef public immutable masterChef;

    

    IERC20 public rewardsToken;
    IERC20 public stakingToken;
    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public rewardsDuration = 7 days;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;

    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    address public rewardsDistribution;

    

    constructor(
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken,
        MasterChef _masterChef
    ) {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
        masterChef = _masterChef;
    }

    

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored +
            (((lastTimeRewardApplicable() - lastUpdateTime) *
                rewardRate *
                1e18) / _totalSupply);
    }

    function earned(address account) public view returns (uint256) {
        return
            (_balances[account] *
                (rewardPerToken() - userRewardPerTokenPaid[account])) /
            1e18 +
            rewards[account];
    }

    function getRewardForDuration() external view returns (uint256) {
        return rewardRate * rewardsDuration;
    }

    

    function stake(uint256 amount)
        external
        nonReentrant
        whenNotPaused
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot stake 0"");
        _totalSupply += amount;
        _balances[msg.sender] += amount;
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.deposit(msg.sender, pid, amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount)
        public
        nonReentrant
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot withdraw 0"");
        _totalSupply -= amount;
        _balances[msg.sender] -= amount;
        stakingToken.safeTransfer(msg.sender, amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.withdraw(msg.sender, pid, amount);
        emit Withdrawn(msg.sender, amount);
    }

    function getReward() public nonReentrant updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function exit() external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    

    function notifyRewardAmount(uint256 reward)
        external
        updateReward(address(0))
    {
        require(
            msg.sender == rewardsDistribution,
            ""Caller is not RewardsDistribution contract""
        );

        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }

        
        
        
        
        uint256 balance = rewardsToken.balanceOf(address(this));
        require(
            rewardRate <= balance / rewardsDuration,
            ""Provided reward too high""
        );

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }

    
    function recoverERC20(address tokenAddress, uint256 tokenAmount)
        external
        onlyOwner
    {
        require(
            tokenAddress != address(stakingToken),
            ""Cannot withdraw the staking token""
        );
        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }

    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }

    function setRewardsDistribution(address _rewardsDistribution)
        external
        onlyOwner
    {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDistribution = _rewardsDistribution;
        emit RewardsDistributionUpdated(rewardsDistribution);
    }

    

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event RewardsDistributionUpdated(address indexed newDistribution);
    event Recovered(address token, uint256 amount);
}",1358.0,1,3,"{
  ""Findings"": [
    {
      ""Issue"": ""Improper Access Control on Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `notifyRewardAmount`, `stake`, and `withdraw` lack sufficient access control. `notifyRewardAmount` is restricted to a single address, which might not be secure, while `stake` and `withdraw` depend on the security of the external `MasterChef` contract."",
      ""Impact"": ""If the controlling address is compromised, or the `MasterChef` contract has vulnerabilities, unauthorized actions could destabilize the reward system or lead to fund mismanagement."",
      ""Location"": ""Functions `notifyRewardAmount`, `stake`, and `withdraw`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The lack of robust access control is crucial, aligning with the task's focus on access control validation.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `withdraw` and `getReward` interact with external contracts after state changes even though they use `nonReentrant`. This pattern is risky if the external contracts aren't secure against reentrancy."",
      ""Impact"": ""Reentrancy attacks through insecure external contracts could manipulate balances or unauthorized reward claims."",
      ""Location"": ""Functions `withdraw` and `getReward`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding correctly identifies potential reentrancy issues, which is critical for ensuring contract security.""
    },
    {
      ""Issue"": ""Insecure Reward Calculation and Distribution"",
      ""Severity"": ""High"",
      ""Description"": ""The reward calculation in `notifyRewardAmount` may lead to incorrect distribution if parameters are not correctly adjusted, and vulnerabilities could lead to overflow."",
      ""Impact"": ""Users might receive incorrect rewards, leading to possible depletion of the rewards pool or execution errors."",
      ""Location"": ""Function `notifyRewardAmount`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Highlighting potential miscalculations and vulnerabilities in reward distribution is crucial for maintaining fairness and contract integrity.""
    },
    {
      ""Issue"": ""Redundant State Updates and Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Repetitive calculations and unnecessary state updates for each call in functions like `rewardPerToken` and through the `updateReward` modifier increase gas costs."",
      ""Impact"": ""Unoptimized operations may lead to higher gas expenses for users."",
      ""Location"": ""Functions and Modifiers involving reward calculations"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Identifying and optimizing redundant operations is relevant for improving contract efficiency.""
    },
    {
      ""Issue"": ""Potential Misuse of Admin Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions such as `recoverERC20` allow the owner to recover tokens, including critical reward tokens. This could be misused if not properly restricted."",
      ""Impact"": ""Misuse could lead to loss of reward tokens, impacting user trust."",
      ""Location"": ""Function `recoverERC20`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it addresses risks associated with admin-controlled operations, critical for secure contract management.""
    },
    {
      ""Issue"": ""External Dependency Risks"",
      ""Severity"": ""Low"",
      ""Description"": ""Interactions with external contracts like `MasterChef` introduce dependencies that could affect the contract's operations if the external contracts are vulnerable."",
      ""Impact"": ""Changes or vulnerabilities in external contracts could disrupt operations or lead to security risks."",
      ""Location"": ""Functions `stake` and `withdraw` interacting with `MasterChef`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Highlighting dependency risks is important for assessing potential operational vulnerabilities.""
    }
  ],
  ""FindingNumber"": 6,
  ""AllRelevance"": 23,
  ""RelevanceCount"": 4,
  ""AllValidation"": 23,
  ""ValidationCount"": 4
}","### **[H-04] StakingRewards Wrong implementation will send concur rewards to the wrong receiver**

**Report Description**:
The `StakingRewards` contract uses `masterChef.deposit()` and `masterChef.withdraw()`, which take `_msgSender()` as the user address. However, `_msgSender()` returns the address of `ConvexStakingWrapper` and `StakingRewards`, not the actual user. This misimplementation could result in rewards being sent to the wrong receiver, leading to incorrect reward distribution and potential loss of funds for users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue is not addressed in the `response_list`. The response list does not cover the specific problem of incorrect reward distribution due to the misuse of `_msgSender()` in the context of `masterChef` interactions.

---

### **[M-06] StakingRewards.sol `recoverERC20()` can be used as a backdoor by the owner to retrieve `rewardsToken`**

**Report Description**:
The `recoverERC20()` function in `StakingRewards.sol` allows the owner to retrieve tokens, including `rewardsToken`. If the owner is malicious or compromised, they could use this function to steal all rewards, leading to a complete loss of user funds.

**Match in Response List**:
Matches with the issue titled **""Potential Misuse of Admin Functions""**.

**Validation**:
**Correct**. The response accurately identifies the risk of misuse of the `recoverERC20()` function by the owner. It correctly highlights the potential for the owner to recover critical reward tokens, which aligns with the issue described in the report.

---

### **[M-09] StakingRewards.sol#`notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards**

**Report Description**:
The `notifyRewardAmount()` function in `StakingRewards.sol` checks if the balance of `rewardsToken` is greater than or equal to future rewards. However, it does not account for rewards that belong to users but have not yet been withdrawn. If `rewardsDistribution` mistakenly notifies a larger amount, the contract may enter a state where some users cannot claim their rewards.

**Match in Response List**:
Matches with the issue titled **""Insecure Reward Calculation and Distribution""**.

**Validation**:
**Partially Correct**. The response identifies potential issues with reward calculation and distribution but does not specifically address the problem of improper balance checks in `notifyRewardAmount()`. The response focuses on miscalculations and vulnerabilities in reward distribution but misses the critical detail of unclaimed user rewards affecting the contract's state.

---

### **[M-13] `StakingRewards.recoverERC20` allows owner to rug the `rewardsToken`**

**Report Description**:
The `recoverERC20` function in `StakingRewards` checks against the `stakingToken` being swept away but does not check against the `rewardsToken`. Over time, `rewardsToken` accumulates in the contract, and the owner can sweep these tokens, potentially rugging depositors.

**Match in Response List**:
Matches with the issue titled **""Potential Misuse of Admin Functions""**.

**Validation**:
**Correct**. The response accurately identifies the risk of the owner misusing the `recoverERC20` function to sweep `rewardsToken`. It correctly highlights the potential for the owner to rug depositors, which aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-06] StakingRewards.sol `recoverERC20()` can be used as a backdoor by the owner to retrieve `rewardsToken`** - **[M-09] StakingRewards.sol#`notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards**
- **[M-13] `StakingRewards.recoverERC20` allows owner to rug the `rewardsToken`**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-04] StakingRewards Wrong implementation will send concur rewards to the wrong receiver**

---",3,0,1,6,23,"```
1. Potential Misuse of Admin Functions
2. Potential Misuse of Admin Functions 3. Insecure Reward Calculation and Distribution
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Potential Misuse of Admin Functions"" appears at rank 5.
   - ""Insecure Reward Calculation and Distribution"" appears at rank 3.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)
   - At rank 5: \( P@5 = \frac{2}{5} = 0.4 \)

3. **Average the precision values**:
   - \( AP = \frac{0.333 + 0.4}{2} = \frac{0.733}{2} \approx 0.3665 \)

**Output**:
- **Average Precision (AP)**: 0.3665"
USDMPegRecovery.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { ICurveMetaPool } from ""./external/CurveInterfaces.sol"";

contract USDMPegRecovery is Ownable {

    using SafeERC20 for IERC20; 

    IERC20 public immutable usdm;

    IERC20 public immutable pool3;

    ICurveMetaPool public immutable usdm3crv;

    address public immutable kpiOracle;

    uint256 public step;

    uint256 public startLiquidity;

    struct Liquidity {
        uint128 usdm;
        uint128 pool3;
    }

    event Deposit(address indexed depositor, Liquidity deposits);

    event Withdraw(address indexed withdrawer, Liquidity withdrawals);

    Liquidity public totalLiquidity;

    mapping(address => Liquidity) public userLiquidity;

    mapping(address => bool) public isGuardian;

    bool public unlockable;

    modifier onlyGuardian() {
        require(isGuardian[msg.sender], ""!guardian"");
        _;
    }

    constructor(
        uint256 _startLiquidity,
        address _kpiOracle
    ) Ownable() {
        startLiquidity = _startLiquidity;
        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);
        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);
        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);
        step = 250000e18;
        kpiOracle = _kpiOracle;
    }

    function addGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = true;
    }

    function removeGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = false;
    }

    function enableUnlock() external {
        require(msg.sender == kpiOracle, ""!oracle"");
        unlockable = true;
    }

    function provide(uint256 _minimumLP) external onlyGuardian {
        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
        // truncate amounts under step
        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;
        // match usdm : pool3 = 1 : 1
        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
        usdm.approve(address(usdm3crv), addingLiquidity);
        pool3.approve(address(usdm3crv), addingLiquidity);
        usdm3crv.add_liquidity(amounts, _minimumLP);
    }

    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {
        uint256 removingLiquidity = _steps * step;
        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];
        usdm3crv.remove_liquidity(_burningLPs, amounts);
    }

    function deposit(Liquidity calldata _deposits) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_deposits.usdm > 0) {
            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));
            total.usdm += _deposits.usdm;
            user.usdm += _deposits.usdm;
        }

        if(_deposits.pool3 > 0) {
            require(totalLiquidity.usdm > 4000000e18, ""usdm low"");
            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));
            total.pool3 += _deposits.pool3;
            user.pool3 += _deposits.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Deposit(msg.sender, _deposits);
    }

    function withdraw(Liquidity calldata _withdrawal) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_withdrawal.usdm > 0) {
            require(unlockable, ""!unlock usdm"");
            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));
            total.usdm -= _withdrawal.usdm;
            user.usdm -= _withdrawal.usdm;
        }

        if(_withdrawal.pool3 > 0) {
            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));
            total.pool3 -= _withdrawal.pool3;
            user.pool3 -= _withdrawal.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Withdraw(msg.sender, _withdrawal);
    }
}",1156.0,129.0,"[H-05] USDMPegRecovery Risk of fund locked, due to discrepancy between curveLP token value against internal contract math
In USDMPegRecovery `deposit` and `withdraw` allow for direct deposits of a specific token (3crv or usdm).
The balances are directly changed and tracked in storage.

[M-03] USDMPegRecovery.sol#`withdraw()` withdraw may often fail
However, because the `withdraw()` function takes funds from the balance of the contract, once the majority of the funds are added to the curve pool via provide(). The withdraw() may often fail due to insufficient funds in the balance.

[M-04] USDMPegRecovery.sol#`provide()` Improper design/implementation make it often unable to add liquidity to the usdm3crv pool
In the current implementation of USDMPegRecovery.sol#`provide()`, `addingLiquidity` is calculated solely based on `usdm` balance (truncate at a step of 250k), and it always uses the same amount of 3pool tokens to add_liquidity with.
Based on other functions of the contract, the balance of usdm can usually be more than the pool3 balance, in that case, usdm3crv.add_liquidity() will fail.

[M-05] USDM locked unless guardian remove liquidity
However, USDM deposits are also locked until guardian remove liquidity because there are no mechanism to remove deposited USDM in `withdraw`.

[M-12] `USDMPegRecovery.provide()` Will Fail If There Is An Excess Of usdm Tokens
The `provide` function does not take a `_steps` argument and will instead calculate `addingLiquidity` by truncating amounts under step. As a result, if there is an excess of usdm such that the truncated amount exceeds the contract's pool3 truncated balance, then the function will revert due to insufficient pool3` collateral.",5.0,"pragma solidity ^0.8.11;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { ICurveMetaPool } from ""./external/CurveInterfaces.sol"";

contract USDMPegRecovery is Ownable {

    using SafeERC20 for IERC20; 

    IERC20 public immutable usdm;

    IERC20 public immutable pool3;

    ICurveMetaPool public immutable usdm3crv;

    address public immutable kpiOracle;

    uint256 public step;

    uint256 public startLiquidity;

    struct Liquidity {
        uint128 usdm;
        uint128 pool3;
    }

    event Deposit(address indexed depositor, Liquidity deposits);

    event Withdraw(address indexed withdrawer, Liquidity withdrawals);

    Liquidity public totalLiquidity;

    mapping(address => Liquidity) public userLiquidity;

    mapping(address => bool) public isGuardian;

    bool public unlockable;

    modifier onlyGuardian() {
        require(isGuardian[msg.sender], ""!guardian"");
        _;
    }

    constructor(
        uint256 _startLiquidity,
        address _kpiOracle
    ) Ownable() {
        startLiquidity = _startLiquidity;
        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);
        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);
        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);
        step = 250000e18;
        kpiOracle = _kpiOracle;
    }

    function addGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = true;
    }

    function removeGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = false;
    }

    function enableUnlock() external {
        require(msg.sender == kpiOracle, ""!oracle"");
        unlockable = true;
    }

    function provide(uint256 _minimumLP) external onlyGuardian {
        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
        
        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;
        
        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
        usdm.approve(address(usdm3crv), addingLiquidity);
        pool3.approve(address(usdm3crv), addingLiquidity);
        usdm3crv.add_liquidity(amounts, _minimumLP);
    }

    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {
        uint256 removingLiquidity = _steps * step;
        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];
        usdm3crv.remove_liquidity(_burningLPs, amounts);
    }

    function deposit(Liquidity calldata _deposits) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_deposits.usdm > 0) {
            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));
            total.usdm += _deposits.usdm;
            user.usdm += _deposits.usdm;
        }

        if(_deposits.pool3 > 0) {
            require(totalLiquidity.usdm > 4000000e18, ""usdm low"");
            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));
            total.pool3 += _deposits.pool3;
            user.pool3 += _deposits.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Deposit(msg.sender, _deposits);
    }

    function withdraw(Liquidity calldata _withdrawal) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_withdrawal.usdm > 0) {
            require(unlockable, ""!unlock usdm"");
            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));
            total.usdm -= _withdrawal.usdm;
            user.usdm -= _withdrawal.usdm;
        }

        if(_withdrawal.pool3 > 0) {
            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));
            total.pool3 -= _withdrawal.pool3;
            user.pool3 -= _withdrawal.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Withdraw(msg.sender, _withdrawal);
    }
}",1129.0,1,4,"{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in `withdraw` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdraw` function performs external calls before updating the user's liquidity state, allowing reentrant attacks. This could result in repeated unauthorized withdrawals."",
      ""Impact"": ""Potential loss of funds due to unauthorized repeated withdrawals by exploiting the reentrancy vulnerability."",
      ""Location"": ""Function `withdraw` in lines 80-97"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it directly addresses the task of inspecting the `withdraw` function for reentrancy vulnerabilities. It is technically valid as the function performs external calls before state updates.""
    },
    {
      ""Issue"": ""Immutable State Variables Prevent Upgradability"",
      ""Severity"": ""High"",
      ""Description"": ""The use of `immutable` keyword for state variables prevents them from being updated post-deployment, limiting the contract's upgradeability."",
      ""Impact"": ""If any of the immutable addresses need to be changed, deploying a new version of the contract is required, leading to potential disruption and increased operational costs."",
      ""Location"": ""Immutable variables declared in lines: 9-12"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The use of immutable variables directly conflicts with the ability to upgrade contracts via proxy patterns, making this finding relevant and valid.""
    },
    {
      ""Issue"": ""Approval Race Condition in `provide` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `provide` function approves the `usdm3crv` pool without resetting the prior allowance to zero, leading to a race condition exploitable by attackers."",
      ""Impact"": ""Tokens could be stolen by an attacker exploiting this race condition, leading to financial loss."",
      ""Location"": ""Function `provide`, lines 57-59"",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Lack of Proxy Pattern for Upgradeability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not implement a proxy pattern, preventing upgrades without deploying a new contract and migrating state."",
      ""Impact"": ""Increased costs and complications in future changes or if critical bugs are discovered post-deployment."",
      ""Location"": ""Overall contract structure, specifically the constructor and state variable definitions"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The contract's design does not support a proxy pattern, essential for future-proofing and flexibility in contract upgrades.""
    },
    {
      ""Issue"": ""Unlockable Flag Dependency"",
      ""Severity"": ""Medium"",
      ""Description"": ""Withdrawals are dependent on the `unlockable` flag, which can only be set by the `kpiOracle`. If compromised or fails, withdrawals could be permanently blocked."",
      ""Impact"": ""Could lead to user funds being locked indefinitely, causing loss of trust and potential financial losses for users."",
      ""Location"": ""Function `withdraw` line 66"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a critical dependency on an external oracle, relevant for assessing risks related to fund accessibility and security.""
    },
    {
      ""Issue"": ""Redundant Storage Writes"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract writes to storage variables `totalLiquidity` and `userLiquidity[msg.sender]` after every deposit and withdrawal, which can be optimized."",
      ""Impact"": ""Unnecessary storage writes increase transaction costs, reducing the efficiency of the contract."",
      ""Location"": ""Functions `deposit` (lines 74 and 89) and `withdraw` (lines 100 and 111)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it directly addresses the task's goal of optimizing storage use to minimize gas costs.""
    },
    {
      ""Issue"": ""Public Exposure of Internal State Variables"",
      ""Severity"": ""Low"",
      ""Description"": ""State variables such as `totalLiquidity`, `userLiquidity`, and `isGuardian` are public, exposing internal contract state."",
      ""Impact"": ""Public information could be used by malicious actors to analyze and exploit user behavior or contract operations."",
      ""Location"": ""State variables `totalLiquidity` (line 22), `userLiquidity` (line 24), `isGuardian` (line 26)"",
      ""Relevance"": true,
      ""Validation"": true
    },
    {
      ""Issue"": ""Arbitrary Guardian Addition"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract allows the owner to add or remove guardians. If the owner's account is compromised, malicious guardians could be added."",
      ""Impact"": ""Could lead to unauthorized users having control over liquidity operations, potentially leading to misuse or manipulation."",
      ""Location"": ""Functions `addGuardian` and `removeGuardian` lines 32 and 36"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The ability to alter guardianship is relevant to security analysis, ensuring only trusted users gain control.""
    }
  ],
  ""FindingNumber"": 8,
  ""AllRelevance"": 22,
  ""RelevanceCount"": 5,
  ""AllValidation"": 22,
  ""ValidationCount"": 5
}","### **Output**

---

**[H-05] USDMPegRecovery Risk of fund locked, due to discrepancy between curveLP token value against internal contract math**

**Report Description**:
The `USDMPegRecovery` contract allows direct deposits of specific tokens (3crv or USDM) in the `deposit` and `withdraw` functions. However, the internal contract math may not accurately reflect the value of the curveLP tokens, leading to discrepancies. This could result in funds being locked due to mismatched balances between the contract and the curve pool.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of fund locking due to discrepancies between curveLP token values and internal contract math. This is a critical oversight, as it directly impacts the contract's ability to manage funds securely.

---

**[M-03] USDMPegRecovery.sol#`withdraw()` withdraw may often fail**

**Report Description**:
The `withdraw` function in `USDMPegRecovery.sol` takes funds from the contract's balance. However, once the majority of the funds are added to the curve pool via `provide()`, the `withdraw` function may often fail due to insufficient funds in the contract's balance.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of `withdraw` failing due to insufficient funds in the contract's balance. This is a significant oversight, as it directly impacts the contract's ability to allow users to withdraw their funds.

---

**[M-04] USDMPegRecovery.sol#`provide()` Improper design/implementation make it often unable to add liquidity to the usdm3crv pool**

**Report Description**:
The `provide` function in `USDMPegRecovery.sol` calculates `addingLiquidity` solely based on the `usdm` balance, truncating at a step of 250k, and always uses the same amount of 3pool tokens to add liquidity. This design can lead to failures when the `usdm` balance exceeds the `pool3` balance, causing the `usdm3crv.add_liquidity()` function to fail.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper design/implementation in the `provide` function, which can lead to failures in adding liquidity to the `usdm3crv` pool. This is a critical oversight, as it directly impacts the contract's ability to manage liquidity.

---

**[M-05] USDM locked unless guardian remove liquidity**

**Report Description**:
USDM deposits in `USDMPegRecovery.sol` are locked until the guardian removes liquidity, as there is no mechanism to remove deposited USDM in the `withdraw` function.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of USDM deposits being locked until the guardian removes liquidity. This is a significant oversight, as it directly impacts the contract's ability to allow users to withdraw their funds.

---

**[M-12] `USDMPegRecovery.provide()` Will Fail If There Is An Excess Of usdm Tokens**

**Report Description**:
The `provide` function does not take a `_steps` argument and calculates `addingLiquidity` by truncating amounts under a step. If there is an excess of `usdm` such that the truncated amount exceeds the contract's `pool3` truncated balance, the function will revert due to insufficient `pool3` collateral.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of the `provide` function failing due to an excess of `usdm` tokens. This is a critical oversight, as it directly impacts the contract's ability to manage liquidity.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- *None*

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-05] USDMPegRecovery Risk of fund locked, due to discrepancy between curveLP token value against internal contract math**
- **[M-03] USDMPegRecovery.sol#`withdraw()` withdraw may often fail**
- **[M-04] USDMPegRecovery.sol#`provide()` Improper design/implementation make it often unable to add liquidity to the usdm3crv pool**
- **[M-05] USDM locked unless guardian remove liquidity**
- **[M-12] `USDMPegRecovery.provide()` Will Fail If There Is An Excess Of usdm Tokens**

---

### **Conclusion**

The `response_list` does not adequately address the issues raised in the `issue` report. Several critical vulnerabilities and risks related to fund locking, withdrawal failures, and improper liquidity management in the `USDMPegRecovery` contract are completely missed. This indicates a significant gap in the coverage, accuracy, and sufficiency of the responses provided.",0,3,2,8,22,"```
None.
```",0.0
,,,,,,,,12,16,,,6,5,17,31,112,,
