nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Match,Partially,Missed,Genes,Task,matchList,MAP
synthVault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";

contract SynthVault {
    address public BASE;
    address public DEPLOYER;

    uint256 public minimumDepositTime;  // Withdrawal & Harvest lockout period; intended to be 1 hour
    uint256 public totalWeight;         // Total weight of the whole SynthVault
    uint256 public erasToEarn;          // Amount of eras that make up the targeted RESERVE depletion; regulates incentives
    uint256 public vaultClaim;          // The SynthVaults's portion of rewards; intended to be ~10% initially
    address [] public stakedSynthAssets; // Array of all synth assets that have ever been staked in (scope: vault)
    uint private lastMonth;             // Timestamp of the start of current metric period (For UI)
    uint public genesis;                // Timestamp from when the synth was first deployed (For UI)

    uint256 public map30DVaultRevenue; // Tally of revenue during current incomplete metric period (for UI)
    uint256 public mapPast30DVaultRevenue; // Tally of revenue from last full metric period (for UI)
    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor(address _base) {
        BASE = _base;
        DEPLOYER = msg.sender;
        erasToEarn = 30;
        minimumDepositTime = 3600; // 1 hour
        vaultClaim = 1000;
        genesis = block.timestamp;
        lastMonth = 0;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;
    mapping(address => uint256) private mapMemberTotal_weight;
    mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;

    mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;
    mapping(address => uint256) private mapMember_depositTime;
    mapping(address => uint256) public lastBlock;
    mapping(address => bool) private isStakedSynth;
    mapping(address => mapping(address => bool)) private isSynthMember;

    event MemberDeposits(
        address indexed synth,
        address indexed member,
        uint256 newDeposit,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberWithdraws(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberHarvests(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );

    function setParams(uint256 one, uint256 two, uint256 three) external onlyDAO {
        erasToEarn = one;
        minimumDepositTime = two;
        vaultClaim = three;
    }

    //====================================== DEPOSIT ========================================//

    // User deposits Synths in the SynthVault
    function deposit(address synth, uint256 amount) external {
        depositForMember(synth, msg.sender, amount);
    }

    // Contract deposits Synths in the SynthVault for user
    function depositForMember(address synth, address member, uint256 amount) public {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); // Must be a valid synth
        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in
        _deposit(synth, member, amount); // Assess and record the deposit
    }

    // Check and record the deposit
    function _deposit(address _synth, address _member, uint256 _amount) internal {
        if(!isStakedSynth[_synth]){
            isStakedSynth[_synth] = true; // Record as a staked synth
            stakedSynthAssets.push(_synth); // Add to staked synth array
        }
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth)
        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member)
        mapMemberSynth_deposit[_member][_synth] += _amount; // Record balance for member
        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); // Get the SPARTA weight of the deposit
        mapMemberSynth_weight[_member][_synth] += _weight; // Add the weight to the user (scope: member -> synth)
        mapMemberTotal_weight[_member] += _weight; // Add to the user's total weight (scope: member)
        totalWeight += _weight; // Add to the total weight (scope: vault)
        isSynthMember[_member][_synth] = true; // Record user as a member
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    //====================================== HARVEST ========================================//

    // User harvests all of their available rewards
    function harvestAll() external returns (bool) {
        for(uint i = 0; i < stakedSynthAssets.length; i++){
            if((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){
                uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);
                if(reward > 0){
                    harvestSingle(stakedSynthAssets[i]);
                }
            }
            
        }
        return true;
    }

    // User harvests available rewards of the chosen asset
    function harvestSingle(address synth) public returns (bool) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); // Must be valid synth
        require(iRESERVE(_DAO().RESERVE()).emissions(), ""!emissions""); // RESERVE emissions must be on
        uint256 _weight;
        uint256 reward = calcCurrentReward(synth, msg.sender); // Calc user's current SPARTA reward
        mapMemberSynth_lastTime[msg.sender][synth] = block.timestamp; // Set last harvest time as now
        address _poolOUT = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(iSYNTH(synth).LayerONE()); // Get pool address
        iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT); // Send the SPARTA from RESERVE to POOL
        (uint synthReward,) = iPOOL(_poolOUT).mintSynth(synth, address(this)); // Mint synths & tsf to SynthVault
        _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(synth).LayerONE(), synthReward); // Calc reward's SPARTA value
        mapMemberSynth_deposit[msg.sender][synth] += synthReward; // Record deposit for the user (scope: member -> synth)
        mapMemberSynth_weight[msg.sender][synth] += _weight; // Add the weight to the user (scope: member -> synth)
        mapMemberTotal_weight[msg.sender] += _weight; // Add to the user's total weight (scope: member)
        totalWeight += _weight; // Add to the total weight (scope: vault)
        _addVaultMetrics(reward); // Add to the revenue metrics (for UI)
        iSYNTH(synth).realise(_poolOUT); // Check synth-held LP value for premium; burn if so
        emit MemberHarvests(synth, msg.sender, reward, _weight, totalWeight);
        return true;
    }

    // Calculate the user's current incentive-claim per era based on selected asset
    function calcCurrentReward(address synth, address member) public view returns (uint256 reward){
        require((block.timestamp > mapMemberSynth_lastTime[member][synth]), ""!unlocked""); // Must not harvest before lockup period passed
        uint256 _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]; // Get seconds passed since last claim
        uint256 _share = calcReward(synth, member); // Get member's share of RESERVE incentives
        reward = (_share * _secondsSinceClaim) / iBASE(BASE).secondsPerEra(); // User's share times eras since they last claimed
        return reward;
    }

    // Calculate the user's current total claimable incentive
    function calcReward(address synth, address member) public view returns (uint256) {
        uint256 _weight = mapMemberSynth_weight[member][synth]; // Get user's weight (scope: member -> synth)
        uint256 _reserve = reserveBASE() / erasToEarn; // Aim to deplete reserve over a number of days
        uint256 _vaultReward = (_reserve * vaultClaim) / 10000; // Get the SynthVault's share of that
        return iUTILS(_DAO().UTILS()).calcShare(_weight, totalWeight, _vaultReward); // Get member's share of that
    }

    //====================================== WITHDRAW ========================================//

    // User withdraws a percentage of their synths from the vault
    function withdraw(address synth, uint256 basisPoints) external returns (uint256 redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints); // Perform the withdrawal
        require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); // Transfer from SynthVault to user
        return redeemedAmount;
    }

    // Contract withdraws a percentage of user's synths from the vault
    function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {
        require((block.timestamp > mapMember_depositTime[_member]), ""lockout""); // Must not withdraw before lockup period passed
        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Calc amount to withdraw
        mapMemberSynth_deposit[_member][_synth] -= _principle; // Remove from user's recorded vault holdings
        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); // Calc SPARTA value of amount
        mapMemberTotal_weight[_member] -= _weight; // Remove from member's total weight (scope: member)
        mapMemberSynth_weight[_member][_synth] -= _weight; // Remove from member's synth weight (scope: member -> synth)
        totalWeight -= _weight; // Remove from total weight (scope: vault)
        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);
        return (_principle + synthReward);
    }

    //================================ Helper Functions ===============================//

    function reserveBASE() public view returns (uint256) {
        return iBEP20(BASE).balanceOf(_DAO().RESERVE());
    }

    function getMemberDeposit(address synth, address member) external view returns (uint256){
        return mapMemberSynth_deposit[member][synth];
    }

    function getMemberWeight(address member) external view returns (uint256) {
        return mapMemberTotal_weight[member];
    }

    function getStakeSynthLength() external view returns (uint256) {
        return stakedSynthAssets.length;
    }

    function getMemberLastTime(address member) external view returns (uint256) {
        return mapMember_depositTime[member];
    }

    function getMemberLastSynthTime(address synth, address member) external view returns (uint256){
        return mapMemberSynth_lastTime[member][synth];
    }

    function getMemberSynthWeight(address synth, address member) external view returns (uint256) {
        return mapMemberSynth_weight[member][synth];
    }

    //=============================== SynthVault Metrics =================================//

    function _addVaultMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ // 30 days
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        } else {
            lastMonth = block.timestamp;
            mapPast30DVaultRevenue = map30DVaultRevenue;
            addRevenue(mapPast30DVaultRevenue);
            map30DVaultRevenue = 0;
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; // 2
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",2956.0,258.0,"[H-01] SynthVault withdraw forfeits rewards
The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.
Usually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.
Recommend claiming the rewards with the user's deposited balance first in withdraw.

[H-06] SynthVault rewards can be gamedThe `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`.
This spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity. However, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool. Therefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:
(1) Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of BASE into it repeatedly (sending lots of smaller trades is less costly due to the path-independence of the continuous liquidity model). This increases the BASE per token price.
(2) Call `SynthVault.depositForMember` and deposit a small amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price.
(3) Optionally drip more `BASE` into the pool and repeat the deposits
(4) Drip back `token` to the pool to rebalance it
The user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.

[M-04] `_deposit` resetting user rewards can be used to grief them and make them loose rewards via depositForMemberThe function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future in `synthVault.sol` L107.
`mapMemberSynth_lastTime` is also used to calculate rewards earned. `depositForMember` allows anyone, to ""make a donation"" for the member and cause that member to lose all their accrued rewards. This can't be used for personal gain, but can be used to bring misery to others.`depositForMember (in synthVault.sol on L95 can be called by anyone.
This will set the member and can be continuously exploited to make members never earn any reward.",3.0,"pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";

contract SynthVault {
    address public BASE;
    address public DEPLOYER;

    uint256 public minimumDepositTime;  
    uint256 public totalWeight;         
    uint256 public erasToEarn;          
    uint256 public vaultClaim;          
    address [] public stakedSynthAssets; 
    uint private lastMonth;             
    uint public genesis;                

    uint256 public map30DVaultRevenue; 
    uint256 public mapPast30DVaultRevenue; 
    uint256 [] public revenueArray; 

    
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor(address _base) {
        BASE = _base;
        DEPLOYER = msg.sender;
        erasToEarn = 30;
        minimumDepositTime = 3600; 
        vaultClaim = 1000;
        genesis = block.timestamp;
        lastMonth = 0;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    mapping(address => mapping(address => uint256)) private mapMemberSynth_weight;
    mapping(address => uint256) private mapMemberTotal_weight;
    mapping(address => mapping(address => uint256)) private mapMemberSynth_deposit;

    mapping(address => mapping(address => uint256)) private mapMemberSynth_lastTime;
    mapping(address => uint256) private mapMember_depositTime;
    mapping(address => uint256) public lastBlock;
    mapping(address => bool) private isStakedSynth;
    mapping(address => mapping(address => bool)) private isSynthMember;

    event MemberDeposits(
        address indexed synth,
        address indexed member,
        uint256 newDeposit,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberWithdraws(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );
    event MemberHarvests(
        address indexed synth,
        address indexed member,
        uint256 amount,
        uint256 weight,
        uint256 totalWeight
    );

    function setParams(uint256 one, uint256 two, uint256 three) external onlyDAO {
        erasToEarn = one;
        minimumDepositTime = two;
        vaultClaim = three;
    }

    

    
    function deposit(address synth, uint256 amount) external {
        depositForMember(synth, msg.sender, amount);
    }

    
    function depositForMember(address synth, address member, uint256 amount) public {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); 
        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); 
        _deposit(synth, member, amount); 
    }

    
    function _deposit(address _synth, address _member, uint256 _amount) internal {
        if(!isStakedSynth[_synth]){
            isStakedSynth[_synth] = true; 
            stakedSynthAssets.push(_synth); 
        }
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; 
        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; 
        mapMemberSynth_deposit[_member][_synth] += _amount; 
        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); 
        mapMemberSynth_weight[_member][_synth] += _weight; 
        mapMemberTotal_weight[_member] += _weight; 
        totalWeight += _weight; 
        isSynthMember[_member][_synth] = true; 
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    

    
    function harvestAll() external returns (bool) {
        for(uint i = 0; i < stakedSynthAssets.length; i++){
            if((block.timestamp > mapMemberSynth_lastTime[msg.sender][stakedSynthAssets[i]])){
                uint256 reward = calcCurrentReward(stakedSynthAssets[i], msg.sender);
                if(reward > 0){
                    harvestSingle(stakedSynthAssets[i]);
                }
            }
            
        }
        return true;
    }

    
    function harvestSingle(address synth) public returns (bool) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); 
        require(iRESERVE(_DAO().RESERVE()).emissions(), ""!emissions""); 
        uint256 _weight;
        uint256 reward = calcCurrentReward(synth, msg.sender); 
        mapMemberSynth_lastTime[msg.sender][synth] = block.timestamp; 
        address _poolOUT = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(iSYNTH(synth).LayerONE()); 
        iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT); 
        (uint synthReward,) = iPOOL(_poolOUT).mintSynth(synth, address(this)); 
        _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(synth).LayerONE(), synthReward); 
        mapMemberSynth_deposit[msg.sender][synth] += synthReward; 
        mapMemberSynth_weight[msg.sender][synth] += _weight; 
        mapMemberTotal_weight[msg.sender] += _weight; 
        totalWeight += _weight; 
        _addVaultMetrics(reward); 
        iSYNTH(synth).realise(_poolOUT); 
        emit MemberHarvests(synth, msg.sender, reward, _weight, totalWeight);
        return true;
    }

    
    function calcCurrentReward(address synth, address member) public view returns (uint256 reward){
        require((block.timestamp > mapMemberSynth_lastTime[member][synth]), ""!unlocked""); 
        uint256 _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]; 
        uint256 _share = calcReward(synth, member); 
        reward = (_share * _secondsSinceClaim) / iBASE(BASE).secondsPerEra(); 
        return reward;
    }

    
    function calcReward(address synth, address member) public view returns (uint256) {
        uint256 _weight = mapMemberSynth_weight[member][synth]; 
        uint256 _reserve = reserveBASE() / erasToEarn; 
        uint256 _vaultReward = (_reserve * vaultClaim) / 10000; 
        return iUTILS(_DAO().UTILS()).calcShare(_weight, totalWeight, _vaultReward); 
    }

    

    
    function withdraw(address synth, uint256 basisPoints) external returns (uint256 redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints); 
        require(iBEP20(synth).transfer(msg.sender, redeemedAmount)); 
        return redeemedAmount;
    }

    
    function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {
        require((block.timestamp > mapMember_depositTime[_member]), ""lockout""); 
        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); 
        mapMemberSynth_deposit[_member][_synth] -= _principle; 
        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); 
        mapMemberTotal_weight[_member] -= _weight; 
        mapMemberSynth_weight[_member][_synth] -= _weight; 
        totalWeight -= _weight; 
        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);
        return (_principle + synthReward);
    }

    

    function reserveBASE() public view returns (uint256) {
        return iBEP20(BASE).balanceOf(_DAO().RESERVE());
    }

    function getMemberDeposit(address synth, address member) external view returns (uint256){
        return mapMemberSynth_deposit[member][synth];
    }

    function getMemberWeight(address member) external view returns (uint256) {
        return mapMemberTotal_weight[member];
    }

    function getStakeSynthLength() external view returns (uint256) {
        return stakedSynthAssets.length;
    }

    function getMemberLastTime(address member) external view returns (uint256) {
        return mapMember_depositTime[member];
    }

    function getMemberLastSynthTime(address synth, address member) external view returns (uint256){
        return mapMemberSynth_lastTime[member][synth];
    }

    function getMemberSynthWeight(address synth, address member) external view returns (uint256) {
        return mapMemberSynth_weight[member][synth];
    }

    

    function _addVaultMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ 
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        } else {
            lastMonth = block.timestamp;
            mapPast30DVaultRevenue = map30DVaultRevenue;
            addRevenue(mapPast30DVaultRevenue);
            map30DVaultRevenue = 0;
            map30DVaultRevenue = map30DVaultRevenue + _fee;
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; 
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",2254.0,2,1,"{
    ""Findings"": [
        {
            ""Issue"": ""Improper Access Control in Withdraw Function"",
            ""Severity"": ""High"",
            ""Description"": ""The `_processWithdraw` function allows withdrawals without properly checking if the member is eligible based on deposit time."",
            ""Impact"": ""Users might withdraw funds prematurely, potentially leading to a loss of funds for other stakeholders."",
            ""Location"": ""Function `_processWithdraw` defined in lines 130-143"",
            ""Relevance"": true,
            ""Validation"": true,
            ""Note"": ""The finding is relevant as it directly relates to improper access control, which is a critical security concern. The code does not check the eligibility based on deposit time, making it technically valid.""
        },
        {
            ""Issue"": ""Lack of Input Validation in Deposit Function"",
            ""Severity"": ""Medium"",
            ""Description"": ""The `depositForMember` function does not validate the deposited amount, which could lead to zero or unintended deposits."",
            ""Impact"": ""This could be exploited to manipulate staking rewards or affect the total weight calculations."",
            ""Location"": ""Function `depositForMember` defined in lines 63-67"",
            ""Relevance"": true,
            ""Validation"": true,
            ""Note"": ""The issue is relevant as input validation is crucial to prevent unintended behavior. The lack of checks for deposit amount makes the finding technically correct and valuable for ensuring robust contract functionality.""
        }
    ],
    ""FindingNumber"": 2,
    ""AllRelevance"": 5,
    ""RelevanceCount"": 4,
    ""AllValidation"": 5,
    ""ValidationCount"": 4
}","### **Comparison of Issue Report and Response List**

---

#### **[H-01] SynthVault withdraw forfeits rewards**

**Report Description**:  
The `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight, causing the user to forfeit their accumulated rewards. The `synthReward` variable in `_processWithdraw` is also unused, likely intended to capture claimed rewards. Typically, withdrawal functions claim rewards first, but this one does not, leading to users losing all their accumulated rewards. The recommendation is to claim rewards with the user's deposited balance first in `withdraw`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue at all. The issue involves the forfeiture of rewards due to improper handling of rewards during withdrawal, which is not mentioned or covered in the response list.

---

#### **[H-06] SynthVault rewards can be gamed**

**Report Description**:  
The `SynthVault._deposit` function adds `weight` for the user based on the spot value of the deposit synth amount in `BASE`. This spot price can be manipulated, especially if the pool's liquidity is low and the reward reserve is high. An attacker can:  
1. Manipulate the pool spot price by dripping `BASE` into it repeatedly.  
2. Deposit a small amount of synth token to inflate their `weight`.  
3. Optionally repeat the process.  
4. Rebalance the pool by dripping `token` back.  
This allows the attacker to claim a large share of rewards at a low cost, making the attack profitable under certain conditions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The issue involves the manipulation of rewards through spot price manipulation, which is not covered in the response list.

---

#### **[M-04] `_deposit` resetting user rewards can be used to grief them and make them lose rewards via `depositForMember`**

**Report Description**:  
The `_deposit` function sets `mapMemberSynth_lastTime` to a future date, which is used to calculate rewards. The `depositForMember` function allows anyone to ""make a donation"" for a member, resetting their `mapMemberSynth_lastTime` and causing them to lose all accrued rewards. This can be exploited to grief members and prevent them from earning rewards.

**Match in Response List**:  
Partially matches with the issue titled **""Lack of Input Validation in Deposit Function""**.

**Validation**:  
**Correct**. The response identifies the lack of input validation in `depositForMember`, which is related to the issue. However, it misses the critical detail that this lack of validation allows griefing by resetting `mapMemberSynth_lastTime` and causing users to lose rewards. The response does not address the core impact of the vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:   - **[M-04] `_deposit` resetting user rewards can be used to grief them and make them lose rewards via `depositForMember`**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] SynthVault withdraw forfeits rewards**  
- **[H-06] SynthVault rewards can be gamed**

---

### **Conclusion**  
The response list fails to address two high-severity issues ([H-01] and [H-06]) and only partially covers one medium-severity issue ([M-04]). The responses focus on access control and input validation but miss critical vulnerabilities related to reward forfeiture, reward manipulation, and griefing. This indicates significant gaps in the coverage, accuracy, and sufficiency of the responses.",1,0,2,2,5,"```
Lack of Input Validation in Deposit Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of true positives**:
   - The true positive is `""Lack of Input Validation in Deposit Function""`.
   - This true positive appears at rank 2 in the ranked list of predictions.

2. **Calculate precision at the rank of the true positive**:
   - Precision at rank 2 (\( P@2 \)) is calculated as the number of true positives up to rank 2 divided by 2.
   - Since there is only one true positive up to rank 2, \( P@2 = \frac{1}{2} = 0.5 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - Therefore, \( AP = 0.5 \).

**Output**:
```
0.5
```"
Pool.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iSYNTH.sol""; 
import ""./interfaces/iSYNTHFACTORY.sol""; 
import ""./interfaces/iBEP677.sol""; 

contract Pool is iBEP20 {  
    address public BASE;
    address public TOKEN;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    uint256 public baseAmount; // SPARTA amount that should be in the pool
    uint256 public tokenAmount; // TOKEN amount that should be in the pool

    uint private lastMonth; // Timestamp of the start of current metric period (For UI)
    uint public genesis; // Timestamp from when the pool was first deployed (For UI)

    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)
    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)
    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)

    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);
    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);
    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);
    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);
    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    constructor (address _base, address _token) {
        BASE = _base;
        TOKEN = _token;
        string memory poolName = ""-SpartanProtocolPool"";
        string memory poolSymbol = ""-SPP"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));
        decimals = 18;
        genesis = block.timestamp;
        DEPLOYER = msg.sender;
        lastMonth = 0;
    }

    //========================================iBEP20=========================================//

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }

    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        // Max approval (saves an SSTORE)
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    //iBEP677 approveAndCall
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval
      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient
      return true;
    }

    //iBEP677 transferAndCall
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _transfer(msg.sender, recipient, amount);
      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient 
      return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //====================================POOL FUNCTIONS =================================//

    // User adds liquidity to the pool
    function add() external returns(uint liquidityUnits){
        liquidityUnits = addForMember(msg.sender);
        return liquidityUnits;
    }

    // Contract adds liquidity for user 
    function addForMember(address member) public returns(uint liquidityUnits){
        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount
        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount
        if(baseAmount == 0 || tokenAmount == 0){
        require(_actualInputBase != 0 && _actualInputToken != 0, ""!Balanced"");
        }
        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint
        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts
        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user
        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);
        return liquidityUnits;
    }
    
    // User removes liquidity from the pool 
    function remove() external returns (uint outputBase, uint outputToken) {
        return removeForMember(msg.sender);
    } 

    // Contract removes liquidity for the user
    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {
        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount
        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units
        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units
        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts
        _burn(address(this), _actualInputUnits); // Burn the LP tokens
        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user
        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user
        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);
        return (outputBase, outputToken);
    }

    // Caller swaps tokens
    function swap(address token) external returns (uint outputAmount, uint fee){
        (outputAmount, fee) = swapTo(token, msg.sender);
        return (outputAmount, fee);
    }

    // Contract swaps tokens for the member
    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {
        require((token == BASE || token == TOKEN), ""!BASE||TOKEN""); // Must be SPARTA or the pool's relevant TOKEN
        address _fromToken; uint _amount;
        if(token == BASE){
            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN
            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount
            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap
        } else {
            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA
            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount
            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap
        }
        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);
        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user
        return (outputAmount, fee);
    }

    // Swap SPARTA for Synths
    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, ""!synth""); // Must be a valid Synth
        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount
        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN
        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted
        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount
        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN
        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA
        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold
        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user
        _addPoolMetrics(fee); // Add slip fee to the revenue metrics
        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);
      return (output, fee);
    }
    
    // Swap Synths for SPARTA
    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, ""!synth""); // Must be a valid Synth
        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount
        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA
        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA
        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract
        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units
        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount
        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user
        _addPoolMetrics(fee); // Add slip fee to the revenue metrics
        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);
      return (outputBase, fee);
    }

    //=======================================INTERNAL MATHS======================================//

    // Check the SPARTA amount received by this Pool
    function _getAddedBaseAmount() internal view returns(uint256 _actual){
        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); 
        if(_baseBalance > baseAmount){
            _actual = _baseBalance-(baseAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }
  
    // Check the TOKEN amount received by this Pool
    function _getAddedTokenAmount() internal view returns(uint256 _actual){
        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); 
        if(_tokenBalance > tokenAmount){
            _actual = _tokenBalance-(tokenAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }

    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts
    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = baseAmount;
        uint256 _Y = tokenAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output
        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee
        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA
        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts
        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics
        return (_y, _fee);
    }

    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts
    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = tokenAmount;
        uint256 _Y = baseAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output
        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee
        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts
        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics
        return (_y, _fee);
    }

    //=======================================BALANCES=========================================//

    // Sync internal balances to actual
    function sync() external {
        baseAmount = iBEP20(BASE).balanceOf(address(this));
        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));
    }

    // Increment internal balances
    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount += _baseAmount;
        tokenAmount += _tokenAmount;
    }

    // Set internal balances
    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {
        baseAmount = _baseAmount;
        tokenAmount = _tokenAmount; 
    }

    // Decrement internal balances
    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount -= _baseAmount;
        tokenAmount -= _tokenAmount; 
    }

    //===========================================POOL FEE ROI=================================//

    function _addPoolMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ // 30Days
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        } else {
            lastMonth = block.timestamp;
            mapPast30DPoolRevenue = map30DPoolRevenue;
            addRevenue(mapPast30DPoolRevenue);
            map30DPoolRevenue = 0;
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; // 2
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",4053.0,366.0,"[H-02] Pool.sol & Synth.sol: Failing Max Value Allowance
In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.
This also makes the comment // No need to re-approve if already max misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.
This affects the `approveAndCall` implementation since it uses type(uint256).max as the allowance amount, but the resulting allowance set is zero.

[H-07] Missing slippage checks
There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.
Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.

[H-09] arbitrary synth mint/burn from poolfunction `mintSynth`, L229-L242
`Pool` can mint arbitrary `Synth` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.Pool's mintSynth logic, Synth's mintSynth logic, and Synth's authorization logic.
The price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool

[H-11] Misuse of AMM model on minting `Synth` (resubmit to add more detail)
`Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the Pool. However, since `token_amount` in the pool would not decrease when users mint Synth, it's always cheaper to mint synth than swap the tokens.
The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.
In Pool's mint synth, The synth amount is calculated at L:232`uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount);`
which is the same as swapping base to token at L:287

[M-06] Pool: `approveAndCall` sets unnecessary approval
The `Pool.approveAndCall` function approves the recipient contract with the max value instead of only the required `amount`.
For safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, like this is the case for `approveAndCall`.",5.0,"pragma solidity 0.8.3;
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iDAO.sol"";
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iSYNTH.sol""; 
import ""./interfaces/iSYNTHFACTORY.sol""; 
import ""./interfaces/iBEP677.sol""; 

contract Pool is iBEP20 {  
    address public BASE;
    address public TOKEN;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    uint256 public baseAmount; 
    uint256 public tokenAmount; 

    uint private lastMonth; 
    uint public genesis; 

    uint256 public map30DPoolRevenue; 
    uint256 public mapPast30DPoolRevenue; 
    uint256 [] public revenueArray; 

    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);
    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);
    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);
    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);
    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    constructor (address _base, address _token) {
        BASE = _base;
        TOKEN = _token;
        string memory poolName = ""-SpartanProtocolPool"";
        string memory poolSymbol = ""-SPP"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));
        decimals = 18;
        genesis = block.timestamp;
        DEPLOYER = msg.sender;
        lastMonth = 0;
    }

    

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { 
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }

    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _approve(msg.sender, recipient, type(uint256).max); 
      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); 
      return true;
    }

    
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
      _transfer(msg.sender, recipient, amount);
      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); 
      return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    

    
    function add() external returns(uint liquidityUnits){
        liquidityUnits = addForMember(msg.sender);
        return liquidityUnits;
    }

    
    function addForMember(address member) public returns(uint liquidityUnits){
        uint256 _actualInputBase = _getAddedBaseAmount(); 
        uint256 _actualInputToken = _getAddedTokenAmount(); 
        if(baseAmount == 0 || tokenAmount == 0){
        require(_actualInputBase != 0 && _actualInputToken != 0, ""!Balanced"");
        }
        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); 
        _incrementPoolBalances(_actualInputBase, _actualInputToken); 
        _mint(member, liquidityUnits); 
        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);
        return liquidityUnits;
    }
    
    
    function remove() external returns (uint outputBase, uint outputToken) {
        return removeForMember(msg.sender);
    } 

    
    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {
        uint256 _actualInputUnits = balanceOf(address(this)); 
        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); 
        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); 
        _decrementPoolBalances(outputBase, outputToken); 
        _burn(address(this), _actualInputUnits); 
        iBEP20(BASE).transfer(member, outputBase); 
        iBEP20(TOKEN).transfer(member, outputToken); 
        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);
        return (outputBase, outputToken);
    }

    
    function swap(address token) external returns (uint outputAmount, uint fee){
        (outputAmount, fee) = swapTo(token, msg.sender);
        return (outputAmount, fee);
    }

    
    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {
        require((token == BASE || token == TOKEN), ""!BASE||TOKEN""); 
        address _fromToken; uint _amount;
        if(token == BASE){
            _fromToken = TOKEN; 
            _amount = _getAddedTokenAmount(); 
            (outputAmount, fee) = _swapTokenToBase(_amount); 
        } else {
            _fromToken = BASE; 
            _amount = _getAddedBaseAmount(); 
            (outputAmount, fee) = _swapBaseToToken(_amount); 
        }
        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);
        iBEP20(token).transfer(member, outputAmount); 
        return (outputAmount, fee);
    }

    
    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, ""!synth""); 
        uint256 _actualInputBase = _getAddedBaseAmount(); 
        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); 
        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); 
        _incrementPoolBalances(_actualInputBase, 0); 
        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); 
        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); 
        _mint(synthOut, _liquidityUnits); 
        iSYNTH(synthOut).mintSynth(member, output); 
        _addPoolMetrics(fee); 
        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);
      return (output, fee);
    }
    
    
    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, ""!synth""); 
        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); 
        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); 
        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); 
        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); 
        iSYNTH(synthIN).burnSynth(); 
        _decrementPoolBalances(outputBase, 0); 
        iBEP20(BASE).transfer(member, outputBase); 
        _addPoolMetrics(fee); 
        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);
      return (outputBase, fee);
    }

    

    
    function _getAddedBaseAmount() internal view returns(uint256 _actual){
        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); 
        if(_baseBalance > baseAmount){
            _actual = _baseBalance-(baseAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }
  
    
    function _getAddedTokenAmount() internal view returns(uint256 _actual){
        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); 
        if(_tokenBalance > tokenAmount){
            _actual = _tokenBalance-(tokenAmount);
        } else {
            _actual = 0;
        }
        return _actual;
    }

    
    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = baseAmount;
        uint256 _Y = tokenAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); 
        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); 
        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); 
        _setPoolAmounts(_X + _x, _Y - _y); 
        _addPoolMetrics(_fee); 
        return (_y, _fee);
    }

    
    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){
        uint256 _X = tokenAmount;
        uint256 _Y = baseAmount;
        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); 
        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); 
        _setPoolAmounts(_Y - _y, _X + _x); 
        _addPoolMetrics(_fee); 
        return (_y, _fee);
    }

    

    
    function sync() external {
        baseAmount = iBEP20(BASE).balanceOf(address(this));
        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));
    }

    
    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount += _baseAmount;
        tokenAmount += _tokenAmount;
    }

    
    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {
        baseAmount = _baseAmount;
        tokenAmount = _tokenAmount; 
    }

    
    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        baseAmount -= _baseAmount;
        tokenAmount -= _tokenAmount; 
    }

    

    function _addPoolMetrics(uint256 _fee) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ 
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        } else {
            lastMonth = block.timestamp;
            mapPast30DPoolRevenue = map30DPoolRevenue;
            addRevenue(mapPast30DPoolRevenue);
            map30DPoolRevenue = 0;
            map30DPoolRevenue = map30DPoolRevenue+(_fee);
        }
    }

    function addRevenue(uint _totalRev) internal {
        if(!(revenueArray.length == 2)){
            revenueArray.push(_totalRev);
        } else {
            addFee(_totalRev);
        }
    }

    function addFee(uint _rev) internal {
        uint _n = revenueArray.length; 
        for (uint i = _n - 1; i > 0; i--) {
            revenueArray[i] = revenueArray[i - 1];
        }
        revenueArray[0] = _rev;
    }
}",3337.0,4,1,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `add`, `addForMember`, `remove`, `removeForMember`, `swapTo`, `mintSynth`, and `burnSynth` can be called by any user. They lack explicit access control, which might lead to unauthorized operations like manipulation of liquidity pools, token swaps, and synth minting/burning."",
      ""Impact"": ""Unauthorized users could manipulate liquidity pools, perform swaps, or mint/burn synths, potentially leading to financial loss or disruption of the protocol."",
      ""Location"": ""Functions `add`, `addForMember`, `remove`, `removeForMember`, `swapTo`, `mintSynth`, `burnSynth`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The identified functions lack access control mechanisms, which is a critical security flaw allowing unauthorized users to alter pool states and perform financial operations.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in Token Transfers"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `transferAndCall` and `approveAndCall` functions involve calling external contracts (`iBEP677.onTokenTransfer` and `iBEP677.onTokenApproval`) which could potentially lead to reentrancy attacks if those external contracts are malicious."",
      ""Impact"": ""A malicious contract could exploit this to perform reentrancy attacks, potentially draining funds from the pool or causing other unintended behaviors."",
      ""Location"": ""Functions `transferAndCall` and `approveAndCall`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The interaction with external contracts without reentrancy protection poses a significant security risk, making this finding technically valid and relevant.""
    },
    {
      ""Issue"": ""Lack of Input Validation in Key Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions such as `addForMember`, `removeForMember`, `swap`, and `swapTo` do not validate input amounts, potentially allowing zero or maliciously structured inputs."",
      ""Impact"": ""This can lead to unintended state changes or other unexpected behaviors if invalid inputs are processed, potentially causing loss of funds or failed transactions."",
      ""Location"": ""Functions `addForMember`, `removeForMember`, `swap`, `swapTo`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Input validation is critical for contract robustness and preventing erroneous behavior, making this finding relevant and accurate.""
    },
    {
      ""Issue"": ""Inadequate Event Emission for State-Changing Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""State-changing functions such as `_incrementPoolBalances`, `_decrementPoolBalances`, and `_setPoolAmounts` do not emit events. Emitting events is crucial for off-chain monitoring and debugging."",
      ""Impact"": ""Without events, it becomes difficult to track changes in the pool's state, hindering transparency and auditability."",
      ""Location"": ""Functions `_incrementPoolBalances`, `_decrementPoolBalances`, `_setPoolAmounts`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The absence of events for critical state changes impacts transparency and is a valid concern for auditability and monitoring.""
    }
  ],
  ""FindingNumber"": 4,
  ""AllRelevance"": 32,
  ""RelevanceCount"": 29,
  ""AllValidation"": 32,
  ""ValidationCount"": 31
}","### **Comparison of Issue Report and Response List**

---

#### **[H-02] Pool.sol & Synth.sol: Failing Max Value Allowance**

**Report Description**:  
In the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (i.e., the allowance remains at the previous value). This behavior is problematic because contract integrations (e.g., DEXes) often hardcode this value to set maximum allowance initially, but this will result in zero allowance being given instead. The comment `// No need to re-approve if already max` is misleading because the max attainable allowance is `type(uint256).max - 1`. This issue also affects the `approveAndCall` implementation, which uses `type(uint256).max` as the allowance amount, resulting in zero allowance being set.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem with the `_approve` function's handling of `type(uint256).max` and its impact on `approveAndCall` is not mentioned. This is a critical oversight, as it directly affects contract integrations and user expectations.

---

#### **[H-07] Missing Slippage Checks**

**Report Description**:  
There are no minimum amounts out or checks to mitigate frontrunning/slippage. This allows anyone with sufficient capital to force arbitrarily large slippage by sandwiching transactions, potentially close to 100%. The recommendation is to add a minimum amount out parameter, with the function reverting if the minimum amount is not obtained.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the lack of slippage checks. This is a significant vulnerability, as it exposes users to potential financial losses due to frontrunning attacks. The absence of this issue in the response list is a notable gap.

---

#### **[H-09] Arbitrary Synth Mint/Burn from Pool**

**Report Description**:  
The `mintSynth` function in `Pool` allows arbitrary minting of `Synth` as long as it is a valid synth. When there are multiple curated pools and synths, hackers can mint expensive synthetics from a cheaper AMM pool, burn the minted synth at the expensive pool, and profit. This arbitrage can be amplified with flash loans, potentially breaking all pegs. The issue involves `Pool`'s `mintSynth` logic, `Synth`'s `mintSynth` logic, and `Synth`'s authorization logic. The price of synthetics to be minted is calculated in `Pool` based on the AMM price of the current pool.

**Match in Response List**:  
**Partially matches** with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:  
**Correct**. The response identifies the lack of access control on `mintSynth` but does not address the arbitrage vulnerability or the specific risks associated with minting expensive synthetics from cheaper pools. The response misses critical details about the economic impact and the potential for flash loan exploitation.

---

#### **[H-11] Misuse of AMM Model on Minting Synth**

**Report Description**:  
`Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the pool. However, since `token_amount` in the pool does not decrease when users mint `Synth`, it is always cheaper to mint `Synth` than to swap tokens. This makes it difficult for synthetics to maintain their peg and creates opportunities for flash loan attackers to exploit arbitrage. The `Synth` amount is calculated using the same formula as swapping base to token.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The misuse of the AMM model for minting `Synth` and its implications for peg stability and arbitrage are not covered. This is a significant oversight, as it directly impacts the protocol's economic model.

---

#### **[M-06] Pool: `approveAndCall` Sets Unnecessary Approval**

**Report Description**:  
The `Pool.approveAndCall` function approves the `recipient` contract with the max value instead of only the required `amount`. For safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, as is the case for `approveAndCall`.

**Match in Response List**:  
**Partially matches** with the issue titled **""Potential Reentrancy Vulnerability in Token Transfers""**.

**Validation**:  
**Correct**. The response identifies the potential reentrancy vulnerability in `approveAndCall` but does not address the unnecessary approval of the max value. The response misses the specific issue of over-approval, which is a separate security concern.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[H-09] Arbitrary Synth Mint/Burn from Pool**  
- **[M-06] Pool: `approveAndCall` Sets Unnecessary Approval**

**Partially Correct Matches**:  
- *None*  

**Missed Issues from Issue Report**:  
- **[H-02] Pool.sol & Synth.sol: Failing Max Value Allowance**  
- **[H-07] Missing Slippage Checks**  
- **[H-11] Misuse of AMM Model on Minting Synth**

---

### **Conclusion**  
The response list partially addresses some issues but misses critical vulnerabilities such as the handling of `type(uint256).max` in `_approve`, the lack of slippage checks, and the misuse of the AMM model for minting `Synth`. These gaps indicate a need for a more comprehensive review of the protocol's security posture.",2,0,3,4,32,"```
1. Lack of Access Control on Critical Functions 2. Potential Reentrancy Vulnerability in Token Transfers
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Lack of Access Control on Critical Functions"" appears at rank 1.
   - ""Potential Reentrancy Vulnerability in Token Transfers"" appears at rank 2.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 2: \( P@2 = \frac{2}{2} = 1.0 \)

3. **Average the precision values to compute the Average Precision (AP)**:
   - \( AP = \frac{1.0 + 1.0}{2} = 1.0 \)

**Output**:
```
1.0
```"
DAO.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)
    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised
    uint256 public proposalCount;   // Count of proposals
    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3
    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives
    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially
    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially
    uint256 public currentProposal; // The most recent proposal; should be === proposalCount
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets
    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    //==================================== PROTOCOL CONTRACTs SETTER =================================//

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    // Can purge deployer once DAO is stable and final
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    // Can change vesting period for bonders
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    //============================== USER - DEPOSIT/WITHDRAW ================================//

    // User deposits LP tokens in the DAOVault
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    // Contract deposits LP tokens for member
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); // Pool must be Curated
        require(amount > 0, ""!amount""); // Deposit amount must be valid
        if (isMember[member] != true) {
            arrayMembers.push(member); // If not a member; add user to member array
            isMember[member] = true; // If not a member; register the user as member
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); // Send user's deposit to the DAOVault
        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight
        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time
        emit MemberDeposits(member, pool, amount);
    }
    
    // User withdraws all of their selected asset from the DAOVault
    function withdraw(address pool) external {
        removeVote(); // Users weight is removed from the current open DAO proposal
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); // User receives their withdrawal
    }

    //============================== REWARDS ================================//
    
    // User claims their DAOVault incentives
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); // Reserve must have emissions turned on
        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE
        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)
        if(reward > daoReward){
            reward = daoReward; // User cannot claim more than the daoReward limit
        }
        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user
    }

    // Calculate the user's current incentive-claim per era
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim
        uint share = calcReward(member); // Get share of rewards for user
        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed
        return reward;
    }

    // Calculate the user's current total claimable incentive
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days
        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that
        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)
    }

    //================================ BOND Feature ==================================//

    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    // List an asset to be enabled for Bonding
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; // Register as a currently enabled asset
            listedBondAssets.push(asset); // Add to historical record of past Bond assets
        }
        emit ListedAsset(msg.sender, asset);
    }

    // Delist an asset from the Bond program
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; // Unregister as a currently enabled asset
        emit DelistedAsset(msg.sender, asset);
    }

    // User deposits assets to be Bonded
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); // Amount must be valid
        require(isListed[asset], '!listed'); // Asset must be listed for Bond
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array
            isMember[msg.sender] = true; // Register user as a member
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    // Add Bonded assets as liquidity and calculate LP units
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens
        } 
    }

    // User claims all of their unlocked Bonded LPs
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; // Get array of bond assets
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked
            }
        }
        return true;
    }

    // User claims unlocked Bond units of a selected asset
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked
        }
        return true;
    }
    
    // Calculate user's unlocked Bond units of a selected asset
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs
        return claimAmount;
    }

    //============================== CREATE PROPOSALS ================================//

    // New ID, but specify type, one type for each function call
    // Votes counted to IDs
    // IDs are finalised
    // IDs are executed, but type specifies unique logic

    // New DAO proposal: Simple action
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: uint parameter
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_param[currentProposal] = param; // Set the proposed parameter
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Address parameter
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Grant SPARTA to wallet
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient
        mapPID_param[currentProposal] = amount; // Set the proposed grant amount
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // If no existing open DAO proposal; register a new one
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal
        proposalCount += 1; // Increase proposal count
        currentProposal = proposalCount; // Set current proposal to the new count
        mapPID_open[currentProposal] = true; // Set new proposal as open status
        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now
    }
    
    // Pay the fee for a new DAO proposal
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee
        return true;
    } 

    //============================== VOTE && FINALISE ================================//

    // Vote for a proposal
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); // Proposal must be open status
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeight = countVotes(); // Vote for proposal and recount
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase
                }
            } else {
                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    // Remove vote from a proposal
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    // Push the proposal into 'finalising' status
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        mapPID_finalising[currentProposal] = true; // Set finalising status to true
        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    // Attempt to cancel the open proposal
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); // Proposal must not be new
        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal
        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)
        emit CancelProposal(msg.sender, currentProposal);
    }

    // A finalising-stage proposal can be finalised after the cool off period
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); // Must be past cooloff period
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); // Must be in finalising stage
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    // Change the DAO to a new contract address
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        DAO = _proposedAddress; // Change the DAO to point to the new DAO address
        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address
        daoHasMoved = true; // Set status of this old DAO
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the ROUTER to a new contract address
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the UTILS to a new contract address
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the RESERVE to a new contract address
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Flip the BASE emissions on/off
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change cool off period (Period of time until a finalising proposal can be finalised)
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        coolOffPeriod = _proposedParam; // Change coolOffPeriod
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change erasToEarn (Used to regulate the incentives flow)
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        erasToEarn = _proposedParam; // Change erasToEarn
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Grant SPARTA to the proposed recipient
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient
        require(_proposedAmount != 0, ""!param""); // Proposed grant amount must be valid
        require(_proposedAddress != address(0), ""!address""); // Proposed recipient must be valid
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Mint a 2.5M SPARTA allocation for the Bond program
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold
        completeProposal(_proposalID); // Finalise the proposal
    }

    // List an asset to be enabled for Bonding
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; // Register asset as listed for Bond
            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets
        }
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Delist an asset from being allowed to Bond
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Add a pool as 'Curated' to enable synths, weight and incentives
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Remove a pool from Curated status
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal
        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }
    
    // After completing the proposal's action; close it
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0
        mapPID_finalised[_proposalID] = true; // Finalise the proposal
        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage
        mapPID_open[_proposalID] = false; // Close the proposal
    }

    //============================== CONSENSUS ================================//
    
    // Add user's total weight to proposal and recount
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights
        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)
        return voteWeight;
    }

    // Check if a proposal has Majority consensus
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Quorum consensus
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 2; // Quorum > 50%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Minority consensus
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 6; // Minority > 16.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    //======================================PROTOCOL CONTRACTs GETTER=================================//
    
    // Get the ROUTER address that the DAO currently points to
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    // Get the UTILS address that the DAO currently points to
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    // Get the BONDVAULT address that the DAO currently points to
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    // Get the DAOVAULT address that the DAO currently points to
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    // Get the POOLFACTORY address that the DAO currently points to
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    // Get the SYNTHFACTORY address that the DAO currently points to
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    // Get the RESERVE address that the DAO currently points to
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    // Get the SYNTHVAULT address that the DAO currently points to
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    //============================== HELPERS ================================//
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }
    }
}",8040.0,725.0,"[H-03] Result of transfer / transferFrom not checked
A call to `transferFrom` or `transfer` is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of ""false"" is returned. It's important to check this. If you don't, you could mint tokens without have received sufficient tokens to do so and could loose funds. Its also a best practice to check this.[M-01] Dao.sol: Insufficient validation for proposal creation
In general, creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions.
- The `typeStr` is not validated at all. For example, one can call `newActionProposal()` with `typeStr = ROUTER` or `typeStr = BAD_STRING`, both of which will pass. The first will cause `finaliseProposal()` to fail because the proposed address is null, preventing `completeProposal()` from executing. The second does nothing because it does not equate to any of the check typeStr, and so completeProposal() isn't executed at all.
- Not checking the proposed values are null. The checks only happen in `finaliseProposal()` when the relevant sub-functions are called, like the `move*()` functions.

[M-02] Missleading onlyDAO modifiersSeveral contracts implement an `onlyDAO` modifier which, as the name suggests, should only authorize the function to be executed by the DAO. However, some implementations are wrong and either allow the DAO or the deployer to execute, or even only the deployer:The deployer may execute the function as well which is a centralization risk. The deployer can only sometimes be purged, as in synthFactory, in which case nobody can execute these functions anymore.

[M-03] Improper access control of claimAllForMember allows anyone to reduce the weight of a member
The `claimAllForMember` function of `Dao` is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member's LP tokens could decrease the member's weight in the `BondVault`, thus affecting the member's votes and rewards in the `Dao` contract.

[M-10] `grantFunds` will revert after a DAO upgrade.
When the DAO is upgraded via `moveDao`, it also updates the DAO address in BASE. However it doesn't update the DAO address in the Reserve.sol contract. This could be done with the function setIncentiveAddresses(..)
Now the next time `grantFunds` of DAO.sol is called, its tries to call `_RESERVE.grantFunds(...)`
The grantFunds of Reserve.sol has the modifier onlyGrantor(), which checks the `msg.sender` == DAO. However in the mean time, the DAO has been updated and Reserve.sol doesn't know about it and thus the modifier will not allow access to the function. Thus grantFunds will revert.",5.0,"pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   
    uint256 public coolOffPeriod;   
    uint256 public proposalCount;   
    uint256 public majorityFactor;  
    uint256 public erasToEarn;      
    uint256 public daoClaim;        
    uint256 public daoFee;          
    uint256 public currentProposal; 
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; 
    uint256 public bondingPeriodSeconds = 15552000; 
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; 
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    

    
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); 
        require(amount > 0, ""!amount""); 
        if (isMember[member] != true) {
            arrayMembers.push(member); 
            isMember[member] = true; 
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); 
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); 
        _DAOVAULT.depositLP(pool, amount, member); 
        mapMember_lastTime[member] = block.timestamp; 
        emit MemberDeposits(member, pool, amount);
    }
    
    
    function withdraw(address pool) external {
        removeVote(); 
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); 
    }

    
    
    
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); 
        uint reward = calcCurrentReward(msg.sender); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); 
        uint daoReward = (reserve * daoClaim) / 10000; 
        if(reward > daoReward){
            reward = daoReward; 
        }
        _RESERVE.grantFunds(reward, msg.sender); 
    }

    
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; 
        uint share = calcReward(member); 
        uint reward = (share * secondsSinceClaim) / secondsPerEra; 
        return reward;
    }

    
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; 
        uint daoReward = (reserve * daoClaim) / 10000; 
        return _UTILS.calcShare(weight, _totalWeight, daoReward); 
    }

    

    
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; 
            listedBondAssets.push(asset); 
        }
        emit ListedAsset(msg.sender, asset);
    }

    
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; 
        emit DelistedAsset(msg.sender, asset);
    }

    
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); 
        require(isListed[asset], '!listed'); 
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); 
            isMember[msg.sender] = true; 
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); 
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); 
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); 
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); 
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); 
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); 
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } 
    }

    
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; 
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); 
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); 
            }
        }
        return true;
    }

    
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); 
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); 
        }
        return true;
    }
    
    
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); 
        return claimAmount;
    }

    

    
    
    
    

    
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_param[currentProposal] = param; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_address[currentProposal] = proposedAddress; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); 
        payFee(); 
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; 
        mapPID_address[currentProposal] = recipient; 
        mapPID_param[currentProposal] = amount; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); 
        proposalCount += 1; 
        currentProposal = proposalCount; 
        mapPID_open[currentProposal] = true; 
        mapPID_startTime[currentProposal] = block.timestamp; 
    }
    
    
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); 
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); 
        return true;
    } 

    

    
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); 
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeight = countVotes(); 
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); 
                }
            } else {
                _finalise(); 
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; 
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; 
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; 
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        mapPID_finalising[currentProposal] = true; 
        mapPID_coolOffTime[currentProposal] = block.timestamp; 
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); 
        mapPID_votes[currentProposal] = 0; 
        mapPID_open[currentProposal] = false; 
        emit CancelProposal(msg.sender, currentProposal);
    }

    
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); 
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); 
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; 
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); 
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        DAO = _proposedAddress; 
        iBASE(BASE).changeDAO(_proposedAddress); 
        daoHasMoved = true; 
        completeProposal(_proposalID); 
    }

    
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _ROUTER = iROUTER(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _UTILS = iUTILS(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE = iRESERVE(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); 
        completeProposal(_proposalID); 
    }

    
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        coolOffPeriod = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        erasToEarn = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; 
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAmount != 0, ""!param""); 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; 
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); 
        completeProposal(_proposalID); 
    }

    
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; 
            listedBondAssets.push(_proposedAddress); 
        }
        completeProposal(_proposalID); 
    }

    
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        isListed[_proposedAddress] = false; 
        completeProposal(_proposalID); 
    }

    
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.addCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.removeCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }
    
    
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; 
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; 
        mapPID_finalised[_proposalID] = true; 
        mapPID_finalising[_proposalID] = false; 
        mapPID_open[_proposalID] = false; 
    }

    
    
    
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; 
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); 
        mapPID_votes[currentProposal] += voteWeight; 
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; 
        return voteWeight;
    }

    
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight * majorityFactor / 10000; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 2; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 6; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }
    }
}",5823.0,1,4,"{
  ""Findings"": [
    {
      ""Issue"": ""Centralized Control and Inadequate Access Control on DAO Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The DAO contract relies on the `onlyDAO` modifier, restricting functions to the deployer address. This centralizes control and poses security risks if the DAO address is compromised. Additionally, functions like `setGenesisAddresses`, `purgeDeployer`, `moveBASEBalance`, and others are inadequately protected, relying solely on the deployer address for access control."",
      ""Impact"": ""A compromised DAO address could lead to unauthorized execution of sensitive functions, resulting in potential loss of control and unauthorized state changes."",
      ""Location"": ""Functions with `onlyDAO` modifier such as `setGenesisAddresses`, `purgeDeployer`, `moveBASEBalance`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant and valid as it highlights critical risks in centralized and inadequate access control mechanisms.""
    },
    {
      ""Issue"": ""Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Functions `depositLPForMember` and `withdraw` make external calls without reentrancy guards, exposing the contract to potential reentrancy attacks if the external contracts are malicious."",
      ""Impact"": ""Exploitation could lead to repeated function calls, manipulating state, unauthorized fund withdrawals, and potential fund losses."",
      ""Location"": ""Functions `depositLPForMember` and `withdraw` in the Dao contract."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it addresses reentrancy vulnerabilities, which are a critical security concern.""
    },
    {
      ""Issue"": ""Lack of Proper Error Handling in External Calls"",
      ""Severity"": ""High"",
      ""Description"": ""The contract does not check return values from external calls to interfaces like `iROUTER`, `iUTILS`, and `iRESERVE`, risking unexpected behavior if these calls fail."",
      ""Impact"": ""Failure of external contract calls may lead to inconsistent contract states or loss of funds."",
      ""Location"": ""Functions like `depositLPForMember`, `harvest`, `handleTransferIn`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Proper error handling in external interactions is crucial for contract security, making this finding relevant and technically valid.""
    },
    {
      ""Issue"": ""Incorrect Reward Calculation in Harvest Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `harvest` function calculates rewards without ensuring `daoReward` sufficiency, potentially leading to over-distribution and depletion of reserves."",
      ""Impact"": ""Could result in unfair reward allocation and accelerated reserve depletion."",
      ""Location"": ""Function `harvest` line 119-131."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The issue is relevant and valid as it identifies a critical flaw in reward calculation logic.""
    },
    {
      ""Issue"": ""Inconsistent Role Management and Ineffective Deployer Privilege Removal"",
      ""Severity"": ""Medium"",
      ""Description"": ""The DAO's role management heavily relies on the deployer. Incorrect handling of transition to a new DAO or purging of the deployer can lead to inconsistencies and frozen functionalities."",
      ""Impact"": ""Unauthorized access or loss of DAO control. Ineffective privilege removal could block legitimate operations."",
      ""Location"": ""Role transition functions and `purgeDeployer`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding identifies significant risks in role management and privilege handling.""
    },
    {
      ""Issue"": ""Potential Risks in Role and Asset Transition Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `moveBASEBalance` and others handling critical transitions rely on the `onlyDAO` modifier. Compromise of the deployer role can lead to unauthorized asset transfers."",
      ""Impact"": ""Unauthorized transitions may result in asset loss or loss of control over the DAO."",
      ""Location"": ""Functions such as `moveBASEBalance`, `listBondAsset`, `delistBondAsset`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Addresses potential unauthorized asset movement risk due to improper role management.""
    },
    {
      ""Issue"": ""Proposal Logic and Finalization Vulnerabilities"",
      ""Severity"": ""Medium"",
      ""Description"": ""Proposal finalization logic does not adequately handle timing and conditions, potentially allowing premature or incorrect finalizations."",
      ""Impact"": ""Could result in unauthorized or unexpected changes in DAO governance settings."",
      ""Location"": ""Function `finaliseProposal` line 354-408."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Identifies vulnerabilities in proposal finalization that could disrupt governance.""
    },
    {
      ""Issue"": ""Violation of Checks-Effects-Interactions Pattern"",
      ""Severity"": ""Medium"",
      ""Description"": ""Some functions do not follow the Checks-Effects-Interactions pattern, which could lead to reentrancy vulnerabilities."",
      ""Impact"": ""Vulnerable to reentrancy attacks causing fund loss or incorrect state updates."",
      ""Location"": ""Functions `depositLPForMember` and `handleTransferIn`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Following the pattern is crucial for preventing reentrancy attacks.""
    },
    {
      ""Issue"": ""Potential for Sybil and Majority Attacks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The DAO's governance mechanism lacks protection against Sybil attacks, where an attacker gains disproportionate influence, and majority attacks that manipulate proposals."",
      ""Impact"": ""Could lead to malicious proposals being passed, compromising DAO integrity."",
      ""Location"": ""Voting-related functions like `voteProposal`, `removeVote`, and `countVotes`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Addressing these threats enhances DAO robustness and security.""
    },
    {
      ""Issue"": ""Arithmetic Operations Without SafeMath"",
      ""Severity"": ""Medium"",
      ""Description"": ""Lack of explicit SafeMath usage for arithmetic operations could lead to misunderstandings, especially if contracts are downgraded."",
      ""Impact"": ""Potential arithmetic errors affecting contract logic and security."",
      ""Location"": ""Various arithmetic operations throughout the Dao contract."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Explicit SafeMath usage enhances clarity and compatibility.""
    },
    {
      ""Issue"": ""Dependency on External Contract Implementations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Reliance on external interfaces like `iROUTER`, `iUTILS`, and `iRESERVE` poses risks if these contracts change or are deprecated."",
      ""Impact"": ""Unexpected external contract changes could lead to DAO operation failures."",
      ""Location"": ""External interfaces declared and used throughout the contract."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""External dependencies are integral to contract functionality and stability.""
    },
    {
      ""Issue"": ""Lack of Upgradeability Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks an upgradeability mechanism, like proxy patterns, crucial for adapting to changes or fixing vulnerabilities."",
      ""Impact"": ""DAO may become obsolete or vulnerable if unpatchable vulnerabilities are discovered."",
      ""Location"": ""Overall contract architecture lacks upgradeability design."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Upgradeability is essential for long-term contract maintenance and security.""
    },
    {
      ""Issue"": ""Lack of Access Control on Certain Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `claimForMember` and `claimAllForMember` are publicly accessible and might not be intended."",
      ""Impact"": ""Unauthorized users could trigger actions on behalf of others, leading to undesirable outcomes."",
      ""Location"": ""Functions `claimAllForMember` and `claimForMember` in the Dao contract."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Access control issues are crucial for security, identifying publicly accessible functions that may need restricted access.""
    },
    {
      ""Issue"": ""Inefficient Gas Usage"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions have inefficient gas usage due to redundant state updates and calculations, such as in `depositLPForMember`, `claimAllForMember`, `removeVote`, and repeated calculation of total weight."",
      ""Impact"": ""Increased gas costs and reduced efficiency."",
      ""Location"": ""Functions like `depositLPForMember`, `claimAllForMember`, `removeVote`, and others."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Optimizing these operations is relevant for improving gas efficiency.""
    },
    {
      ""Issue"": ""Inadequate Validation in Proposal Creation"",
      ""Severity"": ""Low"",
      ""Description"": ""Minimal validation of input parameters in proposal creation functions could lead to proposals with invalid or nonsensical data."",
      ""Impact"": ""Could lead to cluttered proposal logs or unnecessary processing of invalid proposals."",
      ""Location"": ""Functions `newActionProposal`, `newParamProposal`, `newAddressProposal`, `newGrantProposal`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring proper validation helps maintain clean and meaningful proposal logs.""
    }
  ],
  ""FindingNumber"": 15,
  ""AllRelevance"": 27,
  ""RelevanceCount"": 27,
  ""AllValidation"": 27,
  ""ValidationCount"": 27
}","### **Comparison of Issue Report and Response List**

---

#### **[H-03] Result of transfer / transferFrom not checked**

**Report Description**:  
The issue highlights that calls to `transferFrom` or `transfer` are frequently made without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs, but a result of ""false"" is returned. This oversight could lead to minting tokens without receiving sufficient tokens, resulting in fund loss. It is a best practice to check the return value of such calls.

**Match in Response List**:  
Matches with the issue titled **""Lack of Proper Error Handling in External Calls""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unchecked return values from external calls, including `transfer` and `transferFrom`. It correctly explains the risks associated with not validating these return values, which aligns with Solidity best practices for secure contract interactions.

---

#### **[M-01] Dao.sol: Insufficient validation for proposal creation**

**Report Description**:  
The issue points out that creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions. Specifically:
- The `typeStr` is not validated, allowing nonsensical or invalid values.
- Proposed values are not checked for null, leading to potential failures in `finaliseProposal()`.

**Match in Response List**:  
Matches with the issue titled **""Inadequate Validation in Proposal Creation""**.

**Validation**:  
**Correct**. The response correctly identifies the lack of validation in proposal creation functions, which could lead to invalid or nonsensical proposals. It highlights the importance of proper input validation to maintain clean and meaningful proposal logs.

---

#### **[M-02] Misleading onlyDAO modifiers**

**Report Description**:  
The issue reveals that the `onlyDAO` modifier in several contracts is misleading. Some implementations allow the deployer to execute functions instead of restricting access solely to the DAO. This centralization risk could lead to unauthorized execution of sensitive functions if the deployer is compromised.

**Match in Response List**:  
Matches with the issue titled **""Centralized Control and Inadequate Access Control on DAO Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the centralization risk and inadequate access control associated with the `onlyDAO` modifier. It correctly explains the potential impact of a compromised deployer address, which aligns with the issue report.

---

#### **[M-03] Improper access control of claimAllForMember allows anyone to reduce the weight of a member**

**Report Description**:  
The issue highlights that the `claimAllForMember` function in the `Dao` contract is permissionless, allowing anyone to claim unlocked bonded LP tokens for any member. This could decrease the member's weight in the `BondVault`, affecting their votes and rewards.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Certain Functions""**.

**Validation**:  
**Correct**. The response correctly identifies the lack of access control on the `claimAllForMember` function, which could lead to unauthorized actions. It highlights the importance of restricting access to such functions to prevent undesirable outcomes.

---

#### **[M-10] grantFunds will revert after a DAO upgrade**

**Report Description**:  
The issue explains that when the DAO is upgraded via `moveDao`, the DAO address in the `Reserve.sol` contract is not updated. This causes the `grantFunds` function to revert because the `onlyGrantor` modifier checks the `msg.sender` against the outdated DAO address.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this specific issue, which highlights a critical oversight in updating the DAO address in the `Reserve.sol` contract after an upgrade.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-03] Result of transfer / transferFrom not checked**
- **[M-01] Dao.sol: Insufficient validation for proposal creation**
- **[M-02] Misleading onlyDAO modifiers**
- **[M-03] Improper access control of claimAllForMember allows anyone to reduce the weight of a member**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-10] grantFunds will revert after a DAO upgrade**

---

### **Conclusion**

The response list effectively addresses most of the issues in the issue report, particularly those related to access control, external call handling, and proposal validation. However, it misses the critical issue of the `grantFunds` function reverting after a DAO upgrade, which could lead to operational failures. This gap should be addressed to ensure comprehensive coverage of the vulnerabilities.",4,0,1,15,27,"```
1. Lack of Proper Error Handling in External Calls
2. Inadequate Validation in Proposal Creation
3. Centralized Control and Inadequate Access Control on DAO Functions
4. Lack of Access Control on Certain Functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Lack of Proper Error Handling in External Calls"" appears at rank 3.
   - ""Inadequate Validation in Proposal Creation"" appears at rank 15.
   - ""Centralized Control and Inadequate Access Control on DAO Functions"" appears at rank 1.
   - ""Lack of Access Control on Certain Functions"" appears at rank 13.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - At rank 3: \( P@3 = \frac{2}{3} \approx 0.6667 \)
   - At rank 13: \( P@13 = \frac{3}{13} \approx 0.2308 \)
   - At rank 15: \( P@15 = \frac{4}{15} \approx 0.2667 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 0.6667 + 0.2308 + 0.2667}{4} = \frac{2.1642}{4} \approx 0.5411
   \]

**Output**:
```
0.5411
```"
Router.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./Pool.sol"";
import ""./interfaces/iRESERVE.sol""; 
import ""./interfaces/iPOOLFACTORY.sol"";  
import ""./interfaces/iWBNB.sol"";

contract Router {
    address public BASE;
    address public WBNB;
    address public DEPLOYER;

    uint private maxTrades;         // Amount of dividend events per era
    uint private eraLength;         // Dividend factor to regulate the max percentage of RESERVE balance
    uint public normalAverageFee;   // The average fee size (dividend smoothing)
    uint private arrayFeeSize;      // The size of the average window used for normalAverageFee
    uint [] private feeArray;       // The array used to calc normalAverageFee
    uint private lastMonth;         // Timestamp of the start of current metric period (For UI)

    mapping(address=> uint) public mapAddress_30DayDividends;
    mapping(address=> uint) public mapAddress_Past30DayPoolDividends;

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base, address _wbnb) {
        BASE = _base;
        WBNB = _wbnb;
        arrayFeeSize = 20;
        eraLength = 30;
        maxTrades = 100;
        lastMonth = 0;
        DEPLOYER = msg.sender;
    }

    receive() external payable {}

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    // User adds liquidity
    function addLiquidity(uint inputBase, uint inputToken, address token) external payable{
        addLiquidityForMember(inputBase, inputToken, token, msg.sender);
    }

    // Contract adds liquidity for user
    function addLiquidityForMember(uint inputBase, uint inputToken, address token, address member) public payable{
        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);  // Get pool address
        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA to pool
        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN to pool
        Pool(pool).addForMember(member); // Add liquidity to pool for user
    }

    // Trade LP tokens for another type of LP tokens
    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(fromPool) == true); // FromPool must be a valid pool
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(toPool) == true); // ToPool must be a valid pool
        address _fromToken = Pool(fromPool).TOKEN(); // Get token underlying the fromPool
        address _member = msg.sender; // Get user's address
        require(unitsInput <= iBEP20(fromPool).totalSupply()); // Input must be valid
        iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); // Transfer LPs from user to the pool
        Pool(fromPool).remove(); // Remove liquidity to ROUTER
        iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); // Transfer TOKENs from ROUTER to fromPool
        Pool(fromPool).swapTo(BASE, toPool); // Swap the received TOKENs for SPARTA then transfer to the toPool
        iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to toPool
        Pool(toPool).addForMember(_member); // Add liquidity and send the LPs to user
    }

    // User adds liquidity asymetrically (one asset)
    function addLiquiditySingle(uint inputToken, bool fromBase, address token) external payable{
        addLiquiditySingleForMember(inputToken, fromBase, token, msg.sender);
    }

    // Contract adds liquidity asymetrically for user (one asset)
    function addLiquiditySingleForMember(uint inputToken, bool fromBase, address token, address member) public payable{
        require(inputToken > 0); // Must be valid input amount
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address
        address _token = token;
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        if(fromBase){
            _handleTransferIn(BASE, inputToken, _pool); // Transfer SPARTA into pool
            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user
        } else {
            _handleTransferIn(token, inputToken, _pool); // Transfer TOKEN into pool
            Pool(_pool).addForMember(member); // Add liquidity and send LPs to user
        }
    }

    // User removes liquidity - redeems a percentage of their balance
    function removeLiquidity(uint basisPoints, address token) external{
        require((basisPoints > 0 && basisPoints <= 10000)); // Must be valid basis points
        uint _units = iUTILS(_DAO().UTILS()).calcPart(basisPoints, iBEP20(iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token)).balanceOf(msg.sender));
        removeLiquidityExact(_units, token);
    }

    // User removes liquidity - redeems exact qty of LP tokens
    function removeLiquidityExact(uint units, address token) public {
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address
        address _member = msg.sender; // The the user's address
        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to the pool
        if(token != address(0)){
            Pool(_pool).removeForMember(_member); // Remove liquidity and send assets directly to user
        } else {
            Pool(_pool).remove(); // If BNB; remove liquidity and send to ROUTER instead
            uint outputBase = iBEP20(BASE).balanceOf(address(this)); // Get the received SPARTA amount
            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); // Get the received WBNB amount
            _handleTransferOut(token, outputToken, _member); // Unwrap to BNB & tsf it to user
            _handleTransferOut(BASE, outputBase, _member); // Transfer SPARTA to user
        }
    }

    // User removes liquidity asymetrically (one asset)
    function removeLiquiditySingle(uint units, bool toBase, address token) external{
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true); // Pool must be valid
        address _member = msg.sender; // Get user's address
        iBEP20(_pool).transferFrom(_member, _pool, units); // Transfer LPs to pool
        Pool(_pool).remove(); // Remove liquidity & tsf to ROUTER
        address _token = token; // Get token address
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        if(toBase){
            iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); // Transfer TOKEN to pool
            Pool(_pool).swapTo(BASE, _member); // Swap TOKEN for SPARTA & tsf to user
        } else {
            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA to pool
            Pool(_pool).swap(_token); // Swap SPARTA for TOKEN & transfer to ROUTER
            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); // Send TOKEN to user
        } 
    }

    //============================== Swapping Functions ====================================//
    
    // Swap SPARTA for TOKEN
    function buyTo(uint amount, address token, address member) public {
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get the pool address
        _handleTransferIn(BASE, amount, _pool); // Transfer SPARTA to pool
        uint fee;
        if(token != address(0)){
            (, uint feey) = Pool(_pool).swapTo(token, member); // Swap SPARTA to TOKEN & tsf to user
            fee = feey;
        } else {
            (uint outputAmount, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB
            _handleTransferOut(token, outputAmount, member); // Unwrap to BNB & tsf to user
            fee = feez;
        }
        getsDividend(_pool, fee); // Check for dividend & tsf it to pool
    }

    // Swap TOKEN for SPARTA
    function sellTo(uint amount, address token, address member) public payable returns (uint){
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address
        _handleTransferIn(token, amount, _pool); // Transfer TOKEN to pool
        (, uint fee) = Pool(_pool).swapTo(BASE, member); // Swap TOKEN to SPARTA & transfer to user
        getsDividend(_pool, fee); // Check for dividend & tsf it to pool
        return fee;
    }

    // User performs a simple swap (to -> from)
    function swap(uint256 inputAmount, address fromToken, address toToken) external payable{
        swapTo(inputAmount, fromToken, toToken, msg.sender);
    }

    // Contract checks which swap function the user will require
    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member) public payable{
        require(fromToken != toToken); // Tokens must not be the same
        if(fromToken == BASE){
            buyTo(inputAmount, toToken, member); // Swap SPARTA to TOKEN & tsf to user
        } else if(toToken == BASE) {
            sellTo(inputAmount, fromToken, member); // Swap TOKEN to SPARTA & tsf to user
        } else {
            address _poolTo = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get pool address
            uint feey = sellTo(inputAmount, fromToken, _poolTo); // Swap TOKEN to SPARTA & tsf to pool
            address _toToken = toToken;
            if(toToken == address(0)){_toToken = WBNB;} // Handle BNB -> WBNB
            (uint _zz, uint _feez) = Pool(_poolTo).swap(_toToken); // Swap SPARTA to TOKEN & tsf to ROUTER
            uint fee = feey+(_feez); // Get total slip fees
            getsDividend(_poolTo, fee); // Check for dividend & tsf it to pool
            _handleTransferOut(toToken, _zz, member); // Transfer TOKEN to user
        }
    }

    // Check if fee should generate a dividend & send it to the pool
    function getsDividend(address _pool, uint fee) internal {
        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){
            addTradeFee(fee); // Add fee to array for avgFee calcs etc
            addDividend(_pool, fee); // Check and tsf dividend to pool
        }
    }

    //============================== Token Transfer Functions ======================================//
    
    // Handle the transfer of assets into the pool
    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){
        if(_amount > 0) {
            if(_token == address(0)){
                require((_amount == msg.value));
                (bool success, ) = payable(WBNB).call{value: _amount}(""""); // Wrap BNB
                require(success, ""!send"");
                iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool
                actual = _amount;
            } else {
                uint startBal = iBEP20(_token).balanceOf(_pool); // Get prior TOKEN balance of pool
                iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool
                actual = iBEP20(_token).balanceOf(_pool)-(startBal); // Get received TOKEN amount
            }
        }
    }

    // Handle the transfer of assets out of the ROUTER
    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal {
        if(_amount > 0) {
            if (_token == address(0)) {
                iWBNB(WBNB).withdraw(_amount); // Unwrap WBNB to BNB
                (bool success, ) = payable(_recipient).call{value:_amount}("""");  // Send BNB to recipient
                require(success, ""!send"");
            } else {
                iBEP20(_token).transfer(_recipient, _amount); // Transfer TOKEN to recipient
            }
        }
    }

    //================================ Swap Synths ========================================//
    
    // Swap TOKEN to Synth
    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {
        require(fromToken != toSynth); // Tokens must not be the same
        address _synthLayer1 = iSYNTH(toSynth).LayerONE(); // Get underlying token's address
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthLayer1); // Get relevant pool address
        if(fromToken != BASE){
            sellTo(inputAmount, fromToken, address(this)); // Swap TOKEN to SPARTA & tsf to ROUTER
            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); // Transfer SPARTA from ROUTER to pool
        } else {
            iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); // Transfer SPARTA from ROUTER to pool
        }
        (, uint fee) = Pool(_pool).mintSynth(toSynth, msg.sender); // Mint synths & tsf to user
        getsDividend(_pool, fee); // Check and tsf dividend to pool
    }
   
    // Swap Synth to TOKEN
    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {
        require(fromSynth != toToken); // Tokens must not be the same
        address _synthINLayer1 = iSYNTH(fromSynth).LayerONE(); // Get synth's underlying token's address
        address _poolIN = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthINLayer1); // Get synth's relevant pool address
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); // Get TOKEN's relevant pool address
        iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); // Transfer synth from user to pool
        uint outputAmount; uint fee;
        if(toToken == BASE){
            Pool(_poolIN).burnSynth(fromSynth, msg.sender); // Swap Synths for SPARTA & tsf to user
        } else {
            (outputAmount,fee) = Pool(_poolIN).burnSynth(fromSynth, address(this)); // Swap Synths to SPARTA & tsf to ROUTER
            if(toToken != address(0)){
                (, uint feey) = Pool(_pool).swapTo(toToken, msg.sender); // Swap SPARTA to TOKEN & transfer to user
                fee = feey + fee;
            } else {
                (uint outputAmountY, uint feez) = Pool(_pool).swap(WBNB); // Swap SPARTA to WBNB & tsf to ROUTER
                _handleTransferOut(toToken, outputAmountY, msg.sender); // Unwrap to BNB & tsf to user
                fee = feez + fee;
            }
        }
        getsDividend(_pool, fee); // Check and tsf dividend to pool
    }
    
    //============================= Token Dividends / Curated Pools =================================//
    
    // Calculate the Dividend and transfer it to the pool
    function addDividend(address _pool, uint256 _fees) internal {
        if(!(normalAverageFee == 0)){
            uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); // Get SPARTA balance in the RESERVE contract
            if(!(reserve == 0)){
                uint dailyAllocation = (reserve / eraLength) / maxTrades; // Calculate max dividend
                uint numerator = _fees * dailyAllocation;
                uint feeDividend = numerator / (_fees + normalAverageFee); // Calculate actual dividend
                revenueDetails(feeDividend, _pool); // Add to revenue metrics
                iRESERVE(_DAO().RESERVE()).grantFunds(feeDividend, _pool); // Transfer dividend from RESERVE to POOL
                Pool(_pool).sync(); // Sync the pool balances to attribute the dividend to the existing LPers
            }
        }
    }

    // Add fee to feeArray, used to calculate normalAverageFee
    function addTradeFee(uint _fee) internal {
        uint totalTradeFees = 0;
        uint arrayFeeLength = feeArray.length;
        if(arrayFeeLength < arrayFeeSize){
            feeArray.push(_fee); // Build array until it is == arrayFeeSize
        } else {
            addFee(_fee); // If array is required length; shift in place of oldest item
            for(uint i = 0; i < arrayFeeSize; i++){
                totalTradeFees = totalTradeFees + feeArray[i]; // NET sum of feeArray
            }
        }
        normalAverageFee = totalTradeFees / arrayFeeSize; // Calc average fee
    }

    // Shift out oldest fee item and add newest
    function addFee(uint _fee) internal {
        uint n = feeArray.length; // 20
        for (uint i = n - 1; i > 0; i--) {
            feeArray[i] = feeArray[i - 1];
        }
        feeArray[0] = _fee;
    }

    function revenueDetails(uint _fees, address _pool) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ // 30 days
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        } else {
            lastMonth = block.timestamp;
            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];
            mapAddress_30DayDividends[_pool] = 0;
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        }
    }

    function stringToBytes(string memory s) external pure returns (bytes memory){
        return bytes(s);
    }

    function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){
        if(sha256(part1) == sha256(part2)){
            return true;
        }
    }
    
    //======================= Change Dividend Variables ===========================//

    function changeArrayFeeSize(uint _size) external onlyDAO {
        arrayFeeSize = _size;
        delete feeArray;
    }

    function changeMaxTrades(uint _maxtrades) external onlyDAO {
        maxTrades = _maxtrades;
    }

    function changeEraLength(uint _eraLength) external onlyDAO {    
        eraLength = _eraLength; 
    }

    //================================== Helpers =================================//

    function currentPoolRevenue(address pool) external view returns(uint256) {
        return mapAddress_30DayDividends[pool];
    }

    function pastPoolRevenue(address pool) external view returns(uint256) {
        return mapAddress_Past30DayPoolDividends[pool];
    }
}",4449.0,357.0,"[H-04] Members lose SPARTA tokens in removeLiquiditySingle()When a member calls `removeLiquiditySingle()` requesting only SPARTA in return, i.e. `toBASE = true`, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.
In other words, the `_member`'s BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the _member because the _token's transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via swapTo().
This effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.

[H-07] Missing slippage checks
There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated. This means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.
Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.

[H-08] Dividend reward can be gamedThe `Router.addDividend` function tells the reserve to send dividends to the pool depending on the fees. - The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent.
    - The normalAverageFee variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool arrayFeeSize (20) times (use buyTo). The fees of the single wei trades will be zero and thus the normalAverageFee will also be zero as, see addTradeFee.
    - The attacker then does a trade that generates some non-zero fees, setting the normalAverageFee to this trade's fee. The feeDividend is then computed as _fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2. Half of the dailyAllocation is sent to the pool.
    - The attacker repeats the above steps until the reserve is almost empty. Each time the dailyAllocation gets smaller but it's still possible to withdraw almost all of it.
    - They redeem their LP tokens and gain a share of the profitsThe reserve can be emptied by the attacker.",3.0,"pragma solidity 0.8.3;
import ""./Pool.sol"";
import ""./interfaces/iRESERVE.sol""; 
import ""./interfaces/iPOOLFACTORY.sol"";  
import ""./interfaces/iWBNB.sol"";

contract Router {
    address public BASE;
    address public WBNB;
    address public DEPLOYER;

    uint private maxTrades;         
    uint private eraLength;         
    uint public normalAverageFee;   
    uint private arrayFeeSize;      
    uint [] private feeArray;       
    uint private lastMonth;         

    mapping(address=> uint) public mapAddress_30DayDividends;
    mapping(address=> uint) public mapAddress_Past30DayPoolDividends;

    
    modifier onlyDAO() {
        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base, address _wbnb) {
        BASE = _base;
        WBNB = _wbnb;
        arrayFeeSize = 20;
        eraLength = 30;
        maxTrades = 100;
        lastMonth = 0;
        DEPLOYER = msg.sender;
    }

    receive() external payable {}

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    
    function addLiquidity(uint inputBase, uint inputToken, address token) external payable{
        addLiquidityForMember(inputBase, inputToken, token, msg.sender);
    }

    
    function addLiquidityForMember(uint inputBase, uint inputToken, address token, address member) public payable{
        address pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);  
        _handleTransferIn(BASE, inputBase, pool); 
        _handleTransferIn(token, inputToken, pool); 
        Pool(pool).addForMember(member); 
    }

    
    function zapLiquidity(uint unitsInput, address fromPool, address toPool) external {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(fromPool) == true); 
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(toPool) == true); 
        address _fromToken = Pool(fromPool).TOKEN(); 
        address _member = msg.sender; 
        require(unitsInput <= iBEP20(fromPool).totalSupply()); 
        iBEP20(fromPool).transferFrom(_member, fromPool, unitsInput); 
        Pool(fromPool).remove(); 
        iBEP20(_fromToken).transfer(fromPool, iBEP20(_fromToken).balanceOf(address(this))); 
        Pool(fromPool).swapTo(BASE, toPool); 
        iBEP20(BASE).transfer(toPool, iBEP20(BASE).balanceOf(address(this))); 
        Pool(toPool).addForMember(_member); 
    }

    
    function addLiquiditySingle(uint inputToken, bool fromBase, address token) external payable{
        addLiquiditySingleForMember(inputToken, fromBase, token, msg.sender);
    }

    
    function addLiquiditySingleForMember(uint inputToken, bool fromBase, address token, address member) public payable{
        require(inputToken > 0); 
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        address _token = token;
        if(token == address(0)){_token = WBNB;} 
        if(fromBase){
            _handleTransferIn(BASE, inputToken, _pool); 
            Pool(_pool).addForMember(member); 
        } else {
            _handleTransferIn(token, inputToken, _pool); 
            Pool(_pool).addForMember(member); 
        }
    }

    
    function removeLiquidity(uint basisPoints, address token) external{
        require((basisPoints > 0 && basisPoints <= 10000)); 
        uint _units = iUTILS(_DAO().UTILS()).calcPart(basisPoints, iBEP20(iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token)).balanceOf(msg.sender));
        removeLiquidityExact(_units, token);
    }

    
    function removeLiquidityExact(uint units, address token) public {
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        address _member = msg.sender; 
        iBEP20(_pool).transferFrom(_member, _pool, units); 
        if(token != address(0)){
            Pool(_pool).removeForMember(_member); 
        } else {
            Pool(_pool).remove(); 
            uint outputBase = iBEP20(BASE).balanceOf(address(this)); 
            uint outputToken = iBEP20(WBNB).balanceOf(address(this)); 
            _handleTransferOut(token, outputToken, _member); 
            _handleTransferOut(BASE, outputBase, _member); 
        }
    }

    
    function removeLiquiditySingle(uint units, bool toBase, address token) external{
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isPool(_pool) == true); 
        address _member = msg.sender; 
        iBEP20(_pool).transferFrom(_member, _pool, units); 
        Pool(_pool).remove(); 
        address _token = token; 
        if(token == address(0)){_token = WBNB;} 
        if(toBase){
            iBEP20(_token).transfer(_pool, iBEP20(_token).balanceOf(address(this))); 
            Pool(_pool).swapTo(BASE, _member); 
        } else {
            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); 
            Pool(_pool).swap(_token); 
            _handleTransferOut(token, iBEP20(_token).balanceOf(address(this)), _member); 
        } 
    }

    
    
    
    function buyTo(uint amount, address token, address member) public {
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        _handleTransferIn(BASE, amount, _pool); 
        uint fee;
        if(token != address(0)){
            (, uint feey) = Pool(_pool).swapTo(token, member); 
            fee = feey;
        } else {
            (uint outputAmount, uint feez) = Pool(_pool).swap(WBNB); 
            _handleTransferOut(token, outputAmount, member); 
            fee = feez;
        }
        getsDividend(_pool, fee); 
    }

    
    function sellTo(uint amount, address token, address member) public payable returns (uint){
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); 
        _handleTransferIn(token, amount, _pool); 
        (, uint fee) = Pool(_pool).swapTo(BASE, member); 
        getsDividend(_pool, fee); 
        return fee;
    }

    
    function swap(uint256 inputAmount, address fromToken, address toToken) external payable{
        swapTo(inputAmount, fromToken, toToken, msg.sender);
    }

    
    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member) public payable{
        require(fromToken != toToken); 
        if(fromToken == BASE){
            buyTo(inputAmount, toToken, member); 
        } else if(toToken == BASE) {
            sellTo(inputAmount, fromToken, member); 
        } else {
            address _poolTo = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); 
            uint feey = sellTo(inputAmount, fromToken, _poolTo); 
            address _toToken = toToken;
            if(toToken == address(0)){_toToken = WBNB;} 
            (uint _zz, uint _feez) = Pool(_poolTo).swap(_toToken); 
            uint fee = feey+(_feez); 
            getsDividend(_poolTo, fee); 
            _handleTransferOut(toToken, _zz, member); 
        }
    }

    
    function getsDividend(address _pool, uint fee) internal {
        if(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true){
            addTradeFee(fee); 
            addDividend(_pool, fee); 
        }
    }

    
    
    
    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){
        if(_amount > 0) {
            if(_token == address(0)){
                require((_amount == msg.value));
                (bool success, ) = payable(WBNB).call{value: _amount}(""""); 
                require(success, ""!send"");
                iBEP20(WBNB).transfer(_pool, _amount); 
                actual = _amount;
            } else {
                uint startBal = iBEP20(_token).balanceOf(_pool); 
                iBEP20(_token).transferFrom(msg.sender, _pool, _amount); 
                actual = iBEP20(_token).balanceOf(_pool)-(startBal); 
            }
        }
    }

    
    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal {
        if(_amount > 0) {
            if (_token == address(0)) {
                iWBNB(WBNB).withdraw(_amount); 
                (bool success, ) = payable(_recipient).call{value:_amount}("""");  
                require(success, ""!send"");
            } else {
                iBEP20(_token).transfer(_recipient, _amount); 
            }
        }
    }

    
    
    
    function swapAssetToSynth(uint inputAmount, address fromToken, address toSynth) external payable {
        require(fromToken != toSynth); 
        address _synthLayer1 = iSYNTH(toSynth).LayerONE(); 
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthLayer1); 
        if(fromToken != BASE){
            sellTo(inputAmount, fromToken, address(this)); 
            iBEP20(BASE).transfer(_pool, iBEP20(BASE).balanceOf(address(this))); 
        } else {
            iBEP20(BASE).transferFrom(msg.sender, _pool, inputAmount); 
        }
        (, uint fee) = Pool(_pool).mintSynth(toSynth, msg.sender); 
        getsDividend(_pool, fee); 
    }
   
    
    function swapSynthToAsset(uint inputAmount, address fromSynth, address toToken) external {
        require(fromSynth != toToken); 
        address _synthINLayer1 = iSYNTH(fromSynth).LayerONE(); 
        address _poolIN = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(_synthINLayer1); 
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(toToken); 
        iBEP20(fromSynth).transferFrom(msg.sender, _poolIN, inputAmount); 
        uint outputAmount; uint fee;
        if(toToken == BASE){
            Pool(_poolIN).burnSynth(fromSynth, msg.sender); 
        } else {
            (outputAmount,fee) = Pool(_poolIN).burnSynth(fromSynth, address(this)); 
            if(toToken != address(0)){
                (, uint feey) = Pool(_pool).swapTo(toToken, msg.sender); 
                fee = feey + fee;
            } else {
                (uint outputAmountY, uint feez) = Pool(_pool).swap(WBNB); 
                _handleTransferOut(toToken, outputAmountY, msg.sender); 
                fee = feez + fee;
            }
        }
        getsDividend(_pool, fee); 
    }
    
    
    
    
    function addDividend(address _pool, uint256 _fees) internal {
        if(!(normalAverageFee == 0)){
            uint reserve = iBEP20(BASE).balanceOf(_DAO().RESERVE()); 
            if(!(reserve == 0)){
                uint dailyAllocation = (reserve / eraLength) / maxTrades; 
                uint numerator = _fees * dailyAllocation;
                uint feeDividend = numerator / (_fees + normalAverageFee); 
                revenueDetails(feeDividend, _pool); 
                iRESERVE(_DAO().RESERVE()).grantFunds(feeDividend, _pool); 
                Pool(_pool).sync(); 
            }
        }
    }

    
    function addTradeFee(uint _fee) internal {
        uint totalTradeFees = 0;
        uint arrayFeeLength = feeArray.length;
        if(arrayFeeLength < arrayFeeSize){
            feeArray.push(_fee); 
        } else {
            addFee(_fee); 
            for(uint i = 0; i < arrayFeeSize; i++){
                totalTradeFees = totalTradeFees + feeArray[i]; 
            }
        }
        normalAverageFee = totalTradeFees / arrayFeeSize; 
    }

    
    function addFee(uint _fee) internal {
        uint n = feeArray.length; 
        for (uint i = n - 1; i > 0; i--) {
            feeArray[i] = feeArray[i - 1];
        }
        feeArray[0] = _fee;
    }

    function revenueDetails(uint _fees, address _pool) internal {
        if(lastMonth == 0){
            lastMonth = block.timestamp;
        }
        if(block.timestamp <= lastMonth + 2592000){ 
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        } else {
            lastMonth = block.timestamp;
            mapAddress_Past30DayPoolDividends[_pool] = mapAddress_30DayDividends[_pool];
            mapAddress_30DayDividends[_pool] = 0;
            mapAddress_30DayDividends[_pool] = mapAddress_30DayDividends[_pool] + _fees;
        }
    }

    function stringToBytes(string memory s) external pure returns (bytes memory){
        return bytes(s);
    }

    function isEqual(bytes memory part1, bytes memory part2) external pure returns(bool equal){
        if(sha256(part1) == sha256(part2)){
            return true;
        }
    }
    
    

    function changeArrayFeeSize(uint _size) external onlyDAO {
        arrayFeeSize = _size;
        delete feeArray;
    }

    function changeMaxTrades(uint _maxtrades) external onlyDAO {
        maxTrades = _maxtrades;
    }

    function changeEraLength(uint _eraLength) external onlyDAO {    
        eraLength = _eraLength; 
    }

    

    function currentPoolRevenue(address pool) external view returns(uint256) {
        return mapAddress_30DayDividends[pool];
    }

    function pastPoolRevenue(address pool) external view returns(uint256) {
        return mapAddress_Past30DayPoolDividends[pool];
    }
}",3257.0,3,0,"{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""Critical"",
      ""Description"": ""Several functions, such as `_handleTransferOut`, `removeLiquidityExact`, and `swapSynthToAsset`, involve external calls before updating state variables, making them susceptible to reentrancy attacks."",
      ""Impact"": ""An attacker could exploit these vulnerabilities to manipulate token balances or drain funds from the contract."",
      ""Location"": ""Functions `_handleTransferOut`, `removeLiquidityExact`, `swapSynthToAsset`, and others."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The issue accurately identifies a critical security vulnerability related to reentrancy, which is a significant risk in smart contract development.""
    },
    {
      ""Issue"": ""Lack of Input Validation"",
      ""Severity"": ""High"",
      ""Description"": ""Many functions, such as `addLiquidity`, `removeLiquidity`, `swapTo`, and others, do not validate input parameters adequately, leading to potential erroneous transactions or unintended behavior."",
      ""Impact"": ""This could result in unexpected behavior, erroneous transfers, or potential exploits like draining funds."",
      ""Location"": ""Functions `addLiquidity`, `removeLiquidity`, `swapTo`, `addLiquiditySingleForMember`, and others."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The lack of input validation is evident across various functions, which is crucial for preventing undesired contract behavior.""
    },
    {
      ""Issue"": ""Unchecked External Call"",
      ""Severity"": ""High"",
      ""Description"": ""Functions `_handleTransferIn` and `_handleTransferOut` make unchecked external calls for transferring funds, which could fail silently."",
      ""Impact"": ""Failures in fund transfers could lead to user funds being stuck or lost without proper error handling."",
      ""Location"": ""Functions `_handleTransferIn`, `_handleTransferOut`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a potential risk of fund loss, emphasizing the need for error handling in financial transactions.""
    },
    {
      ""Issue"": ""Inadequate Access Control on Management Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `changeArrayFeeSize`, `changeMaxTrades`, and `changeEraLength` rely on the `onlyDAO` modifier, but if the DAO or deployer address is compromised, an attacker could manipulate critical contract parameters."",
      ""Impact"": ""Unauthorized changes could disrupt contract functionality, leading to manipulation or misuse."",
      ""Location"": ""Functions `changeArrayFeeSize`, `changeMaxTrades`, `changeEraLength`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Proper access control is crucial for ensuring only authorized users can change critical parameters.""
    },
    {
      ""Issue"": ""Use of Block Timestamp for Time Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `block.timestamp` for time-dependent logic in functions like `revenueDetails`, which can be manipulated by miners to some extent."",
      ""Impact"": ""This can lead to slight inconsistencies in time-based calculations, although the impact is generally minor."",
      ""Location"": ""Function `revenueDetails`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The use of block timestamps can lead to minor inaccuracies, but it highlights potential manipulation issues in time-based logic.""
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 78,
  ""RelevanceCount"": 65,
  ""AllValidation"": 78,
  ""ValidationCount"": 65
}","### **Comparison of Issue Report and Response List**

---

#### **[H-04] Members lose SPARTA tokens in removeLiquiditySingle()**

**Report Description**:  
When a member calls `removeLiquiditySingle()` requesting only SPARTA in return (`toBASE = true`), the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA tokens are left behind in the Router instead of being returned along with the converted SPARTA from the Pool. This results in the member losing the SPARTA component of their Pool LP tokens, which remain in the Router and could be claimed by future transactions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue at all. The problem involves a logical flaw in the `removeLiquiditySingle()` function, where SPARTA tokens are not returned to the member, leading to potential loss of funds. This is a critical issue that requires a specific fix, but it is entirely missed in the response list.

---

#### **[H-07] Missing Slippage Checks**

**Report Description**:  
The contract lacks minimum amount out parameters or checks to mitigate frontrunning/slippage. This allows attackers with sufficient capital to force arbitrarily large slippage by sandwiching transactions, potentially causing close to 100% slippage. The recommendation is to add a minimum amount out parameter, reverting the transaction if the minimum amount is not obtained.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing slippage checks. This is a significant vulnerability, as it allows attackers to exploit the contract through sandwich attacks, leading to substantial financial losses for users. The absence of this issue in the response list represents a critical gap.

---

#### **[H-08] Dividend Reward Can Be Gamed**

**Report Description**:  
The `Router.addDividend` function sends dividends to the pool based on fees. An attacker can manipulate the `normalAverageFee` variable by trading a single wei in the pool `arrayFeeSize` (20) times, setting the fee to zero. They can then perform a trade with non-zero fees, setting `normalAverageFee` to this trade's fee. This allows the attacker to claim half of the `dailyAllocation` as dividends. By repeating this process, the attacker can drain the reserve almost entirely, gaining a disproportionate share of the profits.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves a manipulation of the dividend distribution mechanism, allowing an attacker to drain the reserve. This is a critical issue that requires specific mitigation, but it is entirely missed in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-04] Members lose SPARTA tokens in removeLiquiditySingle()**  
- **[H-07] Missing Slippage Checks**  
- **[H-08] Dividend Reward Can Be Gamed**

---

### **Conclusion**  
The response list fails to address any of the issues in the provided issue report. While the response list identifies other vulnerabilities (e.g., reentrancy, unchecked external calls, and input validation), it misses critical issues such as the loss of SPARTA tokens, missing slippage checks, and the gaming of dividend rewards. These gaps represent significant risks to the security and functionality of the smart contract. Addressing these issues is essential to ensure the contract's robustness and user safety.",0,1,2,5,78,"```
None.
```",0.0
Synth.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./Pool.sol"";  
import ""./interfaces/iPOOLFACTORY.sol"";

contract Synth is iBEP20 {
    address public BASE;
    address public LayerONE; // Underlying relevant layer1 token
    uint public genesis;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;

    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    mapping(address => uint) public mapSynth_LPBalance;
    mapping(address => uint) public mapSynth_LPDebt;
   
    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }
    
    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER, ""!DAO"");
        _;
    }

    // Restrict access
    modifier onlyPool() {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, ""!curated"");
        _;
    }
    
    constructor (address _base, address _token) {
        BASE = _base;
        LayerONE = _token;
        string memory synthName = ""-SpartanProtocolSynthetic"";
        string memory synthSymbol = ""-SPS"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));
        decimals = iBEP20(_token).decimals();
        DEPLOYER = msg.sender;
        genesis = block.timestamp;
    }

    //========================================iBEP20=========================================//

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    // iBEP20 Transfer function
    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    // iBEP20 Approve, change allowance functions
    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }
    
    // iBEP20 TransferFrom function
    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        // Unlimited approval (saves an SSTORE)
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    //iBEP677 approveAndCall
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval
        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient
        return true;
    }

    //iBEP677 transferAndCall
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _transfer(msg.sender, recipient, amount);
        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient 
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    // Burn supply
    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //==================================== SYNTH FUNCTIONS =================================//

    // Handle received LP tokens and mint Synths
    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){
        uint lpUnits = _getAddedLPAmount(msg.sender); // Get the received LP units
        mapSynth_LPDebt[msg.sender] += amount; // Increase debt by synth amount
        mapSynth_LPBalance[msg.sender] += lpUnits; // Increase lp balance by LPs received
        _mint(member, amount); // Mint the synths & tsf to user
        return amount;
    }
    
    // Handle received Synths and burn the LPs and Synths
    function burnSynth() external returns (bool){
        uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units
        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total
        mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance
        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt
        if(_amountUnits > 0){
            _burn(address(this), _syntheticAmount); // Burn the synths
            Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens
        }
        return true;
    }

    // Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)
    function realise(address pool) external {
        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); // Get the SPARTA value of the LP tokens
        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); // Get the SPARTA value of the synths
        if(baseValueLP > baseValueSynth){
            uint premium = baseValueLP - baseValueSynth; // Get the premium between the two values
            if(premium > 10**18){
                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); // Get the LP value of the premium
                mapSynth_LPBalance[pool] -= premiumLP; // Reduce the LP balance
                Pool(pool).burn(premiumLP); // Burn the premium of the LP tokens
            }
        }
    }

    // Check the received token amount
    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){
        if(_amount > 0) {
            uint startBal = iBEP20(_token).balanceOf(address(this)); // Get existing balance
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in
            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; // Calculate received amount
        }
        return _actual;
    }

    // Check the received LP tokens amount
    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){
        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); // Get total balance held
        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){
            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; // Get received amount
        } else {
            _actual = 0;
        }
        return _actual;
    }

    function getmapAddress_LPBalance(address pool) external view returns (uint){
        return mapSynth_LPBalance[pool];
    }

    function getmapAddress_LPDebt(address pool) external view returns (uint){
        return mapSynth_LPDebt[pool];
    }
}",2196.0,230.0,"[H-05] Synth `realise` is vulnerable to flash loan attacks
Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. `Synth`'s lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.
The attack does not necessarily require a flash loan. A big whale of the lp token holders could keep calling `realise` by shifting token ratio of AMM pool back and forth.
The vulnerability is located at Synth.sol L187-L199. Where the formula here is dangerous.

[H-09] arbitrary synth `mint`/`burn` from pool
`Pool` can mint arbitrary `Synth` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.

[M-07] Synth: approveAndCall sets unnecessary approval
The `Synth.approveAndCall` function approves the `recipient` contract with the max value instead of only the required `amount`.
For safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, like this is the case for `approveAndCall`.",3.0,"pragma solidity 0.8.3;
import ""./Pool.sol"";  
import ""./interfaces/iPOOLFACTORY.sol"";

contract Synth is iBEP20 {
    address public BASE;
    address public LayerONE; 
    uint public genesis;
    address public DEPLOYER;

    string _name; string _symbol;
    uint8 public override decimals; uint256 public override totalSupply;

    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    mapping(address => uint) public mapSynth_LPBalance;
    mapping(address => uint) public mapSynth_LPDebt;
   
    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }
    
    
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER, ""!DAO"");
        _;
    }

    
    modifier onlyPool() {
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, ""!curated"");
        _;
    }
    
    constructor (address _base, address _token) {
        BASE = _base;
        LayerONE = _token;
        string memory synthName = ""-SpartanProtocolSynthetic"";
        string memory synthSymbol = ""-SPS"";
        _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));
        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));
        decimals = iBEP20(_token).decimals();
        DEPLOYER = msg.sender;
        genesis = block.timestamp;
    }

    

    function name() external view override returns (string memory) {
        return _name;
    }

    function symbol() external view override returns (string memory) {
        return _symbol;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    
    function approve(address spender, uint256 amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {
        uint256 currentAllowance = _allowances[msg.sender][spender];
        require(currentAllowance >= subtractedValue, ""!approval"");
        _approve(msg.sender, spender, currentAllowance - subtractedValue);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), ""!owner"");
        require(spender != address(0), ""!spender"");
        if (_allowances[owner][spender] < type(uint256).max) { 
            _allowances[owner][spender] = amount;
            emit Approval(owner, spender, amount);
        }
    }
    
    
    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        
        if (_allowances[sender][msg.sender] < type(uint256).max) {
            uint256 currentAllowance = _allowances[sender][msg.sender];
            require(currentAllowance >= amount, ""!approval"");
            _approve(sender, msg.sender, currentAllowance - amount);
        }
        return true;
    }

    
    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _approve(msg.sender, recipient, type(uint256).max); 
        iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); 
        return true;
    }

    
    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {
        _transfer(msg.sender, recipient, amount);
        iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); 
        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), ""!sender"");
        uint256 senderBalance = _balances[sender];
        require(senderBalance >= amount, ""!balance"");
        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    
    function burn(uint256 amount) external virtual override {
        _burn(msg.sender, amount);
    }

    function burnFrom(address account, uint256 amount) external virtual {  
        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);
        _approve(account, msg.sender, decreasedAllowance); 
        _burn(account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""!account"");
        require(_balances[account] >= amount, ""!balance"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    

    
    function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){
        uint lpUnits = _getAddedLPAmount(msg.sender); 
        mapSynth_LPDebt[msg.sender] += amount; 
        mapSynth_LPBalance[msg.sender] += lpUnits; 
        _mint(member, amount); 
        return amount;
    }
    
    
    function burnSynth() external returns (bool){
        uint _syntheticAmount = balanceOf(address(this)); 
        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; 
        mapSynth_LPBalance[msg.sender] -= _amountUnits; 
        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; 
        if(_amountUnits > 0){
            _burn(address(this), _syntheticAmount); 
            Pool(msg.sender).burn(_amountUnits); 
        }
        return true;
    }

    
    function realise(address pool) external {
        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); 
        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); 
        if(baseValueLP > baseValueSynth){
            uint premium = baseValueLP - baseValueSynth; 
            if(premium > 10**18){
                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); 
                mapSynth_LPBalance[pool] -= premiumLP; 
                Pool(pool).burn(premiumLP); 
            }
        }
    }

    
    function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){
        if(_amount > 0) {
            uint startBal = iBEP20(_token).balanceOf(address(this)); 
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); 
            _actual = iBEP20(_token).balanceOf(address(this)) - startBal; 
        }
        return _actual;
    }

    
    function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){
        uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); 
        if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){
            _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; 
        } else {
            _actual = 0;
        }
        return _actual;
    }

    function getmapAddress_LPBalance(address pool) external view returns (uint){
        return mapSynth_LPBalance[pool];
    }

    function getmapAddress_LPDebt(address pool) external view returns (uint){
        return mapSynth_LPDebt[pool];
    }
}",1840.0,2,1,"{
  ""Findings"": [
    {
      ""Issue"": ""Incorrect Access Control in onlyDAO Modifier"",
      ""Severity"": ""High"",
      ""Description"": ""The `onlyDAO` modifier checks if the caller is `DEPLOYER`, rather than the DAO address. This could allow the deployer to misuse functions meant for DAO control, bypassing governance mechanisms."",
      ""Impact"": ""Functions intended for DAO use can be misused by the deployer, leading to governance issues and unauthorized access."",
      ""Location"": ""Modifier `onlyDAO`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The issue is relevant as it pertains to access control, a critical aspect of smart contract security.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `burnSynth`, `approveAndCall`, and `transferAndCall` make state changes and external calls without reentrancy protection, allowing malicious contracts to manipulate state or re-enter functions."",
      ""Impact"": ""Could lead to unauthorized operations and potential loss of funds due to reentrant attacks."",
      ""Location"": ""Functions `burnSynth`, `approveAndCall`, `transferAndCall`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Identifying reentrancy vulnerabilities is crucial for contract security, making this finding relevant and valid.""
    },
    {
      ""Issue"": ""Unchecked External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions such as `approveAndCall` and `_handleTransferIn` make external calls without checking success, leading to potential reentrancy or logic issues."",
      ""Impact"": ""Malicious contracts could exploit this to perform unintended actions, affecting contract logic and user experience."",
      ""Location"": ""Functions `approveAndCall`, `_handleTransferIn`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Unchecked external calls are a common vulnerability that can lead to unexpected behavior or security risks.""
    },
    {
      ""Issue"": ""Lack of Event Emission for State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `mintSynth`, `burnSynth`, and `realise` do not emit events for critical state changes, making it difficult to track significant interactions."",
      ""Impact"": ""Reduces transparency and hinders auditing and monitoring of contract activity."",
      ""Location"": ""Functions `mintSynth`, `burnSynth`, `realise`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Event emissions are important for transparency and auditing, and the lack thereof can hinder contract tracking.""
    },
    {
      ""Issue"": ""Inadequate Error Messages"",
      ""Severity"": ""Low"",
      ""Description"": ""Error messages in require statements are not descriptive, complicating debugging and increasing the difficulty of diagnosing issues."",
      ""Impact"": ""Affects usability and debugging, potentially leading to longer development and troubleshooting times."",
      ""Location"": ""Require statements throughout the contract"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Clear error messages are crucial for debugging and maintenance, aligning with code quality goals.""
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 35,
  ""RelevanceCount"": 28,
  ""AllValidation"": 35,
  ""ValidationCount"": 28
}","### **Comparison of Issue Report and Response List**

---

#### **[H-05] Synth `realise` is vulnerable to flash loan attacks**

**Report Description**:
The `realise` function in `Synth.sol` calculates `baseValueLP` and `baseValueSynth` based on the AMM spot price, making it vulnerable to flash loan attacks. The vulnerability arises because the function can be exploited by manipulating the AMM pool's token ratio, either through flash loans or by a large LP token holder repeatedly calling `realise`. This could lead to incorrect calculations and potential financial losses. The issue is located in `Synth.sol` at lines 187-199.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific vulnerability related to flash loan attacks or the manipulation of AMM pool ratios in the `realise` function. This is a critical oversight, as the issue poses a high risk to the protocol's financial integrity.

---

#### **[H-09] Arbitrary Synth `mint`/`burn` from pool**

**Report Description**:
The `Pool` contract allows arbitrary minting and burning of `Synth` tokens as long as they are valid. This can be exploited by attackers to mint expensive synthetics from cheaper AMM pools and burn them in more expensive pools, resulting in arbitrage profits. The attack can be amplified using flash loans, potentially breaking all pegs and destabilizing the protocol.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of arbitrary minting and burning of `Synth` tokens or the associated arbitrage risks. This is a significant gap, as the vulnerability could lead to substantial financial losses and protocol instability.

---

#### **[M-07] Synth: `approveAndCall` sets unnecessary approval**

**Report Description**:
The `approveAndCall` function in `Synth.sol` approves the `recipient` contract with the maximum value (`type(uint256).max`) instead of only the required `amount`. This is unnecessary and unsafe, as it exposes the contract to potential misuse if the recipient contract is compromised. The approval should be limited to the specific `amount` required for the call.

**Match in Response List**:
Matches with the issue titled **""Unchecked External Calls""**.

**Validation**:
**Correct**. The response identifies the issue of unchecked external calls in `approveAndCall`, which is relevant but does not specifically address the problem of setting unnecessary maximum approvals. The core issue of excessive approval is missed, making the response incomplete.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[M-07] Synth: `approveAndCall` sets unnecessary approval**

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-05] Synth `realise` is vulnerable to flash loan attacks**
- **[H-09] Arbitrary Synth `mint`/`burn` from pool**

---

### **Analysis and Recommendations**

The response list fails to address two high-severity issues ([H-05] and [H-09]) and only partially addresses one medium-severity issue ([M-07]). This indicates significant gaps in the coverage of critical vulnerabilities, particularly those related to flash loan attacks, arbitrage risks, and excessive approvals. To improve the response list, the following steps are recommended:

1. **Add Specific Findings for Flash Loan Vulnerabilities**:
   - Include a detailed analysis of the `realise` function's vulnerability to flash loan attacks and AMM pool manipulation.

2. **Address Arbitrage Risks in Minting and Burning**:
   - Highlight the risks associated with arbitrary minting and burning of `Synth` tokens and propose mitigation strategies, such as stricter access controls or price validation mechanisms.

3. **Clarify the Issue with Excessive Approvals**:
   - Specifically address the problem of setting maximum approvals in `approveAndCall` and recommend limiting approvals to the required `amount`.

By addressing these gaps, the response list can provide more comprehensive and accurate coverage of the vulnerabilities identified in the issue report.",1,0,2,5,35,"```
1. Unchecked External Calls
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unchecked External Calls"".
   - In the ranked list of predictions, ""Unchecked External Calls"" appears at rank 3.

2. **Calculate the precision at that rank (P@k)**:
   - Precision at rank 3 (P@3) is the number of true positives up to rank 3 divided by 3.
   - Since there is only one true positive up to rank 3, P@3 = 1/3 ≈ 0.333.

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - AP = 0.333.

**Output**:
```
0.333
```"
Utils.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iBEP20.sol"";

contract Utils {
    address public BASE;
    uint public one = 10**18;

    constructor (address _base) {
        BASE = _base;
    }

    struct PoolDataStruct {
        address tokenAddress;
        address poolAddress;
        uint genesis;
        uint baseAmount;
        uint tokenAmount;
        uint fees;
        uint volume;
        uint txCount;
        uint poolUnits;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    //================================== HELPERS ================================//

    function getPoolData(address token) external view returns(PoolDataStruct memory poolData){
        address pool = getPool(token);
        poolData.poolAddress = pool;
        poolData.tokenAddress = token;
        poolData.genesis = iPOOL(pool).genesis();
        poolData.baseAmount = iPOOL(pool).baseAmount();
        poolData.tokenAmount = iPOOL(pool).tokenAmount();
        poolData.poolUnits = iBEP20(pool).totalSupply();
        return poolData;
    }

    function getPoolShareWeight(address token, uint units) external view returns(uint weight){
        address pool = getPool(token);
        weight = calcShare(units, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());
        return (weight);
    }

    function getPool(address token) public view returns(address pool){
        return iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);
    }

    //================================== CORE-MATH ==================================//
    
    // Calculate the feeBurn's feeOnTransfer based on total supply
    function getFeeOnTransfer(uint256 totalSupply, uint256 maxSupply) external pure returns (uint256) {
        return calcShare(totalSupply, maxSupply, 100); // 0 -> 100bp
    }

    // Calculate 'part' of a total using basis points | 10,000 basis points = 100.00%
    function calcPart(uint256 bp, uint256 total) external pure returns (uint256) {
        require(bp <= 10000, ""!bp""); // basis points must be valid
        return calcShare(bp, 10000, total);
    }

    // Calc share | share = amount * part / total
    function calcShare(uint256 part, uint256 total, uint256 amount) public pure returns (uint256 share) {
        if (part > total) {
            part = total; // Part cant be greater than the total
        }
        if (total > 0) {
            share = (amount * part) / total;
        }
    }

    // Calculate liquidity units
    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint units){
        if(P == 0){
            return b; // If pool is empty; use b as initial units
        } else {
            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment
            // P * (part1 + part2) / (part3) * slipAdjustment
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = t*(B);
            uint part2 = T*(b);
            uint part3 = T*(B)*(2);
            uint _units = (P * (part1 + (part2))) / (part3);
            return _units * slipAdjustment / one;  // Divide by 10**18
        }
    }

    // Get slip adjustment
    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint slipAdjustment){
        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))
        // 1 - ABS(part1 - part2)/(part3 * part4))
        uint part1 = B * (t);
        uint part2 = b * (T);
        uint part3 = b * (2) + (B);
        uint part4 = t + (T);
        uint numerator;
        if(part1 > part2){
            numerator = part1 - (part2);
        } else {
            numerator = part2 - (part1);
        }
        uint denominator = part3 * (part4);
        return one - ((numerator * (one)) / (denominator)); // Multiply by 10**18
    }

    // Calculate symmetrical redemption value of LP tokens (per side)
    function calcLiquidityHoldings(uint units, address token, address pool) external view returns (uint share){
        // share = amount * part / total
        // address pool = getPool(token);
        uint amount;
        if(token == BASE){
            amount = iPOOL(pool).baseAmount();
        } else {
            amount = iPOOL(pool).tokenAmount();
        }
        uint totalSupply = iBEP20(pool).totalSupply();
        return(amount*(units))/(totalSupply);
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint output){
        // y = (x * X * Y )/(x + X)^2
        uint numerator = x * (X * (Y));
        uint denominator = (x + (X)) * (x + (X));
        return numerator / (denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint output){
        // y = (x * x * Y) / (x + X)^2
        uint numerator = x * (x * (Y));
        uint denominator = (x + (X)) * (x + (X));
        return numerator / (denominator);
    }

    // Calculate asymmetrical redemption value of LP tokens (remove all to TOKEN)
    function calcAsymmetricValueToken(address pool, uint amount) external view returns (uint tokenValue){
        uint baseAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());
        uint tokenAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).tokenAmount());
        uint baseSwapped = calcSwapValueInTokenWithPool(pool, baseAmount);
        tokenValue = tokenAmount + baseSwapped;
        return tokenValue;
    }

    function calcLiquidityUnitsAsym(uint amount, address pool) external view returns (uint units){
        // synthUnits += (P b)/(2 (b + B))
        uint baseAmount = iPOOL(pool).baseAmount();
        uint totalSupply = iBEP20(pool).totalSupply();
        uint two = 2;
        return (totalSupply * amount) / (two * (amount + baseAmount));
    }

    //==================================== PRICING ====================================//

    function calcSpotValueInBase(address token, uint amount) external view returns (uint value){
        address pool = getPool(token);
        return calcSpotValueInBaseWithPool(pool, amount);
    }

    function calcSpotValueInToken(address token, uint amount) external view returns (uint value){
        address pool = getPool(token);
        return calcSpotValueInTokenWithPool(pool, amount);
    }

    function calcSwapValueInBase(address token, uint amount) external view returns (uint _output){
        address pool = getPool(token);
        return  calcSwapValueInBaseWithPool(pool, amount);
    }

    function calcSwapValueInBaseWithSYNTH(address synth, uint amount) external view returns (uint _output){
        address token = iSYNTH(synth).LayerONE();
        address pool = getPool(token);
        return  calcSwapValueInBaseWithPool(pool, amount);
    }

    function calcSwapValueInToken(address token, uint amount) external view returns (uint _output){
        address pool = getPool(token);
        return  calcSwapValueInTokenWithPool(pool, amount);
    }

    function calcSpotValueInBaseWithPool(address pool, uint amount) public view returns (uint value){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return (amount*(_baseAmount))/(_tokenAmount);
    }

    function calcSpotValueInTokenWithPool(address pool, uint amount) public view returns (uint value){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return (amount*(_tokenAmount))/(_baseAmount);
    }

    function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return  calcSwapOutput(amount, _tokenAmount, _baseAmount);
    }

    function calcSwapValueInTokenWithPool(address pool, uint amount) public view returns (uint _output){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return  calcSwapOutput(amount, _baseAmount, _tokenAmount);
    }

    function calcActualSynthUnits(uint amount, address synth) external view returns (uint _output) {
        address token = iSYNTH(synth).LayerONE();
        address pool = getPool(token);
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return ((amount * _baseAmount) / (2 * _tokenAmount));
    }
}",2087.0,218.0,"***[H-13] Flash loan manipulation on `getPoolShareWeight` of `Utils`***
The `getPoolShareWeight` function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.
According to the implementation of `getPoolShareWeight`, a user's pool share weight is calculated by `uints * baseAmount / totalSupply`, where uints is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool.",1.0,"pragma solidity 0.8.3;
import ""./interfaces/iBASE.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iPOOL.sol"";
import ""./interfaces/iSYNTH.sol"";
import ""./interfaces/iBEP20.sol"";

contract Utils {
    address public BASE;
    uint public one = 10**18;

    constructor (address _base) {
        BASE = _base;
    }

    struct PoolDataStruct {
        address tokenAddress;
        address poolAddress;
        uint genesis;
        uint baseAmount;
        uint tokenAmount;
        uint fees;
        uint volume;
        uint txCount;
        uint poolUnits;
    }

    function _DAO() internal view returns(iDAO) {
        return iBASE(BASE).DAO();
    }

    

    function getPoolData(address token) external view returns(PoolDataStruct memory poolData){
        address pool = getPool(token);
        poolData.poolAddress = pool;
        poolData.tokenAddress = token;
        poolData.genesis = iPOOL(pool).genesis();
        poolData.baseAmount = iPOOL(pool).baseAmount();
        poolData.tokenAmount = iPOOL(pool).tokenAmount();
        poolData.poolUnits = iBEP20(pool).totalSupply();
        return poolData;
    }

    function getPoolShareWeight(address token, uint units) external view returns(uint weight){
        address pool = getPool(token);
        weight = calcShare(units, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());
        return (weight);
    }

    function getPool(address token) public view returns(address pool){
        return iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token);
    }

    
    
    
    function getFeeOnTransfer(uint256 totalSupply, uint256 maxSupply) external pure returns (uint256) {
        return calcShare(totalSupply, maxSupply, 100); 
    }

    
    function calcPart(uint256 bp, uint256 total) external pure returns (uint256) {
        require(bp <= 10000, ""!bp""); 
        return calcShare(bp, 10000, total);
    }

    
    function calcShare(uint256 part, uint256 total, uint256 amount) public pure returns (uint256 share) {
        if (part > total) {
            part = total; 
        }
        if (total > 0) {
            share = (amount * part) / total;
        }
    }

    
    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint units){
        if(P == 0){
            return b; 
        } else {
            
            
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = t*(B);
            uint part2 = T*(b);
            uint part3 = T*(B)*(2);
            uint _units = (P * (part1 + (part2))) / (part3);
            return _units * slipAdjustment / one;  
        }
    }

    
    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint slipAdjustment){
        
        
        uint part1 = B * (t);
        uint part2 = b * (T);
        uint part3 = b * (2) + (B);
        uint part4 = t + (T);
        uint numerator;
        if(part1 > part2){
            numerator = part1 - (part2);
        } else {
            numerator = part2 - (part1);
        }
        uint denominator = part3 * (part4);
        return one - ((numerator * (one)) / (denominator)); 
    }

    
    function calcLiquidityHoldings(uint units, address token, address pool) external view returns (uint share){
        
        
        uint amount;
        if(token == BASE){
            amount = iPOOL(pool).baseAmount();
        } else {
            amount = iPOOL(pool).tokenAmount();
        }
        uint totalSupply = iBEP20(pool).totalSupply();
        return(amount*(units))/(totalSupply);
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint output){
        
        uint numerator = x * (X * (Y));
        uint denominator = (x + (X)) * (x + (X));
        return numerator / (denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint output){
        
        uint numerator = x * (x * (Y));
        uint denominator = (x + (X)) * (x + (X));
        return numerator / (denominator);
    }

    
    function calcAsymmetricValueToken(address pool, uint amount) external view returns (uint tokenValue){
        uint baseAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).baseAmount());
        uint tokenAmount = calcShare(amount, iBEP20(pool).totalSupply(), iPOOL(pool).tokenAmount());
        uint baseSwapped = calcSwapValueInTokenWithPool(pool, baseAmount);
        tokenValue = tokenAmount + baseSwapped;
        return tokenValue;
    }

    function calcLiquidityUnitsAsym(uint amount, address pool) external view returns (uint units){
        
        uint baseAmount = iPOOL(pool).baseAmount();
        uint totalSupply = iBEP20(pool).totalSupply();
        uint two = 2;
        return (totalSupply * amount) / (two * (amount + baseAmount));
    }

    

    function calcSpotValueInBase(address token, uint amount) external view returns (uint value){
        address pool = getPool(token);
        return calcSpotValueInBaseWithPool(pool, amount);
    }

    function calcSpotValueInToken(address token, uint amount) external view returns (uint value){
        address pool = getPool(token);
        return calcSpotValueInTokenWithPool(pool, amount);
    }

    function calcSwapValueInBase(address token, uint amount) external view returns (uint _output){
        address pool = getPool(token);
        return  calcSwapValueInBaseWithPool(pool, amount);
    }

    function calcSwapValueInBaseWithSYNTH(address synth, uint amount) external view returns (uint _output){
        address token = iSYNTH(synth).LayerONE();
        address pool = getPool(token);
        return  calcSwapValueInBaseWithPool(pool, amount);
    }

    function calcSwapValueInToken(address token, uint amount) external view returns (uint _output){
        address pool = getPool(token);
        return  calcSwapValueInTokenWithPool(pool, amount);
    }

    function calcSpotValueInBaseWithPool(address pool, uint amount) public view returns (uint value){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return (amount*(_baseAmount))/(_tokenAmount);
    }

    function calcSpotValueInTokenWithPool(address pool, uint amount) public view returns (uint value){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return (amount*(_tokenAmount))/(_baseAmount);
    }

    function calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return  calcSwapOutput(amount, _tokenAmount, _baseAmount);
    }

    function calcSwapValueInTokenWithPool(address pool, uint amount) public view returns (uint _output){
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return  calcSwapOutput(amount, _baseAmount, _tokenAmount);
    }

    function calcActualSynthUnits(uint amount, address synth) external view returns (uint _output) {
        address token = iSYNTH(synth).LayerONE();
        address pool = getPool(token);
        uint _baseAmount = iPOOL(pool).baseAmount();
        uint _tokenAmount = iPOOL(pool).tokenAmount();
        return ((amount * _baseAmount) / (2 * _tokenAmount));
    }
}",1761.0,1,0,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Sensitive Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `getPool`, `getPoolData`, `getPoolShareWeight`, and others are publicly accessible without any access control mechanisms, potentially exposing sensitive operations to unauthorized users."",
      ""Impact"": ""Without proper access controls, unauthorized users can exploit these functions to manipulate contract state or gain insights into sensitive operations, potentially leading to financial loss or strategic manipulation."",
      ""Location"": ""Functions `getPool`, `getPoolData`, `getPoolShareWeight`, etc."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant because it identifies a security concern with publicly accessible functions that could be exploited. It is technically valid as these functions indeed lack access control.""
    },
    {
      ""Issue"": ""Potential Division by Zero"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `calcShare`, `calcSwapOutput`, and others perform division operations without checking if denominators are zero, which could lead to division by zero errors."",
      ""Impact"": ""Division by zero would cause the transaction to revert, potentially disrupting contract functionality and leading to denial of service."",
      ""Location"": ""Functions `calcShare`, `calcSwapOutput`, and other similar functions."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as division by zero is a known issue that can cause runtime errors. It is technically valid because the code does perform divisions that could result in zero without checks.""
    },
    {
      ""Issue"": ""Unverified External Contract Interactions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract interacts with external contracts via interfaces like `iPOOL`, `iBEP20`, and others without verifying the returned addresses or results, assuming these contracts behave as expected."",
      ""Impact"": ""If any of these external contracts are malicious or incorrectly implemented, it could lead to erroneous behavior or exploitation."",
      ""Location"": ""Throughout the contract where interfaces like `iPOOL` and `iBEP20` are used."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The contract relies heavily on external contracts for critical operations, and any malicious address returned could lead to severe security issues. This accurately reflects the risk involved with the current implementation.""
    },
    {
      ""Issue"": ""Potential Reentrancy in External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions that interact with external contracts could be susceptible to reentrancy attacks if proper precautions are not taken, particularly in functions that update state after making external calls."",
      ""Impact"": ""Reentrancy could allow an attacker to manipulate state or drain funds from the contract."",
      ""Location"": ""Functions interacting with external contracts, such as `getPool`, `calcSwapValueInBaseWithPool`, `calcLiquidityUnits`, etc."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The absence of reentrancy protection is a well-known vulnerability in Solidity, making this finding relevant and valid for ensuring contract security.""
    },
    {
      ""Issue"": ""Arithmetic Precision Loss"",
      ""Severity"": ""Low"",
      ""Description"": ""The calculations involving large numbers and divisions, especially with fixed-point arithmetic, can result in precision loss due to integer division in Solidity."",
      ""Impact"": ""May result in slight inaccuracies in calculations, affecting outputs such as fees, swap values, and liquidity holdings."",
      ""Location"": ""Functions `calcShare`, `calcLiquidityUnits`, `calcSwapOutput`, etc."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Precision loss in arithmetic calculations is relevant to the task as it affects financial accuracy, a critical aspect of smart contracts dealing with financial operations.""
    },
    {
      ""Issue"": ""Inefficient Computation of Swap Values"",
      ""Severity"": ""Low"",
      ""Description"": ""The computation of swap values involves repetitive calculations that could be optimized. Functions like `calcSwapOutput` and `calcSwapFee` perform similar operations which could be refactored to improve efficiency."",
      ""Impact"": ""Increased gas costs and execution time for users interacting with these functions."",
      ""Location"": ""Functions `calcSwapOutput` and `calcSwapFee`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as optimizing repetitive calculations can significantly reduce gas costs, improving the contract's efficiency and user experience.""
    }
  ],
  ""FindingNumber"": 6,
  ""AllRelevance"": 41,
  ""RelevanceCount"": 33,
  ""AllValidation"": 41,
  ""ValidationCount"": 32
}","---

**[H-13] Flash loan manipulation on `getPoolShareWeight` of `Utils`**

**Report Description**:
The `getPoolShareWeight` function calculates a user's pool share weight based on the number of SPARTAN tokens in the pool. This calculation is vulnerable to flash loan manipulation, as an attacker can temporarily increase the number of SPARTAN tokens in the pool by swapping a large amount of TOKEN to SPARTAN. This manipulation inflates the user's pool share weight, which is calculated as `uints * baseAmount / totalSupply`, where `uints` is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. This vulnerability can be exploited to gain an unfair advantage in pool share calculations.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the specific issue of flash loan manipulation in the `getPoolShareWeight` function. While the response list includes findings related to access control, division by zero, and external contract interactions, none of these directly address the vulnerability described in the issue report. The issue of flash loan manipulation is a distinct security concern that requires specific mitigation strategies, such as using time-weighted average prices or implementing flash loan-resistant mechanisms, which are not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-13] Flash loan manipulation on `getPoolShareWeight` of `Utils`**

---",0,0,1,6,41,"```
None.
```",0.0
,,,,issue,,,,13,7,,,8,1,11,37,218,,
