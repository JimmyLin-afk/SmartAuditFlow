nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparsion,Correct Matches,Partially Correct,Missed,Genes,Task,Comparison,matchList,MAP
Pools.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iFACTORY.sol"";

contract Pools {

    // Parameters
    bool private inited;
    uint public pooledVADER;
    uint public pooledUSDV;
    
    address public VADER;
    address public USDV;
    address public ROUTER;
    address public FACTORY;

    mapping(address => bool) _isMember;
    mapping(address => bool) _isAsset;
    mapping(address => bool) _isAnchor;

    mapping(address => uint) public mapToken_Units;
    mapping(address => mapping(address => uint)) public mapTokenMember_Units;
    mapping(address => uint) public mapToken_baseAmount;
    mapping(address => uint) public mapToken_tokenAmount;

    // Events
    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);
    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);
    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);
    event Sync(address indexed token, address indexed pool, uint addedAmount);
    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {}

    // Init
    function init(address _vader, address _usdv, address _router, address _factory) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
    }

    //====================================LIQUIDITY=========================================//

    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {
        require(token != USDV && token != VADER); // Prohibited
        uint _actualInputBase;
        if(base == VADER){
            if(!isAnchor(token)){               // If new Anchor
                _isAnchor[token] = true;
            }
            _actualInputBase = getAddedAmount(VADER, token);
        } else if (base == USDV) {
            if(!isAsset(token)){               // If new Asset
                _isAsset[token] = true;
            }
            _actualInputBase = getAddedAmount(USDV, token);
        }
        uint _actualInputToken = getAddedAmount(token, token);
        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);
        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member
        mapToken_Units[token] += liquidityUnits;                // Add in total
        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE
        mapToken_tokenAmount[token] += _actualInputToken;       // Add token
        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router
    }
    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly
    }
    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {
        require(base == USDV || base == VADER);
        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);
        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);
        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);
        mapToken_Units[token] -=_units;
        mapTokenMember_Units[token][member] -= _units;
        mapToken_baseAmount[token] -= outputBase;
        mapToken_tokenAmount[token] -= outputToken;
        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);
        transferOut(base, outputBase, member);
        transferOut(token, outputToken, member);
        return (outputBase, outputToken);
    }
    
    //=======================================SWAP===========================================//
    
    // Designed to be called by a router, but can be called directly
    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {
        if(toBase){
            uint _actualInput = getAddedAmount(token, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            mapToken_tokenAmount[token] += _actualInput;
            mapToken_baseAmount[token] -= outputAmount;
            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);
            transferOut(base, outputAmount, member);
        } else {
            uint _actualInput = getAddedAmount(base, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            mapToken_baseAmount[token] += _actualInput;
            mapToken_tokenAmount[token] -= outputAmount;
            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);
            transferOut(token, outputAmount, member);
        }
    }

    // Add to balances directly (must send first)
    function sync(address token, address pool) external {
        uint _actualInput = getAddedAmount(token, pool);
        if (token == VADER || token == USDV){
            mapToken_baseAmount[pool] += _actualInput;
        } else {
            mapToken_tokenAmount[pool] += _actualInput;
        // } else if(isSynth()){
        //     //burnSynth && deleteUnits
        }
        emit Sync(token, pool, _actualInput);
    }

    //======================================SYNTH=========================================//

    // Should be done with intention, is gas-intensive
    function deploySynth(address token) external {
        require(token != VADER || token != USDV);
        iFACTORY(FACTORY).deploySynth(token);
    }

    // Mint a Synth against its own pool
    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {
        require(iFACTORY(FACTORY).isSynth(getSynth(token)), ""!synth"");
        uint _actualInputBase = getAddedAmount(base, token);                    // Get input
        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units
        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output
        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self
        mapToken_Units[token] += _synthUnits;                                       // Add supply
        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE 
        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event
        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member
    }
    // Burn a Synth to get out BASE
    function burnSynth(address base, address token, address member) external returns (uint outputBase) {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata
        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self
        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units
        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output
        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE
        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event
        transferOut(base, outputBase, member);                                      // Send BASE to member
    }
    // Remove a synth, make other LPs richer
    function syncSynth(address token) external {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata
        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self
        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units
        emit SynthSync(token, _actualInputSynth, _unitsToDelete);
    }

    //======================================LENDING=========================================//
    
    // Assign units to callee (ie, a LendingRouter)
    function lockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][member] -= units;
        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol
    }
    // Assign units to callee (ie, a LendingRouter)
    function unlockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][msg.sender] -= units;      
        mapTokenMember_Units[token][member] += units;
    }

    //======================================HELPERS=========================================//

    // Safe adds
    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(_token == VADER && _pool != VADER){  // Want to know added VADER
            addedAmount = _balance - pooledVADER;
            pooledVADER = pooledVADER + addedAmount;
        } else if(_token == USDV) {             // Want to know added USDV
            addedAmount = _balance - pooledUSDV;
            pooledUSDV = pooledUSDV + addedAmount;
        } else {                                // Want to know added Asset/Anchor
            addedAmount = _balance - mapToken_tokenAmount[_pool];
        }
    }
    function transferOut(address _token, uint _amount, address _recipient) internal {
        if(_token == VADER){
            pooledVADER = pooledVADER - _amount; // Accounting
        } else if(_token == USDV) {
            pooledUSDV = pooledUSDV - _amount;  // Accounting
        }
        if(_recipient != address(this)){
            iERC20(_token).transfer(_recipient, _amount);
        }
    }

    function isMember(address member) public view returns(bool) {
        return _isMember[member];
    }
    function isAsset(address token) public view returns(bool) {
        return _isAsset[token];
    }
    function isAnchor(address token) public view returns(bool) {
        return _isAnchor[token];
    }
    function getPoolAmounts(address token) external view returns(uint, uint) {
        return (getBaseAmount(token), getTokenAmount(token));
    }
    function getBaseAmount(address token) public view returns(uint) {
        return mapToken_baseAmount[token];
    }
    function getTokenAmount(address token) public view returns(uint) {
        return mapToken_tokenAmount[token];
    }
    function getUnits(address token) external view returns(uint) {
        return mapToken_Units[token];
    }
    function getMemberUnits(address token, address member) external view returns(uint) {
        return mapTokenMember_Units[token][member];
    }
    function getSynth(address token) public view returns (address) {
        return iFACTORY(FACTORY).getSynth(token);
    }
    function isSynth(address token) public view returns (bool) {
        return iFACTORY(FACTORY).isSynth(token);
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
}",2964.0,248.0,"[H-01] Unhandled return value of transfer in transferOut() of Pools.sol
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements to handle these failures.
The transfer call on L211 of transferOut() could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.
 [H-11] Swap token can be traded as fake base token
The Pools.swap function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call swap(token, token, member, toBase=false)
The _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result.
It breaks the accounting for the pool as tokens are transferred in, but the base balance is increased (and token balance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.
Another example scenario is that the token pool amount can be stolen. Send tokenIn=baseAmount of tokens to the pool and call swap(base=token, token, member, toBase=false). Depending on the price of token relative to base this could be cheaper than trading with the base tokens.  [H-12] getAddedAmount can return wrong results
The getAddedAmount function only works correctly when called with (VADER/USDV, pool) or (pool, pool). However, when called with (token, pool) where token is neither VADER/USDV/pool, it returns the wrong results:
It gets the token balance
And subtracts it from the stored mapToken_tokenAmount[_pool] amount which can be that of a completely different token
Anyone can break individual pairs by calling sync(token1, token2) where the token1 balance is less than mapToken_tokenAmount[token2]. This will add the difference to mapToken_tokenAmount[token2] and break the accounting and result in a wrong swap logic.
 [H-13] 4 Synths can be minted with fake base token
The Pools.mintSynth function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call mintSynth(token, token, member).
The _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result.
It breaks the accounting for the pool as tokens are transferred in, but the base balance is increased.

[H-14] Missing access restriction on lockUnits/unlockUnits
The Pool.lockUnits allows anyone to steal pool tokens from a member and assign them to msg.sender. Anyone can steal pool tokens from any other user.
Recommend adding access control and require that msg.sender is the router or another authorized party.  [H-22] Users may unintentionally remove liquidity under a phishing attack.
The removeLiquidity function in Pools.sol uses tx.origin to determine the person who wants to remove liquidity. However, such a design is dangerous since the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack, and he could unintentionally remove liquidity.
 [M-01] User may not get IL protection if certain functions are called directly in Pools.sol
Functions removeLiquidity() and removeLiquidityDirectly() when called directly, do not provide the the user with IL protection unlike when calling the corresponding removeLiquidity() function in Router.sol. This should be prevented, at least for removeLiquidity() or highlighted in the specification and user documentation.  Recommend adding access control (e.g. via a modifier onlyRouter) so removeLiquidity() function of Pools contract can be called only from corresponding Router contract’s removeLiquidity() function which provides IL protection. Alternatively, highlight in the specification and user documentation about which contract interfaces provide IL protection to users.  [M-10] Incorrect operator used in deploySynth() of Pools.sol
The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s deploySynth() function.
However, the require() incorrectly uses the ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.
 [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()  [M-14] Pool functions can be called before initialization in _init_() of Pools.sol
All the external/public functions of Pools.sol can be called by other contracts even before Pools.solcontract is initialized. This can lead to exceptions, state corruption or incorrect accounting in other contracts, which may require redeployment of said contract.",10.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iFACTORY.sol"";

contract Pools {

  
    bool private inited;
    uint public pooledVADER;
    uint public pooledUSDV;
    
    address public VADER;
    address public USDV;
    address public ROUTER;
    address public FACTORY;

    mapping(address => bool) _isMember;
    mapping(address => bool) _isAsset;
    mapping(address => bool) _isAnchor;

    mapping(address => uint) public mapToken_Units;
    mapping(address => mapping(address => uint)) public mapTokenMember_Units;
    mapping(address => uint) public mapToken_baseAmount;
    mapping(address => uint) public mapToken_tokenAmount;

    
    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);
    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);
    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);
    event Sync(address indexed token, address indexed pool, uint addedAmount);
    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);

    
    
    constructor() {}

    
    function init(address _vader, address _usdv, address _router, address _factory) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
    }

    

    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {
        require(token != USDV && token != VADER); 
        uint _actualInputBase;
        if(base == VADER){
            if(!isAnchor(token)){               
                _isAnchor[token] = true;
            }
            _actualInputBase = getAddedAmount(VADER, token);
        } else if (base == USDV) {
            if(!isAsset(token)){               
                _isAsset[token] = true;
            }
            _actualInputBase = getAddedAmount(USDV, token);
        }
        uint _actualInputToken = getAddedAmount(token, token);
        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);
        mapTokenMember_Units[token][member] += liquidityUnits;  
        mapToken_Units[token] += liquidityUnits;                
        mapToken_baseAmount[token] += _actualInputBase;         
        mapToken_tokenAmount[token] += _actualInputToken;       
        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, tx.origin); 
    }
    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, msg.sender); 
    }
    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {
        require(base == USDV || base == VADER);
        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);
        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);
        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);
        mapToken_Units[token] -=_units;
        mapTokenMember_Units[token][member] -= _units;
        mapToken_baseAmount[token] -= outputBase;
        mapToken_tokenAmount[token] -= outputToken;
        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);
        transferOut(base, outputBase, member);
        transferOut(token, outputToken, member);
        return (outputBase, outputToken);
    }
    
    
    
    
    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {
        if(toBase){
            uint _actualInput = getAddedAmount(token, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            mapToken_tokenAmount[token] += _actualInput;
            mapToken_baseAmount[token] -= outputAmount;
            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);
            transferOut(base, outputAmount, member);
        } else {
            uint _actualInput = getAddedAmount(base, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            mapToken_baseAmount[token] += _actualInput;
            mapToken_tokenAmount[token] -= outputAmount;
            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);
            transferOut(token, outputAmount, member);
        }
    }

    
    function sync(address token, address pool) external {
        uint _actualInput = getAddedAmount(token, pool);
        if (token == VADER || token == USDV){
            mapToken_baseAmount[pool] += _actualInput;
        } else {
            mapToken_tokenAmount[pool] += _actualInput;
        
        
        }
        emit Sync(token, pool, _actualInput);
    }

    

    
    function deploySynth(address token) external {
        require(token != VADER || token != USDV);
        iFACTORY(FACTORY).deploySynth(token);
    }

    
    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {
        require(iFACTORY(FACTORY).isSynth(getSynth(token)), ""!synth"");
        uint _actualInputBase = getAddedAmount(base, token);                    
        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     
        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   
        mapTokenMember_Units[token][address(this)] += _synthUnits;                  
        mapToken_Units[token] += _synthUnits;                                       
        mapToken_baseAmount[token] += _actualInputBase;                             
        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   
        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         
    }
    
    function burnSynth(address base, address token, address member) external returns (uint outputBase) {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); 
        iERC20(getSynth(token)).burn(_actualInputSynth);                            
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               
        mapToken_Units[token] -= _unitsToDelete;                                    
        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    
        mapToken_baseAmount[token] -= outputBase;                                   
        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        
        transferOut(base, outputBase, member);                                      
    }
    
    function syncSynth(address token) external {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); 
        iERC20(getSynth(token)).burn(_actualInputSynth);                            
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               
        mapToken_Units[token] -= _unitsToDelete;                                    
        emit SynthSync(token, _actualInputSynth, _unitsToDelete);
    }

    
    
    
    function lockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][member] -= units;
        mapTokenMember_Units[token][msg.sender] += units;       
    }
    
    function unlockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][msg.sender] -= units;      
        mapTokenMember_Units[token][member] += units;
    }

    

    
    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(_token == VADER && _pool != VADER){  
            addedAmount = _balance - pooledVADER;
            pooledVADER = pooledVADER + addedAmount;
        } else if(_token == USDV) {             
            addedAmount = _balance - pooledUSDV;
            pooledUSDV = pooledUSDV + addedAmount;
        } else {                                
            addedAmount = _balance - mapToken_tokenAmount[_pool];
        }
    }
    function transferOut(address _token, uint _amount, address _recipient) internal {
        if(_token == VADER){
            pooledVADER = pooledVADER - _amount; 
        } else if(_token == USDV) {
            pooledUSDV = pooledUSDV - _amount;  
        }
        if(_recipient != address(this)){
            iERC20(_token).transfer(_recipient, _amount);
        }
    }

    function isMember(address member) public view returns(bool) {
        return _isMember[member];
    }
    function isAsset(address token) public view returns(bool) {
        return _isAsset[token];
    }
    function isAnchor(address token) public view returns(bool) {
        return _isAnchor[token];
    }
    function getPoolAmounts(address token) external view returns(uint, uint) {
        return (getBaseAmount(token), getTokenAmount(token));
    }
    function getBaseAmount(address token) public view returns(uint) {
        return mapToken_baseAmount[token];
    }
    function getTokenAmount(address token) public view returns(uint) {
        return mapToken_tokenAmount[token];
    }
    function getUnits(address token) external view returns(uint) {
        return mapToken_Units[token];
    }
    function getMemberUnits(address token, address member) external view returns(uint) {
        return mapTokenMember_Units[token][member];
    }
    function getSynth(address token) public view returns (address) {
        return iFACTORY(FACTORY).getSynth(token);
    }
    function isSynth(address token) public view returns (bool) {
        return iFACTORY(FACTORY).isSynth(token);
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
}",2584.0,6,4,"{
  ""Findings"": [
    {
      ""Issue"": ""Use of `tx.origin` in Authorization"",
      ""Severity"": ""High"",
      ""Description"": ""The use of `tx.origin` for determining caller identity in functions such as `removeLiquidity` poses security risks as it can be spoofed by malicious contracts, leading to phishing attacks and unauthorized actions."",
      ""Impact"": ""Malicious actors could trick users into executing functions unintentionally, resulting in potential financial loss and unauthorized liquidity removal."",
      ""Location"": ""Function `removeLiquidity`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The use of `tx.origin` is a well-known anti-pattern in smart contracts, making this finding highly relevant.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `_removeLiquidity`, `transferOut`, and `swap` are susceptible to reentrancy attacks due to external calls being made before state updates."",
      ""Impact"": ""Attackers could exploit these vulnerabilities to manipulate contract state and drain funds."",
      ""Location"": ""Functions `_removeLiquidity`, `transferOut`, `swap`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Reentrancy vulnerabilities are critical concerns in smart contracts, relevant to maintaining security.""
    },
    {
      ""Issue"": ""Lack of Access Control on Sensitive Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `addLiquidity`, `removeLiquidity`, `swap`, and `deploySynth` lack access control mechanisms, allowing any user to invoke them without restrictions."",
      ""Impact"": ""This could lead to unauthorized manipulation of the liquidity pool, resulting in financial exploitation and compromised pool integrity."",
      ""Location"": ""Functions `addLiquidity`, `removeLiquidity`, `swap`, `deploySynth`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The absence of access control mechanisms is a critical security oversight that directly impacts the contract's integrity.""
    },
    {
      ""Issue"": ""Unchecked External Contract Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""External calls made in functions like `mintSynth`, `burnSynth`, `addLiquidity`, and `removeLiquidity` do not validate return values, risking unexpected behavior or failures."",
      ""Impact"": ""This can lead to unintended consequences and discrepancies in contract operations, potentially resulting in financial loss."",
      ""Location"": ""Functions like `mintSynth`, `burnSynth`, `addLiquidity`, `removeLiquidity`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Unchecked external calls are a common vulnerability in smart contracts, making this finding highly relevant.""
    },
    {
      ""Issue"": ""Arithmetic Operations Not Using SafeMath"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations across various functions do not utilize safe math libraries, leading to potential overflow or underflow issues."",
      ""Impact"": ""This could cause incorrect calculations of token amounts or liquidity units, leading to financial discrepancies and potential exploits."",
      ""Location"": ""Various functions including `addLiquidity`, `removeLiquidity`, `transferOut`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The lack of safe math operations is a critical area for improvement, relevant for contract correctness.""
    },
    {
      ""Issue"": ""Lack of Initialization Check"",
      ""Severity"": ""Low"",
      ""Description"": ""The `init` function does not validate the addresses provided, which could result in the contract being initialized with invalid addresses."",
      ""Impact"": ""Improper initialization could lead to loss of funds or failure of contract operations."",
      ""Location"": ""Function `init`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring valid initialization is essential for contract functionality.""
    },
    {
      ""Issue"": ""Redundant Condition in `deploySynth` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The condition `require(token != VADER || token != USDV);` is always true and serves no functional purpose."",
      ""Impact"": ""While it does not affect functionality, it could mislead developers and marginally increase gas costs."",
      ""Location"": ""Function `deploySynth`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The condition is unnecessary and should be removed for clarity.""
    }
  ],
  ""FindingNumber"": 7,
  ""AllRelevance"": 34,
  ""RelevanceCount"": 25,
  ""AllValidation"": 28,
  ""ValidationCount"": 24
}","---

### **[H-01] Unhandled return value of transfer in transferOut() of Pools.sol**

**Report Description**:
The `transferOut()` function in `Pools.sol` does not handle the return value of the `transfer` call. Some ERC20 tokens may return `false` on failure instead of reverting. Not checking the return value could allow token transfers to silently fail, especially when dealing with untrusted tokens supplied by users. This oversight may lead to discrepancies in token balances and potential security vulnerabilities if malicious tokens are used.

**Match in Response List**:
Matches with the issue titled **""Unchecked External Contract Calls""**.

**Validation**:
**Correct**. The response highlights the issue of unchecked external calls in functions like `mintSynth`, `burnSynth`, `addLiquidity`, and `removeLiquidity`, which is directly relevant to the problem in the `transferOut()` function. The risk of silent failure when interacting with untrusted ERC20 tokens is identified correctly. The solution involves wrapping these calls with `require()` to ensure failures are handled, which aligns with Solidity best practices.

---

### **[H-11] Swap token can be traded as fake base token**

**Report Description**:
The `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer tokens to the pool and set `base=token` and call `swap(token, token, member, toBase=false)`. This results in an incorrect swap calculation, breaking the accounting for the pool. This could lead to LPs being unable to withdraw properly or malicious actors manipulating the pool to steal tokens.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not contain any direct reference to this issue. This is a unique problem where the contract allows users to perform an unauthorized swap between tokens, which the response list does not address. The absence of any validation checks on the `base` token in the `swap` function leads to incorrect accounting and can result in financial exploitation, which is not captured in the existing response list.

---

### **[H-12] getAddedAmount can return wrong results**

**Report Description**:
The `getAddedAmount` function returns incorrect results when called with mismatched tokens (e.g., `token` and `pool`). This leads to incorrect liquidity pool accounting, which can break swap logic and potentially allow exploits when the balance of different tokens is manipulated.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. There is no mention of the `getAddedAmount` function or liquidity pool accounting issues in the response list. This issue centers on incorrect accounting and potential exploit scenarios when calling `sync()` with mismatched tokens. It is a unique vulnerability not covered by any response in the list, making it an important gap.

---

### **[H-13] 4 Synths can be minted with fake base token**

**Report Description**:
The `Pools.mintSynth` function does not check if `base` is one of the base tokens. An attacker can manipulate the pool by transferring tokens and calling `mintSynth(token, token, member)`, leading to incorrect swap calculations and breaking pool accounting.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. This issue mirrors the one in [H-11], where there is a lack of validation in the `mintSynth` function regarding whether the base token is legitimate. It directly impacts pool accounting, but the response list does not cover this specific scenario. The response list should address this type of unvalidated token manipulation, which can lead to significant exploits.

---

### **[H-14] Missing access restriction on lockUnits/unlockUnits**

**Report Description**:
The `lockUnits` and `unlockUnits` functions allow anyone to steal pool tokens from a member and assign them to `msg.sender`. Access control is missing, making the functions highly vulnerable to unauthorized exploitation.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Sensitive Functions""**.

**Validation**:
**Correct**. The response accurately identifies the problem of missing access control on critical functions such as `addLiquidity`, `removeLiquidity`, `swap`, and `deploySynth`, and extends this concern to `lockUnits` and `unlockUnits`. The lack of proper authorization mechanisms poses a serious security risk, and the recommendation to implement access control is in line with Solidity best practices.

---

### **[H-22] Users may unintentionally remove liquidity under a phishing attack**

**Report Description**:
The `removeLiquidity` function uses `tx.origin` to determine the person removing liquidity, which is prone to phishing attacks. If a malicious actor tricks a user into calling this function, they could unintentionally remove liquidity from the pool.

**Match in Response List**:
Matches with the issue titled **""Use of `tx.origin` in Authorization""**.

**Validation**:
**Correct**. The response addresses the security issue of using `tx.origin` for identity validation, which is indeed a well-known anti-pattern and highly vulnerable to phishing attacks. This finding is directly relevant to the issue described in the report, where the use of `tx.origin` for authorization is insecure, allowing attackers to manipulate liquidity removal.

---

### **[M-01] User may not get IL protection if certain functions are called directly in Pools.sol**

**Report Description**:
Users do not receive Impermanent Loss (IL) protection if they call `removeLiquidity()` or `removeLiquidityDirectly()` directly from the contract rather than through the router, which is the intended mechanism for providing IL protection.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. There is no mention of IL protection or the direct calling of liquidity functions in the response list. The report describes a critical scenario where bypassing the router prevents users from getting IL protection, a feature that is essential for maintaining the security and fairness of liquidity operations. This is a significant gap in the response list.

---

### **[M-10] Incorrect operator used in deploySynth() of Pools.sol**

**Report Description**:
The `deploySynth()` function uses the incorrect `||` operator in the `require` statement when checking the token parameter. This allows both VADER and USDV to be used as tokens, which breaks protocol assumptions and could result in vulnerabilities or fund loss.

**Match in Response List**:
Matches with the issue titled **""Redundant Condition in `deploySynth` Function""**.

**Validation**:
**Correct**. The response correctly identifies the redundancy and logical flaw in the `require` condition in `deploySynth()`. Using `||` instead of `&&` leads to an incorrect check that allows both VADER and USDV to be used as tokens when they should not be. The recommendation to remove the redundant condition is valid.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init()` function in `Pools.sol` is accessible by anyone, which could lead to incorrect initialization of the contract or malicious actions during initialization.

**Match in Response List**:
Matches with the issue titled **""Lack of Initialization Check""**.

**Validation**:
**Correct**. The response identifies the risk associated with an open `init()` function that can be called by anyone, leading to improper initialization. Ensuring only authorized parties can invoke initialization functions is a key security measure, which is correctly highlighted in the response.

---

### **[M-14] Pool functions can be called before initialization in _init_() of Pools.sol**

**Report Description**:
The external functions in `Pools.sol` can be called before the contract is fully initialized, potentially leading to incorrect state, exceptions, or other security issues.

**Match in Response List**:
Matches with **""Lack of Initialization Check""**.

**Validation**:
**Correct**. The response addresses the need to validate initialization, aligning with best practices.
---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] Unhandled return value of transfer in transferOut() of Pools.sol** → ""Unchecked External Contract Calls""
- **[H-14] Missing access restriction on lockUnits/unlockUnits** → ""Lack of Access Control on Sensitive Functions""
- **[H-22] Users may unintentionally remove liquidity under a phishing attack** → ""Use of `tx.origin` in Authorization""
- **[M-10] Incorrect operator used in deploySynth() of Pools.sol** → ""Redundant Condition in `deploySynth` Function""
- **[M-13] Init function can be called by everyone** → ""Lack of Initialization Check""
- **[M-14] Pool functions can be called before initialization in _init_() of Pools.sol**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-11] Swap token can be traded as fake base token**
- **[H-12] getAddedAmount can return wrong results**
- **[H-13] 4 Synths can be minted with fake base token**
- **[M-01] User may not get IL protection if certain functions are called directly in Pools.sol**

",6,0,4,7,34,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Unhandled return value of transfer in transferOut() of Pools.sol**

**Report Description**:  
The `transferOut()` function in `Pools.sol` does not handle the return value of the `transfer` call. Some ERC20 tokens may return `false` on failure instead of reverting. Not checking the return value could allow token transfers to silently fail, especially when dealing with untrusted tokens supplied by users. This oversight may lead to discrepancies in token balances and potential security vulnerabilities if malicious tokens are used.

**Match in Response List**:  
Matches with the issue titled **""Unchecked External Contract Calls""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with unchecked external calls in the `transferOut` function. It correctly explains the risks associated with not validating return values from external `transfer` calls, which aligns with Solidity best practices for secure contract interactions.

---

#### **[H-11] Swap token can be traded as fake base token**

**Report Description**:  
The `Pools.swap` function does not check if `base` is one of the base tokens. This allows a user to transfer tokens to the pool, set `base=token`, and call `swap(token, token, member, toBase=false)`. This breaks the accounting for the pool, as tokens are transferred in, but the `base` balance is increased (and `token` balance decreased). This could lead to incorrect swap results, liquidity provider (LP) withdrawal issues, and potential token theft.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this specific vulnerability, which involves incorrect accounting and potential token theft due to the lack of validation of the `base` token in the `swap` function.

---

#### **[H-12] getAddedAmount can return wrong results**

**Report Description**:  
The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. When called with `(token, pool)` where `token` is neither `VADER/USDV/pool`, it returns incorrect results. This can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`, leading to incorrect accounting and swap logic.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which involves incorrect calculations in the `getAddedAmount` function and its impact on pool accounting.

---

#### **[H-13] Synths can be minted with fake base token**

**Report Description**:  
The `Pools.mintSynth` function does not check if `base` is one of the base tokens. This allows a user to transfer tokens to the pool, set `base=token`, and call `mintSynth(token, token, member)`. This breaks the accounting for the pool, as tokens are transferred in, but the `base` balance is increased.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which involves incorrect accounting in the `mintSynth` function due to the lack of validation of the `base` token.

---

#### **[H-14] Missing access restriction on lockUnits/unlockUnits**

**Report Description**:  
The `Pool.lockUnits` function allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`. This is a critical access control issue that could lead to unauthorized token transfers.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Sensitive Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with missing access control in functions like `lockUnits`. It correctly explains the risks associated with unauthorized access, which aligns with Solidity best practices for secure contract design.

---

#### **[H-22] Users may unintentionally remove liquidity under a phishing attack**

**Report Description**:  
The `removeLiquidity` function in `Pools.sol` uses `tx.origin` to determine the person who wants to remove liquidity. This design is dangerous, as it can be exploited in phishing attacks, leading to unintentional liquidity removal.

**Match in Response List**:  
Matches with the issue titled **""Use of `tx.origin` in Authorization""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the use of `tx.origin` in the `removeLiquidity` function. It correctly explains the risks associated with phishing attacks and unauthorized actions, which aligns with Solidity best practices for secure contract design.

---

#### **[M-01] User may not get IL protection if certain functions are called directly in Pools.sol**

**Report Description**:  
Functions `removeLiquidity()` and `removeLiquidityDirectly()` in `Pools.sol` do not provide impermanent loss (IL) protection when called directly, unlike when called through the `Router.sol` contract. This should be prevented or highlighted in the specification and user documentation.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which involves the lack of IL protection in certain functions and its impact on user experience and security.

---

#### **[M-10] Incorrect operator used in deploySynth() of Pools.sol**

**Report Description**:  
The `deploySynth()` function in `Pools.sol` incorrectly uses the `||` operator instead of `&&` in the `require` statement. This allows both `VADER` and `USDV` to be supplied as token parameters, breaking assumptions throughout the protocol and potentially leading to fund loss.

**Match in Response List**:  
Matches with the issue titled **""Redundant Condition in `deploySynth` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with the `require` statement in `deploySynth()` but mischaracterizes it as a redundant condition rather than an incorrect operator usage. The impact of the incorrect operator is not fully addressed.

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:  
The `init` function in most Solidity contracts can be called by anyone, which could lead to improper initialization and potential security risks.

**Match in Response List**:  
Matches with the issue titled **""Lack of Initialization Check""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `init` function and the risks associated with improper initialization, which aligns with Solidity best practices for secure contract design.

---

#### **[M-14] Pool functions can be called before initialization in _init_() of Pools.sol**

**Report Description**:  
All external/public functions of `Pools.sol` can be called before the contract is initialized, leading to exceptions, state corruption, or incorrect accounting in other contracts.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which involves the risks of calling functions before contract initialization.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] Unhandled return value of transfer in transferOut() of Pools.sol**
- **[H-14] Missing access restriction on lockUnits/unlockUnits**
- **[H-22] Users may unintentionally remove liquidity under a phishing attack**
- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- **[M-10] Incorrect operator used in deploySynth() of Pools.sol**

**Missed Issues from Issue Report**:

- **[H-11] Swap token can be traded as fake base token**
- **[H-12] getAddedAmount can return wrong results**
- **[H-13] Synths can be minted with fake base token**
- **[M-01] User may not get IL protection if certain functions are called directly in Pools.sol**
- **[M-14] Pool functions can be called before initialization in _init_() of Pools.sol**

--- 

The response list covers some critical issues but misses several vulnerabilities related to incorrect accounting, lack of validation, and initialization risks. Addressing these gaps is essential for comprehensive security.","```
1. Unchecked External Contract Calls
2. Lack of Access Control on Sensitive Functions
3. Use of `tx.origin` in Authorization
4. Lack of Initialization Check
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Unchecked External Contract Calls"" appears at rank 4.
   - ""Lack of Access Control on Sensitive Functions"" appears at rank 3.
   - ""Use of `tx.origin` in Authorization"" appears at rank 1.
   - ""Lack of Initialization Check"" appears at rank 6.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - At rank 3: \( P@3 = \frac{2}{3} \approx 0.6667 \)
   - At rank 4: \( P@4 = \frac{3}{4} = 0.75 \)
   - At rank 6: \( P@6 = \frac{4}{6} \approx 0.6667 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 0.6667 + 0.75 + 0.6667}{4} = \frac{3.0834}{4} \approx 0.7708
   \]

**Output**:
```
0.7708
```"
USDV.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";

contract USDV is iERC20 {

    // ERC-20 Parameters
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Parameters
    bool private inited;
    uint public nextEraTime;
    uint public blockDelay;

    address public VADER;
    address public VAULT;
    address public ROUTER;

    mapping(address => uint) public lastBlock;

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }
    // Stop flash attacks
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool isMatured){
        if(lastBlock[tx.origin] + blockDelay <= block.number){ // Stops an EOA doing a flash attack in same block
            return true;
        }
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
        name = 'VADER STABLE DOLLAR';
        symbol = 'USDV';
        decimals = 18;
        totalSupply = 0;
    }
    function init(address _vader, address _vault, address _router) external {
        require(inited == false);
        inited = true;
        VADER = _vader;
        VAULT = _vault;
        ROUTER = _router;
        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();
    }

    //========================================iERC20=========================================//
    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    // TransferTo function
    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. 
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(sender != address(0), ""sender"");
            _balances[sender] -= amount;
            _balances[recipient] += amount;
            emit Transfer(sender, recipient, amount);
            _checkIncentives();
        }
    }
    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(account != address(0), ""recipient"");
            totalSupply += amount;
            _balances[account] += amount;
            emit Transfer(address(0), account, amount);
        }
    }
    // Burn supply
    function burn(uint amount) external virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender)- amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(account != address(0), ""address err"");
            _balances[account] -= amount;
            totalSupply -= amount;
            emit Transfer(account, address(0), amount);
        }
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newDelay) external onlyDAO {
        blockDelay = newDelay;
    }

   //======================================INCENTIVES========================================//
    // Internal - Update incentives function
    function _checkIncentives() private {
        if (block.timestamp >= nextEraTime && emitting()) {                 // If new Era
            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _balance = iERC20(VADER).balanceOf(address(this));         // Get spare VADER
            if(_balance > 4){
                uint _USDVShare = _balance/2;                                   // Get 50%
                _convert(address(this), _USDVShare);                            // Convert it
                if(balanceOf(address(this)) > 2){
                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              // Send half USDV to ROUTER
                    _transfer(address(this), VAULT, balanceOf(address(this)));                   // Send rest to VAULT
                }
                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   // Send half VADER to ROUTER
                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      // Send rest to VAULT
            }
        }
    }
    
    //======================================ASSET MINTING========================================//
    // Convert to USDV
    function convert(uint amount) external returns(uint) {
        return convertForMember(msg.sender, amount);
    }
    // Convert for members
    function convertForMember(address member, uint amount) public returns(uint) {
        getFunds(VADER, amount);
        return _convert(member, amount);
    }
    // Internal convert
    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){
        if(minting()){
            lastBlock[tx.origin] = block.number;                    // Record first
            iERC20(VADER).burn(amount);
            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); // Critical pricing functionality
            _mint(_member, _convertAmount);
        }
    }
    // Redeem to VADER
    function redeem(uint amount) external returns(uint) {
        return redeemForMember(msg.sender, amount);
    }
    // Contracts to redeem for members
    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {
        _transfer(msg.sender, VADER, amount);                   // Move funds
        redeemAmount = iVADER(VADER).redeemToMember(member);    // Ask VADER to redeem
        lastBlock[tx.origin] = block.number;                    // Must record block AFTER the tx
    }

    //============================== ASSETS ================================//

    function getFunds(address token, uint amount) internal {
        if(token == address(this)){
            _transfer(msg.sender, address(this), amount);
        } else {
            if(tx.origin==msg.sender){
                require(iERC20(token).transferTo(address(this), amount));
            }else{
                require(iERC20(token).transferFrom(msg.sender, address(this), amount));
            }
        }
    }

    //============================== HELPERS ================================//

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function minting() public view returns(bool){
        return iVADER(VADER).minting();
    }

}",1842.0,219.0,"[H-02] Flash attack mitigation does not work as intended in USDV.sol
One of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0, which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: ""// Stops an EOA from doing a flash attack in the same block""
  [H-16] Tokens can be stolen through transferTo
VADER, USDV, SYNTHS all employ the `transferTo(`) function, which interrogates for `tx.origin` and skips approvals. The author does not subscribe to the belief that this is dangerous   [M-13] Init function can be called by everyone
Most of the solidity contracts have an `init` function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.",3.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";

contract USDV is iERC20 {

    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;
    
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    bool private inited;
    uint public nextEraTime;
    uint public blockDelay;

    address public VADER;
    address public VAULT;
    address public ROUTER;

    mapping(address => uint) public lastBlock;

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }
    
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool isMatured){
        if(lastBlock[tx.origin] + blockDelay <= block.number){ 
            return true;
        }
    }

    constructor() {
        name = 'VADER STABLE DOLLAR';
        symbol = 'USDV';
        decimals = 18;
        totalSupply = 0;
    }
    function init(address _vader, address _vault, address _router) external {
        require(inited == false);
        inited = true;
        VADER = _vader;
        VAULT = _vault;
        ROUTER = _router;
        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();
    }

    
    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    
    
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        if(amount > 0){                                     
            require(sender != address(0), ""sender"");
            _balances[sender] -= amount;
            _balances[recipient] += amount;
            emit Transfer(sender, recipient, amount);
            _checkIncentives();
        }
    }
    
    function _mint(address account, uint amount) internal virtual {
        if(amount > 0){                                     
            require(account != address(0), ""recipient"");
            totalSupply += amount;
            _balances[account] += amount;
            emit Transfer(address(0), account, amount);
        }
    }
    
    function burn(uint amount) external virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender)- amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        if(amount > 0){                                     
            require(account != address(0), ""address err"");
            _balances[account] -= amount;
            totalSupply -= amount;
            emit Transfer(account, address(0), amount);
        }
    }

    
    
    function setParams(uint newDelay) external onlyDAO {
        blockDelay = newDelay;
    }

   
    
    function _checkIncentives() private {
        if (block.timestamp >= nextEraTime && emitting()) {                 
            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _balance = iERC20(VADER).balanceOf(address(this));         
            if(_balance > 4){
                uint _USDVShare = _balance/2;                                   
                _convert(address(this), _USDVShare);                            
                if(balanceOf(address(this)) > 2){
                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              
                    _transfer(address(this), VAULT, balanceOf(address(this)));                   
                }
                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   
                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      
            }
        }
    }
    
    
    
    function convert(uint amount) external returns(uint) {
        return convertForMember(msg.sender, amount);
    }
    
    function convertForMember(address member, uint amount) public returns(uint) {
        getFunds(VADER, amount);
        return _convert(member, amount);
    }
    
    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){
        if(minting()){
            lastBlock[tx.origin] = block.number;                    
            iERC20(VADER).burn(amount);
            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); 
            _mint(_member, _convertAmount);
        }
    }
    
    function redeem(uint amount) external returns(uint) {
        return redeemForMember(msg.sender, amount);
    }
    
    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {
        _transfer(msg.sender, VADER, amount);                   
        redeemAmount = iVADER(VADER).redeemToMember(member);    
        lastBlock[tx.origin] = block.number;                    
    }

    

    function getFunds(address token, uint amount) internal {
        if(token == address(this)){
            _transfer(msg.sender, address(this), amount);
        } else {
            if(tx.origin==msg.sender){
                require(iERC20(token).transferTo(address(this), amount));
            }else{
                require(iERC20(token).transferFrom(msg.sender, address(this), amount));
            }
        }
    }

    

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function minting() public view returns(bool){
        return iVADER(VADER).minting();
    }

}",1487.0,2,1,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on `init` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `init` function can be called by any external account, allowing them to set the addresses for VADER, VAULT, and ROUTER, which can lead to malicious control over the contract's critical parameters."",
      ""Impact"": ""An attacker could initialize the contract with malicious addresses, potentially redirecting funds and compromising the contract's functionality."",
      ""Location"": ""Function `init` defined in lines 27-44"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding accurately identifies a critical vulnerability where the lack of access control allows any user to initialize the contract with arbitrary addresses.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `_transfer`, `convertForMember`, `redeemForMember`, and `getFunds` involve external calls and state updates that can potentially be exploited via reentrancy attacks."",
      ""Impact"": ""An attacker could execute unintended transactions and manipulate contract state, leading to loss of funds or mismanagement."",
      ""Location"": ""Functions `_transfer`, `convertForMember`, `redeemForMember`, and `getFunds`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The findings are valid as they highlight the risk of reentrancy due to external calls without proper handling, which is crucial for maintaining contract integrity.""
    },
    {
      ""Issue"": ""Use of `tx.origin` for Security Checks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `tx.origin` in functions like `flashProof`, `isMature`, `getFunds`, and others, which is insecure as it makes the contract vulnerable to phishing attacks."",
      ""Impact"": ""An attacker could trick users into executing transactions through malicious contracts, leading to unauthorized actions."",
      ""Location"": ""Functions using `tx.origin`, including `flashProof`, `isMature`, `convertForMember`, and `getFunds`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The use of `tx.origin` is a known anti-pattern in Solidity due to its potential to allow phishing attacks.""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions like `init` and `setParams` modify critical state variables without emitting events, which reduces transparency and makes tracking changes difficult."",
      ""Impact"": ""This can hinder off-chain monitoring tools from accurately tracking changes in contract state."",
      ""Location"": ""Functions `init` and `setParams`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Emitting events on state changes is a best practice for transparency and debugging.""
    }
  ],
  ""FindingNumber"": 4,
  ""AllRelevance"": 32,
  ""RelevanceCount"": 16,
  ""AllValidation"": 32,
  ""ValidationCount"": 16
}","### **Issue 1: [H-02] Flash attack mitigation does not work as intended in USDV.sol**

**Report Description**:  
The `flashProof()` modifier uses the `isMature()` check to prevent flash attacks by ensuring that the contract context is at least `blockDelay` blocks ahead of the previous context. However, `blockDelay` is not initialized and defaults to 0, making the check ineffective. This could allow attackers to trigger flash loan attacks by executing multiple calls within the same block.

**Match in Response List**:  
Matches with the issue titled **""Use of `tx.origin` for Security Checks""**.

**Validation**:  
**Partially Correct**.  
While the response highlights a security concern about the use of `tx.origin`—which is indeed a potential vulnerability in the contract—it doesn't address the specific problem described in the report: the improper initialization of the `blockDelay` variable and its role in flash attack prevention. The response seems to focus more on phishing attacks related to `tx.origin`, which isn't directly related to the issue of flash loan attacks or the uninitialized state variable. The absence of the `blockDelay` initialization is a separate issue and needs to be addressed independently from the `tx.origin` concern.

---

### **Issue 2: [H-16] Tokens can be stolen through transferTo**

**Report Description**:  
The `transferTo()` function uses `tx.origin` for checks and skips approvals, which could lead to security risks like unauthorized transfers, especially when interacting with untrusted external contracts.

**Match in Response List**:  
Matches with the issue titled **""Use of `tx.origin` for Security Checks""**.

**Validation**:  
**Correct**.  
The response accurately identifies the use of `tx.origin` as a vulnerability, explaining that its use in security checks can enable phishing attacks. This is directly relevant to the vulnerability described in the issue, where relying on `tx.origin` for transaction security could allow malicious actors to trick users into performing unauthorized actions, like token transfers.

---

### **Issue 3: [M-13] Init function can be called by everyone**

**Report Description**:  
The `init` function can be called by anyone, which could lead to a race condition during contract deployment. A malicious user could call the `init` function early, potentially compromising the contract and requiring a costly redeployment.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on `init` Function""**.

**Validation**:  
**Correct**.  
The response correctly identifies that the lack of access control on the `init` function poses a significant risk. It emphasizes that any external account could call the `init` function, leading to the potential manipulation of critical contract parameters. This matches the concern raised in the report about a race condition during deployment and malicious initialization.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[H-16] Tokens can be stolen through transferTo** – ""Use of `tx.origin` for Security Checks""  
- **[M-13] Init function can be called by everyone** – ""Lack of Access Control on `init` Function""

**Partially Correct Matches**:  
- **[H-02] Flash attack mitigation does not work as intended in USDV.sol** – ""Use of `tx.origin` for Security Checks""

**Missed Issues from Issue Report**:  
- No issue missed; however, the response to **[H-02]** could be more specific about the initialization problem with `blockDelay`.

---

The responses provide good coverage for most of the issues raised in the report, but there's room for improvement in specifically addressing each vulnerability's root cause.
",2,1,0,4,32,"### **Comparison of Issue Report and Response List**

---

#### **[H-02] Flash attack mitigation does not work as intended in USDV.sol**

**Report Description**:  
The `flashProof()` modifier in `USDV.sol` is intended to protect against flash attacks by ensuring that the current block number is at least `blockDelay` ahead of the previous block number (`lastBlock[tx.origin] + blockDelay <= block.number`). However, `blockDelay` is not initialized and defaults to 0, allowing multiple calls to be executed in the same block. This defeats the intended protection against flash attacks, as the contract remains vulnerable to such attacks unless `blockDelay` is set to a value greater than or equal to 1 by the DAO (which currently lacks the capability to call `setParams()`).

**Match in Response List**:  
No direct match found. The response list does not address the specific issue of `blockDelay` being uninitialized or the failure of the `flashProof()` modifier to mitigate flash attacks.

**Validation**:  
**Incorrect**. The response list does not identify or address this issue. The vulnerability remains unacknowledged, and the proposed solutions in the response list do not cover this specific problem.

---

#### **[H-16] Tokens can be stolen through `transferTo`**

**Report Description**:  
The `transferTo()` function in VADER, USDV, and SYNTHS contracts uses `tx.origin` for security checks and skips approvals. This design is dangerous as it allows tokens to be stolen if an attacker tricks a user into interacting with a malicious contract. The author dismisses this concern, but it remains a significant security risk.

**Match in Response List**:  
Matches with the issue titled **""Use of `tx.origin` for Security Checks""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of using `tx.origin` for security checks, which aligns with the issue described in the report. The response correctly highlights the potential for phishing attacks and unauthorized actions, addressing the core concern.

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:  
The `init` function in most Solidity contracts can be called by anyone, leading to a race condition during deployment. A hacker could call the `init` function immediately after deployment, rendering the contracts useless and requiring redeployment, which incurs significant gas costs.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on `init` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the lack of access control on the `init` function, which allows any external account to initialize the contract with malicious addresses. This aligns with the issue described in the report, addressing the core vulnerability and its potential impact.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-16] Tokens can be stolen through `transferTo`**  
- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-02] Flash attack mitigation does not work as intended in USDV.sol**

---

### **Conclusion**  
The response list effectively addresses two of the three issues in the report, accurately identifying and validating the risks associated with the use of `tx.origin` and the lack of access control on the `init` function. However, it fails to address the critical issue of the `flashProof()` modifier's failure to mitigate flash attacks due to the uninitialized `blockDelay` variable. This gap highlights the need for a more comprehensive review of the contract's security mechanisms.","```
1. Use of `tx.origin` for Security Checks
2. Lack of Access Control on `init` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Use of `tx.origin` for Security Checks"" appears at rank 3.
   - ""Lack of Access Control on `init` Function"" appears at rank 1.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - At rank 3: \( P@3 = \frac{2}{3} \approx 0.6667 \)

3. **Average the precision values to compute the Average Precision (AP)**:
   \[
   AP = \frac{1.0 + 0.6667}{2} = \frac{1.6667}{2} \approx 0.8333
   \]

**Output**:
```
0.8333
```"
Vader.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iUSDV.sol"";
import ""./interfaces/iROUTER.sol"";

contract Vader is iERC20 {

    // ERC-20 Parameters
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Parameters
    bool private inited;
    bool public emitting;
    bool public minting;
    uint _1m;
    uint public baseline;
    uint public emissionCurve;
    uint public maxSupply;
    uint public secondsPerEra;
    uint public currentEra;
    uint public nextEraTime;
    uint public feeOnTransfer;

    address public VETHER;
    address public USDV;
    address public UTILS;
    address public burnAddress;
    address public rewardAddress;
    address public DAO;

    event NewEra(uint currentEra, uint nextEraTime, uint emission);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO, ""Not DAO"");
        _;
    }
    // Stop flash attacks
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool){
        return iUSDV(USDV).isMature();
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
        name = 'VADER PROTOCOL TOKEN';
        symbol = 'VADER';
        decimals = 18;
        _1m = 10**6 * 10 ** decimals; //1m
        baseline = _1m;
        totalSupply = 0;
        maxSupply = 2 * _1m;
        currentEra = 1;
        secondsPerEra = 1; //86400;
        nextEraTime = block.timestamp + secondsPerEra;
        emissionCurve = 900;
        DAO = msg.sender;
        burnAddress = 0x0111011001100001011011000111010101100101;
    }
    // Can only be called once
    function init(address _vether, address _USDV, address _utils) external {
        require(inited == false);
        inited = true;
        VETHER = _vether;
        USDV = _USDV;
        UTILS = _utils;
        rewardAddress = _USDV;
    }

    //========================================iERC20=========================================//
    function balanceOf(address account) external view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    // TransferTo function
    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. 
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        require(sender != address(0), ""sender"");
        require(recipient != address(this), ""recipient"");
        _balances[sender] -= amount;
        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  // Critical functionality
        if(_fee >= 0 && _fee <= amount){                            // Stops reverts if UTILS corrupted
            amount -= _fee;
            _burn(msg.sender, _fee);
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        _checkEmission();
    }
    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint amount) internal virtual {
        require(account != address(0), ""recipient"");
        if((totalSupply + amount) >= maxSupply){
            amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply
        }
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    // Burn supply
    function burn(uint amount) public virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender) - amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        require(account != address(0), ""address err"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //=========================================DAO=========================================//
    // Can start
    function flipEmissions() external onlyDAO {
        if(emitting){
            emitting = false;
        } else {
            emitting = true;
        }
    }
    // Can stop
    function flipMinting() external onlyDAO {
        if(minting){
            minting = false;
        } else {
            minting = true;
        }
    }
    // Can set params
    function setParams(uint newEra, uint newCurve) external onlyDAO {
        secondsPerEra = newEra;
        emissionCurve = newCurve;
    }
    // Can set reward address
    function setRewardAddress(address newAddress) external onlyDAO {
        rewardAddress = newAddress;
    }
    // Can change UTILS
    function changeUTILS(address newUTILS) external onlyDAO {
        require(newUTILS != address(0), ""address err"");
        UTILS = newUTILS;
    }
    // Can change DAO
    function changeDAO(address newDAO) external onlyDAO {
        require(newDAO != address(0), ""address err"");
        DAO = newDAO;
    }
    // Can purge DAO
    function purgeDAO() external onlyDAO{
        DAO = address(0);
    }

   //======================================EMISSION========================================//
    // Internal - Update emission function
    function _checkEmission() private {
        if ((block.timestamp >= nextEraTime) && emitting) {                                // If new Era and allowed to emit
            currentEra += 1;                                                               // Increment Era
            nextEraTime = block.timestamp + secondsPerEra;                                 // Set next Era time
            uint _emission = getDailyEmission();                                           // Get Daily Dmission
            _mint(rewardAddress, _emission);                                               // Mint to the Rewad Address
            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        // UpdateFeeOnTransfer
            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                // Max 10% if UTILS corrupted
            emit NewEra(currentEra, nextEraTime, _emission);                               // Emit Event
        }
    }
    // Calculate Daily Emission
    function getDailyEmission() public view returns (uint) {
        uint _adjustedMax;
        if(totalSupply <= baseline){ // If less than 1m, then adjust cap down
            _adjustedMax = (maxSupply * totalSupply) / baseline; // 2m * 0.5m / 1m = 2m * 50% = 1.5m
        } else {
            _adjustedMax = maxSupply;  // 2m
        }
        return (_adjustedMax - totalSupply) / (emissionCurve); // outstanding / curve 
    }

    //======================================ASSET MINTING========================================//
    // VETHER Owners to Upgrade
    function upgrade(uint amount) external {
        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));
        _mint(msg.sender, amount);
    }
    // Directly redeem back to VADER (must have sent USDV first)
    function redeem() external returns (uint redeemAmount){
        return redeemToMember(msg.sender);
    }
    // Redeem on behalf of member (must have sent USDV first)
    function redeemToMember(address member) public flashProof returns (uint redeemAmount){
        if(minting){
            uint _amount = iERC20(USDV).balanceOf(address(this)); 
            iERC20(USDV).burn(_amount);
            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); // Critical pricing functionality
            _mint(member, redeemAmount);
        }
    }
}",2091.0,245.0,"[H-03] Missing DAO functionality to call changeDAO() function in Vader.sol
`changeDAO()` is authorized to be called only from the DAO (per modifier) but DAO contract has no corresponding functionality to call `changeDAO()` function. As a result, DAO address cannot be changed (L192-L196).
  [H-06] Incorrect burn address in Vader.sol
The `internal _transfer()` function is called from external facing `transfer()`, `transferFrom()`, and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo().
These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.
This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.
  [H-16] Tokens can be stolen through transferTo
VADER, USDV, SYNTHS all employ the transferTo() function, which interrogates for tx.origin and skips approvals. The author does not subscribe to the belief that this is dangerous   [H-17] Transfer fee is burned on wrong accounts
The Vader._transfer function burns the transfer fee on msg.sender but this address might not be involved in the transfer at all due to transferFrom.
Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.

 [H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol
Incorrect initialization (perhaps testing parameterization mistakenly carried over to deployment) of secondsPerEra to 1 sec instead of 86400 secs (1 day) causes what should be the daily emission rate to be a secondly emission rate.
This causes inflation of VADER token and likely breaks VADER<>USDV peg and other protocol invariants. Protocol will break and funds will be lost.
  [M-04] flashProof is not flash-proof
The flashProof modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.
However, it performs this check on tx.origin and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.
  [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the `init` function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas. function init()   [M-15] changeDAO should be a two-step process in Vader.sol
`changeDAO()` updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires msg.sender to be the incorrectly used DAO address (for which private keys may not be available to sign transactions). See finding #6 from Trail of Bits audit of Hermez Network.   [M-17] Vader.redeemToMember() vulnerable to front running
The USDV balance of the Vader contract is vulnerable to theft through the Vader.redeemToMember() function. A particular case is through USDV redemption front-running. Users can redeem USDV for Vader through the USDV.redeemForMember() function or the Vader.redeemToMember() function.
",9.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iUSDV.sol"";
import ""./interfaces/iROUTER.sol"";

contract Vader is iERC20 {

    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    
    bool private inited;
    bool public emitting;
    bool public minting;
    uint _1m;
    uint public baseline;
    uint public emissionCurve;
    uint public maxSupply;
    uint public secondsPerEra;
    uint public currentEra;
    uint public nextEraTime;
    uint public feeOnTransfer;

    address public VETHER;
    address public USDV;
    address public UTILS;
    address public burnAddress;
    address public rewardAddress;
    address public DAO;

    event NewEra(uint currentEra, uint nextEraTime, uint emission);

    
    modifier onlyDAO() {
        require(msg.sender == DAO, ""Not DAO"");
        _;
    }
    
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool){
        return iUSDV(USDV).isMature();
    }

    
    
    constructor() {
        name = 'VADER PROTOCOL TOKEN';
        symbol = 'VADER';
        decimals = 18;
        _1m = 10**6 * 10 ** decimals; 
        baseline = _1m;
        totalSupply = 0;
        maxSupply = 2 * _1m;
        currentEra = 1;
        secondsPerEra = 1; 
        nextEraTime = block.timestamp + secondsPerEra;
        emissionCurve = 900;
        DAO = msg.sender;
        burnAddress = 0x0111011001100001011011000111010101100101;
    }
    
    function init(address _vether, address _USDV, address _utils) external {
        require(inited == false);
        inited = true;
        VETHER = _vether;
        USDV = _USDV;
        UTILS = _utils;
        rewardAddress = _USDV;
    }

    
    function balanceOf(address account) external view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    
    
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        require(sender != address(0), ""sender"");
        require(recipient != address(this), ""recipient"");
        _balances[sender] -= amount;
        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  
        if(_fee >= 0 && _fee <= amount){                            
            amount -= _fee;
            _burn(msg.sender, _fee);
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        _checkEmission();
    }
    
    function _mint(address account, uint amount) internal virtual {
        require(account != address(0), ""recipient"");
        if((totalSupply + amount) >= maxSupply){
            amount = maxSupply - totalSupply;       
        }
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    
    function burn(uint amount) public virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender) - amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        require(account != address(0), ""address err"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    
    
    function flipEmissions() external onlyDAO {
        if(emitting){
            emitting = false;
        } else {
            emitting = true;
        }
    }
    
    function flipMinting() external onlyDAO {
        if(minting){
            minting = false;
        } else {
            minting = true;
        }
    }
    
    function setParams(uint newEra, uint newCurve) external onlyDAO {
        secondsPerEra = newEra;
        emissionCurve = newCurve;
    }
    
    function setRewardAddress(address newAddress) external onlyDAO {
        rewardAddress = newAddress;
    }
    
    function changeUTILS(address newUTILS) external onlyDAO {
        require(newUTILS != address(0), ""address err"");
        UTILS = newUTILS;
    }
    
    function changeDAO(address newDAO) external onlyDAO {
        require(newDAO != address(0), ""address err"");
        DAO = newDAO;
    }
    
    function purgeDAO() external onlyDAO{
        DAO = address(0);
    }

   
    
    function _checkEmission() private {
        if ((block.timestamp >= nextEraTime) && emitting) {                                
            currentEra += 1;                                                               
            nextEraTime = block.timestamp + secondsPerEra;                                 
            uint _emission = getDailyEmission();                                           
            _mint(rewardAddress, _emission);                                               
            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        
            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                
            emit NewEra(currentEra, nextEraTime, _emission);                               
        }
    }
    
    function getDailyEmission() public view returns (uint) {
        uint _adjustedMax;
        if(totalSupply <= baseline){ 
            _adjustedMax = (maxSupply * totalSupply) / baseline; 
        } else {
            _adjustedMax = maxSupply;  
        }
        return (_adjustedMax - totalSupply) / (emissionCurve); 
    }

    
    
    function upgrade(uint amount) external {
        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));
        _mint(msg.sender, amount);
    }
    
    function redeem() external returns (uint redeemAmount){
        return redeemToMember(msg.sender);
    }
    
    function redeemToMember(address member) public flashProof returns (uint redeemAmount){
        if(minting){
            uint _amount = iERC20(USDV).balanceOf(address(this)); 
            iERC20(USDV).burn(_amount);
            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); 
            _mint(member, redeemAmount);
        }
    }
}",1699.0,5,4,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Initialization and State-Changing Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `init` function and other state-changing functions like `flipEmissions`, `flipMinting`, `setParams`, `setRewardAddress`, `changeUTILS`, and `changeDAO` lack proper access control. This allows unauthorized users to initialize or alter critical contract parameters."",
      ""Impact"": ""This can lead to unauthorized initialization with arbitrary addresses and unauthorized changes to contract parameters, resulting in potential security breaches and mismanagement."",
      ""Location"": ""Functions including `init`, `flipEmissions`, `flipMinting`, `setParams`, `setRewardAddress`, `changeUTILS`, `changeDAO` defined throughout the contract."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The issue is relevant as it highlights critical access control vulnerabilities in the contract's initialization and state-changing processes.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities in External Contract Interactions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `redeemToMember` and interactions with external contracts lack adequate reentrancy protection, despite using modifiers like `flashProof`. The reliance on conditions such as `iUSDV(USDV).isMature` may not cover all possible scenarios."",
      ""Impact"": ""These vulnerabilities could be exploited by malicious contracts to perform reentrancy attacks, potentially leading to unauthorized minting or fund transfers."",
      ""Location"": ""Functions interacting with external contracts, such as `redeemToMember` defined around lines 195-203."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is crucial as it addresses the potential reentrancy risks associated with external contract interactions.""
    },
    {
      ""Issue"": ""Improper Handling of External Contract Calls"",
      ""Severity"": ""High"",
      ""Description"": ""The contract does not properly handle errors or check return values when interacting with external contracts like `iUSDV`, `iUTILS`, `iROUTER`, and `VETHER`. This oversight can lead to unexpected behavior or vulnerabilities if any external calls fail."",
      ""Impact"": ""Failure to handle errors from external calls can result in loss of funds, incorrect state updates, or other unintended contract behaviors."",
      ""Location"": ""Functions like `_transfer`, `upgrade`, and `redeemToMember`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The analysis highlights the critical nature of secure and error-checked interactions with external contracts.""
    },
    {
      ""Issue"": ""Potential Loss of Governance with `purgeDAO`"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `purgeDAO` function sets the DAO address to the zero address, effectively removing the DAO's control over the contract. This action is irreversible and should be carefully controlled."",
      ""Impact"": ""Once executed, the DAO will permanently lose its ability to control the contract, which could lead to governance issues and inability to respond to future threats or needed updates."",
      ""Location"": ""Function `purgeDAO` defined in lines 148-150."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is critical to contract governance and accurately describes the irreversible action of the `purgeDAO` function.""
    },
    {
      ""Issue"": ""Arithmetic Operations and Emission Checks"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations across various functions do not consistently use SafeMath for explicit overflow protection, and the `_checkEmission` function lacks checks to ensure emissions do not exceed supply limits."",
      ""Impact"": ""Potential for arithmetic overflows or supply inflation could lead to incorrect balances, unauthorized minting, or token supply inflation."",
      ""Location"": ""Functions like `_transfer`, `_mint`, `_burn`, and `_checkEmission`."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The issue is relevant to ensuring safe arithmetic operations and emission controls, which are critical for token management.""
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 30,
  ""RelevanceCount"": 28,
  ""AllValidation"": 30,
  ""ValidationCount"": 28
}","### Issue Evaluation and Matching

---

#### **[H-03] Missing DAO functionality to call `changeDAO()` function in Vader.sol**

**Report Description**:
The `changeDAO()` function in Vader.sol is protected by an access modifier ensuring only the DAO can invoke it. However, there is no corresponding functionality in the DAO contract to call `changeDAO()`, effectively preventing the DAO address from being changed. This oversight limits the ability to update the DAO address and could create governance issues.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Initialization and State-Changing Functions""**.

**Validation**:
**Correct**. The response correctly identifies the lack of access control on critical state-changing functions like `changeDAO()`, which are vulnerable to unauthorized changes. It aligns with the issue of missing functionality for secure management of the DAO address.

---

#### **[H-06] Incorrect burn address in Vader.sol**

**Report Description**:
In Vader.sol, the `_transfer()` function uses `msg.sender` as the burn address for transfer fees. This is incorrect in the case of `transferFrom()` and `transferTo()`, as these functions may have different sender addresses. This results in incorrect accounting, causing potential losses or unexpected behavior.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. While the response list does mention improper handling of external contract calls and reentrancy risks, it does not specifically address the issue of incorrect burn address usage in `Vader.sol`. The lack of specificity about sender addresses and the incorrect burning logic means the response is not relevant to this particular issue.

---

#### **[H-16] Tokens can be stolen through `transferTo()`**

**Report Description**:
The `transferTo()` function in Vader.sol uses `tx.origin` for authorization and skips the approval check. This could allow tokens to be stolen by malicious actors, as `tx.origin` can be manipulated in specific scenarios.

**Match in Response List**:
Matches with the issue titled **""Potential Loss of Governance with `purgeDAO`""** (although this is a stretch, and the specific concern is different).

**Validation**:
**Incorrect**. The response list item on `purgeDAO` addresses governance risks but does not cover the security concern related to `tx.origin` in `transferTo()`. The use of `tx.origin` for authorization and skipping the approval check is a significant vulnerability that is not addressed in the response.

---

#### **[H-17] Transfer fee is burned on wrong accounts**

**Report Description**:
In the `_transfer` function of Vader.sol, transfer fees are incorrectly burned on `msg.sender`, which may not be the actual sender in cases involving contracts like `transferFrom()`. This leads to incorrect fee burning and potential failure for relayer contracts that have no balance to burn.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. There is no response that addresses the specific issue of incorrectly burning fees on the wrong account in the context of `transferFrom()` or `transferTo()`. The problem of incorrectly using `msg.sender` as the burn address for transfers is not addressed in the response.

---

#### **[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol**

**Report Description**:
An initialization error sets `secondsPerEra` to 1 second instead of the intended 86400 seconds (1 day). This results in token emission at a rate that is too fast, potentially leading to inflation, a broken VADER<>USDV peg, and protocol failure.

**Match in Response List**:
Matches with the issue titled **""Arithmetic Operations and Emission Checks""**.

**Validation**:
**Correct**. The response addresses potential issues with arithmetic operations and emission checks, including the impact of incorrect parameterization like the `secondsPerEra` error. The reference to incorrect emission rates due to initialization aligns with the concerns in the report.

---

#### **[M-04] `flashProof` is not flash-proof**

**Report Description**:
The `flashProof` modifier, which is designed to prevent flash loan attacks, uses `tx.origin` instead of an individual user address. This means the modifier only prevents attacks within a single transaction but fails to stop attacks that span multiple transactions.

**Match in Response List**:
Matches with the issue titled **""Potential Reentrancy Vulnerabilities in External Contract Interactions""**.

**Validation**:
**Correct**. While the response addresses vulnerabilities in external contract interactions, it does not directly address the issue of the `flashProof` modifier and its reliance on `tx.origin`. 

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init` function can be called by anyone, potentially allowing a malicious actor to execute it during contract deployment and disrupt the contract's intended state. This could lead to a race condition or a scenario where the contract is rendered useless.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Initialization and State-Changing Functions""**.

**Validation**:
**Correct**. The response correctly identifies a lack of access control on initialization functions, which can be exploited by unauthorized users to modify critical contract parameters. This matches the concern of the `init` function being callable by anyone.

---

#### **[M-15] `changeDAO` should be a two-step process in Vader.sol**

**Report Description**:
The `changeDAO()` function in Vader.sol is a single-step process, which can be dangerous if the wrong DAO address is voted on. It would require the incorrectly used DAO address to approve changes, which might be inaccessible, effectively locking out future governance actions.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Initialization and State-Changing Functions""**.

**Validation**:
**Correct**. The response highlights the importance of proper access control, which aligns with the suggestion to make `changeDAO()` a two-step process to mitigate the risk of governance lock-in. This is relevant to the issue in the report.

---

#### **[M-17] `Vader.redeemToMember()` vulnerable to front running**

**Report Description**:
The `Vader.redeemToMember()` function in the Vader protocol is vulnerable to front-running attacks, allowing users to redeem USDV before others, potentially causing financial loss.

**Match in Response List**:
Matches with the issue titled **""Potential Reentrancy Vulnerabilities in External Contract Interactions""**.

**Validation**:
**Partially Correct**. While the response addresses vulnerabilities in external contract interactions, it does not fully focus on the front-running aspect of the `redeemToMember()` function. The response could be more focused on race conditions and front-running, which are the primary concerns in this report.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- **[H-03] Missing DAO functionality to call `changeDAO()`**
- **[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day**
- **[M-04] `flashProof` is not flash-proof**
- **[M-13] Init function can be called by everyone**
- **[M-15] `changeDAO` should be a two-step process in Vader.sol**

#### **Partially Correct Matches**:
- **[M-17] `Vader.redeemToMember()` vulnerable to front running**

#### **Incorrect Matches**:
- **[H-06] Incorrect burn address in Vader.sol**
- **[H-16] Tokens can be stolen through `transferTo()`**
- **[H-17] Transfer fee is burned on wrong accounts**

#### **Missed Issues from Issue Report**:
- No issues missed from the report.
",5,1,3,5,30,"### **Output**

---

**[H-03] Missing DAO functionality to call `changeDAO()` function in Vader.sol**

**Report Description**:
The `changeDAO()` function in `Vader.sol` is authorized to be called only from the DAO (per modifier), but the DAO contract has no corresponding functionality to call `changeDAO()`. As a result, the DAO address cannot be changed (L192-L196).

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the specific issue of missing DAO functionality to call `changeDAO()`. This is a critical oversight in the contract's governance mechanism.

---

**[H-06] Incorrect burn address in Vader.sol**

**Report Description**:
The `internal _transfer()` function is called from external-facing `transfer()`, `transferFrom()`, and `transferTo()` functions, all of which have different sender addresses. The `_burn()` function incorrectly uses `msg.sender` as the burn address, which is correct only in the context of the `transfer()` caller. This leads to incorrect burning of fees for `transferFrom()` and `transferTo()` callers, causing incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect burn address usage in the `_transfer()` function. This is a critical vulnerability that could lead to fund loss.

---

**[H-16] Tokens can be stolen through `transferTo`**

**Report Description**:
VADER, USDV, and SYNTHS all employ the `transferTo()` function, which interrogates for `tx.origin` and skips approvals. This design is dangerous as it can lead to token theft.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of token theft through the `transferTo()` function. This is a significant security risk.

---

**[H-17] Transfer fee is burned on wrong accounts**

**Report Description**:
The `Vader._transfer` function burns the transfer fee on `msg.sender`, but this address might not be involved in the transfer at all due to `transferFrom`. Smart contracts that relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of transfer fees being burned on incorrect accounts. This is a critical vulnerability that could break the protocol's functionality.

---

**[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol**

**Report Description**:
Incorrect initialization of `secondsPerEra` to 1 second instead of 86400 seconds (1 day) causes what should be the daily emission rate to be a secondly emission rate. This causes inflation of the VADER token and likely breaks the VADER<>USDV peg and other protocol invariants. Protocol will break and funds will be lost.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect initialization causing an incorrect emission rate. This is a critical vulnerability that could lead to fund loss.

---

**[M-04] `flashProof` is not flash-proof**

**Report Description**:
The `flashProof` modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block. However, it performs this check on `tx.origin` and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of the `flashProof` modifier not being effective against flash-loan attacks. This is a significant security risk.

---

**[M-13] Init function can be called by everyone**

**Report Description**:
Most of the Solidity contracts have an `init` function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment, a hacker could call the `init` function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Initialization and State-Changing Functions""**.

**Validation**:
**Correct**. The response accurately identifies the issue of lack of access control on the `init` function, which aligns with the reported vulnerability.

---

**[M-15] `changeDAO` should be a two-step process in Vader.sol**

**Report Description**:
`changeDAO()` updates the DAO address in one step. If an incorrect address is mistakenly used (and voted upon), then future administrative access or recovering from this mistake is prevented because the `onlyDAO` modifier is used for `changeDAO()`, which requires `msg.sender` to be the incorrectly used DAO address (for which private keys may not be available to sign transactions).

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of `changeDAO()` being a one-step process. This is a significant governance risk.

---

**[M-17] `Vader.redeemToMember()` vulnerable to front running**

**Report Description**:
The USDV balance of the Vader contract is vulnerable to theft through the `Vader.redeemToMember()` function. A particular case is through USDV redemption front-running. Users can redeem USDV for Vader through the `USDV.redeemForMember()` function or the `Vader.redeemToMember()` function.

**Match in Response List**:
Matches with the issue titled **""Potential Reentrancy Vulnerabilities in External Contract Interactions""**.

**Validation**:
**Partially Correct**. The response identifies the potential reentrancy vulnerabilities in external contract interactions, which is related to the front-running issue. However, it does not specifically address the front-running vulnerability in `Vader.redeemToMember()`.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- **[M-17] `Vader.redeemToMember()` vulnerable to front running**

**Missed Issues from Issue Report**:

- **[H-03] Missing DAO functionality to call `changeDAO()` function in Vader.sol**
- **[H-06] Incorrect burn address in Vader.sol**
- **[H-16] Tokens can be stolen through `transferTo`**
- **[H-17] Transfer fee is burned on wrong accounts**
- **[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol**
- **[M-04] `flashProof` is not flash-proof**
- **[M-15] `changeDAO` should be a two-step process in Vader.sol**

---","```
1. Lack of Access Control on Initialization and State-Changing Functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Lack of Access Control on Initialization and State-Changing Functions"".
   - This issue appears at **rank 1** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to that rank divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
DAO.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)
    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised
    uint256 public proposalCount;   // Count of proposals
    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3
    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives
    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially
    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially
    uint256 public currentProposal; // The most recent proposal; should be === proposalCount
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets
    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    //==================================== PROTOCOL CONTRACTs SETTER =================================//

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    // Can purge deployer once DAO is stable and final
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    // Can change vesting period for bonders
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    //============================== USER - DEPOSIT/WITHDRAW ================================//

    // User deposits LP tokens in the DAOVault
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    // Contract deposits LP tokens for member
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); // Pool must be Curated
        require(amount > 0, ""!amount""); // Deposit amount must be valid
        if (isMember[member] != true) {
            arrayMembers.push(member); // If not a member; add user to member array
            isMember[member] = true; // If not a member; register the user as member
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); // Send user's deposit to the DAOVault
        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight
        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time
        emit MemberDeposits(member, pool, amount);
    }
    
    // User withdraws all of their selected asset from the DAOVault
    function withdraw(address pool) external {
        removeVote(); // Users weight is removed from the current open DAO proposal
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); // User receives their withdrawal
    }

    //============================== REWARDS ================================//
    
    // User claims their DAOVault incentives
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); // Reserve must have emissions turned on
        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE
        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)
        if(reward > daoReward){
            reward = daoReward; // User cannot claim more than the daoReward limit
        }
        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user
    }

    // Calculate the user's current incentive-claim per era
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim
        uint share = calcReward(member); // Get share of rewards for user
        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed
        return reward;
    }

    // Calculate the user's current total claimable incentive
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days
        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that
        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)
    }

    //================================ BOND Feature ==================================//

    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    // List an asset to be enabled for Bonding
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; // Register as a currently enabled asset
            listedBondAssets.push(asset); // Add to historical record of past Bond assets
        }
        emit ListedAsset(msg.sender, asset);
    }

    // Delist an asset from the Bond program
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; // Unregister as a currently enabled asset
        emit DelistedAsset(msg.sender, asset);
    }

    // User deposits assets to be Bonded
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); // Amount must be valid
        require(isListed[asset], '!listed'); // Asset must be listed for Bond
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array
            isMember[msg.sender] = true; // Register user as a member
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    // Add Bonded assets as liquidity and calculate LP units
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens
        } 
    }

    // User claims all of their unlocked Bonded LPs
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; // Get array of bond assets
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked
            }
        }
        return true;
    }

    // User claims unlocked Bond units of a selected asset
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked
        }
        return true;
    }
    
    // Calculate user's unlocked Bond units of a selected asset
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs
        return claimAmount;
    }

    //============================== CREATE PROPOSALS ================================//

    // New ID, but specify type, one type for each function call
    // Votes counted to IDs
    // IDs are finalised
    // IDs are executed, but type specifies unique logic

    // New DAO proposal: Simple action
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: uint parameter
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_param[currentProposal] = param; // Set the proposed parameter
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Address parameter
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Grant SPARTA to wallet
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient
        mapPID_param[currentProposal] = amount; // Set the proposed grant amount
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // If no existing open DAO proposal; register a new one
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal
        proposalCount += 1; // Increase proposal count
        currentProposal = proposalCount; // Set current proposal to the new count
        mapPID_open[currentProposal] = true; // Set new proposal as open status
        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now
    }
    
    // Pay the fee for a new DAO proposal
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee
        return true;
    } 

    //============================== VOTE && FINALISE ================================//

    // Vote for a proposal
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); // Proposal must be open status
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeight = countVotes(); // Vote for proposal and recount
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase
                }
            } else {
                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    // Remove vote from a proposal
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    // Push the proposal into 'finalising' status
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        mapPID_finalising[currentProposal] = true; // Set finalising status to true
        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    // Attempt to cancel the open proposal
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); // Proposal must not be new
        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal
        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)
        emit CancelProposal(msg.sender, currentProposal);
    }

    // A finalising-stage proposal can be finalised after the cool off period
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); // Must be past cooloff period
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); // Must be in finalising stage
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    // Change the DAO to a new contract address
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        DAO = _proposedAddress; // Change the DAO to point to the new DAO address
        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address
        daoHasMoved = true; // Set status of this old DAO
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the ROUTER to a new contract address
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the UTILS to a new contract address
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the RESERVE to a new contract address
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Flip the BASE emissions on/off
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change cool off period (Period of time until a finalising proposal can be finalised)
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        coolOffPeriod = _proposedParam; // Change coolOffPeriod
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change erasToEarn (Used to regulate the incentives flow)
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        erasToEarn = _proposedParam; // Change erasToEarn
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Grant SPARTA to the proposed recipient
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient
        require(_proposedAmount != 0, ""!param""); // Proposed grant amount must be valid
        require(_proposedAddress != address(0), ""!address""); // Proposed recipient must be valid
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Mint a 2.5M SPARTA allocation for the Bond program
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold
        completeProposal(_proposalID); // Finalise the proposal
    }

    // List an asset to be enabled for Bonding
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; // Register asset as listed for Bond
            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets
        }
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Delist an asset from being allowed to Bond
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Add a pool as 'Curated' to enable synths, weight and incentives
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Remove a pool from Curated status
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal
        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }
    
    // After completing the proposal's action; close it
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0
        mapPID_finalised[_proposalID] = true; // Finalise the proposal
        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage
        mapPID_open[_proposalID] = false; // Close the proposal
    }

    //============================== CONSENSUS ================================//
    
    // Add user's total weight to proposal and recount
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights
        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)
        return voteWeight;
    }

    // Check if a proposal has Majority consensus
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Quorum consensus
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 2; // Quorum > 50%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Minority consensus
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 6; // Minority > 16.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    //======================================PROTOCOL CONTRACTs GETTER=================================//
    
    // Get the ROUTER address that the DAO currently points to
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    // Get the UTILS address that the DAO currently points to
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    // Get the BONDVAULT address that the DAO currently points to
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    // Get the DAOVAULT address that the DAO currently points to
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    // Get the POOLFACTORY address that the DAO currently points to
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    // Get the SYNTHFACTORY address that the DAO currently points to
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    // Get the RESERVE address that the DAO currently points to
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    // Get the SYNTHVAULT address that the DAO currently points to
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    //============================== HELPERS ================================//
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }",8037.0,720.0,"[H-04] Proposals can be cancelled
Anyone can cancel any proposals by calling DAO.cancelProposal(id, id) with oldProposalID == newProposalID. This always passes the minority check as the proposal was approved.
An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.   [H-05] Flash loans can affect governance voting in DAO.sol Flash loans can significantly increase a single voter's weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which, they also deterministically influence the voting outcome to their choice.
This has already happened in the case of MakerDAO governance where a flash loan was used to affect voting outcome and noted by the Maker team as: “a practical example for the community that flash loans can and may impact system governance”
Given that flash loans are a noted concern, the impact of it to DAO governance which can control all critical protocol parameters should be mitigated as in other places.
  [M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol
Given that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if 'DAO' type checked in voteProposal() is a typographical error and should really be 'GRANT'. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%).
  [M-06] Canceled proposals can still be executed
Proposals that passed the threshold (""finalized"") can be cancelled by a minority again using the cancelProposal functions. It only sets mapPID_votes to zero but mapPID_timeStart and mapPID_finalising stay the same and pass the checks in finaliseProposal which queues them for execution.
Proposals cannot be cancelled.
  [M-07] Completed proposals can be voted on and executed again
A proposal that is completed has its state reset, including the votes. Users can just vote on it again and it can be executed again.
Completed proposals should most likely not be allowed to be voted on / executed again. This could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the FinalisedProposal event has fired.
 [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas. function init()",6.0,"pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   
    uint256 public coolOffPeriod;   
    uint256 public proposalCount;   
    uint256 public majorityFactor;  
    uint256 public erasToEarn;      
    uint256 public daoClaim;        
    uint256 public daoFee;          
    uint256 public currentProposal; 
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; 
    uint256 public bondingPeriodSeconds = 15552000; 
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; 
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    

    
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); 
        require(amount > 0, ""!amount""); 
        if (isMember[member] != true) {
            arrayMembers.push(member); 
            isMember[member] = true; 
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); 
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); 
        _DAOVAULT.depositLP(pool, amount, member); 
        mapMember_lastTime[member] = block.timestamp; 
        emit MemberDeposits(member, pool, amount);
    }
    
    
    function withdraw(address pool) external {
        removeVote(); 
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); 
    }

    
    
    
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); 
        uint reward = calcCurrentReward(msg.sender); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); 
        uint daoReward = (reserve * daoClaim) / 10000; 
        if(reward > daoReward){
            reward = daoReward; 
        }
        _RESERVE.grantFunds(reward, msg.sender); 
    }

    
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; 
        uint share = calcReward(member); 
        uint reward = (share * secondsSinceClaim) / secondsPerEra; 
        return reward;
    }

    
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; 
        uint daoReward = (reserve * daoClaim) / 10000; 
        return _UTILS.calcShare(weight, _totalWeight, daoReward); 
    }

    

    
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; 
            listedBondAssets.push(asset); 
        }
        emit ListedAsset(msg.sender, asset);
    }

    
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; 
        emit DelistedAsset(msg.sender, asset);
    }

    
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); 
        require(isListed[asset], '!listed'); 
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); 
            isMember[msg.sender] = true; 
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); 
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); 
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); 
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); 
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); 
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); 
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } 
    }

    
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; 
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); 
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); 
            }
        }
        return true;
    }

    
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); 
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); 
        }
        return true;
    }
    
    
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); 
        return claimAmount;
    }

    

    
    
    
    

    
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_param[currentProposal] = param; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_address[currentProposal] = proposedAddress; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); 
        payFee(); 
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; 
        mapPID_address[currentProposal] = recipient; 
        mapPID_param[currentProposal] = amount; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); 
        proposalCount += 1; 
        currentProposal = proposalCount; 
        mapPID_open[currentProposal] = true; 
        mapPID_startTime[currentProposal] = block.timestamp; 
    }
    
    
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); 
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); 
        return true;
    } 

    

    
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); 
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeight = countVotes(); 
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); 
                }
            } else {
                _finalise(); 
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; 
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; 
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; 
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        mapPID_finalising[currentProposal] = true; 
        mapPID_coolOffTime[currentProposal] = block.timestamp; 
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); 
        mapPID_votes[currentProposal] = 0; 
        mapPID_open[currentProposal] = false; 
        emit CancelProposal(msg.sender, currentProposal);
    }

    
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); 
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); 
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; 
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); 
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        DAO = _proposedAddress; 
        iBASE(BASE).changeDAO(_proposedAddress); 
        daoHasMoved = true; 
        completeProposal(_proposalID); 
    }

    
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _ROUTER = iROUTER(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _UTILS = iUTILS(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE = iRESERVE(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); 
        completeProposal(_proposalID); 
    }

    
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        coolOffPeriod = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        erasToEarn = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; 
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAmount != 0, ""!param""); 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; 
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); 
        completeProposal(_proposalID); 
    }

    
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; 
            listedBondAssets.push(_proposedAddress); 
        }
        completeProposal(_proposalID); 
    }

    
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        isListed[_proposedAddress] = false; 
        completeProposal(_proposalID); 
    }

    
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.addCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.removeCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }
    
    
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; 
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; 
        mapPID_finalised[_proposalID] = true; 
        mapPID_finalising[_proposalID] = false; 
        mapPID_open[_proposalID] = false; 
    }

    
    
    
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; 
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); 
        mapPID_votes[currentProposal] += voteWeight; 
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; 
        return voteWeight;
    }

    
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight * majorityFactor / 10000; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 2; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 6; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }",5820.0,2,4,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Critical Functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""Functions such as `moveBASEBalance`, `setGenesisAddresses`, and `grantFunds` are protected only by the `onlyDAO` modifier. If the DEPLOYER address is compromised or improperly set, unauthorized entities could execute these functions, leading to manipulation of the DAO's assets or configurations."",
      ""Impact"": ""Unauthorized access to critical functions could lead to asset theft, unauthorized changes to the DAO's configuration, and overall disruption of the DAO's operations."",
      ""Location"": ""Functions `moveBASEBalance`, `setGenesisAddresses`, `grantFunds`, etc."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding addresses a critical security issue in access control, essential for the secure operation of the DAO contract.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `harvest`, `withdraw`, and `bond` involve external contract calls before state updates, making them susceptible to reentrancy attacks."",
      ""Impact"": ""Reentrancy attacks could result in unauthorized withdrawal of funds or incorrect reward calculations, leading to significant financial loss."",
      ""Location"": ""Functions `harvest`, `withdraw`, `bond`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a critical security concern in Solidity contracts, especially those handling funds.""
    },
    {
      ""Issue"": ""Lack of Input Validation in Proposal Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Proposal creation functions such as `newActionProposal`, `newParamProposal`, and `newAddressProposal` do not validate inputs such as addresses and parameter values, which could lead to invalid or malicious proposals being created."",
      ""Impact"": ""Invalid proposals could disrupt the DAO's governance processes, and malicious proposals might execute harmful actions if passed."",
      ""Location"": ""Functions `newActionProposal`, `newParamProposal`, `newAddressProposal`, etc."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Proper input validation is crucial for maintaining the integrity of the DAO's proposal system.""
    },
    {
      ""Issue"": ""Inadequate Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical state-changing functions do not emit events, making it difficult to track changes and debug issues, reducing transparency and auditability."",
      ""Impact"": ""Lack of event logging could hinder tracing of state changes and identifying issues, affecting transparency and accountability."",
      ""Location"": ""Functions `moveBASEBalance`, `finaliseProposal`, `grantFunds`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Adequate event logging is essential for transparency and accountability in DAO operations.""
    }
  ],
  ""FindingNumber"": 4,
  ""AllRelevance"": 56,
  ""RelevanceCount"": 49,
  ""AllValidation"": 56,
  ""ValidationCount"": 49
}","---

**[H-04] Proposals can be cancelled**

**Report Description**:
Anyone can cancel any proposal by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved. An attacker can launch a denial of service (DoS) attack on the DAO governance and prevent any proposals from being executed.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the vulnerability of canceling proposals with a minority check that could be exploited for a DoS attack. The issue is related to governance logic and access control, but no related findings are present in the response list regarding this specific flaw.

---

**[H-05] Flash loans can affect governance voting in DAO.sol**

**Report Description**:
Flash loans can significantly increase a single voter's weight and be used to manipulate the voting outcome. A voter can borrow tokens to amplify their voting power, as demonstrated by a real-world MakerDAO incident. Flash loans can affect governance and protocol control, which is a critical risk to DAO systems.

**Match in Response List**:
Matches with the issue titled **""Lack of Input Validation in Proposal Functions""** (although not directly related to flash loans).

**Validation**:
**Partially Correct**. The response addresses input validation concerns but does not specifically mention flash loans or governance manipulation via flash loans. The absence of validation for proposals could theoretically allow for invalid proposals, but flash loan-related vulnerabilities are not addressed in the response list.

---

**[M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol**

**Report Description**:
There is potential undefined behavior in the `voteProposal()` function if the 'DAO' type is a typographical error and should be 'GRANT'. If this error exists, it could cause `GRANT` proposals to only require quorum (33%) instead of the required majority (50%).

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. There is no specific mention of proposal-type errors or quorum issues in the response list. The response discusses input validation and state changes but doesn't address type-checking or quorum calculations for proposals, which is the focus of this issue.

---

**[M-06] Canceled proposals can still be executed**

**Report Description**:
Proposals that pass the threshold and are marked as finalized can still be canceled by a minority using the `cancelProposal` function. This resets certain states but leaves others intact, allowing these proposals to be executed, leading to unexpected or unauthorized execution.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. This specific vulnerability, where finalized proposals can still be executed post-cancellation, is not addressed in the response list. The response list does not cover proposal cancellation and its impact on execution after finalization.

---

**[M-07] Completed proposals can be voted on and executed again**

**Report Description**:
Once a proposal is marked as completed, its state should be reset to prevent re-voting or re-execution. However, completed proposals have their votes reset, and users can vote again on them, leading to potential issues, especially in backend processes that don't expect such behavior.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. This issue regarding the re-execution of completed proposals is not addressed in the response list. There is no mention of preventing proposals from being voted on or executed again after they are marked as completed.

---

**[M-13] Init function can be called by everyone**

**Report Description**:
An init function can be called by anyone, leading to a race condition during deployment. An attacker could call the init function and make the deployed contracts unusable, requiring a redeployment and significant gas costs.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:
**Correct**. The response addresses the lack of access control on critical functions, similar to the vulnerability described in this issue. The init function's potential to be called by anyone is a form of unauthorized access, aligning with the concerns raised in the response regarding critical functions being improperly secured.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone** → **Lack of Access Control on Critical Functions**

**Partially Correct Matches**:

- **[H-05] Flash loans can affect governance voting in DAO.sol** → **Lack of Input Validation in Proposal Functions** (though it doesn't specifically mention flash loans)

**Missed Issues from Issue Report**:

- **[H-04] Proposals can be cancelled** (DoS attack vulnerability)
- **[M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol** (quorum issue)
- **[M-06] Canceled proposals can still be executed** (post-cancellation execution risk)
- **[M-07] Completed proposals can be voted on and executed again** (re-voting on completed proposals)

---
",1,1,4,4,56,"### **[H-04] Proposals can be cancelled**

**Report Description**:
Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved. An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unauthorized proposal cancellation or the associated denial of service risk. This is a critical governance vulnerability that is not covered in the provided responses.

---

### **[H-05] Flash loans can affect governance voting in DAO.sol**

**Report Description**:
Flash loans can significantly increase a single voter's weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which, they also deterministically influence the voting outcome to their choice. This has already happened in the case of MakerDAO governance where a flash loan was used to affect voting outcome and noted by the Maker team as: “a practical example for the community that flash loans can and may impact system governance”. Given that flash loans are a noted concern, the impact of it to DAO governance which can control all critical protocol parameters should be mitigated as in other places.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of flash loans affecting governance voting. This is a significant risk to the integrity of the DAO's governance process and is not covered in the provided responses.

---

### **[M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol**

**Report Description**:
Given that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if 'DAO' type checked in `voteProposal()` is a typographical error and should really be 'GRANT'. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%).

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of undefined behavior or potential typographical errors in proposal types. This could lead to incorrect voting requirements and is not covered in the provided responses.

---

### **[M-06] Canceled proposals can still be executed**

**Report Description**:
Proposals that passed the threshold (""finalized"") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution. Proposals cannot be cancelled.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of canceled proposals still being executable. This is a critical flaw in the proposal execution logic and is not covered in the provided responses.

---

### **[M-07] Completed proposals can be voted on and executed again**

**Report Description**:
A proposal that is completed has its state reset, including the votes. Users can just vote on it again and it can be executed again. Completed proposals should most likely not be allowed to be voted on / executed again. This could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the `FinalisedProposal` event has fired.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of completed proposals being voted on and executed again. This is a significant oversight in the proposal lifecycle management and is not covered in the provided responses.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the `init` function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of the `init` function being callable by everyone, leading to potential race conditions and contract deployment issues. This is a critical security concern and is not covered in the provided responses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-04] Proposals can be cancelled**
- **[H-05] Flash loans can affect governance voting in DAO.sol**
- **[M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol**
- **[M-06] Canceled proposals can still be executed**
- **[M-07] Completed proposals can be voted on and executed again**
- **[M-13] Init function can be called by everyone**

---

The response list does not adequately address the issues identified in the issue report. Several critical and medium-severity vulnerabilities related to governance, proposal management, and initialization are completely missed. The provided responses focus on access control, reentrancy, input validation, and event logging, but fail to cover the specific vulnerabilities outlined in the issue report.","```
None.
```",0.0
utils.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Utils {

    uint private one = 10**18;
    uint private _10k = 10000;
    uint private _year = 31536000; // One Year (in seconds)

    bool private inited;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    constructor () {}

    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        POOLS = _pools;
        FACTORY = _factory;
    }
    //====================================SYSTEM FUNCTIONS====================================//
    // VADER FeeOnTransfer
    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){
        return calcShare(totalSupply, maxSupply, 100); // 0->100BP
    }

    function assetChecks(address collateralAsset, address debtAsset) external {
        if(collateralAsset == VADER){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        } else if(collateralAsset == USDV){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); // Can borrow Asset with VADER/ASSET-SYNTH
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        }
    }

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    //====================================PRICING====================================//

    function calcValueInBase(address token, uint amount) public view returns (uint value){
       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
       if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _baseAmt) / _tokenAmt;
       }
    }

    function calcValueInToken(address token, uint amount) public view returns (uint value){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _tokenAmt) / _baseAmt;
       }
    }
    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){
            return calcValueInToken(token2, calcValueInBase(token1, amount));
    }

    function calcSwapValueInBase(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _tokenAmt, _baseAmt);
    }
    function calcSwapValueInToken(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _baseAmt, _tokenAmt);
    }

    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {
        uint _testingPrice = calcValueInBase(token, one);
        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price
        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price
        if(inside){
            require((_testingPrice >= _lower && _testingPrice <= _upper), ""Not inside"");
        } else {
            require((_testingPrice <= _lower || _testingPrice >= _upper), ""Not outside"");
        }
    }

    //====================================INCENTIVES========================================//

    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {
        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){
            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);
            if (iPOOLS(POOLS).isAsset(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            } else if(iPOOLS(POOLS).isAnchor(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            }
        }
    }

    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {
        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast
    }

    //=================================IMPERMANENT LOSS=====================================//

    // Actual protection with 100 day rule and Reserve balance
    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {
        uint _coverage = getCoverage(member, token);
        if(iROUTER(ROUTER).isCurated(token)){
            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);
            if(_duration <= timeForFullProtection) {
                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule
            } else {
                protection = _coverage;
            }
        }
        return calcPart(basisPoints, protection);
    }
    // Theoretical coverage based on deposit/redemption values
    function getCoverage(address member, address token) public view returns (uint) {
        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);
        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);
        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));
        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));
        return calcCoverage(_B0, _T0, _B1, _T1);
    }

    //==================================== LENDING ====================================//

    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {
        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio
        if(isBase(collateralAsset)){
            baseValue = _collateralAdjusted;
        }else if(isPool(collateralAsset)){
            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE
        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){
            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value
        }
        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output
        return (debt, baseValue);
    }

    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {
        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt
        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral
        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);
        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);
        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral
        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); 
        return (_collateralUnlocked, _memberInterestShare);
    }

    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {
        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year
        if(isBase(collateralAsset)){
            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base
        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {
            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)
        }
    }
    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);
        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; 
    }
    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);
        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);
        return (_debtIssued * 10000) / _debtDepth; 
    }

    //====================================CORE-MATH====================================//

    function calcPart(uint bp, uint total) public pure returns (uint){
        // 10,000 basis points = 100.00%
        require((bp <= 10000) && (bp >= 0), ""Must be correct BP"");
        return calcShare(bp, 10000, total);
    }

    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){
        // share = amount * part/total
        if(part > total){
            part = total;
        }
        if(total > 0){
            share = (amount * part) / total;
        }
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){
        // y = (x * X * Y )/(x + X)^2
        uint numerator = (x * X * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){
        // fee = (x * x * Y) / (x + X)^2
        uint numerator = (x * x * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }
    function calcSwapSlip(uint x, uint X) external pure returns (uint){
        // slip = (x) / (x + X)
        return (x*10000) / (x + X);
    }

    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){
        if(P == 0){
            return b;
        } else {
            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment
            // P * (part1 + part2) / (part3) * slipAdjustment
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = (t * B);
            uint part2 = (T * b);
            uint part3 = (T * B) * 2;
            uint _units = (((P * part1) + part2) / part3);
            return (_units * slipAdjustment) / one;  // Divide by 10**18
        }
    }

    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){
        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))
        // 1 - ABS(part1 - part2)/(part3 * part4))
        uint part1 = B * t;
        uint part2 = b * T;
        uint part3 = (b * 2) + B;
        uint part4 = t + T;
        uint numerator;
        if(part1 > part2){
            numerator = (part1 - part2);
        } else {
            numerator = (part2 - part1);
        }
        uint denominator = (part3 * part4);
        return one - (numerator * one) / denominator; // Multiply by 10**18
    }

    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){
        // (P * b)/(2*(b + B))
        return (P * b) / (2 * (b + B));
    }

    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){
        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3
        // (part1 * (part2 - part3 + part4)) / part5
        uint part1 = (u * A);
        uint part2 = ((U * U) * 2);
        uint part3 = ((U * u) * 2);
        uint part4 = (u * u);
        uint numerator = ((part1 * part2) - part3) + part4;
        uint part5 = ((U * U) * U);
        return (numerator / part5);
    }
    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){
        if(B0 > 0 && T1 > 0){
            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)
            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)
            if(_redemptionValue <= _depositValue){
                coverage = (_depositValue - _redemptionValue);
            }
        }
    }

    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)
    function sortArray(uint[] memory array) external pure returns (uint[] memory) {
        uint l = array.length;
        for(uint i = 0; i < l; i++){
            for(uint j = i+1; j < l; j++){
                if(array[i] > array[j]){
                    uint temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
        }
        return array;
    }

}",3621.0,302.0,"[H-07] Wrong calcAsymmetricShare calculation
The inline-comment defines the number of asymmetric shares as (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3 but the Utils.calcAsymmetricShare function computes (uA * 2U^2 - 2uU + u^2) / U^3 which is not equivalent as can be seen from the A^2 term in the first term which does not occur in the second one.
The associativity on P * part1 is wrong, and part2 is not multiplied by P.
The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up.
  [H-08] Wrong liquidity units calculation
The spec defines the number of LP units to be minted as units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments but the Utils.calcLiquidityUnits function computes ((P * part1) + part2) / part3 * slipAdjustments.
The associativity on P * part1 is wrong, and part2 is not multiplied by P.
The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.
  [M-05] Interest debt is capped after a year
The `Utils.getInterestOwed `function computes the _interestPayment as: However, calcShare caps timeElpased to _year and therefore the owed interest does not grow after a year has elapsed. The impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.   [M-09] Divide before multiply
Can't quite understand the assertion that a division is made before a multiply in the code outlined ```uint _units = (((P * part1) + part2) / part3);
    return (_units * slipAdjustment) / one;  // Divide by 10**18 ```   [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas function init()",5.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Utils {

    uint private one = 10**18;
    uint private _10k = 10000;
    uint private _year = 31536000; 

    bool private inited;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    constructor () {}

    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        POOLS = _pools;
        FACTORY = _factory;
    }
    
    
    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){
        return calcShare(totalSupply, maxSupply, 100); 
    }

    function assetChecks(address collateralAsset, address debtAsset) external {
        if(collateralAsset == VADER){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); 
        } else if(collateralAsset == USDV){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); 
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); 
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); 
        }
    }

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    

    function calcValueInBase(address token, uint amount) public view returns (uint value){
       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
       if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _baseAmt) / _tokenAmt;
       }
    }

    function calcValueInToken(address token, uint amount) public view returns (uint value){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _tokenAmt) / _baseAmt;
       }
    }
    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){
            return calcValueInToken(token2, calcValueInBase(token1, amount));
    }

    function calcSwapValueInBase(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _tokenAmt, _baseAmt);
    }
    function calcSwapValueInToken(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _baseAmt, _tokenAmt);
    }

    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {
        uint _testingPrice = calcValueInBase(token, one);
        uint _lower = calcPart((_10k - bound), targetPrice);                
        uint _upper = (targetPrice * (_10k + bound)) / _10k;                
        if(inside){
            require((_testingPrice >= _lower && _testingPrice <= _upper), ""Not inside"");
        } else {
            require((_testingPrice <= _lower || _testingPrice >= _upper), ""Not outside"");
        }
    }

    

    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {
        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){
            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);
            if (iPOOLS(POOLS).isAsset(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            } else if(iPOOLS(POOLS).isAnchor(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            }
        }
    }

    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {
        return calcShare(1, rewardReductionFactor, amount); 
    }

    

    
    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {
        uint _coverage = getCoverage(member, token);
        if(iROUTER(ROUTER).isCurated(token)){
            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);
            if(_duration <= timeForFullProtection) {
                protection = calcShare(_duration, timeForFullProtection, _coverage); 
            } else {
                protection = _coverage;
            }
        }
        return calcPart(basisPoints, protection);
    }
    
    function getCoverage(address member, address token) public view returns (uint) {
        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);
        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);
        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));
        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));
        return calcCoverage(_B0, _T0, _B1, _T1);
    }

    

    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {
        uint _collateralAdjusted = (collateral * 6666) / 10000; 
        if(isBase(collateralAsset)){
            baseValue = _collateralAdjusted;
        }else if(isPool(collateralAsset)){
            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); 
        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){
            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); 
        }
        debt = calcSwapValueInToken(debtAsset, baseValue);        
        return (debt, baseValue);
    }

    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {
        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); 
        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); 
        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);
        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);
        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); 
        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); 
        return (_collateralUnlocked, _memberInterestShare);
    }

    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {
        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); 
        if(isBase(collateralAsset)){
            interestOwed = calcValueInBase(debtAsset, _interestPayment); 
        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {
            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); 
        }
    }
    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);
        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; 
    }
    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);
        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);
        return (_debtIssued * 10000) / _debtDepth; 
    }

    

    function calcPart(uint bp, uint total) public pure returns (uint){
        
        require((bp <= 10000) && (bp >= 0), ""Must be correct BP"");
        return calcShare(bp, 10000, total);
    }

    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){
        
        if(part > total){
            part = total;
        }
        if(total > 0){
            share = (amount * part) / total;
        }
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){
        
        uint numerator = (x * X * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){
        
        uint numerator = (x * x * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }
    function calcSwapSlip(uint x, uint X) external pure returns (uint){
        
        return (x*10000) / (x + X);
    }

    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){
        if(P == 0){
            return b;
        } else {
            
            
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = (t * B);
            uint part2 = (T * b);
            uint part3 = (T * B) * 2;
            uint _units = (((P * part1) + part2) / part3);
            return (_units * slipAdjustment) / one;  
        }
    }

    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){
        
        
        uint part1 = B * t;
        uint part2 = b * T;
        uint part3 = (b * 2) + B;
        uint part4 = t + T;
        uint numerator;
        if(part1 > part2){
            numerator = (part1 - part2);
        } else {
            numerator = (part2 - part1);
        }
        uint denominator = (part3 * part4);
        return one - (numerator * one) / denominator; 
    }

    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){
        
        return (P * b) / (2 * (b + B));
    }

    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){
        
        
        uint part1 = (u * A);
        uint part2 = ((U * U) * 2);
        uint part3 = ((U * u) * 2);
        uint part4 = (u * u);
        uint numerator = ((part1 * part2) - part3) + part4;
        uint part5 = ((U * U) * U);
        return (numerator / part5);
    }
    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){
        if(B0 > 0 && T1 > 0){
            uint _depositValue = B0 + (T0 * B1) / T1; 
            uint _redemptionValue = B1 + (T1 * B1) / T1; 
            if(_redemptionValue <= _depositValue){
                coverage = (_depositValue - _redemptionValue);
            }
        }
    }

    
    function sortArray(uint[] memory array) external pure returns (uint[] memory) {
        uint l = array.length;
        for(uint i = 0; i < l; i++){
            for(uint j = i+1; j < l; j++){
                if(array[i] > array[j]){
                    uint temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
        }
        return array;
    }

}",3097.0,2,3,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Initialization Function"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `init` function can be called by any user to set the contract's key addresses (VADER, USDV, ROUTER, POOLS, FACTORY). This lack of access control allows unauthorized parties to initialize the contract with malicious addresses, potentially redirecting funds or disrupting the contract's functionality."",
      ""Impact"": ""Unauthorized initialization can lead to serious security issues, such as loss of funds, redirection of contract operations to malicious addresses, and manipulation of contract behavior."",
      ""Location"": ""Function `init` defined in various locations across the reports."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is critical as it highlights a significant security vulnerability concerning access control in the initialization process.""
    },
    {
      ""Issue"": ""Potential Division by Zero"",
      ""Severity"": ""High"",
      ""Description"": ""Functions performing division operations, such as `calcValueInBase`, `calcValueInToken`, `calcSwapOutput`, and similar functions, do not check for zero values in the denominator, which could lead to division by zero errors."",
      ""Impact"": ""Division by zero can cause the contract to revert, disrupting operations and potentially leading to denial of service."",
      ""Location"": ""Functions `calcValueInBase`, `calcValueInToken`, `calcSwapOutput`, and others across the reports."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding highlights a critical bug that could disrupt contract functionality, which is crucial for maintaining contract stability.""
    },
    {
      ""Issue"": ""Unchecked Return Values from External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract makes multiple external calls to interfaces such as iPOOLS, iROUTER, and iFACTORY without verifying the success of these calls. This oversight could lead to unexpected behavior if any of these calls fail or revert silently."",
      ""Impact"": ""Unchecked return values can cause the contract to operate with incorrect assumptions, potentially leading to financial discrepancies or logic errors."",
      ""Location"": ""Throughout various functions where external interface calls are made."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is valid as it highlights a common issue in smart contracts where the lack of return value checking can lead to silent failures.""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical Operations"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract lacks events for critical operations such as initialization and functions altering significant state variables. This makes tracking changes to the contract's state through logs more difficult."",
      ""Impact"": ""Lack of transparency and auditability of state changes, making it harder to debug and track contract interactions."",
      ""Location"": ""Functions like `init` and others performing critical operations."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Event emissions are essential for tracking state changes and debugging, which are important for transparency and auditability.""
    },
    {
      ""Issue"": ""Uninitialized State Variables"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract has state variables that are not explicitly initialized, relying on Solidity's default values. This practice could lead to misunderstandings during code maintenance or extension."",
      ""Impact"": ""Uninitialized state variables could lead to misunderstandings during code maintenance or extension, although the risk is minimal due to Solidity's default initialization."",
      ""Location"": ""State variables declared at the start of the contract."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Explicit initialization can improve code readability and maintainability.""
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 66,
  ""RelevanceCount"": 60,
  ""AllValidation"": 66,
  ""ValidationCount"": 60
}","### **Analysis of Issue Report vs. Response List**

---

#### **[H-07] Wrong calcAsymmetricShare calculation**

**Report Description**:
The `calcAsymmetricShare` function does not implement the correct mathematical formula as defined in the spec. Specifically, it fails to correctly handle the terms involving `A^2` and mismanages the multiplication order and associativity. This could result in incorrect asymmetric share calculations, impacting protocol economics and potentially allowing users to borrow more than they should based on inaccurate collateral valuations.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The issue described relates to incorrect mathematical calculations in a function, whereas none of the responses directly address this specific problem with formula implementation or mathematical correctness. The closest match would have been an issue relating to ""incorrect calculations,"" but there is no response focusing on this vulnerability.

---

#### **[H-08] Wrong liquidity units calculation**

**Report Description**:
The `calcLiquidityUnits` function miscalculates liquidity units due to incorrect mathematical associativity. The spec defines one calculation method, but the function implements a different formula. This issue could lead to minted LP tokens not representing the correct value, causing economic risks, such as users being able to redeem more than the value they originally contributed.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. Similar to the previous issue, this relates to an error in mathematical operations (specifically with associativity in formulas). None of the responses in the list address this problem, making this a missed issue in the response list.

---

#### **[M-05] Interest debt is capped after a year**

**Report Description**:
The `getInterestOwed` function caps the calculation of interest after one year due to the way elapsed time is computed (`block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset]`). This can lead to incorrect interest calculations if the contract runs for longer than a year, potentially resulting in a protocol that fails to account for time accurately, though the impact is likely minimal.

**Match in Response List**:
Matches with the issue titled **""Potential Division by Zero""**.

**Validation**:
**Partially Correct**. While the ""Potential Division by Zero"" issue identifies a problem that could lead to contract failure, the response does not address the specific problem of the interest calculation being incorrectly capped after a year. This issue is more related to time management and the capping of interest, which is a different concern from division errors. Thus, the response partially touches on contract errors but does not sufficiently address this specific vulnerability.

---

#### **[M-09] Divide before multiply**

**Report Description**:
In the provided code snippet, division is performed before multiplication in the formula:
```solidity
uint _units = (((P * part1) + part2) / part3);
return (_units * slipAdjustment) / one;
```
This could lead to a loss of precision or incorrect results, as dividing before multiplying may not align with the intended calculation order.

**Match in Response List**:
Matches with the issue titled **""Potential Division by Zero""**.

**Validation**:
**Incorrect**. The response about division by zero doesn't directly address the concern about the order of operations. The issue here is that dividing before multiplying could result in incorrect calculations or precision loss, which is a distinct issue from division by zero. Therefore, the response is not directly applicable.

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init()` function can be called by anyone, which could lead to a race condition and exploitation. A malicious user could call the `init()` function during deployment, potentially disrupting the contract's functionality or leading to its misuse.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Initialization Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue of a lack of access control on the `init()` function. This oversight could allow unauthorized parties to manipulate the contract's initialization, which aligns with the report's concern. The response's description of the impact and severity is appropriate.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone** → **""Lack of Access Control on Initialization Function""**

**Partially Correct Matches**:

- **[M-05] Interest debt is capped after a year** → **""Potential Division by Zero""** (Partial match due to misalignment with the actual issue)

**Incorrect Matches**:

- **[H-07] Wrong calcAsymmetricShare calculation** → No relevant response.
- **[H-08] Wrong liquidity units calculation** → No relevant response.
- **[M-09] Divide before multiply** → **""Potential Division by Zero""** (Incorrect match)
",1,1,3,5,66,"### **[H-07] Wrong calcAsymmetricShare calculation**

**Report Description**:
The `calcAsymmetricShare` function in `Utils.sol` incorrectly implements the mathematical formula defined in the spec. The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3`, but the function computes `(uA * 2U^2 - 2uU + u^2) / U^3`. This discrepancy, particularly the missing `A^2` term, could lead to incorrect calculations of asymmetric shares, potentially allowing economic exploitation of the protocol. For example, users might be able to borrow more than the collateral they put up.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The incorrect implementation of the mathematical formula in `calcAsymmetricShare` is a critical vulnerability that could lead to economic exploitation, but it is not covered in the response list.

---

### **[H-08] Wrong liquidity units calculation**

**Report Description**:
The `calcLiquidityUnits` function in `Utils.sol` incorrectly implements the mathematical formula defined in the spec. The spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments`, but the function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`. This could lead to economic exploitation, as redeeming the minted LP tokens might not result in the initial tokens.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The incorrect implementation of the mathematical formula in `calcLiquidityUnits` is a critical vulnerability that could lead to economic exploitation, but it is not covered in the response list.

---

### **[M-05] Interest debt is capped after a year**

**Report Description**:
The `Utils.getInterestOwed` function caps `timeElapsed` to `_year`, meaning the owed interest does not grow after a year has elapsed. While the impact is likely small because the elapsed time is computed as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset]` and will probably never exceed a year, this design choice could still lead to unexpected behavior in edge cases.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The capping of interest debt after a year is a design flaw that could lead to unexpected behavior, but it is not covered in the response list.

---

### **[M-09] Divide before multiply**

**Report Description**:
The code snippet `uint _units = (((P * part1) + part2) / part3); return (_units * slipAdjustment) / one;` appears to perform a division before a multiplication, which could lead to precision loss. However, the exact issue is not clearly explained in the report, making it difficult to assess the full impact.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address this issue. The potential precision loss due to dividing before multiplying is a concern, but it is not covered in the response list.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init` function in most Solidity contracts can be called by anyone, leading to a race condition when the contract is deployed. A hacker could call the `init` function and make the deployed contracts useless, requiring redeployment and incurring significant gas costs.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Initialization Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `init` function lacking access control. It correctly explains the risks associated with unauthorized initialization, which aligns with Solidity best practices for secure contract deployment.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-07] Wrong calcAsymmetricShare calculation**
- **[H-08] Wrong liquidity units calculation**
- **[M-05] Interest debt is capped after a year**
- **[M-09] Divide before multiply**

---

The response list covers only one out of the five issues in the report, leaving significant gaps in addressing critical vulnerabilities related to mathematical calculations and design flaws.","```
1. Lack of Access Control on Initialization Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Lack of Access Control on Initialization Function"".
   - This issue appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank itself.
   - \( P@1 = \frac{1}{1} = 1.0 \)

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the AP is simply the precision at rank 1.
   - \( AP = 1.0 \)

**Output**:
```
1.0
```"
Router.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Router {

    // Parameters
    bool private inited;
    uint one = 10**18;
    uint public rewardReductionFactor;
    uint public timeForFullProtection;

    uint public curatedPoolLimit;
    uint public curatedPoolCount;
    mapping(address => bool) private _isCurated;
    
    address public VADER;
    address public USDV;
    address public POOLS;

    uint public anchorLimit;
    uint public insidePriceLimit;
    uint public outsidePriceLimit;
    address[] public arrayAnchors;
    uint[] public arrayPrices;

    uint public repayDelay = 3600;

    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;
    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;
    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;

    mapping(address => CollateralDetails) private mapMember_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; 
    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;

    struct CollateralDetails {
        uint ID;
        mapping(address => DebtDetails) mapCollateral_Debt;
    }
    struct DebtDetails{
        uint ID;
        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt
        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol
        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol
        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time
        // mapping(address =>uint) currentDay; // assetC > AssetD > time
    }

    event PoolReward(address indexed base, address indexed token, uint amount);
    event Protection(address indexed member, uint amount);
    event Curated(address indexed curator, address indexed token);

    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);
    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {}
    // Init
    function init(address _vader, address _usdv, address _pool) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        POOLS = _pool;
        rewardReductionFactor = 1;
        timeForFullProtection = 1;//8640000; //100 days
        curatedPoolLimit = 1;
        anchorLimit = 5;
        insidePriceLimit = 200;
        outsidePriceLimit = 500;
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {
        rewardReductionFactor = newFactor;
        timeForFullProtection = newTime;
        curatedPoolLimit = newLimit;
    }
    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {
        anchorLimit = newLimit;
        insidePriceLimit = newInside;
        outsidePriceLimit = newOutside;
    }

    //====================================LIQUIDITY=========================================//

    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){
        uint _actualInputBase = moveTokenToPools(base, inputBase);
        uint _actualInputToken = moveTokenToPools(token, inputToken);
        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); 
        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {
        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);
        uint _protection = getILProtection(msg.sender, base, token, basisPoints);
        removeDepositData(msg.sender, token, basisPoints, _protection); 
        iERC20(base).transfer(msg.sender, _protection);
    }

      //=======================================SWAP===========================================//
    
    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);
    }
    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);
    }

    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);
    }

    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {
        address _member = msg.sender;
        if(!inSynth){
            moveTokenToPools(inputToken, inputAmount);
        } else {
            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);
        }
        address _base;
        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {
            _base = VADER;
        } else {
            _base = USDV;
        }
        if (isBase(outputToken)) {
            // Token||Synth -> BASE
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);
            } else {
                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);
            }
        } else if (isBase(inputToken)) {
            // BASE -> Token||Synth
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        } else if (!isBase(inputToken) && !isBase(outputToken)) {
            // Token||Synth -> Token||Synth
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);
            } else {
                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);
            }
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        }
        _handlePoolReward(_base, inputToken);
        _handlePoolReward(_base, outputToken);
        _handleAnchorPriceUpdate(inputToken);
        _handleAnchorPriceUpdate(outputToken); 
    }

    //====================================INCENTIVES========================================//

    function _handlePoolReward(address _base, address _token) internal{
        if(!isBase(_token)){                        // USDV or VADER is never a pool
            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);
            iERC20(_base).transfer(POOLS, _reward);
            iPOOLS(POOLS).sync(_base, _token);
            emit PoolReward(_base, _token, _reward);
        }
    }

    //=================================IMPERMANENT LOSS=====================================//
    
    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {
        mapMemberToken_depositBase[member][token] += amountBase;
        mapMemberToken_depositToken[member][token] += amountToken;
        mapMemberToken_lastDeposited[member][token] = block.timestamp;
    }
    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {
        mapMemberToken_depositBase[member][token] += protection;
        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);
        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);
        mapMemberToken_depositBase[member][token] -= _baseToRemove;
        mapMemberToken_depositToken[member][token] -= _tokenToRemove;
    }

    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {
        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);
        if(base == VADER){
            if(protection >= reserveVADER()){
                protection = reserveVADER(); // In case reserve is running out
            }
        } else {
            if(protection >= reserveUSDV()){
                protection = reserveUSDV(); // In case reserve is running out
            }
        }
    }
    
    //=====================================CURATION==========================================//

    function curatePool(address token) external {
        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));
        if(!isCurated(token)){
            if(curatedPoolCount < curatedPoolLimit){ // Limit
                _isCurated[token] = true;
                curatedPoolCount += 1;
            }
        }
        emit Curated(msg.sender, token);
    }
    function replacePool(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAsset(newToken));
        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper
            _isCurated[oldToken] = false;
            _isCurated[newToken] = true;
            emit Curated(msg.sender, newToken);
        }
    }

    //=====================================ANCHORS==========================================//

    function listAnchor(address token) external {
        require(arrayAnchors.length < anchorLimit); // Limit
        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor
        arrayAnchors.push(token);                   // Add
        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));
        _isCurated[token] = true; 
        updateAnchorPrice(token);
    }

    function replaceAnchor(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAnchor(newToken), ""Not anchor"");
        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), ""Not deeper"");
        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%
        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%
        _isCurated[oldToken] = false; 
        _isCurated[newToken] = true; 
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == oldToken){
                arrayAnchors[i] = newToken;
            }
        }
        updateAnchorPrice(newToken);
    }

    // Anyone to update prices
    function updateAnchorPrice(address token) public {
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == token){
                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);
            }
        }
    }

    function _handleAnchorPriceUpdate(address _token) internal{
        if(iPOOLS(POOLS).isAnchor(_token)){
            updateAnchorPrice(_token);
        }
    }

    // Price of 1 VADER in USD
    function getAnchorPrice() public view returns (uint anchorPrice) {
        if(arrayPrices.length > 0){
            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage
            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle
        } else {
            anchorPrice = one;          // Edge case for first USDV mint
        }
    }

    // The correct amount of Vader for an input of USDV
    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){
        uint _price = getAnchorPrice();
        return (_price * USDVAmount) / one;
    }

    // The correct amount of USDV for an input of VADER
    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){
        uint _price = getAnchorPrice();
        return (vaderAmount * one) / _price;
    }
    
    
    //======================================LENDING=========================================//

    // Draw debt for self
    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {
        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);
    }

    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {
        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);
        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral 
        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral 
        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt
        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools
            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools
            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member
        }
        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event
        payInterest(collateralAsset, debtAsset);
        return _debtIssued;
    }

    // Repay for self
    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){
        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);
    }
     // Repay for member
    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){
        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));
        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here
        }
        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral 
        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt 
        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;
        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove
        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);
        _handleTransferOut(member, collateralAsset, _collateralUnlocked);
        payInterest(collateralAsset, debtAsset);
        return _collateralUnlocked;
    }

    // Called once a day to pay interest
    function payInterest(address collateralAsset, address debtAsset) internal {
        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era
            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];
            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);
            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;
            _removeCollateral(_interestOwed, collateralAsset, debtAsset);
            if(isBase(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).sync(collateralAsset, debtAsset);
            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());
            }
        }
    }

    function checkLiquidate() public {
        // get member remaining Collateral: originalDeposit - shareOfInterestPayments
        // if remainingCollateral <= 101% * debtValueInCollateral
        // purge, send remaining collateral to liquidator
    }

    // function purgeMember() public {

    // }

    // Get Collateral
    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds
        }else if(isPool(_collateralAsset)){
             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol
             _inputAmount = _amount;
        }
    }
    // Send Collateral
    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _sendFunds(_collateralAsset, _member, _amount); // Send Base
        }else if(isPool(_collateralAsset)){
            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member
        }
    }

    function _getFunds(address _token, uint _amount) internal returns(uint) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(tx.origin==msg.sender){
            require(iERC20(_token).transferTo(address(this), _amount));
        }else{
            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));
        }
        return iERC20(_token).balanceOf(address(this)) - _balance;
    }

    function _sendFunds(address _token, address _member, uint _amount) internal {
        require(iERC20(_token).transfer(_member, _amount));
    }

    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;
    }
    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;
    }
    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {
        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral 
    }



    //======================================HELPERS=========================================//

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }

    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this));
    }
    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this));
    }

    // Optionality
    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {
        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){
            safeAmount = _amount;
            if(tx.origin==msg.sender){
                iERC20(_token).transferTo(POOLS, _amount);
            }else{
                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            }
        } else {
            uint _startBal = iERC20(_token).balanceOf(POOLS);
            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;
        }
    }

    

    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function isCurated(address token) public view returns(bool curated) {
        if(_isCurated[token]){
            curated = true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    function getMemberBaseDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositBase[member][token];
    }
    function getMemberTokenDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositToken[member][token];
    }
    function getMemberLastDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_lastDeposited[member][token];
    }
    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];
    }
    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];
    }
    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];
    }
    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Debt[collateralAsset][debtAsset];
    }
    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];
    }
    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];
    }
}",5851.0,511.0,"[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol
Incorrect initialization of timeForFullProtection to 1 sec instead of 8640000 secs (100 days) as indicated in code comments, appears to be a test setting mistakenly carried over for deployment. Therefore, unless timeForFullProtection is reset to 100 days by setParams() (calling this function is a missing functionality in the DAO currently), the Impermanent Loss (IL) protection ""rule"" of 100 days will not apply in Utils.getProtection().
This breaks a key value proposition of the Vader protocol which is IL protection as indicated in the specification:
“Impermanent Loss Protection: The deposit value for each member is recorded when they deposit. When they go to withdraw, the redemption value is computed. If it is less than the deposit value, the member is paid the deficit from the reserve. The protection issued increases from 0 to 100% linearly for 100 days.”
Recommend changing to “timeForFullProtection = 8640000; //100 days”  on L84
  [H-10] Anyone can list anchors / curate tokens
The `Router.listAnchor` function can be called by anyone and tokens can be added. The only check is that `require(iPOOLS(POOLS).isAnchor(token));` but this can easily be set by calling `Pools.addLiquidity(VADER, token, _)` once even without actually sending any tokens to the contract. This makes it an essentially useless check.
This only works initially as long as the `anchorLimit` has not been reached yet. However, the `replaceAnchor` can be used in the same way and flash loans can be used to get around the liquidity restrictions and push another anchor token out of the price range as these checks use the current reserves.
Anchored pools are automatically curated pools and determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control. After a pool has been anchored through flash loans, liquidity can be withdrawn which could make the anchor price easy to manipulate in the next block and launch other attacks.
Recommend revisiting the `_isAnchor[token] = true;` statement in addLiquidity, it seems strange without any further checks. Consider making listAnchor / replaceAnchor DAO-only functions and make them flash-loan secure. One should probably use time-weighted prices for these pools for the bounds check.
  [H-15] Wrong slippage protection on Token -> Token trades
The Router.swapWithSynthsWithLimit allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:
(1) token to base
(2) base to token The slippage protection of the second trade (base to token) is computed wrong: ```
require(iUTILS(UTILS()).calcSwapSlip(
    inputAmount, // should use outToken here from prev trade
    iPOOLS(POOLS).getBaseAmount(outputToken)
  ) <= slipLimit
) ``` It compares the token input amount (of the first trade) to the base reserve of the second pair.
Slippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.
Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.
  [H-23] Anyone can curate pools and steal rewards
The `Router.curatePool` and `replacePool` don't have any access restriction. An attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools.
Curated pools determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control. They can then go ahead and game the reward system by repeatedly swapping in their custom pool with useless tokens, withdraw liquidity, and in the end, pay back the base flashloan.
Recommend preventing the replacing of curations through flash loans. Also, consider making pool curations DAO-exclusive actions.
  [M-03] Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol
There is no input validation in `replacePool()` function to check if `oldToken` exists and is curated. Using a non-existing `oldToken` (even 0 address) passes the check on L236 (because `Pools.getBaseAmount()` will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the `curatedPoolLimit` enforced only in `curatePool()` function.   [M-11] Allowing duplicated anchors could cause bias on anchor price.
In Router.sol, the setup of the five anchors can be interrupted by anyone adding a new anchor due to the lack of access control of the listAnchor function. Also, duplicate anchors are allowed. If the same anchor is added three times, then this anchor biases the result of getAnchorPrice. Referenced code: Router.sol#L245-L252
PoC: Link to PoC See the file 200_listAnchor.js for a PoC of this attack. To run it, use npx hardhat test 200_listAnchor.js.
Recommend only allowing listAnchor to be called from the deployer by adding a require statement. Also, check if an anchor is added before by require(_isCurated == false).
  [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas. function init()",7.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Router {

    
    bool private inited;
    uint one = 10**18;
    uint public rewardReductionFactor;
    uint public timeForFullProtection;

    uint public curatedPoolLimit;
    uint public curatedPoolCount;
    mapping(address => bool) private _isCurated;
    
    address public VADER;
    address public USDV;
    address public POOLS;

    uint public anchorLimit;
    uint public insidePriceLimit;
    uint public outsidePriceLimit;
    address[] public arrayAnchors;
    uint[] public arrayPrices;

    uint public repayDelay = 3600;

    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;
    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;
    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;

    mapping(address => CollateralDetails) private mapMember_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; 
    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;

    struct CollateralDetails {
        uint ID;
        mapping(address => DebtDetails) mapCollateral_Debt;
    }
    struct DebtDetails{
        uint ID;
        mapping(address =>uint) debt; 
        mapping(address =>uint) collateral; 
        
        
        
    }

    event PoolReward(address indexed base, address indexed token, uint amount);
    event Protection(address indexed member, uint amount);
    event Curated(address indexed curator, address indexed token);

    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);
    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    
    
    constructor() {}
    
    function init(address _vader, address _usdv, address _pool) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        POOLS = _pool;
        rewardReductionFactor = 1;
        timeForFullProtection = 1;
        curatedPoolLimit = 1;
        anchorLimit = 5;
        insidePriceLimit = 200;
        outsidePriceLimit = 500;
    }

    
    
    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {
        rewardReductionFactor = newFactor;
        timeForFullProtection = newTime;
        curatedPoolLimit = newLimit;
    }
    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {
        anchorLimit = newLimit;
        insidePriceLimit = newInside;
        outsidePriceLimit = newOutside;
    }

    

    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){
        uint _actualInputBase = moveTokenToPools(base, inputBase);
        uint _actualInputToken = moveTokenToPools(token, inputToken);
        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); 
        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {
        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);
        uint _protection = getILProtection(msg.sender, base, token, basisPoints);
        removeDepositData(msg.sender, token, basisPoints, _protection); 
        iERC20(base).transfer(msg.sender, _protection);
    }

      
    
    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);
    }
    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);
    }

    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);
    }

    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {
        address _member = msg.sender;
        if(!inSynth){
            moveTokenToPools(inputToken, inputAmount);
        } else {
            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);
        }
        address _base;
        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {
            _base = VADER;
        } else {
            _base = USDV;
        }
        if (isBase(outputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);
            } else {
                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);
            }
        } else if (isBase(inputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        } else if (!isBase(inputToken) && !isBase(outputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);
            } else {
                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);
            }
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        }
        _handlePoolReward(_base, inputToken);
        _handlePoolReward(_base, outputToken);
        _handleAnchorPriceUpdate(inputToken);
        _handleAnchorPriceUpdate(outputToken); 
    }

    

    function _handlePoolReward(address _base, address _token) internal{
        if(!isBase(_token)){                        
            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);
            iERC20(_base).transfer(POOLS, _reward);
            iPOOLS(POOLS).sync(_base, _token);
            emit PoolReward(_base, _token, _reward);
        }
    }

    
    
    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {
        mapMemberToken_depositBase[member][token] += amountBase;
        mapMemberToken_depositToken[member][token] += amountToken;
        mapMemberToken_lastDeposited[member][token] = block.timestamp;
    }
    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {
        mapMemberToken_depositBase[member][token] += protection;
        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);
        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);
        mapMemberToken_depositBase[member][token] -= _baseToRemove;
        mapMemberToken_depositToken[member][token] -= _tokenToRemove;
    }

    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {
        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);
        if(base == VADER){
            if(protection >= reserveVADER()){
                protection = reserveVADER(); 
            }
        } else {
            if(protection >= reserveUSDV()){
                protection = reserveUSDV(); 
            }
        }
    }
    
    

    function curatePool(address token) external {
        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));
        if(!isCurated(token)){
            if(curatedPoolCount < curatedPoolLimit){ 
                _isCurated[token] = true;
                curatedPoolCount += 1;
            }
        }
        emit Curated(msg.sender, token);
    }
    function replacePool(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAsset(newToken));
        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ 
            _isCurated[oldToken] = false;
            _isCurated[newToken] = true;
            emit Curated(msg.sender, newToken);
        }
    }

    

    function listAnchor(address token) external {
        require(arrayAnchors.length < anchorLimit); 
        require(iPOOLS(POOLS).isAnchor(token));     
        arrayAnchors.push(token);                   
        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));
        _isCurated[token] = true; 
        updateAnchorPrice(token);
    }

    function replaceAnchor(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAnchor(newToken), ""Not anchor"");
        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), ""Not deeper"");
        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             
        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               
        _isCurated[oldToken] = false; 
        _isCurated[newToken] = true; 
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == oldToken){
                arrayAnchors[i] = newToken;
            }
        }
        updateAnchorPrice(newToken);
    }

    
    function updateAnchorPrice(address token) public {
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == token){
                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);
            }
        }
    }

    function _handleAnchorPriceUpdate(address _token) internal{
        if(iPOOLS(POOLS).isAnchor(_token)){
            updateAnchorPrice(_token);
        }
    }

    
    function getAnchorPrice() public view returns (uint anchorPrice) {
        if(arrayPrices.length > 0){
            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  
            anchorPrice = _sortedAnchorFeed[2];                         
        } else {
            anchorPrice = one;          
        }
    }

    
    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){
        uint _price = getAnchorPrice();
        return (_price * USDVAmount) / one;
    }

    
    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){
        uint _price = getAnchorPrice();
        return (vaderAmount * one) / _price;
    }
    
    
    

    
    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {
        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);
    }

    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {
        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);
        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  
        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               
        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            
        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  
            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  
            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         
        }
        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               
        payInterest(collateralAsset, debtAsset);
        return _debtIssued;
    }

    
    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){
        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);
    }
     
    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){
        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));
        uint _debt = moveTokenToPools(debtAsset, _amount);    
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           
        }
        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); 
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               
        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   
        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;
        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  
        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);
        _handleTransferOut(member, collateralAsset, _collateralUnlocked);
        payInterest(collateralAsset, debtAsset);
        return _collateralUnlocked;
    }

    
    function payInterest(address collateralAsset, address debtAsset) internal {
        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              
            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];
            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);
            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;
            _removeCollateral(_interestOwed, collateralAsset, debtAsset);
            if(isBase(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).sync(collateralAsset, debtAsset);
            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());
            }
        }
    }

    function checkLiquidate() public {
        
        
        
    }

    

    

    
    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _inputAmount = _getFunds(_collateralAsset, _amount); 
        }else if(isPool(_collateralAsset)){
             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); 
             _inputAmount = _amount;
        }
    }
    
    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _sendFunds(_collateralAsset, _member, _amount); 
        }else if(isPool(_collateralAsset)){
            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); 
        }
    }

    function _getFunds(address _token, uint _amount) internal returns(uint) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(tx.origin==msg.sender){
            require(iERC20(_token).transferTo(address(this), _amount));
        }else{
            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));
        }
        return iERC20(_token).balanceOf(address(this)) - _balance;
    }

    function _sendFunds(address _token, address _member, uint _amount) internal {
        require(iERC20(_token).transfer(_member, _amount));
    }

    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;
    }
    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;
    }
    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {
        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               
    }



    

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }

    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this));
    }
    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this));
    }

    
    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {
        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){
            safeAmount = _amount;
            if(tx.origin==msg.sender){
                iERC20(_token).transferTo(POOLS, _amount);
            }else{
                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            }
        } else {
            uint _startBal = iERC20(_token).balanceOf(POOLS);
            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;
        }
    }

    

    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function isCurated(address token) public view returns(bool curated) {
        if(_isCurated[token]){
            curated = true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    function getMemberBaseDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositBase[member][token];
    }
    function getMemberTokenDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositToken[member][token];
    }
    function getMemberLastDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_lastDeposited[member][token];
    }
    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];
    }
    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];
    }
    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];
    }
    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Debt[collateralAsset][debtAsset];
    }
    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];
    }
    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];
    }
}",5281.0,4,3,"{
  ""Findings"": [
    {
      ""Issue"": ""Re-initialization Vulnerability in `init` Function"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `init` function lacks proper access control, allowing it to be executed by anyone if `inited` is false, potentially leading to unauthorized initialization."",
      ""Impact"": ""This could allow an attacker to initialize the contract with their own parameters, leading to loss of control over the contract's state and potentially causing financial loss."",
      ""Location"": ""Function `init` defined in lines 85-95"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is accurate in pointing out a critical security flaw where the `init` function can be called by anyone, potentially allowing malicious actors to initialize the contract with arbitrary parameters.""
    },
    {
      ""Issue"": ""Missing onlyDAO Modifier in Critical Functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""The functions `setParams` and `setAnchorParams` are properly guarded with `onlyDAO`, but other critical functions like `init` lack this restriction."",
      ""Impact"": ""This can lead to unauthorized modifications of critical parameters by any user, compromising the security and intended governance of the system."",
      ""Location"": ""Function `init` around line 48; `setParams` and `setAnchorParams` with `onlyDAO` at lines 63 and 67 respectively"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is critical as it highlights inconsistent access control measures, particularly for the `init` function, which could lead to unauthorized parameter modifications.""
    },
    {
      ""Issue"": ""Potential for Reentrancy Attacks in Collateral Management"",
      ""Severity"": ""Critical"",
      ""Description"": ""The contract does not adequately protect against reentrancy attacks during collateral and debt management operations. Functions such as `borrowForMember` and `repayForMember` perform external calls before updating the state."",
      ""Impact"": ""An attacker could exploit this to manipulate collateral and debt, leading to financial loss and destabilization of the system."",
      ""Location"": ""Functions `borrowForMember` and `repayForMember`, specifically around token transfers and state updates"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Reentrancy attacks are a significant security concern, and addressing them is crucial for maintaining contract integrity, which is highly relevant to the task's focus on security.""
    },
    {
      ""Issue"": ""Immutable Initialization of External Contract Addresses"",
      ""Severity"": ""Critical"",
      ""Description"": ""The initialization of external contract addresses (`VADER`, `USDV`, `POOLS`) is done in the `init` function without any subsequent mechanism to change them securely. If initialized incorrectly, it can lead to permanent misconfiguration."",
      ""Impact"": ""Incorrect initialization can result in the contract interacting with unintended addresses, leading to potential loss of funds or contract malfunction."",
      ""Location"": ""Function `init` defined around line 57."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a critical design flaw that could permanently affect contract functionality, making it highly relevant and valid.""
    },
    {
      ""Issue"": ""Reentrancy Vulnerability in `swap` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `swap` function calls `swapWithSynthsWithLimit`, which interacts with external contracts via `iPOOLS(POOLS).swap` and `iPOOLS(POOLS).mintSynth`. These functions transfer tokens and could potentially be reentered if the external contract is compromised or malicious."",
      ""Impact"": ""A reentrancy attack could allow an attacker to drain funds from the contract by repeatedly calling the swap function before the first call is completed."",
      ""Location"": ""Function `swapWithSynthsWithLimit` in the `Router` contract"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant to the task as it addresses reentrancy vulnerabilities, which are a major security concern in functions interacting with external contracts. The assessment of the `swap` function aligns with the task’s focus on identifying such issues.""
    },
    {
      ""Issue"": ""Reentrancy Vulnerability in `borrow` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `borrow` function and its related functions (`borrowForMember`, `repay`, `repayForMember`) interact with external contracts through `iPOOLS(POOLS).swap`, which could be reentered by malicious contracts."",
      ""Impact"": ""This could lead to unauthorized fund withdrawals or manipulation of the contract's state."",
      ""Location"": ""Functions `borrow`, `borrowForMember`, `repay`, `repayForMember` in the `Router` contract"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant because it highlights potential reentrancy vulnerabilities in the `borrow` function and related functions, which are critical to the contract's security. The technical analysis accurately identifies the risk of reentrancy in these functions.""
    },
    {
      ""Issue"": ""External Call Failure Handling"",
      ""Severity"": ""High"",
      ""Description"": ""The contract makes multiple external calls to `iPOOLS`, `iUTILS`, and `iERC20` without handling potential failures. For example, if the external contract call fails or reverts, it can cause the entire transaction to fail, leading to a loss of gas fees paid by the user."",
      ""Impact"": ""Unanticipated failures in external calls can result in loss of funds, denial of service, or unintended state changes."",
      ""Location"": ""Functions `addLiquidity`, `removeLiquidity`, `swapWithSynthsWithLimit`, and others involving external calls."",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding directly addresses the need for robust external call handling, which is crucial for the contract's reliability and aligns with the task's scope.""
    },
    {
      ""Issue"": ""Lack of Access Control on Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `curatePool` and `replacePool` have no access restrictions, allowing any user to alter curated pools, which could lead to manipulation or abuse."",
      ""Impact"": ""Malicious actors could adjust curated pools to benefit themselves, potentially affecting pool rewards and liquidity management."",
      ""Location"": ""Functions `curatePool` and `replacePool` around lines 240-260"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it identifies a significant risk due to lack of access control, which could lead to manipulation by unauthorized users.""
    },
    {
      ""Issue"": ""Lack of Upgradeability Mechanism"",
      ""Severity"": ""High"",
      ""Description"": ""The contract does not implement any upgradeability mechanism, such as using a proxy pattern. This limits the ability to upgrade the contract in the future to fix bugs, add new features, or optimize performance."",
      ""Impact"": ""Inability to upgrade the contract could lead to prolonged exposure to bugs or vulnerabilities that may be discovered post-deployment. It also limits the adaptability of the contract to future requirements."",
      ""Location"": ""Overall contract design"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding correctly identifies the absence of an upgradeability mechanism, which is crucial for maintaining the contract's adaptability and security in a dynamic environment.""
    },
    {
      ""Issue"": ""Unchecked External Call in `_getFunds` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_getFunds` function uses `iERC20(_token).transferFrom` without verifying the return value, which could lead to failures being unnoticed."",
      ""Impact"": ""This could cause the contract to operate under incorrect assumptions about token transfers, potentially leading to fund loss or incorrect balances."",
      ""Location"": ""Function `_getFunds` in the `Router` contract"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant because it addresses the unchecked return value of an external call, a potential source of errors in contract execution. The analysis is technically valid, providing insight into ensuring robust token transfer handling.""
    },
    {
      ""Issue"": ""Absence of Slippage Handling in Swap Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The swap functions, such as `swap` and `swapWithSynths`, do not implement adequate checks for slippage, which can lead to users receiving less output than expected."",
      ""Impact"": ""Users may be dissatisfied due to unexpected losses during swaps, leading to a decrease in platform usage and trust."",
      ""Location"": ""Functions `swap` and `swapWithSynths`, lacking slippage checks"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Slippage handling is essential for user satisfaction and trust, and its absence is a valid concern for swap operations, directly relevant to the task.""
    },
    {
      ""Issue"": ""Incomplete Liquidation Logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `checkLiquidate` function is not implemented, leaving the system vulnerable to situations where over-leveraged positions are not liquidated, increasing systemic risk."",
      ""Impact"": ""Unmanaged debt positions can lead to insolvency and financial losses for the protocol and its users."",
      ""Location"": ""Function `checkLiquidate`, currently not implemented"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Liquidation logic is critical for managing risk in debt positions, and its absence directly affects system stability, making it a relevant concern for the task.""
    },
    {
      ""Issue"": ""Redundant Calls to External Contracts"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `swapWithSynthsWithLimit` make multiple calls to external contracts (e.g., `iPOOLS`, `iUTILS`) without storing interim results, which can be optimized."",
      ""Impact"": ""Repeated external contract calls are costly in terms of gas and should be minimized by storing results in local variables when possible."",
      ""Location"": ""Function `swapWithSynthsWithLimit` (lines 91-127)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it highlights unnecessary external calls, suggesting an optimization to reduce gas costs.""
    },
    {
      ""Issue"": ""Unchecked External Call in `_sendFunds` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_sendFunds` function calls the ERC-20 `transfer` function without verifying the return value. This might ignore failed transfers, potentially leading to fund loss or incorrect state updates."",
      ""Impact"": ""Ignoring failed transfers could lead to inconsistencies and potential exploits, especially with non-standard ERC-20 tokens."",
      ""Location"": ""Function `_sendFunds` around lines 550-553"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is technically correct and highlights a critical security practice of checking external call return values, which is important for preventing fund loss.""
    },
    {
      ""Issue"": ""Potential Integer Overflow in Swap Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations, such as those in the `swapWithSynthsWithLimit` function, do not utilize safe math operations. This poses a risk of overflow or underflow."",
      ""Impact"": ""Overflow or underflow can lead to incorrect calculations, exploitation, and financial losses."",
      ""Location"": ""Function `swapWithSynthsWithLimit` around lines 139-192"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding addresses a common vulnerability in smart contracts related to arithmetic operations, which is essential for maintaining contract integrity.""
    },
    {
      ""Issue"": ""Repetitive State Variable Reads in Loops"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `replaceAnchor` and `updateAnchorPrice` functions contain loops that repeatedly read from state variables like `arrayAnchors` and `arrayPrices`. These reads can be optimized by storing the values in memory variables before the loop."",
      ""Impact"": ""Repeated state variable reads in loops increase gas costs, making transactions more expensive for users."",
      ""Location"": ""Functions `replaceAnchor` (lines 206-217) and `updateAnchorPrice` (lines 220-224)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it addresses optimization of state reads within loops, enhancing performance by reducing gas costs.""
    },
    {
      ""Issue"": ""Inefficient Loop in `replaceAnchor`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The loop in `replaceAnchor` iterates over `arrayAnchors` to replace an old token with a new one. This approach is inefficient if `arrayAnchors` has a large number of elements."",
      ""Impact"": ""Inefficient loops can lead to high gas consumption, especially with large arrays, potentially hitting block gas limits."",
      ""Location"": ""Function `replaceAnchor` (lines 206-217)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding accurately identifies a potential inefficiency in looping through an array, which is relevant for optimizing gas usage.""
    },
    {
      ""Issue"": ""Insufficient Curated Pool Management"",
      ""Severity"": ""Low"",
      ""Description"": ""The logic for managing curated pools lacks flexibility and may not adapt well to changing market conditions, such as pool depth and asset volatility."",
      ""Impact"": ""Curated pools may not remain optimal, affecting liquidity and trading efficiency on the platform."",
      ""Location"": ""Functions `curatePool` and `replacePool`, handling of curated pools"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""While of lower severity, the management of curated pools is relevant to the efficiency of the platform, aligning with the task's objectives on performance and adaptability.""
    },
    {
      ""Issue"": ""Redundant State Updates"",
      ""Severity"": ""Low"",
      ""Description"": ""The `addDepositData` and `removeDepositData` functions update state variables even if the amounts to add or remove are zero."",
      ""Impact"": ""Updating state unnecessarily can lead to increased gas costs."",
      ""Location"": ""Functions `addDepositData` (lines 160-164) and `removeDepositData` (lines 165-170)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it points out unnecessary state updates, which can be avoided to save on gas fees.""
    },
    {
      ""Issue"": ""Lack of Event Emission for State-Changing Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions that result in state changes, such as `addLiquidity` and `removeLiquidity`, do not emit events, which is a best practice for transparency and off-chain tracking."",
      ""Impact"": ""Lack of event emission can hinder off-chain monitoring and debugging, reducing transparency in the contract's operation."",
      ""Location"": ""Functions `addLiquidity` and `removeLiquidity` around lines 94-108"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Event logging is a best practice for transparency and debugging, making this finding relevant as it helps improve contract interaction visibility.""
    }
  ],
  ""FindingNumber"": 20,
  ""AllRelevance"": 33,
  ""RelevanceCount"": 7,
  ""AllValidation"": 33,
  ""ValidationCount"": 7
}","---

### **[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol**

**Report Description**:  
The issue details a vulnerability where the `timeForFullProtection` is incorrectly initialized to 1 second instead of 100 days, likely due to a test configuration being carried over. Without proper initialization, the impermanent loss (IL) protection intended for 100 days is effectively reduced to 1 second. The missing functionality in the DAO to reset this value via `setParams()` further exacerbates the problem.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. There is no response in the provided list that directly addresses the incorrect initialization of `timeForFullProtection`. While some responses mention access control and function initialization concerns, none discuss the specific risk of incorrect initialization in this context.

---

### **[H-10] Anyone can list anchors / curate tokens**

**Report Description**:  
The `Router.listAnchor` function can be called by anyone, allowing anyone to add tokens as anchors. The only check in place (`require(iPOOLS(POOLS).isAnchor(token))`) can be bypassed by using the `Pools.addLiquidity` function, enabling attackers to add tokens to the pool. This issue could lead to manipulation of pool rewards and token prices through flash loans.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:  
**Correct**. The response correctly identifies the lack of access control on critical functions such as `curatePool` and `replacePool`. It also mentions the risk of unauthorized users manipulating curated pools, which aligns with the concerns raised in the report about the potential for manipulation via anchor token curation.

---

### **[H-15] Wrong slippage protection on Token -> Token trades**

**Report Description**:  
The report describes an issue with the `Router.swapWithSynthsWithLimit` function, where slippage protection is computed incorrectly. It compares the input amount of the first trade with the base reserve of the second pair, leading to either incorrect slippage rejection or the acceptance of trades with higher losses than expected.

**Match in Response List**:  
Matches with the issue titled **""Absence of Slippage Handling in Swap Operations""**.

**Validation**:  
**Correct**. The response points out the absence of proper slippage handling in swap operations, which directly correlates with the problem in the report where slippage protection is computed incorrectly. The response highlights the need for better slippage checks, which is relevant and accurate.

---

### **[H-23] Anyone can curate pools and steal rewards**

**Report Description**:  
The report highlights that both the `Router.curatePool` and `replacePool` functions lack access control, enabling anyone to modify curated pools. By doing so, an attacker can replace pools, steal rewards, and exploit the reward system, even bypassing liquidity restrictions using flash loans.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:  
**Correct**. The response correctly identifies the lack of access control over critical functions such as `curatePool` and `replacePool`. The report’s concern about manipulation of curated pools and reward theft is addressed in the response, which mentions the potential abuse of these functions due to the lack of restrictions.

---

### **[M-03] Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol**

**Report Description**:  
This issue describes the lack of input validation in the `replacePool()` function, where the function does not check if the `oldToken` exists and is curated. This allows an attacker to bypass the `curatedPoolLimit` check by passing a non-existing `oldToken`.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation""**.

**Validation**:  
**Correct**. The response identifies the issue with input validation in the replacePool() function. Failing to check whether the oldToken exists and is curated can allow improper tokens to be passed and could manipulate the curated pools or bypass limits.

---

### **[M-11] Allowing duplicated anchors could cause bias on anchor price**

**Report Description**:  
The issue describes that duplicated anchors can be added due to a lack of access control in the `listAnchor` function. This could lead to bias in anchor price calculation and manipulation of the results if the same anchor is added multiple times.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. There is no response that specifically addresses the problem of duplicated anchors and price bias in anchor price calculation. While the access control issues are discussed, this specific concern about duplicated anchors is not addressed.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:  
The issue points out that the `init` function can be called by anyone, leading to a potential race condition during contract deployment. A malicious actor could call the `init` function and interfere with the contract's initialization, potentially rendering it unusable.

**Match in Response List**:  
Matches with the issue titled **""Re-initialization Vulnerability in `init` Function""**.

**Validation**:  
**Correct**. The response correctly identifies the vulnerability in the `init` function due to the lack of access control, aligning with the concern raised in the report about unauthorized initialization. The validation also points out the risk of unauthorized execution, which could lead to loss of contract control.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-10] Anyone can list anchors / curate tokens** – Matched with ""Lack of Access Control on Critical Functions""
- **[H-15] Wrong slippage protection on Token -> Token trades** – Matched with ""Absence of Slippage Handling in Swap Operations""
- **[H-23] Anyone can curate pools and steal rewards** – Matched with ""Lack of Access Control on Critical Functions""
- **[M-03] Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol** - Matches with the issue titled ""Lack of Input Validation""
- **[M-13] Init function can be called by everyone** – Matched with ""Re-initialization Vulnerability in `init` Function""

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days**
- **[M-11] Allowing duplicated anchors could cause bias on anchor price**
",5,0,2,20,37,"### **Comparison of Issue Report and Response List**

---

#### **[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol**

**Report Description**:  
The `timeForFullProtection` variable is incorrectly initialized to 1 second instead of 8640000 seconds (100 days), as indicated in the code comments. This appears to be a test setting mistakenly carried over for deployment. Unless `timeForFullProtection` is reset to 100 days by `setParams()` (which is currently missing in the DAO), the Impermanent Loss (IL) protection ""rule"" of 100 days will not apply in `Utils.getProtection()`. This breaks a key value proposition of the Vader protocol, which is IL protection as specified in the documentation.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The incorrect initialization of `timeForFullProtection` is a critical vulnerability that directly impacts the protocol's functionality, but it is not covered in the response list.

---

#### **[H-10] Anyone can list anchors / curate tokens**

**Report Description**:  
The `Router.listAnchor` function can be called by anyone, allowing tokens to be added without proper checks. The only check is `require(iPOOLS(POOLS).isAnchor(token));`, which can be bypassed by calling `Pools.addLiquidity(VADER, token, _)` once, even without sending tokens. This makes the check essentially useless. Additionally, `replaceAnchor` can be exploited using flash loans to manipulate anchor tokens and curated pools, allowing attackers to remove rewards from existing pools and add rewards to their own pools. This can lead to price manipulation and other attacks.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the lack of access control on critical functions like `curatePool` and `replacePool`, which aligns with the issue. However, it does not address the specific exploitation of `listAnchor` and the use of flash loans to manipulate anchor tokens and curated pools.

---

#### **[H-15] Wrong slippage protection on Token -> Token trades**

**Report Description**:  
The `Router.swapWithSynthsWithLimit` function incorrectly computes slippage protection for token-to-token trades. Specifically, the slippage protection for the second trade (base to token) uses the input amount of the first trade instead of the base output from the first trade. This can lead to trades being canceled when they shouldn't be or accepted when the user suffers more losses than expected.

**Match in Response List**:  
Matches with the issue titled **""Absence of Slippage Handling in Swap Operations""**.

**Validation**:  
**Correct**. The response accurately identifies the lack of proper slippage handling in swap operations, which aligns with the issue. The response also suggests implementing better slippage protection, which is consistent with the recommendation in the issue report.

---

#### **[H-23] Anyone can curate pools and steal rewards**

**Report Description**:  
The `Router.curatePool` and `replacePool` functions lack access control, allowing anyone to curate or replace pools. An attacker can use flash loans to replace existing curated pools with their own pools, thereby stealing rewards. This can be exploited to game the reward system by repeatedly swapping in custom pools with useless tokens, withdrawing liquidity, and paying back the flash loan.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the lack of access control on critical functions like `curatePool` and `replacePool`, which aligns with the issue. However, it does not address the specific exploitation using flash loans to steal rewards.

---

#### **[M-03] Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol**

**Report Description**:  
The `replacePool()` function lacks input validation to check if `oldToken` exists and is curated. Using a non-existing `oldToken` (even the 0 address) bypasses the check, allowing `newToken` to be curated without enforcing the `curatedPoolLimit`. This can be used to bypass the curated pool limit enforced in `curatePool()`.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the lack of access control on critical functions, which aligns with the issue. However, it does not address the specific bypass of the curated pool limit due to missing input validation in `replacePool()`.

---

#### **[M-11] Allowing duplicated anchors could cause bias on anchor price**

**Report Description**:  
The `Router.listAnchor` function allows duplicate anchors to be added, which can bias the result of `getAnchorPrice`. If the same anchor is added multiple times, it can manipulate the anchor price calculation. This issue is exacerbated by the lack of access control on `listAnchor`.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Critical Functions""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the lack of access control on critical functions, which aligns with the issue. However, it does not address the specific issue of duplicate anchors biasing the anchor price calculation.

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:  
The `init` function in most Solidity contracts can be called by anyone, leading to a race condition when the contract is deployed. A hacker could call the `init` function and make the deployed contracts useless, requiring redeployment and incurring significant gas costs.

**Match in Response List**:  
Matches with the issue titled **""Re-initialization Vulnerability in `init` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the re-initialization vulnerability in the `init` function, which aligns with the issue. The response correctly explains the risks associated with unauthorized initialization, which is consistent with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-15] Wrong slippage protection on Token -> Token trades**
- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- **[H-10] Anyone can list anchors / curate tokens**
- **[H-23] Anyone can curate pools and steal rewards**
- **[M-03] Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol**
- **[M-11] Allowing duplicated anchors could cause bias on anchor price**

**Missed Issues from Issue Report**:

- **[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol**

--- 

This analysis highlights the coverage, accuracy, and sufficiency of the responses in addressing the issues reported. While some issues are correctly or partially addressed, others are entirely missed, indicating gaps in the response list.","```
1. Absence of Slippage Handling in Swap Operations
2. Re-initialization Vulnerability in `init` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Absence of Slippage Handling in Swap Operations"" appears at rank 12.
   - ""Re-initialization Vulnerability in `init` Function"" appears at rank 1.

2. **Calculate the precision at each rank**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 12: \( P@12 = \frac{2}{12} \approx 0.1667 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 0.1667}{2} = \frac{1.1667}{2} \approx 0.5833 \)

**Average Precision (AP)**: 0.5833"
Vault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.3;

import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

contract Vault {

    bool private inited;
    uint public erasToEarn;
    uint public minGrantTime;
    uint public lastGranted;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    uint public minimumDepositTime;
    uint public totalWeight;

    mapping(address => uint) private mapMember_weight;
    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;
    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;

    // Events
    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    constructor(){}

    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {
        require(inited == false);
        inited = true;
        POOLS = _pool;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
        POOLS = _pool;
        erasToEarn = 100;
        minimumDepositTime = 1;
        minGrantTime = 2592000;     // 30 days
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {
        erasToEarn = newEra;
        minimumDepositTime = newDepositTime;
        minGrantTime = newGrantTime;
    }

    // Can issue grants
    function grant(address recipient, uint amount) public onlyDAO {
        require((block.timestamp - lastGranted) >= minGrantTime, ""not too fast"");
        lastGranted = block.timestamp;
        iERC20(USDV).transfer(recipient, amount); 
    }

    //======================================DEPOSITS========================================//

    // Deposit USDV or SYNTHS
    function deposit(address synth, uint amount) external {
        depositForMember(synth, msg.sender, amount);
    }
    // Wrapper for contracts
    function depositForMember(address synth, address member, uint amount) public {
        require((iFACTORY(FACTORY).isSynth(synth)), ""Not Synth""); // Only Synths
        getFunds(synth, amount);
        _deposit(synth, member, amount);
    }
    function _deposit(address _synth, address _member, uint _amount) internal {
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         // Time of deposit
        mapMemberSynth_deposit[_member][_synth] += _amount;                 // Record deposit
        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);
        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){
            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               // Price in USDV
        }
        mapMember_weight[_member] += _weight;                               // Total member weight 
        totalWeight += _weight;                                             // Total weight 
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    //====================================== HARVEST ========================================//

    // Harvest, get payment, allocate, increase weight
    function harvest(address synth) external returns(uint reward) {
        address _member = msg.sender;
        uint _weight;
        address _token = iSYNTH(synth).TOKEN();
        reward = calcCurrentReward(synth, _member);                     // In USDV
        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      // Reset time
        if(iPOOLS(POOLS).isAsset(_token)){
            iERC20(USDV).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));
            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);
        } else {
            iERC20(VADER).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));
            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));
        }
        mapMemberSynth_deposit[_member][synth] += reward; 
        mapMember_weight[_member] += _weight;
        totalWeight += _weight;
        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);
    }

    // Get the payment owed for a member
    function calcCurrentReward(address synth, address member) public view returns(uint reward) {
        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        // Get time since last claim
        uint _share = calcReward(synth, member);                                               // Get share of rewards for member
        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         // Get owed amount, based on per-day rates
        uint _reserve;
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            _reserve = reserveUSDV();
        } else {
            _reserve = reserveVADER();
        }
        if(reward >= _reserve) {
            reward = _reserve;                                                          // Send full reserve if the last
        }
    }

    function calcReward(address synth, address member) public view returns(uint reward) {
        uint _weight = mapMember_weight[member];  
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      // Aggregrate reserves
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   // Get member's share of that
        } else{
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          
        }
    }

    //====================================== WITHDRAW ========================================//

    // Members to withdraw
    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          // Get amount to withdraw
        sendFunds(synth, msg.sender, redeemedAmount);
    }
    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {
        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, ""DepositTime"");    // stops attacks
        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Share of deposits
        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  // Reduce for member                             
        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   // Find recorded weight to reduce
        mapMember_weight[_member] -= _weight;                                   // Reduce for member 
        totalWeight -= _weight;                                                 // Reduce for total
        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   // Event
    }

    //============================== ASSETS ================================//

    function getFunds(address synth, uint amount) internal {
        if(tx.origin==msg.sender){
            require(iERC20(synth).transferTo(address(this), amount));
        }else{
            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));
        }
    }
    function sendFunds(address synth, address member, uint amount) internal {
        require(iERC20(synth).transfer(member, amount));
    }

    //============================== HELPERS ================================//

    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this)); // Balance
    }
    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this)); // Balance
    }

    function getMemberDeposit(address synth, address member) external view returns(uint){
        return mapMemberSynth_deposit[member][synth];
    }
    function getMemberWeight(address member) external view returns(uint){
        return mapMember_weight[member];
    }
    function getMemberLastTime(address synth, address member) external view returns(uint){
        return mapMemberSynth_lastTime[member][synth];
    }

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }

}",2105.0,206.0,"[H-18] Vault rewards can be gamed
The `_deposit` function increases the member's weight by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.
Notice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.
Call `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.
  [H-19] Vault rewards last claim time not always initialized
The `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the _secondsSinceClaim becomes the current block timestamp.
The larger the `_secondsSinceClaim` the larger the rewards. This bug allows claiming a huge chunk of the rewards.

 [H-20] Vault Weight accounting is wrong for withdrawals
When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.
The second deposited synth is now essentially weightless.
Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.

 [M-13] Init function can be called by everyone
Most of the solidity contracts have an `init` function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas. function init()",4.0,"pragma solidity ^0.8.3;

import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

contract Vault {

    bool private inited;
    uint public erasToEarn;
    uint public minGrantTime;
    uint public lastGranted;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    uint public minimumDepositTime;
    uint public totalWeight;

    mapping(address => uint) private mapMember_weight;
    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;
    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;

    
    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    constructor(){}

    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {
        require(inited == false);
        inited = true;
        POOLS = _pool;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
        POOLS = _pool;
        erasToEarn = 100;
        minimumDepositTime = 1;
        minGrantTime = 2592000;     
    }

    
    
    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {
        erasToEarn = newEra;
        minimumDepositTime = newDepositTime;
        minGrantTime = newGrantTime;
    }

    
    function grant(address recipient, uint amount) public onlyDAO {
        require((block.timestamp - lastGranted) >= minGrantTime, ""not too fast"");
        lastGranted = block.timestamp;
        iERC20(USDV).transfer(recipient, amount); 
    }

    

    
    function deposit(address synth, uint amount) external {
        depositForMember(synth, msg.sender, amount);
    }
    
    function depositForMember(address synth, address member, uint amount) public {
        require((iFACTORY(FACTORY).isSynth(synth)), ""Not Synth""); 
        getFunds(synth, amount);
        _deposit(synth, member, amount);
    }
    function _deposit(address _synth, address _member, uint _amount) internal {
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         
        mapMemberSynth_deposit[_member][_synth] += _amount;                 
        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);
        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){
            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               
        }
        mapMember_weight[_member] += _weight;                               
        totalWeight += _weight;                                             
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    

    
    function harvest(address synth) external returns(uint reward) {
        address _member = msg.sender;
        uint _weight;
        address _token = iSYNTH(synth).TOKEN();
        reward = calcCurrentReward(synth, _member);                     
        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      
        if(iPOOLS(POOLS).isAsset(_token)){
            iERC20(USDV).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));
            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);
        } else {
            iERC20(VADER).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));
            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));
        }
        mapMemberSynth_deposit[_member][synth] += reward; 
        mapMember_weight[_member] += _weight;
        totalWeight += _weight;
        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);
    }

    
    function calcCurrentReward(address synth, address member) public view returns(uint reward) {
        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        
        uint _share = calcReward(synth, member);                                               
        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         
        uint _reserve;
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            _reserve = reserveUSDV();
        } else {
            _reserve = reserveVADER();
        }
        if(reward >= _reserve) {
            reward = _reserve;                                                          
        }
    }

    function calcReward(address synth, address member) public view returns(uint reward) {
        uint _weight = mapMember_weight[member];  
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   
        } else{
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          
        }
    }

    

    
    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          
        sendFunds(synth, msg.sender, redeemedAmount);
    }
    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {
        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, ""DepositTime"");    
        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); 
        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  
        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   
        mapMember_weight[_member] -= _weight;                                   
        totalWeight -= _weight;                                                 
        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   
    }

    

    function getFunds(address synth, uint amount) internal {
        if(tx.origin==msg.sender){
            require(iERC20(synth).transferTo(address(this), amount));
        }else{
            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));
        }
    }
    function sendFunds(address synth, address member, uint amount) internal {
        require(iERC20(synth).transfer(member, amount));
    }

    

    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this)); 
    }
    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this)); 
    }

    function getMemberDeposit(address synth, address member) external view returns(uint){
        return mapMemberSynth_deposit[member][synth];
    }
    function getMemberWeight(address member) external view returns(uint){
        return mapMember_weight[member];
    }
    function getMemberLastTime(address synth, address member) external view returns(uint){
        return mapMemberSynth_lastTime[member][synth];
    }

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }

}",1860.0,3,1,"{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerabilities in Critical Functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""Multiple functions such as `depositForMember`, `withdraw`, `harvest`, and others have been identified with reentrancy vulnerabilities. These functions make external calls before updating internal state variables, allowing attackers to exploit them through recursive calls to manipulate funds."",
      ""Impact"": ""Reentrancy attacks can lead to unauthorized withdrawals, manipulation of balances, and potentially draining contract funds."",
      ""Location"": ""Functions `depositForMember`, `withdraw`, `harvest`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""These findings are critical as they highlight severe vulnerabilities that can lead to significant financial losses if exploited.""
    },
    {
      ""Issue"": ""Lack of Access Control on Initialization and Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Critical functions including `init` lack proper access control. Anyone can initialize or set critical parameters, potentially leading to unauthorized configuration and control over the contract."",
      ""Impact"": ""Improper access control can result in unauthorized manipulation of critical contract parameters, potentially leading to security breaches and financial losses."",
      ""Location"": ""Function `init` and other critical parameter-setting functions"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The lack of access control in these functions poses a high risk of unauthorized access and manipulation, aligning with core security concerns.""
    },
    {
      ""Issue"": ""Improper Use of `tx.origin` for Authorization"",
      ""Severity"": ""High"",
      ""Description"": ""The use of `tx.origin` in authorization checks is discouraged due to its susceptibility to phishing attacks. Functions like `getFunds` rely on `tx.origin`, which can lead to unauthorized transactions."",
      ""Impact"": ""An attacker could exploit this vulnerability to perform unauthorized actions, leading to financial losses."",
      ""Location"": ""Function `getFunds`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This issue is critical as it directly affects the security of transaction authorization, posing a significant risk.""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""Arithmetic operations across functions like `_deposit`, `calcReward`, and others do not utilize safe math libraries, risking overflow or underflow."",
      ""Impact"": ""Incorrect calculations could affect reward distributions and contract balance management, leading to financial discrepancies."",
      ""Location"": ""Functions `_deposit`, `calcReward`, and others"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it addresses critical arithmetic operations that are essential for maintaining contract integrity.""
    },
    {
      ""Issue"": ""Lack of Event Emission for Critical State Changes"",
      ""Severity"": ""Low"",
      ""Description"": ""Critical state changes in functions like `init`, `setParams`, and `grant` do not emit events, impacting transparency and traceability."",
      ""Impact"": ""Reduced ability to track changes and audit contract interactions, potentially leading to disputes or lack of accountability."",
      ""Location"": ""Functions `init`, `setParams`, `grant`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a best practice issue that, while not critical, affects contract transparency and effective monitoring.""
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 54,
  ""RelevanceCount"": 53,
  ""AllValidation"": 54,
  ""ValidationCount"": 53
}","---

### **[H-18] Vault rewards can be gamed**

**Report Description**:
The `_deposit` function increases the member's weight based on the output amount when trading a deposited underlying synth. Since users can create custom synths by calling `Pools.deploySynth(customToken)`, it is possible for malicious actors to create custom tokens and then use them in the vault to manipulate reward calculations. This would allow users to withdraw more rewards than they are entitled to, exploiting the weight-based reward system.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue described in H-18, which is about manipulating rewards via custom synth tokens. The response focuses on access control, reentrancy vulnerabilities, and other issues not directly related to token creation or vault reward manipulation. The issue here is a flaw in how custom synth tokens are handled in the reward system and the potential for gaming the system, which is not covered by the responses provided.

---

### **[H-19] Vault rewards last claim time not always initialized**

**Report Description**:
The `harvest` function calls `calcCurrentReward`, which calculates the time since the last claim based on `mapMemberSynth_lastTime[member][synth]`. If this value is uninitialized, it could cause `_secondsSinceClaim` to be set to the current timestamp, allowing users to claim more rewards than intended. This bug could result in users exploiting the system to claim rewards prematurely.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not specifically address the issue of uninitialized `mapMemberSynth_lastTime` leading to incorrect reward calculations. This issue revolves around the initialization and handling of member claim times, which could cause users to claim rewards they shouldn't be entitled to. None of the responses cover the impact of uninitialized state variables in reward calculations.

---

### **[H-20] Vault Weight accounting is wrong for withdrawals**

**Report Description**:
When two different synths are deposited, their weights are stored in the same `mapMember_weight[_member]` variable. If the full weight for one synth is withdrawn, the remaining synth becomes weightless, preventing users from claiming their fair share of rewards. This results in incorrect weight accounting and improper reward distribution.

**Match in Response List**:
No match found.

**Validation**:
**Incorrect**. The response list does not address the issue of weight accounting during withdrawals, where one synth's withdrawal leaves the remaining synth weightless. This issue pertains to how the contract manages and tracks weights associated with different deposited assets. It is a logic flaw in how the contract handles multiple synths and rewards, which is not addressed in any of the responses.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init` function can be called by anyone, potentially allowing a malicious actor to manipulate the contract state during deployment. This could lead to race conditions or the ability to disable the contract, requiring costly redeployment.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on Initialization and Critical Functions""**.

**Validation**:
**Correct**. The response correctly identifies the issue of improper access control on the `init` function. It accurately explains the risk of unauthorized access and manipulation of critical contract parameters, aligning with the vulnerability described in M-13. Proper access control mechanisms should be implemented to prevent unauthorized function calls, particularly for critical functions like `init`.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone** → **""Lack of Access Control on Initialization and Critical Functions""**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-18] Vault rewards can be gamed**
- **[H-19] Vault rewards last claim time not always initialized**
- **[H-20] Vault Weight accounting is wrong for withdrawals**

---

### **Summary of Evaluation**

- The response list provides useful insights into access control and reentrancy vulnerabilities, but **it fails to address several issues related to the vault's reward system and state handling**, such as custom synth manipulation, uninitialized timestamps, and weight accounting for withdrawals.
- More comprehensive responses that directly address the specific flaws in vault management, initialization, and reward systems are needed.
",1,0,3,5,54,"### **Comparison of Issue Report and Response List**

---

#### **[H-18] Vault rewards can be gamed**

**Report Description**:  
The `_deposit` function increases the member's weight based on the swap output amount when trading the deposited underlying synth amount. However, anyone can create custom synths by calling `Pools.deploySynth(customToken)`. By calling `harvest(realSynth)` with a synth of actual value, the synth balance is increased, which can later be withdrawn. This allows users to game the vault rewards system.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of vault rewards being gamed through the creation of custom synths and manipulation of the `harvest` function. This is a significant oversight, as it directly impacts the fairness and security of the reward distribution mechanism.

---

#### **[H-19] Vault rewards last claim time not always initialized**

**Report Description**:  
The `harvest` function calls `calcCurrentReward`, which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth]`. Since users can claim rewards for synths they did not deposit, `mapMemberSynth_lastTime[member][synth]` might remain uninitialized, causing `_secondsSinceClaim` to equal the current block timestamp. This results in disproportionately large rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of uninitialized `mapMemberSynth_lastTime` leading to inflated rewards. This is a critical vulnerability that undermines the integrity of the reward system.

---

#### **[H-20] Vault Weight accounting is wrong for withdrawals**

**Report Description**:  
When depositing two different synths, their weights are added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth using `_processWithdraw(synth, member, basisPoints=10000)`, the full weight is decreased. This leaves the second deposited synth effectively weightless, preventing users who deposited multiple synths from claiming their fair share of rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect weight accounting during withdrawals, which unfairly impacts users who deposit multiple synths. This is a significant flaw in the reward distribution logic.

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:  
Most Solidity contracts have an `init` function that can be called by anyone. This could lead to a race condition during contract deployment, where a hacker could call the `init` function and render the deployed contracts useless. This would necessitate redeployment, incurring significant gas costs.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on Initialization and Critical Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of improper access control on the `init` function. It correctly highlights the risk of unauthorized initialization, which aligns with the reported vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-18] Vault rewards can be gamed**
- **[H-19] Vault rewards last claim time not always initialized**
- **[H-20] Vault Weight accounting is wrong for withdrawals**

---

### **Analysis**

The response list effectively addresses some issues, such as improper access control on the `init` function, but it fails to cover critical vulnerabilities related to the vault reward system. Specifically, the issues of gaming rewards, uninitialized claim times, and incorrect weight accounting are entirely missed. These gaps represent significant risks to the fairness and security of the contract, and they should be addressed in future updates to the response list.","```
1. Lack of Access Control on Initialization and Critical Functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Lack of Access Control on Initialization and Critical Functions"".
   - In the ranked list of predictions, this issue appears at **rank 2**.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Here, \( k = 2 \), and there is **1 true positive** up to rank 2.
   - \( P@2 = \frac{1}{2} = 0.5 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only **1 true positive**, the AP is simply the precision at its rank.
   - \( AP = 0.5 \).

**Output**:
```
0.5
```"
Vether.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iVETHER.sol"";

// Token Contract
contract Vether is iVETHER {

    // Coin Defaults
    string public override name;                                         // Name of Coin
    string public override symbol;                                       // Symbol of Coin
    uint public override decimals  = 18;                              // Decimals
    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   // 1,000,000 Total

    uint public totalFees;
    mapping(address=>bool) public mapAddress_Excluded;  

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    
    // Minting event
    constructor() {
        name = ""Vether"";
        symbol  = ""VETH"";
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""iERC20: approve from the zero address"");
        require(spender != address(0), ""iERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

       // Internal transfer function which includes the Fee
    function _transfer(address _from, address _to, uint _value) private {
        require(_balances[_from] >= _value, 'Must not send more than balance');
        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');
        _balances[_from] -= _value;
        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount
        _balances[_to] += (_value - _fee);                                               // Add to receiver
        _balances[address(this)] += _fee;                                                   // Add fee to self
        totalFees += _fee;                                                                  // Track fees collected
        emit Transfer(_from, _to, (_value - _fee));                                      // Transfer event
        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {
            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event
        }
    }
    
    // Calculate Fee amount
    function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }

    function addExcluded(address excluded) public {
        mapAddress_Excluded[excluded] = true;
    }
}",921.0,96.0,"[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List.
Vether.sol implements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses (mapAddress_Excluded). However, the addExcluded() function in Vether.sol has no restrictions on who can call it. So any user can call addExcluded with their own address as the argument, and bypass all transfer fees Alice calls:
(1) Vether.addExcluded(aliceAddress), which adds Alice's address to mapAddress_Excluded. (2) Alice can now freely transfer Vether with no fees.
Recommend adding restrictions to who can call addExcluded, perhaps by restricting it to a caller set by DAO.sol
",1.0,"pragma solidity 0.8.3;


import ""./interfaces/iVETHER.sol"";


contract Vether is iVETHER {

    
    string public override name;                                         
    string public override symbol;                                       
    uint public override decimals  = 18;                              
    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   

    uint public totalFees;
    mapping(address=>bool) public mapAddress_Excluded;  

    
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    
    
    constructor() {
        name = ""Vether"";
        symbol  = ""VETH"";
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""iERC20: approve from the zero address"");
        require(spender != address(0), ""iERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

       
    function _transfer(address _from, address _to, uint _value) private {
        require(_balances[_from] >= _value, 'Must not send more than balance');
        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');
        _balances[_from] -= _value;
        uint _fee = _getFee(_from, _to, _value);                                            
        _balances[_to] += (_value - _fee);                                               
        _balances[address(this)] += _fee;                                                   
        totalFees += _fee;                                                                  
        emit Transfer(_from, _to, (_value - _fee));                                      
        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {
            emit Transfer(_from, address(this), _fee);                                      
        }
    }
    
    
    function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        
        } else {
            return (_value / 1000);                                                         
        }
    }

    function addExcluded(address excluded) public {
        mapAddress_Excluded[excluded] = true;
    }
}",787.0,1,0,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on addExcluded Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `addExcluded` function is publicly accessible, allowing users to add any address to the `mapAddress_Excluded` list, potentially exempting them from transaction fees without proper authorization."",
      ""Impact"": ""This could lead to unfair advantages and potential loss of protocol revenue as malicious actors could exclude themselves or others from fees."",
      ""Location"": ""Function `addExcluded`, lines 68, 78, 94, 98-100"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding highlights a critical issue with lack of access control on a function that can modify fee exemptions.""
    },
    {
      ""Issue"": ""Potential Arithmetic Underflow in Allowance Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `decreaseAllowance` and `transferFrom` perform unchecked subtraction on allowances, risking underflows which can lead to incorrect allowance values."",
      ""Impact"": ""This can result in unauthorized transfers and incorrect permissions due to unintended large allowance values."",
      ""Location"": ""Function `decreaseAllowance`, lines 32, 40-43; Function `transferFrom`, lines 54, 55-58"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The issue is relevant for ensuring ERC20 compliance and proper allowance management, preventing underflows.""
    },
    {
      ""Issue"": ""Potential Mismanagement of Fees"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_transfer` function collects fees but lacks a mechanism to manage or utilize these accumulated fees, potentially leading to locked funds."",
      ""Impact"": ""Accumulated fees may be inaccessible or mismanaged, resulting in potential loss of funds if not properly handled or distributed."",
      ""Location"": ""Function `_transfer`, lines 56, 70-81"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding highlights a risk in the management of collected fees, crucial for financial soundness.""
    },
    {
      ""Issue"": ""Redundant State Update in _transfer Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The state update for totalFees is redundant when the fee is zero, leading to unnecessary gas consumption."",
      ""Impact"": ""Unnecessary state updates consume additional gas, which can be optimized to reduce transaction costs."",
      ""Location"": ""Function `_transfer`, line 57"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This addresses the efficiency of state updates, aligning with the task's scope of optimizing gas consumption.""
    },
    {
      ""Issue"": ""Fee Collection and Distribution Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract collects fees but does not specify how these fees are to be utilized or distributed, potentially leading to an accumulation of funds without clear usage."",
      ""Impact"": ""Accumulated fees can lead to locked funds if not properly managed, resulting in a loss of utility for the fees collected."",
      ""Location"": ""Function `_transfer`, lines 70-81"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The observation about fee collection without a clear distribution mechanism highlights a potential issue of fund accumulation without specified utility.""
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 19,
  ""RelevanceCount"": 12,
  ""AllValidation"": 19,
  ""ValidationCount"": 12
}","---

**[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List**

**Report Description**:
The `addExcluded()` function in `Vether.sol` lacks access control, allowing any user to add their address to the list of excluded addresses (`mapAddress_Excluded`). This enables users to bypass all transfer fees by adding themselves to the exclusion list, leading to potential loss of protocol revenue and unfair advantages for malicious actors.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on addExcluded Function""**.

**Validation**:
**Correct**. The response accurately identifies the lack of access control on the `addExcluded` function, noting that any user can add themselves to the exclusion list and bypass transaction fees. The description matches the vulnerability in the original issue report, and the severity is correctly marked as high due to the potential for malicious actors to exploit this issue. The recommendation to add restrictions (such as by limiting access to certain addresses) aligns well with best practices for securing sensitive contract functions.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

---
",1,0,0,5,19,"---

**[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List**

**Report Description**:
The `addExcluded()` function in `Vether.sol` allows any user to add their address to the `mapAddress_Excluded` list, bypassing all transfer fees. This lack of access control enables malicious actors to exempt themselves or others from fees, leading to unfair advantages and potential loss of protocol revenue. The issue recommends restricting access to the `addExcluded` function, possibly by limiting it to a caller set by `DAO.sol`.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control on addExcluded Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `addExcluded` function, highlighting the lack of access control and its potential impact on protocol revenue. The description and impact align with the issue report, and the response correctly emphasizes the need for proper authorization to prevent misuse. This aligns with Solidity best practices for access control and secure contract design.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

---","```
1. Lack of Access Control on addExcluded Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Lack of Access Control on addExcluded Function"".
   - This prediction appears at rank 1 in the ranked list.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - \( P@1 = \frac{1}{1} = 1.0 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the AP is simply the precision at rank 1.

**Average Precision (AP)**: 1.0"
,,,,,,,,25,20,,,22,4,19,55,328,,,
