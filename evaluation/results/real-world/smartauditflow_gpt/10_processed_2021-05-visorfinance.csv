nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparaion,Correct Matches,Partially Correct,Missed,GPT-generated,Tasks,Comparison,matchList,MAP
Visor.sol,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";

/// @title Visor
/// @notice Vault for isolated storage of staking tokens
/// @dev Warning: not compatible with rebasing tokens
contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    /* constant */

    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks
    // the gas requirement cannot be determined at runtime by querying the delegate
    // as it could potentially be manipulated by a malicious delegate who could force
    // the calls to revert.
    // The gas limit could alternatively be set upon vault initialization or creation
    // of a lock, but the gas consumption trade-offs are not favorable.
    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    /* storage */

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    /* initialization function */

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    /* ether receive */

    receive() external payable {}

    /* internal  */

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    /* pure functions */

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    /* getter functions */

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        // iterate over all token locks and validate sufficient balance
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            // fetch storage lock reference
            LockData storage _lockData = _locks[_lockSet.at(index)];
            // if insufficient balance and no∏t shutdown, return false
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        // if sufficient balance or shutdown, return true
        return true;
    }

    // @notice Get ERC721 from nfts[] by index
    /// @param i nfts index of nfts[] 
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    // @notice Get index of ERC721 in nfts[]
    /// @param nftContract Address of ERC721 
    /// @param tokenId tokenId for NFT in nftContract 
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    // @notice Get number of timelocks for given ERC20 token 
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    // @notice Get number of timelocks for NFTs of a given ERC721 contract 
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

    /* user functions */

    /// @notice Lock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: anytime
    /// state scope:
    /// - insert or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being locked
    /// @param amount Amount of tokens being locked
    /// @param permission Permission signature payload
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // add lock to storage
        if (_lockSet.contains(lockID)) {
            // if lock already exists, increase amount
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            // if does not exist, create new lock
            // add lock to set
            assert(_lockSet.add(lockID));
            // add lock data to storage
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        // validate sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        // increase nonce
        _nonce += 1;

        // emit event
        emit Locked(msg.sender, token, amount);
    }

    /// @notice Unlock ERC20 tokens in the vault
    /// access control: called by delegate with signed permission from owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove or update _locks
    /// - increase _nonce
    /// token transfer: none
    /// @param token Address of token being unlocked
    /// @param amount Amount of tokens being unlocked
    /// @param permission Permission signature payload
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        // get lock id
        bytes32 lockID = calculateLockID(msg.sender, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // update lock data
        if (_locks[lockID].balance > amount) {
            // substract amount from lock balance
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            // delete lock data
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        // increase nonce
        _nonce += 1;

        // emit event
        emit Unlocked(msg.sender, token, amount);
    }

    /// @notice Forcibly cancel delegate lock
    /// @dev This function will attempt to notify the delegate of the rage quit using
    ///      a fixed amount of gas.
    /// access control: only owner
    /// state machine: after valid lock from delegate
    /// state scope:
    /// - remove item from _locks
    /// token transfer: none
    /// @param delegate Address of delegate
    /// @param token Address of token being unlocked
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        // get lock id
        bytes32 lockID = calculateLockID(delegate, token);

        // validate existing lock
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        // attempt to notify delegate
        if (delegate.isContract()) {
            // check for sufficient gas
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            // attempt rageQuit notification
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        // update lock storage
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        // emit event
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }

    /// @notice Transfer ERC20 tokens out of vault
    /// access control: only owner
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    // @notice Approve delegate account to transfer ERC20 tokens out of vault
    /// @param token Address of token being transferred
    /// @param delegate Address being approved
    /// @param amount Amount of tokens approved to transfer
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }

    /// @notice Transfer ERC20 tokens out of vault with an approved account
    /// access control: only approved accounts in erc20Approvals 
    /// state machine: when balance >= max(lock) + amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param token Address of token being transferred
    /// @param to Address of the to
    /// @param amount Amount of tokens to transfer
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        // check for sufficient balance
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        // perform transfer
        TransferHelper.safeTransfer(token, to, amount);
    }

    /// @notice Transfer ETH out of vault
    /// access control: only owner
    /// state machine: when balance >= amount
    /// state scope: none
    /// token transfer: transfer any token
    /// @param to Address of the to
    /// @param amount Amount of ETH to transfer
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      // perform transfer
      TransferHelper.safeTransferETH(to, amount);
    }

    // @notice Approve delegate account to transfer ERC721 token out of vault
    /// @param delegate Account address being approved to transfer nft  
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }

    /// @notice Transfer ERC721 out of vault
    /// access control: only owner or approved
    /// ERC721 transfer: transfer any ERC721 token
    /// @param to recipient address 
    /// @param nftContract address of nft minter 
    /// @param tokenId token id of the nft instance 
    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    // @notice Adjust nfts[] on ERC721 token recieved 
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }

    // @notice Lock ERC721 in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw 
    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }

    // @notice Withdraw ERC721 in vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param nftContract address of nft minter 
    /// @param tokenId Token id of the nft instance 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    // @notice Withdraw ERC20 from vault post expires by recipient
    /// @param recipient Address with right to withdraw after expires 
    /// @param token Address of token to lock 
    /// @param amount Amount of token to lock 
    /// @param expires Timestamp when recipient is allowed to withdraw
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",5244,643,"[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault
Let’s consider a scenario where a particular NFT token was timelocked for a certain duration by the owner using `timeLockERC721()` with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using `timeUnlockERC721()`. This is possible because `transferERC721()` does all the timelock checks on `expires/block.timestamp` and `recipient/msg.sender` as is done in timeUnlockERC721(). But it misses deleting timelockERC721s[key] for that NFT tokenID (as done in L572 of timeUnlockERC721()). Because of this missing deletion, if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the `transferERC721()` call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock).   [H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens
NFT transfer approvals that are set to true in `approveTransferERC721()` are never set to false and there is no way to remove such an nft approval. Impact 1: The approval is not removed (set to false) after a transfer in transferERC721(). So if the NFT is ever moved back into the owner's vault again, then the previous/compromised delegate can again transfer it to any address of choice without requiring a new approval.
Impact 2: If a delegate becomes compromised/untrustworthy after granting approval but before transfer then the owner will lose its NFT because there is no mechanism to revoke the approval that was granted earlier.
  [H-03] Approval for NFT transfers is not removed after transfer
The `Visor.transferERC721` does not reset the approval for the NFT.
An approved delegatee can move the NFT out of the contract once. It could be moved to a market and bought by someone else who then deposits it again to the same vault. The first delegatee can steal the NFT and move it out of the contract a second time.
  [H-04] Unbounded loop in _removeNft could lead to a griefing/DOS attack Griefing/DOS attack is possible when a malicious NFT contract sends many NFTs to the vault, which could cause excessive gas consumed and even transactions reverted when other users are trying to unlock or transfer NFTs.
The function `_removeNft` uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas. The function onERC721Received is permission-less. The vault accepts any NFTs from any NFT contract and pushes the received NFT into the array nfts. A malicious user could write an NFT contract, which calls onERC721Received of the vault many times to make the array nfts grow to a large size. Besides, the malicious NFT contract reverts when anyone tries to transfer (e.g., safeTransferFrom) its NFT. The vault then has no way to remove the transferred NFT from the malicious NFT contract. The two only functions to remove NFTs, transferERC721 and timeUnlockERC721, fail since the malicious NFT contract reverts all safeTransferFrom calls. As a result, benign users who unlock or transfer NFTs would suffer from large and unnecessary gas consumption. The consumed gas could even exceed the block gas limit and cause the transaction to fail every time. Recommend using a mapping (e.g., mapping(address=>Nft[]) nfts) to store the received NFTs into separate arrays according to nftContract instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly.   [M-01] Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from Consensys Diligence Audit of Aave Protocol V2. While the contract uses Uniswap’s TransferHelper library function safeTransfer in other places for ERC20 tokens, or OpenZeppelin’s saferTransferFrom for ERC721 tokens (both of which call the token’s transfer/transferFrom functions and check return value for success and return data), it misses using TransferHelper.safeTransferFrom in this one case on L610 in timeLockERC20() when tokens are transferred from owner to the vault and instead directly uses the token’s transferFrom() call without checking for its return value.
The impact can be that for an arbitrary ERC20 token, this transferFrom() call may return failure but the vault logic misses that, assumes it was successfully transferred into the vault and updates the timelockERC20Balances accounting accordingly. The timeUnlockERC20(), transferERC20() or delegatedTransferERC20() calls for that token will fail because the vault contract balance would have less tokens than accounted for in timelockERC20Balances because of the previously failed (but ignored) transferFrom() call.
  [M-02] transferERC721 doesn't clean timelockERC721s
The function transferERC721 works similar to the functions timeUnlockERC721 with timelocked NFT's. However timeUnlockERC721 cleans timelockERC721s (delete timelockERC721s[key];), while transferERC721 doesn't clean timelockERC721s
This could mean that timelock keys could be used later on (when the NFT would have been transferred to the contract on a later moment in time). Also, the administration doesn't correspond to the available NFT's. Additionally doing a delete gives backs some gas (at least for now).   [M-03] `timelockERC721Keys` could exceed the block size limit
On line 504 of Visor.sol, looping through the `timelockERC721Keys` could exceed the block size limit
Recommend transfer by index instead of token ID",7,"pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {IERC721Receiver} from ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";

import {Initializable} from ""@openzeppelin/contracts/proxy/Initializable.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {EIP712} from ""./EIP712.sol"";
import {ERC1271} from ""./ERC1271.sol"";
import {OwnableERC721} from ""./OwnableERC721.sol"";
import {IRageQuit} from ""../hypervisor/Hypervisor.sol"";

import {IUniversalVault} from ""../interfaces/IUniversalVault.sol"";
import {IVisorService} from ""../interfaces/IVisorService.sol"";


contract Visor is
    IUniversalVault,
    EIP712(""UniversalVault"", ""1.0.0""),
    ERC1271,
    OwnableERC721,
    Initializable,
    IERC721Receiver
{
    using SafeMath for uint256;
    using Address for address;
    using Address for address payable;
    using EnumerableSet for EnumerableSet.Bytes32Set;

    uint256 public constant RAGEQUIT_GAS = 500000;
    bytes32 public constant LOCK_TYPEHASH =
        keccak256(""Lock(address delegate,address token,uint256 amount,uint256 nonce)"");
    bytes32 public constant UNLOCK_TYPEHASH =
        keccak256(""Unlock(address delegate,address token,uint256 amount,uint256 nonce)"");

    string public constant VERSION = ""VISOR-2.0.3"";

    

    uint256 private _nonce;
    mapping(bytes32 => LockData) private _locks;
    EnumerableSet.Bytes32Set private _lockSet;
    string public uri;

    struct Nft {
      uint256 tokenId; 
      address nftContract;
    }

    Nft[] public nfts;
    mapping(bytes32=>bool) public nftApprovals;
    mapping(bytes32=>uint256) public erc20Approvals;

    struct TimelockERC20 {
      address recipient;
      address token;
      uint256 amount;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC20) public timelockERC20s; 
    mapping(address=>bytes32[]) public timelockERC20Keys;
    mapping(address=>uint256) public timelockERC20Balances;

    struct TimelockERC721 {
      address recipient;
      address nftContract;
      uint256 tokenId;
      uint256 expires;
    }

    mapping(bytes32=>TimelockERC721) public timelockERC721s; 
    mapping(address=>bytes32[]) public timelockERC721Keys;

    event AddNftToken(address nftContract, uint256 tokenId);
    event RemoveNftToken(address nftContract, uint256 tokenId);
    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);
    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);
    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);

    

    function initializeLock() external initializer {}

    function initialize() external override initializer {
      OwnableERC721._setNFT(msg.sender);
    }

    

    receive() external payable {}

    

    function _addNft(address nftContract, uint256 tokenId) internal {

      nfts.push(
        Nft({
          tokenId: tokenId,
          nftContract: nftContract
        })
      );
      emit AddNftToken(nftContract, tokenId);
    }

    function _removeNft(address nftContract, uint256 tokenId) internal {
      uint256 len = nfts.length;
      for (uint256 i = 0; i < len; i++) {
        Nft memory nftInfo = nfts[i];
        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {
          if(i != len - 1) {
            nfts[i] = nfts[len - 1];
          }
          nfts.pop();
          emit RemoveNftToken(nftContract, tokenId);
          break;
        }
      }
    }

    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {
        return OwnableERC721.owner();
    }

    

    function calculateLockID(address delegate, address token)
        public
        pure
        override
        returns (bytes32 lockID)
    {
        return keccak256(abi.encodePacked(delegate, token));
    }

    

    function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }

    function getNonce() external view override returns (uint256 nonce) {
        return _nonce;
    }

    function owner()
        public
        view
        override(IUniversalVault, OwnableERC721)
        returns (address ownerAddress)
    {
        return OwnableERC721.owner();
    }

    function getLockSetCount() external view override returns (uint256 count) {
        return _lockSet.length();
    }

    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {
        return _locks[_lockSet.at(index)];
    }

    function getBalanceDelegated(address token, address delegate)
        external
        view
        override
        returns (uint256 balance)
    {
        return _locks[calculateLockID(delegate, token)].balance;
    }

    function getBalanceLocked(address token) public view override returns (uint256 balance) {
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            LockData storage _lockData = _locks[_lockSet.at(index)];
            if (_lockData.token == token && _lockData.balance > balance)
                balance = _lockData.balance;
        }
        return balance;
    }

    function checkBalances() external view override returns (bool validity) {
        
        uint256 count = _lockSet.length();
        for (uint256 index; index < count; index++) {
            
            LockData storage _lockData = _locks[_lockSet.at(index)];
            
            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;
        }
        
        return true;
    }

    
    
    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {
        require(i < nfts.length, ""ID overflow"");
        Nft memory ni = nfts[i];
        nftContract = ni.nftContract;
        tokenId = ni.tokenId;
    }

    
    
    
    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {
        uint256 len = nfts.length;
        for (uint256 i = 0; i < len; i++) {
            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {
                return i;
            }
        }
        require(false, ""Token not found"");
    }

    
    function getTimeLockCount(address token) public view returns(uint256) {
      return timelockERC20Keys[token].length;
    }

    
    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {
      return timelockERC721Keys[nftContract].length;
    }

   
    function lock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        if (_lockSet.contains(lockID)) {
            
            _locks[lockID].balance = _locks[lockID].balance.add(amount);
        } else {
            
            
            assert(_lockSet.add(lockID));
            
            _locks[lockID] = LockData(msg.sender, token, amount);
        }

        
        require(
            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,
            ""UniversalVault: insufficient balance""
        );

        
        _nonce += 1;

        
        emit Locked(msg.sender, token, amount);
    }

   
    function unlock(
        address token,
        uint256 amount,
        bytes calldata permission
    )
        external
        override
        onlyValidSignature(
            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),
            permission
        )
    {
        
        bytes32 lockID = calculateLockID(msg.sender, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (_locks[lockID].balance > amount) {
            
            _locks[lockID].balance = _locks[lockID].balance.sub(amount);
        } else {
            
            delete _locks[lockID];
            assert(_lockSet.remove(lockID));
        }

        
        _nonce += 1;

        
        emit Unlocked(msg.sender, token, amount);
    }


    
    function rageQuit(address delegate, address token)
        external
        override
        onlyOwner
        returns (bool notified, string memory error)
    {
        
        bytes32 lockID = calculateLockID(delegate, token);

        
        require(_lockSet.contains(lockID), ""UniversalVault: missing lock"");

        
        if (delegate.isContract()) {
            
            require(gasleft() >= RAGEQUIT_GAS, ""UniversalVault: insufficient gas"");

            
            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {
                notified = true;
            } catch Error(string memory res) {
                notified = false;
                error = res;
            } catch (bytes memory) {
                notified = false;
            }
        }

        
        assert(_lockSet.remove(lockID));
        delete _locks[lockID];

        
        emit RageQuit(delegate, token, notified, error);
    }

    function setURI(string memory _uri) public onlyOwner {
      uri = _uri;
    }


    
    function transferERC20(
        address token,
        address to,
        uint256 amount
    ) external override onlyOwner {
        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    
    
    
    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {
      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;
    }


    
    function delegatedTransferERC20(
        address token,
        address to,
        uint256 amount
    ) external {
        if(msg.sender != _getOwner()) {

        require( 
            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,
            ""Account not approved to transfer amount""); 
        } 

        
        require(
            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),
            ""UniversalVault: insufficient balance""
        );
        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);
        
        
        TransferHelper.safeTransfer(token, to, amount);
    }

    
    function transferETH(address to, uint256 amount) external payable override onlyOwner {
      
      TransferHelper.safeTransferETH(to, amount);
    }


    function approveTransferERC721(
      address delegate, 
      address nftContract, 
      uint256 tokenId
    ) external onlyOwner {
      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;
    }


    function transferERC721(
        address to,
        address nftContract,
        uint256 tokenId
    ) external {
        if(msg.sender != _getOwner()) {
          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], ""NFT not approved for transfer""); 
        } 

        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {
          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {
              require(
                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, 
                ""NFT locked and not expired""
              );
              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, ""NFT locked and must be withdrawn by timelock recipient"");
          }
        }

        _removeNft(nftContract, tokenId);
        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);
    }

    
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {
      _addNft(msg.sender, tokenId);
      return IERC721Receiver.onERC721Received.selector;
    }


    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );
 
      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 

      require(
        timelockERC721s[key].expires == 0,
        ""TimelockERC721 already exists""
      );
     
      timelockERC721s[key] = TimelockERC721({
          recipient: recipient,
          nftContract: nftContract,
          tokenId: tokenId,
          expires: expires
      });

      timelockERC721Keys[nftContract].push(key);

      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);
      emit TimeLockERC20(recipient, nftContract, tokenId, expires);
    }


    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {

      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); 
      require(
        timelockERC721s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC721s[key].recipient, ""Not recipient"");

      _removeNft(nftContract, tokenId);
      delete timelockERC721s[key];

      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);
      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);
    }

    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {

      require(
        IERC20(token).allowance(msg.sender, address(this)) >= amount, 
        ""Amount not approved""
      );

      require(
        expires > block.timestamp, 
        ""Expires must be in future""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 

      require(
        timelockERC20s[key].expires == 0,
        ""TimelockERC20 already exists""
      );
    
      timelockERC20s[key] = TimelockERC20({
          recipient: recipient,
          token: token,
          amount: amount,
          expires: expires
      });
      timelockERC20Keys[token].push(key);
      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);
      IERC20(token).transferFrom(msg.sender, address(this), amount);
      emit TimeLockERC20(recipient, token, amount, expires);
    }

    
    
    
    
    
    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {

      require(
        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),
        ""Insufficient balance""
      );

      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); 
      require(
        timelockERC20s[key].expires <= block.timestamp,
        ""Not expired yet""
      );

      require(msg.sender == timelockERC20s[key].recipient, ""Not recipient"");
      
      delete timelockERC20s[key];

      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);
      TransferHelper.safeTransfer(token, recipient, amount);
      emit TimeUnlockERC20(recipient, token, amount, expires);
    }

}",3800,4,3,"{
  ""Findings"": [
    {
      ""Issue"": ""Missing `onlyOwner` Modifier on Critical Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `approveTransferERC20`, `approveTransferERC721`, `timeLockERC20`, and `timeLockERC721` lack the `onlyOwner` modifier, allowing unauthorized users to approve transfers and lock tokens/NFTs."",
      ""Impact"": ""This could lead to unauthorized token and NFT transfers, unauthorized locking, and potential loss of funds or assets."",
      ""Location"": ""Functions `approveTransferERC20` (line 317), `approveTransferERC721` (line 363), `timeLockERC20` (line 442), and `timeLockERC721` (line 419)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it highlights critical security issues regarding access control and ownership.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Functions such as `transferERC721`, `rageQuit`, and `unlock` make external calls without proper reentrancy protection, which could be exploited by malicious contracts."",
      ""Impact"": ""This vulnerability could lead to unauthorized transfers, manipulation of contract state, or funds loss."",
      ""Location"": ""Functions `transferERC721` (line 356), `rageQuit` (line 294), and `unlock` (line 261)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding is relevant as it addresses a common vulnerability in smart contracts associated with external calls.""
    },
    {
      ""Issue"": ""Potential Unauthorized Access in Delegated Transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `delegatedTransferERC20` function allows transfers based on approvals but does not ensure that approvals are revoked after use, leading to potential repeated unauthorized transfers."",
      ""Impact"": ""This could allow unauthorized users to exploit the approval mechanism, leading to fund loss."",
      ""Location"": ""Function `delegatedTransferERC20` (line 335)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it points out a need for proper management of approvals.""
    },
    {
      ""Issue"": ""Insufficient Error Handling for External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions such as `transferERC20`, `delegatedTransferERC20`, `timeUnlockERC20`, `timeLockERC721`, and `timeUnlockERC721` lack proper error handling for external calls, risking silent failures."",
      ""Impact"": ""Failure to handle errors could lead to failed transfers or unintended consequences, potentially causing fund loss."",
      ""Location"": ""Functions `transferERC20` (line 288), `delegatedTransferERC20` (lines 311-318), `timeUnlockERC20` (lines 480-487), `timeLockERC721` (line 429), `timeUnlockERC721` (line 463)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it addresses error handling in external calls, crucial for contract integrity.""
    },
    {
      ""Issue"": ""Gas Inefficiency in NFT and Balance Checks"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions `_removeNft`, `getNftIdByTokenIdAndAddr`, and `checkBalances` utilize loops for searching and removal, which can be gas-inefficient."",
      ""Impact"": ""Increased gas costs during NFT management operations, especially with large arrays."",
      ""Location"": ""Functions `_removeNft` (lines 110-121), `getNftIdByTokenIdAndAddr` (lines 184-192), `checkBalances` (lines 160-169)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it identifies gas optimization opportunities in the contract.""
    },
    {
      ""Issue"": ""Inadequate Timelock and Nonce Management"",
      ""Severity"": ""High"",
      ""Description"": ""Functions `transferERC721`, `timeUnlockERC20`, and nonce management in `lock` and `unlock` functions lack sufficient checks, allowing potential bypass of timelocks and replay attacks."",
      ""Impact"": ""This could allow unauthorized access to tokens and increase the risk of replay attacks."",
      ""Location"": ""Functions `transferERC721` (line 265), `timeUnlockERC20` (line 413), `lock` (line 302), `unlock` (line 332)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it addresses the necessity for strict timelock enforcement and nonce management.""
    },
    {
      ""Issue"": ""Inconsistent Event Emission"",
      ""Severity"": ""Low"",
      ""Description"": ""The `timeLockERC721` function emits `TimeLockERC20`, which is a likely error in event naming."",
      ""Impact"": ""This can cause confusion in event tracking related to ERC721 operations."",
      ""Location"": ""Function `timeLockERC721` (line 573)"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding is relevant as it highlights a need for consistency in event emissions.""
    }
  ],
  ""FindingNumber"": 7,
  ""AllRelevance"": 33,
  ""RelevanceCount"": 33,
  ""AllValidation"": 33,
  ""ValidationCount"": 33
}","[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault
Report Description: The issue involves a scenario where an NFT token becomes permanently stuck in the vault if it’s transferred back without unlocking it first. The problem arises because the transferERC721() function does not properly handle the deletion of the timelockERC721s entry when transferring the NFT out of the vault. This results in the contract assuming an old timelock state when the NFT is later deposited back, leading to failure during transfers or unlocks.
Match in Response List: Matches with the issue titled ""Inadequate Timelock and Nonce Management"".
Validation: Partially Correct. The response addresses timelock management, but it focuses more on nonce management and general timelock bypass concerns. While the response’s mention of ""lack of sufficient checks"" may apply to broader timelock scenarios, it does not specifically address the issue of the missing deletion of timelockERC721s, which is the core of the problem in {H-01}. Therefore, this response only partially aligns with the issue.
Suggestions:
The response should have specifically mentioned the missing deletion of timelockERC721s and how this could lead to an invalid timelock state when the same NFT is re-deposited.

[H-02] NFT transfer approvals are not removed and cannot be revoked, thus leading to loss of NFT tokens
Report Description: The report highlights that NFT transfer approvals are set to true in the approveTransferERC721() function but are never set to false, and there is no mechanism to revoke or remove these approvals. This could lead to unauthorized transfers or loss of tokens.
Match in Response List: Matches with the issue titled ""Potential Unauthorized Access in Delegated Transfers"".
Validation: Correct. The response correctly identifies that approvals are not managed properly, specifically within the delegatedTransferERC20 function. It highlights the potential for repeated unauthorized transfers because the approvals are not revoked after being used, which could lead to loss of NFTs or tokens, which is a valid concern for {H-02}.
Suggestions:
The response should have clarified that the same issue applies to NFTs in {H-02} and not just ERC20 tokens. A suggestion to add functionality for revoking approvals after use would strengthen the response.

[H-03] Approval for NFT transfers is not removed after transfer
Report Description: The report notes that Visor.transferERC721() does not reset NFT approvals after a transfer, allowing the same delegate to potentially steal the NFT in subsequent transfers.
Match in Response List: Matches with the issue titled ""Potential Unauthorized Access in Delegated Transfers"".
Validation: Correct. The response addresses the issue of improperly handled approvals in delegated transfers, which directly corresponds to {H-03}'s concern about NFTs being transferred without resetting approvals, allowing them to be moved out of the contract again.
Suggestions:
No further suggestions are necessary, as the response is sufficient in addressing the core issue of approval management for NFT transfers.

[H-04] Unbounded loop in _removeNft could lead to a griefing/DOS attack
Report Description: This issue arises from the _removeNft function, which uses an unbounded loop to iterate through the nfts array. A malicious actor could exploit this by sending many NFTs to the vault, causing excessive gas consumption during the NFT removal process, potentially resulting in transaction failures.
Match in Response List: Matches with the issue titled ""Gas Inefficiency in NFT and Balance Checks"".
Validation: Correct. The response addresses gas inefficiency, highlighting the issue with unbounded loops in functions like _removeNft. This aligns well with {H-04}, which describes a similar vulnerability, and emphasizes the potential for griefing attacks.
Suggestions:
The response could also have explicitly suggested using a more efficient data structure, such as a mapping, as recommended in the issue report.

[M-01] Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients
Report Description: The report highlights the risk of failing to check the return value of transferFrom in timeLockERC20(). ERC20 tokens may return false instead of reverting on failure, and failing to handle this can lead to incorrect assumptions about token transfers and result in the loss of funds.
Match in Response List: Matches with the issue titled ""Insufficient Error Handling for External Calls"".
Validation: Correct. The response addresses the issue of unhandled external call errors and explicitly mentions the lack of proper error handling in functions such as timeLockERC20, aligning with {M-01}. This is a valid concern, as failure to handle errors from external token transfers can result in failed transactions and inconsistent contract states.
Suggestions:
No further suggestions are needed, as the response appropriately highlights the issue.

[M-02] transferERC721 doesn't clean timelockERC721s
Report Description: The issue describes that the transferERC721 function does not clean the timelockERC721s mapping, which could lead to stale data and failures when re-depositing NFTs into the vault.
Match in Response List: Matches with the issue titled ""Insufficient Error Handling for External Calls"".
Validation: Partially Correct. While the response correctly highlights the importance of error handling, it does not specifically address the problem of cleaning the timelockERC721s mapping after an NFT transfer. This is a crucial detail that the response overlooks.
Suggestions:
The response should have been more specific about the failure to delete timelockERC721s in transferERC721, which is directly responsible for the issue in {M-02}.

[M-03] timelockERC721Keys could exceed the block size limit
Report Description: The issue points out that looping through timelockERC721Keys in Visor.sol could potentially exceed the block size limit, which might cause transactions to fail.
Match in Response List: No match found.
Validation: No match found. The issue is not addressed in any of the responses provided. It is a separate concern related to potential gas inefficiencies when dealing with large arrays in Solidity.
Suggestions:
The response list should have addressed potential gas inefficiencies related to looping over large arrays and recommended the use of more gas-efficient structures or methods (e.g., mappings or breaking down the loop into smaller chunks).

GPT-Generated Potential Issues (May Be Incorrect)
[R-01] Missing onlyOwner Modifier on Critical Functions
Response Description: This issue suggests adding an onlyOwner modifier to critical functions like approveTransferERC20, approveTransferERC721, timeLockERC20, and timeLockERC721 to prevent unauthorized access and actions by non-owners.
Assessment: Valid Concern. While this issue was not explicitly mentioned in the original {issue} report, adding access control measures (like onlyOwner) is a fundamental security best practice. Unauthorized access to critical functions could lead to significant vulnerabilities, such as unauthorized transfers or locking of tokens/NFTs.
Suggestions:
The implementation of the onlyOwner modifier is essential for ensuring that only the contract owner can perform sensitive operations. This should be added to functions managing token approvals, transfers, and timelocks.

Summary of Matches and Gaps
Correct Matches:
[H-02] NFT transfer approvals are not removed and cannot be revoked: Addressed by ""Potential Unauthorized Access in Delegated Transfers"".
[H-03] Approval for NFT transfers is not removed after transfer: Addressed by ""Potential Unauthorized Access in Delegated Transfers"".
[H-04] Unbounded loop in _removeNft could lead to a griefing/DOS attack: Addressed by ""Gas Inefficiency in NFT and Balance Checks"".
[M-01] Unhandled return value of transferFrom in timeLockERC20(): Addressed by ""Insufficient Error Handling for External Calls"".
Partially Correct Matches:
[H-01] A previously timelocked NFT token becomes permanently stuck in vault: Partially addressed by ""Inadequate Timelock and Nonce Management"".
[M-02] transferERC721 doesn't clean timelockERC721s: Partially addressed by ""Insufficient Error Handling for External Calls"".
Missed Issues from Issue Report:
[M-03] timelockERC721Keys could exceed the block size limit: Not addressed in the response list.
GPT-Generated Potential Issues (May Be Incorrect):
[R-01] Missing onlyOwner Modifier on Critical Functions: A valid suggestion to improve access control.",2,0,5,7,33,"### **Summary of Matches and Gaps**

---

#### **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**

**Report Description**:  
The `transferERC721()` function in the vault does not delete the `timelockERC721s[key]` entry for an NFT token ID after transferring it out of the vault. If the same NFT is later moved back into the vault without a timelock, the vault logic still considers it timelocked with the older/stale recipient address. This causes the `transferERC721()` call to fail unless the caller controls the stale recipient address, effectively locking the NFT in the vault.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The problem involves improper cleanup of timelock data in `transferERC721()`, which is not covered in the response list.

---

#### **[H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens**

**Report Description**:  
NFT transfer approvals set in `approveTransferERC721()` are never revoked or set to false. This allows a compromised delegate to repeatedly transfer the NFT if it is moved back into the vault. Additionally, there is no mechanism to revoke approvals, leading to potential loss of NFTs if a delegate becomes untrustworthy.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unrevoked NFT transfer approvals. This is a critical oversight in the contract's approval management.

---

#### **[H-03] Approval for NFT transfers is not removed after transfer**

**Report Description**:  
The `Visor.transferERC721` function does not reset the approval for the NFT after a transfer. This allows a previously approved delegate to steal the NFT if it is deposited back into the vault, even after ownership has changed.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unreset NFT transfer approvals. This is a significant security gap in the contract's approval handling.

---

#### **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**

**Report Description**:  
The `_removeNft` function uses an unbounded loop to search for and remove an NFT from the `nfts` array. A malicious user could exploit this by sending many NFTs to the vault, causing excessive gas consumption or transaction reverts when other users attempt to unlock or transfer NFTs. This could lead to a denial-of-service (DOS) attack.

**Match in Response List**:  
Matches with the issue titled **""Gas Inefficiency in NFT and Balance Checks""**.

**Validation**:  
**Correct**. The response identifies the gas inefficiency of the `_removeNft` function but does not fully address the potential for a griefing/DOS attack. The response focuses on gas optimization rather than the security implications of the unbounded loop.

---

#### **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients**

**Report Description**:  
The `timeLockERC20()` function does not handle the return value of the `transferFrom` call. Some ERC20 tokens may return `false` on failure instead of reverting. This could lead to discrepancies in the vault's token accounting, causing subsequent `timeUnlockERC20()`, `transferERC20()`, or `delegatedTransferERC20()` calls to fail.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Error Handling for External Calls""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of insufficient error handling for external calls, which aligns with the problem of unhandled return values in `timeLockERC20()`.

---

#### **[M-02] `transferERC721` doesn't clean `timelockERC721s`**

**Report Description**:  
The `transferERC721` function does not clean the `timelockERC721s` mapping after transferring a timelocked NFT. This could lead to stale timelock keys being used later, incorrect administration of available NFTs, and unnecessary gas consumption.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves improper cleanup of timelock data in `transferERC721()`, which is not covered in the response list.

---

#### **[M-03] `timelockERC721Keys` could exceed the block size limit**

**Report Description**:  
The loop in `Visor.sol` (line 504) iterates through `timelockERC721Keys`, which could exceed the block size limit if the array grows too large. This could cause transactions to fail due to excessive gas consumption.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem involves potential gas inefficiency and block size limitations, which are not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Unhandled return value of `transferFrom` in `timeLockERC20()` could lead to fund loss for recipients** - **[H-04] Unbounded loop in `_removeNft` could lead to a griefing/DOS attack**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] A previously timelocked NFT token becomes permanently stuck in vault if it’s ever moved back into the vault**
- **[H-02] NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens**
- **[H-03] Approval for NFT transfers is not removed after transfer**
- **[M-02] `transferERC721` doesn't clean `timelockERC721s`**
- **[M-03] `timelockERC721Keys` could exceed the block size limit**

---

### **Conclusion**

The response list partially addresses some issues but misses several critical vulnerabilities, particularly those related to NFT timelock management, approval handling, and gas inefficiency. The response list should be expanded to cover these gaps to ensure comprehensive security coverage.","```
1. Insufficient Error Handling for External Calls 2. Gas Inefficiency in NFT and Balance Checks
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Insufficient Error Handling for External Calls** appears at rank 4.
   - **Gas Inefficiency in NFT and Balance Checks** appears at rank 5.

2. **Calculate the precision at each rank where a true positive appears**:
   - **Precision at rank 4 (P@4)**: Number of true positives up to rank 4 is 1. So, \( P@4 = \frac{1}{4} = 0.25 \).
   - **Precision at rank 5 (P@5)**: Number of true positives up to rank 5 is 2. So, \( P@5 = \frac{2}{5} = 0.4 \).

3. **Average the precision values**:
   - \( AP = \frac{P@4 + P@5}{2} = \frac{0.25 + 0.4}{2} = 0.325 \).

**Output**:
```
0.325
```"
