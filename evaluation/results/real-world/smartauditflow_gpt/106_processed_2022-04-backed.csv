nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Detecting aspects,matchList,MAP
NFTLoanFacilitator.sol,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    // ==== constants ====

    /** 
     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     
     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%
     */
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    /// See {INFTLoanFacilitator-SCALAR}.
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    // ==== state variables ====

    /// See {INFTLoanFacilitator-originationFeeRate}.
    /// @dev starts at 1%
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    /// See {INFTLoanFacilitator-requiredImprovementRate}.
    /// @dev starts at 10%
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    /// See {INFTLoanFacilitator-lendTicketContract}.
    address public override lendTicketContract;

    /// See {INFTLoanFacilitator-borrowTicketContract}.
    address public override borrowTicketContract;

    /// See {INFTLoanFacilitator-loanInfo}.
    mapping(uint256 => Loan) public loanInfo;

    /// @dev tracks loan count
    uint256 private _nonce = 1;

    
    // ==== modifiers ====

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    // ==== constructor ====

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    // ==== state changing external functions ====

    /// See {INFTLoanFacilitator-createLoan}.
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    /// See {INFTLoanFacilitator-closeLoan}.
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-lend}.
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            // will underflow if amount < previousAmount
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    /// See {INFTLoanFacilitator-repayAndCloseLoan}.
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    /// See {INFTLoanFacilitator-seizeCollateral}.
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    // === owner state changing ===

    /**
     * @notice Sets lendTicketContract to _contract
     * @dev cannot be set if lendTicketContract is already set
     */
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    /**
     * @notice Sets borrowTicketContract to _contract
     * @dev cannot be set if borrowTicketContract is already set
     */
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    /**
     * @notice Updates originationFeeRate the faciliator keeps of each loan amount
     * @dev Cannot be set higher than 5%
     */
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    /**
     * @notice updates the percent improvement required of at least one loan term when buying out lender 
     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount
     * must be 10% higher or interest rate must be 10% lower. 
     * @dev Cannot be 0.
     */
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    // ==== external view ====

    /// See {INFTLoanFacilitator-loanInfoStruct}.
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    /// See {INFTLoanFacilitator-totalOwed}.
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-interestOwed}.
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    /// See {INFTLoanFacilitator-loanEndSeconds}.
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    // === private ===

    /// @dev Returns the total interest owed on loan
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 // SCALAR * 1e18
            + accumulatedInterest;
    }
}",3357,388,"[H-01] Can force borrower to pay huge interest
In the function `lend()`, the loan amount is used as a min loan amount. It can be matched as high as possible (realistically up to the collateral NFT's worth to remain in profit) and the borrower has to pay interest on the entire amount instead of just on the desired loan amount when the loan was created.
  [H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout
If an attacker already calls `lend()` to lend to a loan, the attacker can manipulate `loanInfo` by reentrancy attack when any lenders try to buyout. The attacker can set bad values of lendInfo (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.

[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy
If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.  [M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it
If an attacker (lender) lends to a loan, the attacker can always revert transactions when any lenders try to buyout, making anyone can not buyout the loan of the attacker.   [M-02] Protocol doesn't handle fee on transfer tokens
Since the borrower is able to specify any asset token, it is possible that loans will be created with tokens that support fee on transfer. If a fee on transfer asset token is chosen, the protocol will contain a point of failure on the original `lend()` call.

[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen
The `sendCollateralTo` will receive the collateral NFT when `closeLoan()` is called. However, if `sendCollateralTo` is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract.   [M-04] `requiredImprovementRate` can not work as expected when `previousInterestRate` less than 10 due to precision loss   [M-05] Borrowers lose funds if they call `repayAndCloseLoan` instead of `closeLoan`
The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan (matched with `lend`). Users should use closeLoan in this case but the contract should disallow calling `repayAndCloseLoan` because users can lose funds.
It performs a `ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount)` call where interest will be a high value accumulated from timestamp 0 and the loan.loanAmount is the initially desired min loan amount `minLoanAmount` set in `createLoan`. The user will lose these funds if they ever approved the contract (for example, for another loan).

[M-06] Might not get desired min loan amount if _originationFeeRate changes
Admins can update the origination fee by calling `updateOriginationFeeRate`. Note that a borrower does not receive their `minLoanAmount` set in createLoan, they only receive `(1 - originationFee) * minLoanAmount`, see lend. Therefore, they need to precalculate the `minLoanAmount` using the `current` origination fee to arrive at the post-fee amount that they actually receive. If admins then increase the fee, the borrower receives fewer funds than required to cover their rent and might become homeless.
  [M-07] `mintBorrowTicketTo` can be a contract with no `onERC721Received` method, which may cause the `BorrowTicket NFT` to be frozen and put users' funds at risk
“IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);”",10,"pragma solidity 0.8.12;

import {IERC721} from ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import {SafeTransferLib, ERC20} from ""@rari-capital/solmate/src/utils/SafeTransferLib.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";

import {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';
import {IERC721Mintable} from './interfaces/IERC721Mintable.sol';
import {ILendTicket} from './interfaces/ILendTicket.sol';

contract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {
    using SafeTransferLib for ERC20;

    

    
    uint8 public constant override INTEREST_RATE_DECIMALS = 3;

    
    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;

    
    

    
    
    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);

    
    
    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);

    
    address public override lendTicketContract;

    
    address public override borrowTicketContract;

    
    mapping(uint256 => Loan) public loanInfo;

    
    uint256 private _nonce = 1;

    
    

    modifier notClosed(uint256 loanId) { 
        require(!loanInfo[loanId].closed, ""NFTLoanFacilitator: loan closed"");
        _; 
    }


    

    constructor(address _manager) {
        transferOwnership(_manager);
    }

    
    

    
    function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

    
    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }

    
    function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

    
    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }

    
    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, 
        ""NFTLoanFacilitator: lend ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,
        ""NFTLoanFacilitator: payment is not late"");

        loan.closed = true;
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            sendCollateralTo,
            loan.collateralTokenId
        );

        emit SeizeCollateral(loanId);
        emit Close(loanId);
    }

    
    

    
    function setLendTicketContract(address _contract) external onlyOwner {
        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');

        lendTicketContract = _contract;
    }

    
    function setBorrowTicketContract(address _contract) external onlyOwner {
        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');

        borrowTicketContract = _contract;
    }

    
    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {
        ERC20(asset).safeTransfer(to, amount);

        emit WithdrawOriginationFees(asset, amount, to);
    }

    
    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }

    
    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {
        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');

        requiredImprovementRate = _improvementRate;

        emit UpdateRequiredImprovementRate(_improvementRate);
    }

    
    

    
    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {
        return loanInfo[loanId];
    }

    
    function totalOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return loanInfo[loanId].loanAmount + _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    
    function interestOwed(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;

        return _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
    }

    
    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {
        Loan storage loan = loanInfo[loanId];
        return loan.durationSeconds + loan.lastAccumulatedTimestamp;
    }

    
    

    
    function _interestOwed(
        uint256 loanAmount,
        uint256 lastAccumulatedTimestamp,
        uint256 perAnumInterestRate,
        uint256 accumulatedInterest
    ) 
        internal 
        view 
        returns (uint256) 
    {
        return loanAmount
            * (block.timestamp - lastAccumulatedTimestamp)
            * (perAnumInterestRate * 1e18 / 365 days)
            / 1e21 
            + accumulatedInterest;
    }
}",2789,3,7,"{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerabilities in Critical Functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""Functions such as `lend`, `repayAndCloseLoan`, and `seizeCollateral` are vulnerable to reentrancy attacks due to external token transfers occurring before state updates. This includes potential recursive calls that could manipulate contract state or drain funds."",
      ""Impact"": ""Reentrancy attacks could result in unauthorized access, manipulation of loan terms, or financial losses due to repeated withdrawals."",
      ""Location"": ""Functions `lend`, `repayAndCloseLoan`, `seizeCollateral`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Reentrancy is a well-known vulnerability in smart contract security and addressing it is crucial to prevent significant financial losses.""
    },
    {
      ""Issue"": ""Unchecked External Calls in ERC20 and ERC721 Transfers"",
      ""Severity"": ""High"",
      ""Description"": ""The contract makes external calls to `ERC20.safeTransferFrom`, `ERC20.safeTransfer`, and `IERC721.transferFrom` without adequate checks for success. This could result in silent failures, especially with non-standard token implementations."",
      ""Impact"": ""Potential loss of funds or incorrect balances if transfers fail but go unnoticed, leading to inconsistent contract state."",
      ""Location"": ""Functions `lend`, `repayAndCloseLoan`, `createLoan`, `closeLoan`, `seizeCollateral`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring successful execution of external calls is essential to maintain contract integrity and prevent unexpected behavior.""
    },
    {
      ""Issue"": ""Lack of Input Validation on Critical Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions such as `createLoan` and `lend` do not adequately validate input parameters like `interestRate`, `loanAmount`, and contract addresses, potentially allowing invalid or malicious inputs."",
      ""Impact"": ""Invalid inputs could lead to contract malfunctions or exploitation, affecting the financial terms or leading to unexpected errors."",
      ""Location"": ""Functions `createLoan`, `lend`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Proper input validation is crucial for preventing misuse and ensuring logical correctness of contract operations.""
    },
    {
      ""Issue"": ""Unchecked Arithmetic Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses unchecked arithmetic operations for calculations like `amountIncrease` and `facilitatorTake`, which could lead to overflows or underflows if not carefully controlled."",
      ""Impact"": ""Arithmetic errors could result in incorrect calculations, leading to financial discrepancies or logical errors."",
      ""Location"": ""Functions `lend`, `createLoan`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Although Solidity 0.8+ has built-in overflow checks, explicit handling is advisable for clarity and safety, especially in future code modifications.""
    },
    {
      ""Issue"": ""Lack of Validation and Access Control on Contract Setup"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions for setting critical contract parameters, like `setLendTicketContract` and `setBorrowTicketContract`, lack validation to ensure correct contract addresses and do not employ robust access controls."",
      ""Impact"": ""Incorrect setup could result in malfunctioning minting processes or unauthorized modifications, impacting the platform's operations."",
      ""Location"": ""Functions `setLendTicketContract`, `setBorrowTicketContract`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Proper validation and access control are necessary to ensure the secure and correct setup of contract parameters.""
    },
    {
      ""Issue"": ""Potential Integer Overflow in Interest Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_interestOwed` function performs arithmetic operations that could potentially overflow with large values of `loanAmount` or `perAnumInterestRate`."",
      ""Impact"": ""Overflow in interest calculations could lead to incorrect repayment amounts, resulting in financial discrepancies."",
      ""Location"": ""Function `_interestOwed`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Ensuring safe arithmetic operations is crucial for maintaining accurate financial calculations in smart contracts.""
    },
    {
      ""Issue"": ""Lack of Reentrancy Guard"",
      ""Severity"": ""Medium"",
      ""Description"": ""Certain functions that handle asset transfers and state updates do not use any form of reentrancy guard, risking potential attacks."",
      ""Impact"": ""Without reentrancy protection, attackers could exploit functions to perform unauthorized operations before state changes are committed."",
      ""Location"": ""Functions `lend`, `repayAndCloseLoan`, `seizeCollateral`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Implementing reentrancy guards is a common best practice to protect against such vulnerabilities.""
    },
    {
      ""Issue"": ""Lack of Access Control on Loan Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions like `createLoan` and `lend` allow any address to modify or create loans, potentially leading to unauthorized access and manipulation of loan terms."",
      ""Impact"": ""Unauthorized users could create loans with arbitrary parameters, leading to financial exploitation or system manipulation."",
      ""Location"": ""Functions `createLoan`, `lend`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The absence of access control mechanisms exposes the system to potential misuse, which is a significant security concern.""
    }
  ],
  ""FindingNumber"": 8,
  ""AllRelevance"": 70,
  ""RelevanceCount"": 70,
  ""AllValidation"": 70,
  ""ValidationCount"": 70
}","### **Comparison and Evaluation**

---

#### **[H-01] Can force borrower to pay huge interest**

**Report Description**:  
In the `lend()` function, the loan amount is used as a minimum loan amount. It can be matched as high as possible (up to the collateral NFT's worth), forcing the borrower to pay interest on the entire amount instead of just the desired loan amount. This could lead to financial exploitation.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While it covers reentrancy and unchecked external calls, it does not mention the manipulation of loan amounts or the financial impact on borrowers.

---

#### **[H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout**

**Report Description**:  
If an attacker calls `lend()` to lend to a loan, they can manipulate `loanInfo` via a reentrancy attack when lenders attempt to buyout. The attacker can set unfavorable terms (e.g., very long duration, 0 interest rate), which the lender does not expect.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerabilities in Critical Functions""**.

**Validation**:  
**Correct**. The response accurately identifies reentrancy vulnerabilities in critical functions like `lend`, which aligns with the described issue. It correctly highlights the risks of state manipulation and unauthorized access.

---

#### **[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy**

**Report Description**:  
If a borrower lends to their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. This allows the borrower to keep the NFT, loan amount, and accrued interest.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerabilities in Critical Functions""**.

**Validation**:  
**Correct**. The response correctly identifies reentrancy vulnerabilities in functions like `repayAndCloseLoan`, which aligns with the described issue. It highlights the risks of unauthorized fund retention and state manipulation.

---

#### **[M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it**

**Report Description**:  
If an attacker lends to a loan, they can always revert transactions when lenders attempt to buyout, preventing anyone from buying out the loan.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While it covers reentrancy and access control, it does not mention the potential for DoS attacks via transaction reverts.

---

#### **[M-02] Protocol doesn't handle fee on transfer tokens**

**Report Description**:  
The borrower can specify any asset token, including those that support fee on transfer. If such a token is chosen, the protocol may fail during the `lend()` call due to unexpected token behavior.

**Match in Response List**:  
Matches with the issue titled **""Unchecked External Calls in ERC20 and ERC721 Transfers""**.

**Validation**:  
**Correct**. The response identifies unchecked external calls but does not specifically address fee-on-transfer tokens. While related, the response misses the critical detail of handling non-standard token behavior.

---

#### **[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen**

**Report Description**:  
The `sendCollateralTo` address receives the collateral NFT when `closeLoan()` is called. If it is a contract address that does not support ERC721, the NFT can be frozen.

**Match in Response List**:  
Matches with the issue titled **""Unchecked External Calls in ERC20 and ERC721 Transfers""**.

**Validation**:  
**Correct**. The response accurately identifies the risks of unchecked external calls, including the potential for NFTs to be frozen in non-compliant contracts.

---

#### **[M-04] requiredImprovementRate can not work as expected when previousInterestRate less than 10 due to precision loss**

**Report Description**:  
The `requiredImprovementRate` may not function as expected when `previousInterestRate` is less than 10 due to precision loss in calculations.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While it covers arithmetic operations, it does not mention precision loss in interest rate calculations.

---

#### **[M-05] Borrowers lose funds if they call repayAndCloseLoan instead of closeLoan**

**Report Description**:  
The `repayAndCloseLoan` function does not revert if there has not been a lender for a loan. Users should use `closeLoan` in this case, but the contract does not enforce this, leading to potential fund loss.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerabilities in Critical Functions""**.

**Validation**:  
**Partially Correct**. The response identifies reentrancy vulnerabilities but does not specifically address the misuse of `repayAndCloseLoan` and its financial impact on borrowers.

---

#### **[M-06] Might not get desired min loan amount if _originationFeeRate changes**

**Report Description**:  
Admins can update the origination fee, which affects the borrower's received amount. If the fee increases after loan creation, the borrower may receive fewer funds than required.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While it covers input validation, it does not mention the impact of fee changes on loan amounts.

---

#### **[M-07] mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen**

**Report Description**:  
The `mintBorrowTicketTo` address may be a contract that does not support ERC721, causing the BorrowTicket NFT to be frozen and putting users' funds at risk.

**Match in Response List**:  
Matches with the issue titled **""Unchecked External Calls in ERC20 and ERC721 Transfers""**.

**Validation**:  
**Correct**. The response accurately identifies the risks of unchecked external calls, including the potential for NFTs to be frozen in non-compliant contracts.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] currentLoanOwner can manipulate loanInfo when any lenders try to buyout**
- **[H-03] Borrower can be their own lender and steal funds from buyout due to reentrancy** - **[M-02] Protocol doesn't handle fee on transfer tokens**
- **[M-03] sendCollateralTo is unchecked in closeLoan(), which can cause user's collateral NFT to be frozen** - **[M-05] Borrowers lose funds if they call repayAndCloseLoan instead of closeLoan**
- **[M-07] mintBorrowTicketTo can be a contract with no onERC721Received method, which may cause the BorrowTicket NFT to be frozen**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] Can force borrower to pay huge interest**
- **[M-01] When an attacker lends to a loan, the attacker can trigger DoS that any lenders can not buyout it**
- **[M-04] requiredImprovementRate can not work as expected when previousInterestRate less than 10 due to precision loss**
- **[M-06] Might not get desired min loan amount if _originationFeeRate changes**

--- 

The response list covers many critical issues but misses several specific vulnerabilities and risks. Addressing these gaps is essential for comprehensive security.",6,0,4,8,70,"```
1. Reentrancy Vulnerabilities in Critical Functions
2. Unchecked External Calls in ERC20 and ERC721 Transfers
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Reentrancy Vulnerabilities in Critical Functions"" appears at rank 1.
   - ""Unchecked External Calls in ERC20 and ERC721 Transfers"" appears at rank 2.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - At rank 2: \( P@2 = \frac{2}{2} = 1.0 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 1.0}{2} = 1.0 \)

**Output**:
```
1.0
```"
