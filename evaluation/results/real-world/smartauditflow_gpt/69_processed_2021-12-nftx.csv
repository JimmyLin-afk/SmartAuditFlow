nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,Comparison,Match,Partially,Not Match,Genes,Task,matchList,MAP
NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",5808.0,615.0,"[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets
In the NFTXMarketplaceZap.sol contract, the `buyAndSwap1155WETH` function uses the WETH provided by the user to exchange VaultToken, but when executing the `_buyVaultToken` method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail

[H-03] A vault can be locked from MarketplaceZap and StakingZap
Any user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.
Every operation performed by the marketplace, that deals with vToken minting, performs this check:
“require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance”);""
A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace

[M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer.

[M-03] NFTXMarketplaceZap.sol#buyAndSwap721WETH() should return unused weth/eth back to `msg.sender` instead of `to`
function `buyAndSwap721WETH`[M-04] NFTXStakingZap and NFTXMarketplaceZap transferFromERC721 transfer Cryptokitties to the wrong address
`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).

[M-12] `buyAndSwap1155WETH` Does Not Work As Intended
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.",6.0,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",4873.0,2.0,4.0,"{'task_list': [{'Area': 'Security Vulnerabilities', 'Tasks': ['Check for potential reentrancy vulnerabilities in functions with external calls, despite the use of ReentrancyGuard.', ""Verify proper access control and ensure that sensitive functions are protected with 'onlyOwner' or other suitable modifiers."", 'Examine external calls to ensure they are performed safely and handle any failures gracefully.', 'Ensure that all arithmetic operations are safe from overflows/underflows given Solidity 0.8+ protections.']}, {'Area': 'Compliance', 'Tasks': ['Review contract compliance with ERC721 and ERC1155 standards for NFT operations.', 'Validate the use of interfaces (INFTXVault, IUniswapV2Router01) for correct and expected behavior.']}, {'Area': 'Complex Logic/Algorithms', 'Tasks': ['Conduct a detailed walkthrough of the minting and swapping logic to ensure it functions as intended and handles edge cases.', 'Verify that the fee calculation logic (mint, swap, redeem fees) is correctly implemented and consistent with the design specifications.']}, {'Area': 'External Interactions', 'Tasks': ['Review interactions with external contracts (e.g., NFTX Vaults, SushiRouter) to ensure correct handling of returns and errors.', 'Ensure that proper approvals are handled correctly for ERC20, ERC721, and ERC1155 tokens.']}, {'Area': 'Gas Optimization', 'Tasks': ['Identify potential gas inefficiencies, especially in loops and batch processing, and suggest optimizations.', 'Review the usage of immutable and constant variables for gas savings.']}, {'Area': 'Liquidity Pools & AMM Risks', 'Tasks': ['Analyze the use of SushiRouter for token swaps to ensure it is resistant to manipulation and impermanent loss risks.', 'Check for mechanisms that handle potential slippage and price impact in swaps.']}, {'Area': 'Flash Loan Protection', 'Tasks': [""Assess the contract's vulnerability to flash loan attacks and suggest protective measures if necessary.""]}, {'Area': 'Transaction Ordering & Front-running', 'Tasks': ['Evaluate the possibility of front-running attacks during swap operations and propose mitigation strategies, such as commit-reveal schemes.']}, {'Area': 'Fallback/Emergency Stops', 'Tasks': ['Ensure that emergency stop or pause mechanisms are implemented and can be triggered by authorized parties.']}]}",,"{'Findings': [{'Issue': 'Reentrancy Vulnerability', 'Severity': 'High', 'Description': 'Multiple functions, including `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, and others, involve external calls that could be exploited through reentrancy attacks, despite using a nonReentrant modifier. These vulnerabilities are particularly critical when these functions handle Ether transfers or interact with untrusted contracts.', 'Impact': 'An attacker could exploit these vulnerabilities to re-enter the contract during execution and manipulate its state, potentially draining funds or causing unauthorized state changes.', 'Location': 'Functions `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, among others handling ETH/WETH.'}, {'Issue': 'Unchecked External Call Results', 'Severity': 'Medium', 'Description': 'Several functions such as `transferFromERC721` and `approveERC721` make external calls without verifying the success of these calls, relying instead on the success flag. This may lead to silent failures and unexpected contract states.', 'Impact': 'Failed external calls without proper checks can result in inconsistent contract states and potential exploitation if assumptions about state are incorrect.', 'Location': 'Functions `transferFromERC721` and `approveERC721`.'}, {'Issue': 'Lack of Input Validation', 'Severity': 'Medium', 'Description': 'Functions like `mintAndSell721`, `buyAndSwap721`, and others do not adequately validate input parameters such as array lengths and address parameters. This can result in unexpected behaviors or operations with invalid inputs, such as zero addresses.', 'Impact': 'Could lead to unexpected contract behavior, loss of funds, or runtime errors.', 'Location': 'Functions `mintAndSell721`, `buyAndSwap721`, `mintAndSell1155`, etc.'}, {'Issue': 'Hardcoded Addresses', 'Severity': 'Low', 'Description': 'The contract uses hardcoded addresses for specific NFT contracts like CryptoKitties and CryptoPunks. This reduces flexibility and could lead to issues if these addresses change or if the contract is deployed on different networks.', 'Impact': ""Potential for errors or failure if these contracts are upgraded or deployed at new addresses, limiting the contract's adaptability."", 'Location': 'Functions `transferFromERC721` and `approveERC721`.'}, {'Issue': 'Lack of Event Emission for Critical Operations', 'Severity': 'Low', 'Description': 'Critical operations such as minting or swapping tokens do not emit events for all state changes. This lack of event emission reduces transparency and traceability.', 'Impact': 'Hinders monitoring and auditing of actions by external observers, reducing accountability and traceability of transactions.', 'Location': 'Functions `_mint721`, `_swap1155`, and `_redeem`.'}, {'Issue': 'Potential Integer Overflow/Underflow', 'Severity': 'Medium', 'Description': 'Some arithmetic operations are conducted without explicit overflow/underflow protection using SafeMath. Although Solidity 0.8+ has built-in overflow checks, explicit protections are recommended to ensure safety, especially if the code is migrated or used in a different context.', 'Impact': 'Could lead to incorrect arithmetic results and potential vulnerabilities if input values are unexpectedly large.', 'Location': 'Functions involving arithmetic such as `_mint721`, `_mint1155`, and fee calculations.'}], 'IssueNumber': 64, 'OutputList': 6}","---

### **[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets**

**Report Description**:  
The `buyAndSwap1155WETH` function in the `NFTXMarketplaceZap.sol` contract uses WETH provided by the user to exchange VaultToken. However, the `_buyVaultToken` method incorrectly uses `msg.value` instead of `maxWethIn`. Since `msg.value` is 0, the call will fail, leading to the function not working as intended and potentially causing user asset loss.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability""** in the response list.

**Validation**:  
**Incorrect**.  
The response in the `response_list` does not address the core issue described in the report. The issue is about the incorrect use of `msg.value` instead of `maxWethIn`, which causes the function to fail. The response instead discusses reentrancy vulnerabilities, which are unrelated to this specific issue. The response fails to identify the root cause or provide a solution for the described problem.

**Suggestions**:  
- The response should explicitly address the incorrect use of `msg.value` in the `_buyVaultToken` call and recommend using `maxWethIn` as intended.  
- It should also suggest adding tests to ensure the function behaves as expected when handling WETH and ETH inputs.

---

### **[H-03] A vault can be locked from MarketplaceZap and StakingZap**

**Report Description**:  
Any user owning a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone. This is due to the following check in operations involving vToken minting:  
`require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");`  
A malicious user could transfer any amount > 0 of a vault's vToken to the zap contracts, making the vault functionality unavailable for all users.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Incorrect**.  
The `response_list` does not address this issue. The described vulnerability is a denial-of-service (DoS) attack vector where a malicious user can lock vault functionality by transferring tokens to the zap contracts. None of the responses in the `response_list` discuss this specific issue or its impact.

**Suggestions**:  
- The response should identify the DoS vulnerability caused by the unchecked token transfer and recommend implementing a mechanism to prevent unauthorized or malicious token transfers to the zap contracts.  
- For example, the contract could include a whitelist of allowed token transfers or validate the source of incoming tokens.

---

### **[M-01] Missing non-reentrancy modifier**

**Report Description**:  
Certain functions are missing the `nonReentrant` modifier, even though other public/external functions in the contract use it. This inconsistency could expose the contract to reentrancy attacks.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability""** in the response list.

**Validation**:  
**Correct**.  
The response identifies reentrancy vulnerabilities in functions like `buyAndSwap721`, `buyAndSwap1155`, and others. However, it does not specifically address the inconsistency in applying the `nonReentrant` modifier across functions. The response also does not provide a detailed recommendation to ensure all vulnerable functions are protected.

**Suggestions**:  
- The response should explicitly list the functions missing the `nonReentrant` modifier and recommend adding it where necessary.  
- It should also suggest reviewing the contract for other potential reentrancy vulnerabilities and ensuring consistent use of the modifier.

---

### **[M-03] `NFTXMarketplaceZap.sol#buyAndSwap721WETH()` should return unused WETH/ETH back to `msg.sender` instead of `to`**

**Report Description**:  
The `buyAndSwap721WETH` function should return unused WETH/ETH to the `msg.sender` instead of the `to` address. Returning funds to the wrong address could lead to user funds being sent to unintended recipients.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Incorrect**.  
The `response_list` does not address this issue. The described problem is about returning unused funds to the correct address (`msg.sender`), which is critical for ensuring user funds are not lost or misdirected. None of the responses in the `response_list` discuss this specific issue or its impact.

**Suggestions**:  
- The response should recommend modifying the function to return unused WETH/ETH to the `msg.sender` instead of the `to` address.  
- It should also suggest adding tests to verify the correct behavior of the function.

---

### **[M-04] `NFTXStakingZap` and `NFTXMarketplaceZap` transferFromERC721 transfer CryptoKitties to the wrong address**

**Report Description**:  
The `transferFromERC721` function transfers CryptoKitties to `address(this)` instead of the `to` address. This appears to be a mistake, as there is no additional logic for this case. The incorrect transfer leads to wrong NFT accounting, with the NFT being missed in the vault.

**Match in Response List**:  
Matches with the issue titled **""Hardcoded Addresses""** in the response list.

**Validation**:  
**Correct**.  
The response identifies the use of hardcoded addresses for specific NFT contracts like CryptoKitties and CryptoPunks. However, it does not specifically address the incorrect transfer logic in the `transferFromERC721` function. The response also does not provide a solution for the described issue.

**Suggestions**:  
- The response should explicitly address the incorrect transfer logic and recommend modifying the function to transfer NFTs to the correct `to` address.  
- It should also suggest removing hardcoded addresses and using a more flexible approach, such as a mapping of supported NFT contracts.

---

### **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

**Report Description**:  
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping ERC1155 tokens within a single transaction. However, the `_buyVaultToken` call uses `msg.value` instead of `maxWethIn`. As a result, the function will not work unless the user supplies both WETH and native ETH amounts equivalent to the `maxWethIn` amount.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability""** in the response list.

**Validation**:  
**Incorrect**.  
The response in the `response_list` does not address the core issue described in the report. The issue is about the incorrect use of `msg.value` in the `_buyVaultToken` call, which causes the function to fail. The response instead discusses reentrancy vulnerabilities, which are unrelated to this specific issue.

**Suggestions**:  
- The response should explicitly address the incorrect use of `msg.value` in the `_buyVaultToken` call and recommend using `maxWethIn` as intended.  
- It should also suggest adding tests to ensure the function behaves as expected when handling WETH and ETH inputs.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-01] Missing non-reentrancy modifier**  
- **[M-04] `NFTXStakingZap` and `NFTXMarketplaceZap` transferFromERC721 transfer CryptoKitties to the wrong address**

**Partially Correct Matches**:  
- *None*  

**Missed Issues from Issue Report**:  
- **[H-01] `buyAndSwap1155WETH()` function may cause loss of user assets**  
- **[H-03] A vault can be locked from MarketplaceZap and StakingZap**  
- **[M-03] `NFTXMarketplaceZap.sol#buyAndSwap721WETH()` should return unused WETH/ETH back to `msg.sender` instead of `to`**  
- **[M-12] `buyAndSwap1155WETH` Does Not Work As Intended**

---",2,0,4,6.0,64.0,``` 1. Reentrancy Vulnerability 2. Hardcoded Addresses ```,"To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Reentrancy Vulnerability** appears at rank 1.
   - **Hardcoded Addresses** appears at rank 4.

2. **Calculate the precision at each rank where a true positive appears**:
   - **Precision at rank 1 (P@1)**: \( \frac{1}{1} = 1.0 \)
   - **Precision at rank 4 (P@4)**: \( \frac{2}{4} = 0.5 \)

3. **Average the precision values**:
   - **Average Precision (AP)**: \( \frac{1.0 + 0.5}{2} = 0.75 \)

**Output**:
```
0.75
```"
NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1672.0,172.0,"[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees
In the NFTXSimpleFeeDistributor.sol contract, the `distribute` function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the `_sendForReceiver` function.
In the `_sendForReceiver` function, when `_receiver` is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.

[M-01] Missing non reentrancy modifier
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer.

[M-02] `addReceiver()`: Failure to check for existing receiver
The `addReceiver()` function fails to check if the `_receiver` already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.
The receiver would receive more than expected (until the duplicate entry has been removed).

[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract
Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.

[M-14] Return variable can remain unassigned in `_sendForReceiver`
The `_sendForReceiver()` function only sets a return function in the ""if"" code block, not the ""else"" case. If the ""else"" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover > 0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.
This problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.

[M-16] Malicious receiver can make `distribute` function denial of service
`distribute` function
In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the `_sendForReceiver` function to distribute the feeIn the `_sendForReceiver` function, when the `_receiver` is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.",6.0,,"pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1605.0,1.0,5.0,"{'task_list': [{'Area': 'Security Vulnerabilities', 'Tasks': ['Review the use of the ReentrancyGuardUpgradeable to ensure it effectively protects against reentrancy attacks.', 'Verify all external calls are handled safely, particularly in the distribute function, to prevent misuse or unexpected behavior.', 'Ensure SafeMathUpgradeable is used explicitly for all arithmetic operations to prevent overflows and underflows.']}, {'Area': 'Access Control', 'Tasks': ['Ensure that functions with the onlyOwner modifier are appropriately restricted to owner access.', 'Check that the set functions (setTreasuryAddress, setLPStakingAddress, etc.) are protected against unauthorized access and can only be called by the owner.']}, {'Area': 'External Interactions', 'Tasks': ['Examine interactions with external contracts like INFTXVaultFactory, INFTXLPStaking, and INFTXInventoryStaking for security and compatibility.', 'Verify that token transfers and approvals are correctly handled using SafeERC20Upgradeable to prevent loss or mismanagement of tokens.']}, {'Area': 'Complex Logic/Algorithms', 'Tasks': ['Test the distribute function thoroughly for different scenarios, including edge cases where allocTotal is zero or distributionPaused is true.', 'Analyze the fee receiver allocation logic to ensure correct distribution of tokens based on allocation points.']}, {'Area': 'Gas Optimization', 'Tasks': ['Review the loop in the distribute function and consider optimizations to minimize gas consumption, especially as the feeReceivers array grows.', 'Identify any redundant operations or state changes that could be optimized for gas efficiency.']}, {'Area': 'Fallback/Emergency Stops', 'Tasks': ['Verify the implementation of the pauseFeeDistribution function to ensure it can effectively halt distribution when necessary.', 'Check that the contract has appropriate mechanisms to handle emergencies or unexpected conditions safely.']}]}","{'ReviewingTheCode': 'The NFTXSimpleFeeDistributor contract is designed to handle fee distribution for an NFTX system, allocating fees to various receivers based on allocation points. It includes mechanisms to distribute tokens, manage receivers, and update addresses for key components like treasury and staking. The contract handles ERC20 tokens and interacts with other contracts in the NFTX ecosystem, ensuring safe transfers and updates.', 'IdentifyingKeyComponents': {'ContractName': 'NFTXSimpleFeeDistributor', 'Purpose': 'To manage and distribute fees collected from NFTX operations to designated fee receivers based on allocation points.', 'InheritanceAndImports': {'InheritsFrom': ['INFTXSimpleFeeDistributor', 'ReentrancyGuardUpgradeable', 'PausableUpgradeable'], 'Imports': ['INFTXLPStaking', 'INFTXSimpleFeeDistributor', 'INFTXInventoryStaking', 'INFTXVaultFactory', 'IERC20Upgradeable', 'SafeERC20Upgradeable', 'SafeMathUpgradeable', 'PausableUpgradeable', 'ReentrancyGuardUpgradeable']}, 'StateVariables': [{'Name': 'distributionPaused', 'Type': 'bool', 'Purpose': 'Indicates if the distribution of fees is paused.'}, {'Name': 'nftxVaultFactory', 'Type': 'address', 'Purpose': 'Address of the NFTX vault factory contract.'}, {'Name': 'lpStaking', 'Type': 'address', 'Purpose': 'Address of the LP staking contract.'}, {'Name': 'treasury', 'Type': 'address', 'Purpose': 'Address where remaining tokens are sent if distribution is paused.'}, {'Name': 'allocTotal', 'Type': 'uint256', 'Purpose': 'Total allocation points for fee distribution.'}, {'Name': 'feeReceivers', 'Type': 'FeeReceiver[]', 'Purpose': 'Array of fee receivers with their allocation points and addresses.'}, {'Name': 'inventoryStaking', 'Type': 'address', 'Purpose': 'Address of the inventory staking contract.'}], 'FunctionsAndModifiers': [{'Name': '__SimpleFeeDistributor__init__', 'Visibility': 'public', 'Purpose': 'Initializes the contract with LP staking and treasury addresses.', 'Parameters': ['address _lpStaking', 'address _treasury'], 'Returns': []}, {'Name': 'distribute', 'Visibility': 'external', 'Purpose': 'Distributes fees to receivers based on allocation points.', 'Parameters': ['uint256 vaultId'], 'Returns': []}, {'Name': 'addReceiver', 'Visibility': 'external', 'Purpose': 'Adds a new fee receiver.', 'Parameters': ['uint256 _allocPoint', 'address _receiver', 'bool _isContract'], 'Returns': []}, {'Name': 'initializeVaultReceivers', 'Visibility': 'external', 'Purpose': 'Initializes vault receivers for a new vault.', 'Parameters': ['uint256 _vaultId'], 'Returns': []}, {'Name': 'changeReceiverAlloc', 'Visibility': 'public', 'Purpose': 'Changes allocation points for a fee receiver.', 'Parameters': ['uint256 _receiverIdx', 'uint256 _allocPoint'], 'Returns': []}, {'Name': 'changeReceiverAddress', 'Visibility': 'public', 'Purpose': 'Changes address for a fee receiver.', 'Parameters': ['uint256 _receiverIdx', 'address _address', 'bool _isContract'], 'Returns': []}, {'Name': 'removeReceiver', 'Visibility': 'external', 'Purpose': 'Removes a fee receiver.', 'Parameters': ['uint256 _receiverIdx'], 'Returns': []}, {'Name': 'setTreasuryAddress', 'Visibility': 'public', 'Purpose': 'Sets the treasury address.', 'Parameters': ['address _treasury'], 'Returns': []}, {'Name': 'setLPStakingAddress', 'Visibility': 'public', 'Purpose': 'Sets the LP staking address.', 'Parameters': ['address _lpStaking'], 'Returns': []}, {'Name': 'setInventoryStakingAddress', 'Visibility': 'public', 'Purpose': 'Sets the inventory staking address.', 'Parameters': ['address _inventoryStaking'], 'Returns': []}, {'Name': 'setNFTXVaultFactory', 'Visibility': 'external', 'Purpose': 'Sets the NFTX vault factory address.', 'Parameters': ['address _factory'], 'Returns': []}, {'Name': 'pauseFeeDistribution', 'Visibility': 'external', 'Purpose': 'Pauses or unpauses fee distribution.', 'Parameters': ['bool pause'], 'Returns': []}, {'Name': 'rescueTokens', 'Visibility': 'external', 'Purpose': 'Rescues tokens accidentally sent to the contract.', 'Parameters': ['address _address'], 'Returns': []}]}, 'SecurityAnalysis': {'PotentialVulnerabilities': ['Reentrancy Risks: The contract uses the ReentrancyGuardUpgradeable to mitigate this risk.', 'Arithmetic Overflows/Underflows: SafeMathUpgradeable should be used to ensure safe arithmetic operations.', 'Access Control Flaws: Functions are protected by the onlyOwner modifier where necessary.', 'Unbounded Loops/Excessive Gas Consumption: The distribute function has a loop that could potentially lead to high gas consumption if the feeReceivers array grows large.'], 'MitigationRecommendations': ['Use SafeMathUpgradeable explicitly to ensure all arithmetic operations are safe.', 'Consider implementing a mechanism to limit the number of fee receivers to prevent excessive gas consumption.']}, 'ExternalInteractions': ['The contract interacts with external contracts such as INFTXVaultFactory, INFTXLPStaking, and INFTXInventoryStaking.'], 'DesignPatternsAndMechanisms': ['The contract uses the Pausable pattern to allow pausing of fee distribution.', 'The ReentrancyGuard pattern is used to prevent reentrancy attacks.'], 'TestCoverageAndDocumentation': ['The contract is well-documented with events and function descriptions.', 'Ensure comprehensive testing, especially for the distribute function to handle various scenarios and edge cases.'], 'Questions': ['What are the expected maximum number of fee receivers to ensure the distribute function remains efficient?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in distribute Function', 'Severity': 'High', 'Description': 'The `distribute` function is prone to reentrancy attacks due to multiple external calls within loops and its reliance on external contract balances. While the `nonReentrant` modifier is employed, not all scenarios are fully protected, potentially allowing attackers to exploit token balance manipulations.', 'Impact': 'An attacker could exploit this vulnerability to manipulate token balances during distribution, leading to incorrect allocations and potential fund loss.', 'Location': 'Function `distribute`, lines 41-73'}, {'Issue': 'Unsafe Handling of External Calls', 'Severity': 'Medium', 'Description': 'Functions like `_sendForReceiver` make external calls via `.call` without verifying success, potentially leading to reentrancy attacks or unintended outcomes if the external contract is malicious.', 'Impact': 'This could allow a malicious contract to exploit the system, potentially draining funds or causing other unintended side effects.', 'Location': 'Function `_sendForReceiver`, lines 148-194'}, {'Issue': 'Lack of Access Control on Sensitive Functions', 'Severity': 'Critical', 'Description': 'Functions such as `setTreasuryAddress`, `setLPStakingAddress`, `setNFTXVaultFactory`, and others lack adequate access control beyond the `onlyOwner` modifier. If ownership is compromised, critical parameters and funds could be redirected or mismanaged.', 'Impact': 'Critical funds and operations may be redirected or manipulated by unauthorized users, leading to potential loss or mismanagement of assets.', 'Location': 'Functions `setTreasuryAddress`, `setLPStakingAddress`, `setNFTXVaultFactory`, etc., lines 117-142'}, {'Issue': 'Potential Arithmetic Overflow/Underflow', 'Severity': 'Medium', 'Description': ""Arithmetic operations in functions like `changeReceiverAlloc` and `removeReceiver` do not explicitly use `SafeMath`, which is a best practice for clarity and safety, despite Solidity 0.8.0's built-in checks."", 'Impact': 'Potential future issues if newer versions of Solidity change the default behavior, or if the code is migrated to an environment without these checks.', 'Location': 'Functions `changeReceiverAlloc`, `removeReceiver`, lines 100-137'}, {'Issue': 'Lack of Event Emission for Critical Changes', 'Severity': 'Low', 'Description': 'Critical state changes, such as pausing distribution and changing receiver configurations, do not always emit events, reducing transparency and making it difficult to track changes off-chain.', 'Impact': 'Lack of visibility into contract state changes, impacting monitoring and auditing.', 'Location': 'Functions `pauseFeeDistribution`, `changeReceiverAlloc`, lines 118, 152'}], 'IssueNumber': 30, 'OutputList': 5}","---

### **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**

**Report Description**:  
The `_sendForReceiver` function in `NFTXSimpleFeeDistributor.sol` does not return a value when `_receiver` is not a contract. By default, this results in a `false` return value. The `distribute` function relies on this return value to determine whether the fee was successfully sent. If the return value is `false`, the `distribute` function assumes the fee transfer failed and sends additional fees in subsequent calls, leading to overpayment.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Handling of External Calls""**.

**Validation**:  
**Partially Correct**.  
The response identifies the unsafe handling of external calls in `_sendForReceiver` and highlights the risks of unintended outcomes. However, it does not explicitly address the specific issue of the `_sendForReceiver` function returning `false` by default when `_receiver` is not a contract, nor does it discuss the resulting overpayment problem. The response could be improved by explicitly mentioning the default `false` return value and its impact on the `distribute` function.

**Suggestions**:  
- Update the response to explicitly address the default `false` return value when `_receiver` is not a contract and its impact on fee distribution.
- Recommend explicitly returning a `true` value in `_sendForReceiver` when the transfer is successful, regardless of whether `_receiver` is a contract.

---

### **[M-01] Missing non-reentrancy modifier**

**Report Description**:  
Certain public/external functions in the contract lack the `nonReentrant` modifier, even though other functions use it. This inconsistency could leave the contract vulnerable to reentrancy attacks, especially in functions that involve external calls or state changes.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in distribute Function""**.

**Validation**:  
**Correct**.  
The response identifies the reentrancy vulnerability in the `distribute` function and mentions the use of the `nonReentrant` modifier. However, it does not address the broader issue of missing `nonReentrant` modifiers in other functions. The response could be improved by explicitly listing the functions that lack the modifier and recommending its addition where necessary.

**Suggestions**:  
- Expand the response to include all functions that lack the `nonReentrant` modifier and explain why they are vulnerable to reentrancy attacks.
- Recommend adding the `nonReentrant` modifier to these functions or restructuring them to mitigate reentrancy risks.

---

### **[M-02] `addReceiver()`: Failure to check for existing receiver**

**Report Description**:  
The `addReceiver()` function does not check whether the `_receiver` already exists in the list of receivers. This oversight allows the same receiver to be added multiple times, leading to erroneous fee distributions where the receiver receives more than their intended share.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Incorrect**.  
The response list does not address the issue of duplicate receivers in the `addReceiver()` function. This is a critical oversight, as it directly impacts the accuracy of fee distributions.

**Suggestions**:  
- Add a response that explicitly addresses the need to check for duplicate receivers in the `addReceiver()` function.
- Recommend implementing a mechanism to prevent duplicate entries, such as maintaining a mapping of receivers to their existence status.

---

### **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**

**Report Description**:  
The `_sendForReceiver` function does not return a success value when the `_receiver` is not a contract. This causes the `distribute` function to send fees twice: once to the current receiver and again to the next receiver in the list. This results in double payments for some receivers and missed payments for others.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Handling of External Calls""**.

**Validation**:  
**Partially Correct**.  
The response identifies the unsafe handling of external calls in `_sendForReceiver` but does not specifically address the issue of double payments and missed payments caused by the lack of a success return value. The response could be improved by explicitly discussing the double payment issue and its impact on fee distribution.

**Suggestions**:  
- Update the response to explicitly address the double payment and missed payment issues caused by the lack of a success return value in `_sendForReceiver`.
- Recommend modifying `_sendForReceiver` to always return a success value when the transfer is successful.

---

### **[M-14] Return variable can remain unassigned in `_sendForReceiver`**

**Report Description**:  
The `_sendForReceiver` function only assigns a return value in the `if` block but not in the `else` block. If the `else` block is executed, the function implicitly returns `false`. This can cause the `distribute` function to misinterpret successful transfers as failures, leading to leftover tokens being sent to the treasury unnecessarily.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Handling of External Calls""**.

**Validation**:  
**Partially Correct**.  
The response highlights the risks of unsafe external calls but does not specifically address the issue of unassigned return variables in `_sendForReceiver`. The response could be improved by explicitly discussing the implicit `false` return value and its impact on the `distribute` function.

**Suggestions**:  
- Update the response to explicitly address the issue of unassigned return variables in `_sendForReceiver`.
- Recommend explicitly assigning a return value in both the `if` and `else` blocks to avoid unintended behavior.

---

### **[M-16] Malicious receiver can make `distribute` function denial of service**

**Report Description**:  
The `distribute` function calls the `_sendForReceiver` function, which in turn calls the `receiveRewards` function of the `_receiver` contract. A malicious receiver can execute a `revert()` in their `receiveRewards` function, causing the `distribute` function to fail and resulting in a denial of service (DoS).

**Match in Response List**:  
Matches with the issue titled **""Unsafe Handling of External Calls""**.

**Validation**:  
**Correct**.  
The response identifies the risks of unsafe external calls and mentions the potential for malicious contracts to exploit the system. This aligns with the issue described in the report.

**Suggestions**:  
- Recommend implementing a mechanism to handle failures gracefully, such as skipping over failing receivers and logging the failure for later review.

---

### **Summary of Matches and Gaps**

**Correct Matches**:   - **[H-02] The return value of the `_sendForReceiver` function is not set, causing the receiver to receive more fees**   - **[M-01] Missing non-reentrancy modifier**   - **[M-10] `_sendForReceiver` doesn't return success if receiver is not a contract**
- **[M-14] Return variable can remain unassigned in `_sendForReceiver`** - **[M-16] Malicious receiver can make `distribute` function denial of service**

**Partially Correct Matches**:   - *None*

**Missed Issues from Issue Report**:  
- **[M-02] `addReceiver()`: Failure to check for existing receiver**

---",5,0,1,5.0,30.0,``` 1. Reentrancy Vulnerability in distribute Function 2. Unsafe Handling of External Calls ```,"To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Reentrancy Vulnerability in distribute Function** appears at rank 1.
   - **Unsafe Handling of External Calls** appears at rank 2.

2. **Calculate the precision at each rank where a true positive appears**:
   - **Precision at rank 1 (P@1)**: \( \frac{1}{1} = 1.0 \)
   - **Precision at rank 2 (P@2)**: \( \frac{2}{2} = 1.0 \)

3. **Average the precision values to compute the Average Precision (AP)**:
   - \( AP = \frac{1.0 + 1.0}{2} = 1.0 \)

**Output**:
- **Average Precision (AP)**: 1.0"
NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

// Authors: @0xKiwi_ and @alexgausman.

contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    // Added in v1.0.3.
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    // // This function allows for the manager to set their own arbitrary eligibility contract.
    // // Once eligiblity is set, it cannot be unset or changed.
    // Disabled for launch.
    // function setEligibilityStorage(address _newEligibility) public virtual {
    //     onlyPrivileged();
    //     require(
    //         address(eligibilityStorage) == address(0),
    //         ""NFTXVault: eligibility already set""
    //     );
    //     eligibilityStorage = INFTXEligibility(_newEligibility);
    //     // Toggle this to let the contract know to check eligibility now.
    //     allowAllItems = false;
    //     emit CustomEligibilityDeployed(address(_newEligibility));
    // }

    // The manager has control over options like fees and features
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        // Take the NFTs.
        uint256 count = receiveNFTs(tokenIds, amounts);

        // Mint to the user.
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burn(msg.sender, base * amount);

        // Pay the tokens + toll.
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        // Withdraw from vault.
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        // Give the NFTs first, so the user wont get the same thing back, just to be nice. 
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    // Added in v1.0.3.
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    // Added in v1.0.3.
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    // Added in v1.0.3.
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                // We may already own the NFT here so we check in order:
                // Does the vault own it?
                //   - If so, check if its in holdings list
                //      - If so, we reject. This means the NFT has already been claimed for.
                //      - If not, it means we have not yet accounted for this NFT, so we continue.
                //   -If not, we ""pull"" it from the msg.sender and add to holdings.
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            // This will always be fine considering the validations made above. 
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        // Do not charge fees if the zap contract is calling
        // Added in v1.0.3. Changed to mapping in v1.0.5.
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            // Changed to a _transfer() in v1.0.3.
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Changed in v1.0.4.
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            // Default.
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Cryptokitties.
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            // Fix here for frontrun attack. Added in v1.0.2.
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            // Default.
            // Allow other contracts to ""push"" into the vault, safely.
            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4750.0,561.0,"[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users
Pool Manager can front-run entry fee to 100% and users could lose all their deposits.
Anyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10**18 (100% as this is a per token fee).

[M-09] Bypass zap timelock
The default value of `inventoryLockTime` in NFTXStakingZap is 7 days while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in XTokenUpgradeable.
The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in NFTXInventoryStaking`",2.0,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";



contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true , true , true , true , true );
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    
    
    
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        
        uint256 count = receiveNFTs(tokenIds, amounts);

        
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        
        _burn(msg.sender, base * amount);

        
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                
                
                
                
                
                
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        
        
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            
            
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            
            
            
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4033.0,0.0,2.0,"{'task_list': [{'Area': 'Security Vulnerabilities', 'Tasks': ['Review the implementation of the ReentrancyGuard to ensure that all functions interacting with external contracts are protected against reentrancy attacks.', 'Check for any unchecked low-level calls that might result in unexpected failures or exploits.', 'Ensure all arithmetic operations are safe from overflow/underflow, considering Solidity 0.8+ has built-in checks.']}, {'Area': 'Access Control', 'Tasks': ['Verify that access control mechanisms (e.g., onlyPrivileged, onlyOwnerIfPaused) are properly implemented and secure against unauthorized access.', 'Ensure that the manager and owner roles are clearly defined and that there are no potential loopholes for unauthorized role changes.']}, {'Area': 'External Interactions', 'Tasks': ['Audit all external contract calls, particularly those involving INFTXVaultFactory, INFTXEligibilityManager, and INFTXFeeDistributor, to ensure they handle failures gracefully.', 'Verify that the contract correctly interfaces with ERC721 and ERC1155 tokens, ensuring safe transfers and handling of NFTs.']}, {'Area': 'Complex Logic/Algorithms', 'Tasks': ['Review the logic for minting, redeeming, and swapping NFTs to ensure it operates correctly and efficiently.', 'Check the eligibility checking logic to ensure it accurately determines if NFTs are valid for the vault.']}, {'Area': 'Gas Optimization', 'Tasks': ['Identify any loops or operations that could be optimized for gas efficiency, especially in functions like receiveNFTs and withdrawNFTsTo.', ""Ensure that the contract's design minimizes unnecessary state changes or complex computations.""]}, {'Area': 'Flash Loan Protection', 'Tasks': ['Examine the flashLoan function to ensure it has sufficient checks and balances to prevent flash loan-based attacks or exploits.']}, {'Area': 'Fallback/Emergency Stops', 'Tasks': ['Verify the presence and functionality of mechanisms to pause or stop contract operations in emergency situations.', 'Ensure that emergency stop functions can only be triggered by authorized personnel and are protective against malicious use.']}]}","{'ReviewingTheCode': 'The NFTXVaultUpgradeable contract is a smart contract for managing NFT vaults, allowing minting, redeeming, and swapping of NFTs. It uses multiple inherited contracts and interfaces for functionality and security, including reentrancy protection and ownership control. The contract is designed for both ERC721 and ERC1155 token standards, with features for minting, swapping, and redeeming tokens. It includes mechanisms for setting fees, managing eligibility, and handling external interactions with other contracts.', 'IdentifyingKeyComponents': {'ContractName': 'NFTXVaultUpgradeable', 'Purpose': 'Manages NFT vaults, allowing minting, redeeming, and swapping of NFTs with support for ERC721 and ERC1155 standards.', 'InheritanceAndImports': {'InheritsFrom': ['OwnableUpgradeable', 'ERC20FlashMintUpgradeable', 'ReentrancyGuardUpgradeable', 'ERC721SafeHolderUpgradeable', 'ERC1155SafeHolderUpgradeable', 'INFTXVault'], 'Imports': ['./interface/INFTXVault.sol', './interface/INFTXVaultFactory.sol', './interface/INFTXEligibility.sol', './interface/INFTXEligibilityManager.sol', './interface/INFTXLPStaking.sol', './interface/INFTXFeeDistributor.sol', './interface/IERC165Upgradeable.sol', './token/ERC20FlashMintUpgradeable.sol', './token/ERC721SafeHolderUpgradeable.sol', './token/ERC1155SafeHolderUpgradeable.sol', './token/IERC721Upgradeable.sol', './token/IERC1155Upgradeable.sol', './util/OwnableUpgradeable.sol', './util/ReentrancyGuardUpgradeable.sol', './util/EnumerableSetUpgradeable.sol']}, 'StateVariables': [{'Name': 'base', 'Type': 'uint256', 'Purpose': 'Base multiplier for token calculations, set to 10^18.'}, {'Name': 'vaultId', 'Type': 'uint256', 'Purpose': 'Identifier for the vault.'}, {'Name': 'manager', 'Type': 'address', 'Purpose': 'Address of the vault manager.'}, {'Name': 'assetAddress', 'Type': 'address', 'Purpose': 'Address of the asset being managed in the vault.'}, {'Name': 'vaultFactory', 'Type': 'INFTXVaultFactory', 'Purpose': 'Factory contract for creating and managing vaults.'}, {'Name': 'eligibilityStorage', 'Type': 'INFTXEligibility', 'Purpose': 'Contract storing eligibility criteria for NFTs.'}, {'Name': 'randNonce', 'Type': 'uint256', 'Purpose': 'Nonce used for generating random numbers.'}, {'Name': 'is1155', 'Type': 'bool', 'Purpose': 'Flag indicating if the vault handles ERC1155 tokens.'}, {'Name': 'allowAllItems', 'Type': 'bool', 'Purpose': 'Flag indicating if all items are allowed in the vault.'}, {'Name': 'enableMint', 'Type': 'bool', 'Purpose': 'Flag indicating if minting is enabled.'}, {'Name': 'enableRandomRedeem', 'Type': 'bool', 'Purpose': 'Flag indicating if random redeeming is enabled.'}, {'Name': 'enableTargetRedeem', 'Type': 'bool', 'Purpose': 'Flag indicating if target redeeming is enabled.'}, {'Name': 'holdings', 'Type': 'EnumerableSetUpgradeable.UintSet', 'Purpose': 'Set of token IDs held in the vault.'}, {'Name': 'quantity1155', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Mapping of ERC1155 token IDs to their quantities in the vault.'}, {'Name': 'enableRandomSwap', 'Type': 'bool', 'Purpose': 'Flag indicating if random swapping is enabled.'}, {'Name': 'enableTargetSwap', 'Type': 'bool', 'Purpose': 'Flag indicating if target swapping is enabled.'}], 'FunctionsAndModifiers': [{'Name': '__NFTXVault_init', 'Visibility': 'public', 'Purpose': 'Initializes the vault with the provided parameters.', 'Parameters': ['string memory _name', 'string memory _symbol', 'address _assetAddress', 'bool _is1155', 'bool _allowAllItems'], 'Returns': []}, {'Name': 'finalizeVault', 'Visibility': 'external', 'Purpose': 'Finalizes the vault by setting the manager to address zero.', 'Parameters': [], 'Returns': []}, {'Name': 'setVaultMetadata', 'Visibility': 'public', 'Purpose': 'Sets the metadata (name and symbol) for the vault.', 'Parameters': ['string memory name_', 'string memory symbol_'], 'Returns': []}, {'Name': 'setVaultFeatures', 'Visibility': 'public', 'Purpose': 'Enables or disables various vault features.', 'Parameters': ['bool _enableMint', 'bool _enableRandomRedeem', 'bool _enableTargetRedeem', 'bool _enableRandomSwap', 'bool _enableTargetSwap'], 'Returns': []}, {'Name': 'assignDefaultFeatures', 'Visibility': 'external', 'Purpose': 'Assigns default features to the vault.', 'Parameters': [], 'Returns': []}, {'Name': 'setFees', 'Visibility': 'public', 'Purpose': 'Sets the fees for various actions in the vault.', 'Parameters': ['uint256 _mintFee', 'uint256 _randomRedeemFee', 'uint256 _targetRedeemFee', 'uint256 _randomSwapFee', 'uint256 _targetSwapFee'], 'Returns': []}, {'Name': 'disableVaultFees', 'Visibility': 'public', 'Purpose': 'Disables the fees for the vault.', 'Parameters': [], 'Returns': []}, {'Name': 'deployEligibilityStorage', 'Visibility': 'external', 'Purpose': 'Deploys eligibility storage for the vault.', 'Parameters': ['uint256 moduleIndex', 'bytes calldata initData'], 'Returns': ['address']}, {'Name': 'setManager', 'Visibility': 'public', 'Purpose': 'Sets the manager for the vault.', 'Parameters': ['address _manager'], 'Returns': []}, {'Name': 'mint', 'Visibility': 'external', 'Purpose': ""Mints tokens to the caller's address."", 'Parameters': ['uint256[] calldata tokenIds', 'uint256[] calldata amounts'], 'Returns': ['uint256']}, {'Name': 'mintTo', 'Visibility': 'public', 'Purpose': 'Mints tokens to a specified address.', 'Parameters': ['uint256[] memory tokenIds', 'uint256[] memory amounts', 'address to'], 'Returns': ['uint256']}, {'Name': 'redeem', 'Visibility': 'external', 'Purpose': 'Redeems tokens and withdraws NFTs to the caller.', 'Parameters': ['uint256 amount', 'uint256[] calldata specificIds'], 'Returns': ['uint256[] memory']}, {'Name': 'redeemTo', 'Visibility': 'public', 'Purpose': 'Redeems tokens and withdraws NFTs to a specified address.', 'Parameters': ['uint256 amount', 'uint256[] memory specificIds', 'address to'], 'Returns': ['uint256[] memory']}, {'Name': 'swap', 'Visibility': 'external', 'Purpose': 'Swaps NFTs in the vault.', 'Parameters': ['uint256[] calldata tokenIds', 'uint256[] calldata amounts', 'uint256[] calldata specificIds'], 'Returns': ['uint256[] memory']}, {'Name': 'swapTo', 'Visibility': 'public', 'Purpose': 'Swaps NFTs to a specified address.', 'Parameters': ['uint256[] memory tokenIds', 'uint256[] memory amounts', 'uint256[] memory specificIds', 'address to'], 'Returns': ['uint256[] memory']}, {'Name': 'flashLoan', 'Visibility': 'public', 'Purpose': 'Executes a flash loan with the specified parameters.', 'Parameters': ['IERC3156FlashBorrowerUpgradeable receiver', 'address token', 'uint256 amount', 'bytes memory data'], 'Returns': ['bool']}, {'Name': 'mintFee', 'Visibility': 'public', 'Purpose': 'Returns the current mint fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'randomRedeemFee', 'Visibility': 'public', 'Purpose': 'Returns the current random redeem fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'targetRedeemFee', 'Visibility': 'public', 'Purpose': 'Returns the current target redeem fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'randomSwapFee', 'Visibility': 'public', 'Purpose': 'Returns the current random swap fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'targetSwapFee', 'Visibility': 'public', 'Purpose': 'Returns the current target swap fee.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'vaultFees', 'Visibility': 'public', 'Purpose': 'Returns all current fees for the vault.', 'Parameters': [], 'Returns': ['uint256', 'uint256', 'uint256', 'uint256', 'uint256']}, {'Name': 'allValidNFTs', 'Visibility': 'public', 'Purpose': 'Checks if all provided NFT token IDs are valid according to eligibility storage.', 'Parameters': ['uint256[] memory tokenIds'], 'Returns': ['bool']}, {'Name': 'nftIdAt', 'Visibility': 'external', 'Purpose': 'Returns the NFT ID at a specific holdings index.', 'Parameters': ['uint256 holdingsIndex'], 'Returns': ['uint256']}, {'Name': 'allHoldings', 'Visibility': 'external', 'Purpose': 'Returns all NFT holdings in the vault.', 'Parameters': [], 'Returns': ['uint256[] memory']}, {'Name': 'totalHoldings', 'Visibility': 'external', 'Purpose': 'Returns the total number of NFT holdings in the vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'version', 'Visibility': 'external', 'Purpose': 'Returns the version of the contract.', 'Parameters': [], 'Returns': ['string memory']}, {'Name': 'afterRedeemHook', 'Visibility': 'internal', 'Purpose': 'Executes post-redeem logic, such as updating eligibility storage.', 'Parameters': ['uint256[] memory tokenIds'], 'Returns': []}, {'Name': 'receiveNFTs', 'Visibility': 'internal', 'Purpose': 'Receives NFTs and updates vault holdings.', 'Parameters': ['uint256[] memory tokenIds', 'uint256[] memory amounts'], 'Returns': ['uint256']}, {'Name': 'withdrawNFTsTo', 'Visibility': 'internal', 'Purpose': 'Withdraws NFTs from the vault to a specified address.', 'Parameters': ['uint256 amount', 'uint256[] memory specificIds', 'address to'], 'Returns': ['uint256[] memory']}, {'Name': '_chargeAndDistributeFees', 'Visibility': 'internal', 'Purpose': 'Charges and distributes fees for a transaction.', 'Parameters': ['address user', 'uint256 amount'], 'Returns': []}, {'Name': 'transferERC721', 'Visibility': 'internal', 'Purpose': 'Transfers an ERC721 token from the vault to a specified address.', 'Parameters': ['address assetAddr', 'address to', 'uint256 tokenId'], 'Returns': []}, {'Name': 'transferFromERC721', 'Visibility': 'internal', 'Purpose': 'Transfers an ERC721 token from the sender to the vault.', 'Parameters': ['address assetAddr', 'uint256 tokenId'], 'Returns': []}, {'Name': 'getRandomTokenIdFromVault', 'Visibility': 'internal', 'Purpose': ""Selects a random token ID from the vault's holdings."", 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'onlyPrivileged', 'Visibility': 'internal', 'Purpose': 'Ensures the caller is privileged (either the owner or manager).', 'Parameters': [], 'Returns': []}, {'Name': 'onlyOwnerIfPaused', 'Visibility': 'internal', 'Purpose': 'Ensures the caller is the owner if the contract is paused.', 'Parameters': ['uint256 lockId'], 'Returns': []}]}, 'SecurityAnalysis': {'PotentialVulnerabilities': ['Reentrancy in functions interacting with external contracts, although ReentrancyGuard is used.', 'No use of SafeMath for arithmetic operations, but Solidity 0.8+ has built-in overflow checks.', 'Access control relies on manager and owner checks, which may be vulnerable if these roles are compromised.', 'Potential excessive gas consumption in loops over holdings, which may result in denial-of-service.'], 'MitigationRecommendations': ['Ensure thorough testing of reentrancy guards, especially around mint, redeem, and swap functions.', 'Regularly audit and monitor access control roles (manager, owner) for any unauthorized changes.', 'Consider gas optimization techniques for looping over large data sets.']}, 'ExternalInteractions': ['Interacts with INFTXVaultFactory for setting and disabling fees.', 'Interacts with INFTXEligibilityManager and INFTXEligibility for deploying and checking eligibility.', 'Interacts with INFTXFeeDistributor for distributing fees.', 'Handles ERC721 and ERC1155 token transfers through IERC721Upgradeable and IERC1155Upgradeable.'], 'DesignPatternsAndMechanisms': ['Factory pattern for vault creation and management.', 'Use of upgradeable contract patterns (OwnableUpgradeable, ReentrancyGuardUpgradeable).', 'Safe handling of ERC721 and ERC1155 tokens using SafeHolderUpgradeable interfaces.'], 'TestCoverageAndDocumentation': ['The contract should have comprehensive test coverage, especially for edge cases in minting, redeeming, and swapping.', 'Inline documentation is present but could be expanded for complex logic, particularly around eligibility and fee distribution.'], 'Questions': ['How are the eligibility modules tested to ensure they correctly implement eligibility criteria?', ""What mechanisms are in place to handle potential mismanagement by the vault's manager?""]}","{'Findings': [{'Issue': 'Lack of Access Control on Critical Functions', 'Severity': 'High', 'Description': 'Many functions, such as `mint`, `redeem`, `swap`, `setManager`, `setVaultMetadata`, `setVaultFeatures`, and others, lack adequate access controls, allowing unauthorized users to perform sensitive operations. This could lead to unauthorized minting, redeeming, or manipulation of vault features and fees.', 'Impact': 'Potential unauthorized manipulation of token supply, vault features, and critical operations, leading to financial loss and security breaches.', 'Location': 'Functions `mint`, `redeem`, `swap`, `setManager`, `setVaultMetadata`, `setVaultFeatures`, and others.'}, {'Issue': 'Reentrancy Vulnerability in NFT and Token Functions', 'Severity': 'Critical', 'Description': 'Functions like `swapTo`, `redeemTo`, and others handling external calls and state changes are vulnerable to reentrancy attacks. Despite some use of reentrancy guards, these functions execute external calls before finalizing state updates, allowing potential attacks if interacting with malicious contracts.', 'Impact': 'Reentrancy attacks could lead to unauthorized fund withdrawals, double-spending, or manipulation of the contract state, resulting in asset loss.', 'Location': 'Functions `swapTo`, `redeemTo`, `mintTo`, and others.'}, {'Issue': 'Predictability and Manipulation of Randomness', 'Severity': 'Medium', 'Description': 'The `getRandomTokenIdFromVault` function uses block variables such as `blockhash`, `block.timestamp`, and others for randomness, which are predictable and susceptible to manipulation by miners.', 'Impact': 'Predictable randomness can lead to biased outcomes and potential exploitation by attackers to influence token selections or distributions.', 'Location': 'Function `getRandomTokenIdFromVault`'}, {'Issue': 'Unchecked External Calls in ERC721 Functions', 'Severity': 'High', 'Description': 'Functions such as `transferERC721` and `transferFromERC721` perform external calls to transfer tokens without proper checks or error handling, leading to potential failures and inconsistencies in contract state.', 'Impact': 'Failed transfers can result in loss of tokens or incorrect contract state, causing operational issues and asset loss.', 'Location': 'Functions `transferERC721`, `transferFromERC721`'}, {'Issue': 'Hardcoded Address for Privileged Access', 'Severity': 'Low', 'Description': 'The `assignDefaultFeatures` function uses a hardcoded developer address for access control, reducing flexibility and increasing the risk of security issues if the address needs to change or becomes compromised.', 'Impact': 'Could lead to unauthorized access or loss of functionality if the hardcoded address becomes invalid or is compromised.', 'Location': 'Function `assignDefaultFeatures`'}, {'Issue': 'Insufficient Input Validation', 'Severity': 'Medium', 'Description': 'Functions such as `receiveNFTs`, `mintTo`, and others do not adequately validate inputs, leading to potential errors or unexpected behavior when invalid data is passed.', 'Impact': 'Invalid operations could be executed, potentially leading to data corruption, logical errors, or denial of service.', 'Location': 'Functions `receiveNFTs`, `mintTo`, and others.'}, {'Issue': 'Lack of Event Emission for Critical State Changes', 'Severity': 'Low', 'Description': 'Critical state changes, such as changes made in `setManager`, `setFees`, and `disableVaultFees`, do not emit events, reducing transparency and traceability.', 'Impact': 'Lack of event emissions makes it difficult to track and audit important changes to contract state.', 'Location': 'Functions `setManager`, `setFees`, `disableVaultFees`'}], 'IssueNumber': 70, 'OutputList': 7}","---

### **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Report Description**:  
The Pool Manager can manipulate the entry fee to 100% by front-running transactions. This allows the Pool Manager to steal all user deposits. Since anyone can create a pool and attract users, a malicious Pool Manager could exploit this by setting the fee to the maximum value (`uint(1 ether)` = 100%) just before a large deposit transaction is executed. This creates a significant risk of financial loss for users.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Incorrect.** None of the responses in the `response_list` address the issue of fee manipulation or front-running by the Pool Manager. The closest response, ""Lack of Access Control on Critical Functions,"" mentions unauthorized manipulation of vault features and fees, but it does not specifically address the ability of a Pool Manager to front-run transactions and set fees to 100%. This is a distinct issue that requires specific mitigation strategies, such as implementing timelocks or restricting fee changes during active transactions.

**Suggestions**:  
- Introduce a timelock mechanism for fee changes to prevent immediate manipulation.
- Implement a cap on the maximum allowable fee to ensure it cannot be set to 100%.
- Require user confirmation for fee changes if they occur within a short timeframe before a deposit.

---

### **[M-09] Bypass zap timelock**

**Report Description**:  
The `inventoryLockTime` in `NFTXStakingZap` defaults to 7 days, while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is set to 2 ms. This discrepancy allows users to bypass the intended 7-day timelock by calling the `deposit` function in `NFTXInventoryStaking`, which calculates the timelock as `block.timestamp + timelockLength`. This effectively reduces the timelock to 2 ms, enabling users to circumvent the intended delay and potentially exploit the system.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Incorrect.** None of the responses in the `response_list` address the issue of bypassing the timelock due to inconsistent default values between `NFTXStakingZap` and `NFTXInventoryStaking`. The responses do not mention the specific vulnerability of reducing the timelock to 2 ms or the associated risks.

**Suggestions**:  
- Ensure consistent timelock values across all related contracts.
- Validate the timelock length in the `deposit` function to prevent it from being set to an unreasonably low value.
- Add a check to enforce a minimum timelock duration, regardless of the default values.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
1. **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**  
2. **[M-09] Bypass zap timelock**

---

### **Analysis and Recommendations**

The `response_list` fails to address the issues raised in the `issue` report. Both vulnerabilities are critical and require specific mitigation strategies to ensure the security and integrity of the smart contracts. The responses in the `response_list` focus on general issues like access control, reentrancy, and unchecked external calls but do not cover the unique vulnerabilities described in the `issue` report.

To improve the coverage of the `response_list`, the following steps are recommended:
1. **Expand the scope of analysis**: Ensure that all potential vulnerabilities, including fee manipulation and timelock inconsistencies, are explicitly addressed.
2. **Provide targeted solutions**: Include specific recommendations for each identified issue, such as implementing timelocks, input validation, and access control mechanisms.
3. **Cross-reference issues**: Regularly compare the identified vulnerabilities with the response list to ensure comprehensive coverage.

---",0,0,2,7.0,70.0,,The **Average Precision (AP)** for the query is **0.0**.
NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",4828.0,479.0,"***[M-08] Low-level call return value not checked***
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.",1.0,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888.0,0.0,1.0,"{'task_list': [{'Area': 'Security Vulnerabilities', 'Tasks': ['Review the usage of the ReentrancyGuard to ensure all external calls are protected.', ""Check for potential integer overflow/underflow issues despite Solidity 0.8.0's built-in checks."", 'Verify that all external contract calls handle failures gracefully and do not leave the contract in an inconsistent state.', 'Ensure that the `rescue` function is secure and cannot be misused by verifying access control and logic.']}, {'Area': 'External Interactions', 'Tasks': ['Audit interactions with the WETH contract to ensure proper Ether wrapping and unwrapping.', 'Verify that calls to the NFTX vaults are secure and that the correct amount of tokens are minted.', 'Ensure that interaction with the SushiSwap router for liquidity provision is correctly implemented and handles slippage correctly.']}, {'Area': 'Access Control', 'Tasks': ['Verify that the `onlyOwner` modifier is correctly applied to functions that modify critical state variables.', 'Check the security of ownership transfer and ensure the new owner is correctly set and verified.', 'Review the logic for setting lock times to ensure they cannot be manipulated to the detriment of users.']}, {'Area': 'Gas Optimization', 'Tasks': ['Analyze loops in the `provideInventory721` and `provideInventory1155` functions for potential gas exhaustion with large input arrays.', 'Review the use of `immutable` and `constant` variables to ensure efficient gas usage.']}, {'Area': 'Liquidity Pools & AMM Risks', 'Tasks': ['Evaluate the `_addLiquidityAndLock` function to ensure it correctly computes liquidity and handles token transfers.', 'Check that the pair computation in `pairFor` is accurate and aligns with standard Uniswap V2 practices.']}, {'Area': 'Fallback/Emergency Stops', 'Tasks': ['Ensure the contract has a mechanism to handle unexpected failures, such as a fallback function or emergency stop.', 'Verify that the `receive` function handles Ether correctly and securely.']}]}","{'ReviewingTheCode': 'The NFTXStakingZap contract is designed to facilitate NFT staking, liquidity provision, and interaction with various DeFi protocols. It inherits from Ownable and ReentrancyGuard and interacts with multiple external interfaces. The contract includes mechanisms for depositing NFTs, adding liquidity, and handling ERC721 and ERC1155 tokens.', 'IdentifyingKeyComponents': {'ContractName': 'NFTXStakingZap', 'Purpose': 'The contract allows users to stake NFTs and provide liquidity to NFTX vaults, while handling staking and liquidity provision with security features like reentrancy protection.', 'InheritanceAndImports': {'InheritsFrom': ['Ownable', 'ReentrancyGuard', 'ERC721HolderUpgradeable', 'ERC1155HolderUpgradeable'], 'Imports': ['INFTXVault', 'INFTXVaultFactory', 'INFTXSimpleFeeDistributor', 'INFTXLPStaking', 'INFTXInventoryStaking', 'ITimelockRewardDistributionToken', 'IUniswapV2Router01', 'IERC721', 'IERC1155Upgradeable', 'IERC20Upgradeable', 'OwnableUpgradeable']}, 'StateVariables': [{'Name': 'WETH', 'Type': 'IWETH', 'Purpose': 'Immutable reference to the WETH contract for handling Ether in wrapped form.'}, {'Name': 'lpStaking', 'Type': 'INFTXLPStaking', 'Purpose': 'Immutable reference to the LP staking contract for managing liquidity provision.'}, {'Name': 'inventoryStaking', 'Type': 'INFTXInventoryStaking', 'Purpose': 'Immutable reference for inventory staking operations.'}, {'Name': 'nftxFactory', 'Type': 'INFTXVaultFactory', 'Purpose': 'Immutable reference to the NFTX vault factory for vault interactions.'}, {'Name': 'sushiRouter', 'Type': 'IUniswapV2Router01', 'Purpose': 'Immutable reference to the SushiSwap router for liquidity provision.'}, {'Name': 'lpLockTime', 'Type': 'uint256', 'Purpose': 'Lock time for LP tokens, default to 48 hours.'}, {'Name': 'inventoryLockTime', 'Type': 'uint256', 'Purpose': 'Lock time for inventory tokens, default to 7 days.'}, {'Name': 'BASE', 'Type': 'uint256', 'Purpose': 'Constant used for token calculations, set to 10^18.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract with the given factory and router addresses.', 'Parameters': ['_nftxFactory', '_sushiRouter'], 'Returns': []}, {'Name': 'setLPLockTime', 'Visibility': 'external', 'Purpose': 'Allows the owner to set the lock time for LP tokens.', 'Parameters': ['newLPLockTime'], 'Returns': []}, {'Name': 'setInventoryLockTime', 'Visibility': 'external', 'Purpose': 'Allows the owner to set the lock time for inventory tokens.', 'Parameters': ['newInventoryLockTime'], 'Returns': []}, {'Name': 'provideInventory721', 'Visibility': 'public', 'Purpose': 'Enables users to provide ERC721 tokens to the inventory.', 'Parameters': ['vaultId', 'tokenIds'], 'Returns': []}, {'Name': 'provideInventory1155', 'Visibility': 'public', 'Purpose': 'Facilitates providing ERC1155 tokens to the inventory.', 'Parameters': ['vaultId', 'tokenIds', 'amounts'], 'Returns': []}, {'Name': 'addLiquidity721ETH', 'Visibility': 'public payable', 'Purpose': 'Adds liquidity using ERC721 tokens and Ether.', 'Parameters': ['vaultId', 'ids', 'minWethIn'], 'Returns': ['uint256']}, {'Name': 'addLiquidity721ETHTo', 'Visibility': 'public payable', 'Purpose': 'Adds liquidity with specified recipient using ERC721 tokens and Ether.', 'Parameters': ['vaultId', 'ids', 'minWethIn', 'to'], 'Returns': ['uint256']}, {'Name': 'addLiquidity1155ETH', 'Visibility': 'public payable', 'Purpose': 'Adds liquidity using ERC1155 tokens and Ether.', 'Parameters': ['vaultId', 'ids', 'amounts', 'minEthIn'], 'Returns': ['uint256']}, {'Name': 'addLiquidity1155ETHTo', 'Visibility': 'public payable', 'Purpose': 'Adds liquidity with specified recipient using ERC1155 tokens and Ether.', 'Parameters': ['vaultId', 'ids', 'amounts', 'minEthIn', 'to'], 'Returns': ['uint256']}, {'Name': 'addLiquidity721', 'Visibility': 'public', 'Purpose': 'Adds liquidity using ERC721 tokens and WETH.', 'Parameters': ['vaultId', 'ids', 'minWethIn', 'wethIn'], 'Returns': ['uint256']}, {'Name': 'addLiquidity721To', 'Visibility': 'public', 'Purpose': 'Adds liquidity with specified recipient using ERC721 tokens and WETH.', 'Parameters': ['vaultId', 'ids', 'minWethIn', 'wethIn', 'to'], 'Returns': ['uint256']}, {'Name': 'addLiquidity1155', 'Visibility': 'public', 'Purpose': 'Adds liquidity using ERC1155 tokens and WETH.', 'Parameters': ['vaultId', 'ids', 'amounts', 'minWethIn', 'wethIn'], 'Returns': ['uint256']}, {'Name': 'addLiquidity1155To', 'Visibility': 'public', 'Purpose': 'Adds liquidity with specified recipient using ERC1155 tokens and WETH.', 'Parameters': ['vaultId', 'ids', 'amounts', 'minWethIn', 'wethIn', 'to'], 'Returns': ['uint256']}, {'Name': 'transferFromERC721', 'Visibility': 'internal', 'Purpose': 'Transfers ERC721 tokens from the user to the specified address.', 'Parameters': ['assetAddr', 'tokenId', 'to'], 'Returns': []}, {'Name': 'approveERC721', 'Visibility': 'internal', 'Purpose': 'Approves the transfer of ERC721 tokens to a specified address.', 'Parameters': ['assetAddr', 'to', 'tokenId'], 'Returns': []}, {'Name': 'pairFor', 'Visibility': 'internal view', 'Purpose': 'Computes the address of the pair for two tokens.', 'Parameters': ['tokenA', 'tokenB'], 'Returns': ['address']}, {'Name': 'sortTokens', 'Visibility': 'internal pure', 'Purpose': 'Sorts two token addresses.', 'Parameters': ['tokenA', 'tokenB'], 'Returns': ['address', 'address']}, {'Name': 'rescue', 'Visibility': 'external', 'Purpose': 'Allows the owner to rescue tokens from the contract.', 'Parameters': ['token'], 'Returns': []}]}, 'SecurityAnalysis': {'PotentialVulnerabilities': ['Reentrancy risks are mostly mitigated with the use of the ReentrancyGuard modifier.', 'There are no explicit checks for integer overflows/underflows, but Solidity 0.8.0 has built-in checks.', 'Access control is well-defined using the Ownable pattern, though the rescue function requires careful monitoring.', 'There are loops in provideInventory functions that could theoretically consume excessive gas for large input arrays.', 'The contract handles Ether through WETH, mitigating direct Ether handling risks.'], 'MitigationRecommendations': ['Consider implementing a cap on the number of tokens processed in loops to prevent potential gas exhaustion.', 'Ensure the owner is a trusted entity, as they have critical control over contract settings and rescue functions.']}, 'ExternalInteractions': ['Interacts with WETH for Ether wrapping and unwrapping.', 'Calls to NFTX vaults for minting operations.', 'Uses SushiSwap router for liquidity provision.', 'Interacts with various token standards via IERC721, IERC1155Upgradeable, and IERC20Upgradeable.'], 'DesignPatternsAndMechanisms': ['The contract uses the Ownable design pattern for access control.', 'ReentrancyGuard is used to prevent reentrant calls.', 'The contract uses immutable variables for key external dependencies, enhancing security and gas efficiency.'], 'TestCoverageAndDocumentation': ['The code lacks inline comments, which would aid in understanding complex logic.', 'Test coverage is not indicated in the code snippet, but thorough testing is recommended, especially for DeFi interactions.'], 'Questions': ['How does the contract handle NFT standards that are not explicitly supported (e.g., non-standard ERC721/ERC1155)?', 'Are there any fallback mechanisms if external calls (e.g., minting or liquidity provision) fail?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability in Ether Transfer Functions', 'Severity': 'High', 'Description': 'The functions `addLiquidity721ETHTo` and `addLiquidity1155ETHTo` are vulnerable to reentrancy attacks. Despite using the `nonReentrant` modifier, they involve external Ether transfers using the `call` method, which can be exploited if the recipient contract contains a reentrancy vector.', 'Impact': 'Exploitation could lead to unauthorized re-execution of functions, draining of contract funds, or unintended state changes.', 'Location': 'Functions `addLiquidity721ETHTo` and `addLiquidity1155ETHTo`, lines 140-148, 173-181, 122-137, 154-168, 232, 259.'}, {'Issue': 'Improper Handling of External Calls', 'Severity': 'Medium', 'Description': 'Several functions perform external calls (e.g., token transfers) without checking the result of these calls, potentially leading to inconsistencies or funds being locked if the calls fail.', 'Impact': 'Failure in these calls could lead to an inconsistent contract state or financial losses for users.', 'Location': 'Throughout the contract, especially in functions involving token transfers like `provideInventory721`, `provideInventory1155`, `_addLiquidity721WETH`, `_addLiquidity1155WETH`, etc.'}, {'Issue': 'Potential Gas Exhaustion in Loops', 'Severity': 'High', 'Description': 'Functions `provideInventory721` and `provideInventory1155` contain loops over user-provided arrays that can be very large, risking block gas limit exhaustion and transaction failure.', 'Impact': 'Submitting large arrays could cause transactions to revert, making the contract unusable for large operations.', 'Location': 'Functions `provideInventory721` (lines 95-104) and `provideInventory1155` (lines 108-117).'}, {'Issue': 'Lack of Emergency Stop Mechanism', 'Severity': 'Medium', 'Description': 'The contract lacks a circuit breaker mechanism to halt operations in case of a detected vulnerability or emergency, risking continued exploitation.', 'Impact': 'In the event of an exploit, the contract would remain operational, potentially leading to further financial losses.', 'Location': 'Entire contract.'}], 'IssueNumber': 26, 'OutputList': 4}","---

### **[M-08] Low-level call return value not checked**

**Report Description**:  
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value to confirm if the call succeeded. This oversight can lead to silent failures in Ether transfers, potentially locking funds or causing inconsistencies in the contract's state. Solidity best practices recommend always checking the return value of low-level calls to ensure proper execution and mitigate risks.

---

**Match in Response List**:  
Matches with the issue titled **""Improper Handling of External Calls""** in the `response_list`.

---

**Validation**:  
**Correct**.  
The response in `response_list` under **""Improper Handling of External Calls""** partially addresses the issue. It correctly identifies the general problem of not checking the results of external calls, including token transfers, and highlights the potential risks of inconsistencies or locked funds. However, the response does not specifically address the low-level `.call` in the `addLiquidity721ETHTo` function or the specific risks associated with Ether transfers. Additionally, the response does not provide a detailed solution or mitigation strategy for this particular case.

---

**Suggestions**:  
1. The response should explicitly mention the low-level `.call` in the `addLiquidity721ETHTo` function and the associated risks of not checking its return value.  
2. Recommend a specific mitigation strategy, such as checking the return value of `.call` and reverting the transaction if the call fails. For example:  
   ```solidity
   (bool success, ) = payable(to).call{value: msg.value - amountEth}("""");
   require(success, ""Ether transfer failed"");
   ```
3. Emphasize the importance of handling low-level calls carefully, especially when transferring Ether, as they do not automatically revert on failure.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-08] Low-level call return value not checked**:  
  The response under **""Improper Handling of External Calls""** partially addresses the issue but lacks specificity regarding the low-level `.call` in `addLiquidity721ETHTo` and the associated risks of Ether transfers.

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- *None*

---",1,0,0,4.0,26.0,``` 1. Improper Handling of External Calls ```,"To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is `Improper Handling of External Calls`.
   - In the ranked predictions, `Improper Handling of External Calls` appears at rank 2.

2. **Calculate the precision at that rank**:
   - Precision at rank 2 (\( P@2 \)) is calculated as the number of true positives up to rank 2 divided by 2.
   - Since there is only one true positive up to rank 2, \( P@2 = \frac{1}{2} = 0.5 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the AP is simply \( P@2 = 0.5 \).

**Output**:
- **Average Precision (AP)**: 0.5"
,,,,,,,,,,,,,,,8,0,7,22.0,190.0,,
