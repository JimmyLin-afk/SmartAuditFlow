nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Detecting aspects,matchList,MAP
Wrappedlbbtc.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICoreOracle.sol"";

/*
    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)
*/
contract WrappedIbbtc is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 

    ICoreOracle public oracle;

    event SetOracle(address oracle);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == address(oracle), ""onlyOracle"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        oracle = ICoreOracle(_oracle);
        ibbtc = ERC20Upgradeable(_ibbtc);

        emit SetOracle(_oracle);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    function setOracle(address _oracle) external onlyGovernance {
        oracle = ICoreOracle(_oracle);
        emit SetOracle(_oracle);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Current pricePerShare read live from oracle
    function pricePerShare() public view virtual returns (uint256) {
        return oracle.pricePerShare();
    }

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare()).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare()).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare());
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare()).div(1e18);
    }
}",1204.0,156.0,"[H-01] The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool
Per the documentation, variables `wibBTC` is designed for a Curve StableSwap pool. However, the design of `wibBTC` makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.
Specifically, a Curve StableSwap pool will maintain the balances of its `coins` based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.
The pool's actual dynamic balance of `wibBTC` will deviate from the recorded balance in the pool contract as the pricePerShare increases.
Furthermore, there is no such way in Curve StableSwap similar to the `sync()` function of UNI v2, which will force sync the stored reserves to match the balances.
  [H-02] Approved spender can spend too many tokens
The `approve` function has not been overridden and therefore uses the internal shares, whereas transfer(From) uses the rebalanced amount.
Impact: The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with `pricePerShare`.
Many contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).
 
[H-04] `WrappedIbbtc` contracts do not filter out price feed outliers
If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics would be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.
  [M-01] Unable to transfer WrappedIbbtc if Oracle go down
In function `WrappedIbbtc`, user will not be able to transfer if `oracle.pricePerShare()` (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().
If this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it uses the cached value in a local variable pricePerShare, which is only updated upon call to updatePricePerShare().
  [M-02] Null check in `pricePerShare`
oracle can 0 as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: WrappedIbbtc.sol L148) resulting in Denial Of Service.
  [M-03] hard to clear balance
The contract does not allow users to `transfer` by share. Therefore, It is hard for users to clear out all the shares. There will be users using this token with Metamask and it is likely the `pricePerShare` would increase after the user sends transactions. I consider this is a medium-risk issue.
 
[M-04] No sanity check on `pricePerShare` might lead to lost value
`pricePerShare` is read either from an oracle or from ibBTC's core.
If one of these is bugged or exploited, there are no safety checks to prevent loss of funds. Impact: As pricePerShare is used to calculate transfer amount, a bug or wrong data retuning a smaller pricePerShare than it really is, could result in drainage of wibbtc from Curve pool.
",7.0,"pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICoreOracle.sol"";


contract WrappedIbbtc is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 

    ICoreOracle public oracle;

    event SetOracle(address oracle);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == address(oracle), ""onlyOracle"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        oracle = ICoreOracle(_oracle);
        ibbtc = ERC20Upgradeable(_ibbtc);

        emit SetOracle(_oracle);
    }

    
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    function setOracle(address _oracle) external onlyGovernance {
        oracle = ICoreOracle(_oracle);
        emit SetOracle(_oracle);
    }

    
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    

    
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    

    
    function pricePerShare() public view virtual returns (uint256) {
        return oracle.pricePerShare();
    }

    
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare()).div(1e18);
    }

    
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare()).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare());
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare()).div(1e18);
    }
}",811.0,3,4,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Mint and Burn Functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `mint` and `burn` functions are publicly accessible, allowing any user to mint or burn tokens freely, potentially leading to inflation or deflation of the token supply and economic instability."",
      ""Impact"": ""Unauthorized users could manipulate the token supply, leading to devaluation, financial loss, or contract integrity issues."",
      ""Location"": ""Functions `mint` and `burn`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The finding highlights a critical security flaw due to lack of access control, which could lead to severe consequences like inflation or unauthorized token burns. It is directly relevant and technically accurate.""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in Mint and Burn Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `mint` and `burn` functions involve external calls to the `ibbtc` contract before updating the contract's state, potentially allowing reentrancy attacks."",
      ""Impact"": ""An attacker could exploit the reentrancy vulnerability to manipulate the token supply or balances, leading to potential loss of funds."",
      ""Location"": ""Functions `mint` and `burn`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The sequence of external calls before state updates violates the Checks-Effects-Interactions pattern, making it susceptible to reentrancy attacks.""
    },
    {
      ""Issue"": ""Unchecked Return Value from Token Transfer Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `mint` and `burn` functions call `transferFrom` and `transfer` without checking the returned boolean value, potentially proceeding with incorrect state updates if the transfer fails."",
      ""Impact"": ""This could result in over-minting of tokens or user funds being lost, leading to discrepancies in token balances."",
      ""Location"": ""Functions `mint` and `burn`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Failing to check the transfer result can cause user funds to be lost, aligning with the task's focus on error handling.""
    },
    {
      ""Issue"": ""Potential Arithmetic Issues without SafeMath"",
      ""Severity"": ""High"",
      ""Description"": ""Arithmetic operations in functions like `balanceToShares` and `sharesToBalance` are performed without SafeMath, leading to potential overflow or underflow errors."",
      ""Impact"": ""Arithmetic errors could result in incorrect balance calculations, potentially leading to loss of funds or contract malfunction."",
      ""Location"": ""Functions `balanceToShares` and `sharesToBalance`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding addresses the risk of arithmetic errors in critical contract functions, directly relating to secure and correct functionality.""
    },
    {
      ""Issue"": ""Oracle Dependency without Fallback"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on an external oracle for the `pricePerShare` function without a defined fallback mechanism."",
      ""Impact"": ""If the oracle fails or is compromised, it could lead to incorrect price calculations and subsequent financial inaccuracies."",
      ""Location"": ""Function `pricePerShare`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding points out the dependency on external systems without safeguards, crucial for ensuring reliable and accurate function execution.""
    },
    {
      ""Issue"": ""Non-standard ERC20 Functionality in Transfer Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transfer` and `transferFrom` functions are overridden to use 'amountInShares' instead of the passed 'amount', deviating from standard ERC20 behavior."",
      ""Impact"": ""This could lead to confusion and unexpected behavior for users and integrators expecting standard ERC20 functionality."",
      ""Location"": ""Functions `transfer` and `transferFrom`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""This finding addresses compliance with ERC20 standards, which is a stated objective of the task.""
    },
    {
      ""Issue"": ""Reinitialization Vulnerability in `initialize` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `initialize` function uses the `initializer` modifier from OpenZeppelin's Initializable contract, but care must be taken during upgrades to prevent reinitialization vulnerabilities."",
      ""Impact"": ""Reinitialization can reset the contract's state, leading to loss of control over governance, disruption of the intended logic, or even fund loss."",
      ""Location"": ""Function `initialize`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Explicit checks for reinitialization can prevent potential misuse or misunderstandings.""
    }
  ],
  ""FindingNumber"": 7,
  ""AllRelevance"": 28,
  ""RelevanceCount"": 26,
  ""AllValidation"": 28,
  ""ValidationCount"": 26
}","### **Comparison of Issue Report and Response List**

---

#### **[H-01] The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool**

**Report Description**:  
The `wibBTC` token is designed for a Curve StableSwap pool, but its dynamic balance changes are unusual for an ERC20 token and incompatible with the pool's static balance management. The pool's recorded balance of `wibBTC` will deviate from its actual dynamic balance as `pricePerShare` increases. Additionally, there is no mechanism like UNI v2's `sync()` function to force synchronization of stored reserves with actual balances.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the incompatibility of `wibBTC` with Curve StableSwap pools or the lack of a synchronization mechanism. This issue is entirely missed.

---

#### **[H-02] Approved spender can spend too many tokens**

**Report Description**:  
The `approve` function uses internal `shares`, while `transfer(From)` uses the rebalanced amount. This discrepancy allows an approved spender to spend more tokens than intended, as the approved amount grows with `pricePerShare`. Contracts that use the same amount for `approve` and `transferFrom` calls may approve an excessively large amount.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `approve` and `transferFrom` discrepancies or the growing approved amount due to `pricePerShare`. This issue is entirely missed.

---

#### **[H-04] `WrappedIbbtc` contracts do not filter out price feed outliers**

**Report Description**:  
The contracts do not filter out manipulated or malfunctioning price feed data, exposing users to unsustainable price movements. This creates a substantial attack surface, and mitigation mechanics are needed to protect user economics.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the lack of price feed outlier filtering or the associated risks. This issue is entirely missed.

---

#### **[M-01] Unable to transfer `WrappedIbbtc` if Oracle goes down**

**Report Description**:  
Users cannot transfer `WrappedIbbtc` if `oracle.pricePerShare()` reverts, as `balanceToShares` calls `pricePerShare()` in both `transfer` and `transferFrom`. This behavior contrasts with `WrappedIbbtcEth`, which uses a cached `pricePerShare` value updated only upon calling `updatePricePerShare()`.

**Match in Response List**:  
**Oracle Dependency without Fallback**.

**Validation**:  
**Partially Correct**. The response identifies the dependency on the oracle but does not address the specific issue of transfer functionality being blocked if the oracle reverts. It also misses the comparison with `WrappedIbbtcEth`.

---

#### **[M-02] Null check in `pricePerShare`**

**Report Description**:  
If the oracle returns `0` for `pricePerShare`, it becomes the denominator in calculations, causing SafeMath reverts and Denial of Service.

**Match in Response List**:  
**Oracle Dependency without Fallback**.

**Validation**:  
**Partially Correct**. The response highlights the dependency on the oracle but does not address the specific risk of `0` as a denominator or the resulting Denial of Service.

---

#### **[M-03] Hard to clear balance**

**Report Description**:  
The contract does not allow users to `transfer` by share, making it difficult to clear out all shares. As `pricePerShare` increases, users may face challenges in sending transactions, especially when using tools like Metamask.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the difficulty of clearing balances or the lack of share-based transfers. This issue is entirely missed.

---

#### **[M-04] No sanity check on `pricePerShare` might lead to lost value**

**Report Description**:  
If `pricePerShare` is bugged or exploited, there are no safety checks to prevent loss of funds. A smaller `pricePerShare` than the actual value could result in drainage of `wibBTC` from the Curve pool.

**Match in Response List**:  
**Oracle Dependency without Fallback**.

**Validation**:  
**Partially Correct**. The response identifies the dependency on the oracle but does not address the specific risk of lost value due to incorrect `pricePerShare` or the potential drainage of `wibBTC` from the Curve pool.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-01] Unable to transfer `WrappedIbbtc` if Oracle goes down**  
- **[M-02] Null check in `pricePerShare`**  
- **[M-04] No sanity check on `pricePerShare` might lead to lost value**

**Missed Issues from Issue Report**:  
- **[H-01] The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool**  
- **[H-02] Approved spender can spend too many tokens**  
- **[H-04] `WrappedIbbtc` contracts do not filter out price feed outliers**  
- **[M-03] Hard to clear balance**

---

### **Conclusion**  
The response list partially addresses some issues related to oracle dependency but misses critical vulnerabilities and risks, such as the incompatibility of `wibBTC` with Curve StableSwap pools, the growing approved amount in `approve`, and the lack of price feed outlier filtering. Additionally, it does not address usability concerns like clearing balances. Significant gaps remain in the coverage of the provided issue report.",0,3,4,1,28,"```
None.
```",0.0
WrappedlbbtcEth.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICore.sol"";

/*
    Wrapped Interest-Bearing Bitcoin (Ethereum mainnet variant)
*/
contract WrappedIbbtcEth is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 
    
    ICore public core;

    uint256 public pricePerShare;
    uint256 public lastPricePerShareUpdate;

    event SetCore(address core);
    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _core) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        core = ICore(_core);
        ibbtc = ERC20Upgradeable(_ibbtc);

        updatePricePerShare();

        emit SetCore(_core);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    /// @dev The ibBTC token is technically capable of having it's Core contract changed via governance process. This allows the wrapper to adapt.
    /// @dev This function should be run atomically with setCore() on ibBTC if that eventuality ever arises.
    function setCore(address _core) external onlyGovernance {
        core = ICore(_core);
        emit SetCore(_core);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Update live ibBTC price per share from core
    /// @dev We cache this to reduce gas costs of mint / burn / transfer operations.
    /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date
    function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare).div(1e18);
    }
}",1337.0,164.0,"[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if `updatePricePerShare` wasn't run properly
Malicious user can monitor `SetPricePerShare` event and, if it was run long enough time ago and market moved, but, since there were no `SetPricePerShare` fired, the contract's `pricePerShare` is outdated, so a user can `mint()` with `pricePerShare` that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.
  [H-04] WrappedIbbtcEth contracts do not filter out price feed outliers
If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics would be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.",2.0,"pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICore.sol"";


contract WrappedIbbtcEth is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 
    
    ICore public core;

    uint256 public pricePerShare;
    uint256 public lastPricePerShareUpdate;

    event SetCore(address core);
    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _core) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        core = ICore(_core);
        ibbtc = ERC20Upgradeable(_ibbtc);

        updatePricePerShare();

        emit SetCore(_core);
    }

    
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    
    
    function setCore(address _core) external onlyGovernance {
        core = ICore(_core);
        emit SetCore(_core);
    }

    
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    

    
    
    
    function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

    
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    

    
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare).div(1e18);
    }

    
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare).div(1e18);
    }
}",854.0,2,0,"{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Mint and Burn Functions"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `mint` and `burn` functions are publicly accessible, allowing any user to mint or burn tokens without restrictions. This can lead to unauthorized changes in the token supply."",
      ""Impact"": ""Malicious users could inflate or deflate the token supply, resulting in financial loss and token instability."",
      ""Location"": ""Functions `mint` and `burn`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The functions lack access control, allowing any user to impact the token supply, which is a critical security concern.""
    },
    {
      ""Issue"": ""Potential Reentrancy in Burn Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `burn` function transfers tokens after burning shares, potentially exposing the contract to reentrancy attacks if the token is not secure."",
      ""Impact"": ""An attacker could exploit a reentrancy vulnerability to manipulate balances, leading to financial loss."",
      ""Location"": ""Function `burn`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The sequence in the burn function could lead to reentrancy issues, especially if the token is not safe.""
    },
    {
      ""Issue"": ""Potential Arithmetic Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract performs arithmetic operations without SafeMath, risking overflows or underflows in functions like `balanceOf`, `totalSupply`, `balanceToShares`, and `sharesToBalance`."",
      ""Impact"": ""Arithmetic errors could lead to incorrect calculations, resulting in financial discrepancies."",
      ""Location"": ""Functions `balanceOf`, `totalSupply`, `balanceToShares`, `sharesToBalance`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""The absence of SafeMath can lead to arithmetic vulnerabilities in older Solidity versions.""
    },
    {
      ""Issue"": ""No Event Emission for Critical Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions such as `mint` and `burn` do not emit events after execution, hindering transparency and tracking of critical state changes."",
      ""Impact"": ""Lack of event emissions complicates auditing and monitoring efforts, reducing transparency."",
      ""Location"": ""Functions `mint` and `burn`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Events are crucial for tracking operations on-chain, and their absence is a valid concern.""
    },
    {
      ""Issue"": ""Use of Deprecated `now` for Timestamp"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `now`, which is deprecated in newer Solidity versions. It is recommended to use `block.timestamp` for better compatibility."",
      ""Impact"": ""Using deprecated features can lead to compatibility issues with future Solidity versions."",
      ""Location"": ""Function `updatePricePerShare`"",
      ""Relevance"": true,
      ""Validation"": true,
      ""Note"": ""Switching from `now` to `block.timestamp` is advisable for future-proofing.""
    }
  ],
  ""FindingNumber"": 5,
  ""AllRelevance"": 58,
  ""RelevanceCount"": 50,
  ""AllValidation"": 58,
  ""ValidationCount"": 50
}","### **Output**

---

**[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if `updatePricePerShare` wasn't run properly**

**Report Description**:
The `WrappedIbbtcEth` contract relies on the `pricePerShare` value for minting and burning tokens. If the `updatePricePerShare` function is not executed regularly, the `pricePerShare` value may become outdated. A malicious user can monitor the `SetPricePerShare` event and exploit the outdated price by minting tokens at the stale price and burning them after the price is updated, resulting in risk-free profit at the expense of the contract's holdings.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of outdated `pricePerShare` values or the potential for exploitation through minting and burning at stale prices. This is a critical oversight, as the issue poses a significant financial risk to the contract.

---

**[H-04] WrappedIbbtcEth contracts do not filter out price feed outliers**

**Report Description**:
The `WrappedIbbtcEth` contract does not implement any mechanism to filter out outliers in the price feed. If the price feed is manipulated or experiences volatility due to market malfunctions, the contract will pass these anomalies on to users. This creates a substantial attack surface, as malicious actors could exploit price outliers to manipulate the contract's operations. Implementing mitigation mechanics would ensure that only sustainable price movements affect user economics.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of price feed outliers or the need for mitigation mechanisms. This is a significant gap, as the issue highlights a critical vulnerability that could be exploited by malicious actors.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if `updatePricePerShare` wasn't run properly**
- **[H-04] WrappedIbbtcEth contracts do not filter out price feed outliers**

---

### **Conclusion**
The `response_list` does not adequately address the issues raised in the `issue` report. Both **[H-03]** and **[H-04]** highlight critical vulnerabilities related to price management and manipulation, which are not covered in the response list. This indicates a significant gap in the security analysis and recommendations provided.",0,0,2,5,58,"```
None.
```",0.0
,,,,,,,,5,4,,,0,3,6,6,86,,
