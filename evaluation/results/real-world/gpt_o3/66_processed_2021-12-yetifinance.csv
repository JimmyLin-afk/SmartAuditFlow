nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Reasoning,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
StabilityPool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a ""compounded deposit"": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositor’s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a ""feedback"" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate ""per-unit-staked"" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a ""feedback"" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate ""per-unit-staked"" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want ""slightly too much"" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P ""favors the Pool"", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",12382.0,1177.0,"[H-01] receiveCollateral() can be called by anyone
In StabilityPool.sol, the `receiveCollateral()` function should be called by ActivePool per comments, but anyone can call it passing in `_tokens` and `_amounts` args to update stability pool balances.",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";



contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    
    ISortedTroves internal sortedTroves;

    
    uint256 internal totalYUSDDeposits;

    
    
    
    newColls internal totalColl;

    

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; 

    
    mapping(address => Snapshots) public depositSnapshots; 

    mapping(address => FrontEnd) public frontEnds; 
    mapping(address => uint256) public frontEndStakes; 
    mapping(address => Snapshots) public frontEndSnapshots; 

    
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    
    uint128 public currentScale;

    
    uint128 public currentEpoch;

    
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    
    uint256 public lastYETIError;
    
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    

    
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    

    
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        
        
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; 
        
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    

    
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; 
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); 
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    


    
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; 
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    

    
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    
    
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    
    
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    

    
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    
    
    
    
    
    
    
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            
            compoundedStake = 0;
        }

        
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    

    
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    

    
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    
    
    
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",7250.0,1,0,"Evaluating smart contract security
I’m working through the user's request to analyze and list vulnerabilities in a smart contract. This involves examining Solidity code for potential security flaws, providing a thorough and insightful overview.
Identifying vulnerabilities
I’m analyzing the specified Solidity code of the smart contract to pinpoint security weaknesses. This requires a detailed review of the code's structure and logic to ensure a thorough evaluation.
Listing vulnerabilities
I’m compiling a list of vulnerabilities in the smart contract code, focusing on accurately identifying weaknesses without including mitigations. This process ensures a thorough understanding of the code's security posture.
Focusing on vulnerabilities
I'm detailing the security flaws in the smart contract code, emphasizing thorough documentation of weaknesses without suggesting fixes. This approach highlights both the need for and potential areas of improvement.
","Here is a list of potential vulnerabilities in the provided smart contract:

1. **Reentrancy Vulnerabilities**:
   - The functions that involve transferring tokens (`_sendGainsToDepositor`, `_sendYUSDtoStabilityPool`, and `_sendYUSDToDepositor`) may be vulnerable to reentrancy attacks, especially if the token contracts being interacted with do not have checks to prevent reentrancy.

2. **Access Control Issues**:
   - The `_requireCallerIsWhitelist`, `_requireCallerIsActivePool`, and `_requireCallerIsTML` functions only check the caller addresses without ensuring they are properly set or modified. This could lead to unauthorized access if these addresses are manipulated.
   - The use of `onlyOwner` in `setAddresses` could also be problematic if the owner account is compromised, as it grants control over key addresses.

3. **Lack of Proper Validation in Functions**:
   - The function `_decreaseYUSD` does not perform validation for ensuring the `totalYUSDDeposits` is sufficient before attempting to decrease it.
   - Functions like `getCollateral` and `getAllCollateral` assume the collateral index is valid without ensuring that the `_collateral` passed is part of the allowed collateral list in the whitelist.
   - The function `offset` doesn't validate the length of the input arrays `_tokens` and `_amountsAdded`. If the arrays have different lengths, it could result in unexpected behavior.

4. **Integer Overflow/Underflow**:
   - While SafeMath is used in some parts of the contract, integer overflow or underflow could still occur in functions where the math operations aren't protected, such as `getCompoundedYUSDDeposit`, and `getCompoundedFrontEndStake`. Although `LiquitySafeMath128` is used in some places, not all the functions are fully covered.

5. **Potential for Dividing by Zero**:
   - The function `_computeYETIPerUnitStaked` could result in a division by zero error if `totalYUSDDeposits` is zero, which is not properly handled in all places. Specifically, when `totalYUSDDeposits` is zero, there could be errors in subsequent calculations like `_updateG`.

6. **Unprotected State Changes**:
   - The `_updateDepositAndSnapshots` function updates the state variables related to a depositor's information without any access control. This allows any user to modify their own deposit details, but care should be taken when modifying the contract state based on user actions to prevent abuse.

7. **Improper Validation of Front-End Registration**:
   - In the `registerFrontEnd` function, the `_requireValidKickbackRate` check ensures that the kickback rate is valid, but there could still be other edge cases where front-end addresses are registered incorrectly or maliciously without proper restrictions on kickback rates.

8. **Misuse of `msg.sender`**:
   - Functions like `_requireCallerIsActivePool`, `_requireCallerIsWhitelist`, `_requireCallerIsTML`, etc., compare `msg.sender` to hardcoded addresses. If these addresses are incorrect or compromised, it could cause the contract to accept unauthorized actions.

9. **Excessive Gas Consumption**:
   - Some functions involve complex logic with loops or mappings (such as `getDepositorGains`, `getDepositorYETIGain`, and `_calculateGains`) which could lead to excessive gas usage, making them prohibitively expensive for end users in certain conditions.

10. **Lack of `require` Statements for Array Length Matching**:
   - Functions such as `addCollateralType` and `receiveCollateral` assume that the lengths of the `_tokens` and `_amounts` arrays match, but there is no explicit validation to check this. This could lead to mismatches and unintended behaviors if the arrays don't match in length.

11. **Unreliable Handling of Zero Values**:
   - In several places, the contract doesn't properly handle cases where certain variables are zero, potentially leading to logical errors or unnecessary transactions (e.g., `totalYUSDDeposits`, `_debtToOffset`, and `initialDeposit` can be zero, but they might still be involved in operations without checks).

12. **Missed Event Emissions**:
   - While some state-changing actions are appropriately logged, others, such as updating `frontEndStakes`, don't always emit events. Missing events could make it harder to track contract interactions and state changes.

13. **Uncontrolled `P` Value**:
   - The parameter `P` is subject to changes without thorough validation or constraints. If the value of `P` is manipulated inappropriately, it could have cascading effects on the entire system.","### **[H-01] receiveCollateral() can be called by anyone**

**Report Description**:
In `StabilityPool.sol`, the `receiveCollateral()` function is intended to be called exclusively by the `ActivePool`, as indicated by the comments. However, the function lacks proper access control, allowing anyone to call it by passing in `_tokens` and `_amounts` arguments. This can lead to unauthorized updates to the stability pool balances, potentially causing discrepancies and security vulnerabilities.

**Match in Response List**:
Matches with the issue titled **""Access Control Issues""**.

**Validation**:
**Correct**. The response identifies access control issues in the contract, specifically mentioning that functions like `_requireCallerIsActivePool` and `_requireCallerIsWhitelist` only check caller addresses without ensuring they are properly set or modified. This aligns with the issue in `receiveCollateral()`, where the lack of proper access control allows unauthorized calls. The response accurately captures the risk of unauthorized access and manipulation of contract state, which is consistent with Solidity best practices for secure contract design.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] receiveCollateral() can be called by anyone**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

--- 

This evaluation confirms that the response list adequately addresses the issue in the report, identifying the access control vulnerability and its potential impact.",1,0,0,13,"```
1. Access Control Issues
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Access Control Issues"".
   - In the ranked list of predictions, ""Access Control Issues"" appears at rank 2.

2. **Calculate the precision at rank 2 (\( P@2 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 2, there is 1 true positive.
   - \( P@2 = \frac{1}{2} = 0.5 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.5 \).

**Output**:
```
0.5
```"
sYetiToken.sol,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}

// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)
// modified by BoringCrypto for DictatorDAO


// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 
// Each rebase increases the effective yetibalance by a certain amount of the total value
// of the contract, which is equal to the yusd balance + the last price which the buyback 
// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200
// of the total value of the contract is added to the effective yetibalance. Also updated on 
// mint and withdraw, because that is actual value that is added to the contract. 

contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain
    // and do that one. 
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    /// @notice owner > balance mapping.
    mapping(address => User) public users;
    /// @notice owner > spender > allowance mapping.
    mapping(address => mapping(address => uint256)) public override allowance;
    /// @notice owner > nonce mapping. Used in `permit`.
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); // Moved down so other failed calls safe some gas
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; // Underflow is checked
                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; // Underflow is checked
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.
    /// @param to The address to move the tokens.
    /// @param shares of the tokens to move.
    /// @return (bool) Returns True if succeeded.
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.
    /// @param from Address to draw tokens from.
    /// @param to The address to move the tokens.
    /// @param shares The token shares to move.
    /// @return (bool) Returns True if succeeded.
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18
    /// theoretically you can grow the amount/share ratio, but it's not practical and useless
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    /** 
     * Buyback function called by owner of function. Keeps track of the 
     */
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    /** 
     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.
     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock 
     * in order to activate. 
     * No YUSDToSell param since this just does 5% of the YUSD in the contract.
     */
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        // Get 5% of the YUSD in the contract
        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. 
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        // Checks internal mapping to see if router is valid
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    // Rebase function for adding new value to the sYETI - YETI ratio. 
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns 
        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance

        // raw balance of the contract
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        // amount of YETI free / available to give out
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        // in YETI, amount that should be eligible to give out.
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        // in YETI, amount to rebase
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. 
        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        // rebase amount joins the effective supply. 
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        // update rebase time
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    // Sums YUSD balance + old price. 
    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI 
    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    // Sets new transfer ratio for rebasing
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    // TODO - add time delay for setting new valid router. 
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    // TODO - add time delay for invalidating router. 
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    // Safe divide
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",3595.0,338.0,"[H-02] Yeti token rebase checks the additional token amount incorrectly
function `rebuse`, `effectiveYetiTokenBalance`
`yetiToken.balance - effectiveYetiTokenBalance`
The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added to effectiveYetiTokenBalance during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.
The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users’ claims. In other words, the contract will be in default if enough users claim after that.
 
[M-01] Wrong `lastBuyBackPrice`
The `sYETIToken.lastBuyBackPrice` is set in `buyBack` and hardcoded as:
“function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner “
It divides the first and second return `amounts` of the swap, however, these amounts depend on the swap path parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).",2.0,"pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}












contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    
    
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    
    mapping(address => User) public users;
    
    mapping(address => mapping(address => uint256)) public override allowance;
    
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); 
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; 
                users[to].balance = toUser.balance + shares128; 
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; 
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    
    
    
    
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    
    
    
    
    
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    
    
    
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    
    
    
    
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    
    
    
    
    
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    
    
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); 
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        
        
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        
        

        
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        
        
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    
    
    
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",2343.0,1,1,"Spotting weaknesses
I'm listing vulnerabilities in a smart contract now, so let's break this down together.
Pinpointing security issues
I'm tasked with identifying vulnerabilities in a smart contract, assessing its code for potential security flaws. Let's methodically break down each component to ensure clarity.
Shining a light on security
I'm digging into vulnerabilities in smart contract code, meticulously highlighting areas that might pose security or functionality risks.
Highlighting vulnerabilities
Taking a closer look at vulnerabilities in the smart contract, examining each aspect carefully to ensure precise identification of security issues.
","Here are the potential vulnerabilities in the provided smart contract:

1. **Reentrancy Attack (in `burn`, `burnFrom`, `_burn` functions)**:
   - While not immediately obvious, functions that interact with external contracts (like `yetiToken.transfer()` and `yetiToken.sendToSYETI()`) could be susceptible to reentrancy attacks, especially when they update the state variables before making external calls. If an external contract is called and it tries to call back into the contract during the transaction (reentrancy), it could lead to unexpected results.

2. **Lack of a SafeMath Library for Division (in `div` function)**:
   - The custom `div` function handles division but lacks protection against division by zero. Although it has a `require` statement to prevent this, it's not as robust as using a well-established SafeMath library, which may be more foolproof in edge cases.

3. **Timestamp Dependence (in `rebase` and `publicBuyBack` functions)**:
   - Both functions rely on `block.timestamp` for important logic (e.g., limiting how often they can be called). This can be manipulated by miners within a small range and might introduce unexpected behavior if the block time is manipulated. The use of `block.timestamp` for critical checks should be carefully considered.

4. **Owner Control (in functions like `setAddresses`, `setTransferRatio`, `addValidRouter`, etc.)**:
   - Several critical functions like `setAddresses`, `setTransferRatio`, and `addValidRouter` are controlled solely by the owner, which gives the owner significant power over the contract. If the owner's private key is compromised, it could result in malicious actions like transferring all funds or modifying key parameters.

5. **Insecure Approval Logic (in `permit` and `approve` functions)**:
   - The `permit` function is based on EIP-2612, but it doesn't implement proper nonce handling to prevent double-spending of approvals. The `nonces[owner_]++` could potentially be manipulated or replayed in a malicious attack.
   - The `approve` function does not guard against the ""race condition"" vulnerability, where if someone approves an amount and another spender quickly transfers before the approval change, this can result in unintended transfers.

6. **Untrusted Contract Calls (in `buyBack` and `_buyBack` functions)**:
   - The contract relies on external calls to untrusted router contracts (`_routerAddress`). If an attacker is able to inject their own contract into the `validRouters` mapping or gain control of a router, they could execute malicious code through these functions.

7. **Hardcoded Time Delays (in `publicBuyBack` and `rebase` functions)**:
   - The `publicBuyBack` function allows a buyback to occur every 169 hours, while the `rebase` function has a limit of 8 hours between executions. These hardcoded delays may not be flexible enough if the system needs adjustments or if there is an emergency requiring a change in timing.

8. **Potential Overflow/Underflow Risk in `balanceOf` and `mint` Functions**:
   - Although the contract uses `BoringMath` for most operations, there is still a risk of overflow/underflow in certain parts of the contract, especially where unchecked math happens, such as in balance updates or token minting. The use of `uint128` for balances could also be problematic in some cases if balances exceed the max value for a `uint128`.

9. **Lack of Event Emissions for Key Functions**:
   - Some functions (e.g., `setTransferRatio`, `addValidRouter`) modify state variables but do not emit events to indicate that these critical parameters have been changed. This could lead to tracking and auditability issues.

10. **`_buyBack` Approvals and Potential for Spender's Loss of Funds**:
    - The contract explicitly calls `yusdToken.approve()` with a value of 0, which could potentially interfere with other approvals made by other contracts interacting with the same token. 

11. **Invalid Router Address (in `addValidRouter` function)**:
    - The `addValidRouter` function lacks a check to ensure the router address is not already in the list of valid routers, potentially leading to unnecessary state changes.","### **[H-02] Yeti token rebase checks the additional token amount incorrectly**

**Report Description**:
The `rebuse` function in the contract incorrectly checks the additional token amount by using the entire balance (`yetiToken.balance - effectiveYetiTokenBalance`) instead of the actual Yeti tokens bought back from the market. This oversight allows the amount added to `effectiveYetiTokenBalance` during rebase to exceed the actual amount of Yeti tokens owned by the contract. This discrepancy can lead to a deficit in Yeti tokens, especially if the price of Yeti tokens increases. In such a scenario, users may be unable to withdraw their tokens, as the contract's net holdings would be less than the total claims, potentially leading to default.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect token amount checks during rebase. This is a critical vulnerability that could lead to financial discrepancies and contract default, but it is entirely missed in the response list.

---

### **[M-01] Wrong `lastBuyBackPrice`**

**Report Description**:
The `lastBuyBackPrice` in `sYETIToken` is set in the `buyBack` function by dividing the first and second return `amounts` of the swap. However, this calculation assumes a swap path of length 2 and that all routers sort pairs the same way (e.g., Uniswap/Sushiswap). If a swap path of length 3 is used, the calculation becomes incorrect. This could lead to inaccurate pricing data, affecting the contract's financial logic and potentially leading to incorrect token valuations.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect `lastBuyBackPrice` calculation due to assumptions about swap paths and router behavior. This is a significant oversight, as it could lead to incorrect financial calculations and potential exploitation.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-02] Yeti token rebase checks the additional token amount incorrectly**
- **[M-01] Wrong `lastBuyBackPrice`**

---

### **Conclusion**
The response list fails to address two critical issues from the issue report: the incorrect token amount check during rebase and the flawed `lastBuyBackPrice` calculation. Both issues have significant implications for the contract's financial integrity and user trust. The response list focuses on other vulnerabilities but misses these key concerns, indicating a gap in the coverage and accuracy of the responses.",0,0,2,11,"```
None.
```","The **Average Precision (AP)** for the query is **0.0**.

### Explanation:
Since there are no true positives in the provided list (`true_positives` is empty), there are no ranks at which true positives appear. Therefore, the precision at any rank is undefined, and the **Average Precision (AP)** is **0.0**."
PriceFeed.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";


/*
* PriceFeed for mainnet deployment, to be connected to Chainlink's live Collateral:USD aggregator reference
* contract, and a wrapper contract TellorCaller, which connects to TellorMaster contract.
*
* The PriceFeed uses Chainlink as primary oracle, and Tellor as fallback. It contains logic for
* switching oracles based on oracle failures, timeouts, and conditions for returning to the primary
* Chainlink oracle.
*/
contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  // Mainnet Chainlink aggregator
    ITellorCaller public tellorCaller;  // Wrapper contract that calls the Tellor system

    // Core Liquity contracts
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    // Use to convert a price answer to an 18-digit precision uint
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.
    uint constant public TIMEOUT = 14400;  // 4 hours: 60 * 60 * 4

    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; // 50%

    /*
    * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed
    * to return to using the Chainlink oracle. 18-digit precision.
    */
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%

    // The last good price seen from an oracle by Liquity
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    // --- Dependency setters ---

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        // Explicitly set initial system status
        status = Status.chainlinkWorking;

        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    // --- Functions ---

    /*
    * fetchPrice():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail,
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice() external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen, switch to Tellor and return last good price
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                /*
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is working and Tellor is broken, remember Tellor is broken
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            // If Chainlink is working, return Chainlink current price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }


        // --- CASE 2: The system fetched last price from Tellor ---
        if (status == Status.usingTellorChainlinkUntrusted) {
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // Otherwise, use Tellor price
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                return _storeTellorPrice(tellorResponse);
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
        if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted,
            // return Chainlink price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    // --- Functions ---

    /*
    * fetchPrice_vce_v():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail, 
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice_v() view external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                // If Tellor is frozen, switch to Tellor and return last good price 
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                /* 
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink 
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            // If Chainlink is working, return Chainlink current price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        // --- CASE 2: The system fetched last price from Tellor --- 
        if (status == Status.usingTellorChainlinkUntrusted) { 
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            // Otherwise, use Tellor price
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
         if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch 
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted, 
            // return Chainlink price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    // --- Helper functions ---

    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round
    * for two reasons:
    *
    * 1) It is necessary data for the price deviation check in case 1,
    * and
    * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds
    * peace of mind when using or returning to Chainlink.
    */
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid roundId that is 0
        if (_response.roundId == 0) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for non-positive price
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        /*
        * Use the larger price as the denominator:
        * - If price decreased, the percentage deviation is in relation to the the previous price.
        * - If price increased, the percentage deviation is in relation to the current price.
        */
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        // Return true if price has more than doubled, or more than halved.
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for zero price
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        // Return false if either oracle is broken or frozen
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        /*
        * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting
        * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.
        */
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        /*
        * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by Liquity.
        * At date of Liquity launch, Chainlink uses an 8-digit price, but we also handle the possibility of
        * future changes.
        *
        */
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            // Scale the returned price value down to Liquity's target precision
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            // Scale the returned price value up to Liquity's target precision
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    // --- Oracle response wrapper functions ---

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            // If call to Tellor succeeds, return the response and success = true
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            // If call to Tellor reverts, return a zero response with success = false
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        // First, try to get current decimal precision:
        try priceAggregator.decimals() returns (uint8 decimals) {
            // If call to Chainlink succeeds, record the current decimal precision
            chainlinkResponse.decimals = decimals;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }

        // Secondly, try to get latest price data:
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        /*
        * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a
        * previous round.  We assume the decimals used in the previous round are the same as the current round.
        */

        // Try to get the price data from the previous round:
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return prevChainlinkResponse;
        }
    }
}",7613.0,799.0,"[M-02] Should check return data from Chainlink aggregators
Function `_getCurrentChainlinkResponse`, no checks on `lastRoundData`
The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.
Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";



contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  
    ITellorCaller public tellorCaller;  

    
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    
    uint constant public TIMEOUT = 14400;  

    
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; 

    
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; 

    
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        
        status = Status.chainlinkWorking;

        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    

    
    function fetchPrice() external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                
                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            
            return _storeChainlinkPrice(chainlinkResponse);
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    

    
    function fetchPrice_v() view external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) { 
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
         if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    

    
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.roundId == 0) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        
        try priceAggregator.decimals() returns (uint8 decimals) {
            
            chainlinkResponse.decimals = decimals;
        } catch {
            
            return chainlinkResponse;
        }

        
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        

        
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            
            return prevChainlinkResponse;
        }
    }
}",4598.0,0,1,"Pulling together vulnerabilities
I’m thinking through the task of listing all vulnerabilities in a given smart contract. This involves careful examination and listing the identified vulnerabilities.
Mapping out the response
I’m thinking about a strategy to list all vulnerabilities in the smart contract without suggesting mitigations, ensuring a thorough and unbiased assessment.
Charting the course
Piecing together a comprehensive list of vulnerabilities in the smart contract, evaluating each one carefully to ensure a thorough understanding without suggesting mitigations.
Formulating the plan
I’m gathering information to list all vulnerabilities in the smart contract, ensuring a comprehensive assessment without suggesting mitigations. This approach lays out a thorough strategy for addressing each identified risk.
","Here is a list of potential vulnerabilities in the provided smart contract:

1. **Reentrancy Attack**: There is no explicit protection against reentrancy attacks, especially in functions where external calls are made (e.g., calling `tellorCaller.getTellorCurrentValue` and `priceAggregator.latestRoundData`). While it may not be as critical in the current context, it could still be a vector for malicious manipulation.

2. **Use of `block.timestamp`**: The contract relies on `block.timestamp` for determining timeouts and other time-dependent logic. This could be manipulated by miners (although it would require significant effort). Using a more secure and reliable time source or introducing more stringent checks can help mitigate this.

3. **Lack of Input Validation in `setAddresses`**: The `setAddresses` function allows the owner to set the addresses for the price aggregator and Tellor caller. There is a check to validate the contract addresses (`checkContract`), but the contract does not ensure that these addresses correspond to actual, working implementations of the required interfaces. If an invalid or malicious address is set, it could result in incorrect or malicious behavior.

4. **Lack of Access Control**: While the `setAddresses` function is protected by the `onlyOwner` modifier, the contract does not enforce strong enough control over other critical state-changing operations. For example, a malicious owner could modify core parameters, leading to unauthorized price feeds.

5. **Insecure `lastGoodPrice` Handling**: The `lastGoodPrice` is stored and returned when oracle responses are not trustworthy, but there is no mechanism to protect the integrity of this value. A malicious actor could manipulate the `lastGoodPrice` by exploiting vulnerabilities in the oracle responses or by re-entering values under certain conditions.

6. **Outdated `SafeMath` Version**: The contract uses `SafeMath` for handling mathematical operations, but the latest versions of Solidity (>=0.8) have built-in overflow checks. Using SafeMath is redundant and may add unnecessary gas costs.

7. **No Gas Optimization in `if` Conditionals**: In functions like `fetchPrice` and `fetchPrice_v`, there are several nested `if` conditions that can be simplified. Some redundant checks can be combined or streamlined for better gas optimization and clarity.

8. **Oracle Dependency**: The contract is heavily reliant on external oracles (Chainlink and Tellor). If any of these services become unavailable or provide faulty data, the contract's logic could be compromised. This risk is partially mitigated by using fallback mechanisms, but the reliance on external data sources introduces a centralization risk.

9. **No Fallback for Oracle Failures**: If both oracles fail, the contract returns `lastGoodPrice`. While this ensures some continuity, it may be an issue if the last known good price is outdated or incorrect. The contract could have additional safety mechanisms for handling prolonged outages or discrepancies between oracles.

10. **Inconsistent Error Handling**: Some functions use a `try-catch` mechanism (e.g., `_getCurrentTellorResponse`, `_getCurrentChainlinkResponse`), while others do not. This inconsistency could lead to unpredictable behavior or missed exceptions in some cases.

11. **Event Emission Risk**: The contract emits events (`LastGoodPriceUpdated`, `PriceFeedStatusChanged`) whenever certain state changes occur. While this is useful for tracking, it could also be abused by an attacker to flood the logs with unnecessary events, potentially making it harder to track meaningful information.

12. **Potential for Incorrect Price Calculations**: The contract includes logic for price scaling and comparisons between oracles. If either the Chainlink or Tellor price deviates significantly or returns incorrect values, there could be cases where the price is improperly scaled or stored.

13. **Lack of Complete Failover Mechanism**: In cases where both oracles are untrusted or broken, the contract does not have a clear strategy to determine which price feed should be trusted more. A more robust failover mechanism or a multi-signature approach could be considered to avoid single points of failure.

14. **No Mechanism for Reverting State Changes**: If one of the oracle responses is found to be faulty after a price has been updated, there is no mechanism for rolling back or reverting the state changes to ensure consistency.","### **[M-02] Should check return data from Chainlink aggregators**

**Report Description**:  
The function `_getCurrentChainlinkResponse` in `PriceFeed.sol` fetches the asset price from a Chainlink aggregator using the `latestRoundData` function. However, it does not check the `roundID` or other critical return values (e.g., `answeredInRound`, `timestamp`). According to Chainlink's documentation, this function does not error if no answer has been reached but returns 0, which could lead to stale or incorrect prices being fed into the system. This introduces risks such as outdated data being used in price calculations, potentially compromising the integrity of the liquidity system. The reliance on external Chainlink oracles also introduces inherent risks, as the oracle could fail or fall behind, leading to incorrect index price calculations.

**Match in Response List**:  
Matches with the issue titled **""Oracle Dependency""** and **""No Fallback for Oracle Failures""**.

**Validation**:  
**Partially Correct**.  
- The response **""Oracle Dependency""** correctly identifies the risk of relying on external oracles like Chainlink, which aligns with the issue's concern about stale or incorrect data. However, it does not specifically address the lack of checks on `roundID` or other return values from `latestRoundData`.  
- The response **""No Fallback for Oracle Failures""** partially addresses the issue by mentioning the reliance on `lastGoodPrice` as a fallback. However, it does not explicitly discuss the risks of stale data or the need to validate `roundID` and other return values.  
While both responses touch on aspects of the issue, they miss critical details about the specific vulnerabilities in handling Chainlink's `latestRoundData` return values.  

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*  

**Partially Correct Matches**:  
- **[M-02] Should check return data from Chainlink aggregators**  

**Missed Issues from Issue Report**:  
- *None*  

--- 

**Analysis**:  
The `response_list` partially addresses the issue by highlighting the risks of oracle dependency and the lack of fallback mechanisms. However, it does not fully capture the specific vulnerability of failing to validate `roundID` and other return values from Chainlink's `latestRoundData` function. This gap could lead to stale or incorrect prices being used in the system, which is a critical security concern. To improve the response, it should explicitly recommend validating `roundID`, `timestamp`, and `answeredInRound` to ensure the data is fresh and reliable.",0,1,0,14,"```
None.
```",0.0
ActivePool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";

/*
 * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.
 *
 * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the
 * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.
 *
 */
contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts 
    newColls internal poolColl;

    // YUSD Debt tracker. Tracker of all debt in the system. 
    uint256 internal YUSDDebt;

    // --- Events ---

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    // --- Internal Functions ---

    // --- Getters for public variables. Required by IPool interface ---

    /*
    * Returns the collateralBalance for a given collateral
    *
    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.
    */
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    /*
    * Returns all collateral balances in state. Not necessarily the contract's actual balances.
    */
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    // returns the VC value of a given collateralAddress in this contract
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    /*
    * Returns the VC of the contract
    *
    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.
    *
    * Computed when called by taking the collateral balances and
    * multiplying them by the corresponding price and ratio and then summing that
    */
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    // Debt that this pool holds. 
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    // --- Pool functionality ---

    // Internal function to send collateral to a different pool. 
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. 
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.
    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,
    // It also harvests rewards on the user's behalf. 
    // _from is where the reward balance is, _to is where to send the tokens. 
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                // Collects rewards automatically for that amount and unwraps for the original borrower. 
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails
            }
        }
        return true;
    }

    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); // reverts if send fails
        return true;
    }

    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            // Collects rewards automatically for that amount and unwraps for the original borrower. 
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); // reverts if send fails
        }
        return true;
    }

    // View function that returns if the contract transferring to needs to have its balances updated. 
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    // Increases the YUSD Debt of this pool. 
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // Decreases the YUSD Debt of this pool. 
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // --- 'require' functions ---

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    // should be called by BorrowerOperations or DefaultPool
    // __after__ collateral is transferred to this contract.
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    // Adds collateral type from whitelist. 
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2716.0,304.0,"[M-03] Unwhitelisted token can cause disaster
Contract instability and financial loss. This will happen if one of the allowed contract calls sendCollaterals with non whitelisted token (may happen with user input on allowed contract)
  [M-04] Out of gas.
There is no upper limit on `poolColl.tokens[]`, it increments each time when a new collateral is added. Eventually, as the count of collateral increases, gas cost of smart contract calls will raise and that there is no implemented function to reduce the array size.
Impact: For every call `getVC()` function which computed contain the VC value of a given collateralAddress is listed in `poolColl.tokens[]` array, the gas consumption can be more expensive each time that a new collateral address is appended to the array, until reaching an ""Out of Gas"" error or a ""Block Gas Limit"" in the worst scenario.",2.0,"pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";


contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    
    newColls internal poolColl;

    
    uint256 internal YUSDDebt;

    

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    

    

    
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    

    
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); 
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    
    
    
    
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); 
            }
        }
        return true;
    }

    
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); 
        return true;
    }

    
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); 
        }
        return true;
    }

    
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2101.0,0,2,"Evaluating smart contract security
OK, let me see. Assessing all potential vulnerabilities in the given smart contract to pinpoint security risks.
Breaking down vulnerabilities
I’m identifying potential security flaws in the smart contract code, aiming to systematically pinpoint issues that may lead to breaches or exploitations.
Considering vulnerabilities
I’m identifying potential security flaws in this smart contract, aiming to uncover areas that might be vulnerable to breaches. This thorough analysis helps pinpoint areas that need attention.
Tasking through potential vulnerabilities
I'm systematically analyzing the smart contract's code to identify potential security risks, ensuring a comprehensive review of all areas that might pose a threat.
","Here are some potential vulnerabilities in the given smart contract:

1. **Reentrancy Risk**: 
   - The `_sendCollateral` and other functions that transfer assets (like `sendCollaterals`, `sendSingleCollateral`, etc.) do not use a `ReentrancyGuard`. These functions could be vulnerable to reentrancy attacks, especially when interacting with external contracts (e.g., `IERC20.safeTransfer`).

2. **Lack of Access Control in Functions**: 
   - The contract heavily relies on `require` statements for access control but lacks fine-grained control in some cases. For example, multiple functions such as `increaseYUSDDebt`, `decreaseYUSDDebt`, and `sendCollaterals` are controlled by a few addresses but do not have a strong restriction on who can call them, apart from basic `require` checks. This could lead to potential misuse or unintended calls if the access control is bypassed.

3. **Unchecked External Calls**:
   - Calls to external contracts (e.g., `IWAsset.unwrapFor`, `whitelist.getIndex`) are made without any form of validation to ensure they are safe. In some cases, external contracts may behave unexpectedly or maliciously, causing state changes in the contract.

4. **Default Pool Access Control**:
   - The contract has an issue where `defaultPoolAddress` can interact with a wide range of functions (`_requireCallerIsBorrowerOperationsOrDefaultPool`). If an attacker can change the `defaultPoolAddress` to a malicious contract, they might be able to bypass certain restrictions.

5. **Data Integrity**:
   - The contract allows `poolColl.amounts` to be updated via several functions, but there is no validation or locking mechanism to ensure the integrity of the data. For example, adding collaterals or manipulating the collateral values might be susceptible to data inconsistencies or unwanted manipulation.

6. **Potential for Misuse with `onlyOwner`**:
   - The `setAddresses` function can change several key addresses and the `onlyOwner` modifier gives a lot of control to the owner. If the ownership is transferred or compromised, the malicious owner could alter crucial contract addresses and have full control over the contract.

7. **Lack of Event Emission for Key State Changes**:
   - While some state changes (like `YUSDDebt` updates) are logged with events, others are not. For example, adding new collateral types via `addCollateralType` does not emit an event, which can lead to a lack of transparency in the system.

8. **Gas Limit Risk in Loops**:
   - Functions like `getVC` loop over the `poolColl.tokens` array. If the array grows too large, the gas limit could be exceeded, causing the transaction to fail.

9. **Lack of Input Validation**:
   - In several functions (e.g., `sendCollateralsUnwrap`, `sendSingleCollateral`), the contract doesn't properly validate the input array lengths or their contents beyond basic checks. Invalid data could lead to unexpected behavior, especially when interacting with external contracts.

10. **Duplicated Function Definitions**:
    - There are multiple functions with similar or duplicated logic, such as `_requireCallerIsBOorTroveMorSP` and `_requireCallerIsBOorTroveM`, which could lead to confusion and errors during contract maintenance.

11. **Reentrancy in the `receiveCollateral` Function**:
    - The `receiveCollateral` function calls `_leftSumColls`, which updates `poolColl.amounts`. If any of the collateral tokens are malicious, they could potentially trigger a reentrancy attack.

12. **Insecure `renounceOwnership`**:
    - In the `setAddresses` function, the contract renounces ownership via `_renounceOwnership()`. If the ownership is renounced entirely, no one will have control over critical contract settings, which may not be desired behavior.","### **[M-03] Unwhitelisted token can cause disaster**

**Report Description**:
The issue arises when an unwhitelisted token is used in the `sendCollaterals` function, which can be triggered by user input on an allowed contract. This can lead to contract instability and financial loss, as the contract may not handle unwhitelisted tokens properly, potentially causing unintended behavior or vulnerabilities.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of unwhitelisted tokens causing contract instability or financial loss. While some responses touch on access control and external calls, none specifically mention the risks associated with unwhitelisted tokens.

---

### **[M-04] Out of gas**

**Report Description**:
The `poolColl.tokens[]` array has no upper limit and grows each time a new collateral is added. This can lead to increasing gas costs for functions like `getVC()`, which loops over the array. Eventually, this could result in an ""Out of Gas"" error or exceed the block gas limit, causing transaction failures.

**Match in Response List**:
Matches with the issue titled **""Gas Limit Risk in Loops""**.

**Validation**:
**Correct**. The response accurately identifies the issue of gas limit risks in loops, specifically mentioning the `getVC` function and the `poolColl.tokens` array. It correctly highlights the potential for exceeding gas limits as the array grows, which aligns with the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-04] Out of gas**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-03] Unwhitelisted token can cause disaster**

---

### **Conclusion**

The response list effectively addresses the gas limit risk in loops (M-04) but fails to identify or address the issue of unwhitelisted tokens causing contract instability (M-03). This gap highlights the need for a more comprehensive review of potential vulnerabilities, particularly those related to token whitelisting and access control.",1,0,1,12,"```
1. Gas Limit Risk in Loops
```",0.08333333333333333
BorrowerOperations.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, etc. 
 */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        // transfer collateral into ActivePool
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called _after_ collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist and no duplicates
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }


        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // Use the unmodified _YUSDChange here, as we don't send the fee to the user
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        // transfer withdrawn collateral to msg.sender from ActivePool
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     */
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    /* Checks that:
     * 1. _colls contains no duplicates
     * 2. All elements of _colls are active collateral on the whitelist
     */
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    // requires that avax indices are in order
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",9859.0,1116.0,"[M-05] Reentrancy in contracts/BorrowerOperations.sol

Submitted by heiho1, also found by jayjonah8
Impact

There are several potential re-entrant functions in contracts/BorrowerOperations.sol:
=> Function addColl() on line 346 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _adjustTrove() which potentially impacts user debt, collateral top-ups or withdrawals.
Same applies to
-- withdrawColl() on line 373 -- withdrawYUSD() on line 389 -- repayYUSD() on line 406 -- adjustTrove() on line 420
=> Function openTrove() on line 207 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _openTroveInternal() which potentially impacts trove creation, YUSD withdrawals and YUSD gas compensation.
=> Function closeTrove() on line 628 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes troveManagerCached.r",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";



contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    
    
    
    
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, 
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); 

        _requireAtLeastMinNetDebt(vars.netDebt);
        
        
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); 
            _requireNewTCRisAboveCCR(newTCR);
        }

        
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    
    
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    
    
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); 
        _requireNoDuplicateColls(_collsOut);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, 
                params._maxFeePercentage
            );
            
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); 
        }


        
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); 
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        
        
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    
    function claimCollateral() external override {
        
        collSurplusPool.claimColl(msg.sender);
    }

    

    
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); 
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    
    
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); 
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { 
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { 
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    
    
    
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    

    
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    

    
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",8265.0,0,0,"Assessing contract threats
I'm examining the smart contract for weaknesses, highlighting potential issues without providing mitigation strategies.
Highlighting vulnerabilities
Listing all potential risks in the smart contract, carefully avoiding mitigation strategies as per the user's request.
Identifying risks
Listing all vulnerabilities in the smart contract without presenting potential solutions as requested.
Spotting vulnerabilities
Piecing together potential weaknesses in the smart contract based on the provided snippet, while carefully skipping over any mitigation suggestions as per the request.
","Here is a list of potential vulnerabilities in the provided smart contract code:

1. **Reentrancy Attacks**:
   - Several external calls are made, such as in `_transferCollateralsIntoActivePool`, `_withdrawYUSD`, and `_repayYUSD`. If any of these external contracts are not implemented securely, they could allow for reentrancy attacks where an attacker could exploit the contract’s state changes before the external call completes.

2. **Lack of Gas Limit Checks**:
   - Some functions perform loops over arrays (like `_getNewPortfolio` and `_transferCollateralsIntoActivePool`). If the array sizes are too large, they could potentially cause a transaction to exceed the block gas limit.

3. **No Checks for Address Validity**:
   - In various places, addresses are passed as parameters (e.g., `_collsIn`, `_collsOut`). There is no explicit check to ensure these addresses are not zero addresses, potentially causing issues if a zero address is passed inadvertently.

4. **Lack of Proper Access Control**:
   - The contract uses `onlyOwner` for the `setAddresses` function, but there’s no apparent mechanism to revoke ownership or protect critical changes after deployment. This might give excessive control to a single address, which could be dangerous if the owner’s private key is compromised.

5. **No Event Emission for Critical Actions**:
   - Functions such as `_adjustTrove`, `_transferCollateralsIntoActivePool`, and `_getTotalVariableDepositFee` perform critical operations but don’t emit events that can help with tracking the contract’s state changes.

6. **Potential Overflow in Arithmetic Operations**:
   - There are many places where arithmetic operations are performed, such as adding and subtracting debt and collateral values (`add`, `sub`). Even though Solidity 0.6+ uses safe math by default, ensuring that no overflows or underflows occur requires proper handling (though the checks for this seem to be in place, extra caution is needed).

7. **External Contract Dependency Risks**:
   - The contract relies on external contracts such as `IYUSDToken`, `ITroveManager`, `ICollSurplusPool`, etc., and uses them for critical operations. If any of these contracts are flawed, they could affect the BorrowerOperations contract’s behavior. A security audit of these external contracts is essential.

8. **Delegatecall or Proxy Risks**:
   - If any of the external contract calls use `delegatecall`, an attacker could potentially manipulate the behavior of the contract by making an external contract vulnerable through controlled changes in the proxy.

9. **Lack of Recovery Mechanism**:
   - Although the contract includes a function `_requireNotInRecoveryMode`, there is no explicit mention of a recovery mechanism in case of an emergency. A recovery mechanism could help protect the system in case of unexpected failures or attacks.

10. **Denial of Service (DoS) Vulnerabilities**:
    - In `_requireValidDepositCollateral`, the contract checks for conditions on every element of the collateral array, which could fail if one of the collateral types is not active in the whitelist, thus blocking the entire transaction. This could lead to DoS under certain conditions.

11. **Unchecked External Calls to Untrusted Addresses**:
    - Functions like `checkContract` and `whitelist.getFeeAndUpdate` make calls to untrusted external addresses, which could potentially be manipulated.

12. **Integer Precision Issues**:
    - Calculations involving percentages (such as fee calculations) could suffer from rounding errors or integer overflow if not properly handled. This issue could lead to unexpected outcomes or manipulations.

13. **Use of `assert` Instead of `require`**:
    - The code uses `assert` in some places (e.g., `assert(MIN_NET_DEBT > 0);`). While `assert` is used for internal errors, `require` would be better for user input validation to prevent unexpected contract states.","### **[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Report Description**:
The issue highlights several potentially re-entrant functions in `BorrowerOperations.sol` due to the lack of reentrancy guards. Specifically, the following functions are identified as vulnerable:
- `addColl()` (line 346): Calls `_adjustTrove()`, which impacts user debt, collateral top-ups, or withdrawals.
- `withdrawColl()` (line 373), `withdrawYUSD()` (line 389), `repayYUSD()` (line 406), and `adjustTrove()` (line 420): These functions are external and lack reentrancy guards, making them susceptible to reentrancy attacks.
- `openTrove()` (line 207): Calls `_openTroveInternal()`, which impacts trove creation, YUSD withdrawals, and YUSD gas compensation.
- `closeTrove()` (line 628): Calls `troveManagerCached`, which could be exploited if the external contract is malicious.

The absence of reentrancy guards in these functions could allow attackers to manipulate the contract’s state during external calls, leading to potential financial losses or unexpected behavior.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Attacks""**.

**Validation**:
**Correct**. The response accurately identifies the risk of reentrancy attacks in the contract, particularly in functions that make external calls. It correctly explains that insecure external contracts could allow attackers to exploit state changes before the external call completes. This aligns with the issue report’s concerns about the lack of reentrancy guards in critical functions. The response covers the core vulnerability and its potential impact, making it a correct match.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- *None*

---

### **Analysis of Other Responses in `response_list`**

While the response list covers a wide range of potential vulnerabilities, it does not explicitly address all the specific functions mentioned in the issue report (e.g., `addColl()`, `withdrawColl()`, `openTrove()`, etc.). However, the general description of reentrancy attacks is sufficient to cover the core issue. Other responses in the list, such as **""Lack of Gas Limit Checks""**, **""No Checks for Address Validity""**, and **""Lack of Proper Access Control""**, are unrelated to the reentrancy issue and do not impact the validation of this specific match.",1,0,0,13,"```
1. Reentrancy Attacks
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Reentrancy Attacks,"" which appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank itself.
   - \( P@1 = \frac{1}{1} = 1.0 \)

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the Average Precision (AP) is simply the precision at rank 1.
   - \( AP = 1.0 \)

**Output**:
```
1.0
```"
ThreePieceWiseLinearPriceCurve.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";

/** 
 * This contract is used to calculate the variable fee for an input of tokens. 
 * Uses three linear piecewise functions to calculate the fee, and the average 
 * of the system collateralization by that asset before and after the tx. 
 */
contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    /** 
     * f1 = m1 * x + b1
     * f1 meets f2 at cutoff1, which is defined by that intersection point and slope m2
     * f2 meets f3 at cutoff2, which is defined by that intersection point and slope m3
     * Everything in terms of actual * 1e18, scaled by 1e18 because can't do percentages
     * Decimal precision = 1e18
     */

    /** 
     * Function for setting slopes and intercepts of linear functions used for fee calculations. 
     */
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        // b2 = _m1.mul(_cutoff1).div(1e18).add(_b1).sub(_m2.mul(_cutoff1).div(1e18));
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        // b3 = _m2.mul(_cutoff2).div(1e18).add(b2).sub(_m3.mul(_cutoff2).div(1e18));
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; // Cap in VC terms of max of this asset. dollarCap = 0 means no cap. No cap.
        decayTime = 5 days;
    }

    // Set the whitelist address so that the fee can only be updated by whitelistAddress
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    // Set the decay time in seconds
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    // Gets the fee cap and time currently. Used for setting new values for next price curve. 
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. 
    // Called only by whitelist. 
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     * @param _collateralVCInput is how much collateral is being input by the user into the system
     * @param _totalCollateralVCBalance is how much collateral is in the system
     * @param _totalVCBalancePost is how much VC the system for all collaterals after all adjustments (additions, subtractions)
     */
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    // Called only by whitelist. Updates the last fee time and last fee percent
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     */
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        // percent of all VC backed by this collateral * 1e18
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { // use function 1
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { // use function 2
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            // return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
        } else { // use function 3
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            // return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        // Decay within bounds of decay time, then decay the fee. 
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            // If it has been longer than decay time, then reset fee to 0.
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",2218.0,197.0,"[M-07] Cannot use most piecewise linear functions with current implementation
The `adjustParams function` uses three functions `f1`, `f2`, `f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0)`, `b3 = f_3(0)`) for each of these but uses unsigned integers for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.
 
[M-08] Wrong comment in `getFee()`
The function `getFee` comment states that the total + the input must be less than the cap:
“If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.”
The code only checks if the input is less than the cap.   [M-09] Fee not decayed if past decayTime
The function `calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0` && `decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead..",3.0,"pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";


contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    

    
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; 
        decayTime = 5 days;
    }

    
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    
    
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { 
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { 
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            
        } else { 
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",1536.0,0,3,"Focusing on vulnerabilities
I’m digging into listing vulnerabilities in smart contracts without suggesting fixes. This keeps the analysis neutral and objective, focusing on identifying security gaps.
Analyzing security risks
Listing all vulnerabilities in smart contracts without suggesting mitigations, providing a comprehensive and neutral analysis that categorizes findings by risk severity.
Pinpointing vulnerabilities
I’m meticulously identifying vulnerabilities in smart contracts, focusing on aspects like input validation errors, lack of access control, and improper handling of external calls, without suggesting mitigations.
Spotting weaknesses
OK, let me see. I'm scanning smart contracts for input flaws, access control gaps, and external call mismanagement, ensuring vulnerabilities are identified without suggesting solutions.
","The smart contract `ThreePieceWiseLinearPriceCurve` contains several potential vulnerabilities and issues, which could be exploited by attackers or lead to unintended behaviors. Here's a list of vulnerabilities and concerns in the contract:

1. **Reentrancy Risk**: 
   - There are external function calls in `setFeeCapAndTime` and `getFeeAndUpdate` that update state variables like `lastFeePercent` and `lastFeeTime`. These functions could potentially be susceptible to reentrancy attacks if external calls in other functions (if added later) interact with funds. Even though no direct Ether transfers are made in this contract, functions with external calls should still be audited for reentrancy.

2. **Lack of Proper Access Control on `setAddresses` and `setFeeCapAndTime`**:
   - The contract allows the owner to set a whitelist address via `setAddresses`, but there is no restriction on who can call `setDecayTime`. The `setFeeCapAndTime` function requires the sender to be whitelisted, but the whitelist check may be bypassed by malicious manipulation of the contract's internal state.

3. **Magic Numbers in `decayTime`**:
   - The default `decayTime` is set to 5 days (`5 days` hardcoded). This ""magic number"" could lead to future confusion or adjustments that are not made to the code explicitly.

4. **Uninitialized State Variables**:
   - The state variables `name`, `m1`, `b1`, `m2`, `m3`, `b2`, `b3`, etc., could be uninitialized if the `adjustParams` function is not called early in the contract's lifecycle, potentially leading to unexpected behavior.

5. **Insecure `onlyOwner` modifier**:
   - The contract uses the `Ownable` pattern, but this could be risky if the private key of the owner is compromised. If the owner key is lost or stolen, the contract could be locked or misused by an attacker.

6. **Overflows in Mathematical Operations**:
   - Although `SafeMath` is used in the contract to prevent overflow/underflow in most calculations, the function `_min` and `_max` have not been explicitly protected. Depending on the inputs, an attacker may be able to manipulate calculations if these values are not carefully controlled.

7. **No Validations on `setDecayTime`**:
   - The `setDecayTime` function doesn't validate the input time. An attacker could set an unrealistic decay time, such as a very short or long period, which could either invalidate the decay behavior or affect the correctness of the fee calculation.

8. **Potential Integer Division Issues**:
   - In the `getFee` function, there are several places where division by `1e18` occurs. If this is not done carefully, integer division may result in truncation, which could lead to errors. This should be reviewed to ensure accuracy in mathematical calculations.

9. **Potential Attacks via `getFeeAndUpdate`**:
   - The `getFeeAndUpdate` function allows the whitelisted address to modify the fee. If an attacker gains control of the whitelist address, they can manipulate the fee calculations. The assumption that only trusted addresses are whitelisted could lead to problems if the whitelisted address is compromised.

10. **Incorrect Handling of Negative `b2` and `b3`**:
   - The variables `b2Negative` and `b3Negative` are set but not sufficiently validated or tested in edge cases. If these negative values are handled improperly, the price curve calculations may return incorrect results.

11. **`require` Statements Not Giving Sufficient Error Feedback**:
   - Some `require` statements, such as `require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"")`, could potentially benefit from more informative error messages. If the contract fails, it's harder to debug due to vague error messages.

12. **Lack of Event Emissions**:
   - No events are emitted for critical changes, such as updating the `feeCap` or changing the `decayTime`. Event logs help with transparency and are necessary for tracking and auditing state changes.","### **[M-07] Cannot use most piecewise linear functions with current implementation**

**Report Description**:
The `adjustParams` function uses three functions `f1`, `f2`, `f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0)`, `b3 = f_3(0)`) for each of these but uses unsigned integers for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.

**Match in Response List**:
Matches with the issue titled **""Incorrect Handling of Negative `b2` and `b3`""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the handling of negative values for `b2` and `b3`. It correctly explains that the use of unsigned integers prevents the use of functions that require negative y-axis intersects, which aligns with the issue described in the report.

---

### **[M-08] Wrong comment in `getFee()`**

**Report Description**:
The function `getFee` comment states that the total + the input must be less than the cap: “If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.” The code only checks if the input is less than the cap.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the discrepancy between the comment and the actual code in the `getFee` function. This is a missed issue.

---

### **[M-09] Fee not decayed if past decayTime**

**Report Description**:
The function `calculateDecayedFee` is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0` && `decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue with the `calculateDecayedFee` function failing to decay the fee to 0 when `decay > decayTime`. This is a missed issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-07] Cannot use most piecewise linear functions with current implementation**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-08] Wrong comment in `getFee()`**
- **[M-09] Fee not decayed if past decayTime**

---

The response list covers some issues but misses critical details in the `getFee` and `calculateDecayedFee` functions. The handling of negative values in `b2` and `b3` is correctly identified, but the discrepancies in comments and the incomplete decay logic are not addressed.",1,0,2,12,"```
1. Incorrect Handling of Negative `b2` and `b3`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Handling of Negative `b2` and `b3`"".
   - This appears at rank **10** in the ranked list of predictions.

2. **Calculate the precision at rank 10**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 10, there is **1** true positive.
   - \( P@10 = \frac{1}{10} = 0.1 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.1 \).

**Output**:
```
0.1
```"
,,,,,,,,2,7,,,,4,1,5,75,,
