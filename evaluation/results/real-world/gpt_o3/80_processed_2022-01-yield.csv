nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Reasoning,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
ConvexYieldWrapper.sol,"// SPDX-License-Identifier: MIT
// Original contract: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol
pragma solidity 0.8.6;

import ""@yield-protocol/utils-v2/contracts/token/IERC20.sol"";
import ""@yield-protocol/utils-v2/contracts/token/ERC20.sol"";
import ""@yield-protocol/utils-v2/contracts/access/AccessControl.sol"";
import ""@yield-protocol/utils-v2/contracts/token/TransferHelper.sol"";
import ""./interfaces/IRewardStaking.sol"";
import ""./interfaces/IConvexDeposits.sol"";
import ""./interfaces/ICvx.sol"";
import ""./CvxMining.sol"";

/// @notice Wrapper used to manage staking of Convex tokens
contract ConvexStakingWrapper is ERC20, AccessControl {
    using TransferHelper for IERC20;

    struct EarnedData {
        address token;
        uint256 amount;
    }

    struct RewardType {
        address reward_token;
        address reward_pool;
        uint128 reward_integral;
        uint128 reward_remaining;
        mapping(address => uint256) reward_integral_for;
        mapping(address => uint256) claimable_reward;
    }

    uint256 public cvx_reward_integral;
    uint256 public cvx_reward_remaining;
    mapping(address => uint256) public cvx_reward_integral_for;
    mapping(address => uint256) public cvx_claimable_reward;

    //constants/immutables
    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    address public curveToken;
    address public convexToken;
    address public convexPool;
    address public collateralVault;
    uint256 public convexPoolId;

    //rewards
    RewardType[] public rewards;

    //management
    bool public isShutdown;
    bool private _status;

    bool private constant _NOT_ENTERED = false;
    bool private constant _ENTERED = true;

    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);
    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);

    constructor(
        address _curveToken,
        address _convexToken,
        address _convexPool,
        uint256 _poolId,
        address _vault,
        string memory name,
        string memory symbol,
        uint8 decimals
    ) ERC20(name, symbol, decimals) {
        curveToken = _curveToken;
        convexToken = _convexToken;
        convexPool = _convexPool;
        convexPoolId = _poolId;
        collateralVault = _vault;

        //add rewards
        addRewards();
        setApprovals();
    }

    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");
        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
        _;
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }

    /// @notice Give maximum approval to the pool & convex booster contract to transfer funds from wrapper
    function setApprovals() public {
        IERC20(curveToken).approve(convexBooster, 0);
        IERC20(curveToken).approve(convexBooster, type(uint256).max);
        IERC20(convexToken).approve(convexPool, type(uint256).max);
    }

    /// @notice Adds reward tokens by reading the available rewards from the RewardStaking pool
    /// @dev CRV token is added as a reward by default
    function addRewards() public {
        address mainPool = convexPool;

        uint256 rewardsLength = rewards.length;

        if (rewardsLength == 0) {
            RewardType storage reward = rewards.push();
            reward.reward_token = crv;
            reward.reward_pool = mainPool;
            rewardsLength += 1;
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        uint256 startIndex = rewardsLength - 1;
        for (uint256 i = startIndex; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            RewardType storage reward = rewards.push();
            reward.reward_token = IRewardStaking(extraPool).rewardToken();
            reward.reward_pool = extraPool;
        }
    }

    /// @notice Returns the length of the reward tokens added
    /// @return The count of reward tokens
    function rewardLength() external view returns (uint256) {
        return rewards.length;
    }

    /// @notice Get user's balance
    /// @param _account User's address for which balance is requested
    /// @return User's balance of collateral
    /// @dev Included here to allow inheriting contracts to override.
    function _getDepositedBalance(address _account) internal view virtual returns (uint256) {
        if (_account == address(0) || _account == collateralVault) {
            return 0;
        }
        //get balance from collateralVault

        return _balanceOf[_account];
    }

    /// @notice TotalSupply of wrapped token
    /// @return The total supply of wrapped token
    /// @dev This function is provided and marked virtual as convenience to future development
    function _getTotalSupply() internal view virtual returns (uint256) {
        return _totalSupply;
    }

    /// @notice Calculates & upgrades the integral for distributing the CVX rewards
    /// @param _accounts Accounts for which the CvxIntegral has to be calculated
    /// @param _balances Balances of the accounts
    /// @param _supply Total supply of the wrapped token
    /// @param _isClaim Whether to claim the calculated rewards
    function _calcCvxIntegral(
        address[2] memory _accounts,
        uint256[2] memory _balances,
        uint256 _supply,
        bool _isClaim
    ) internal {
        uint256 bal = IERC20(cvx).balanceOf(address(this));
        uint256 cvxRewardRemaining = cvx_reward_remaining;
        uint256 d_cvxreward = bal - cvxRewardRemaining;
        uint256 cvxRewardIntegral = cvx_reward_integral;

        if (_supply > 0 && d_cvxreward > 0) {
            cvxRewardIntegral = cvxRewardIntegral + (d_cvxreward * 1e20) / (_supply);
            cvx_reward_integral = cvxRewardIntegral;
        }

        //update user integrals for cvx
        uint256 accountsLength = _accounts.length;
        for (uint256 u = 0; u < accountsLength; u++) {
            //do not give rewards to address 0
            if (_accounts[u] == address(0)) continue;
            if (_accounts[u] == collateralVault) continue;

            uint256 userI = cvx_reward_integral_for[_accounts[u]];
            if (_isClaim || userI < cvxRewardIntegral) {
                uint256 receiveable = cvx_claimable_reward[_accounts[u]] +
                    ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);
                if (_isClaim) {
                    if (receiveable > 0) {
                        cvx_claimable_reward[_accounts[u]] = 0;
                        IERC20(cvx).safeTransfer(_accounts[u], receiveable);
                        bal = bal - (receiveable);
                    }
                } else {
                    cvx_claimable_reward[_accounts[u]] = receiveable;
                }
                cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral;
            }
        }

        //update reward total
        if (bal != cvxRewardRemaining) {
            cvx_reward_remaining = bal;
        }
    }

    /// @notice Calculates & upgrades the integral for distributing the reward token
    /// @param _index The index of the reward token for which the calculations are to be done
    /// @param _accounts Accounts for which the CvxIntegral has to be calculated
    /// @param _balances Balances of the accounts
    /// @param _supply Total supply of the wrapped token
    /// @param _isClaim Whether to claim the calculated rewards
    function _calcRewardIntegral(
        uint256 _index,
        address[2] memory _accounts,
        uint256[2] memory _balances,
        uint256 _supply,
        bool _isClaim
    ) internal {
        RewardType storage reward = rewards[_index];

        uint256 rewardIntegral = reward.reward_integral;
        uint256 rewardRemaining = reward.reward_remaining;

        //get difference in balance and remaining rewards
        //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed
        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));
        if (_supply > 0 && (bal - rewardRemaining) > 0) {
            rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);
            reward.reward_integral = uint128(rewardIntegral);
        }
        //update user integrals
        uint256 accountsLength = _accounts.length;
        for (uint256 u = 0; u < accountsLength; u++) {
            //do not give rewards to address 0
            if (_accounts[u] == address(0)) continue;
            if (_accounts[u] == collateralVault) continue;

            uint256 userI = reward.reward_integral_for[_accounts[u]];
            if (_isClaim || userI < rewardIntegral) {
                if (_isClaim) {
                    uint256 receiveable = reward.claimable_reward[_accounts[u]] +
                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);
                    if (receiveable > 0) {
                        reward.claimable_reward[_accounts[u]] = 0;
                        IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);
                        bal = bal - receiveable;
                    }
                } else {
                    reward.claimable_reward[_accounts[u]] =
                        reward.claimable_reward[_accounts[u]] +
                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);
                }
                reward.reward_integral_for[_accounts[u]] = rewardIntegral;
            }
        }

        //update remaining reward here since balance could have changed if claiming
        if (bal != rewardRemaining) {
            reward.reward_remaining = uint128(bal);
        }
    }

    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them
    /// @param _accounts The accounts for which checkpoints have to be calculated
    function _checkpoint(address[2] memory _accounts) internal {
        //if shutdown, no longer checkpoint in case there are problems
        if (isShutdown) return;

        uint256 supply = _getTotalSupply();
        uint256[2] memory depositedBalance;
        depositedBalance[0] = _getDepositedBalance(_accounts[0]);
        depositedBalance[1] = _getDepositedBalance(_accounts[1]);

        IRewardStaking(convexPool).getReward(address(this), true);

        uint256 rewardCount = rewards.length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);
        }
        _calcCvxIntegral(_accounts, depositedBalance, supply, false);
    }

    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them & claims the rewards
    /// @param _accounts The accounts for which checkpoints have to be calculated
    function _checkpointAndClaim(address[2] memory _accounts) internal {
        uint256 supply = _getTotalSupply();
        uint256[2] memory depositedBalance;
        depositedBalance[0] = _getDepositedBalance(_accounts[0]); //only do first slot

        IRewardStaking(convexPool).getReward(address(this), true);

        uint256 rewardCount = rewards.length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(i, _accounts, depositedBalance, supply, true);
        }
        _calcCvxIntegral(_accounts, depositedBalance, supply, true);
    }

    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them
    /// @param _accounts The accounts for which checkpoints have to be calculated
    function user_checkpoint(address[2] calldata _accounts) external returns (bool) {
        _checkpoint([_accounts[0], _accounts[1]]);
        return true;
    }

    /// @notice Get the balance of the user
    /// @param _account Address whose balance is to be checked
    /// @return The balance of the supplied address
    function totalBalanceOf(address _account) external view returns (uint256) {
        return _getDepositedBalance(_account);
    }

    /// @notice Get the amount of tokens the user has earned
    /// @param _account Address whose balance is to be checked
    /// @return claimable Array of earned tokens and their amount
    function earned(address _account) external view returns (EarnedData[] memory claimable) {
        uint256 supply = _getTotalSupply();
        uint256 rewardCount = rewards.length;
        claimable = new EarnedData[](rewardCount + 1);

        for (uint256 i = 0; i < rewardCount; i++) {
            RewardType storage reward = rewards[i];
            address rewardToken = reward.reward_token;

            //change in reward is current balance - remaining reward + earned
            uint256 bal = IERC20(rewardToken).balanceOf(address(this));
            uint256 d_reward = bal - reward.reward_remaining;
            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));

            uint256 I = reward.reward_integral;
            if (supply > 0) {
                I = I + (d_reward * 1e20) / supply;
            }

            uint256 newlyClaimable = (_getDepositedBalance(_account) * (I - reward.reward_integral_for[_account])) /
                1e20;
            claimable[i].amount = reward.claimable_reward[_account] + newlyClaimable;
            claimable[i].token = rewardToken;

            //calc cvx here
            if (rewardToken == crv) {
                claimable[rewardCount].amount =
                    cvx_claimable_reward[_account] +
                    CvxMining.ConvertCrvToCvx(newlyClaimable);
                claimable[rewardCount].token = cvx;
            }
        }
        return claimable;
    }

    /// @notice Claim reward for the supplied account
    /// @param _account Address whose reward is to be claimed
    function getReward(address _account) external {
        //claim directly in checkpoint logic to save a bit of gas
        _checkpointAndClaim([_account, address(0)]);
    }
}",3329.0,353.0,"[H-01] Malicious Users Can Duplicate Protocol Earned Yield By Transferring `wCVX` Tokens To Another Account
ConvexYieldWrapper.sol is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the Ladle.sol contract's batch() function which:
  [H-02] Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol
ConvexYieldWrapper.sol is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the Ladle.sol contract's batch() function which:",2.0,"pragma solidity 0.8.6;

import ""@yield-protocol/utils-v2/contracts/token/IERC20.sol"";
import ""@yield-protocol/utils-v2/contracts/token/ERC20.sol"";
import ""@yield-protocol/utils-v2/contracts/access/AccessControl.sol"";
import ""@yield-protocol/utils-v2/contracts/token/TransferHelper.sol"";
import ""./interfaces/IRewardStaking.sol"";
import ""./interfaces/IConvexDeposits.sol"";
import ""./interfaces/ICvx.sol"";
import ""./CvxMining.sol"";


contract ConvexStakingWrapper is ERC20, AccessControl {
    using TransferHelper for IERC20;

    struct EarnedData {
        address token;
        uint256 amount;
    }

    struct RewardType {
        address reward_token;
        address reward_pool;
        uint128 reward_integral;
        uint128 reward_remaining;
        mapping(address => uint256) reward_integral_for;
        mapping(address => uint256) claimable_reward;
    }

    uint256 public cvx_reward_integral;
    uint256 public cvx_reward_remaining;
    mapping(address => uint256) public cvx_reward_integral_for;
    mapping(address => uint256) public cvx_claimable_reward;

    
    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    address public curveToken;
    address public convexToken;
    address public convexPool;
    address public collateralVault;
    uint256 public convexPoolId;

    
    RewardType[] public rewards;

    
    bool public isShutdown;
    bool private _status;

    bool private constant _NOT_ENTERED = false;
    bool private constant _ENTERED = true;

    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);
    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);

    constructor(
        address _curveToken,
        address _convexToken,
        address _convexPool,
        uint256 _poolId,
        address _vault,
        string memory name,
        string memory symbol,
        uint8 decimals
    ) ERC20(name, symbol, decimals) {
        curveToken = _curveToken;
        convexToken = _convexToken;
        convexPool = _convexPool;
        convexPoolId = _poolId;
        collateralVault = _vault;

        
        addRewards();
        setApprovals();
    }

    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");
        
        _status = _ENTERED;
        _;
        
        
        _status = _NOT_ENTERED;
    }

    
    function setApprovals() public {
        IERC20(curveToken).approve(convexBooster, 0);
        IERC20(curveToken).approve(convexBooster, type(uint256).max);
        IERC20(convexToken).approve(convexPool, type(uint256).max);
    }

    
    
    function addRewards() public {
        address mainPool = convexPool;

        uint256 rewardsLength = rewards.length;

        if (rewardsLength == 0) {
            RewardType storage reward = rewards.push();
            reward.reward_token = crv;
            reward.reward_pool = mainPool;
            rewardsLength += 1;
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        uint256 startIndex = rewardsLength - 1;
        for (uint256 i = startIndex; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            RewardType storage reward = rewards.push();
            reward.reward_token = IRewardStaking(extraPool).rewardToken();
            reward.reward_pool = extraPool;
        }
    }

    
    
    function rewardLength() external view returns (uint256) {
        return rewards.length;
    }

    
    
    
    
    function _getDepositedBalance(address _account) internal view virtual returns (uint256) {
        if (_account == address(0) || _account == collateralVault) {
            return 0;
        }
        

        return _balanceOf[_account];
    }

    
    
    
    function _getTotalSupply() internal view virtual returns (uint256) {
        return _totalSupply;
    }

    
    
    
    
    
    function _calcCvxIntegral(
        address[2] memory _accounts,
        uint256[2] memory _balances,
        uint256 _supply,
        bool _isClaim
    ) internal {
        uint256 bal = IERC20(cvx).balanceOf(address(this));
        uint256 cvxRewardRemaining = cvx_reward_remaining;
        uint256 d_cvxreward = bal - cvxRewardRemaining;
        uint256 cvxRewardIntegral = cvx_reward_integral;

        if (_supply > 0 && d_cvxreward > 0) {
            cvxRewardIntegral = cvxRewardIntegral + (d_cvxreward * 1e20) / (_supply);
            cvx_reward_integral = cvxRewardIntegral;
        }

        
        uint256 accountsLength = _accounts.length;
        for (uint256 u = 0; u < accountsLength; u++) {
            
            if (_accounts[u] == address(0)) continue;
            if (_accounts[u] == collateralVault) continue;

            uint256 userI = cvx_reward_integral_for[_accounts[u]];
            if (_isClaim || userI < cvxRewardIntegral) {
                uint256 receiveable = cvx_claimable_reward[_accounts[u]] +
                    ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);
                if (_isClaim) {
                    if (receiveable > 0) {
                        cvx_claimable_reward[_accounts[u]] = 0;
                        IERC20(cvx).safeTransfer(_accounts[u], receiveable);
                        bal = bal - (receiveable);
                    }
                } else {
                    cvx_claimable_reward[_accounts[u]] = receiveable;
                }
                cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral;
            }
        }

        
        if (bal != cvxRewardRemaining) {
            cvx_reward_remaining = bal;
        }
    }

    
    
    
    
    
    
    function _calcRewardIntegral(
        uint256 _index,
        address[2] memory _accounts,
        uint256[2] memory _balances,
        uint256 _supply,
        bool _isClaim
    ) internal {
        RewardType storage reward = rewards[_index];

        uint256 rewardIntegral = reward.reward_integral;
        uint256 rewardRemaining = reward.reward_remaining;

        
        
        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));
        if (_supply > 0 && (bal - rewardRemaining) > 0) {
            rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);
            reward.reward_integral = uint128(rewardIntegral);
        }
        
        uint256 accountsLength = _accounts.length;
        for (uint256 u = 0; u < accountsLength; u++) {
            
            if (_accounts[u] == address(0)) continue;
            if (_accounts[u] == collateralVault) continue;

            uint256 userI = reward.reward_integral_for[_accounts[u]];
            if (_isClaim || userI < rewardIntegral) {
                if (_isClaim) {
                    uint256 receiveable = reward.claimable_reward[_accounts[u]] +
                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);
                    if (receiveable > 0) {
                        reward.claimable_reward[_accounts[u]] = 0;
                        IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);
                        bal = bal - receiveable;
                    }
                } else {
                    reward.claimable_reward[_accounts[u]] =
                        reward.claimable_reward[_accounts[u]] +
                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);
                }
                reward.reward_integral_for[_accounts[u]] = rewardIntegral;
            }
        }

        
        if (bal != rewardRemaining) {
            reward.reward_remaining = uint128(bal);
        }
    }

    
    
    function _checkpoint(address[2] memory _accounts) internal {
        
        if (isShutdown) return;

        uint256 supply = _getTotalSupply();
        uint256[2] memory depositedBalance;
        depositedBalance[0] = _getDepositedBalance(_accounts[0]);
        depositedBalance[1] = _getDepositedBalance(_accounts[1]);

        IRewardStaking(convexPool).getReward(address(this), true);

        uint256 rewardCount = rewards.length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);
        }
        _calcCvxIntegral(_accounts, depositedBalance, supply, false);
    }

    
    
    function _checkpointAndClaim(address[2] memory _accounts) internal {
        uint256 supply = _getTotalSupply();
        uint256[2] memory depositedBalance;
        depositedBalance[0] = _getDepositedBalance(_accounts[0]); 

        IRewardStaking(convexPool).getReward(address(this), true);

        uint256 rewardCount = rewards.length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(i, _accounts, depositedBalance, supply, true);
        }
        _calcCvxIntegral(_accounts, depositedBalance, supply, true);
    }

    
    
    function user_checkpoint(address[2] calldata _accounts) external returns (bool) {
        _checkpoint([_accounts[0], _accounts[1]]);
        return true;
    }

    
    
    
    function totalBalanceOf(address _account) external view returns (uint256) {
        return _getDepositedBalance(_account);
    }

    
    
    
    function earned(address _account) external view returns (EarnedData[] memory claimable) {
        uint256 supply = _getTotalSupply();
        uint256 rewardCount = rewards.length;
        claimable = new EarnedData[](rewardCount + 1);

        for (uint256 i = 0; i < rewardCount; i++) {
            RewardType storage reward = rewards[i];
            address rewardToken = reward.reward_token;

            
            uint256 bal = IERC20(rewardToken).balanceOf(address(this));
            uint256 d_reward = bal - reward.reward_remaining;
            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));

            uint256 I = reward.reward_integral;
            if (supply > 0) {
                I = I + (d_reward * 1e20) / supply;
            }

            uint256 newlyClaimable = (_getDepositedBalance(_account) * (I - reward.reward_integral_for[_account])) /
                1e20;
            claimable[i].amount = reward.claimable_reward[_account] + newlyClaimable;
            claimable[i].token = rewardToken;

            
            if (rewardToken == crv) {
                claimable[rewardCount].amount =
                    cvx_claimable_reward[_account] +
                    CvxMining.ConvertCrvToCvx(newlyClaimable);
                claimable[rewardCount].token = cvx;
            }
        }
        return claimable;
    }

    
    
    function getReward(address _account) external {
        
        _checkpointAndClaim([_account, address(0)]);
    }
}",2515.0,2,0,"Revealing vulnerabilities
Taking a closer look at the smart contract's code, identifying unhandled exceptions and overflow issues, and applying security patterns like checkpoint and correct-check.
Analyzing vulnerabilities
I'm digging into unhandled exceptions and overflow risks, suggesting the use of patterns like checkpoint and correct-check to boost smart contract security.
Identifying vulnerabilities
I'm thinking through vulnerabilities in a smart contract by examining unhandled exceptions and overflow risks, and suggesting security patterns like checkpoint and correct-check to mitigate these issues.
Identifying vulnerabilities
Right now, I'm analyzing unhandled exceptions and overflow risks in the smart contract, and considering security patterns like checkpoint and correct-check to address these potential threats.
","Here are the potential vulnerabilities in the provided smart contract:

1. **Reentrancy Vulnerability**:
   - The contract uses a `nonReentrant` modifier to prevent reentrancy attacks. However, this modifier is applied only to certain functions like `_calcCvxIntegral` and `_calcRewardIntegral`. There is no explicit protection in other functions where external calls (like `safeTransfer`) are made, potentially allowing reentrancy attacks in functions like `getReward` or `_checkpointAndClaim` if they are used incorrectly.

2. **Untrusted External Calls**:
   - The contract makes calls to external contracts like `IRewardStaking`, `IERC20`, and `CvxMining`. If any of these external contracts are compromised or malicious, they could exploit vulnerabilities in the contract. There is a risk when calling untrusted or third-party smart contracts.

3. **Integer Overflow/Underflow**:
   - Although the contract uses Solidity version 0.8.6 (which has built-in overflow/underflow checks), manual calculations using `uint128` and `uint256` might still be a point of failure if not properly managed. Any manual casting between different unsigned integer types (e.g., `uint128` to `uint256`) may cause issues if not handled carefully.

4. **Unrestricted `addRewards` function**:
   - The `addRewards` function allows anyone to add new reward pools and tokens. If the contract is not properly governed or controlled, it could lead to the addition of malicious or unintended reward tokens, potentially draining funds or misallocating rewards.

5. **Lack of Access Control on `setApprovals`**:
   - The `setApprovals` function is callable by anyone, meaning anyone could reset the approval settings for the `curveToken` and `convexToken`. This could potentially allow unauthorized transfers of tokens.

6. **Potential for Unclaimed Rewards to Accumulate**:
   - The contract seems to allow users to accumulate rewards that might never be claimed (e.g., by calling `_checkpointAndClaim`). This could lead to a situation where rewards stay locked or unclaimed without being transferred or claimed appropriately.

7. **Insecure `collateralVault` Usage**:
   - There is no explicit check for whether the `collateralVault` is a valid contract or a trusted address. If it is a malicious address, it could exploit the contract by interacting with the rewards or tokens in unexpected ways.

8. **Gas Limit Issues**:
   - The `addRewards` function potentially iterates through external calls to reward pools, which could be expensive in terms of gas if there are many reward tokens added over time. This might lead to transaction failures due to exceeding the gas limit.

9. **State Variables Without Initialization**:
   - Variables such as `cvx_reward_integral`, `cvx_reward_remaining`, `cvx_reward_integral_for`, and others are initialized but might not be properly set at the right time during contract creation or updates. If not handled carefully, this might cause inconsistent state or rewards calculation errors.

10. **No Protection Against Repeated Calls in `user_checkpoint`**:
    - There is no protection to prevent users from calling `user_checkpoint` repeatedly in a short time span, potentially leading to unexpected state changes or race conditions, especially when interacting with external systems like `convexPool` or `cvx`.","### **Output**

---

**[H-01] Malicious Users Can Duplicate Protocol Earned Yield By Transferring `wCVX` Tokens To Another Account**

**Report Description**:
The `ConvexYieldWrapper.sol` contract allows users to stake convex tokens and earn rewards. However, malicious users can duplicate the protocol's earned yield by transferring `wCVX` tokens to another account. This is possible because the contract does not properly track or restrict token transfers, allowing users to exploit the reward mechanism by moving tokens between accounts to claim rewards multiple times.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of yield duplication through token transfers. While some responses touch on external calls and access control, none directly address the vulnerability described in the issue. This is a critical oversight, as the issue highlights a significant risk to the protocol's reward distribution mechanism.

---

**[H-02] Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol**

**Report Description**:
The `ConvexYieldWrapper.sol` contract allows users to stake convex tokens and earn rewards. However, malicious users can transfer vault collateral to other accounts to extract additional yield from the protocol. This is possible because the contract does not enforce proper access control or restrictions on collateral transfers, enabling users to manipulate the reward system by moving collateral between accounts.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of collateral transfer exploitation. While some responses mention access control and external calls, none directly address the vulnerability described in the issue. This is a significant gap, as the issue highlights a critical risk to the protocol's collateral management and reward distribution.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] Malicious Users Can Duplicate Protocol Earned Yield By Transferring `wCVX` Tokens To Another Account**
- **[H-02] Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol**

---

### **Analysis**:
The `response_list` does not adequately address the specific vulnerabilities described in the `issue` report. While the response list covers general security concerns like reentrancy, external calls, and access control, it fails to identify or address the critical issues of yield duplication and collateral transfer exploitation. These gaps indicate a need for more focused and detailed responses that align with the specific risks outlined in the issue report.",0,0,2,10,"```
None.
```",0.0
Cvx3CrvOracle.sol,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.6;

import ""@yield-protocol/utils-v2/contracts/access/AccessControl.sol"";
import ""@yield-protocol/vault-interfaces/IOracle.sol"";
import ""@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol"";

import ""./interfaces/ICurvePool.sol"";
import ""./interfaces/AggregatorV3Interface.sol"";

// Oracle Code Inspiration: https://github.com/Abracadabra-money/magic-internet-money/blob/main/contracts/oracles/3CrvOracle.sol
/**
 *@title  Cvx3CrvOracle
 *@notice Provides current values for Cvx3Crv
 *@dev    Both peek() (view) and get() (transactional) are provided for convenience
 */
contract Cvx3CrvOracle is IOracle, AccessControl {
    using CastBytes32Bytes6 for bytes32;
    ICurvePool public threecrv;
    AggregatorV3Interface public DAI;
    AggregatorV3Interface public USDC;
    AggregatorV3Interface public USDT;

    bytes32 public cvx3CrvId;
    bytes32 public ethId;

    /**
     *@notice Set threecrv pool and the chainlink sources
     *@param  cvx3CrvId_ cvx3crv Id
     *@param  ethId_ ETH ID
     *@param  threecrv_ The 3CRV pool address
     *@param  DAI_ DAI/ETH chainlink price feed address
     *@param  USDC_ USDC/ETH chainlink price feed address
     *@param  USDT_ USDT/ETH chainlink price feed address
     */
    function setSource(
        bytes32 cvx3CrvId_,
        bytes32 ethId_,
        ICurvePool threecrv_,
        AggregatorV3Interface DAI_,
        AggregatorV3Interface USDC_,
        AggregatorV3Interface USDT_
    ) external auth {
        cvx3CrvId = cvx3CrvId_;
        ethId = ethId_;
        threecrv = threecrv_;
        DAI = DAI_;
        USDC = USDC_;
        USDT = USDT_;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.
     * @param base Id of base token
     * @param quote Id of quoted token
     * @return quoteAmount Total amount in terms of quoted token
     * @return updateTime Time quote was last updated
     */
    function peek(
        bytes32 base,
        bytes32 quote,
        uint256 baseAmount
    )
        external
        view
        virtual
        override
        returns (uint256 quoteAmount, uint256 updateTime)
    {
        return _peek(base.b6(), quote.b6(), baseAmount);
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.
     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.
     * @param base Id of base token
     * @param quote Id of quoted token
     * @return quoteAmount Total amount in terms of quoted token
     * @return updateTime Time quote was last updated
     */
    function get(
        bytes32 base,
        bytes32 quote,
        uint256 baseAmount
    )
        external
        virtual
        override
        returns (uint256 quoteAmount, uint256 updateTime)
    {
        return _peek(base.b6(), quote.b6(), baseAmount);
    }

    /**
     * @notice Retrieve the value of the amount at the latest oracle price.
     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.
     * @param base Id of base token
     * @param quote Id of quoted token
     * @return quoteAmount Total amount in terms of quoted token
     * @return updateTime Time quote was last updated
     */
    function _peek(
        bytes6 base,
        bytes6 quote,
        uint256 baseAmount
    ) private view returns (uint256 quoteAmount, uint256 updateTime) {
        require(
            (base == ethId && quote == cvx3CrvId) ||
                (base == cvx3CrvId && quote == ethId),
            ""Invalid quote or base""
        );
        (, int256 daiPrice, , , ) = DAI.latestRoundData();
        (, int256 usdcPrice, , , ) = USDC.latestRoundData();
        (, int256 usdtPrice, , , ) = USDT.latestRoundData();

        require(
            daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0,
            ""Chainlink pricefeed reporting 0""
        );

        // This won't overflow as the max value for int256 is less than the max value for uint256
        uint256 minStable = min(
            uint256(daiPrice),
            min(uint256(usdcPrice), uint256(usdtPrice))
        );

        uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18;

        if (base == cvx3CrvId && quote == ethId) {
            quoteAmount = (baseAmount * price) / 1e18;
        } else {
            quoteAmount = (baseAmount * 1e18) / price;
        }

        updateTime = block.timestamp;
    }
}",1236.0,147.0,"[M-01] Oracle data feed is insufficiently validated
Price can be stale and can lead to wrong `quoteAmount` return value in function _peek()
Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong quoteAmount return value",1.0,"pragma solidity 0.8.6;

import ""@yield-protocol/utils-v2/contracts/access/AccessControl.sol"";
import ""@yield-protocol/vault-interfaces/IOracle.sol"";
import ""@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol"";

import ""./interfaces/ICurvePool.sol"";
import ""./interfaces/AggregatorV3Interface.sol"";



contract Cvx3CrvOracle is IOracle, AccessControl {
    using CastBytes32Bytes6 for bytes32;
    ICurvePool public threecrv;
    AggregatorV3Interface public DAI;
    AggregatorV3Interface public USDC;
    AggregatorV3Interface public USDT;

    bytes32 public cvx3CrvId;
    bytes32 public ethId;

    
    function setSource(
        bytes32 cvx3CrvId_,
        bytes32 ethId_,
        ICurvePool threecrv_,
        AggregatorV3Interface DAI_,
        AggregatorV3Interface USDC_,
        AggregatorV3Interface USDT_
    ) external auth {
        cvx3CrvId = cvx3CrvId_;
        ethId = ethId_;
        threecrv = threecrv_;
        DAI = DAI_;
        USDC = USDC_;
        USDT = USDT_;
    }

    
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    
    function peek(
        bytes32 base,
        bytes32 quote,
        uint256 baseAmount
    )
        external
        view
        virtual
        override
        returns (uint256 quoteAmount, uint256 updateTime)
    {
        return _peek(base.b6(), quote.b6(), baseAmount);
    }

    
    function get(
        bytes32 base,
        bytes32 quote,
        uint256 baseAmount
    )
        external
        virtual
        override
        returns (uint256 quoteAmount, uint256 updateTime)
    {
        return _peek(base.b6(), quote.b6(), baseAmount);
    }

    
    function _peek(
        bytes6 base,
        bytes6 quote,
        uint256 baseAmount
    ) private view returns (uint256 quoteAmount, uint256 updateTime) {
        require(
            (base == ethId && quote == cvx3CrvId) ||
                (base == cvx3CrvId && quote == ethId),
            ""Invalid quote or base""
        );
        (, int256 daiPrice, , , ) = DAI.latestRoundData();
        (, int256 usdcPrice, , , ) = USDC.latestRoundData();
        (, int256 usdtPrice, , , ) = USDT.latestRoundData();

        require(
            daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0,
            ""Chainlink pricefeed reporting 0""
        );

        
        uint256 minStable = min(
            uint256(daiPrice),
            min(uint256(usdcPrice), uint256(usdtPrice))
        );

        uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18;

        if (base == cvx3CrvId && quote == ethId) {
            quoteAmount = (baseAmount * price) / 1e18;
        } else {
            quoteAmount = (baseAmount * 1e18) / price;
        }

        updateTime = block.timestamp;
    }
}",740.0,0,1,"Identifying vulnerabilities
I’m pulling together vulnerabilities in the smart contract, focusing on Solidity code issues. This involves pinpointing common security flaws to ensure a comprehensive review.
Identifying critical risks
Mapping out all serious smart contract vulnerabilities to ensure a thorough security analysis.
Pinpointing vulnerabilities
Identifying all critical vulnerabilities in the smart contract code to ensure no detail is overlooked in the security assessment process.
Spotting security gaps
I’m examining the smart contract code, identifying all security vulnerabilities without considering mitigation strategies. This thorough analysis is crucial for a comprehensive security review.
","Here are some potential vulnerabilities in the provided smart contract:

1. **Unrestricted `setSource` Function**: 
   - The `setSource` function can change key variables such as `cvx3CrvId`, `ethId`, and the price feeds (`DAI`, `USDC`, `USDT`). However, it is only protected by the `auth` modifier, which is part of the `AccessControl` contract. If the access control is misconfigured or if an attacker gains access to the `auth` role, they can maliciously change the contract's behavior, potentially manipulating price feeds.

2. **Reentrancy Risk**:
   - The contract interacts with external contracts (`ICurvePool`, `AggregatorV3Interface`) in the `_peek` function. Although there are no direct calls that would allow reentrancy within the `_peek` function itself, if one of the external contracts has reentrancy vulnerabilities, this contract could be susceptible to attacks if it interacts with those contracts.

3. **Lack of Price Feed Validation**:
   - The contract checks whether the price feeds (DAI, USDC, USDT) are greater than 0 but does not check if the values are reasonable or valid. If the price feeds report unusually high or low values, it could lead to price manipulation or inaccurate calculations. 

4. **Magic Numbers**:
   - The contract uses `1e18` in the price calculation, which could be a ""magic number"" that is unclear in purpose. If it's used for scaling, there should be a clear documentation of its intent to prevent confusion or misuse.

5. **No Handling of Failed External Calls**:
   - The contract calls external functions like `latestRoundData` on the Chainlink oracles. If these external calls fail or return unexpected results (e.g., the oracle is down or returns erroneous data), the contract may behave incorrectly. The contract does not have a fallback or error-handling mechanism in case of failure from these external sources.

6. **Missing Access Control on Internal Functions**:
   - The `_peek` function is private, but if the design changes, there might be a risk if it were to be made public or internal without proper access control.

7. **Lack of Events**:
   - There are no events emitted in key areas of the contract, such as when the source is set using `setSource` or when prices are successfully retrieved and calculations are performed. This can make it difficult to track the contract's behavior or debug issues.

8. **No Protection Against Div/Mod by Zero**:
   - In the price calculation, there's a division by `1e18`, but there is no check to ensure that the denominator (price) is not zero. Although the contract checks if the price feeds are greater than 0, there's still a potential risk if there’s any issue with the virtual price returned by `threecrv.get_virtual_price()`.","---

**[M-01] Oracle data feed is insufficiently validated**

**Report Description**:
The oracle data feed in the `_peek` function is insufficiently validated. Specifically, there is no check for stale prices or round completeness. This can lead to incorrect `quoteAmount` return values if the price data is stale or incomplete, potentially causing financial losses or manipulation.

**Match in Response List**:
Matches with the issue titled **""Lack of Price Feed Validation""**.

**Validation**:
**Partially Correct**. The response identifies the issue of insufficient price feed validation, which aligns with the reported issue. However, it misses critical details such as the lack of checks for stale prices and round completeness, which are explicitly mentioned in the issue report. While the response correctly highlights the risk of inaccurate price data, it does not fully address the specific vulnerabilities related to stale data and round completeness.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-01] Oracle data feed is insufficiently validated**

**Missed Issues from Issue Report**:
- *None*

---",0,1,0,8,"```
None.
```",0.0
ConvexStakingWrapper.sol,"// SPDX-License-Identifier: MIT
// Original contract: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol
pragma solidity 0.8.6;

import ""@yield-protocol/utils-v2/contracts/token/IERC20.sol"";
import ""@yield-protocol/utils-v2/contracts/token/ERC20.sol"";
import ""@yield-protocol/utils-v2/contracts/access/AccessControl.sol"";
import ""@yield-protocol/utils-v2/contracts/token/TransferHelper.sol"";
import ""./interfaces/IRewardStaking.sol"";
import ""./interfaces/IConvexDeposits.sol"";
import ""./interfaces/ICvx.sol"";
import ""./CvxMining.sol"";

/// @notice Wrapper used to manage staking of Convex tokens
contract ConvexStakingWrapper is ERC20, AccessControl {
    using TransferHelper for IERC20;

    struct EarnedData {
        address token;
        uint256 amount;
    }

    struct RewardType {
        address reward_token;
        address reward_pool;
        uint128 reward_integral;
        uint128 reward_remaining;
        mapping(address => uint256) reward_integral_for;
        mapping(address => uint256) claimable_reward;
    }

    uint256 public cvx_reward_integral;
    uint256 public cvx_reward_remaining;
    mapping(address => uint256) public cvx_reward_integral_for;
    mapping(address => uint256) public cvx_claimable_reward;

    //constants/immutables
    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    address public curveToken;
    address public convexToken;
    address public convexPool;
    address public collateralVault;
    uint256 public convexPoolId;

    //rewards
    RewardType[] public rewards;

    //management
    bool public isShutdown;
    bool private _status;

    bool private constant _NOT_ENTERED = false;
    bool private constant _ENTERED = true;

    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);
    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);

    constructor(
        address _curveToken,
        address _convexToken,
        address _convexPool,
        uint256 _poolId,
        address _vault,
        string memory name,
        string memory symbol,
        uint8 decimals
    ) ERC20(name, symbol, decimals) {
        curveToken = _curveToken;
        convexToken = _convexToken;
        convexPool = _convexPool;
        convexPoolId = _poolId;
        collateralVault = _vault;

        //add rewards
        addRewards();
        setApprovals();
    }

    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");
        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
        _;
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }

    /// @notice Give maximum approval to the pool & convex booster contract to transfer funds from wrapper
    function setApprovals() public {
        IERC20(curveToken).approve(convexBooster, 0);
        IERC20(curveToken).approve(convexBooster, type(uint256).max);
        IERC20(convexToken).approve(convexPool, type(uint256).max);
    }

    /// @notice Adds reward tokens by reading the available rewards from the RewardStaking pool
    /// @dev CRV token is added as a reward by default
    function addRewards() public {
        address mainPool = convexPool;

        uint256 rewardsLength = rewards.length;

        if (rewardsLength == 0) {
            RewardType storage reward = rewards.push();
            reward.reward_token = crv;
            reward.reward_pool = mainPool;
            rewardsLength += 1;
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        uint256 startIndex = rewardsLength - 1;
        for (uint256 i = startIndex; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            RewardType storage reward = rewards.push();
            reward.reward_token = IRewardStaking(extraPool).rewardToken();
            reward.reward_pool = extraPool;
        }
    }

    /// @notice Returns the length of the reward tokens added
    /// @return The count of reward tokens
    function rewardLength() external view returns (uint256) {
        return rewards.length;
    }

    /// @notice Get user's balance
    /// @param _account User's address for which balance is requested
    /// @return User's balance of collateral
    /// @dev Included here to allow inheriting contracts to override.
    function _getDepositedBalance(address _account) internal view virtual returns (uint256) {
        if (_account == address(0) || _account == collateralVault) {
            return 0;
        }
        //get balance from collateralVault

        return _balanceOf[_account];
    }

    /// @notice TotalSupply of wrapped token
    /// @return The total supply of wrapped token
    /// @dev This function is provided and marked virtual as convenience to future development
    function _getTotalSupply() internal view virtual returns (uint256) {
        return _totalSupply;
    }

    /// @notice Calculates & upgrades the integral for distributing the CVX rewards
    /// @param _accounts Accounts for which the CvxIntegral has to be calculated
    /// @param _balances Balances of the accounts
    /// @param _supply Total supply of the wrapped token
    /// @param _isClaim Whether to claim the calculated rewards
    function _calcCvxIntegral(
        address[2] memory _accounts,
        uint256[2] memory _balances,
        uint256 _supply,
        bool _isClaim
    ) internal {
        uint256 bal = IERC20(cvx).balanceOf(address(this));
        uint256 cvxRewardRemaining = cvx_reward_remaining;
        uint256 d_cvxreward = bal - cvxRewardRemaining;
        uint256 cvxRewardIntegral = cvx_reward_integral;

        if (_supply > 0 && d_cvxreward > 0) {
            cvxRewardIntegral = cvxRewardIntegral + (d_cvxreward * 1e20) / (_supply);
            cvx_reward_integral = cvxRewardIntegral;
        }

        //update user integrals for cvx
        uint256 accountsLength = _accounts.length;
        for (uint256 u = 0; u < accountsLength; u++) {
            //do not give rewards to address 0
            if (_accounts[u] == address(0)) continue;
            if (_accounts[u] == collateralVault) continue;

            uint256 userI = cvx_reward_integral_for[_accounts[u]];
            if (_isClaim || userI < cvxRewardIntegral) {
                uint256 receiveable = cvx_claimable_reward[_accounts[u]] +
                    ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);
                if (_isClaim) {
                    if (receiveable > 0) {
                        cvx_claimable_reward[_accounts[u]] = 0;
                        IERC20(cvx).safeTransfer(_accounts[u], receiveable);
                        bal = bal - (receiveable);
                    }
                } else {
                    cvx_claimable_reward[_accounts[u]] = receiveable;
                }
                cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral;
            }
        }

        //update reward total
        if (bal != cvxRewardRemaining) {
            cvx_reward_remaining = bal;
        }
    }

    /// @notice Calculates & upgrades the integral for distributing the reward token
    /// @param _index The index of the reward token for which the calculations are to be done
    /// @param _accounts Accounts for which the CvxIntegral has to be calculated
    /// @param _balances Balances of the accounts
    /// @param _supply Total supply of the wrapped token
    /// @param _isClaim Whether to claim the calculated rewards
    function _calcRewardIntegral(
        uint256 _index,
        address[2] memory _accounts,
        uint256[2] memory _balances,
        uint256 _supply,
        bool _isClaim
    ) internal {
        RewardType storage reward = rewards[_index];

        uint256 rewardIntegral = reward.reward_integral;
        uint256 rewardRemaining = reward.reward_remaining;

        //get difference in balance and remaining rewards
        //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed
        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));
        if (_supply > 0 && (bal - rewardRemaining) > 0) {
            rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);
            reward.reward_integral = uint128(rewardIntegral);
        }
        //update user integrals
        uint256 accountsLength = _accounts.length;
        for (uint256 u = 0; u < accountsLength; u++) {
            //do not give rewards to address 0
            if (_accounts[u] == address(0)) continue;
            if (_accounts[u] == collateralVault) continue;

            uint256 userI = reward.reward_integral_for[_accounts[u]];
            if (_isClaim || userI < rewardIntegral) {
                if (_isClaim) {
                    uint256 receiveable = reward.claimable_reward[_accounts[u]] +
                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);
                    if (receiveable > 0) {
                        reward.claimable_reward[_accounts[u]] = 0;
                        IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);
                        bal = bal - receiveable;
                    }
                } else {
                    reward.claimable_reward[_accounts[u]] =
                        reward.claimable_reward[_accounts[u]] +
                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);
                }
                reward.reward_integral_for[_accounts[u]] = rewardIntegral;
            }
        }

        //update remaining reward here since balance could have changed if claiming
        if (bal != rewardRemaining) {
            reward.reward_remaining = uint128(bal);
        }
    }

    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them
    /// @param _accounts The accounts for which checkpoints have to be calculated
    function _checkpoint(address[2] memory _accounts) internal {
        //if shutdown, no longer checkpoint in case there are problems
        if (isShutdown) return;

        uint256 supply = _getTotalSupply();
        uint256[2] memory depositedBalance;
        depositedBalance[0] = _getDepositedBalance(_accounts[0]);
        depositedBalance[1] = _getDepositedBalance(_accounts[1]);

        IRewardStaking(convexPool).getReward(address(this), true);

        uint256 rewardCount = rewards.length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);
        }
        _calcCvxIntegral(_accounts, depositedBalance, supply, false);
    }

    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them & claims the rewards
    /// @param _accounts The accounts for which checkpoints have to be calculated
    function _checkpointAndClaim(address[2] memory _accounts) internal {
        uint256 supply = _getTotalSupply();
        uint256[2] memory depositedBalance;
        depositedBalance[0] = _getDepositedBalance(_accounts[0]); //only do first slot

        IRewardStaking(convexPool).getReward(address(this), true);

        uint256 rewardCount = rewards.length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(i, _accounts, depositedBalance, supply, true);
        }
        _calcCvxIntegral(_accounts, depositedBalance, supply, true);
    }

    /// @notice Create a checkpoint for the supplied addresses by updating the reward integrals & claimable reward for them
    /// @param _accounts The accounts for which checkpoints have to be calculated
    function user_checkpoint(address[2] calldata _accounts) external returns (bool) {
        _checkpoint([_accounts[0], _accounts[1]]);
        return true;
    }

    /// @notice Get the balance of the user
    /// @param _account Address whose balance is to be checked
    /// @return The balance of the supplied address
    function totalBalanceOf(address _account) external view returns (uint256) {
        return _getDepositedBalance(_account);
    }

    /// @notice Get the amount of tokens the user has earned
    /// @param _account Address whose balance is to be checked
    /// @return claimable Array of earned tokens and their amount
    function earned(address _account) external view returns (EarnedData[] memory claimable) {
        uint256 supply = _getTotalSupply();
        uint256 rewardCount = rewards.length;
        claimable = new EarnedData[](rewardCount + 1);

        for (uint256 i = 0; i < rewardCount; i++) {
            RewardType storage reward = rewards[i];
            address rewardToken = reward.reward_token;

            //change in reward is current balance - remaining reward + earned
            uint256 bal = IERC20(rewardToken).balanceOf(address(this));
            uint256 d_reward = bal - reward.reward_remaining;
            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));

            uint256 I = reward.reward_integral;
            if (supply > 0) {
                I = I + (d_reward * 1e20) / supply;
            }

            uint256 newlyClaimable = (_getDepositedBalance(_account) * (I - reward.reward_integral_for[_account])) /
                1e20;
            claimable[i].amount = reward.claimable_reward[_account] + newlyClaimable;
            claimable[i].token = rewardToken;

            //calc cvx here
            if (rewardToken == crv) {
                claimable[rewardCount].amount =
                    cvx_claimable_reward[_account] +
                    CvxMining.ConvertCrvToCvx(newlyClaimable);
                claimable[rewardCount].token = cvx;
            }
        }
        return claimable;
    }

    /// @notice Claim reward for the supplied account
    /// @param _account Address whose reward is to be claimed
    function getReward(address _account) external {
        //claim directly in checkpoint logic to save a bit of gas
        _checkpointAndClaim([_account, address(0)]);
    }
}",3329.0,351.0,"[M-02] Rewards distribution can be disrupted by a early user
`reward.reward_integral` is `uint128`, if a early user mint (wrap) just 1 Wei of `convexToken`, and make `_supply == 1`, and then tranferring `5e18` of `reward_token` to the contract. As a result, `reward.reward_integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.",1.0,"pragma solidity 0.8.6;

import ""@yield-protocol/utils-v2/contracts/token/IERC20.sol"";
import ""@yield-protocol/utils-v2/contracts/token/ERC20.sol"";
import ""@yield-protocol/utils-v2/contracts/access/AccessControl.sol"";
import ""@yield-protocol/utils-v2/contracts/token/TransferHelper.sol"";
import ""./interfaces/IRewardStaking.sol"";
import ""./interfaces/IConvexDeposits.sol"";
import ""./interfaces/ICvx.sol"";
import ""./CvxMining.sol"";


contract ConvexStakingWrapper is ERC20, AccessControl {
    using TransferHelper for IERC20;

    struct EarnedData {
        address token;
        uint256 amount;
    }

    struct RewardType {
        address reward_token;
        address reward_pool;
        uint128 reward_integral;
        uint128 reward_remaining;
        mapping(address => uint256) reward_integral_for;
        mapping(address => uint256) claimable_reward;
    }

    uint256 public cvx_reward_integral;
    uint256 public cvx_reward_remaining;
    mapping(address => uint256) public cvx_reward_integral_for;
    mapping(address => uint256) public cvx_claimable_reward;

    
    address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    address public curveToken;
    address public convexToken;
    address public convexPool;
    address public collateralVault;
    uint256 public convexPoolId;

    
    RewardType[] public rewards;

    
    bool public isShutdown;
    bool private _status;

    bool private constant _NOT_ENTERED = false;
    bool private constant _ENTERED = true;

    event Deposited(address indexed _user, address indexed _account, uint256 _amount, bool _wrapped);
    event Withdrawn(address indexed _user, uint256 _amount, bool _unwrapped);

    constructor(
        address _curveToken,
        address _convexToken,
        address _convexPool,
        uint256 _poolId,
        address _vault,
        string memory name,
        string memory symbol,
        uint8 decimals
    ) ERC20(name, symbol, decimals) {
        curveToken = _curveToken;
        convexToken = _convexToken;
        convexPool = _convexPool;
        convexPoolId = _poolId;
        collateralVault = _vault;

        
        addRewards();
        setApprovals();
    }

    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");
        
        _status = _ENTERED;
        _;
        
        
        _status = _NOT_ENTERED;
    }

    
    function setApprovals() public {
        IERC20(curveToken).approve(convexBooster, 0);
        IERC20(curveToken).approve(convexBooster, type(uint256).max);
        IERC20(convexToken).approve(convexPool, type(uint256).max);
    }

    
    
    function addRewards() public {
        address mainPool = convexPool;

        uint256 rewardsLength = rewards.length;

        if (rewardsLength == 0) {
            RewardType storage reward = rewards.push();
            reward.reward_token = crv;
            reward.reward_pool = mainPool;
            rewardsLength += 1;
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        uint256 startIndex = rewardsLength - 1;
        for (uint256 i = startIndex; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            RewardType storage reward = rewards.push();
            reward.reward_token = IRewardStaking(extraPool).rewardToken();
            reward.reward_pool = extraPool;
        }
    }

    
    
    function rewardLength() external view returns (uint256) {
        return rewards.length;
    }

    
    
    
    
    function _getDepositedBalance(address _account) internal view virtual returns (uint256) {
        if (_account == address(0) || _account == collateralVault) {
            return 0;
        }
        

        return _balanceOf[_account];
    }

    
    
    
    function _getTotalSupply() internal view virtual returns (uint256) {
        return _totalSupply;
    }

    
    
    
    
    
    function _calcCvxIntegral(
        address[2] memory _accounts,
        uint256[2] memory _balances,
        uint256 _supply,
        bool _isClaim
    ) internal {
        uint256 bal = IERC20(cvx).balanceOf(address(this));
        uint256 cvxRewardRemaining = cvx_reward_remaining;
        uint256 d_cvxreward = bal - cvxRewardRemaining;
        uint256 cvxRewardIntegral = cvx_reward_integral;

        if (_supply > 0 && d_cvxreward > 0) {
            cvxRewardIntegral = cvxRewardIntegral + (d_cvxreward * 1e20) / (_supply);
            cvx_reward_integral = cvxRewardIntegral;
        }

        
        uint256 accountsLength = _accounts.length;
        for (uint256 u = 0; u < accountsLength; u++) {
            
            if (_accounts[u] == address(0)) continue;
            if (_accounts[u] == collateralVault) continue;

            uint256 userI = cvx_reward_integral_for[_accounts[u]];
            if (_isClaim || userI < cvxRewardIntegral) {
                uint256 receiveable = cvx_claimable_reward[_accounts[u]] +
                    ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);
                if (_isClaim) {
                    if (receiveable > 0) {
                        cvx_claimable_reward[_accounts[u]] = 0;
                        IERC20(cvx).safeTransfer(_accounts[u], receiveable);
                        bal = bal - (receiveable);
                    }
                } else {
                    cvx_claimable_reward[_accounts[u]] = receiveable;
                }
                cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral;
            }
        }

        
        if (bal != cvxRewardRemaining) {
            cvx_reward_remaining = bal;
        }
    }

    
    
    
    
    
    
    function _calcRewardIntegral(
        uint256 _index,
        address[2] memory _accounts,
        uint256[2] memory _balances,
        uint256 _supply,
        bool _isClaim
    ) internal {
        RewardType storage reward = rewards[_index];

        uint256 rewardIntegral = reward.reward_integral;
        uint256 rewardRemaining = reward.reward_remaining;

        
        
        uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));
        if (_supply > 0 && (bal - rewardRemaining) > 0) {
            rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);
            reward.reward_integral = uint128(rewardIntegral);
        }
        
        uint256 accountsLength = _accounts.length;
        for (uint256 u = 0; u < accountsLength; u++) {
            
            if (_accounts[u] == address(0)) continue;
            if (_accounts[u] == collateralVault) continue;

            uint256 userI = reward.reward_integral_for[_accounts[u]];
            if (_isClaim || userI < rewardIntegral) {
                if (_isClaim) {
                    uint256 receiveable = reward.claimable_reward[_accounts[u]] +
                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);
                    if (receiveable > 0) {
                        reward.claimable_reward[_accounts[u]] = 0;
                        IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);
                        bal = bal - receiveable;
                    }
                } else {
                    reward.claimable_reward[_accounts[u]] =
                        reward.claimable_reward[_accounts[u]] +
                        ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);
                }
                reward.reward_integral_for[_accounts[u]] = rewardIntegral;
            }
        }

        
        if (bal != rewardRemaining) {
            reward.reward_remaining = uint128(bal);
        }
    }

    
    
    function _checkpoint(address[2] memory _accounts) internal {
        
        if (isShutdown) return;

        uint256 supply = _getTotalSupply();
        uint256[2] memory depositedBalance;
        depositedBalance[0] = _getDepositedBalance(_accounts[0]);
        depositedBalance[1] = _getDepositedBalance(_accounts[1]);

        IRewardStaking(convexPool).getReward(address(this), true);

        uint256 rewardCount = rewards.length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(i, _accounts, depositedBalance, supply, false);
        }
        _calcCvxIntegral(_accounts, depositedBalance, supply, false);
    }

    
    
    function _checkpointAndClaim(address[2] memory _accounts) internal {
        uint256 supply = _getTotalSupply();
        uint256[2] memory depositedBalance;
        depositedBalance[0] = _getDepositedBalance(_accounts[0]); 

        IRewardStaking(convexPool).getReward(address(this), true);

        uint256 rewardCount = rewards.length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(i, _accounts, depositedBalance, supply, true);
        }
        _calcCvxIntegral(_accounts, depositedBalance, supply, true);
    }

    
    
    function user_checkpoint(address[2] calldata _accounts) external returns (bool) {
        _checkpoint([_accounts[0], _accounts[1]]);
        return true;
    }

    
    
    
    function totalBalanceOf(address _account) external view returns (uint256) {
        return _getDepositedBalance(_account);
    }

    
    
    
    function earned(address _account) external view returns (EarnedData[] memory claimable) {
        uint256 supply = _getTotalSupply();
        uint256 rewardCount = rewards.length;
        claimable = new EarnedData[](rewardCount + 1);

        for (uint256 i = 0; i < rewardCount; i++) {
            RewardType storage reward = rewards[i];
            address rewardToken = reward.reward_token;

            
            uint256 bal = IERC20(rewardToken).balanceOf(address(this));
            uint256 d_reward = bal - reward.reward_remaining;
            d_reward = d_reward + IRewardStaking(reward.reward_pool).earned(address(this));

            uint256 I = reward.reward_integral;
            if (supply > 0) {
                I = I + (d_reward * 1e20) / supply;
            }

            uint256 newlyClaimable = (_getDepositedBalance(_account) * (I - reward.reward_integral_for[_account])) /
                1e20;
            claimable[i].amount = reward.claimable_reward[_account] + newlyClaimable;
            claimable[i].token = rewardToken;

            
            if (rewardToken == crv) {
                claimable[rewardCount].amount =
                    cvx_claimable_reward[_account] +
                    CvxMining.ConvertCrvToCvx(newlyClaimable);
                claimable[rewardCount].token = cvx;
            }
        }
        return claimable;
    }

    
    
    function getReward(address _account) external {
        
        _checkpointAndClaim([_account, address(0)]);
    }
}",2515.0,0,1,"Listing vulnerabilities
I’m working through identifying vulnerabilities in the smart contract without detailing mitigations. This involves a thorough code review and employing security tools.
Highlighting key issues
I'm outlining the main vulnerabilities in the smart contract's code, ensuring a detailed assessment without focusing on remedies. This approach is essential for understanding the current security status.
Analyzing the code
I'm starting by identifying potential vulnerabilities and assessing their impact, without suggesting mitigations, to provide a comprehensive view of the risks present in the smart contract.
Identifying vulnerabilities
I’m mapping out the main vulnerabilities in the smart contract code, focusing on their practical implications and assessing the overall security posture. This approach helps in pinpointing weaknesses effectively.
","Here are some potential vulnerabilities identified in the provided smart contract:

1. **Reentrancy Risk**: Although the contract uses a `nonReentrant` modifier to protect against reentrancy attacks, there are still multiple functions that call external contracts (e.g., `getReward`, `IRewardStaking(convexPool).getReward`, and `IERC20.safeTransfer`). These calls could still lead to reentrancy vulnerabilities if not properly safeguarded.

2. **Uninitialized Reward Token Addresses**: The `addRewards()` function does not guarantee that the reward tokens are properly initialized for all reward pools. If the external reward pool's `rewardToken` address is incorrect or not initialized, it could lead to undefined behavior or loss of rewards.

3. **Inconsistent `cvx_claimable_reward` Calculation**: The function `_calcCvxIntegral` uses a claimable rewards calculation based on the current `cvx_claimable_reward`. However, if there are discrepancies or unexpected values in the reward calculation process (such as due to malicious manipulation or unforeseen external factors), users could be overpaid or underpaid in rewards.

4. **Lack of Access Control for `setApprovals()`**: The function `setApprovals()` is publicly callable. This function approves maximum allowances for `curveToken` and `convexToken` to external addresses (`convexBooster` and `convexPool`). This could lead to unauthorized manipulation of token allowances if someone with access to this function could alter the approval settings maliciously.

5. **Lack of Circuit Breaker**: While the contract has an `isShutdown` flag, it is not utilized in all critical functions. For example, if an emergency occurs where further interactions should be stopped, the flag is not checked in the `addRewards()` or `setApprovals()` functions, allowing potential damage from malicious actors or bugs.

6. **Unprotected Token Transfers**: The function `getReward` calls the `_checkpointAndClaim` function, which then calls external functions to transfer tokens (`safeTransfer`). If the transfer logic is not well-protected (e.g., if the token's transfer function has bugs or is subject to reentrancy), users could lose their funds.

7. **Inadequate Input Validation**: The function `_getDepositedBalance()` allows any address to be checked for its balance. However, it does not check the validity of the address beyond ensuring it is not the collateral vault or zero address, meaning potential malicious interactions with invalid addresses might not be properly handled.

8. **Gas Optimization Issues**: Functions such as `_calcCvxIntegral` and `_calcRewardIntegral` involve complex loops over multiple accounts and balances. This could result in high gas costs, especially in scenarios with a large number of users or rewards, potentially causing the contract to be unusable if the gas costs exceed block limits.

9. **Overflow/Underflow**: While Solidity 0.8.x includes built-in overflow/underflow protection, it is essential to ensure that functions that manipulate large values (e.g., the reward integrals and balances) are safe from unexpected behaviors due to improper input or edge cases.

10. **Potential Issues with `extraRewards` Handling**: The function `addRewards()` dynamically adds reward tokens based on the length of `extraRewards` from the external `IRewardStaking` contract. This logic could be faulty if the external contract behaves unexpectedly or if there are issues with retrieving the extra reward pools.

11. **Lack of Gas Efficiency for `earned` Function**: The `earned` function performs a series of token balance checks and reward calculations for every reward token in the rewards array. This could be expensive in terms of gas, particularly if the number of rewards grows over time, leading to possible issues with gas limits during claims.

12. **Unreliable State Updates**: The function `_calcCvxIntegral` updates global variables (`cvx_reward_integral`, `cvx_claimable_reward`, etc.) based on complex calculations. In case of an exception, a failure in any part of the process could leave the contract in an inconsistent state.

13. **Incorrect Use of `mapping`**: The reward type uses mappings (`reward_integral_for` and `claimable_reward`) within the `RewardType` struct, which may result in unexpected behavior if the mappings are not correctly reset or updated. Additionally, iterating over these mappings can become inefficient if there are a large number of users.","### **[M-02] Rewards distribution can be disrupted by an early user**

**Report Description**:  
The issue arises due to the use of `uint128` for `reward.reward_integral`. If an early user mints (wraps) just 1 Wei of `convexToken`, making `_supply == 1`, and then transfers `5e18` of `reward_token` to the contract, `reward.reward_integral` can exceed `type(uint128).max` and overflow. This overflow disrupts the rewards distribution mechanism, potentially leading to incorrect reward calculations and distribution failures.

**Match in Response List**:  
Matches with the issue titled **""Overflow/Underflow""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the general risk of overflow/underflow in the contract, which aligns with the issue described. However, it does not specifically address the scenario where an early user can manipulate `_supply` to cause an overflow in `reward.reward_integral`. The response lacks the detailed context and specific impact of this vulnerability, making it only partially correct.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-02] Rewards distribution can be disrupted by an early user**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis of Gaps**  
While the response list covers the general risk of overflow/underflow, it does not delve into the specific scenario described in the issue report. This highlights a gap in the response list's ability to address nuanced vulnerabilities that arise from edge cases or specific user behaviors. To improve, the response list should include more detailed examples or scenarios that illustrate how overflow/underflow vulnerabilities can manifest in practice.",0,1,0,13,"```
None.
```",0.0
,,,,,,,,2,2,,,,0,2,2,31,,
