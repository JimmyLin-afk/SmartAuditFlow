nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,Reasoning,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
SwappableYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";

/// @title Swappable yield source contract to allow a PoolTogether prize pool to swap between different yield sources.
/// @dev This contract adheres to the PoolTogether yield source interface.
/// @dev This contract inherits AssetManager which extends OwnableUpgradable.
/// @notice Swappable yield source for a PoolTogether prize pool that generates yield by depositing into the specified yield source.
contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  /// @notice Emitted when the swappable yield source is initialized.
  /// @param yieldSource Address of yield source used to initialize this swappable yield source.
  /// @param decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param owner Swappable yield source owner.
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  /// @notice Emitted when a yield source has been successfuly set.
  /// @param yieldSource Yield source address that was set.
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  /// @notice Emitted when funds are successfully transferred from specified yield source to current yield source.
  /// @param yieldSource Yield source address that provided funds.
  /// @param amount Amount of funds transferred.
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  /// @notice Emitted when ERC20 tokens other than yield source's tokens are withdrawn from the swappable yield source.
  /// @param from Address that transferred funds.
  /// @param to Address that received funds.
  /// @param amount Amount of tokens transferred.
  /// @param token ERC20 token transferred.
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  /// @notice Yield source interface.
  IYieldSource public yieldSource;

  /// @notice Mock Initializer to initialize implementations used by minimal proxies.
  function freeze() public initializer {
    //no-op
  }

  /// @notice Hack to determine if address passed is an actual yield source.
  /// @dev If depositTokenAddressData.length is not superior to 0, then staticcall didn't return any data.
  /// @param _yieldSource Yield source address to check.
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  /// @notice Initializes the swappable yield source with the yieldSource address provided.
  /// @dev We approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI), to save gas for future calls.
  /// @param _yieldSource Yield source address used to initialize this swappable yield source.
  /// @param _decimals Number of decimals the shares (inherited ERC20) will have.  Same as underlying asset to ensure same ExchangeRates.
  /// @param _symbol Token symbol for the underlying ERC20 shares (eg: sysDAI).
  /// @param _name Token name for the underlying ERC20 shares (eg: PoolTogether Swappable Yield Source DAI).
  /// @param _owner Swappable yield source owner.
  /// @return true if operation is successful.
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  /// @notice Approve yieldSource to spend maxUint256 amount of depositToken (eg: DAI).
  /// @dev Emergency function to re-approve max amount if approval amount dropped too low.
  /// @return true if operation is successful.
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  /// @notice Calculates the number of shares that should be minted or burned when a user deposit or withdraw.
  /// @param tokens Amount of tokens.
  /// @return Number of shares.
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      // rate = tokens / shares
      // shares = tokens * (totalShares / swappableYieldSourceTotalSupply)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  /// @notice Calculates the number of tokens a user has in the yield source.
  /// @param shares Amount of shares.
  /// @return Number of tokens.
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      // tokens = shares * (yieldSourceTotalSupply / totalShares)
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  /// @notice Mint tokens to the user.
  /// @dev Shares corresponding to the number of tokens supplied are minted to user's balance.
  /// @param mintAmount Amount of asset tokens to be minted.
  /// @param to User whose balance will receive the tokens.
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  /// @notice Burn shares from user's balance.
  /// @dev Shares corresponding to the number of tokens withdrawn are burnt from user's balance.
  /// @param burnAmount Amount of asset tokens to be burnt.
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  /// @notice Supplies tokens to the current yield source.  Allows assets to be supplied on other user's behalf using the `to` param.
  /// @dev Asset tokens are supplied to the yield source, then deposited into the underlying yield source (eg: Aave, Compound, etc...).
  /// @dev Shares from the yield source are minted to the swappable yield source address (this contract).
  /// @dev Shares from the swappable yield source are minted to the `to` address.
  /// @param amount Amount of `depositToken()` to be supplied.
  /// @param to User whose balance will receive the tokens.
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return ERC20 asset token address.
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  /// @notice Returns the total balance in swappable tokens (eg: swsDAI).
  /// @return Underlying balance of swappable tokens.
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  /// @notice Redeems tokens from the current yield source.
  /// @dev Shares of the swappable yield source address (this contract) are burnt from the yield source.
  /// @dev Shares of the `msg.sender` address are burnt from the swappable yield source.
  /// @param amount Amount of `depositToken()` to withdraw.
  /// @return Actual amount of tokens that were redeemed.
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  /// @notice Determine if passed yield source is different from current yield source.
  /// @param _yieldSource Yield source address to check.
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  /// @notice Set new yield source.
  /// @dev After setting the new yield source, we need to approve it to spend maxUint256 amount of depositToken (eg: DAI).
  /// @param _newYieldSource New yield source address to set.
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  /// @notice Set new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param _newYieldSource New yield source address to set.
  /// @return true if operation is successful.
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We check that the `currentBalance` transferred is at least equal or superior to the `amount` requested.
  /// @dev `currentBalance` can be superior to `amount` if yield has been accruing between redeeming and checking for a mathematical error.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param _amount Amount of funds to transfer from passed yield source to current yield source.
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  /// @notice Transfer funds from specified yield source to current yield source.
  /// @dev We only verify it is a different yield source in the public function cause we already check for it in `_setYieldSource` function.
  /// @param _yieldSource Yield source address to transfer funds from.
  /// @param amount Amount of funds to transfer from passed yield source to current yield source.
  /// @return true if operation is successful.
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  /// @notice Swap current yield source for new yield source.
  /// @dev This function is only callable by the owner or asset manager.
  /// @dev We set a new yield source and then transfer funds from the now previous yield source to the new current yield source.
  /// @param _newYieldSource New yield source address to set and transfer funds to.
  /// @return true if operation is successful.
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  /// @notice Transfer ERC20 tokens other than the yield source's tokens held by this contract to the recipient address.
  /// @dev This function is only callable by the owner or asset manager.
  /// @param erc20Token ERC20 token to transfer.
  /// @param to Recipient of the tokens.
  /// @param amount Amount of tokens to transfer.
  /// @return true if operation is successful.
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",3524,331,"[H-01] `onlyOwnerOrAssetManager` can swap Yield Source in SwappableYieldSource at any time, immediately rugging all funds from old yield source
The function `swapYieldSource` SwappableYieldSource.sol` L307
Can be called by the owner (deployer / initializer) or Asset Manager. The function will take all funds from the old Yield Source, and transfer them to the new Yield source. Any contract that implement the function function depositToken() external returns (address) will pass the check
However, if either the owner or the `assetManager` have malicious intent, this function allows them to instantly rug all funds
- Create a contract that implements the function `depositToken()` external returns (address)
- Be the Owner or AssetManager
- Call setYieldSource while pointing at your malicious contract
- Profit
  [H-02] redeemToken can fail for certain tokens
The `SwappableYieldSource.redeemToken` function transfers tokens from the contract back to the sender, however, it uses the `ERC20.transferFrom(address(this), msg.sender, redeemableBalance)` function for this. Some deposit token implementations might fail as transferFrom checks if the contract approved itself for the redeemableBalance instead of skipping the allowance check in case the sender is the from address.   [H-03] setYieldSource leads to temporary wrong results
The use of `setYieldSource` leaves the contract in a temporary inconsistent state because it changes the underlying yield source, but doesn't (yet) transfer the underlying balances, while the shares stay the same.
The function `balanceOfToken` will show the wrong results, because it is based on `_sharesToToken`, which uses yieldSource.balanceOfToken(address(this)), that isn't updated yet.
More importantly supplyTokenTo will give the wrong amount of shares back: First it supplies tokens to the yieldsource. Then is calls `_mintShares`, which calls `_tokenToShares`, which calculates the shares, using yieldSource.balanceOfToken(address(this)) This yieldSource.balanceOfToken(address(this)) only contains the just supplied tokens, but doesn't include the tokens from the previous YieldSource. So the wrong amount of shares is given back to the user; they will be given more shares than appropriate which means they can drain funds later on (once transferFunds has been done).
  [H-04] SwappableYieldSource: Missing same deposit token check in transferFunds() `transferFunds()` will transfer funds from a specified yield source _yieldSource to the current yield source set in the contract _currentYieldSource. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference. Assumptions:
- `_yieldSource` has a deposit token of WETH (18 decimals)
- `_currentYieldSource` has a deposit token of DAI (18 decimals)
- `1 WETH > 1 DAI` (definitely true, I'd be really sad otherwise)
  [M-01] Single-step process for critical ownership transfer/renounce is risky The `SwappableYieldSource` allows owners and asset managers to set/swap/transfer yield sources/funds. As such, the contract ownership plays a critical role in the protocol.
Given that `AssetManager` is derived from `Ownable`, the ownership management of this contract defaults to `Ownable`’s `transferOwnership()` and `renounceOwnership()` methods which are not overridden here. Such critical address transfer/renouncing in one-step is very risky because it is irrecoverable from any mistakes.   [M-02] Use of `safeApprove` will always cause `approveMax` to revert
Unlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as (1) Deprecated because of approve-like race condition and (2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.
The usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0. See issue page for referenced code.
 
[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens
The `supplyTokenTo` function of SwappableYieldSource assumes that amount of _depositToken is transferred to itself after calling the safeTransferFrom function (and thus it supplies amount of token to the yield source). However, this may not be true if the _depositToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. SwappableYieldSource.sol L211-L212   [M-04] Old yield source still has infinite approval After swapping a yield source, the old yield source still has infinite approval. Infinite approval has been used in large attacks if the yield source isn't perfectly safe (see furucombo).",8,,"pragma solidity 0.7.6;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";
import ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";

import ""./access/AssetManager.sol"";





contract SwappableYieldSource is ERC20Upgradeable, IYieldSource, AssetManager, ReentrancyGuardUpgradeable {
  using SafeMathUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;

  
  
  
  
  
  
  event SwappableYieldSourceInitialized(
    IYieldSource indexed yieldSource,
    uint8 decimals,
    string symbol,
    string name,
    address indexed owner
  );

  
  
  event SwappableYieldSourceSet(
    IYieldSource indexed yieldSource
  );

  
  
  
  event FundsTransferred(
    IYieldSource indexed yieldSource,
    uint256 amount
  );

  
  
  
  
  
  event TransferredERC20(
    address indexed from,
    address indexed to,
    uint256 amount,
    IERC20Upgradeable indexed token
  );

  
  IYieldSource public yieldSource;

  
  function freeze() public initializer {
    
  }

  
  
  
  function _requireYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(0), ""SwappableYieldSource/yieldSource-not-zero-address"");

    (, bytes memory depositTokenAddressData) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));

    bool isInvalidYieldSource;

    if (depositTokenAddressData.length > 0) {
      (address depositTokenAddress) = abi.decode(depositTokenAddressData, (address));

      isInvalidYieldSource = depositTokenAddress != address(0);
    }

    require(isInvalidYieldSource, ""SwappableYieldSource/invalid-yield-source"");
  }

  
  
  
  
  
  
  
  
  function initialize(
    IYieldSource _yieldSource,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  ) public initializer returns (bool) {
    _requireYieldSource(_yieldSource);
    yieldSource = _yieldSource;

    __Ownable_init();

    require(_owner != address(0), ""SwappableYieldSource/owner-not-zero-address"");
    transferOwnership(_owner);

    __ReentrancyGuard_init();

    __ERC20_init(_name, _symbol);
    require(_decimals > 0, ""SwappableYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    IERC20Upgradeable(_yieldSource.depositToken()).safeApprove(address(_yieldSource), type(uint256).max);

    emit SwappableYieldSourceInitialized(
      _yieldSource,
      _decimals,
      _symbol,
      _name,
      _owner
    );

    return true;
  }

  
  
  
  function approveMaxAmount() external onlyOwner returns (bool) {
    IYieldSource _yieldSource = yieldSource;
    IERC20Upgradeable _depositToken = IERC20Upgradeable(_yieldSource.depositToken());

    uint256 allowance = _depositToken.allowance(address(this), address(_yieldSource));
    _depositToken.safeIncreaseAllowance(address(_yieldSource), type(uint256).max.sub(allowance));

    return true;
  }

  
  
  
  function _tokenToShares(uint256 tokens) internal returns (uint256) {
    uint256 shares;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      shares = tokens;
    } else {
      
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(_totalSupply, yieldSource.balanceOfToken(address(this)));
      shares = FixedPoint.multiplyUintByMantissa(tokens, exchangeMantissa);
    }

    return shares;
  }

  
  
  
  function _sharesToToken(uint256 shares) internal returns (uint256) {
    uint256 tokens;
    uint256 _totalSupply = totalSupply();

    if (_totalSupply == 0) {
      tokens = shares;
    } else {
      
      uint256 exchangeMantissa = FixedPoint.calculateMantissa(yieldSource.balanceOfToken(address(this)), _totalSupply);
      tokens = FixedPoint.multiplyUintByMantissa(shares, exchangeMantissa);
    }

    return tokens;
  }

  
  
  
  
  function _mintShares(uint256 mintAmount, address to) internal {
    uint256 shares = _tokenToShares(mintAmount);

    require(shares > 0, ""SwappableYieldSource/shares-gt-zero"");

    _mint(to, shares);
  }

  
  
  
  function _burnShares(uint256 burnAmount) internal {
    uint256 shares = _tokenToShares(burnAmount);
    _burn(msg.sender, shares);
  }

  
  
  
  
  
  
  function supplyTokenTo(uint256 amount, address to) external override nonReentrant {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _depositToken.safeTransferFrom(msg.sender, address(this), amount);
    yieldSource.supplyTokenTo(amount, address(this));

    _mintShares(amount, to);
  }

  
  
  function depositToken() public view override returns (address) {
    return yieldSource.depositToken();
  }

  
  
  function balanceOfToken(address addr) external override returns (uint256) {
    return _sharesToToken(balanceOf(addr));
  }

  
  
  
  
  
  function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }

  
  
  function _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {
    require(address(_yieldSource) != address(yieldSource), ""SwappableYieldSource/same-yield-source"");
  }

  
  
  
  function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }

  
  
  
  
  function setYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    _setYieldSource(_newYieldSource);
    return true;
  }

  
  
  
  
  
  function _transferFunds(IYieldSource _yieldSource, uint256 _amount) internal {
    IYieldSource _currentYieldSource = yieldSource;

    _yieldSource.redeemToken(_amount);
    uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));

    require(_amount <= currentBalance, ""SwappableYieldSource/transfer-amount-different"");

    _currentYieldSource.supplyTokenTo(currentBalance, address(this));

    emit FundsTransferred(_yieldSource, _amount);
  }

  
  
  
  
  
  function transferFunds(IYieldSource _yieldSource, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    _requireDifferentYieldSource(_yieldSource);
    _transferFunds(_yieldSource, amount);
    return true;
  }

  
  
  
  
  
  function swapYieldSource(IYieldSource _newYieldSource) external onlyOwnerOrAssetManager returns (bool) {
    IYieldSource _currentYieldSource = yieldSource;
    uint256 balance = _currentYieldSource.balanceOfToken(address(this));

    _setYieldSource(_newYieldSource);
    _transferFunds(_currentYieldSource, balance);

    return true;
  }

  
  
  
  
  
  
  function transferERC20(IERC20Upgradeable erc20Token, address to, uint256 amount) external onlyOwnerOrAssetManager returns (bool) {
    require(address(erc20Token) != address(yieldSource), ""SwappableYieldSource/yield-source-token-transfer-not-allowed"");
    erc20Token.safeTransfer(to, amount);
    emit TransferredERC20(msg.sender, to, amount, erc20Token);
    return true;
  }
}",1938,4,4,"Assessing smart contract risks
I’m analyzing a Solidity smart contract dubbed SwappableYieldSource, focusing on the ""freeze"" initializer function, which is currently empty. It’s interesting to see that the contract uses the initializer pattern and is written in Solidity 0.7.6.
Assessing yield source validation
The _requireYieldSource function ensures a valid yield source by verifying its address and checking if the depositToken returns a non-zero value. However, potential flaws may arise if the depositToken is zero.
Reassessing function viability
Reevaluating the _requireYieldSource function reveals its potential for reentrancy attacks if the depositToken returns an empty value, leading to a failing require condition.
Examining initializer logic
Interestingly enough, I’m looking into the initializer function's public nature and its potential misuse if not secured, despite the use of OpenZeppelin's initializer modifier, which typically restricts reuse.
Highlighting initializer steps
In the initializer function, I’m noticing safeApprove uses the yieldSource's deposit token. This raises alarms if the deposit token is untrusted or potentially malicious.
Assessing token interaction
I’m mapping out how functions like _tokenToShares and _sharesToToken interface with yieldSource.balanceOfToken. These functions involve state modifications and external calls, warranting a closer look for potential reentrancy risks.
Protecting against reentrancy
I’m analyzing functions like _mintShares for reentrancy risks. Ensuring non-reentrancy and precise fixed-point calculations is key to safeguarding operations against these potential threats.
Assessing potential concerns
OK, let me see. If yieldSource.supplyTokenTo doesn't function as expected, there's an allowance for reentrancy, even with nonReentrant protection. This underscores the importance of stringent controls.
Clarifying token transfer
OK, I’m thinking through the necessity of an allowance for safeTransferFrom to work internally in the contract, which seems unnecessary given the token's existing balance.
Adjusting token transfer logic
I’m working through the redeemToken function's token transfer method. Using safeTransfer instead of safeTransferFrom seems necessary for proper functionality and avoiding misuse.
Navigating yield source risks
Interestingly, _transferFunds potentially mixes yield sources. A malicious _yieldSource could cause unintended behavior when tokens are redeemed and supplied to the existing source.
Evaluating security layers
It's interesting to see the onlyOwnerOrAssetManager mechanism and nonReentrant protection in place. They are essential for minimizing vulnerabilities from reentrancy or faulty yield sources.
Assessing reentrancy risk
OK, let's think it through: balanceOfToken is not marked as nonReentrant, which could expose the system to reentrancy if called inadvertently by other functions.
Assessing contract functions
I'm noticing that approveMaxAmount uses safeIncreaseAllowance, which is essential to prevent overflow. Overall, the potential risks seem manageable with these safeguards in place.
Tracking potential imbalance
It seems challenging to track whether redeemToken uses _tokenToShares correctly. Lack of consistency might lead to users receiving fewer tokens than expected due to malicious yield sources.
Evaluating potential risks
I'm focusing on _transferFunds, swapYieldSource, and _yieldSource in swapYieldSource. If _yieldSource is fraudulent, it could falsely report token balances or manipulate them, leading to financial discrepancies.
Highlighting conversion risk
I'm noticing that swapping yield sources could cause significant financial losses, especially if the redemption fails or the yield sources have different conversion rates.
Assessing risk and action
I’m noting potential reentrancy in _transferFunds due to privileged roles. Also, _burnShares could mistakenly attribute shares to the wrong owner if redemption triggers it.
Identifying input risks
I'm looking at the swapYieldSource and transferFunds functions. Without input validation, misuse of yieldSource addresses might occur. Considering reentrancy and rounding errors is crucial.
Evaluating staticcall vulnerabilities
I'm examining the staticcall with abi.encode(_yieldSource.depositToken.selector). This could be exploited by a malicious yield source to return non-standard outputs or manipulate data.
Spotting reentrancy flaws
I’m realizing that the absence of nonReentrant guards in transferFunds and swapYieldSource functions makes them vulnerable to reentrancy attacks when interacting with external yield sources.
Evaluating token transfer methods
Considering the shift from safeTransferFrom to safeTransfer in redeemToken to avoid fund lock, and noting precision issues in conversion functions.
Weighing functionality
Considering the benefits and potential drawbacks of allowing asset managers or owners to transfer ERC20 tokens, including the risk of misuse and theft.
Assessing risks
Analyzing potential vulnerabilities in redeemToken, transferFunds, swapYieldSource, and conversion functions, including reentrancy attacks, misuse of yieldSource, and precise transfer methods.
Examining function logic
I’m digging into _transferFunds and swapYieldSource, considering potential logic errors, partial state failures, and missing reentrancy protection amid the complex interplay of yield sources.
Addressing vulnerabilities
I'm focusing on reentrancy issues in transferFunds and the token transfer mistake in redeemToken, where the contract should use safeTransfer instead of safeTransferFrom for token management.
Tracing the issue
In redeemToken, the _tokenToShares function might convert small token amounts to zero shares, preventing any tokens from being burned and effectively allowing tokens to be redeemed for free.","Below is a list of issues we identified in the contract. (Note that this list does not include “mitigations” or fixes – only the potential vulnerabilities and problematic patterns we observed.) Some of these “vulnerabilities” may be design issues or “gotchas” that an attacker (or a careless administrator) might exploit.

---

1. **Incorrect Token Transfer in Redemption**  
   In the `redeemToken` function the contract calls  
   ```solidity
   _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);
   ```  
   rather than a direct transfer (for example, via `safeTransfer`). Since the contract already holds the tokens, using `transferFrom` requires that an allowance be set for `msg.sender` – which it is not. This mistake will likely cause redemption calls to revert (or at best behave unpredictably), and in some cases could be exploited for a denial‐of‐service or funds “locking” scenario.

2. **Unprotected Rounding/Precision Issues in Share Conversion (Burn Path)**  
   The conversion functions `_tokenToShares` and `_sharesToToken` rely on external data from  
   ```solidity
   yieldSource.balanceOfToken(address(this))
   ```  
   and use fixed‐point math. In the “mint” path the code requires that the resulting share amount be greater than zero. However, in the “burn” path (inside `_burnShares`) there is no check that the computed number of shares is nonzero. In a situation where a small amount of “tokens” to redeem converts (by rounding/truncation) to 0 shares, no tokens will actually be burned. This opens the possibility for a user to call `redeemToken` for an amount that “costs” 0 burned shares – effectively redeeming yield without reducing his share balance.

3. **Dependence on External Yield Source for Conversion Calculations**  
   Both share conversion functions call  
   ```solidity
   yieldSource.balanceOfToken(address(this))
   ```  
   to compute exchange mantissas. If the configured yield source is malicious (or simply “behaves strangely”) then the conversion from tokens to shares (or vice versa) can be manipulated. In particular, if the yield source returns an unexpected value the conversion may be off, potentially allowing an attacker (or even causing unintended accounting errors) to redeem more than his fair share.

4. **Potential Reentrancy via Yield Source Calls in Administrative Fund Transfers**  
   Several administrative functions (namely `transferFunds` and `swapYieldSource`) call the external yield source’s functions (e.g. calling `redeemToken` on one yield source and then `supplyTokenTo` on another) without a reentrancy guard. Although these functions are restricted to privileged roles (onlyOwnerOrAssetManager), the external calls to yield sources that might be under the control of an attacker can introduce a reentrancy risk. (Contrast with the user‐facing functions like `supplyTokenTo` and `redeemToken` that are marked `nonReentrant`.) In other words, if a malicious yield source calls back into one of these functions before state changes are fully “done,” the internal accounting might be manipulated.

5. **State Inconsistency on Yield Source Swap**  
   The `swapYieldSource` function first changes the contract’s yield source (via `_setYieldSource`) and then attempts to transfer funds out of the old yield source. If the subsequent `_transferFunds` call fails or behaves unexpectedly, the contract will be left in a state where its “active” yield source has already been switched but the funds have not been correctly transferred. Such partial state updates can lead to funds being “lost” or locked in a yield source.

6. **Weak “Validity” Check of the Provided Yield Source**  
   The internal function `_requireYieldSource` checks that a candidate yield source returns a nonzero deposit token address via a low‐level staticcall. This check is nonstandard and may be bypassed by a yield source that is deliberately crafted to return a “good‐looking” deposit token address even though its behavior is malicious. In other words, the contract’s way of “validating” a yield source may not be robust.

7. **Initializer (“Freeze”) Function on the Implementation Contract**  
   The contract includes an empty public function named `freeze()` marked with the `initializer` modifier. In upgradeable (proxy) patterns it is common to “lock” the implementation contract by calling an initializer. If this contract is ever deployed as a standalone (non‐proxied) implementation and the “freeze” isn’t called immediately, an attacker might be able to call an initializer (or any unprotected initialization function) to gain control over ownership or other critical parameters. (This pattern is common but must be managed with care.)","### **Comparison of Issue Report and Response List**

---

#### **[H-01] `onlyOwnerOrAssetManager` can swap Yield Source in `SwappableYieldSource` at any time, immediately rugging all funds from old yield source**

**Report Description**:  
The `swapYieldSource` function in `SwappableYieldSource.sol` allows the owner or `AssetManager` to transfer all funds from the old yield source to a new one. If either role has malicious intent, they can exploit this to rug-pull funds by setting a malicious yield source that implements `depositToken()`.

**Match in Response List**:  
Matches with **""Potential Reentrancy via Yield Source Calls in Administrative Fund Transfers""** and **""State Inconsistency on Yield Source Swap""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of reentrancy and state inconsistency during yield source swaps, which aligns with the issue. However, it misses the critical aspect of malicious intent by privileged roles (owner or `AssetManager`) and the rug-pull scenario. The response does not explicitly address the trust assumptions or the potential for abuse by these roles.

---

#### **[H-02] `redeemToken` can fail for certain tokens**

**Report Description**:  
The `redeemToken` function uses `ERC20.transferFrom` to transfer tokens back to the sender. This may fail for certain tokens that require the contract to approve itself for the `redeemableBalance`, as `transferFrom` checks for allowances even when the sender is the `from` address.

**Match in Response List**:  
Matches with **""Incorrect Token Transfer in Redemption""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with using `transferFrom` instead of a direct transfer. It correctly explains the potential for reverts or unpredictable behavior due to the allowance check, which aligns with the issue description.

---

#### **[H-03] `setYieldSource` leads to temporary wrong results**

**Report Description**:  
The `setYieldSource` function changes the yield source but does not immediately transfer underlying balances, leaving the contract in an inconsistent state. This causes `balanceOfToken` and `supplyTokenTo` to return incorrect results, potentially allowing users to drain funds later.

**Match in Response List**:  
Matches with **""State Inconsistency on Yield Source Swap""**.

**Validation**:  
**Correct**. The response correctly identifies the state inconsistency issue during yield source swaps. It explains the potential for incorrect accounting and fund loss, which aligns with the issue description.

---

#### **[H-04] `SwappableYieldSource`: Missing same deposit token check in `transferFunds()`**

**Report Description**:  
The `transferFunds` function fails to check if the deposit tokens of the old and new yield sources are the same. This allows a malicious owner or `AssetManager` to exploit differences in token valuations and pocket the difference.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The lack of a deposit token check is a critical vulnerability that could lead to financial exploitation.

---

#### **[M-01] Single-step process for critical ownership transfer/renounce is risky**

**Report Description**:  
The contract uses `Ownable`'s `transferOwnership` and `renounceOwnership` methods without overriding them. This single-step process is risky because it is irreversible, and any mistakes could lead to loss of control over the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The lack of a two-step ownership transfer process is a significant design flaw that could lead to irreversible mistakes.

---

#### **[M-02] Use of `safeApprove` will always cause `approveMax` to revert**

**Report Description**:  
The contract uses `safeApprove`, which is deprecated and will revert if the current allowance is not zero. This prevents increasing the allowance unless it is reset to zero first, leading to potential operational issues.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The use of `safeApprove` in this context is problematic and could lead to reverts and operational failures.

---

#### **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**

**Report Description**:  
The `supplyTokenTo` function assumes the full `amount` of tokens is transferred, but this may not be true for transfer-on-fee or deflationary tokens. This could lead to inconsistent accounting and potential loss of funds.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The lack of handling for transfer-on-fee or deflationary tokens is a significant oversight that could lead to accounting errors.

---

#### **[M-04] Old yield source still has infinite approval**

**Report Description**:  
After swapping a yield source, the old yield source retains infinite approval. This could be exploited if the old yield source is compromised, leading to potential fund loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The retention of infinite approval for old yield sources is a security risk that could lead to fund loss.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] `redeemToken` can fail for certain tokens**  
- **[H-03] `setYieldSource` leads to temporary wrong results**

**Partially Correct Matches**:

- **[H-01] `onlyOwnerOrAssetManager` can swap Yield Source in `SwappableYieldSource` at any time, immediately rugging all funds from old yield source**

**Missed Issues from Issue Report**:

- **[H-04] `SwappableYieldSource`: Missing same deposit token check in `transferFunds()`**  
- **[M-01] Single-step process for critical ownership transfer/renounce is risky**  
- **[M-02] Use of `safeApprove` will always cause `approveMax` to revert**  
- **[M-03] Inconsistent balance when supplying transfer-on-fee or deflationary tokens**  
- **[M-04] Old yield source still has infinite approval**

---

The response list covers some critical issues but misses several vulnerabilities, particularly those related to privileged roles, token handling, and ownership management. These gaps highlight the need for a more comprehensive review of the contract's security posture.",2,1,5,7,"```
1. Incorrect Token Transfer in Redemption
2. State Inconsistency on Yield Source Swap
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Incorrect Token Transfer in Redemption"" appears at rank 1.
   - ""State Inconsistency on Yield Source Swap"" appears at rank 5.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 5: \( P@5 = \frac{2}{5} = 0.4 \)

3. **Average the precision values to compute the Average Precision (AP)**:
   \[
   AP = \frac{1.0 + 0.4}{2} = 0.7
   \]

**Output**:
```
0.7
```"
