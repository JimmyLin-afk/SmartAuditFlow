nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Reasoning,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
Vault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";

/**
 * A vault where other accounts can deposit an underlying token
 * currency and set distribution params for their principal and yield
 *
 * @dev Yield generation strategies not yet implemented
 */

contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    //
    // Constants
    //

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    //
    // State
    //

    /// Underlying ERC20 token accepted by the vault
    /// See {IVault}
    IERC20 public override(IVault) underlying;

    /// See {IVault}
    IStrategy public strategy;

    /// See {IVault}
    uint256 public investPerc;

    /// See {IVault}
    uint256 public immutable override(IVault) minLockPeriod;

    /// See {IVaultSponsoring}
    uint256 public override(IVaultSponsoring) totalSponsored;

    /// Depositors, represented as an NFT per deposit
    Depositors public depositors;

    /// Yield allocation
    Claimers public claimers;

    /// Unique IDs to correlate donations that belong to the same foundation
    Counters.Counter private _depositGroupIds;

    /**
     * @param _underlying Underlying ERC20 token to use.
     */
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    //
    // IVault
    //

    /// See {IVault}
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    /// See {IVault}
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    /// See {IVault}
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    /// See {IVault}
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    /// See {IVault}
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    /// See {IVault}
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    /// See {IVault}
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    /// See {IVault}
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    /// See {IVault}
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    /// See {IVault}
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    /// See {IVault}
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    //
    // IVaultSponsoring

    /// See {IVaultSponsoring}
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    /// See {IVaultSponsoring}
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    /// See {IVaultSponsoring}
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    //
    // Public API
    //

    /**
     * Computes the total amount of principal + yield currently controlled by the
     * vault and the strategy. The principal + yield is the total amount
     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.
     *
     * @return Total amount of principal and yield help by the vault (not including sponsored amount).
     */
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        // TODO no invested amount yet
        return totalUnderlying() - totalSponsored;
    }

    //
    // ERC165
    //

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    //
    // Internal API
    //

    /**
     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    /**
     * Withdraws the sponsored amount for the deposits with the ids provided
     * in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    /**
     * Creates a deposit with the given amount of underlying and claim
     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.
     * @notice This function assumes underlying will be transfered elsewhere in
     * the transaction.
     *
     * @notice Underlying must be transfered *after* this function, in order to
     * correctly calculate shares.
     *
     * @notice claims must add up to 100%.
     *
     * @param _amount Amount of underlying to consider @param claims claim
     * @param _lockedUntil When the depositor can unsponsor the amount.
     * @param claims Claim params
     * params.
     */
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    /**
     * Burns a deposit NFT and reduces the principal and shares of the claimer.
     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.
     *
     * @notice This function doesn't transfer any funds, it only updates the state.
     *
     * @notice Only the owner of the deposit may call this function.
     *
     * @param _tokenId The deposit ID to withdraw from.
     * @param _totalShares The total shares to consider for the withdraw.
     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.
     *
     * @return the amount to withdraw.
     */
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    /**
     * Computes amount of shares that will be received for a given deposit amount
     *
     * @param _amount Amount of deposit to consider.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount of shares the deposit will receive.
     */
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    /**
     * Computes the amount of underlying from a given number of shares
     *
     * @param _shares Number of shares.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount that corresponds to the number of shares.
     */
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            // TODO exclude sponsored assets
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    /**
     * Checks if the given address is a contract implementing IIntegration
     *
     * @param addr Address to check
     * @return true if contract is an IIntegraiont
     */
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",4418.0,652.0,"[H-01] `forceUnsponsor()` may open a window for attackers to manipulate the `_totalShares` and freeze users' funds at a certain deposit amount
function `_unsponsor()`, variables `totalSponsored`
When `sponsorAmount > totalUnderlying()`, the contract will transfer `totalUnderlying()` to `sponsorToTransfer`, even if there are other depositors and `totalShares` > 0.
After that, and before others despoiting into the Vault, the Attacker can send 1 wei underlying token, then cal `deposit()` with 0.1 * 1e18 , since `newShares = (_amount * _totalShares) / _totalUnderlyingMinusSponsored` and `_totalUnderlyingMinusSponsored` is 1, with a tiny amount of underlying token, newShares will become extremly large.
As we stated in issue #166, when the value of totalShares is manipulated precisely, the attacker can plant a bomb, and the contract will not work when the deposit/withdraw amount reaches a certain value, freezing the user's funds.
  [H-02] Withdrawers can get more value returned than expected with reentrant call
The impact of this is that users can get significantly more UST withdrawn than they would be alotted if they had done non-reentrant withdraw calls.
  [H-04] deposit() function is open to reentrancy attacks
In Vault.sol the `deposit()` function is left wide open to reentrancy attacks. The function eventually calls `_createDeposit()` => `_createClaim()` which calls `depositors.mint()` which will then mint an NFT. When the NFT is minted the sender will receive a callback which can then be used to call the `deposit()` function again before execution is finished. An attacker can do this minting multiple NFT's for themselves. claimers.mint() is also called in the same function which can also be used to call back into the deposit function before execution is complete. Since there are several state updates before and after NFT's are minted this can be used to further manipulate the protocol like with newShares which is called before minting. This is not counting what an attacker can do with cross function reentrancy entering into several other protocol functions (like withdraw) before code execution is complete further manipulating the system.
  [H-05] sponsor() function in open to reentrancy attacks
In Vault.sol the `sponsor()` function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender. Since there are state updates after the call to depositors.mint() function this is especially dangerous. An attacker can make it so the totalSponsored amount is only updated once after calling mint() several times since the update takes place after the callback. The same will be true for the Sponsored event that is emitted.
  [M-04] `_unsponsor`, claimYield and withdraw might fail unexpectedly
`totalUnderlying()` includes the invested assets, they are not in the contract balance.
when a user calls withdraw, claimYield or unsponsor, the system might not have enough assets in the balance and the transfer would fail.
especially, force unsponsor will always fail, because it tries to transfer the entire `totalUnderlying()`, which the system doesn't have:
  [M-06] `totalUnderlyingMinusSponsored()` may revert on underflow and malfunction the contract
As a function that many other functions depended on, `totalUnderlyingMinusSponsored()` can revert on underflow when `sponsorAmount > totalUnderlying()` which is possible and has been considered elsewhere in this contract:   [M-07] Vault can't receive deposits if underlying token charges fees on transfer
`function _transferAndCheckUnderlying`
Some ERC20 tokens charge a fee for every transfer. If the underlying token of a vault is such a token any deposit to the protocol will fail.
Some tokens have the possibility of adding fees later on, e.g. USDT. So those have to be covered too.
Generally, the user would also receive fewer tokens on withdrawing in such a scenario but that's not the protocol's fault.
  [M-15] Check `_to` is not empty
functions claimYield, `_withdraw`, and `_unsponsor` should validate that `_to` is not an empty 0x0 address to prevent accidental burns.",8.0,"pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";



contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    
    
    

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; 
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    
    
    

    
    
    IERC20 public override(IVault) underlying;

    
    IStrategy public strategy;

    
    uint256 public investPerc;

    
    uint256 public immutable override(IVault) minLockPeriod;

    
    uint256 public override(IVaultSponsoring) totalSponsored;

    
    Depositors public depositors;

    
    Claimers public claimers;

    
    Counters.Counter private _depositGroupIds;

    
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    
    
    

    
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    
    

    
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    
    
    

    
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        
        return totalUnderlying() - totalSponsored;
    }

    
    
    

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    
    
    

    
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",3364.0,4,4,"Thinking critically I’m analyzing the request to list vulnerabilities in a smart contract without suggesting mitigations, considering the need for thoroughness and specificity.
Identifying vulnerabilities I’m focusing on listing vulnerabilities in the smart contract, ensuring a comprehensive approach to assessment and precision.
Listing key vulnerabilities I’m systematically identifying and detailing vulnerabilities in the smart contract, ensuring a thorough walkthrough of all areas of concern.
Identifying security gaps Listing all identified security vulnerabilities in the smart contract, without any mitigations, to ensure a comprehensive understanding of the potential risks.
","Here is a list of potential vulnerabilities in the provided smart contract:

1. **Reentrancy Risk**:
   - The `withdraw`, `forceWithdraw`, `claimYield`, and other functions that interact with external addresses and transfer funds are potentially vulnerable to reentrancy attacks. While the contract uses `SafeERC20` for token transfers, it doesn't explicitly implement the ""checks-effects-interactions"" pattern or a reentrancy guard, making it susceptible to reentrancy attacks when interacting with other contracts.

2. **Unchecked External Call**:
   - In functions like `_isIntegration`, `_transferAndCheckUnderlying`, and `_withdrawDeposit`, the contract interacts with external addresses without checking for the possibility of failure. This could lead to unexpected behavior or attacks, such as a failing external contract causing the function to revert or behave incorrectly.

3. **Access Control Weaknesses**:
   - The `setStrategy`, `setInvestPerc`, `updateInvested`, and similar functions are protected by the `requiresTrust` modifier, but the `Trust` contract’s implementation isn't provided, so it’s unclear whether this modifier is properly securing these functions against unauthorized access.
   - Additionally, the `forceWithdraw` and `forceUnsponsor` functions may allow an authorized user to bypass certain restrictions, which could be a security concern if misused.

4. **Gas Limit Issues**:
   - The `deposit` and `claimYield` functions involve iterating over dynamic arrays or performing complex calculations that could lead to gas limit issues when handling large inputs. If a user provides too many claims or tokens to withdraw, the transaction could fail due to exceeding the gas limit.

5. **Integer Overflow/Underflow (potentially mitigated by Solidity 0.8.x)**:
   - The contract is written in Solidity 0.8.x, which has built-in protection against integer overflow and underflow. However, in earlier versions, such issues could have occurred if mathematical operations were improperly handled.

6. **Inconsistent Validation of Lock Duration**:
   - The `sponsor` and `unsponsor` functions perform checks for `lockedUntil` to prevent withdrawal before the lock time expires. However, inconsistent validation of lock duration across functions might lead to vulnerabilities where users could withdraw funds prematurely or when they shouldn’t.

7. **Potential Inaccurate Calculation in `_computeShares`**:
   - The `_computeShares` function relies on the `_totalShares` and `_totalUnderlyingMinusSponsored` to calculate shares. If either of these values is improperly updated or has incorrect data, it could lead to inaccurate calculations of shares, potentially resulting in users receiving incorrect amounts of funds.

8. **Potential Integer Division Issues**:
   - In functions like `_computeAmount` and `_computeShares`, integer division is performed, which may lead to truncation errors if not properly handled. This could affect the expected distribution of funds, especially for small values.

9. **Lack of User Input Validation for `_force` Flags**:
   - In the `forceWithdraw`, `forceUnsponsor`, and `_unsponsor` functions, the `_force` flag is used to bypass certain checks. While this may be necessary for administrative purposes, it could lead to unintended behavior if the `_force` flag is set incorrectly.

10. **Insecure Contract Integration**:
    - In the `_isIntegration` function, the contract checks whether an external contract implements the `IIntegration` interface, but it does not check for the actual integrity or validity of the external contract. If a malicious or vulnerable contract implements the interface, it could lead to unexpected behavior or exploitation of the contract.

11. **Unclear Trust Management**:
    - The contract depends heavily on the `Trust` contract for access control. However, it’s unclear how the trust mechanism is implemented or if it has been properly audited. If the `Trust` contract has any flaws, it could potentially allow unauthorized access to critical functions.

12. **Insufficient Event Emission for Critical Functions**:
    - While the contract emits events like `DepositMinted`, `DepositBurned`, `Sponsored`, and `Unsponsored`, some important actions such as changes in the strategy or investment percentage may not be adequately tracked or logged, which could affect transparency and user accountability.","### **Output**

---

#### **[H-01] `forceUnsponsor()` may open a window for attackers to manipulate the `_totalShares` and freeze users' funds at a certain deposit amount**

**Report Description**:  
The `forceUnsponsor()` function allows an attacker to manipulate `_totalShares` by depositing a minimal amount of underlying tokens (e.g., 1 wei) after `totalSponsored` exceeds `totalUnderlying()`. This manipulation can cause `newShares` to become extremely large, leading to a situation where the contract becomes non-functional when deposit/withdraw amounts reach a certain value, effectively freezing users' funds.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of `forceUnsponsor()` allowing manipulation of `_totalShares` or the freezing of user funds. While it mentions potential integer division issues and inaccurate calculations in `_computeShares`, it does not cover the described attack vector.

---

#### **[H-02] Withdrawers can get more value returned than expected with reentrant call**

**Report Description**:  
The withdraw function is vulnerable to reentrancy attacks, allowing users to withdraw significantly more UST than expected by exploiting reentrant calls during the withdrawal process.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Risk""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy risk in functions like `withdraw`, which aligns with the issue description. It correctly highlights the lack of a reentrancy guard or adherence to the ""checks-effects-interactions"" pattern.

---

#### **[H-04] `deposit()` function is open to reentrancy attacks**

**Report Description**:  
The `deposit()` function in `Vault.sol` is vulnerable to reentrancy attacks due to the use of `depositors.mint()` and `claimers.mint()`, which trigger callbacks. An attacker can exploit this to mint multiple NFTs and manipulate the protocol's state.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Risk""**.

**Validation**:  
**Correct**. The response correctly identifies the reentrancy risk in functions like `deposit`, which aligns with the issue description. It highlights the lack of a reentrancy guard or adherence to the ""checks-effects-interactions"" pattern.

---

#### **[H-05] `sponsor()` function is open to reentrancy attacks**

**Report Description**:  
The `sponsor()` function is vulnerable to reentrancy attacks due to the use of `depositors.mint()`, which triggers a callback. An attacker can exploit this to manipulate the `totalSponsored` amount and other state variables.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Risk""**.

**Validation**:  
**Correct**. The response correctly identifies the reentrancy risk in functions like `sponsor`, which aligns with the issue description. It highlights the lack of a reentrancy guard or adherence to the ""checks-effects-interactions"" pattern.

---

#### **[M-04] `_unsponsor`, `claimYield`, and `withdraw` might fail unexpectedly**

**Report Description**:  
The `_unsponsor`, `claimYield`, and `withdraw` functions may fail unexpectedly because `totalUnderlying()` includes invested assets that are not in the contract balance. This could lead to failed transfers, especially in `forceUnsponsor`, which attempts to transfer the entire `totalUnderlying()`.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of insufficient contract balance causing unexpected failures in `_unsponsor`, `claimYield`, and `withdraw`.

---

#### **[M-06] `totalUnderlyingMinusSponsored()` may revert on underflow and malfunction the contract**

**Report Description**:  
The `totalUnderlyingMinusSponsored()` function may revert on underflow when `sponsorAmount > totalUnderlying()`, which could malfunction the contract since many other functions depend on it.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the underflow issue in `totalUnderlyingMinusSponsored()`.

---

#### **[M-07] Vault can't receive deposits if underlying token charges fees on transfer**

**Report Description**:  
If the underlying token charges fees on transfer, deposits to the vault will fail. This is because the `_transferAndCheckUnderlying` function does not account for such fees.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of tokens with transfer fees causing deposit failures.

---

#### **[M-15] Check `_to` is not empty**

**Report Description**:  
Functions like `claimYield`, `_withdraw`, and `_unsponsor` should validate that `_to` is not an empty address (0x0) to prevent accidental burns.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing validation for the `_to` address in critical functions.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Withdrawers can get more value returned than expected with reentrant call**
- **[H-04] `deposit()` function is open to reentrancy attacks**
- **[H-05] `sponsor()` function is open to reentrancy attacks**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] `forceUnsponsor()` may open a window for attackers to manipulate the `_totalShares` and freeze users' funds at a certain deposit amount**
- **[M-04] `_unsponsor`, `claimYield`, and `withdraw` might fail unexpectedly**
- **[M-06] `totalUnderlyingMinusSponsored()` may revert on underflow and malfunction the contract**
- **[M-07] Vault can't receive deposits if underlying token charges fees on transfer**
- **[M-15] Check `_to` is not empty**

--- 

The response list covers reentrancy risks well but misses several critical issues related to contract functionality, underflow, token transfer fees, and input validation.",3,0,5,12,"```
1. Reentrancy Risk
```",1.0
NonUSTStrategy.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import ""./curve/ICurve.sol"";
import ""./BaseStrategy.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/**
 * Strategy that handles non-UST tokens, by first converting them to UST via
 * Curve (https://curve.fi/), and only then depositing into EthAnchor
 */
contract NonUSTStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    // address of the Curve pool to use
    ICurve public curvePool;

    // index of the underlying token in the pool
    int128 public underlyingI;

    // index of the UST token in the pool
    int128 public ustI;

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner,
        address _curvePool,
        int128 _underlyingI,
        int128 _ustI
    )
        BaseStrategy(
            _vault,
            _treasury,
            _ethAnchorRouter,
            _exchangeRateFeeder,
            _ustToken,
            _aUstToken,
            _perfFeePct,
            _owner
        )
    {
        require(underlying != _ustToken, ""invalid underlying"");
        require(_curvePool != address(0), ""0x addr"");
        curvePool = ICurve(_curvePool);
        underlyingI = _underlyingI;
        ustI = _ustI;

        ustToken.safeApprove(_curvePool, type(uint256).max);
        underlying.safeApprove(_curvePool, type(uint256).max);
    }

    /**
     * Swaps the underlying currency for UST, and initiates a deposit of all
     * the converted UST into EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the deposit process, but does not finish it.
     */
    function doHardWork() external override(BaseStrategy) restricted {
        _swapUnderlyingToUst();
        _initDepositStable();
    }

    /**
     * Calls Curve to convert the existing underlying balance into UST
     */
    function _swapUnderlyingToUst() internal {
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            // slither-disable-next-line unused-return
            curvePool.exchange_underlying(
                underlyingI,
                ustI,
                underlyingBalance,
                0
            );
        }
    }

    /**
     * Calls Curve to convert the existing UST back into the underlying token
     */
    function _swapUstToUnderlying() internal {
        uint256 ustBalance = _getUstBalance();
        if (ustBalance > 0) {
            // slither-disable-next-line unused-return
            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);
        }
    }

    /**
     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.
     * Once UST is retrieved, convert it back to underlying via Curve
     *
     * @notice Must be called some time after `initRedeemStable()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending redeem operation
     */
    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {
        super.finishRedeemStable(idx);
        _swapUstToUnderlying();
    }

    /**
     * Amount, expressed in the underlying currency, currently in the strategy
     *
     * @notice both held and invested amounts are included here, using the
     * latest known exchange rates to the underlying currency
     *
     * @return The total amount of underlying
     */
    function investedAssets()
        external
        view
        override(BaseStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance();
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(
            address(aUstToken),
            true
        ) * aUstBalance) / 1e18) + pendingDeposits;
        return
            underlyingBalance +
            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);
    }
}",1005.0,137.0,"[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool
In short, the NonUSTStrategy is vulnerable to attacks by flash loans on curve pools.
- Here’s an outline of the attack:
- Assume there is a vault with DAI underlying and a NonUSTStrategy with a DAI / UST curve pool
- Take out a flash loan of DAI
- Exchange a ton of DAI for UST
- The exchange rate from DAI to UST has gone up (!!)
- Withdraw or deposit from vault with more favorable terms than market
- Transfer back UST to DAI
- Repay flash loan
  [M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users
Function `_swapUnderlyingToUst`
NonUSTStrategy will swap the deposited non-UST assets into UST before depositing to EthAnchor. However, the swap fee is not attributed to the depositor correctly like many other yield farming vaults involving swaps (ZapIn).
An attacker can exploit it for the swap fees paid by other users by taking a majority share of the liquidity pool.
  [M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals
The `investedAssets()` function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in `finishRedeemStable()`.",3.0,"pragma solidity ^0.8.10;

import ""./curve/ICurve.sol"";
import ""./BaseStrategy.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";


contract NonUSTStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    
    ICurve public curvePool;

    
    int128 public underlyingI;

    
    int128 public ustI;

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner,
        address _curvePool,
        int128 _underlyingI,
        int128 _ustI
    )
        BaseStrategy(
            _vault,
            _treasury,
            _ethAnchorRouter,
            _exchangeRateFeeder,
            _ustToken,
            _aUstToken,
            _perfFeePct,
            _owner
        )
    {
        require(underlying != _ustToken, ""invalid underlying"");
        require(_curvePool != address(0), ""0x addr"");
        curvePool = ICurve(_curvePool);
        underlyingI = _underlyingI;
        ustI = _ustI;

        ustToken.safeApprove(_curvePool, type(uint256).max);
        underlying.safeApprove(_curvePool, type(uint256).max);
    }

    
    function doHardWork() external override(BaseStrategy) restricted {
        _swapUnderlyingToUst();
        _initDepositStable();
    }

    
    function _swapUnderlyingToUst() internal {
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            
            curvePool.exchange_underlying(
                underlyingI,
                ustI,
                underlyingBalance,
                0
            );
        }
    }

    
    function _swapUstToUnderlying() internal {
        uint256 ustBalance = _getUstBalance();
        if (ustBalance > 0) {
            
            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);
        }
    }

    
    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {
        super.finishRedeemStable(idx);
        _swapUstToUnderlying();
    }

    
    function investedAssets()
        external
        view
        override(BaseStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance();
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(
            address(aUstToken),
            true
        ) * aUstBalance) / 1e18) + pendingDeposits;
        return
            underlyingBalance +
            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);
    }
}",664.0,1,2,"Assessing vulnerabilities
OK, let me see. The request aims to pinpoint all potential weaknesses in the smart contract code. By listing these vulnerabilities, it should offer a comprehensive view of the smart contract, excluding mitigation strategies.
Unveiling vulnerabilities
Taking a closer look at the smart contract code to identify and list all potential weaknesses, ensuring a comprehensive overview of its risks and potential issues.
Identifying vulnerabilities
I’m mapping out all potential vulnerabilities in the smart contract code. This involves a thorough review to ensure every issue is documented, providing a complete assessment of risks.
Assessing vulnerabilities
I’m gathering a detailed list of all potential security risks in the smart contract. This comprehensive analysis helps ensure a thorough understanding of all aspects and potential issues.
","Here is a list of potential vulnerabilities in the provided smart contract:

1. **Reentrancy Risk:**
   - There are functions like `_swapUnderlyingToUst()` and `_swapUstToUnderlying()` where tokens are being transferred, which could potentially be vulnerable to reentrancy attacks if any of the external calls (like `curvePool.exchange_underlying()`) interact with other contracts that could call back into the contract.
   
2. **Unchecked External Call Results:**
   - The contract makes external calls to `curvePool.exchange_underlying()` but does not check the return value or ensure that the call was successful. If the call fails, the contract may behave unexpectedly.

3. **Uninitialized `underlying`:**
   - The `require(underlying != _ustToken, ""invalid underlying"");` condition is checking the `underlying` token but there is no initialization for the `underlying` variable in the constructor. This could lead to an error when the contract is deployed.

4. **Lack of Access Control:**
   - While the `doHardWork()` function is marked `restricted`, there is no indication of the access control implementation in the provided code. If the modifier doesn't restrict access properly, unauthorized users could call `doHardWork()`, leading to unintended operations.

5. **Approval Handling:**
   - The contract uses `safeApprove` with `type(uint256).max` for both the `ustToken` and `underlying` tokens. While `SafeERC20` is used, using the maximum approval can be risky because it allows unlimited token transfers, which could be exploited if the token contract is vulnerable.

6. **Unverified Exchange Rate Feeder:**
   - The `investedAssets()` function uses an external call to `exchangeRateFeeder.exchangeRateOf()` without any verification or checks on the data provided by the feeder. If the exchange rate feeder is manipulated or provides incorrect rates, the function’s return value might be skewed.

7. **No Event Emissions for State Changes:**
   - There are no events emitted when key state changes occur, such as when tokens are swapped, assets are invested, or redeems are finished. This can make tracking the contract’s behavior difficult for off-chain monitoring systems.

8. **Lack of Validation for Input Values:**
   - There is no validation on the input values like `_curvePool`, `_underlyingI`, `_ustI`, etc. in the constructor other than the check on `_curvePool`. Malicious or incorrect input could cause the contract to malfunction or lose funds.

9. **Overflow/Underflow Risk:**
   - While Solidity 0.8.x has built-in overflow and underflow protection, the contract still relies heavily on external token contract interactions where this protection might not be enforced, especially with older tokens that don't use SafeERC20.

10. **Lack of Gas Optimization:**
    - Functions like `investedAssets()` perform multiple calculations with potential multiple external calls (e.g., `exchangeRateFeeder.exchangeRateOf()`, `curvePool.get_dy_underlying()`) without considering the gas consumption. This could lead to high gas costs when interacting with the contract.

11. **No Upgradeability or Contract Ownership Mechanism:**
    - The contract does not appear to implement upgradeability or provide mechanisms to modify critical parameters (like the owner or governance). If the contract logic needs to change in the future, there would be no built-in upgradeability feature.

12. **Lack of proper validation or checks in `finishRedeemStable`:**
    - The function `finishRedeemStable()` calls `_swapUstToUnderlying()` after a super call. If any error occurs during the super call or the underlying exchange, it could cause the transaction to revert without a clear error message.","### **[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool**

**Report Description**:  
The `NonUSTStrategy` is vulnerable to flash loan attacks on curve pools. An attacker can manipulate the exchange rate of DAI to UST by taking out a flash loan, exchanging a large amount of DAI for UST, and then withdrawing or depositing from the vault with more favorable terms than the market. This exploit allows the attacker to profit at the expense of other users.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the specific vulnerability related to flash loan attacks on curve pools. While some responses touch on external calls and exchange rate manipulation (e.g., ""Unverified Exchange Rate Feeder""), they do not identify the core issue of flash loan exploitation or its impact on the `NonUSTStrategy`.

---

### **[M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users**

**Report Description**:  
The `_swapUnderlyingToUst` function in `NonUSTStrategy.sol` does not correctly attribute swap fees to the depositor. An attacker can exploit this by taking a majority share of the liquidity pool, allowing them to steal swap fees paid by other users.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of improper swap fee handling or the potential for attackers to exploit this vulnerability. While some responses discuss external calls and approval handling, they do not cover the specific risk of fee misattribution.

---

### **[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Report Description**:  
The `investedAssets()` function does not account for the performance fee charged by the treasury during strategy withdrawals, as shown in `finishRedeemStable()`. This oversight could lead to inaccurate reporting of the vault's investments.

**Match in Response List**:  
Matches with the issue titled **""Unverified Exchange Rate Feeder""**.

**Validation**:  
**Partially Correct**. The response identifies the use of an external call to `exchangeRateFeeder.exchangeRateOf()` without verification, which is related to the issue of inaccurate reporting. However, it does not address the specific problem of performance fees being unaccounted for in `investedAssets()`. The response partially overlaps with the issue but misses critical details.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Missed Issues from Issue Report**:  
- **[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool**  
- **[M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users**

---

### **Overall Assessment**  
The response list covers a broad range of potential vulnerabilities but fails to address the specific issues highlighted in the issue report. While some responses partially overlap with the reported issues, critical vulnerabilities like flash loan attacks and improper swap fee handling are entirely missed. The response list would benefit from a more targeted analysis of the reported issues to ensure comprehensive coverage.",0,1,2,12,"```
None.
```",0.0
BaseStrategy.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import ""../lib/PercentMath.sol"";
import ""../vault/IVault.sol"";
import ""./IStrategy.sol"";
import ""./anchor/IEthAnchorRouter.sol"";
import ""./anchor/IExchangeRateFeeder.sol"";

// import ""./Controllable.sol"";

/**
 * Base strategy that handles UST tokens and invests them via the EthAnchor
 * protocol (https://docs.anchorprotocol.com/ethanchor/ethanchor)
 */
abstract contract BaseStrategy is IStrategy, Trust {
    using SafeERC20 for IERC20;
    using PercentMath for uint256;

    event PerfFeeClaimed(uint256 amount);
    event PerfFeePctUpdated(uint256 pct);

    struct Operation {
        address operator;
        uint256 amount;
    }

    IERC20 public override(IStrategy) underlying;
    // Vault address
    address public override(IStrategy) vault;

    // address of the treasury
    address public treasury;

    // address for the UST token
    IERC20 public ustToken;

    // address for the aUST token (wrapped Anchor UST, received to accrue interest for an Anchor deposit)
    IERC20 public aUstToken;

    // performance fee taken by the treasury on profits
    uint16 public perfFeePct;

    // external contract to interact with EthAnchor
    IEthAnchorRouter public ethAnchorRouter;

    // external exchange rate provider
    IExchangeRateFeeder public exchangeRateFeeder;

    // amount currently pending in deposits to EthAnchor
    uint256 public pendingDeposits;

    // amount currently pending redeemption from EthAnchor
    uint256 public pendingRedeems;

    // deposit operations history
    Operation[] public depositOperations;

    // redeem operations history
    Operation[] public redeemOperations;

    // amount of UST converted (used to calculate yield)
    uint256 public convertedUst;

    // restructs a function to be called only by the vault or governance
    modifier restricted() {
        require(msg.sender == vault || isTrusted[msg.sender], ""restricted"");

        _;
    }

    modifier onlyVault() {
        require(msg.sender == vault, ""only vault"");

        _;
    }

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner
    ) Trust(_owner) {
        require(_ethAnchorRouter != address(0), ""0x addr"");
        require(_exchangeRateFeeder != address(0), ""0x addr"");
        require(address(_ustToken) != address(0), ""0x addr"");
        require(address(_aUstToken) != address(0), ""0x addr"");
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");

        treasury = _treasury;
        vault = _vault;
        underlying = IVault(_vault).underlying();
        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);
        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);
        ustToken = _ustToken;
        aUstToken = _aUstToken;
        perfFeePct = _perfFeePct;

        // pre-approve EthAnchor router to transact all UST and aUST
        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);
        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);
    }

    /**
     * Initiates a deposit of all the currently held UST into EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the deposit process, but does not finish it.
     */
    function doHardWork() external virtual override(IStrategy) restricted {
        _initDepositStable();
    }

    function _initDepositStable() internal {
        uint256 ustBalance = _getUstBalance();
        require(ustBalance > 0, ""balance 0"");
        pendingDeposits += ustBalance;
        address _operator = ethAnchorRouter.initDepositStable(ustBalance);
        depositOperations.push(
            Operation({operator: _operator, amount: ustBalance})
        );
    }

    /**
     * Calls EthAnchor with a pending deposit ID, and attempts to finish it.
     *
     * @notice Must be called some time after `doHardWork()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending deposit operation
     */
    function finishDepositStable(uint256 idx) external {
        require(depositOperations.length > idx, ""not running"");
        Operation storage operation = depositOperations[idx];
        ethAnchorRouter.finishDepositStable(operation.operator);

        pendingDeposits -= operation.amount;
        convertedUst += operation.amount;

        operation.operator = depositOperations[depositOperations.length - 1]
            .operator;
        operation.amount = depositOperations[depositOperations.length - 1]
            .amount;
        depositOperations.pop();
    }

    /**
     * Initiates a withdrawal of UST from EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the redeem process, but does not finish it.
     *
     * @param amount Amount of aUST to redeem
     */
    function initRedeemStable(uint256 amount) public restricted {
        uint256 aUstBalance = _getAUstBalance();
        require(amount > 0, ""amount 0"");
        require(aUstBalance >= amount, ""insufficient"");
        pendingRedeems += amount;
        address _operator = ethAnchorRouter.initRedeemStable(amount);
        redeemOperations.push(Operation({operator: _operator, amount: amount}));
    }

    /**
     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.
     *
     * @notice Must be called some time after `initRedeemStable()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending redeem operation
     */
    function finishRedeemStable(uint256 idx) public virtual {
        require(redeemOperations.length > idx, ""not running"");
        Operation storage operation = redeemOperations[idx];
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;
        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;
        uint256 ustBalanceBefore = _getUstBalance();

        ethAnchorRouter.finishRedeemStable(operation.operator);

        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;
        uint256 perfFee = redeemedAmount > originalUst
            ? (redeemedAmount - originalUst).percOf(perfFeePct)
            : 0;
        if (perfFee > 0) {
            ustToken.safeTransfer(treasury, perfFee);
            emit PerfFeeClaimed(perfFee);
        }
        convertedUst -= originalUst;
        pendingRedeems -= operation.amount;

        operation.operator = redeemOperations[redeemOperations.length - 1]
            .operator;
        operation.amount = redeemOperations[redeemOperations.length - 1].amount;
        redeemOperations.pop();
    }

    /**
     * Withdraws the entire amount back to the vault
     *
     * @notice since some of the amount may be deposited into EthAnchor, this
     * call may not withdraw all the funds right away. It will start a redeem
     * process on EthAnchor, but this function must be called again a second
     * time once that is finished.
     */
    function withdrawAllToVault() external override(IStrategy) restricted {
        uint256 aUstBalance = _getAUstBalance();
        if (aUstBalance > 0) {
            initRedeemStable(aUstBalance);
        }
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            underlying.safeTransfer(vault, underlyingBalance);
        }
    }

    /**
     * Withdraws a specified amount back to the vault
     *
     * @notice Unlike `withdrawToVault`, this function only considers the
     * amount currently not invested, but only what is currently held by the
     * strategy
     *
     * @param amount Amount to withdraw
     */
    function withdrawToVault(uint256 amount)
        external
        override(IStrategy)
        restricted
    {
        underlying.safeTransfer(vault, amount);
    }

    /**
     * Updates the performance fee
     *
     * @notice Can only be called by governance
     *
     * @param _perfFeePct The new performance fee %
     */
    function setPerfFeePct(uint16 _perfFeePct) external restricted {
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");
        perfFeePct = _perfFeePct;
        emit PerfFeePctUpdated(_perfFeePct);
    }

    /**
     * Amount, expressed in the underlying currency, currently in the strategy
     *
     * @notice both held and invested amounts are included here, using the
     * latest known exchange rates to the underlying currency
     *
     * @return The total amount of underlying
     */
    function investedAssets()
        external
        view
        virtual
        override(IStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        return
            underlyingBalance +
            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *
                aUstBalance) / 1e18);
    }

    // Amount of underlying tokens in the strategy
    function _getUnderlyingBalance() internal view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    // Amount of UST tokens in the strategy
    function _getUstBalance() internal view returns (uint256) {
        return ustToken.balanceOf(address(this));
    }

    // Amount of aUST tokens in the strategy
    function _getAUstBalance() internal view returns (uint256) {
        return aUstToken.balanceOf(address(this));
    }

    // Amount of pending deposit operations
    function depositOperationLength() external view returns (uint256) {
        return depositOperations.length;
    }

    // Amount of pending redeem operations
    function redeemOperationLength() external view returns (uint256) {
        return redeemOperations.length;
    }
}",2363.0,303.0,"[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys
The current implementation requires trusted key holders (`isTrusted[msg.sender]`) to send transactions (`initRedeemStable()`) to initialize withdrawals from EthAnchor before the users can withdraw funds from the contract.
  [M-05] Add a timelock to BaseStrategy:`setPerfFeePct`
To give more trust to users: functions that set key/critical variables should be put behind a timelock.
 
[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals
The `investedAssets()` function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in `finishRedeemStable()`. Therefore, an attacker could avoid paying their fair share of the performance fee by withdrawing their assets before several calls to finishRedeemStable() are made and reenter the vault once the fee is charged.",3.0,"pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import ""../lib/PercentMath.sol"";
import ""../vault/IVault.sol"";
import ""./IStrategy.sol"";
import ""./anchor/IEthAnchorRouter.sol"";
import ""./anchor/IExchangeRateFeeder.sol"";




abstract contract BaseStrategy is IStrategy, Trust {
    using SafeERC20 for IERC20;
    using PercentMath for uint256;

    event PerfFeeClaimed(uint256 amount);
    event PerfFeePctUpdated(uint256 pct);

    struct Operation {
        address operator;
        uint256 amount;
    }

    IERC20 public override(IStrategy) underlying;
    
    address public override(IStrategy) vault;

    
    address public treasury;

    
    IERC20 public ustToken;

    
    IERC20 public aUstToken;

    
    uint16 public perfFeePct;

    
    IEthAnchorRouter public ethAnchorRouter;

    
    IExchangeRateFeeder public exchangeRateFeeder;

    
    uint256 public pendingDeposits;

    
    uint256 public pendingRedeems;

    
    Operation[] public depositOperations;

    
    Operation[] public redeemOperations;

    
    uint256 public convertedUst;

    
    modifier restricted() {
        require(msg.sender == vault || isTrusted[msg.sender], ""restricted"");

        _;
    }

    modifier onlyVault() {
        require(msg.sender == vault, ""only vault"");

        _;
    }

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner
    ) Trust(_owner) {
        require(_ethAnchorRouter != address(0), ""0x addr"");
        require(_exchangeRateFeeder != address(0), ""0x addr"");
        require(address(_ustToken) != address(0), ""0x addr"");
        require(address(_aUstToken) != address(0), ""0x addr"");
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");

        treasury = _treasury;
        vault = _vault;
        underlying = IVault(_vault).underlying();
        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);
        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);
        ustToken = _ustToken;
        aUstToken = _aUstToken;
        perfFeePct = _perfFeePct;

        
        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);
        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);
    }

    
    function doHardWork() external virtual override(IStrategy) restricted {
        _initDepositStable();
    }

    function _initDepositStable() internal {
        uint256 ustBalance = _getUstBalance();
        require(ustBalance > 0, ""balance 0"");
        pendingDeposits += ustBalance;
        address _operator = ethAnchorRouter.initDepositStable(ustBalance);
        depositOperations.push(
            Operation({operator: _operator, amount: ustBalance})
        );
    }

    
    function finishDepositStable(uint256 idx) external {
        require(depositOperations.length > idx, ""not running"");
        Operation storage operation = depositOperations[idx];
        ethAnchorRouter.finishDepositStable(operation.operator);

        pendingDeposits -= operation.amount;
        convertedUst += operation.amount;

        operation.operator = depositOperations[depositOperations.length - 1]
            .operator;
        operation.amount = depositOperations[depositOperations.length - 1]
            .amount;
        depositOperations.pop();
    }

    
    function initRedeemStable(uint256 amount) public restricted {
        uint256 aUstBalance = _getAUstBalance();
        require(amount > 0, ""amount 0"");
        require(aUstBalance >= amount, ""insufficient"");
        pendingRedeems += amount;
        address _operator = ethAnchorRouter.initRedeemStable(amount);
        redeemOperations.push(Operation({operator: _operator, amount: amount}));
    }

    
    function finishRedeemStable(uint256 idx) public virtual {
        require(redeemOperations.length > idx, ""not running"");
        Operation storage operation = redeemOperations[idx];
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;
        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;
        uint256 ustBalanceBefore = _getUstBalance();

        ethAnchorRouter.finishRedeemStable(operation.operator);

        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;
        uint256 perfFee = redeemedAmount > originalUst
            ? (redeemedAmount - originalUst).percOf(perfFeePct)
            : 0;
        if (perfFee > 0) {
            ustToken.safeTransfer(treasury, perfFee);
            emit PerfFeeClaimed(perfFee);
        }
        convertedUst -= originalUst;
        pendingRedeems -= operation.amount;

        operation.operator = redeemOperations[redeemOperations.length - 1]
            .operator;
        operation.amount = redeemOperations[redeemOperations.length - 1].amount;
        redeemOperations.pop();
    }

    
    function withdrawAllToVault() external override(IStrategy) restricted {
        uint256 aUstBalance = _getAUstBalance();
        if (aUstBalance > 0) {
            initRedeemStable(aUstBalance);
        }
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            underlying.safeTransfer(vault, underlyingBalance);
        }
    }

    
    function withdrawToVault(uint256 amount)
        external
        override(IStrategy)
        restricted
    {
        underlying.safeTransfer(vault, amount);
    }

    
    function setPerfFeePct(uint16 _perfFeePct) external restricted {
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");
        perfFeePct = _perfFeePct;
        emit PerfFeePctUpdated(_perfFeePct);
    }

    
    function investedAssets()
        external
        view
        virtual
        override(IStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        return
            underlyingBalance +
            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *
                aUstBalance) / 1e18);
    }

    
    function _getUnderlyingBalance() internal view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    
    function _getUstBalance() internal view returns (uint256) {
        return ustToken.balanceOf(address(this));
    }

    
    function _getAUstBalance() internal view returns (uint256) {
        return aUstToken.balanceOf(address(this));
    }

    
    function depositOperationLength() external view returns (uint256) {
        return depositOperations.length;
    }

    
    function redeemOperationLength() external view returns (uint256) {
        return redeemOperations.length;
    }
}",1636.0,0,3,"I started by understanding the task. Listing all vulnerabilities in the smart contract helps pinpoint security issues, which is crucial for maintaining integrity and preventing attacks.
OK, let me see. Listing all vulnerabilities in a smart contract involves identifying security flaws and weaknesses. This helps in understanding potential risks and crafting effective defense mechanisms.
Highlighting vulnerabilities
I’m digging into potential risks in smart contracts, identifying flaws like code errors and setup issues, and noting security gaps. This approach reveals critical areas for more robust protection.
Spotting weaknesses
I’m identifying key vulnerabilities in smart contracts, like flawed exchanges and setup bugs, to highlight areas needing enhancement for better security.
","Here is a list of potential vulnerabilities in the given smart contract:

1. **Reentrancy Risk**:
   - Functions like `finishDepositStable` and `finishRedeemStable` interact with external contracts (`ethAnchorRouter`), which can expose the contract to reentrancy attacks. These functions could be vulnerable to reentrancy if the external contract calls back into the current contract, leading to unexpected state changes.

2. **Approval Race Condition**:
   - The contract uses `safeApprove` to set approvals for `ustToken` and `aUstToken`. If these tokens are used elsewhere (in other contracts), the approval process can lead to issues, especially with the `type(uint256).max` value. If a malicious actor interacts with the token contract between the approval and transfer, this can potentially allow unexpected token transfers.

3. **Lack of Access Control in Functions**:
   - While the contract uses modifiers like `restricted` and `onlyVault`, certain critical functions like `setPerfFeePct` and `doHardWork` might be accessible if misconfigured. There’s also a possibility of unwanted state changes if a trusted account or vault operator becomes compromised.

4. **Hardcoded Address Dependencies**:
   - External contract addresses like `ethAnchorRouter` and `exchangeRateFeeder` are passed during the constructor. If these addresses are compromised or incorrect, it could affect the contract's behavior or lead to loss of funds. There's no validation to ensure these addresses point to valid, functioning contracts beyond the checks for zero addresses.

5. **No Event Emission for Critical Actions**:
   - Although `PerfFeeClaimed` and `PerfFeePctUpdated` are emitted, there are no events emitted for other critical operations such as the deposits or redemptions themselves, which could hinder contract transparency and monitoring.

6. **Lack of Input Validation in Some Functions**:
   - The function `finishRedeemStable` calculates `originalUst` based on the `aUstBalance`, which can potentially result in integer overflows/underflows, though Solidity 0.8.x does have built-in overflow checks. Still, the logic could lead to incorrect results if the parameters are not properly validated.

7. **Potential Inaccurate `investedAssets` Calculation**:
   - In the `investedAssets` function, the method of calculating the total invested assets by adding the `underlyingBalance` and `aUstBalance` using the exchange rate feeder may not always yield an accurate result, especially if the exchange rate feeder is faulty or manipulated.

8. **Lack of Security Around `vault` Variable**:
   - While the `vault` is set in the constructor and only accessible through the `restricted` modifier, there is no mechanism to update the `vault` if necessary. If the vault address is compromised, the contract could be vulnerable, as it relies on a single vault address for critical operations.

9. **Unintended Token Transfers**:
   - In the `withdrawToVault` and `withdrawAllToVault` functions, the underlying tokens are transferred to the vault without any checks to ensure that the vault address is correct or authorized. If the vault is compromised or incorrectly set, tokens could be lost.

10. **No Limit on Pending Deposits or Redeems**:
    - The contract allows an unlimited amount of pending deposits and redeems (`pendingDeposits` and `pendingRedeems`), which could potentially lead to a denial-of-service (DoS) scenario if a large number of operations are added to the `depositOperations` or `redeemOperations` arrays.

11. **Potential for State Divergence**:
    - Variables like `pendingDeposits`, `pendingRedeems`, and `convertedUst` are not protected from being manually modified or diverging from the expected state, which could lead to inconsistencies if these are not carefully managed in the contract logic.

These vulnerabilities should be addressed during the smart contract audit and review process.","### **Output**

---

**[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys**

**Report Description**:
The current implementation requires trusted key holders (`isTrusted[msg.sender]`) to send transactions (`initRedeemStable()`) to initialize withdrawals from EthAnchor before users can withdraw funds from the contract. This introduces a centralization risk where funds could be frozen if the trusted key holders lose access to their keys, rendering the contract non-functional for withdrawals.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the centralization risk associated with trusted key holders losing access to their keys. This is a critical issue that could lead to a complete freeze of funds, and it is not covered in the response list.

---

**[M-05] Add a timelock to BaseStrategy:`setPerfFeePct`**

**Report Description**:
To increase user trust, functions that set key/critical variables should be put behind a timelock. The `setPerfFeePct` function in `BaseStrategy` currently lacks a timelock mechanism, which could allow for abrupt changes in performance fees without giving users sufficient notice or time to react.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not mention the lack of a timelock mechanism for critical functions like `setPerfFeePct`. This is a significant oversight, as timelocks are a standard security measure to prevent abrupt changes in critical contract parameters.

---

**[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Report Description**:
The `investedAssets()` function, implemented by the vault's strategy contracts, does not account for the performance fee charged by the treasury as shown in `finishRedeemStable()`. This oversight could allow an attacker to avoid paying their fair share of the performance fee by withdrawing their assets before several calls to `finishRedeemStable()` are made and reentering the vault once the fee is charged.

**Match in Response List**:
Matches with the issue titled **""Potential Inaccurate `investedAssets` Calculation""**.

**Validation**:
**Partially Correct**. The response identifies the potential inaccuracy in the `investedAssets` calculation but does not specifically address the issue of performance fees being ignored. The response focuses on the exchange rate feeder's potential inaccuracies rather than the performance fee omission, which is a critical aspect of the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-12] `investedAssets()` Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Missed Issues from Issue Report**:
- **[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys**
- **[M-05] Add a timelock to BaseStrategy:`setPerfFeePct`**

---

### **Conclusion**
The response list covers some vulnerabilities but misses critical issues related to centralization risks and the lack of timelocks for key functions. Additionally, the response to the `investedAssets` issue is partially correct but does not fully address the performance fee omission. These gaps should be addressed to ensure comprehensive security coverage.",0,1,2,11,"```
None.
```",0.0
,,,,,,,,5,9,,,,3,2,9,35,,
