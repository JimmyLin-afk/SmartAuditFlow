nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
DelegatedStaking.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

contract DelegatedStaking is OwnableUpgradeable{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    uint256 constant divider = 10**18; // 18 decimals used for scaling the rates
    uint128 validatorCoolDown; // how many epochs until validator unstaking is unlocked
    uint128 delegatorCoolDown; // how many epochs until delegator unstaking is unlocked
    uint128 maxCapMultiplier;
    uint128 validatorMinStakedRequired; // minimum # of tokens validator is required to have staked
    uint128 allocatedTokensPerEpoch; // # of tokens per epoch to be distributed
    uint128 rewardsLocked; // # of tokens the owner sent to the contract
    uint128 endEpoch; // the epoch when the contract will be out of allocated reward tokens
    uint128 totalGlobalShares; // global shares
    uint128 lastUpdateEpoch; // block # when the global exchange rate was updated last
    uint128 globalExchangeRate;
    uint128 validatorsN; // number of validators, used to get validator ids
    mapping(uint128 => Validator) validators; // id -> validator instance
    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);

    struct Staking {
        uint128 staked; // initial CQT amount staked
        uint128 shares; // # of validator shares that delegate owns
    }
    struct Unstaking {
        uint128 coolDownEnd; // epoch when unstaking can be redeemed
        uint128 amount;
    }
    struct Validator {
        address _address;
        address operator;
        uint128 commissionRate; // validator commission rate
        uint128 disabledEpoch; // epoch when validator got disabled, if set to 0, validator is enabled
        uint128 globalShares; // total number of global shares under a validator
        uint128 lastUpdateGlobalRate; // global exchange rate when the validator was updated the last time
        uint128 totalShares; // total number of validator shares
        uint128 delegated; // total number of tokens originally staked/delegated to the validator, this does not include interest
        uint128 exchangeRate; // validator exchange rate
        uint128 commissionAvailableToRedeem; // # of CQTs paid to the validator
        mapping(address => Staking) stakings;
        mapping(address => Unstaking[]) unstakings;
    }
    event RewardTokensDeposited(uint128 amount);
    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);
    event ValidatorDisabled(uint128 indexed id);
    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);
    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event AllocatedTokensTaken(uint128 amount);
    event MaxCapMultiplierChanged(uint128 amount);
    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event EmissionRateChanged(uint128 newRate);
    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);
    event ValidatorMinStakedRequiredChanged(uint128 amount);
    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);

    // this is used to have the contract upgradeable
    function initialize(uint128 minStakedRequired) public initializer {
        __Ownable_init();
        validatorMinStakedRequired = minStakedRequired;
        validatorCoolDown = 180*6646; // ~ 6 months
        delegatorCoolDown = 28*6646; // ~ 28 days
        maxCapMultiplier = 10;
        allocatedTokensPerEpoch = 1*10**18; // should never be 0
        globalExchangeRate = 10**18; // 1 to 1
        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);
    }

    // used to transfer CQT from delegators, validators and the owner to the contract
    function _transferToContract(address from, uint128 amount) internal {
        CQT.safeTransferFrom(from, address(this), amount);
    }

    // used to transfer CQT from contract, for rewards redemption or transferring out unstaked
    function _transferFromContract(address to, uint128 amount) internal {
        CQT.safeTransfer(to, amount);
    }

    // transfer CQT from the owner to the contract for rewards allocation, must change end epoch
    function depositRewardTokens(uint128 amount) public onlyOwner {
        require(amount >= allocatedTokensPerEpoch, ""Does not cover least 1 epoch"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0) {
            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }
        }
        else{
            unchecked { rewardsLocked += amount; }
        }
        _transferToContract(msg.sender, amount);
        emit RewardTokensDeposited(amount);
    }

    // transfer reward CQT from the contract to the owner, must change end epoch and not allow transfer from the past
    function takeOutRewardTokens(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0){
            uint128 currentEpoch = uint128(block.number);
            uint128 epochs = amount / allocatedTokensPerEpoch;
            require(endEpoch - epochs > currentEpoch, ""Cannot takeout rewards from past"");
            unchecked { endEpoch = endEpoch - epochs; }
        }
        else{
            require(rewardsLocked >= amount, ""Amount is greater than available"");
            unchecked { rewardsLocked -= amount; }
        }
        _transferFromContract(msg.sender, amount);
        emit AllocatedTokensTaken(amount);
    }

    // update global exchange rate
    function _updateGlobalExchangeRate() internal {
        uint128 currentBlock = uint128(block.number);
        // if the program ended, set update epoch to the end epoch
        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;
        if (currentEpoch != lastUpdateEpoch){
            // when no one has staked anything, do not update the rate
            if(totalGlobalShares > 0)
            {
                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }
            }
            lastUpdateEpoch = currentEpoch;
        }
    }

    // update validator exchange rate
    function _updateValidator(Validator storage v) internal {
        // if validator is disabled, we do not update it since it was updated during disabling transaction
        if(v.disabledEpoch == 0){
            if (v.totalShares == 0){
                // when validator stakes the first time, the exchange rate must be equal to the current global exchange rate
                v.exchangeRate = globalExchangeRate;
            }
            else {
                // the growth of global exchange rate since the validator was updated the last time
                uint128 rateDifference;
                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }
                // tokens given to the validator and its delegators since last update
                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);
                // commission paid out of the tokens
                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);
                // increase validator exchange rate by distributing the leftover tokens through the validator shares
                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);
                // give commission tokens to the validator
                unchecked { v.commissionAvailableToRedeem += commissionPaid; }
            }
            // set the last update global rate to the current one
            v.lastUpdateGlobalRate = globalExchangeRate;
        }
    }
    // used to convert global shares or validator shares to CQT
    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){
        return uint128(uint256(sharesN) * uint256(rate) / divider);
    }
    // used to convert CQT to global shares or validator shares
    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){
        return uint128(uint256(amount) * divider / uint256(rate));
    }

    function stake(uint128 validatorId, uint128 amount) public {
        _stake(validatorId, amount, true);
    }
    // need to update global exchange rate, validator data and then delegator instance
    // withTransfer set to false when delegators recover unstake, because the tokens are already in the contract
    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {
        require(amount >= divider, ""Amount must be at least 1 token"");
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is disabled"");
        // if this is the first stake, then set the end epoch
        if (endEpoch == 0){
            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }
            rewardsLocked = 0; // no longer used and saves a bit of gas
        }
        require(endEpoch > block.number, ""Program ended"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // if staker is validator who self delegates
        if (msg.sender == v._address){
            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, ""Amount < min staked required"");
        }
        else {
            // otherwise need to check for max cap
            uint128 validatorStaked = v.stakings[v._address].staked;
            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;
            uint128 newDelegated = v.delegated - validatorStaked + amount;
            require(newDelegated <= validatorMaxCap, ""Validator max capacity exceeded"");
        }
        // it is set to true when there is a stake
        // it is set to false when we recover delegation from unstaking
        if (withTransfer)
            _transferToContract(msg.sender, amount);
        Staking storage s = v.stakings[msg.sender];

        // update global shares #
        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);
        unchecked { totalGlobalShares += globalSharesToAdd; }
        unchecked { v.globalShares += globalSharesToAdd; }

        // update validator shares #
        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);
        unchecked { v.totalShares += newDelegatorSharesN; }
        unchecked { s.shares += newDelegatorSharesN; }
        unchecked { v.delegated += amount; }
        unchecked { s.staked += amount; }
        emit Staked(validatorId, msg.sender, amount);
    }

    // need to update global exchange rate, validator data and then delegator instance
    function unstake(uint128 validatorId, uint128 amount) public {
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        Staking storage s = v.stakings[msg.sender];
        require(s.staked >= amount, ""Staked < amount provided"");
        bool isValidator = msg.sender == v._address;
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore
        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
        require(validatorSharesRemove > 0, ""Unstake amount is too small"");
        if (v.disabledEpoch == 0){
            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required
            if (isValidator && endEpoch > block.number){
                uint128 newValidatorStaked = s.staked - amount;
                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;
                uint128 delegated = v.delegated - s.staked;
                require(delegated <= newValidatorMaxCap, ""Cannot unstake beyond max cap"");
                require(newValidatorStaked >= validatorMinStakedRequired, ""Unstake > min staked required"");
            }

            // update global shares #
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            require(globalSharesRemove > 0, ""Unstake amount is too small"");
            unchecked { totalGlobalShares -= globalSharesRemove;}
            unchecked { v.globalShares -= globalSharesRemove; }

            // update validator shares #
            unchecked { v.totalShares -= validatorSharesRemove; }
            unchecked { v.delegated -= amount; }
        }
        unchecked { s.shares -= validatorSharesRemove; }
        unchecked { s.staked -= amount; }

        // create unstaking instance
        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);
        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }
        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));
        emit Unstaked(validatorId, msg.sender, amount);
    }

    // restake unstaked tokens
    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(validatorId, amount, false);
        us.amount -= amount;
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);
    }

    // if amount is 0 then redeem all
    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {
        require(beneficiary!=address(0x0), ""Invalid beneficiary"");
        _updateGlobalExchangeRate();
        Validator storage v = validators[validatorId];
        _updateValidator(v);
        Staking storage s = v.stakings[msg.sender];

        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
        if(msg.sender == v._address){
            if(amount == 0){
                unchecked { amount = rewards + v.commissionAvailableToRedeem; }
            }
            require(rewards + v.commissionAvailableToRedeem >= amount, ""Redeem amount > available"");
            // first redeem rewards from commission
            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;
            // if there is more, redeem  it from regular rewards
            if (commissionLeftOver == 0){
                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);
                unchecked { s.shares -= validatorSharesRemove; }
                unchecked { v.totalShares -= validatorSharesRemove; }
            }
            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);
            v.commissionAvailableToRedeem = commissionLeftOver;
        }
        else {
            if(amount == 0){
                amount = rewards;
            }
            require(rewards >= amount, ""Redeem amount > available"");
            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
            unchecked { s.shares -= validatorSharesRemove; }
            unchecked { v.totalShares -= validatorSharesRemove; }
        }
        _transferFromContract(beneficiary, amount);

        // update global shares #
        // this includes commission and rewards earned
        // only update if the validator is enabled, otherwise the shares were already excluded during disableValidator call
        if (v.disabledEpoch == 0){
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            unchecked { totalGlobalShares -= globalSharesRemove; }
            unchecked { v.globalShares -= globalSharesRemove; }
        }
        emit RewardRedeemed(validatorId, beneficiary, amount);
    }

    // redeem all available rewards
    function redeemAllRewards( uint128 validatorId, address beneficiary) external {
        _redeemRewards(validatorId, beneficiary, 0);
    }

    // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards
    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {
        require(amount > 0, ""Amount is 0"");
        _redeemRewards(validatorId, beneficiary, amount);
    }

    // add new validator instance
    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {
        require(commissionRate < divider, ""Rate must be less than 100%"");
        uint128 N = validatorsN;
        validators[N]._address = validator;
        validators[N].operator = operator;
        validators[N].commissionRate = commissionRate;
        emit ValidatorAdded(N, validator, operator);
        unchecked { validatorsN += 1; }
    }

    // can only be called by the owner or the validator, disabling will allow validator to fully unstake
    // validator instance can only be disabled once and can never be reenabled
    function disableValidator(uint128 validatorId) public {
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is already disabled"");
        require(v._address == msg.sender || msg.sender == owner(), ""Caller is not owner or validator"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;
        unchecked { totalGlobalShares -= v.globalShares; }
        emit ValidatorDisabled(validatorId);
    }

    // change emission rate, should reset end epoch
    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        uint128 toTransfer;
        if (endEpoch != 0){
            _updateGlobalExchangeRate();
            // get number of epochs from now to the end epoch
            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;
            // calculate how much rewards would be distributed with the old emission rate
            uint128 futureRewards = allocatedTokensPerEpoch * epochs;
            // calculate how many epochs will be covered
            uint128 addEpochs = futureRewards / amount;
            toTransfer = futureRewards % amount;
            require(addEpochs != 0, ""This amount will end the program"");
            unchecked { endEpoch = uint128(block.number) + addEpochs; }
        }
        else {
          toTransfer = rewardsLocked % amount;
        }
        allocatedTokensPerEpoch = amount;
        emit EmissionRateChanged(amount);
        if(toTransfer > 0)
            _transferFromContract(msg.sender, toTransfer);

    }

    // we assume that we will never set it to less than what is staked already
    function setMaxCapMultiplier(uint128 amount) public onlyOwner {
        require(amount > 0, ""Must be greater than 0"");
        maxCapMultiplier = amount;
        emit MaxCapMultiplierChanged(amount);
    }

    // only owner can change commission rate
    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {
        require(amount < divider, ""Rate must be less than 100%"");
        _updateGlobalExchangeRate();
        _updateValidator(validators[validatorId]);
        validators[validatorId].commissionRate = amount;
        emit ValidatorCommissionRateChanged(validatorId, amount);
    }

    // we are assuming there will never be a case when the owner sets the value to something extremely big and if that happens accidentally, we will just recall the function
    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {
        validatorMinStakedRequired = amount;
        emit ValidatorMinStakedRequiredChanged(amount);
    }

    // if a validator gets disabled, delegators can redelegate their tokens to another validator
    // first they need to unstake
    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {
        require(validators[oldValidatorId].disabledEpoch != 0, ""Validator is not disabled"");
        require(validators[oldValidatorId]._address != msg.sender, ""Validator cannot redelegate"");
        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(newValidatorId, amount, false);
        unchecked { us.amount -= amount; }
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);
    }

    // transfer out unlocked unstaked tokens back to the delegator
    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require( uint128(block.number) > us.coolDownEnd, ""Cooldown period has not ended"" );
        require(us.amount >= amount, ""Amount is too high"");
        _transferFromContract(msg.sender, amount);
        unchecked { us.amount -= amount; }
        // set cool down end to 0 to release gas if new unstaking amount is 0
        if (us.amount == 0)
            us.coolDownEnd = 0;
        emit UnstakeRedeemed(validatorId, msg.sender, amount);
    }

    // returns details of each validator
    // array index is id
    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {
        commissionRates = new uint128[](validatorsN);
        delegated = new uint128[](validatorsN);
        for (uint128 i = 0; i < validatorsN; ++i){
            Validator storage v = validators[i];
            commissionRates[i] = v.commissionRate;
            delegated[i] = v.delegated - v.stakings[v._address].staked;
        }
        return (commissionRates, delegated);
    }

    // this follows the same logic as _updateGlobalExchangeRate and _updateValidator
    // array index is id of validator
    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {
       delegated = new uint128[](validatorsN);
       rewardsAvailable = new uint128[](validatorsN);
       commissionRewards = new uint128[](validatorsN);
       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;
       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;
       Validator storage v;
       Staking storage s;
        for (uint128 i = 0; i < validatorsN; ++i){
            v = validators[i];
            s = v.stakings[delegator];
            delegated[i] = s.staked;
            if (v.disabledEpoch == 0){
                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);
                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);
                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;
            }
            else {
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem;
            }
        }
        return (delegated, rewardsAvailable, commissionRewards);
    }

    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){
        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);
        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);
    }
}
",5629,477,"[H-01] Usage of an incorrect version of Ownbale library can potentially malfunction all onlyOwner functions

Submitted by WatchPug
DelegatedStaking.sol L62-L63 ```
// this is used to have the contract upgradeable
function initialize(uint128 minStakedRequired) public initializer {
```
Based on the context and comments in the code, the DelegatedStaking.sol contract is designed to be deployed as an upgradeable proxy contract.
However, the current implementation is using an non-upgradeable version of the Ownbale library: @openzeppelin/contracts/access/Ownable.sol instead of the upgradeable version: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol.
A regular, non-upgradeable Ownbale library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract.
As a result, all the onlyOwner functions will be inaccessible.
 [H-02] unstake should update exchange rates first

Submitted by cmichel
The unstake function does not immediately update the exchange rates. It first computes the validatorSharesRemove = tokensToShares(amount, v.exchangeRate) with the old exchange rate.
Only afterwards, it updates the exchange rates (if the validator is not disabled):
// @audit shares are computed here with old rate
uint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate);
require(validatorSharesRemove > 0, ""Unstake amount is too small"");

if (v.disabledEpoch == 0) {
    // @audit rates are updated here
    updateGlobalExchangeRate();
    updateValidator(v);
    // ...
}   [M-01] reward tokens could get lost due to rounding down

The function `depositRewardTokens` divides the ""amount"" of tokens by allocatedTokensPerEpoch to calculate the endEpoch. When ""amount"" isn't a multiple of allocatedTokensPerEpoch the result of the division will be rounded down, effectively losing a number of tokens for the rewards.
For example if allocatedTokensPerEpoch is set to 3e18 and ""amount"" is 100e18 then endEpoch will be increased with 33e18 and the last 1e18 tokens are lost.
A similar problem occurs here:
in setAllocatedTokensPerEpoch(), with the recalculation of endEpoch
in takeOutRewardTokens(), with the retrieval of tokens
in _stake(), when initializing endEpoch (e.g. when endEpoch==0)
Proof of Concept

DelegatedStaking.sol L90-L98
DelegatedStaking.sol L368-L383

[M-02] Incorrect updateGlobalExchangeRate implementation

Function `_UpdateGlobalExchangeRate` has incorrect implementation when totalGlobalShares is zero.
If any user didn't start stake, totalGlobalShares is 0, and every stake it will increase. but there is possibility that totalGlobalShares can be 0 amount later by unstake or disable validator.
 [M-03] Validator can fail to receive commission reward in redeemAllRewards

Validator can fail to receive commission reward by calling redeemAllRewards. There's a check in redeemAllRewards
uint128 rewards = sharesToTokens(s.shares, v.exchangeRate) - s.staked;
require(rewards > 0, ""Nothing to redeem"");

The validator's tx might be reverted here even if he got some commission reward to receive.
",5,,"pragma solidity ^0.8.0;
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";

contract DelegatedStaking is OwnableUpgradeable{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    uint256 constant divider = 10**18; 
    uint128 validatorCoolDown; 
    uint128 delegatorCoolDown; 
    uint128 maxCapMultiplier;
    uint128 validatorMinStakedRequired; 
    uint128 allocatedTokensPerEpoch; 
    uint128 rewardsLocked; 
    uint128 endEpoch; 
    uint128 totalGlobalShares; 
    uint128 lastUpdateEpoch; 
    uint128 globalExchangeRate;
    uint128 validatorsN; 
    mapping(uint128 => Validator) validators; 
    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);

    struct Staking {
        uint128 staked; 
        uint128 shares; 
    }
    struct Unstaking {
        uint128 coolDownEnd; 
        uint128 amount;
    }
    struct Validator {
        address _address;
        address operator;
        uint128 commissionRate; 
        uint128 disabledEpoch; 
        uint128 globalShares; 
        uint128 lastUpdateGlobalRate; 
        uint128 totalShares; 
        uint128 delegated; 
        uint128 exchangeRate; 
        uint128 commissionAvailableToRedeem; 
        mapping(address => Staking) stakings;
        mapping(address => Unstaking[]) unstakings;
    }
    event RewardTokensDeposited(uint128 amount);
    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);
    event ValidatorDisabled(uint128 indexed id);
    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);
    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);
    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);
    event AllocatedTokensTaken(uint128 amount);
    event MaxCapMultiplierChanged(uint128 amount);
    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);
    event EmissionRateChanged(uint128 newRate);
    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);
    event ValidatorMinStakedRequiredChanged(uint128 amount);
    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);

    
    function initialize(uint128 minStakedRequired) public initializer {
        __Ownable_init();
        validatorMinStakedRequired = minStakedRequired;
        validatorCoolDown = 180*6646; 
        delegatorCoolDown = 28*6646; 
        maxCapMultiplier = 10;
        allocatedTokensPerEpoch = 1*10**18; 
        globalExchangeRate = 10**18; 
        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);
    }

    
    function _transferToContract(address from, uint128 amount) internal {
        CQT.safeTransferFrom(from, address(this), amount);
    }

    
    function _transferFromContract(address to, uint128 amount) internal {
        CQT.safeTransfer(to, amount);
    }

    
    function depositRewardTokens(uint128 amount) public onlyOwner {
        require(amount >= allocatedTokensPerEpoch, ""Does not cover least 1 epoch"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0) {
            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }
        }
        else{
            unchecked { rewardsLocked += amount; }
        }
        _transferToContract(msg.sender, amount);
        emit RewardTokensDeposited(amount);
    }

    
    function takeOutRewardTokens(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0){
            uint128 currentEpoch = uint128(block.number);
            uint128 epochs = amount / allocatedTokensPerEpoch;
            require(endEpoch - epochs > currentEpoch, ""Cannot takeout rewards from past"");
            unchecked { endEpoch = endEpoch - epochs; }
        }
        else{
            require(rewardsLocked >= amount, ""Amount is greater than available"");
            unchecked { rewardsLocked -= amount; }
        }
        _transferFromContract(msg.sender, amount);
        emit AllocatedTokensTaken(amount);
    }

    
    function _updateGlobalExchangeRate() internal {
        uint128 currentBlock = uint128(block.number);
        
        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;
        if (currentEpoch != lastUpdateEpoch){
            
            if(totalGlobalShares > 0)
            {
                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }
            }
            lastUpdateEpoch = currentEpoch;
        }
    }

    
    function _updateValidator(Validator storage v) internal {
        
        if(v.disabledEpoch == 0){
            if (v.totalShares == 0){
                
                v.exchangeRate = globalExchangeRate;
            }
            else {
                
                uint128 rateDifference;
                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }
                
                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);
                
                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);
                
                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);
                
                unchecked { v.commissionAvailableToRedeem += commissionPaid; }
            }
            
            v.lastUpdateGlobalRate = globalExchangeRate;
        }
    }
    
    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){
        return uint128(uint256(sharesN) * uint256(rate) / divider);
    }
    
    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){
        return uint128(uint256(amount) * divider / uint256(rate));
    }

    function stake(uint128 validatorId, uint128 amount) public {
        _stake(validatorId, amount, true);
    }
    
    
    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {
        require(amount >= divider, ""Amount must be at least 1 token"");
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is disabled"");
        
        if (endEpoch == 0){
            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }
            rewardsLocked = 0; 
        }
        require(endEpoch > block.number, ""Program ended"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        
        if (msg.sender == v._address){
            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, ""Amount < min staked required"");
        }
        else {
            
            uint128 validatorStaked = v.stakings[v._address].staked;
            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;
            uint128 newDelegated = v.delegated - validatorStaked + amount;
            require(newDelegated <= validatorMaxCap, ""Validator max capacity exceeded"");
        }
        
        
        if (withTransfer)
            _transferToContract(msg.sender, amount);
        Staking storage s = v.stakings[msg.sender];

        
        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);
        unchecked { totalGlobalShares += globalSharesToAdd; }
        unchecked { v.globalShares += globalSharesToAdd; }

        
        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);
        unchecked { v.totalShares += newDelegatorSharesN; }
        unchecked { s.shares += newDelegatorSharesN; }
        unchecked { v.delegated += amount; }
        unchecked { s.staked += amount; }
        emit Staked(validatorId, msg.sender, amount);
    }

    
    function unstake(uint128 validatorId, uint128 amount) public {
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        Staking storage s = v.stakings[msg.sender];
        require(s.staked >= amount, ""Staked < amount provided"");
        bool isValidator = msg.sender == v._address;
        _updateGlobalExchangeRate();
        _updateValidator(v);
        
        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
        require(validatorSharesRemove > 0, ""Unstake amount is too small"");
        if (v.disabledEpoch == 0){
            
            if (isValidator && endEpoch > block.number){
                uint128 newValidatorStaked = s.staked - amount;
                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;
                uint128 delegated = v.delegated - s.staked;
                require(delegated <= newValidatorMaxCap, ""Cannot unstake beyond max cap"");
                require(newValidatorStaked >= validatorMinStakedRequired, ""Unstake > min staked required"");
            }

            
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            require(globalSharesRemove > 0, ""Unstake amount is too small"");
            unchecked { totalGlobalShares -= globalSharesRemove;}
            unchecked { v.globalShares -= globalSharesRemove; }

            
            unchecked { v.totalShares -= validatorSharesRemove; }
            unchecked { v.delegated -= amount; }
        }
        unchecked { s.shares -= validatorSharesRemove; }
        unchecked { s.staked -= amount; }

        
        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);
        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }
        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));
        emit Unstaked(validatorId, msg.sender, amount);
    }

    
    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(validatorId, amount, false);
        us.amount -= amount;
        
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);
    }

    
    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {
        require(beneficiary!=address(0x0), ""Invalid beneficiary"");
        _updateGlobalExchangeRate();
        Validator storage v = validators[validatorId];
        _updateValidator(v);
        Staking storage s = v.stakings[msg.sender];

        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
        if(msg.sender == v._address){
            if(amount == 0){
                unchecked { amount = rewards + v.commissionAvailableToRedeem; }
            }
            require(rewards + v.commissionAvailableToRedeem >= amount, ""Redeem amount > available"");
            
            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;
            
            if (commissionLeftOver == 0){
                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);
                unchecked { s.shares -= validatorSharesRemove; }
                unchecked { v.totalShares -= validatorSharesRemove; }
            }
            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);
            v.commissionAvailableToRedeem = commissionLeftOver;
        }
        else {
            if(amount == 0){
                amount = rewards;
            }
            require(rewards >= amount, ""Redeem amount > available"");
            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);
            unchecked { s.shares -= validatorSharesRemove; }
            unchecked { v.totalShares -= validatorSharesRemove; }
        }
        _transferFromContract(beneficiary, amount);

        
        
        
        if (v.disabledEpoch == 0){
            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);
            unchecked { totalGlobalShares -= globalSharesRemove; }
            unchecked { v.globalShares -= globalSharesRemove; }
        }
        emit RewardRedeemed(validatorId, beneficiary, amount);
    }

    
    function redeemAllRewards( uint128 validatorId, address beneficiary) external {
        _redeemRewards(validatorId, beneficiary, 0);
    }

    
    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {
        require(amount > 0, ""Amount is 0"");
        _redeemRewards(validatorId, beneficiary, amount);
    }

    
    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {
        require(commissionRate < divider, ""Rate must be less than 100%"");
        uint128 N = validatorsN;
        validators[N]._address = validator;
        validators[N].operator = operator;
        validators[N].commissionRate = commissionRate;
        emit ValidatorAdded(N, validator, operator);
        unchecked { validatorsN += 1; }
    }

    
    
    function disableValidator(uint128 validatorId) public {
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is already disabled"");
        require(v._address == msg.sender || msg.sender == owner(), ""Caller is not owner or validator"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;
        unchecked { totalGlobalShares -= v.globalShares; }
        emit ValidatorDisabled(validatorId);
    }

    
    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        uint128 toTransfer;
        if (endEpoch != 0){
            _updateGlobalExchangeRate();
            
            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;
            
            uint128 futureRewards = allocatedTokensPerEpoch * epochs;
            
            uint128 addEpochs = futureRewards / amount;
            toTransfer = futureRewards % amount;
            require(addEpochs != 0, ""This amount will end the program"");
            unchecked { endEpoch = uint128(block.number) + addEpochs; }
        }
        else {
          toTransfer = rewardsLocked % amount;
        }
        allocatedTokensPerEpoch = amount;
        emit EmissionRateChanged(amount);
        if(toTransfer > 0)
            _transferFromContract(msg.sender, toTransfer);

    }

    
    function setMaxCapMultiplier(uint128 amount) public onlyOwner {
        require(amount > 0, ""Must be greater than 0"");
        maxCapMultiplier = amount;
        emit MaxCapMultiplierChanged(amount);
    }

    
    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {
        require(amount < divider, ""Rate must be less than 100%"");
        _updateGlobalExchangeRate();
        _updateValidator(validators[validatorId]);
        validators[validatorId].commissionRate = amount;
        emit ValidatorCommissionRateChanged(validatorId, amount);
    }

    
    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {
        validatorMinStakedRequired = amount;
        emit ValidatorMinStakedRequiredChanged(amount);
    }

    
    
    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {
        require(validators[oldValidatorId].disabledEpoch != 0, ""Validator is not disabled"");
        require(validators[oldValidatorId]._address != msg.sender, ""Validator cannot redelegate"");
        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];
        require(us.amount >= amount, ""Unstaking has less tokens"");
        _stake(newValidatorId, amount, false);
        unchecked { us.amount -= amount; }
        
        if(us.amount == 0)
            us.coolDownEnd = 0;
        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);
    }

    
    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {
        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];
        require( uint128(block.number) > us.coolDownEnd, ""Cooldown period has not ended"" );
        require(us.amount >= amount, ""Amount is too high"");
        _transferFromContract(msg.sender, amount);
        unchecked { us.amount -= amount; }
        
        if (us.amount == 0)
            us.coolDownEnd = 0;
        emit UnstakeRedeemed(validatorId, msg.sender, amount);
    }

    
    
    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {
        commissionRates = new uint128[](validatorsN);
        delegated = new uint128[](validatorsN);
        for (uint128 i = 0; i < validatorsN; ++i){
            Validator storage v = validators[i];
            commissionRates[i] = v.commissionRate;
            delegated[i] = v.delegated - v.stakings[v._address].staked;
        }
        return (commissionRates, delegated);
    }

    
    
    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {
       delegated = new uint128[](validatorsN);
       rewardsAvailable = new uint128[](validatorsN);
       commissionRewards = new uint128[](validatorsN);
       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;
       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;
       Validator storage v;
       Staking storage s;
        for (uint128 i = 0; i < validatorsN; ++i){
            v = validators[i];
            s = v.stakings[delegator];
            delegated[i] = s.staked;
            if (v.disabledEpoch == 0){
                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);
                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);
                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;
            }
            else {
                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;
                if(delegator == v._address)
                    commissionRewards[i] = v.commissionAvailableToRedeem;
            }
        }
        return (delegated, rewardsAvailable, commissionRewards);
    }

    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){
        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);
        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);
    }
}",4532,2,3,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Audit all `unchecked` blocks for potential integer overflow/underflow vulnerabilities, especially considering the use of `uint128` and calculations involving `divider`."",
        ""Verify potential reentrancy risks, particularly in functions involving external calls (`_transferToContract`, `_transferFromContract`) followed by state updates (e.g., `stake`, `unstake`, `_redeemRewards`, `transferUnstakedOut`)."",
        ""Analyze potential manipulation of `globalExchangeRate` and validator `exchangeRate` through strategically timed stakes/unstakes or reward redemptions."",
        ""Check for Denial of Service (DoS) vectors, such as reverting transactions under specific conditions (e.g., division by zero if `totalGlobalShares` or `v.totalShares` could become zero unexpectedly, though checks exist)."",
        ""Review division operations (`_sharesToTokens`, `_tokensToShares`, rate updates) for potential precision loss or rounding errors that could be exploited or lead to unfair reward distribution over time."",
        ""Examine edge cases where staking/unstaking/redeeming very small amounts (dust) might lead to unexpected behavior or locked funds due to precision issues.""
      ]
    },
    {
      ""Area"": ""Staking/Rewards Logic"",
      ""Tasks"": [
        ""Verify the mathematical correctness and consistency of the reward calculation logic in `_updateGlobalExchangeRate` and `_updateValidator`, including commission calculation."",
        ""Trace the state updates (`totalGlobalShares`, `v.globalShares`, `v.totalShares`, `s.shares`, `s.staked`, `v.delegated`, `v.commissionAvailableToRedeem`) across all relevant functions (`stake`, `unstake`, `_redeemRewards`, `disableValidator`, `recoverUnstaking`, `redelegateUnstaked`) to ensure atomicity and correctness."",
        ""Analyze the interaction between `rewardsLocked` and `endEpoch`, ensuring the transition and calculation logic in `stake` and `depositRewardTokens` is sound."",
        ""Review the behavior of the system precisely at and after `endEpoch`. Ensure reward calculations cease correctly and remaining actions (unstaking, redeeming) function as expected."",
        ""Validate the cooldown logic in `unstake` and `transferUnstakedOut`, ensuring correct calculation of `coolDownEnd` and enforcement of the waiting period."",
        ""Assess the logic for handling validator disabling (`disableValidator`), ensuring rewards stop accruing correctly for the validator and its delegators, and that global share accounting is accurate."",
        ""Confirm the logic in `recoverUnstaking` and `redelegateUnstaked` correctly re-stakes the specified amount and updates associated shares and balances without requiring new token transfers."",
        ""Verify that redeeming zero amount (`redeemAllRewards` or `_redeemRewards` with amount=0) correctly calculates and transfers all available rewards/commission."",
        ""Check requirements related to minimum stake (`validatorMinStakedRequired`) and max capacity (`maxCapMultiplier`) in `stake` and `unstake` functions for correct enforcement.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Confirm that all functions intended for the owner (`depositRewardTokens`, `takeOutRewardTokens`, `addValidator`, `setAllocatedTokensPerEpoch`, `setMaxCapMultiplier`, `setValidatorCommissionRate`, `setValidatorMinStakedRequired`) correctly implement the `onlyOwner` modifier or equivalent check."",
        ""Verify the access control for `disableValidator`, ensuring only the owner or the validator's address (`v._address`) can call it."",
        ""Ensure that users cannot perform actions on validators or unstakings they do not own (e.g., cannot `unstake` or `redeemRewards` for another user, cannot `transferUnstakedOut` from another user's unstaking entry)."",
        ""Check that `redelegateUnstaked` correctly prevents the validator address itself from redelegating its own unstaked funds from its disabled validator entry.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify the correct and safe usage of `SafeERC20Upgradeable` for all CQT token transfers (`safeTransferFrom`, `safeTransfer`)."",
        ""Assess the implications of the hardcoded CQT token address. Confirm it points to the correct, intended ERC20 contract."",
        ""Consider potential issues if the CQT token implementation is non-standard (e.g., fee-on-transfer, reentrancy callbacks, revert on zero-value transfers - though SafeERC20 handles some)."",
        ""Ensure the contract correctly handles potential `transfer`/`transferFrom` failures (though `SafeERC20Upgradeable` reverts on failure).""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze loops in `getValidatorsDetails` and `getDelegatorDetails` for potential gas exhaustion if the number of validators (`validatorsN`) becomes very large."",
        ""Identify redundant state reads or calculations within functions, especially repeated calls to `_updateGlobalExchangeRate` and `_updateValidator` if their results could be cached within a single transaction."",
        ""Evaluate storage access patterns for potential optimizations (e.g., packing structs, minimizing SLOAD/SSTORE operations).""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Confirm the `initialize` function adheres to OZ Upgradeable standards (uses `initializer` modifier, calls parent initializers like `__Ownable_init`)."",
        ""Verify that no constructors are present."",
        ""Review the state variable layout for potential storage collision risks in future upgrades."",
        ""Ensure immutables/constants like `CQT` and `divider` are appropriate or if they might need changing in future versions (changing `CQT` would require a more complex upgrade or redeployment).""
      ]
    },
    {
      ""Area"": ""Parameterization and Tokenomics"",
      ""Tasks"": [
        ""Evaluate the implications of using `uint128` for most state variables. Confirm that intermediate calculations, especially multiplications within `unchecked` blocks, are unlikely to exceed `type(uint128).max` under reasonable assumptions."",
        ""Analyze the logic in `setAllocatedTokensPerEpoch`, particularly the calculation and transfer of `toTransfer`, ensuring it behaves correctly and doesn't lock/leak funds."",
        ""Review the initial hardcoded values for `validatorCoolDown`, `delegatorCoolDown`, and `maxCapMultiplier` in `initialize` and assess if they should be configurable post-deployment."",
        ""Assess the impact of changing parameters like `maxCapMultiplier` or `validatorMinStakedRequired` on existing validators and delegators.""
      ]
    },
    {
      ""Area"": ""Edge Cases and Robustness"",
      ""Tasks"": [
        ""Test scenarios where `totalGlobalShares` or a validator's `totalShares` become zero. Verify division-by-zero is correctly handled by existing checks."",
        ""Analyze behavior when adding the very first validator (`validatorsN = 0` initially)."",
        ""Check the handling of zero-amount inputs where require statements check for `> 0` (e.g., `takeOutRewardTokens`, `redeemRewards`, `setAllocatedTokensPerEpoch`)."",
        ""Verify the logic correctly handles unstaking the entire staked amount."",
        ""Assess the handling of array access in `validators[validatorId]` and `v.unstakings[msg.sender][unstakingId]`, ensuring IDs are validated to prevent out-of-bounds access (checks `validatorId < validatorsN` exist, need to ensure `unstakingId` is valid within the user's array).""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code implements a delegated staking mechanism, allowing users to stake CQT tokens through validators and earn rewards. The contract manages validator registration, staking/unstaking, reward distribution, and handles edge cases like validator disabling and unstaking cooldowns. It uses upgradeable contracts from OpenZeppelin."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""DelegatedStaking"",
    ""Purpose"": ""Implements a delegated staking system where users stake CQT tokens with validators to earn rewards. The contract handles staking, unstaking, reward distribution, and validator management."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""OwnableUpgradeable""],
      ""Imports"": [""IERC20Upgradeable"", ""OwnableUpgradeable"", ""Initializable"", ""SafeERC20Upgradeable""]
    },
    ""StateVariables"": [
      {
        ""Name"": ""divider"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant for calculations, set to 10**18, presumably for fixed-point arithmetic.""
      },
      {
        ""Name"": ""validatorCoolDown"",
        ""Type"": ""uint128"",
        ""Purpose"": ""Cooldown period for validators after unstaking.""
      },
      {
        ""Name"": ""delegatorCoolDown"",
        ""Type"": ""uint128"",
        ""Purpose"": ""Cooldown period for delegators after unstaking.""
      },
      {
        ""Name"": ""maxCapMultiplier"",
        ""Type"": ""uint128"",
        ""Purpose"": ""Multiplier to calculate the maximum delegation capacity for a validator.""
      },
      {
        ""Name"": ""validatorMinStakedRequired"",
        ""Type"": ""uint128"",
        ""Purpose"": ""Minimum amount of tokens a validator must stake.""
      },
      {
        ""Name"": ""allocatedTokensPerEpoch"",
        ""Type"": ""uint128"",
        ""Purpose"": ""The amount of tokens allocated for rewards per epoch.""
      },
      {
        ""Name"": ""rewardsLocked"",
        ""Type"": ""uint128"",
        ""Purpose"": ""Amount of reward tokens locked in the contract. Used before epoch calculation starts.""
      },
      {
        ""Name"": ""endEpoch"",
        ""Type"": ""uint128"",
        ""Purpose"": ""The block number at which the rewards program ends.""
      },
      {
        ""Name"": ""totalGlobalShares"",
        ""Type"": ""uint128"",
        ""Purpose"": ""The total number of global shares in the system.""
      },
      {
        ""Name"": ""lastUpdateEpoch"",
        ""Type"": ""uint128"",
        ""Purpose"": ""The last epoch at which the global exchange rate was updated.""
      },
      {
        ""Name"": ""globalExchangeRate"",
        ""Type"": ""uint128"",
        ""Purpose"": ""The global exchange rate used to calculate rewards.""
      },
      {
        ""Name"": ""validatorsN"",
        ""Type"": ""uint128"",
        ""Purpose"": ""The total number of validators.""
      },
      {
        ""Name"": ""validators"",
        ""Type"": ""mapping(uint128 => Validator)"",
        ""Purpose"": ""Mapping from validator ID to Validator struct.""
      },
      {
        ""Name"": ""CQT"",
        ""Type"": ""IERC20Upgradeable"",
        ""Purpose"": ""Constant address of the CQT token contract.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, setting initial values for state variables."",
        ""Parameters"": [""uint128 minStakedRequired""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferToContract"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers tokens from a specified address to the contract."",
        ""Parameters"": [""address from"", ""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromContract"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers tokens from the contract to a specified address."",
        ""Parameters"": [""address to"", ""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""depositRewardTokens"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Deposits reward tokens into the contract, increasing the endEpoch."",
        ""Parameters"": [""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""takeOutRewardTokens"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Takes out reward tokens from the contract, decreasing the endEpoch."",
        ""Parameters"": [""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateGlobalExchangeRate"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the global exchange rate based on the elapsed time since the last update."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateValidator"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates a validator's exchange rate and commission available to redeem."",
        ""Parameters"": [""Validator storage v""],
        ""Returns"": []
      },
      {
        ""Name"": ""_sharesToTokens"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Converts shares to tokens based on a given rate."",
        ""Parameters"": [""uint128 sharesN"", ""uint128 rate""],
        ""Returns"": [""uint128""]
      },
      {
        ""Name"": ""_tokensToShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Converts tokens to shares based on a given rate."",
        ""Parameters"": [""uint128 amount"", ""uint128 rate""],
        ""Returns"": [""uint128""]
      },
      {
        ""Name"": ""stake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to stake tokens with a specific validator."",
        ""Parameters"": [""uint128 validatorId"", ""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_stake"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to stake tokens with a specific validator."",
        ""Parameters"": [""uint128 validatorId"", ""uint128 amount"", ""bool withTransfer""],
        ""Returns"": []
      },
      {
        ""Name"": ""unstake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to unstake tokens from a specific validator."",
        ""Parameters"": [""uint128 validatorId"", ""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""recoverUnstaking"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Recovers a portion of unstaked tokens, restaking them."",
        ""Parameters"": [""uint128 amount"", ""uint128 validatorId"", ""uint128 unstakingId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_redeemRewards"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to redeem rewards for a user."",
        ""Parameters"": [""uint128 validatorId"", ""address beneficiary"", ""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""redeemAllRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Redeems all available rewards for a user."",
        ""Parameters"": [""uint128 validatorId"", ""address beneficiary""],
        ""Returns"": []
      },
      {
        ""Name"": ""redeemRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Redeems a specific amount of rewards for a user."",
        ""Parameters"": [""uint128 validatorId"", ""address beneficiary"", ""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""addValidator"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds a new validator to the system. Only callable by the owner."",
        ""Parameters"": [""address validator"", ""address operator"", ""uint128 commissionRate""],
        ""Returns"": []
      },
      {
        ""Name"": ""disableValidator"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Disables a validator, preventing further staking and reward accrual."",
        ""Parameters"": [""uint128 validatorId""],
        ""Returns"": []
      },
      {
        ""Name"": ""setAllocatedTokensPerEpoch"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the amount of tokens allocated per epoch. Only callable by the owner."",
        ""Parameters"": [""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setMaxCapMultiplier"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the maximum capacity multiplier for validators. Only callable by the owner."",
        ""Parameters"": [""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setValidatorCommissionRate"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the commission rate for a specific validator. Only callable by the owner."",
        ""Parameters"": [""uint128 amount"", ""uint128 validatorId""],
        ""Returns"": []
      },
      {
        ""Name"": ""setValidatorMinStakedRequired"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the minimum staked required for a validator. Only callable by the owner."",
        ""Parameters"": [""uint128 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""redelegateUnstaked"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Redelegates unstaked tokens from a disabled validator to a new validator."",
        ""Parameters"": [""uint128 amount"", ""uint128 oldValidatorId"", ""uint128 newValidatorId"", ""uint128 unstakingId""],
        ""Returns"": []
      },
      {
        ""Name"": ""transferUnstakedOut"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers unstaked tokens out of the contract after the cooldown period."",
        ""Parameters"": [""uint128 amount"", ""uint128 validatorId"", ""uint128 unstakingId""],
        ""Returns"": []
      },
       {
        ""Name"": ""getValidatorsDetails"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns commission rates and delegated amounts of all validators"",
        ""Parameters"": [],
        ""Returns"": [""uint128[] commissionRates"", ""uint128[] delegated""]
      },
      {
        ""Name"": ""getDelegatorDetails"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns staking, rewards and commission rewards information for a given delegator"",
        ""Parameters"": [""address delegator""],
        ""Returns"": [""uint128[] delegated"", ""uint128[] rewardsAvailable"", ""uint128[] commissionRewards""]
      },
      {
        ""Name"": ""getMetadata"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns current system metadata"",
        ""Parameters"": [],
        ""Returns"": [""uint128 allocatedTokensPerEpoch"", ""uint128 endEpoch"", ""uint128 maxCapMultiplier"", ""uint128 totalStaked"", ""uint128 validatorsN""]
      }
    ]
  },
  ""ExternalInteractions"": [""IERC20Upgradeable (CQT token)""],
  ""SpecialMechanisms"": [
    ""Upgradeable contract using OpenZeppelin's upgradeable contracts."",
    ""Uses SafeERC20Upgradeable for safe token transfers."",
    ""Employs a shares-based system for tracking staking and rewards."",
    ""Manages validator commissions and reward distribution."",
    ""Implements a cooldown period for unstaking."",
    ""Uses block numbers to define epochs.""
  ],
  ""Questions"": [
    ""How is the initial value for 'rewardsLocked' handled when calculating the 'endEpoch'?"",
    ""What happens if a validator is disabled during an unstaking cooldown?"",
    ""Is there a mechanism to handle rounding errors in the _sharesToTokens and _tokensToShares functions?"",
    ""The initialization function sets hardcoded values for validatorCoolDown and delegatorCoolDown. Should these be configurable?"",
    ""The CQT token address is hardcoded. How will the contract be updated if the CQT token is migrated to a new address?"",
    ""Why are most of the uint variables defined as uint128 instead of uint256. Is there any specific reason to limit their range?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in Reward Redemption and Unstaking"",
      ""Severity"": ""High"",
      ""Description"": ""The `_redeemRewards` and `transferUnstakedOut` functions transfer tokens using `_transferFromContract` *before* updating internal state. This allows a malicious recipient contract to re-enter the staking contract during the token transfer via the CQT token's `safeTransfer` callback, potentially draining funds multiple times or manipulating contract state before the original transaction completes. This violates the Checks-Effects-Interactions pattern."",
      ""Impact"": ""Significant loss of funds, contract malfunction, and unauthorized access to rewards due to reentrancy attacks where an attacker can repeatedly call functions to drain funds or manipulate the contract's state in an unintended manner."",
      ""Location"": ""_redeemRewards function, redeemAllRewards function, redeemRewards function, transferUnstakedOut function, _transferFromContract""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Reward Calculations"",
      ""Severity"": ""High"",
      ""Description"": ""The contract performs arithmetic operations on `uint128` variables (especially in reward distribution and share calculations within `_updateGlobalExchangeRate`, `_updateValidator`, `_sharesToTokens`, `_tokensToShares`, and `_redeemRewards`) without sufficient overflow/underflow checks, even with `unchecked` blocks. Large values for `allocatedTokensPerEpoch`, `currentEpoch - lastUpdateEpoch`, `totalGlobalShares`, or `commissionRate` could cause overflows/underflows, leading to incorrect `globalExchangeRate` or `commissionPaid` and ultimately incorrect reward distribution and accounting."",
      ""Impact"": ""Incorrect reward calculations, potential loss of funds for stakers, manipulation of the system to favor certain actors, and contract malfunction due to inconsistent state."",
      ""Location"": ""_updateGlobalExchangeRate function, _updateValidator function, _sharesToTokens function, _tokensToShares function, _redeemRewards""
    },
    {
      ""Issue"": ""Potential Division by Zero in Exchange Rate and Reward Calculations"",
      ""Severity"": ""High"",
      ""Description"": ""The `_updateGlobalExchangeRate` and `_updateValidator` functions perform division operations using `totalGlobalShares` and `v.totalShares` respectively. If either of these values is zero, a division by zero error will occur, halting contract execution and preventing reward distribution. Although checks exist, race conditions or logic errors may lead to this state, especially during initialization."",
      ""Impact"": ""Contract functionality will be halted, preventing stakers from claiming rewards or unstaking their tokens. This could lead to a significant loss of funds and reputational damage. Staking rewards will be blocked in case of division by zero. This can affect users and validators."",
      ""Location"": ""_updateGlobalExchangeRate, _updateValidator, _sharesToTokens, _tokensToShares""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `_updateGlobalExchangeRate`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_updateGlobalExchangeRate` function calculates `globalExchangeRate` by adding a product of `allocatedTokensPerEpoch`, `divider`, and `(currentEpoch - lastUpdateEpoch)` divided by `totalGlobalShares`. While using `unchecked` blocks mitigates reverts, a large enough `currentEpoch - lastUpdateEpoch` value multiplied by `allocatedTokensPerEpoch` and `divider` could cause an overflow which leads to an incorrect `globalExchangeRate`, affecting reward calculations."",
      ""Impact"": ""Incorrect reward distribution, potential loss of funds for stakers, and inconsistency in exchange rate calculation."",
      ""Location"": ""DelegatedStaking.sol:_updateGlobalExchangeRate""
    },
    {
      ""Issue"": ""Incorrect Calculation of Future Rewards in `setAllocatedTokensPerEpoch`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `setAllocatedTokensPerEpoch`, the contract attempts to adjust the `endEpoch` based on the new `allocatedTokensPerEpoch`. The calculation of `futureRewards` and subsequent adjustment of `endEpoch` and `toTransfer` can lead to inaccuracies and potentially transfer funds to the owner incorrectly. If `futureRewards` is very large and `amount` is small, the modulo operation could result in small `toTransfer` values which may lead to stakers not receiving rewards at the correct rate."",
      ""Impact"": ""Incorrect duration of the staking program, potentially leading to early termination or unexpected reward distribution. Funds potentially get sent to the owner incorrectly. Stakers may not receive the accurate rewards"",
      ""Location"": ""setAllocatedTokensPerEpoch function""
    },
    {
      ""Issue"": ""Incorrect Calculation of `rewardsAvailable` in `getDelegatorDetails`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getDelegatorDetails` function calculates `rewardsAvailable` using a local `newGlobalExchangeRate` calculation, which doesn't fully account for potential integer overflows or precise calculations as `_updateGlobalExchangeRate` does. The use of `block.number` can be manipulated in `eth_call` by miners to return 0. If `newGlobalExchangeRate` is inaccurate, `newTokensGiven` will also be inaccurate and affect rewards. This inaccurate rewardsAvailable affects stakers' decisions."",
      ""Impact"": ""Inaccurate reward information displayed to users, potentially leading to dissatisfaction and confusion."",
      ""Location"": ""getDelegatorDetails function""
    },
    {
      ""Issue"": ""Potential for Griefing in `setAllocatedTokensPerEpoch` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""If the owner reduces the `allocatedTokensPerEpoch` significantly in the `setAllocatedTokensPerEpoch` function, the calculation of `addEpochs` can become zero, leading to a require statement `require(addEpochs != 0, \\""This amount will end the program\\"")` failing. Additionally, the calculation toTransfer = futureRewards % amount will potentially lead to loss of funds for stakers and inconsistent exchange rates because toTransfer funds will be transfered to the owner\'s address."",
      ""Impact"": ""Denial of service, Potential loss of stakers' funds."",
      ""Location"": ""DelegatedStaking.sol:setAllocatedTokensPerEpoch""
    },
    {
      ""Issue"": ""Inconsistent Epoch Management Due to Reliance on `block.number`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `block.number` to determine the current epoch and calculate rewards. Relying on `block.number` introduces dependencies on block production and can be subject to manipulation. It also mixes block numbers and calculated epoch values which can lead to unexpected behavior or incorrect assumptions about the duration of staking epochs."",
      ""Impact"": ""Inconsistent reward distribution, errors in calculating the number of epochs, or vulnerabilities to blockchain reorganizations. Unexpected behavior in reward distribution and staking program duration."",
      ""Location"": ""_updateGlobalExchangeRate, depositRewardTokens, takeOutRewardTokens, stake, unstake, disableValidator, setAllocatedTokensPerEpoch""
    },
    {
      ""Issue"": ""Missing Access Control on `redelegateUnstaked` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `redelegateUnstaked` function requires the `oldValidator` to be disabled, but has no checks if the `msg.sender` is authorized to redelegate from the `unstakings` array, allowing anyone to call this function. It is possible for an unauthorized user to call `redelegateUnstaked` with the correct parameters, which will cause `us.amount` to decrease without actually staking."",
      ""Impact"": ""A malicious actor may be able to \'burn\' a user\'s unstaked tokens by repeatedly calling `redelegateUnstaked`."",
      ""Location"": ""redelegateUnstaked function""
    },
    {
      ""Issue"": ""Potential for Denial of Service (DoS) in Unstaking Due to Large Unstaking Array"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `Validator` struct contains a mapping `mapping(address => Unstaking[]) unstakings;`. This allows each delegator to have an array of `Unstaking` objects for each validator. If a user unstakes many times (creating a large number of entries in the `unstakings` array), subsequent operations that iterate or access this array could become extremely gas-intensive, potentially leading to a denial of service (DoS). In particular, `recoverUnstaking` and `transferUnstakedOut` access elements within this array, and if `unstakingId` is very large, the gas cost could make these functions unusable."",
      ""Impact"": ""Inability to recover or transfer unstaked tokens, potential griefing attack by creating large unstaking arrays."",
      ""Location"": ""Validator struct, unstake function, recoverUnstaking function, transferUnstakedOut function""
    },
    {
      ""Issue"": ""Potential Loss of Funds Due to Incorrect Commission Calculation Logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_updateValidator` function, the commission is calculated based on the tokens given to the validator: `uint128 commissionPaid`. However, `commissionPaid` is later added to `v.commissionAvailableToRedeem`. The commission is calculated based on global exchange rate differences and is not directly tied to the validator\'s delegated stake. Therefore, it\'s possible for the calculated commission and subsequently `v.commissionAvailableToRedeem` to exceed the total rewards generated by validator's stake. If a malicious validator sets a high commission rate, they could drain a disproportionate amount of rewards from the system at the expense of the delegators' stake."",
      ""Impact"": ""Validators can unfairly extract a large share of rewards that should belong to delegators, leading to financial loss for delegators and potential instability of the staking system. Malicious validators can exploit this vulnerability to drain funds from the contract."",
      ""Location"": ""Functions: `_updateValidator`, `_redeemRewards`""
    },
    {
      ""Issue"": ""Missing Access Control on `transferUnstakedOut`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferUnstakedOut` function allows a delegator to withdraw unstaked tokens after the cooldown period has ended. While there is a check to ensure that the cooldown period has elapsed (`uint128(block.number) > us.coolDownEnd`) and that the amount is valid (`us.amount >= amount`), there is no explicit check to verify that the caller (`msg.sender`) is the intended recipient of the unstaked tokens."",
      ""Impact"": ""The function is susceptible to potential logical errors if the intended delegator is not the caller."",
      ""Location"": ""DelegatedStaking.sol:362""
    },
    {
      ""Issue"": ""Potential for Griefing in `redelegateUnstaked` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `redelegateUnstaked` function allows delegators to redelegate their unstaked tokens from a disabled validator to a new validator. However, it requires that the old validator is disabled and that the caller is not the validator itself.  A malicious actor could potentially grief delegators by repeatedly calling `redelegateUnstaked` with small amounts, depleting their unstaked balance bit by bit and increasing transaction costs for the delegator."",
      ""Impact"": ""Delegators might experience increased transaction costs and inconvenience due to griefing attacks."",
      ""Location"": ""Function: `redelegateUnstaked`""
    },
    {
      ""Issue"": ""Unbounded Array Length in `unstakings` Mapping"",
      ""Severity"": ""Low"",
      ""Description"": ""The `unstakings` mapping in the `Validator` struct uses an unbounded array (`Unstaking[]`). If a user repeatedly unstakes from a validator, the `unstakings` array could grow indefinitely, potentially leading to gas exhaustion issues when iterating over it or when the storage becomes too large. Consider implementing a mechanism to limit the size of the `unstakings` array, such as enforcing a maximum number of unstaking requests or allowing users to consolidate multiple unstaking requests into a single one."",
      ""Impact"": ""Increased gas costs for users, potential for denial-of-service attacks if the `unstakings` array becomes too large."",
      ""Location"": ""Validator struct definition, `unstake` function""
    },
    {
      ""Issue"": ""Rounding errors in share/token conversion"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_sharesToTokens` and `_tokensToShares` functions perform integer division, which can lead to rounding errors. These rounding errors can accumulate over time and result in small discrepancies in the amount of tokens users receive or the number of shares they are credited with."",
      ""Impact"": ""Slightly inaccurate reward distribution or stake tracking."",
      ""Location"": ""DelegatedStaking.sol:_sharesToTokens, DelegatedStaking.sol:_tokensToShares""
    }
  ],
  ""IssueNumber"": 50,
  ""OutputList"": 14
}",240.4732840061188,4682.0,32.0,"### **Output**

---

**[H-01] Usage of an incorrect version of Ownable library can potentially malfunction all onlyOwner functions**

**Report Description**:  
The `DelegatedStaking.sol` contract is designed to be deployed as an upgradeable proxy contract. However, it uses the non-upgradeable version of the `Ownable` library (`@openzeppelin/contracts/access/Ownable.sol`) instead of the upgradeable version (`@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol`). This mismatch means that the deployer will not be set as the owner when the contract is deployed as a proxy, rendering all `onlyOwner` functions inaccessible.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the incorrect usage of the `Ownable` library in an upgradeable contract, which is not covered in the response list.

---

**[H-02] unstake should update exchange rates first**

**Report Description**:  
The `unstake` function computes `validatorSharesRemove` using the old exchange rate before updating the exchange rates. This can lead to incorrect calculations of shares to be removed, especially if the exchange rate changes significantly between the computation and the update.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the order of operations in the `unstake` function, which is not covered in the response list.

---

**[M-01] reward tokens could get lost due to rounding down**

**Report Description**:  
The `depositRewardTokens` function divides the `amount` of tokens by `allocatedTokensPerEpoch` to calculate the `endEpoch`. When `amount` is not a multiple of `allocatedTokensPerEpoch`, the result of the division is rounded down, leading to the loss of tokens. This issue also occurs in `setAllocatedTokensPerEpoch`, `takeOutRewardTokens`, and `_stake`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to rounding errors in reward token calculations, which is not covered in the response list.

---

**[M-02] Incorrect updateGlobalExchangeRate implementation**

**Report Description**:  
The `_updateGlobalExchangeRate` function has an incorrect implementation when `totalGlobalShares` is zero. If `totalGlobalShares` becomes zero due to unstaking or disabling a validator, the function may fail or produce incorrect results.

**Match in Response List**:  
Matches with the issue titled **""Potential Division by Zero in Exchange Rate and Reward Calculations""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with division by zero in `_updateGlobalExchangeRate`. It correctly explains the risks associated with this scenario, which aligns with the issue report.

---

**[M-03] Validator can fail to receive commission reward in redeemAllRewards**

**Report Description**:  
The `redeemAllRewards` function includes a check that requires `rewards > 0`. However, this check may cause the transaction to revert even if the validator has commission rewards to receive, as the commission rewards are not included in this calculation.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The problem is specific to the incorrect handling of commission rewards in `redeemAllRewards`, which is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] Incorrect updateGlobalExchangeRate implementation**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-01] Usage of an incorrect version of Ownable library can potentially malfunction all onlyOwner functions**
- **[H-02] unstake should update exchange rates first**
- **[M-01] reward tokens could get lost due to rounding down**
- **[M-03] Validator can fail to receive commission reward in redeemAllRewards**

---","```
1. Potential Division by Zero in Exchange Rate and Reward Calculations
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Potential Division by Zero in Exchange Rate and Reward Calculations"".
   - This issue appears at **rank 3** in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 3 (\( P@3 \)) is calculated as the number of true positives up to rank 3 divided by 3.
   - Since there is only one true positive up to rank 3, \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - Therefore, \( AP = 0.333 \).

**Output**:
```
0.333
```"
