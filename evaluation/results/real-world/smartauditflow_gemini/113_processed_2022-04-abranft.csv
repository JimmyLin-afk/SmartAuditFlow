nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTPairWithOracle.sol,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8413,754,"[H-01] Avoidance of Liquidation Via Malicious Oracle
Issue: Arbitrary oracles are permitted on construction of loans, and there is no check that the lender agrees to the used oracle.
Consequences: A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation. Lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed
  [H-02] The return value success of the get function of the INFTOracle interface is not checked “(, uint256 rate) = loanParams.oracle.get(address(this), tokenId);”
The get function of the INFTOracle interface returns two values, but the success value is not checked when used in the NFTPairWithOracle contract. When success is false, NFTOracle may return stale data.
  [H-03] Critical Oracle Manipulation Risk by Lender
The intended use of the Oracle is to protect the lender from a drop in the borrower's collateral value. If the collateral value goes up significantly and higher than borrowed amount + interest, the lender should not be able to seize the collateral at the expense of the borrower. However, in the NFTPairWithOracle contract, the lender could change the Oracle once a loan is outstanding, and therefore seize the collateral at the expense of the borrower, if the actual value of the collateral has increased significantly. This is a critical risk because borrowers asset could be lost to malicious lenders.
  [H-04] Lender is able to seize the collateral by changing the loan parameters The `updateLoanParams()` allows the lender to modify the parameters of an active loan in favor of the borrower. But, by setting the ltvBPS value to 0 they are able to seize the collateral.   [H-05] Mistake while checking LTV to lender accepted LTV
It comments in the `_lend()` function that lender accepted conditions must be at least as good as the borrower is asking for. The line which checks the accepted LTV (lender's LTV) against borrower asking LTV is: `params.ltvBPS >= accepted.ltvBPS`, This means lender should be offering a lower LTV, which must be the opposite way around. I think this may have the potential to strand the lender, if he enters a lower LTV. For example borrower asking LTV is 86%. However, lender enters his accepted LTV as 80%. lend() will execute with 86% LTV and punish the lender, whereas it should revert and acknowledge the lender that his bid is not good enough.
  [M-01] Reentrancy at _requestLoan allows requesting a loan without supplying collateral
The function `_requestLoan` makes an external call to the collateral contract before updating the NFTPair contract state.
",6,,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; 
    uint64 duration; 
    uint16 annualInterestBPS; 
    uint16 ltvBPS; 
    INFTOracle oracle; 
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}




contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    
    address public feeTo;

    
    
    IERC721 public collateral;
    IERC20 public asset;

    
    

    
    uint256 public feesEarnedShare;

    
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    
    mapping(address => uint256) public nonces;

    
    
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            
            
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            
            
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            
            
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        
        
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    
    
    
    
    
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    
    
    
    
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            
            
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                
                
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        
        
        
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        
        
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); 
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    
    
    
    
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    
    
    

    
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    

    
    
    
    
    
    
    
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    
    
    
    
    
    
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); 
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        
        
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    
    uint8 internal constant ACTION_CALL = 30;

    
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); 
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    
    
    
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    
    
    
    
    
    
    
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    
    
    
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",4953,5,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze all external calls (especially via `cook`'s `ACTION_CALL`) for potential reentrancy vulnerabilities. Pay close attention to state updates before and after external calls."",
        ""Examine integer overflow/underflow possibilities in the `calculateInterest` function, especially given the multiplications and divisions involved. Verify the `BoringMath` library is correctly mitigating these risks."",
        ""Inspect the `skim` parameters in `requestLoan`, `lend`, and `repay` for potential misuse scenarios where assets/NFTs sent directly to the contract could lead to unexpected behavior or exploits. Ensure all paths using skim are properly authorized and validated."",
        ""Investigate potential denial-of-service (DoS) vulnerabilities. For example, could a large number of loan requests exhaust gas limits or state variables?"",
        ""Check for potential front-running opportunities, especially in `requestLoan` and `lend`. Could malicious actors manipulate loan parameters or valuations before a transaction is mined?"",
        ""Verify that the `DOMAIN_SEPARATOR` and signature verification logic in `requestAndBorrow` and `takeCollateralAndLend` are correctly implemented to prevent signature malleability or replay attacks. Ensure nonces are incremented correctly and consistently."",
        ""Analyze how the contract handles reverts and exceptions to prevent stuck states or loss of funds. Specifically, check error handling in BentoBox interactions and external oracle calls."",
        ""Assess if it's possible to manipulate the NFT oracle to artificially inflate the value of the collateral, leading to excessive borrowing.""
      ]
    },
    {
      ""Area"": ""Compliance and Standards"",
      ""Tasks"": [
        ""Confirm that the contract correctly implements the IERC721 and IERC20 interfaces for `collateral` and `asset` tokens, respectively. Verify that all required functions are present and behave as expected."",
        ""Ensure that all token transfers adhere to the ERC721 and ERC20 standards, especially when interacting with the BentoBox. Review the BentoBox's documentation to understand how it handles non-standard tokens."",
        ""Verify that the contract complies with any relevant regulatory requirements for lending platforms, such as KYC/AML compliance (if applicable)."",
        ""Confirm correct handling of ERC777 tokens if asset is ERC777.""
      ]
    },
    {
      ""Area"": ""Complex Logic and Algorithms"",
      ""Tasks"": [
        ""Thoroughly review the `calculateInterest` function for accuracy and potential edge cases. Compare the results to a trusted interest calculation library and analyze potential deviations, especially for large principal values, long durations, and high APRs. Consider using formal verification methods to ensure its correctness."",
        ""Analyze the logic in `removeCollateral` to ensure that the liquidation criteria (oracle price vs. debt) are correctly implemented and prevent scenarios where lenders can unfairly seize collateral or borrowers are unjustly liquidated. Check the handling of rounding errors."",
        ""Examine the `cook` function for potential vulnerabilities due to the flexibility it provides. Ensure that the allowed actions and data are properly validated and that no malicious combinations of actions can lead to unexpected or harmful outcomes."",
        ""Verify that the loan state machine (LOAN_INITIAL, LOAN_REQUESTED, LOAN_OUTSTANDING) is robust and prevents invalid state transitions or inconsistencies.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Analyze the trust assumptions and potential risks associated with relying on the external `INFTOracle`. Research the oracle's implementation and security measures to assess its reliability and resistance to manipulation. Implement circuit breakers or fallback mechanisms in case of oracle failure or data staleness."",
        ""Investigate the interaction with the `ILendingClub` contract in `requestAndBorrow`. Ensure that the `willLend` function is secure and reliable, and that its response cannot be manipulated by malicious actors."",
        ""Assess the potential impact of unexpected behavior or vulnerabilities in the BentoBox contract. Review the BentoBox's audit reports and security documentation to identify potential risks."",
        ""Analyze the gas costs associated with calling different functions in the contract, especially those involving external interactions. Identify opportunities for gas optimization to reduce transaction costs for users.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is correctly used to protect sensitive functions, such as `setFeeTo`. Ensure that the owner address is properly managed and secured."",
        ""Analyze the access control logic in `updateLoanParams` and `removeCollateral` to ensure that only authorized parties can modify loan parameters or claim collateral. Prevent scenarios where unauthorized actors can manipulate loans or steal assets."",
        ""Examine the `bentoBox.setMasterContractApproval` calls within the `cook` function, ensuring that approval is only granted with proper authorization and that the user truly intends to approve this master contract.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify gas-intensive operations, especially those involving loops, storage access, and external calls."",
        ""Optimize data storage by using efficient data types (e.g., `uint128` where appropriate) and minimizing storage reads/writes."",
        ""Consider using assembly code for gas-critical operations (if necessary), but only after careful security review."",
        ""Evaluate the use of caching and other techniques to reduce gas consumption in frequently called functions."",
        ""Check if the `skim` parameters significantly reduce gas costs and justify the added complexity and potential risks.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `NFTPairWithOracle` facilitates NFT-collateralized lending within the SushiSwap BentoBox ecosystem. It allows users to deposit an NFT as collateral, request a loan in a specific ERC20 asset, and have lenders fulfill these requests. The contract manages the loan lifecycle, including parameter updates, interest calculation (compounded), repayment, and liquidation (removal of collateral) based on time expiry or oracle-provided valuation relative to LTV. It leverages BentoBox for efficient token handling, supports gasless approvals via EIP-712 signatures, and includes a batch execution function (`cook`) for combining multiple actions."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTPairWithOracle"",
    ""Purpose"": ""To create and manage individual lending markets for a specific NFT collection (collateral) paired with a specific ERC20 token (asset), integrating with BentoBox and an NFT oracle."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""BoringOwnable"",
        ""Domain"",
        ""IMasterContract""
      ],
      ""Imports"": [
        ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"",
        ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"",
        ""@boringcrypto/boring-solidity/contracts/Domain.sol"",
        ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"",
        ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"",
        ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"",
        ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"",
        ""./interfaces/IERC721.sol"",
        ""./interfaces/INFTOracle.sol"",
        ""./interfaces/ILendingClub.sol"",
        ""./interfaces/INFTPair.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""bentoBox"",
        ""Type"": ""IBentoBoxV1"",
        ""Purpose"": ""Immutable reference to the BentoBox contract used for token storage and transfers.""
      },
      {
        ""Name"": ""masterContract"",
        ""Type"": ""NFTPairWithOracle"",
        ""Purpose"": ""Immutable reference to the master contract implementation (itself in this case), required by BentoBox.""
      },
      {
        ""Name"": ""feeTo"",
        ""Type"": ""address"",
        ""Purpose"": ""Address designated to receive protocol fees.""
      },
      {
        ""Name"": ""collateral"",
        ""Type"": ""IERC721"",
        ""Purpose"": ""The NFT contract address for the collateral.""
      },
      {
        ""Name"": ""asset"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""The ERC20 token contract address for the loan asset.""
      },
      {
        ""Name"": ""feesEarnedShare"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Accumulated protocol fees stored as BentoBox shares.""
      },
      {
        ""Name"": ""tokenLoanParams"",
        ""Type"": ""mapping(uint256 => TokenLoanParams)"",
        ""Purpose"": ""Stores the specific loan parameters (valuation, duration, interest, LTV, oracle) for each collateral NFT tokenId.""
      },
      {
        ""Name"": ""tokenLoan"",
        ""Type"": ""mapping(uint256 => TokenLoan)"",
        ""Purpose"": ""Tracks the status and participants (borrower, lender, start time, status) of the loan for each collateral NFT tokenId.""
      },
      {
        ""Name"": ""nonces"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Stores nonces for users to prevent replay attacks on EIP-712 signatures.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes immutable state variables (bentoBox, masterContract)."",
        ""Parameters"": [
          ""IBentoBoxV1 bentoBox_""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""init"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract pair settings (collateral and asset tokens). Called once after deployment, likely by a factory."",
        ""Parameters"": [
          ""bytes calldata data""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateLoanParams"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the borrower (if LOAN_REQUESTED) or lender (if LOAN_OUTSTANDING) to update loan parameters, potentially making them more favorable."",
        ""Parameters"": [
          ""uint256 tokenId"",
          ""TokenLoanParams memory params""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_requestLoan"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic to handle collateral deposit and loan request setup."",
        ""Parameters"": [
          ""address collateralProvider"",
          ""uint256 tokenId"",
          ""TokenLoanParams memory params"",
          ""address to"",
          ""bool skim""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""requestLoan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Public function for a user to deposit collateral and request a loan."",
        ""Parameters"": [
          ""uint256 tokenId"",
          ""TokenLoanParams memory params"",
          ""address to"",
          ""bool skim""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""removeCollateral"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows borrower to cancel a requested loan or lender to claim collateral if loan is expired or undercollateralized based on oracle price."",
        ""Parameters"": [
          ""uint256 tokenId"",
          ""address to""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_lend"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to handle loan fulfillment, fund transfers via BentoBox, and loan status update."",
        ""Parameters"": [
          ""address lender"",
          ""uint256 tokenId"",
          ""TokenLoanParams memory accepted"",
          ""bool skim""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""lend"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Public function for a lender to fulfill an existing loan request."",
        ""Parameters"": [
          ""uint256 tokenId"",
          ""TokenLoanParams memory accepted"",
          ""bool skim""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""DOMAIN_SEPARATOR"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the EIP-712 domain separator for signature verification."",
        ""Parameters"": [],
        ""Returns"": [
          ""bytes32""
        ]
      },
      {
        ""Name"": ""requestAndBorrow"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a borrower to request a loan and immediately borrow using a pre-approved lender signature or LendingClub confirmation."",
        ""Parameters"": [
          ""uint256 tokenId"",
          ""address lender"",
          ""address recipient"",
          ""TokenLoanParams memory params"",
          ""bool skimCollateral"",
          ""bool anyTokenId"",
          ""SignatureParams memory signature""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""takeCollateralAndLend"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a lender to initiate a loan using a pre-approved borrower signature."",
        ""Parameters"": [
          ""uint256 tokenId"",
          ""address borrower"",
          ""TokenLoanParams memory params"",
          ""bool skimFunds"",
          ""SignatureParams memory signature""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""calculateInterest"",
        ""Visibility"": ""public pure"",
        ""Purpose"": ""Calculates the compounded interest accrued on a loan based on principal, time elapsed, and APR."",
        ""Parameters"": [
          ""uint256 principal"",
          ""uint64 t"",
          ""uint16 aprBPS""
        ],
        ""Returns"": [
          ""uint256 interest""
        ]
      },
      {
        ""Name"": ""repay"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the borrower (or anyone) to repay the loan principal plus accrued interest, transferring funds via BentoBox and returning the collateral."",
        ""Parameters"": [
          ""uint256 tokenId"",
          ""bool skim""
        ],
        ""Returns"": [
          ""uint256 amount""
        ]
      },
      {
        ""Name"": ""cook"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows batching multiple actions (e.g., deposit, lend, withdraw) into a single transaction."",
        ""Parameters"": [
          ""uint8[] calldata actions"",
          ""uint256[] calldata values"",
          ""bytes[] calldata datas""
        ],
        ""Returns"": [
          ""uint256 value1"",
          ""uint256 value2""
        ]
      },
      {
        ""Name"": ""withdrawFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers accumulated protocol fees (in BentoBox shares) to the `feeTo` address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setFeeTo"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Owner-only function to update the `feeTo` address."",
        ""Parameters"": [
          ""address newFeeTo""
        ],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IBentoBoxV1: For depositing, withdrawing, and transferring the loan `asset` token and managing shares."",
    ""IERC721 (Collateral): For transferring NFTs (`transferFrom`) and checking ownership (`ownerOf`)."",
    ""IERC20 (Asset): Used by BentoBox for identifying the token being lent/borrowed."",
    ""INFTOracle: For fetching NFT valuation (`get`) to check LTV constraints during lending and liquidation."",
    ""ILendingClub: Optional external contract to check if a lender `willLend` without requiring a signature."",
    ""Arbitrary Contracts via `cook` ACTION_CALL: Can call external contracts, excluding BentoBox, the collateral contract, and itself.""
  ],
  ""SpecialMechanisms"": [
    ""BentoBox Integration: Leverages BentoBox for efficient token management using shares, potentially saving gas on transfers."",
    ""EIP-712 Signatures: Uses off-chain signatures (`requestAndBorrow`, `takeCollateralAndLend`) for gasless approvals from lenders/borrowers."",
    ""Cook Pattern: Implements a batch execution function (`cook`) allowing multiple actions within the contract and BentoBox in one transaction."",
    ""Oracle Integration: Relies on an external `INFTOracle` to determine NFT value for LTV checks."",
    ""Compounding Interest: Calculates interest using a formula that appears to be an approximation of continuous compounding (Taylor series expansion)."",
    ""Skim Option: Allows using assets/collateral already held by the contract address in certain operations (`requestLoan`, `lend`, `repay`) to potentially save gas on transfers."",
    ""Loan State Machine: Uses `LOAN_INITIAL`, `LOAN_REQUESTED`, `LOAN_OUTSTANDING` states to manage loan lifecycle.""
  ],
  ""Questions"": [
    ""What is the precision and potential deviation of the `calculateInterest` formula compared to true continuous compounding, especially over long durations or high APRs?"",
    ""How is oracle manipulation or unavailability handled? Are there checks for price staleness or circuit breakers?"",
    ""The `removeCollateral` function allows liquidation based on oracle price vs. current debt (`amount`). Is there a grace period or buffer implemented, or is liquidation immediate upon the condition being met?"",
    ""What are the security implications of the `skim` parameter? Could it be misused if external callers manage to send assets/NFTs directly to the contract address outside the normal flow?"",
    ""How is the `masterContract` variable (set to `this`) specifically utilized by BentoBox in this context? Is it purely for authorization checks within BentoBox?"",
    ""The `requestAndBorrow` function has an `anyTokenId` flag for signatures. What is the intended use case for signing a lend approval valid for *any* token ID within this pair contract?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `cook` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `cook` function iterates through a series of actions, some of which involve external calls to other contracts. If a malicious contract is called, it could re-enter the `cook` function before the initial execution is complete, or re-enter other critical functions. This could lead to unexpected state changes, loss of funds, duplicated actions, or incorrect value calculations. Actions such as `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`, `ACTION_BENTO_WITHDRAW`, `ACTION_BENTO_TRANSFER`, `ACTION_BENTO_TRANSFER_MULTIPLE`, `ACTION_REQUEST_AND_BORROW`, and `ACTION_TAKE_COLLATERAL_AND_LEND` are particularly susceptible."",
      ""Impact"": ""Potential loss of funds, incorrect state updates, denial of service, or other unintended consequences due to reentrancy."",
      ""Location"": ""cook function and functions called by it (e.g., _call, _bentoDeposit, _bentoWithdraw), requestAndBorrow, takeCollateralAndLend""
    },
    {
      ""Issue"": ""Lack of Reentrancy Protection in `repay` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `repay` function transfers the asset to the lender and then transfers the collateral back to the borrower. A malicious borrower (implemented as a contract) could potentially implement a reentrancy hook in the `collateral.transferFrom` call and re-enter the `repay` function before it completes, potentially allowing them to repeatedly withdraw the collateral."",
      ""Impact"": ""An attacker can potentially drain the contract of collateral by re-entering the repay function."",
      ""Location"": ""repay function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `calculateInterest` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `calculateInterest` function performs a series of multiplications and divisions. While BoringMath is used for some operations, the intermediate calculations, particularly the repeated multiplication and division within the loop, could lead to integer overflows or underflows if `principal`, `t`, or `aprBPS` are maliciously large, or if `principal`, `x`, or `YEAR_BPS` are extremely large. This can lead to incorrect interest calculations. A check `if (interest >= 2**128)` is present, but intermediate values can overflow before this check."",
      ""Impact"": ""Incorrect interest calculation, potentially leading to loss of funds for either lender or borrower, and incorrect accounting for the protocol. In extreme cases, overflows might cause the interest to wrap around to a very small value, effectively reducing the cost of the loan to near zero."",
      ""Location"": ""calculateInterest function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `updateLoanParams` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `updateLoanParams` function checks if the new loan parameters are 'worse' for the lender (duration increases, valuation decreases, interest and LTV decrease). However, it doesn't prevent setting extremely bad or unrealistic values for duration, interest, valuation, or LTV, potentially leading to unexpected behavior, denial of service, or economic exploits. Additionally, there isn't a check to ensure the oracle is not a zero address."",
      ""Impact"": ""Malicious or erroneous input values could lead to incorrect loan calculations, denial-of-service, or economic exploits. For instance, a very large duration could cause issues with interest calculations and overflows in the calculateInterest function. Also a zero oracle address would cause the function to fail."",
      ""Location"": ""updateLoanParams function""
    },
    {
      ""Issue"": ""Oracle Manipulation Risk in Lending Decisions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The lending decisions rely on the price feed from the `INFTOracle`. A compromised or manipulated oracle can lead to incorrect valuations of the NFT collateral, leading to undercollateralized loans and losses for lenders or unfair liquidations. While there's a check for minimum price `rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation` in `_lend()`, subtle manipulation within the LTV boundary can still be exploited, and if the oracle does not protect against price staleness, then price manipulation can be even more effective."",
      ""Impact"": ""Lenders could approve loans with insufficient collateral, resulting in losses if the borrower defaults. Unfair liquidations due to manipulated prices."",
      ""Location"": ""lend function, requestAndBorrow function, takeCollateralAndLend function, INFTOracle interface, TokenLoanParams struct, _lend, removeCollateral""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `requestLoan`, `lend`, `requestAndBorrow` and `takeCollateralAndLend`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `requestLoan`, `lend`, `requestAndBorrow` and `takeCollateralAndLend` functions don't have measures to prevent front-running. An attacker could observe a transaction in the mempool and submit it before the intended recipient does, potentially manipulating loan parameters to their advantage. The nonce increment mitigates against replay attacks, but doesn't prevent front-running."",
      ""Impact"": ""A malicious user could manipulate the loan parameters to their advantage. Unauthorized lending or borrowing using someone else's signature, leading to potential loss of funds. Lender or borrower might get worse loan terms than intended."",
      ""Location"": ""requestLoan, lend, requestAndBorrow and takeCollateralAndLend functions""
    },
    {
      ""Issue"": ""Potential Signature replay in `requestAndBorrow` and `takeCollateralAndLend`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses a nonce to prevent replay attacks. However, the nonce is incremented *before* checking the validity of the signature. This means that if an invalid signature is provided, the nonce will still be incremented, effectively burning that nonce. An attacker could repeatedly submit invalid signatures to exhaust the nonces of a legitimate user, causing their legitimate signatures to be rejected."",
      ""Impact"": ""Legitimate user's transactions will be rejected after nonce exhaustion."",
      ""Location"": ""requestAndBorrow and takeCollateralAndLend functions""
    },
    {
      ""Issue"": ""Unbounded Loop in `cook` can cause out-of-gas errors"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `cook` function iterates through `actions`, `values`, and `datas` arrays. If the length of these arrays is large, it could lead to an out-of-gas error, especially if the individual actions are also gas-intensive. There's no explicit gas limit or mechanism to prevent this."",
      ""Impact"": ""Transactions may fail due to out-of-gas errors, hindering the functionality of the contract. The `cook` function may become unusable, preventing legitimate users from performing actions. Denial of Service."",
      ""Location"": ""cook function""
    },
    {
      ""Issue"": ""Potential denial of service due to unbounded gas cost in `transferMultiple`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `cook` function allows the use of `transferMultiple` action, which relies on `bentoBox.transferMultiple`. If a user provides a very large array of `tos` and `shares`, the gas cost of the transaction could exceed the block gas limit, leading to a denial of service. This is particularly concerning because anyone can call the `cook` function."",
      ""Impact"": ""The `cook` function may become unusable, preventing legitimate users from performing actions."",
      ""Location"": ""cook function, ACTION_BENTO_TRANSFER_MULTIPLE""
    },
    {
      ""Issue"": ""Lack of slippage control when interacting with BentoBox"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract interacts with BentoBox to deposit and withdraw assets. There's no slippage control implemented, which means the contract and users could be exposed to price fluctuations, especially with illiquid assets. A large deposit or withdraw could be frontrun, resulting in loss of funds."",
      ""Impact"": ""Loss of funds due to price slippage when interacting with BentoBox. Borrower or Lender could get slightly less amount of assets than expected."",
      ""Location"": ""_bentoDeposit, _bentoWithdraw functions, lend function, repay function, cook function for BentoBox actions.""
    },
    {
      ""Issue"": ""Approval of LendingClub can bypass signature check"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `requestAndBorrow` function, if the `signature` parameters are all zeroed out (`signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)`), the function will instead call `ILendingClub(lender).willLend(tokenId, params)`. If this `willLend` function returns true, then the loan is processed without checking any signature. This means that a malicious LendingClub contract can approve loans under any conditions, bypassing the intended signature authentication mechanism."",
      ""Impact"": ""A malicious LendingClub contract could be used to initiate fraudulent loans. If `willLend` is implemented incorrectly or maliciously, it can approve loans that should otherwise be rejected."",
      ""Location"": ""requestAndBorrow function""
    },
    {
      ""Issue"": ""Missing Access Control for Fee Withdrawal"",
      ""Severity"": ""Low"",
      ""Description"": ""While `setFeeTo` is protected by `onlyOwner`, the `withdrawFees` function only verifies that the sender is the `masterContract` (which is `this` or that `feeTo` address is the current value of `feeTo`). This means that anyone can call `cook` and perform an `ACTION_CALL` which will call `withdrawFees`. It should be protected by onlyOwner or have a more restrictive access control mechanism."",
      ""Impact"": ""Unauthorized withdrawal of fees. Potential disruption of fee distribution mechanism, front-running opportunities. While funds go to the intended recipient, unexpected timing of withdrawals might have undesired effects."",
      ""Location"": ""withdrawFees function""
    },
    {
      ""Issue"": ""Skimming risks and Inconsistent use of `skim` parameter"",
      ""Severity"": ""Low"",
      ""Description"": ""The `skim` parameter is used to bypass transferring from/to the sender and use the contract's balance instead, but the usage and requirements vary slightly in functions like `requestLoan`, `lend` and `repay`. If not properly managed, this could lead to unexpected behavior. Skimming without proper authorization is a security vulnerability."",
      ""Impact"": ""Possible theft of funds, unexpected state changes. Inconsistencies in token handling could lead to unexpected reverts or token losses."",
      ""Location"": ""Functions `requestLoan`, `_requestLoan`, `lend`, `_lend`, `repay`.""
    },
    {
      ""Issue"": ""Lack of Access Control on `feesEarnedShare`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `feesEarnedShare` variable is only modified internally by the `_lend` function. However, it's used in the `repay` and `_lend` functions' skim checks. While there is no direct way to manipulate it other than through normal contract execution, a deeper audit is required to ensure that side effects of other functions cannot influence `feesEarnedShare` in unintended ways, especially when used with skimming. Specifically the skim check in repay can revert a valid repay if feesEarnedShare is too high."",
      ""Impact"": ""Possible denial of service if skimming check in repay always fails."",
      ""Location"": ""feesEarnedShare variable, and functions _lend and repay""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `calculateInterest` function"",
      ""Severity"": ""Low"",
      ""Description"": ""While BoringMath library is used, the `calculateInterest` function performs a series of multiplications and divisions that could lead to integer overflow or underflow if the input values are very large, especially with higher COMPOUND_INTEREST_TERMS. The final check prevents the total interest from overflowing uint128 when casting in the repay function, however, intermediate calculations may cause unexpected behavior. Rounding errors due to integer division can also accumulate."",
      ""Impact"": ""Incorrect interest calculation, potentially leading to losses for either the lender or the borrower. Slightly inaccurate interest calculations that can result in small losses or gains for the lender or borrower."",
      ""Location"": ""calculateInterest function""
    },
    {
      ""Issue"": ""Inconsistent use of `transfer` and `transferFrom` for collateral transfer"",
      ""Severity"": ""Low"",
      ""Description"": ""The `requestLoan` function uses `collateral.transferFrom` to transfer the NFT to the contract, while the `removeCollateral` function also uses `collateral.transferFrom` to return the NFT. It's unclear when a user would need to first `approve` the contract to pull the token and also the skim boolean logic might need to be clarified."",
      ""Impact"": ""Unnecessary approval calls, confusing user logic."",
      ""Location"": ""requestLoan function, removeCollateral function""
    },
    {
      ""Issue"": ""Centralization Risk with `setFeeTo` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setFeeTo` function allows the owner to change the address where protocol fees are sent. While necessary for upgrades or administrative tasks, this introduces a centralization risk if the owner's account is compromised, potentially diverting funds to an attacker-controlled address."",
      ""Impact"": ""Potential loss of protocol revenue if the owner's account is compromised."",
      ""Location"": ""setFeeTo function""
    },
    {
      ""Issue"": ""Possible Denial of Service in `repay` Function due to `loan.startTime` comparison"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `repay` function, there is a `require` statement that compares `loan.startTime + loanParams.duration` with `block.timestamp`. If a loan is created close to the maximum `block.timestamp` value, adding `loanParams.duration` to it could cause an overflow, resulting in the check always passing and preventing repayment, effectively freezing the loan."",
      ""Impact"": ""Inability to repay the loan under certain timestamp conditions, leading to denial of service for both borrower and lender."",
      ""Location"": ""Function `repay`.""
    },
    {
      ""Issue"": ""Inconsistent use of `BPS` constant"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `BPS = 10_000` for basis points calculations. Care must be taken to ensure that all calculations involving BPS do not result in overflows, especially in compound operations. The reliance on BoringMath helps, but the overall approach relies on manual audit that BPS usage does not cause overflows."",
      ""Impact"": ""Potentially incorrect calculations if overflows occur, affecting loan terms, fees, or other financial calculations."",
      ""Location"": ""Throughout the contract, where `BPS` is used in calculations.""
    },
        {
      ""Issue"": ""Rounding errors in `calculateInterest` impact"",
      ""Severity"": ""Low"",
      ""Description"": ""The `calculateInterest` function uses integer division, which inherently introduces rounding errors. These rounding errors can accumulate and lead to inaccuracies in the calculated interest, especially over long loan durations or with small principal values. Note that with COMPOUND_INTEREST_TERMS set to 6, the impact of these compounding terms will be limited."",
      ""Impact"": ""Slightly inaccurate interest calculations that can result in small losses or gains for the lender or borrower."",
      ""Location"": ""Function `calculateInterest`""
    }
  ],
  ""IssueNumber"": 43,
  ""OutputList"": 20
}",205.6279981136322,3562.0,26.0,"### **Output**

---

**[H-01] Avoidance of Liquidation Via Malicious Oracle**

**Report Description**:  
Arbitrary oracles are permitted on construction of loans, and there is no check that the lender agrees to the used oracle. A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation. The lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed.

**Match in Response List**:  
Matches with the issue titled **""Oracle Manipulation Risk in Lending Decisions""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of oracle manipulation in lending decisions. It highlights the potential for incorrect valuations of NFT collateral due to a compromised or manipulated oracle, which aligns with the issue described in the report. The response also mentions the impact on lenders and unfair liquidations, which is consistent with the consequences outlined in the issue.

---

**[H-02] The return value `success` of the get function of the INFTOracle interface is not checked**

**Report Description**:  
The `get` function of the `INFTOracle` interface returns two values, but the `success` value is not checked when used in the `NFTPairWithOracle` contract. When `success` is false, the oracle may return stale data.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unchecked return values from the `INFTOracle` interface. This is a critical oversight, as failing to validate the `success` flag could lead to the use of stale or incorrect data, which is a significant security risk.

---

**[H-03] Critical Oracle Manipulation Risk by Lender**

**Report Description**:  
The intended use of the oracle is to protect the lender from a drop in the borrower's collateral value. However, in the `NFTPairWithOracle` contract, the lender could change the oracle once a loan is outstanding, allowing them to seize the collateral at the expense of the borrower if the actual value of the collateral has increased significantly. This is a critical risk because the borrower's asset could be lost to malicious lenders.

**Match in Response List**:  
Matches with the issue titled **""Oracle Manipulation Risk in Lending Decisions""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of oracle manipulation but does not specifically address the scenario where the lender changes the oracle after the loan is outstanding. The issue described in the report is more specific and highlights a critical vulnerability that is not fully covered in the response.

---

**[H-04] Lender is able to seize the collateral by changing the loan parameters**

**Report Description**:  
The `updateLoanParams()` function allows the lender to modify the parameters of an active loan in favor of the borrower. However, by setting the `ltvBPS` value to `0`, the lender is able to seize the collateral.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation in `updateLoanParams` function""**.

**Validation**:  
**Correct**. The response accurately identifies the lack of input validation in the `updateLoanParams` function, which could allow the lender to set unrealistic or malicious values. The response also mentions the potential for economic exploits, which aligns with the issue described in the report.

---

**[H-05] Mistake while checking LTV to lender accepted LTV**

**Report Description**:  
The `_lend()` function checks the accepted LTV (lender's LTV) against the borrower's asking LTV with the condition `params.ltvBPS >= accepted.ltvBPS`. This means the lender should be offering a lower LTV, which is the opposite of what is intended. This could strand the lender if they enter a lower LTV than the borrower's asking LTV.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect LTV checks in the `_lend()` function. This is a critical oversight, as it could lead to unfair loan terms and potential financial losses for the lender.

---

**[M-01] Reentrancy at `_requestLoan` allows requesting a loan without supplying collateral**

**Report Description**:  
The function `_requestLoan` makes an external call to the collateral contract before updating the `NFTPair` contract state, which could allow a borrower to request a loan without supplying collateral.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability in `cook` function""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of reentrancy in the `cook` function but does not specifically address the issue in the `_requestLoan` function. While both issues involve reentrancy, the specific vulnerability described in the report is not fully covered in the response.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] Avoidance of Liquidation Via Malicious Oracle**
- **[H-04] Lender is able to seize the collateral by changing the loan parameters**

**Partially Correct Matches**:

- **[H-03] Critical Oracle Manipulation Risk by Lender**
- **[M-01] Reentrancy at `_requestLoan` allows requesting a loan without supplying collateral**

**Missed Issues from Issue Report**:

- **[H-02] The return value `success` of the get function of the INFTOracle interface is not checked**
- **[H-05] Mistake while checking LTV to lender accepted LTV**

---","```
1. Oracle Manipulation Risk in Lending Decisions
2. Lack of Input Validation in `updateLoanParams` function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - ""Oracle Manipulation Risk in Lending Decisions"" appears at rank 5.
   - ""Lack of Input Validation in `updateLoanParams` function"" appears at rank 4.

2. **Calculate the precision at each rank**:
   - For rank 4: \( P@4 = \frac{1}{4} = 0.25 \)
   - For rank 5: \( P@5 = \frac{2}{5} = 0.4 \)

3. **Average the precision values**:
   - \( AP = \frac{0.25 + 0.4}{2} = 0.325 \)

**Average Precision (AP)**: 0.325"
