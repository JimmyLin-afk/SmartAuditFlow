nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
TwabRewards.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";

import ""./interfaces/ITwabRewards.sol"";

/**
 * @title PoolTogether V4 TwabRewards
 * @author PoolTogether Inc Team
 * @notice Contract to distribute rewards to depositors in a pool.
 * This contract supports the creation of several promotions that can run simultaneously.
 * In order to calculate user rewards, we use the TWAB (Time-Weighted Average Balance) from the Ticket contract.
 * This way, users simply need to hold their tickets to be eligible to claim rewards.
 * Rewards are calculated based on the average amount of tickets they hold during the epoch duration.
 */
contract TwabRewards is ITwabRewards {
    using SafeERC20 for IERC20;

    /* ============ Global Variables ============ */

    /// @notice Settings of each promotion.
    mapping(uint256 => Promotion) internal _promotions;

    /// @notice Latest recorded promotion id.
    /// @dev Starts at 0 and is incremented by 1 for each new promotion. So the first promotion will have id 1, the second 2, etc.
    uint256 internal _latestPromotionId;

    /// @notice Keeps track of claimed rewards per user.
    /// @dev _claimedEpochs[promotionId][user] => claimedEpochs
    /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.
    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;

    /* ============ Events ============ */

    /**
        @notice Emitted when a promotion is created.
        @param promotionId Id of the newly created promotion
    */
    event PromotionCreated(uint256 indexed promotionId);

    /**
        @notice Emitted when a promotion is cancelled.
        @param promotionId Id of the promotion being cancelled
        @param amount Amount of tokens transferred to the promotion creator
    */
    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);

    /**
        @notice Emitted when a promotion is extended.
        @param promotionId Id of the promotion being extended
        @param numberOfEpochs Number of epochs the promotion has been extended by
    */
    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);

    /**
        @notice Emitted when rewards have been claimed.
        @param promotionId Id of the promotion for which epoch rewards were claimed
        @param epochIds Ids of the epochs being claimed
        @param user Address of the user for which the rewards were claimed
        @param amount Amount of tokens transferred to the recipient address
    */
    event RewardsClaimed(
        uint256 indexed promotionId,
        uint256[] epochIds,
        address indexed user,
        uint256 amount
    );

    /* ============ Modifiers ============ */

    /// @dev Ensure that the caller is the creator of the promotion.
    /// @param _promotionId Id of the promotion to check
    modifier onlyPromotionCreator(uint256 _promotionId) {
        require(
            msg.sender == _getPromotion(_promotionId).creator,
            ""TwabRewards/only-promotion-creator""
        );
        _;
    }

    /* ============ External Functions ============ */

    /// @inheritdoc ITwabRewards
    function createPromotion(
        address _ticket,
        IERC20 _token,
        uint216 _tokensPerEpoch,
        uint32 _startTimestamp,
        uint32 _epochDuration,
        uint8 _numberOfEpochs
    ) external override returns (uint256) {
        _requireTicket(_ticket);

        uint256 _nextPromotionId = _latestPromotionId + 1;
        _latestPromotionId = _nextPromotionId;

        _promotions[_nextPromotionId] = Promotion(
            msg.sender,
            _ticket,
            _token,
            _tokensPerEpoch,
            _startTimestamp,
            _epochDuration,
            _numberOfEpochs
        );

        _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);

        emit PromotionCreated(_nextPromotionId);

        return _nextPromotionId;
    }

    /// @inheritdoc ITwabRewards
    function cancelPromotion(uint256 _promotionId, address _to)
        external
        override
        onlyPromotionCreator(_promotionId)
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);
        require(_to != address(0), ""TwabRewards/recipient-not-zero-address"");

        uint256 _remainingRewards = _getRemainingRewards(_promotion);

        delete _promotions[_promotionId];
        _promotion.token.safeTransfer(_to, _remainingRewards);

        emit PromotionCancelled(_promotionId, _remainingRewards);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)
        external
        override
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);

        uint8 _extendedNumberOfEpochs = _promotion.numberOfEpochs + _numberOfEpochs;
        _promotions[_promotionId].numberOfEpochs = _extendedNumberOfEpochs;

        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;
        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);

        emit PromotionExtended(_promotionId, _numberOfEpochs);

        return true;
    }

    /// @inheritdoc ITwabRewards
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external override returns (uint256) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _rewardsAmount;
        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];

        for (uint256 index = 0; index < _epochIds.length; index++) {
            uint256 _epochId = _epochIds[index];

            require(
                !_isClaimedEpoch(_userClaimedEpochs, _epochId),
                ""TwabRewards/rewards-already-claimed""
            );

            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);
            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);
        }

        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;

        _promotion.token.safeTransfer(_user, _rewardsAmount);

        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);

        return _rewardsAmount;
    }

    /// @inheritdoc ITwabRewards
    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {
        return _getPromotion(_promotionId);
    }

    /// @inheritdoc ITwabRewards
    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {
        return _getCurrentEpochId(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {
        return _getRemainingRewards(_getPromotion(_promotionId));
    }

    /// @inheritdoc ITwabRewards
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external view override returns (uint256[] memory) {
        Promotion memory _promotion = _getPromotion(_promotionId);
        uint256[] memory _rewardsAmount = new uint256[](_epochIds.length);

        for (uint256 index = 0; index < _epochIds.length; index++) {
            _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);
        }

        return _rewardsAmount;
    }

    /* ============ Internal Functions ============ */

    /**
    @notice Determine if address passed is actually a ticket.
    @param _ticket Address to check
   */
    function _requireTicket(address _ticket) internal view {
        require(_ticket != address(0), ""TwabRewards/ticket-not-zero-address"");

        (bool succeeded, bytes memory data) = address(_ticket).staticcall(
            abi.encodePacked(ITicket(_ticket).controller.selector)
        );

        address controllerAddress;

        if (data.length > 0) {
            controllerAddress = abi.decode(data, (address));
        }

        require(succeeded && controllerAddress != address(0), ""TwabRewards/invalid-ticket"");
    }

    /**
        @notice Determine if a promotion is active.
        @param _promotion Promotion to check
    */
    function _requirePromotionActive(Promotion memory _promotion) internal view {
        uint256 _promotionEndTimestamp = _promotion.startTimestamp +
            (_promotion.epochDuration * _promotion.numberOfEpochs);

        require(
            _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp,
            ""TwabRewards/promotion-not-active""
        );
    }

    /**
        @notice Get settings for a specific promotion.
        @dev Will revert if the promotion does not exist.
        @param _promotionId Promotion id to get settings for
        @return Promotion settings
     */
    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {
        return _promotions[_promotionId];
    }

    /**
        @notice Get the current epoch id of a promotion.
        @dev Epoch ids and their boolean values are tightly packed and stored in a uint256, so epoch id starts at 0.
        @param _promotion Promotion to get current epoch for
        @return Epoch id
     */
    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
        // elapsedTimestamp / epochDurationTimestamp
        return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
    }

    /**
        @notice Get reward amount for a specific user.
        @dev Rewards can only be claimed once the epoch is over.
        @param _user User to get reward amount for
        @param _promotion Promotion from which the epoch is
        @param _epochId Epoch id to get reward amount for
        @return Reward amount
     */
    function _calculateRewardAmount(
        address _user,
        Promotion memory _promotion,
        uint256 _epochId
    ) internal view returns (uint256) {
        uint256 _epochDuration = _promotion.epochDuration;
        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);
        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;

        require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over"");

        ITicket _ticket = ITicket(_promotion.ticket);

        uint256 _averageBalance = _ticket.getAverageBalanceBetween(
            _user,
            uint64(_epochStartTimestamp),
            uint64(_epochEndTimestamp)
        );

        uint64[] memory _epochStartTimestamps = new uint64[](1);
        _epochStartTimestamps[0] = uint64(_epochStartTimestamp);

        uint64[] memory _epochEndTimestamps = new uint64[](1);
        _epochEndTimestamps[0] = uint64(_epochEndTimestamp);

        uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(
            _epochStartTimestamps,
            _epochEndTimestamps
        );

        if (_averageTotalSupplies[0] > 0) {
            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];
        }

        return 0;
    }

    /**
        @notice Get the total amount of tokens left to be rewarded.
        @param _promotion Promotion to get the total amount of tokens left to be rewarded for
        @return Amount of tokens left to be rewarded
     */
    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
        // _tokensPerEpoch * _numberOfEpochsLeft
        return
            _promotion.tokensPerEpoch *
            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
    }

    /**
        @notice Set boolean value for a specific epoch.
        @dev Bits are stored in a uint256 from right to left.
        Let's take the example of the following 8 bits word. 0110 0011
        To set the boolean value to 1 for the epoch id 2, we need to create a mask by shifting 1 to the left by 2 bits.
        We get: 0000 0001 << 2 = 0000 0100
        We then OR the mask with the word to set the value.
        We get: 0110 0011 | 0000 0100 = 0110 0111
        @param _userClaimedEpochs Tightly packed epoch ids with their boolean values
        @param _epochId Id of the epoch to set the boolean for
        @return Tightly packed epoch ids with the newly boolean value set
    */
    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (uint256)
    {
        return _userClaimedEpochs | (uint256(1) << _epochId);
    }

    /**
        @notice Check if rewards of an epoch for a given promotion have already been claimed by the user.
        @dev Bits are stored in a uint256 from right to left.
        Let's take the example of the following 8 bits word. 0110 0111
        To retrieve the boolean value for the epoch id 2, we need to shift the word to the right by 2 bits.
        We get: 0110 0111 >> 2 = 0001 1001
        We then get the value of the last bit by masking with 1.
        We get: 0001 1001 & 0000 0001 = 0000 0001 = 1
        We then return the boolean value true since the last bit is 1.
        @param _userClaimedEpochs Record of epochs already claimed by the user
        @param _epochId Epoch id to check
        @return true if the rewards have already been claimed for the given epoch, false otherwise
     */
    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (bool)
    {
        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;
    }
}",3228,378,"[H-01] createPromotion() Lack of input validation for _epochDuration can potentially freeze promotion creator's funds
In the current implementation of `createPromotion()`, `_epochDuration` is allowed to be 0.
However, when _epochDuration = 0, it will be impossible for users to claim the rewards, and the promotion creator won't be able to cancel it.

[H-02] Backdated _startTimestamp can lead to loss of funds

Function `createPromotion()`
This can lead to loss of funds as there is no recovery function of funds stuck like this
 [H-03] Continue claiming reqrds after numberOfEpochs are over

When claiming rewards via claimRewards(), the function `_calculateRewardAmount()` is called. The function \_calculateRewardAmount() has a check to make sure the epoch is over
  require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over""); 

However neither functions check if the \_epochId is within the range of the reward epochs. Ergo it is possible to continue claiming rewards after the reward period is over. This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.
The proof of concept contains a simplified version of the contract, and shows how this can be done. When run in remix you get the following output, while there is only 1 epoch. console.log:  Claiming for epoch 1 1  Claiming for epoch 2 1  Claiming for epoch 3 1  Claiming for epoch 4 1  Claiming for epoch 5 1
  [H-04] cancelPromotion is too rigorous

When you cancel a promotion with `cancelPromotion()` then the promotion is complete deleted. This means no-one can claim any rewards anymore, because \_promotions\[\_promotionId] no longer exists.
It also means all the unclaimed tokens (of the previous epochs) will stay locked in the contract.
  [H-05] Malicious tickets can lead to the loss of all tokens
 function `createPromotion()`
It allows an attacker to retrieve all the tokens of each promotions.
Analysis

Anyone can create a new promotion using createPromotion(). An attacker can create a new malicious promotion with the following parameters:
the address of a malicious ticket smart contract
the token address from the targeted promotion(s)
optionally, _numberOfEpochs equal to 0 to create this promotion for free
The only verification made on the ticket address given by _requireTicket() is that the smart contract must implement the ITicket interface.
  [H-06] Rewards can be claimed multiple times

Function `claimRewards() `
An attacker can claim its reward 256 * epochDuration seconds after the timestamp at which the promotion started. The vulnerability allows him to claim a reward several times to retrieve all the tokens associated to the promotion.
Analysis

claimRewards() claim rewards for a given promotion and epoch. In order to prevent a user from claiming a reward multiple times, the mapping _claimedEpochs keeps track of claimed rewards per user:
  [H-07] Contract does not work with fee-on transfer tokens

Function `_calculateRewardAmount()`
``` promotion.tokensPerEpoch * promotion.numberOfEpochs ``` 
There exist ERC20 tokens that charge a fee for every transfer.
This kind of token does not work correctly with the TwabRewards contract as the rewards calculation for an user is based on promotion.tokensPerEpoch (see line 320).
However, the actual amount of tokens the contract holds could be less than promotion.tokensPerEpoch * promotion.numberOfEpochs leading to not claimable rewards for users claiming later than others.
  [M-01] cancelPromotion() Unable to cancel unstarted promotions

Submitted by WatchPug, also found by kenzo, and certora
For unstarted promotions, cancelPromotion() will revert at block.timestamp - _promotion.startTimestamp in _getCurrentEpochId().
Call stack: cancelPromotion() -> _getRemainingRewards() -> _getCurrentEpochId().
https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L331-L336
function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
    // _tokensPerEpoch * _numberOfEpochsLeft
    return
        _promotion.tokensPerEpoch *
        (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
}

https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279
function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
    // elapsedTimestamp / epochDurationTimestamp
    return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
}
  [M-02] `getRewardsAmount` doesn't check epochs haven't been claimed

In ITwabRewards.sol, it is claimed that getRewardsAmount should account for epochs that have already been claimed, and not include these epochs in the total amount (indeed, there is a line that says @dev Will be 0 if user has already claimed rewards for the epoch.)
However, no such check is done in the implementation of getRewardsAmount. This means that users will be shown rewardAmounts that are higher than they should be, and users will be confused when they are transferred fewer tokens than they are told they will. This would cause confusion, and people may begin to mistrust the contract since they think they are being transferred fewer tokens than they are owed.
  [M-03] Dust Token Balances Cannot Be Claimed By An `admin` Account

Users who have a small claim on rewards for various promotions, may not feasibly be able to claim these rewards as gas costs could outweigh the sum they receive in return. Hence, it is likely that a dust balance accrues overtime for tokens allocated for various promotions. Additionally, the _calculateRewardAmount calculation may result in truncated results, leading to further accrual of a dust balance. Therefore, it is useful that these funds do not go to waste
  [M-04] Unsafe uint64 casting may overflow

The `_calculateRewardAmount` function casts epoch timestamps from uint256 to uint64 and these may overflow. The epochStartTimestamp value is a function of the user-supplied \_epochId value, which could be extremely large (up to 2**255 – 1). While Solidity 0.8.x checks for overflows on arithmetic operations, it does not do so for casting – the OpenZeppelin SafeCast library offers this. The overflow condition could cause \_epochStartTimestamp > \_epochEndTimestamp, which the Ticket.sol getAverageBalanceBetween may not be expected to handle. The \_epochStartTimestamp could overflow to have a value before the actual start of the promotion, also impacting the rewards calculation.
  [M-05] Missing Check When Transferring Tokens Out For A Given Promotion

Submitted by leastwood
Impact

The claimRewards function is called upon by ticket holders who parse a set of _epochIds they wish to claim rewards on. An internal call is made to _calculateRewardAmount to calculate the correct reward amount owed to the user. Subsequently, the _updateClaimedEpoch function will set the epoch bit of the tracked _claimedEpochs mapping, ensuring an epochId cannot be claimed twice for a given promotion.
However, there may be inaccuracies in the _calculateRewardAmount function, which results in more tokens being sent out than allocated by a promotion creator. This severely impacts the ability for users to claim their owed tokens on other promotions.
",12,,"pragma solidity 0.8.6;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"";

import ""./interfaces/ITwabRewards.sol"";


contract TwabRewards is ITwabRewards {
    using SafeERC20 for IERC20;

    

    
    mapping(uint256 => Promotion) internal _promotions;

    
    
    uint256 internal _latestPromotionId;

    
    
    
    mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;

    

    
    event PromotionCreated(uint256 indexed promotionId);

    
    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);

    
    event PromotionExtended(uint256 indexed promotionId, uint256 numberOfEpochs);

    
    event RewardsClaimed(
        uint256 indexed promotionId,
        uint256[] epochIds,
        address indexed user,
        uint256 amount
    );

    

    
    
    modifier onlyPromotionCreator(uint256 _promotionId) {
        require(
            msg.sender == _getPromotion(_promotionId).creator,
            ""TwabRewards/only-promotion-creator""
        );
        _;
    }

    

    
    function createPromotion(
        address _ticket,
        IERC20 _token,
        uint216 _tokensPerEpoch,
        uint32 _startTimestamp,
        uint32 _epochDuration,
        uint8 _numberOfEpochs
    ) external override returns (uint256) {
        _requireTicket(_ticket);

        uint256 _nextPromotionId = _latestPromotionId + 1;
        _latestPromotionId = _nextPromotionId;

        _promotions[_nextPromotionId] = Promotion(
            msg.sender,
            _ticket,
            _token,
            _tokensPerEpoch,
            _startTimestamp,
            _epochDuration,
            _numberOfEpochs
        );

        _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);

        emit PromotionCreated(_nextPromotionId);

        return _nextPromotionId;
    }

    
    function cancelPromotion(uint256 _promotionId, address _to)
        external
        override
        onlyPromotionCreator(_promotionId)
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);
        require(_to != address(0), ""TwabRewards/recipient-not-zero-address"");

        uint256 _remainingRewards = _getRemainingRewards(_promotion);

        delete _promotions[_promotionId];
        _promotion.token.safeTransfer(_to, _remainingRewards);

        emit PromotionCancelled(_promotionId, _remainingRewards);

        return true;
    }

    
    function extendPromotion(uint256 _promotionId, uint8 _numberOfEpochs)
        external
        override
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);

        uint8 _extendedNumberOfEpochs = _promotion.numberOfEpochs + _numberOfEpochs;
        _promotions[_promotionId].numberOfEpochs = _extendedNumberOfEpochs;

        uint256 _amount = _numberOfEpochs * _promotion.tokensPerEpoch;
        _promotion.token.safeTransferFrom(msg.sender, address(this), _amount);

        emit PromotionExtended(_promotionId, _numberOfEpochs);

        return true;
    }

    
    function claimRewards(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external override returns (uint256) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _rewardsAmount;
        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];

        for (uint256 index = 0; index < _epochIds.length; index++) {
            uint256 _epochId = _epochIds[index];

            require(
                !_isClaimedEpoch(_userClaimedEpochs, _epochId),
                ""TwabRewards/rewards-already-claimed""
            );

            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);
            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);
        }

        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;

        _promotion.token.safeTransfer(_user, _rewardsAmount);

        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);

        return _rewardsAmount;
    }

    
    function getPromotion(uint256 _promotionId) external view override returns (Promotion memory) {
        return _getPromotion(_promotionId);
    }

    
    function getCurrentEpochId(uint256 _promotionId) external view override returns (uint256) {
        return _getCurrentEpochId(_getPromotion(_promotionId));
    }

    
    function getRemainingRewards(uint256 _promotionId) external view override returns (uint256) {
        return _getRemainingRewards(_getPromotion(_promotionId));
    }

    
    function getRewardsAmount(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external view override returns (uint256[] memory) {
        Promotion memory _promotion = _getPromotion(_promotionId);
        uint256[] memory _rewardsAmount = new uint256[](_epochIds.length);

        for (uint256 index = 0; index < _epochIds.length; index++) {
            _rewardsAmount[index] = _calculateRewardAmount(_user, _promotion, _epochIds[index]);
        }

        return _rewardsAmount;
    }

    

    
    function _requireTicket(address _ticket) internal view {
        require(_ticket != address(0), ""TwabRewards/ticket-not-zero-address"");

        (bool succeeded, bytes memory data) = address(_ticket).staticcall(
            abi.encodePacked(ITicket(_ticket).controller.selector)
        );

        address controllerAddress;

        if (data.length > 0) {
            controllerAddress = abi.decode(data, (address));
        }

        require(succeeded && controllerAddress != address(0), ""TwabRewards/invalid-ticket"");
    }

    
    function _requirePromotionActive(Promotion memory _promotion) internal view {
        uint256 _promotionEndTimestamp = _promotion.startTimestamp +
            (_promotion.epochDuration * _promotion.numberOfEpochs);

        require(
            _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp,
            ""TwabRewards/promotion-not-active""
        );
    }

    
    function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {
        return _promotions[_promotionId];
    }

    
    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
        
        return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
    }

    
    function _calculateRewardAmount(
        address _user,
        Promotion memory _promotion,
        uint256 _epochId
    ) internal view returns (uint256) {
        uint256 _epochDuration = _promotion.epochDuration;
        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);
        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;

        require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over"");

        ITicket _ticket = ITicket(_promotion.ticket);

        uint256 _averageBalance = _ticket.getAverageBalanceBetween(
            _user,
            uint64(_epochStartTimestamp),
            uint64(_epochEndTimestamp)
        );

        uint64[] memory _epochStartTimestamps = new uint64[](1);
        _epochStartTimestamps[0] = uint64(_epochStartTimestamp);

        uint64[] memory _epochEndTimestamps = new uint64[](1);
        _epochEndTimestamps[0] = uint64(_epochEndTimestamp);

        uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(
            _epochStartTimestamps,
            _epochEndTimestamps
        );

        if (_averageTotalSupplies[0] > 0) {
            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];
        }

        return 0;
    }

    
    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
        
        return
            _promotion.tokensPerEpoch *
            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
    }

    
    function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (uint256)
    {
        return _userClaimedEpochs | (uint256(1) << _epochId);
    }

    
    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId)
        internal
        pure
        returns (bool)
    {
        return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;
    }
}",1979,7,5,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Verify the `onlyPromotionCreator` modifier correctly restricts access to sensitive functions like `cancelPromotion` to the intended promotion creator."",
        ""Analyze the potential impact of an incorrect `msg.sender` value on promotion creation and subsequent operations."",
        ""Ensure that the intended access control is enforced for all functions that modify the state of the contract, including those interacting with external contracts.""
      ]
    },
    {
      ""Area"": ""Reward Calculation and Distribution"",
      ""Tasks"": [
        ""Examine the `_calculateRewardAmount` function for potential rounding errors or integer division issues that could lead to inaccurate reward distribution."",
        ""Analyze the `getAverageBalanceBetween` and `getAverageTotalSuppliesBetween` calls to the ITicket contract and assess their reliability and potential vulnerabilities."",
        ""Verify that the reward calculation logic accurately reflects the intended TWAB mechanism and that the total rewards distributed do not exceed the allocated amount."",
        ""Investigate potential vulnerabilities in the `ITicket` contract related to `getAverageBalanceBetween` and `getAverageTotalSuppliesBetween` that could be exploited to inflate rewards. Consider scenarios where these functions might return unexpected or manipulated values."",
        ""Confirm that the _getRemainingRewards calculation cannot underflow.""
      ]
    },
    {
      ""Area"": ""Epoch Management and Claiming"",
      ""Tasks"": [
        ""Review the `getCurrentEpochId` function to ensure it correctly calculates the current epoch ID based on the current timestamp and promotion parameters."",
        ""Analyze the `claimRewards` function to prevent double-spending or other vulnerabilities related to epoch claiming. Pay close attention to the bitmasking logic used to track claimed epochs."",
        ""Assess the scalability of the `_claimedEpochs` mapping and identify potential gas limitations when claiming rewards for a large number of epochs or users. Consider alternative storage mechanisms or pagination strategies."",
        ""Determine the maximum number of epochIds that can be processed in a single `claimRewards` transaction without exceeding gas limits. Recommend implementing pagination or batch claiming if necessary.""
      ]
    },
    {
      ""Area"": ""Promotion Management and Lifecycle"",
      ""Tasks"": [
        ""Examine the `createPromotion` function for potential vulnerabilities related to invalid or malicious promotion parameters. Ensure that appropriate checks and validations are in place."",
        ""Analyze the `cancelPromotion` function to verify that it correctly handles the remaining rewards and that the promotion state is properly updated."",
        ""Review the `extendPromotion` function to prevent potential overflows in the `numberOfEpochs` variable and ensure that the total number of epochs does not exceed reasonable limits."",
        ""Assess the potential impact of extending a promotion with a large number of epochs on storage costs and gas consumption."",
        ""Investigate the potential for front-running in the `createPromotion` function. Can a malicious actor create a promotion with unfavorable parameters before the intended creator can do so?""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that the contract correctly interacts with the `IERC20` and `ITicket` interfaces and that all external calls are properly handled."",
        ""Assess the risks associated with calling external contracts, such as reentrancy attacks, and implement appropriate countermeasures."",
        ""Analyze the `_requireTicket` function to ensure that it properly validates the ticket address and that the `controller` function returns a valid address."",
        ""Investigate the scenario where _requireTicket's `staticcall` succeeds but returns a zero address, and outline the potential consequences.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify potential areas for gas optimization, such as reducing storage usage, minimizing external calls, and optimizing loop structures."",
        ""Evaluate the gas costs associated with different function calls and suggest improvements to reduce gas consumption."",
        ""Consider using more efficient data structures or algorithms to improve the performance of computationally intensive operations.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Check for integer overflows/underflows in arithmetic operations, especially in reward calculations and epoch management."",
        ""Analyze for potential reentrancy vulnerabilities in functions that interact with external contracts (IERC20, ITicket)."",
        ""Ensure proper error handling and prevent denial-of-service (DoS) attacks, especially in loops and external calls."",
        ""Assess the risk of front-running in the `createPromotion` function and implement necessary protections.""
      ]
    },
    {
      ""Area"": ""Input Validation"",
      ""Tasks"": [
        ""Validate all input parameters to functions to prevent unexpected behavior or vulnerabilities. This includes checking for zero addresses, valid ranges, and appropriate data types."",
        ""Specifically, check the values of _startTimestamp, _epochDuration and _numberOfEpochs in the `createPromotion` and `extendPromotion` functions."",
        ""Ensure the recipient `_to` in `cancelPromotion` is not the contract address to prevent accidental locking of funds.""
      ]
    },
    {
      ""Area"": ""Unintended Token Transfer"",
      ""Tasks"": [
          ""Check the potential for tokens to be unintentionally transferred or locked due to logical errors.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code implements a time-weighted average balance (TWAB) rewards system. Users holding a specific token (ticket) receive rewards (another ERC20 token) based on their average balance over defined epochs. Promotions are created by a creator, specifying the ticket, reward token, rewards per epoch, start timestamp, epoch duration, and the number of epochs. Users can claim rewards for multiple epochs at once. The contract uses bit manipulation to track claimed epochs for each user and promotion."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""TwabRewards"",
    ""Purpose"": ""Distribute ERC20 rewards to users based on their Time-Weighted Average Balance (TWAB) of a ticket token across epochs."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""ITwabRewards""],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""@pooltogether/v4-core/contracts/interfaces/ITicket.sol"",
        ""./interfaces/ITwabRewards.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""_promotions"",
        ""Type"": ""mapping(uint256 => Promotion)"",
        ""Purpose"": ""Stores promotion details, indexed by promotion ID.""
      },
      {
        ""Name"": ""_latestPromotionId"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Keeps track of the most recently created promotion ID.""
      },
      {
        ""Name"": ""_claimedEpochs"",
        ""Type"": ""mapping(uint256 => mapping(address => uint256))"",
        ""Purpose"": ""Tracks which epochs have been claimed by which user for each promotion.  Uses bitmasking.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""createPromotion"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new rewards promotion.  Transfers reward tokens to the contract."",
        ""Parameters"": [
          ""_ticket (address)"",
          ""_token (IERC20)"",
          ""_tokensPerEpoch (uint216)"",
          ""_startTimestamp (uint32)"",
          ""_epochDuration (uint32)"",
          ""_numberOfEpochs (uint8)""
        ],
        ""Returns"": [""uint256 (promotionId)""]
      },
      {
        ""Name"": ""cancelPromotion"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Cancels an active promotion and returns any remaining rewards to the specified address."",
        ""Parameters"": [""_promotionId (uint256)"", ""_to (address)""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""extendPromotion"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Extends an existing promotion by adding more epochs. Transfers reward tokens to the contract."",
        ""Parameters"": [""_promotionId (uint256)"", ""_numberOfEpochs (uint8)""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""claimRewards"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to claim rewards for specified epochs within a promotion."",
        ""Parameters"": [
          ""_user (address)"",
          ""_promotionId (uint256)"",
          ""_epochIds (uint256[])""
        ],
        ""Returns"": [""uint256 (amount)""]
      },
      {
        ""Name"": ""getPromotion"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns promotion details."",
        ""Parameters"": [""_promotionId (uint256)""],
        ""Returns"": [""Promotion memory""]
      },
      {
        ""Name"": ""getCurrentEpochId"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the current epoch ID for a promotion."",
        ""Parameters"": [""_promotionId (uint256)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getRemainingRewards"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the number of remaining rewards for a promotion."",
        ""Parameters"": [""_promotionId (uint256)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getRewardsAmount"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates the reward amount for a user for specific epochs within a promotion."",
        ""Parameters"": [
          ""_user (address)"",
          ""_promotionId (uint256)"",
          ""_epochIds (uint256[])""
        ],
        ""Returns"": [""uint256[] memory""]
      },
      {
        ""Name"": ""onlyPromotionCreator"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the promotion creator."",
        ""Parameters"": [""_promotionId (uint256)""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20: Used for transferring reward tokens and querying token balances."",
    ""ITicket: Used for querying the average balance and total supply of the ticket token over specific time periods."",
    ""SafeERC20: Used for safe ERC20 token transfers.""
  ],
  ""SpecialMechanisms"": [
    ""Time-Weighted Average Balance (TWAB): The contract calculates rewards based on the TWAB of a ticket token."",
    ""Epoch Management: Rewards are distributed based on discrete time periods called epochs."",
    ""Bitmasking: The `_claimedEpochs` mapping uses bitmasking to efficiently track claimed epochs for each user and promotion."",
    ""SafeERC20: Using SafeERC20 library from OpenZeppelin to prevent common ERC20 transfer issues.""
  ],
  ""Questions"": [
    ""The `_requireTicket` function checks the `controller` function on the ticket. Why is the controller's address checked against zero after the staticcall check?  Is it possible for the `staticcall` to succeed but return a zero address? If so, what are the security implications?"",
    ""In `_getRemainingRewards`, the calculation `_promotion.numberOfEpochs - _getCurrentEpochId(_promotion)` could underflow if `_getCurrentEpochId` returns a value greater than `_promotion.numberOfEpochs`. This does not seem possible given the checks in `_requirePromotionActive` but should be confirmed or add a check to avoid underflow."",
    ""Is there a mechanism to handle edge cases or rounding errors in the reward calculation? Could these errors accumulate to a significant amount over time? Should tests be added to prove no rewards are lost or gained by the contract?"",
    ""Could a malicious user manipulate their average balance within an epoch to unfairly claim more rewards? Are there any measures in place to prevent this?"",
    ""The `extendPromotion` function allows a promotion to be extended. Is there a limit to the number of times a promotion can be extended, or the total number of epochs allowed? Without a limit, this could be a DOS vector as `_promotion.numberOfEpochs` could become very large. Is there a cap on `_extendedNumberOfEpochs`?"",
    ""The _claimedEpochs mapping grows linearly with the number of epochs and users who claim. Is there a strategy in place to manage storage costs and prevent excessive gas usage when claiming rewards for a large number of epochs or users?"",
    ""The claimRewards function iterates through epochIds. If a large number of epochIds are provided, this could exceed gas limits. Should pagination or batch claiming be considered?"",
    ""The type of tokensPerEpoch is uint216. Why was this type chosen, given it isn't a standard uint size, and Solidity typically operates on 32 byte words at a time?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in `claimRewards`"",
      ""Severity"": ""High"",
      ""Description"": ""The `claimRewards` function transfers tokens to the user using `_promotion.token.safeTransfer(_user, _rewardsAmount)` after calculating the rewards and updating the `_claimedEpochs` mapping. A malicious ERC20 token could trigger a callback to the `claimRewards` function before the state is fully updated, potentially allowing the user to claim rewards multiple times for the same epochs, draining the contract's funds. OpenZeppelin's `SafeERC20` library mitigates some reentrancy issues, but may not prevent all types of reentrancy or malicious ERC20 behavior."",
      ""Impact"": ""A malicious user could repeatedly claim rewards for the same epochs, potentially draining the contract's funds and leading to financial loss."",
      ""Location"": ""TwabRewards.sol:claimRewards""
    },
    {
      ""Issue"": ""Denial of Service (DoS) Vulnerability in `claimRewards` due to Unbounded Loop"",
      ""Severity"": ""High"",
      ""Description"": ""The `claimRewards` function iterates through the `_epochIds` array without any limits on its size. An attacker can provide a very large `_epochIds` array, causing the loop to consume excessive gas, potentially exceeding the block gas limit and preventing legitimate users from claiming their rewards. The gas cost increases linearly with the number of epochs to claim, making it economically unfeasible for legitimate users to claim rewards when the number of epochs is large."",
      ""Impact"": ""Inability for users to claim rewards due to transaction failures caused by high gas consumption, effectively causing a denial-of-service attack on the `claimRewards` function."",
      ""Location"": ""TwabRewards.sol:88 `for (uint256 index = 0; index < _epochIds.length; index++) { ... }`""
    },
    {
      ""Issue"": ""Lack of Access Control on `extendPromotion`"",
      ""Severity"": ""High"",
      ""Description"": ""The `extendPromotion` function lacks access control, allowing anyone to extend a promotion and add more tokens to it. This is unexpected and could lead to unintended consequences if a malicious user can extend a promotion and transfer funds that do not belong to them into the contract, draining the token balance."",
      ""Impact"": ""Unauthorized extension of promotions, leading to potential loss of funds from unintended users, denial of service, and fund draining."",
      ""Location"": ""TwabRewards.sol:extendPromotion""
    },
    {
      ""Issue"": ""Lack of check for sufficient allowance before `safeTransferFrom` in `createPromotion` and `extendPromotion`"",
      ""Severity"": ""High"",
      ""Description"": ""The `createPromotion` and `extendPromotion` functions use `safeTransferFrom` to transfer tokens from the promotion creator to the contract, but they do not check if the promotion creator has approved the contract to spend the required amount of tokens. If the allowance is insufficient, the `safeTransferFrom` function will revert, causing the transaction to fail, and the promotion will not be created or extended."",
      ""Impact"": ""Promotion creation or extension fails if the promotion creator has not approved the contract to spend the required amount of tokens."",
      ""Location"": ""Functions `createPromotion` and `extendPromotion`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `_getCurrentEpochId`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `_getCurrentEpochId` calculates the current epoch ID using `(block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration`. If `block.timestamp` is less than `_promotion.startTimestamp`, the subtraction will result in underflow, wrapping around to a very large number. This can lead to incorrect epoch calculations, incorrect reward distribution, early/late termination of promotions, and potential denial of service. Integer overflow could happen with a small epoch duration and large timestamp differences."",
      ""Impact"": ""Incorrect epoch ID calculation, potentially leading to incorrect reward distribution or denial of service, early/late termination of promotions."",
      ""Location"": ""TwabRewards.sol:_getCurrentEpochId""
    },
    {
      ""Issue"": ""Unchecked Arithmetic leading to potential overflow in `extendPromotion`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The line `uint8 _extendedNumberOfEpochs = _promotion.numberOfEpochs + _numberOfEpochs;` in the `extendPromotion` function is vulnerable to integer overflow. Since `_promotion.numberOfEpochs` and `_numberOfEpochs` are of type `uint8`, their sum can exceed the maximum value representable by a `uint8` (255). This would cause the value to wrap around, resulting in a significantly smaller `_extendedNumberOfEpochs` than intended. This can lead to incorrect promotion duration and reward calculation."",
      ""Impact"": ""Incorrect promotion duration and reward calculation, leading to potential loss of funds or unexpected behavior."",
      ""Location"": ""TwabRewards.sol:extendPromotion""
    },
    {
      ""Issue"": ""Potential Division by Zero in `_calculateRewardAmount`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_calculateRewardAmount` function, the reward calculation involves dividing by `_averageTotalSupplies[0]`. If `_averageTotalSupplies[0]` is equal to 0, a division by zero will occur, causing the transaction to revert, even with the `_averageTotalSupplies[0] > 0` check. This can happen if there were no ticket holders during the epoch or if the ITicket contract returns 0 for the total supply."",
      ""Impact"": ""Transaction reverts when calculating reward amount if the average total supply is zero, causing denial of service. Users will not be able to claim rewards for that epoch."",
      ""Location"": ""TwabRewards.sol:_calculateRewardAmount""
    },
    {
      ""Issue"": ""Insufficient Validation of Input Parameters in `createPromotion`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createPromotion` function lacks comprehensive checks on parameters. Specifically, there's no validation to ensure that `_tokensPerEpoch`, `_startTimestamp`, `_epochDuration`, and `_numberOfEpochs` are within reasonable ranges. Also there is no check to ensure the supplied `_token` address is in fact a valid ERC20 token. Unreasonable values can lead to unexpected behavior, integer overflows, or denial of service."",
      ""Impact"": ""Unexpected behavior, potential integer overflows, or denial of service due to unreasonable parameter values."",
      ""Location"": ""TwabRewards.sol:createPromotion""
    },
    {
      ""Issue"": ""Potential Race Condition/Front Running Vulnerability in `cancelPromotion`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `cancelPromotion` function calculates the remaining rewards based on `_getRemainingRewards`. This calculation relies on `block.timestamp` which can change between the time the transaction is created and when it is mined. An attacker could potentially front-run the transaction to cancel the promotion and receive more rewards than intended if the epoch is about to change."",
      ""Impact"": ""Potential for an attacker to cancel a promotion and claim a larger portion of the rewards than intended if they can front-run the transaction."",
      ""Location"": ""Function `cancelPromotion`""
    },
        {
      ""Issue"": ""Lack of Promotion Pause/Resume Functionality"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks a mechanism to pause or resume promotions. In case of unforeseen issues with the ticket contract or the rewards distribution mechanism, the contract owner cannot temporarily halt the promotion to investigate and resolve the problem.  The only option is to cancel the promotion."",
      ""Impact"": ""Limited control over running promotions in case of unexpected issues, potentially leading to loss of funds or user dissatisfaction."",
      ""Location"": ""N/A - missing functionality""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `_getRemainingRewards`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_getRemainingRewards` function, if `_getCurrentEpochId(_promotion)` becomes greater than `_promotion.numberOfEpochs` due to incorrect timestamp or epoch calculations, it might lead to integer underflow, resulting in a very large number of remaining rewards. The `_requirePromotionActive` mitigates this but doesn't fully prevent it."",
      ""Impact"": ""Incorrect rewards calculation, possibly leading to users claiming more rewards than intended."",
      ""Location"": ""TwabRewards.sol:_getRemainingRewards""
    },
    {
      ""Issue"": ""Potential Loss of Funds due to Precision Loss in reward calculation."",
      ""Severity"": ""Low"",
      ""Description"": ""The reward calculation in `_calculateRewardAmount` involves division. Solidity performs integer division, which truncates any fractional part of the result. While this is common, it can lead to a slight loss of precision and, over time, might result in a small amount of rewards remaining undistributed."",
      ""Impact"": ""Minor loss of funds due to truncation during reward calculation."",
      ""Location"": ""TwabRewards.sol:_calculateRewardAmount""
    },
    {
      ""Issue"": ""Missing Check for Sufficient Balance Before Transferring in `cancelPromotion`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `cancelPromotion` calculates the remaining rewards and transfers them to the specified address. However, there is no check to ensure that the contract has sufficient balance of the reward token to perform the transfer. If the contract somehow sent more rewards than held, the transfer function would revert."",
      ""Impact"": ""Revert if the contract doesn't have sufficient token balance which would cause denial of service."",
      ""Location"": ""TwabRewards.sol:cancelPromotion""
    },
    {
      ""Issue"": ""Missing Check for Zero Epoch Duration"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createPromotion` function doesn't check if `_epochDuration` is zero. If `_epochDuration` is zero, `_getCurrentEpochId` will result in division by zero."",
      ""Impact"": ""Division by zero, causing the transaction to revert."",
      ""Location"": ""TwabRewards.sol:createPromotion""
    },
    {
      ""Issue"": ""Inconsistent Usage of `_promotion` Variable in `extendPromotion`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `extendPromotion` function, after retrieving the `_promotion` from storage, the code directly modifies the storage variable `_promotions[_promotionId].numberOfEpochs`. However, later, the code uses a memory copy of `_promotion` to access the token. While this does not directly cause an error, it can lead to confusion and potential errors if other properties of the memory-based `_promotion` were used after modifying the storage version, and is generally not a good pattern."",
      ""Impact"": ""Potential for confusion and future errors during maintenance or modifications."",
      ""Location"": ""TwabRewards.sol:extendPromotion""
    },
    {
      ""Issue"": ""Missing Input Validation for `_numberOfEpochs` in `extendPromotion`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `extendPromotion` function adds `_numberOfEpochs` to the existing `numberOfEpochs` without checking if the result exceeds the maximum value for the `uint8` type.  This could lead to an overflow, causing the `numberOfEpochs` to wrap around to a small value."",
      ""Impact"": ""Potential overflow of `numberOfEpochs`, leading to incorrect promotion duration and reward distribution."",
      ""Location"": ""Function `extendPromotion`""
    },
    {
      ""Issue"": ""Missing input validation for `startTimestamp`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `createPromotion` function doesn't check if `_startTimestamp` is in the future. The `_startTimestamp` can be set to past or current timestamp, which might affect the rewards calculation."",
      ""Impact"": ""The rewards can be wrongly calculated because the epoch has already begun"",
      ""Location"": ""TwabRewards.sol:createPromotion""
    },
    {
      ""Issue"": ""Potential precision loss in `_calculateRewardAmount` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_calculateRewardAmount` function calculates the reward amount using the formula `(_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0]`. Since Solidity performs integer division, the result will be truncated, leading to precision loss. In scenarios where `_averageBalance` is small relative to `_averageTotalSupplies[0]`, the reward amount could be rounded down to zero, effectively denying users their rightful rewards."",
      ""Impact"": ""Users may receive less rewards than they are entitled to due to integer division truncation."",
      ""Location"": ""TwabRewards.sol:177 `return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];`""
    }
  ],
  ""IssueNumber"": 50,
  ""OutputList"": 17
}",188.343199968338,3538.0,32.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] createPromotion() Lack of input validation for _epochDuration can potentially freeze promotion creator's funds**

**Report Description**:  
The `createPromotion()` function allows `_epochDuration` to be set to 0. When `_epochDuration = 0`, users cannot claim rewards, and the promotion creator cannot cancel the promotion, effectively freezing the funds.

**Match in Response List**:  
Matches with the issue titled **""Missing Check for Zero Epoch Duration""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of missing validation for `_epochDuration` being zero, which aligns with the reported vulnerability. The impact of division by zero and freezing funds is correctly addressed.

---

#### **[H-02] Backdated _startTimestamp can lead to loss of funds**

**Report Description**:  
The `createPromotion()` function allows a backdated `_startTimestamp`, which can lead to loss of funds as there is no recovery mechanism for funds stuck in such scenarios.

**Match in Response List**:  
Matches with the issue titled **""Missing input validation for `startTimestamp`""**.

**Validation**:  
**Correct**. The response correctly identifies the lack of validation for `_startTimestamp`, which can lead to incorrect rewards calculation and potential loss of funds.

---

#### **[H-03] Continue claiming rewards after numberOfEpochs are over**

**Report Description**:  
The `claimRewards()` function does not check if `_epochId` is within the range of reward epochs, allowing users to claim rewards indefinitely as long as there are tokens in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of unchecked `_epochId` validation, which allows users to claim rewards beyond the intended reward period.

---

#### **[H-04] cancelPromotion is too rigorous**

**Report Description**:  
The `cancelPromotion()` function deletes the promotion entirely, preventing users from claiming rewards and locking unclaimed tokens in the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of overly rigorous cancellation, which leads to locked funds and inability to claim rewards.

---

#### **[H-05] Malicious tickets can lead to the loss of all tokens**

**Report Description**:  
The `createPromotion()` function allows the use of malicious ticket contracts, enabling attackers to retrieve all tokens from promotions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of malicious ticket contracts leading to token loss.

---

#### **[H-06] Rewards can be claimed multiple times**

**Report Description**:  
The `claimRewards()` function allows an attacker to claim rewards multiple times due to insufficient validation in the `_claimedEpochs` mapping.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in `claimRewards`""**.

**Validation**:  
**Partially Correct**. The response identifies the reentrancy issue but does not fully address the specific vulnerability of multiple claims due to insufficient validation in `_claimedEpochs`.

---

#### **[H-07] Contract does not work with fee-on-transfer tokens**

**Report Description**:  
The contract does not account for fee-on-transfer tokens, leading to discrepancies in reward calculations and unclaimable rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of fee-on-transfer tokens, which affects reward calculations and claimability.

---

#### **[M-01] cancelPromotion() Unable to cancel unstarted promotions**

**Report Description**:  
The `cancelPromotion()` function reverts for unstarted promotions due to an underflow in `_getCurrentEpochId()`.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow/Underflow in `_getCurrentEpochId`""**.

**Validation**:  
**Correct**. The response accurately identifies the underflow issue in `_getCurrentEpochId`, which prevents cancellation of unstarted promotions.

---

#### **[M-02] getRewardsAmount doesn't check epochs haven't been claimed**

**Report Description**:  
The `getRewardsAmount` function does not account for claimed epochs, leading to incorrect reward amounts being displayed to users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of incorrect reward amounts due to unclaimed epochs.

---

#### **[M-03] Dust Token Balances Cannot Be Claimed By An `admin` Account**

**Report Description**:  
Small reward claims may not be feasible due to high gas costs, leading to dust balances that cannot be claimed.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of dust token balances and the inability to claim them.

---

#### **[M-04] Unsafe uint64 casting may overflow**

**Report Description**:  
The `_calculateRewardAmount` function casts epoch timestamps from `uint256` to `uint64`, which may overflow and lead to incorrect reward calculations.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue of unsafe casting leading to potential overflow.

---

#### **[M-05] Missing Check When Transferring Tokens Out For A Given Promotion**

**Report Description**:  
The `claimRewards` function does not check for sufficient token balance before transferring rewards, which could lead to transaction reverts.

**Match in Response List**:  
Matches with the issue titled **""Missing Check for Sufficient Balance Before Transferring in `cancelPromotion`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of insufficient balance checks but focuses on `cancelPromotion` instead of `claimRewards`.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] createPromotion() Lack of input validation for _epochDuration can potentially freeze promotion creator's funds**
- **[H-02] Backdated _startTimestamp can lead to loss of funds**
- **[M-01] cancelPromotion() Unable to cancel unstarted promotions**

**Partially Correct Matches**:

- **[H-06] Rewards can be claimed multiple times**
- **[M-05] Missing Check When Transferring Tokens Out For A Given Promotion**

**Missed Issues from Issue Report**:

- **[H-03] Continue claiming rewards after numberOfEpochs are over**
- **[H-04] cancelPromotion is too rigorous**
- **[H-05] Malicious tickets can lead to the loss of all tokens**
- **[H-07] Contract does not work with fee-on-transfer tokens**
- **[M-02] getRewardsAmount doesn't check epochs haven't been claimed**
- **[M-03] Dust Token Balances Cannot Be Claimed By An `admin` Account**
- **[M-04] Unsafe uint64 casting may overflow**

--- 

The response list covers some critical issues but misses several vulnerabilities, particularly those related to reward claims, malicious tickets, and fee-on-transfer tokens. Additionally, some responses are partially correct, as they address related issues but not the specific vulnerabilities described in the report.","```
1. Missing Check for Zero Epoch Duration
2. Missing input validation for `startTimestamp`
3. Potential Integer Overflow/Underflow in `_getCurrentEpochId`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Missing Check for Zero Epoch Duration**: Rank 14
   - **Missing input validation for `startTimestamp`**: Rank 17
   - **Potential Integer Overflow/Underflow in `_getCurrentEpochId`**: Rank 5

2. **Calculate the precision at each rank**:
   - **Rank 5**: \( P@5 = \frac{1}{5} = 0.2 \)
   - **Rank 14**: \( P@14 = \frac{2}{14} \approx 0.1429 \)
   - **Rank 17**: \( P@17 = \frac{3}{17} \approx 0.1765 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.2 + 0.1429 + 0.1765}{3} \approx \frac{0.5194}{3} \approx 0.1731
   \]

**Average Precision (AP)**: 0.1731"
