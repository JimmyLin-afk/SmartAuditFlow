nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
IdleYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; 
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./interfaces/idle/IIdleTokenHelper.sol"";
import ""./access/AssetManager.sol"";

/// @title An pooltogether yield source for Idle token
/// @author Sunny Radadiya
contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public totalUnderlyingAssets;

    /// @notice Emitted when the yield source is initialized
    event IdleYieldSourceInitialized(address indexed idleToken);

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    /// @notice Emitted when ERC20 tokens other than yield source's idleToken are withdrawn from the yield source
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    /// @notice Initializes the yield source with Idle Token
    /// @param _idleToken Idle Token address
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() external view override returns (address) {
        return (underlyingAsset);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Calculates the balance of Total idle Tokens Contract hasv
    /// @return balance of Idle Tokens
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    /// @notice Calculates the number of shares that should be mint or burned when a user deposit or withdraw
    /// @param tokens Amount of tokens
    /// return Number of shares
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(_totalShare() == 0) {
            shares = tokens;
        } else {
            shares = (tokens * _totalShare())  / totalUnderlyingAssets;
        }
    }

    /// @notice Calculates the number of tokens a user has in the yield source
    /// @param shares Amount of shares
    /// return Number of tokens
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        if(_totalShare() == 0) {
            tokens = shares;
        } else {
            tokens = (shares * totalUnderlyingAssets) / _totalShare();
        }
    }

    /// @notice Deposit asset tokens to Idle
    /// @param mintAmount The amount of asset tokens to be deposited
    /// @return 0 if successful 
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
        return mintedTokens;
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param mintAmount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {
        uint256 mintedTokenShares = _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    /// @notice Redeems tokens from the yield source from the msg.sender, it burn yield bearing tokens and return token to the sender.
    /// @param redeemAmount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {
        uint256 _idleShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, _idleShare);
        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;
        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);
        return redeemedUnderlyingAsset;
    }

    /// @notice Transfer ERC20 tokens other than the idleTokens held by this contract to the recipient address
    /// @dev This function is only callable by the owner or asset manager
    /// @param erc20Token The ERC20 token to transfer
    /// @param to The recipient of the tokens
    /// @param amount The amount of tokens to transfer
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(address(erc20Token) != address(idleToken), ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1555,160,"[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource
The `redeemToken` function in IdleYieldSource uses redeemedShare instead of redeemAmount as the input parameter when calling redeemIdleToken of the Idle yield source. As a result, users could get fewer underlying tokens than they should.
When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the tokenPriceWithFee() is greater than ONE_IDLE_TOKEN, and thus redeemedShare is less than redeemAmount, causing users to get fewer underlying tokens than expected.
 [H-05] IdleYieldSource doesn't use mantissa calculations
Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.
For example, say I deposit 1 token, expecting 1 share in return. On L95, if the totalUnderlyingAssets is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.
Recommend implementing mantissa calculations like in the contract for the AAVE yield.
  [M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits
Function `timelockDepositTo` The contract uses _msgSender() to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be.
While the code handles this separation of role in most cases, it misses doing so in timelockDepositTo() function where it accounts the _timelockBalances to the operator address instead of the user specified to address. It assumes they are the same. The corresponding usage in _mintTimelock() which is called from withdrawWithTimelockFrom() uses the user specified 'from' address and not the _msgSender(). Therefore the corresponding usage in timelockDepositTo() should be the same.
In the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operator’s address does not have the required amount of _timelockBalances.
",3,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; 
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./interfaces/idle/IIdleTokenHelper.sol"";
import ""./access/AssetManager.sol"";



contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public totalUnderlyingAssets;

    
    event IdleYieldSourceInitialized(address indexed idleToken);

    
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    
    
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    
    
    function depositToken() external view override returns (address) {
        return (underlyingAsset);
    }

    
    
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    
    
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    
    
    
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(_totalShare() == 0) {
            shares = tokens;
        } else {
            shares = (tokens * _totalShare())  / totalUnderlyingAssets;
        }
    }

    
    
    
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        if(_totalShare() == 0) {
            tokens = shares;
        } else {
            tokens = (shares * totalUnderlyingAssets) / _totalShare();
        }
    }

    
    
    
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
        return mintedTokens;
    }

    
    
    
    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {
        uint256 mintedTokenShares = _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    
    
    
    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {
        uint256 _idleShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, _idleShare);
        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;
        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);
        return redeemedUnderlyingAsset;
    }

    
    
    
    
    
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(address(erc20Token) != address(idleToken), ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    
    
    
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1010,2,1,"{'task_list': [{'Area': 'Share Calculation and Accounting', 'Tasks': ['Verify the accuracy of `_tokenToShares` and `_sharesToToken` calculations, especially when `_totalShare()` or `totalUnderlyingAssets` is very small or very large, to prevent rounding errors or overflows.', 'Analyze the impact of accrued yield in the Idle protocol on the share price within `IdleYieldSource`. Confirm that the `totalUnderlyingAssets` variable correctly reflects the total value backing the shares, including yield, or investigate potential discrepancies between internal share price and actual redeemable amount.', 'Investigate potential scenarios where `IIdleToken(idleToken).redeemIdleToken(_idleShare)` returns less than the intended amount due to slippage, fees, or internal Idle protocol mechanics. Evaluate if this difference is accounted for and if it could lead to a loss of funds for users.', 'Simulate deposit and withdrawal scenarios with varying amounts and Idle protocol yield to ensure that share values and redemption amounts are calculated correctly and fairly for all users.', 'Assess the potential for manipulation of the share price by front-running deposits or withdrawals, especially during periods of high Idle protocol yield fluctuations.']}, {'Area': 'External Interactions & Dependencies', 'Tasks': ['Review the `IIdleToken` interface and its implementation in the actual Idle token contract to understand the behavior of `mintIdleToken` and `redeemIdleToken`, including any potential failure modes or unexpected return values.', ""Examine the role of the `address(0)` argument in the `mintIdleToken` call within `_depositToIdle`. Determine its function within the Idle protocol (e.g., referral system) and confirm it doesn't introduce any security risks."", 'Assess the potential risks associated with changes or upgrades to the Idle protocol. Evaluate if `IdleYieldSource` has mechanisms to handle such events gracefully, such as emergency shutdowns or migrations.', 'Confirm that `safeApprove` is called with the correct allowance and target (idleToken) to prevent potential issues with token approvals.']}, {'Area': 'Access Control and Permissions', 'Tasks': ['Thoroughly review the `AssetManager` contract, including its role in managing the `transferERC20` function. Clearly define the permissions granted to the Asset Manager role and assess the potential impact of a compromised Asset Manager account.', 'Verify that the `onlyOwnerOrAssetManager` modifier is correctly implemented and used consistently throughout the contract.', ""Analyze the potential risks associated with the owner's ability to transfer arbitrary ERC20 tokens using `transferERC20`. Assess whether any restrictions or whitelists are necessary to mitigate these risks."", 'Evaluate the implications of ownership transfer and upgradeability on the security and trust of the contract.']}, {'Area': 'Reentrancy Vulnerabilities', 'Tasks': ['Despite the use of `nonReentrant`, carefully analyze all external calls (especially `IIdleToken.mintIdleToken` and `IIdleToken.redeemIdleToken`) for potential reentrancy vulnerabilities, considering the specific logic within the Idle protocol.', 'Review the state updates within `supplyTokenTo` and `redeemToken` to ensure that no reentrancy attack can manipulate these updates to cause inconsistencies or fund loss.']}, {'Area': 'Arithmetic Overflows/Underflows', 'Tasks': ['Although SafeERC20 is used, examine `_tokenToShares` and `_sharesToToken` for potential overflow or underflow issues due to large input values or extreme ratios between total shares and underlying assets. Add checks where needed.', 'Carefully review the calculation of `totalUnderlyingAssets` in `supplyTokenTo` and `redeemToken` to ensure that it cannot be manipulated to cause an overflow or underflow.']}, {'Area': 'Gas Optimization', 'Tasks': ['Analyze the gas costs of key functions, such as `supplyTokenTo` and `redeemToken`, and identify potential optimizations to reduce gas consumption.', 'Review the order of operations and state variable access patterns to minimize gas costs.', 'Evaluate the use of storage variables and consider caching frequently accessed values in memory to reduce gas consumption.']}]}","{'ReviewingTheCode': 'The contract `IdleYieldSource` acts as an adapter or wrapper around an Idle Finance yield-bearing token (`idleToken`). It implements the `IProtocolYieldSource` interface (likely for integration with systems like PoolTogether) and also functions as an ERC20 token itself, representing shares of the underlying Idle position managed by this contract. It allows users to deposit the `underlyingAsset` (e.g., DAI) via `supplyTokenTo`, which deposits into Idle and mints shares of this contract (`IdleYieldSource` token). Users can redeem their shares for the underlying asset via `redeemToken`. It includes sponsorship functionality and administrative token transfer capabilities. The contract is upgradeable and uses a reentrancy guard.', 'IdentifyingKeyComponents': {'ContractName': 'IdleYieldSource', 'Purpose': 'To provide a standardized yield source interface (IProtocolYieldSource) for an underlying Idle Finance token, while issuing its own ERC20 shares representing deposits into that Idle token.', 'InheritanceAndImports': {'InheritsFrom': ['IProtocolYieldSource', 'Initializable', 'ReentrancyGuardUpgradeable', 'ERC20Upgradeable', 'AssetManager'], 'Imports': ['@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol', './interfaces/pooltogether/IProtocolYieldSource.sol', './interfaces/idle/IIdleToken.sol', './interfaces/idle/IIdleTokenHelper.sol', './access/AssetManager.sol']}, 'StateVariables': [{'Name': 'idleToken', 'Type': 'address', 'Purpose': 'Address of the underlying Idle Finance protocol token (e.g., idleDAI).'}, {'Name': 'underlyingAsset', 'Type': 'address', 'Purpose': 'Address of the base asset managed by the Idle token (e.g., DAI).'}, {'Name': 'totalUnderlyingAssets', 'Type': 'uint256', 'Purpose': 'Tracks the total amount of underlying assets deposited into the Idle protocol *through this contract*. Used for share calculation.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the contract state, setting the Idle token, underlying asset, approving Idle spending, and initializing Ownable.', 'Parameters': ['address _idleToken'], 'Returns': []}, {'Name': 'depositToken', 'Visibility': 'external view override', 'Purpose': 'Returns the address of the underlying asset that should be deposited. Part of the IProtocolYieldSource interface.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balanceOfToken', 'Visibility': 'external view override', 'Purpose': 'Calculates the underlying asset value equivalent to the shares held by an address in this contract. Part of the IProtocolYieldSource interface.', 'Parameters': ['address addr'], 'Returns': ['uint256']}, {'Name': '_totalShare', 'Visibility': 'internal view', 'Purpose': 'Returns the total balance of the `idleToken` held by this contract.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_tokenToShares', 'Visibility': 'internal view', 'Purpose': ""Converts an amount of the `underlyingAsset` to the equivalent number of shares in *this* contract's ERC20 token."", 'Parameters': ['uint256 tokens'], 'Returns': ['uint256 shares']}, {'Name': '_sharesToToken', 'Visibility': 'internal view', 'Purpose': ""Converts a number of shares in *this* contract's ERC20 token to the equivalent amount of the `underlyingAsset`."", 'Parameters': ['uint256 shares'], 'Returns': ['uint256 tokens']}, {'Name': '_depositToIdle', 'Visibility': 'internal', 'Purpose': 'Helper function to transfer underlying asset from the caller and mint `idleToken`.', 'Parameters': ['uint256 mintAmount'], 'Returns': ['uint256 (minted idleTokens)']}, {'Name': 'supplyTokenTo', 'Visibility': 'public override', 'Purpose': ""Deposits `underlyingAsset` into the Idle protocol and mints shares of *this* contract's ERC20 token to the specified address `to`."", 'Parameters': ['uint256 mintAmount', 'address to'], 'Returns': []}, {'Name': 'redeemToken', 'Visibility': 'public override', 'Purpose': ""Burns shares of *this* contract's ERC20 token from the caller, redeems the corresponding amount from the Idle protocol, and transfers the `underlyingAsset` back to the caller."", 'Parameters': ['uint256 redeemAmount'], 'Returns': ['uint256 (redeemedUnderlyingAsset)']}, {'Name': 'transferERC20', 'Visibility': 'external override', 'Purpose': 'Allows the owner or asset manager to transfer out any ERC20 token *other than* the `idleToken` held by this contract.', 'Parameters': ['address erc20Token', 'address to', 'uint256 amount'], 'Returns': []}, {'Name': 'sponsor', 'Visibility': 'external override', 'Purpose': 'Allows anyone to deposit `underlyingAsset` into the Idle protocol via this contract without receiving shares, effectively increasing the yield for existing shareholders.', 'Parameters': ['uint256 amount'], 'Returns': []}, {'Name': 'nonReentrant', 'Visibility': 'modifier', 'Purpose': 'Prevents reentrancy attacks (from ReentrancyGuardUpgradeable).', 'Parameters': [], 'Returns': []}, {'Name': 'onlyOwnerOrAssetManager', 'Visibility': 'modifier', 'Purpose': 'Restricts function access to the owner or a designated asset manager (defined in AssetManager).', 'Parameters': [], 'Returns': []}, {'Name': 'initializer', 'Visibility': 'modifier', 'Purpose': 'Ensures a function can only be called once during initialization (from Initializable).', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['Idle Finance Token Contract (`idleToken`): Calls `token()`, `mintIdleToken()`, `redeemIdleToken()`, `balanceOf()`.', 'Underlying Asset ERC20 Contract (`underlyingAsset`): Calls `safeApprove()`, `safeTransferFrom()`, `safeTransfer()`.', 'Arbitrary ERC20 Contract (`erc20Token` in `transferERC20`): Calls `safeTransfer()`.'], 'SpecialMechanisms': ['Upgradeable Contract: Uses OpenZeppelin Initializable pattern.', 'ERC20 Token Implementation: Inherits from ERC20Upgradeable, making the contract itself an ERC20 token representing shares.', 'Yield Source Interface: Implements `IProtocolYieldSource` for compatibility with other DeFi protocols (e.g., PoolTogether).', 'Reentrancy Protection: Uses `ReentrancyGuardUpgradeable`.', 'Access Control: Uses `AssetManager` (likely extending Ownable) for restricted functions.', 'Internal Share Calculation: Uses internal state (`totalUnderlyingAssets`) and external calls (`_totalShare()`) to manage the value of its own shares relative to the underlying Idle position.'], 'Questions': ['How is the `AssetManager` role defined and managed? What specific permissions does it grant beyond ownership?', 'The share calculation logic in `_tokenToShares` and `_sharesToToken` relies on `totalUnderlyingAssets` (updated only on deposit/redeem) and `_totalShare()` (current Idle balance). How does this accurately reflect yield accrued within the Idle token? If `_totalShare()` increases due to yield while `totalUnderlyingAssets` is static, the formulas seem to imply the value per share decreases, which is counter-intuitive. Is `totalUnderlyingAssets` intended to represent something other than the sum of principals deposited/withdrawn?', ""In `redeemToken`, the amount of `idleToken` shares to redeem (`_idleShare`) is calculated using the contract's internal ratio. If this ratio slightly diverges from the Idle protocol's internal ratio due to rounding, minor yield differences, or timing, could `IIdleToken(idleToken).redeemIdleToken(_idleShare)` return slightly less than the expected `redeemAmount` of the underlying asset?"", ""What is the purpose of the `address(0)` argument in the `mintIdleToken` call within `_depositToIdle`? Does it relate to Idle's referral system or specific minting options?"", 'Is there any mechanism to handle potential losses or discrepancies if the Idle protocol undergoes changes or if `redeemIdleToken` returns less than expected?']}","{'Findings': [{'Issue': 'Missing Initialization for Upgradeable Contracts (ERC20Upgradeable, ReentrancyGuardUpgradeable)', 'Severity': 'Critical', 'Description': ""The contract `IdleYieldSource` inherits from `Initializable`, `ReentrancyGuardUpgradeable`, `ERC20Upgradeable`, and `AssetManager`. While `__Ownable_init()` (via AssetManager) is called, the initializers for `ReentrancyGuardUpgradeable` (`__ReentrancyGuard_init()`) and especially `ERC20Upgradeable` (`__ERC20_init(name, symbol)`) are missing in the `initialize` function. This leaves the ERC20 token's metadata (name, symbol, decimals) uninitialized, rendering it non-compliant and potentially unusable. Failing to initialize inherited upgradeable contracts can lead to storage collisions, incorrect state, unpredictable behavior, and vulnerabilities."", 'Impact': 'The `IdleYieldSource` token will be unusable as a standard ERC20 token, failing interactions with wallets, dApps, and exchanges. The contract may not function correctly, potentially leading to loss of funds or denial of service. Upgradeability features might also be compromised.', 'Location': 'initialize function in IdleYieldSource.sol'}, {'Issue': 'Lack of Access Control on `initialize` Function', 'Severity': 'High', 'Description': ""The `initialize` function is only protected by the `initializer` modifier, which prevents re-initialization within the same deployment context but doesn't prevent it across upgrades or if the contract is deployed without calling initialize immediately. Anyone could potentially call `initialize` on an uninitialized implementation or after an upgrade if not properly managed, allowing them to set critical parameters like `idleToken` and `underlyingAsset`, potentially taking control or bricking the contract."", 'Impact': 'Malicious actors could seize control of the contract by re-initializing it with arbitrary parameters, leading to loss of user funds or denial of service.', 'Location': 'function initialize(...)'}, {'Issue': 'Incorrect Accounting of `totalUnderlyingAssets` during Redemption', 'Severity': 'High', 'Description': 'The `redeemToken` function updates `totalUnderlyingAssets` by subtracting `redeemAmount` (the user-requested amount) rather than the actual amount of underlying assets received (`redeemedUnderlyingAsset`) from the `IIdleToken(idleToken).redeemIdleToken(_idleShare)` call. If the actual redeemed amount differs from the requested amount (due to slippage, fees, or Idle protocol mechanics), `totalUnderlyingAssets` will become inaccurate. This discrepancy corrupts the internal accounting and affects share price calculations.', 'Impact': 'Incorrect accounting of total underlying assets leads to skewed share/token conversion rates in `_tokenToShares` and `_sharesToToken`. This can be exploited to mint shares cheaply or redeem them for excessive value, potentially draining funds from the contract or causing losses for other users.', 'Location': 'redeemToken function in IdleYieldSource.sol'}, {'Issue': 'Potential Reentrancy in `redeemToken` via External Calls', 'Severity': 'High', 'Description': 'The `redeemToken` function calls the external function `IIdleToken(idleToken).redeemIdleToken(_idleShare)` before transferring the redeemed assets. While the function uses the `nonReentrant` modifier, a malicious or compromised `IdleToken` implementation could potentially call back into the `IdleYieldSource` contract *before* the state updates are fully consistent or *after* the initial `nonReentrant` check but before completion. Additionally, the final `safeTransfer` of `redeemedUnderlyingAsset` could also be a vector if the underlying token has malicious callbacks (e.g., ERC777 hooks). This could bypass the intended protection and allow manipulation of contract state.', 'Impact': 'A successful reentrancy attack could allow an attacker to manipulate state variables like `totalUnderlyingAssets` or re-enter the redemption logic multiple times within a single transaction, potentially leading to theft of funds.', 'Location': 'redeemToken function in IdleYieldSource.sol, specifically external call to `redeemIdleToken` and subsequent `safeTransfer`'}, {'Issue': 'Lack of Slippage Control on Idle Token Minting and Redemption', 'Severity': 'Medium', 'Description': 'The `_depositToIdle` function calls `IIdleToken(idleToken).mintIdleToken` and the `redeemToken` function calls `IIdleToken(idleToken).redeemIdleToken` without specifying a minimum amount of Idle shares to receive or a minimum amount of underlying asset to receive, respectively. In volatile market conditions or periods of low liquidity within the Idle protocol, the actual exchange rate might differ significantly from the expected rate, causing the user to receive fewer tokens (either Idle shares or underlying asset) than anticipated.', 'Impact': 'Users may suffer value loss due to unfavorable exchange rates (slippage) when depositing or redeeming tokens, especially during volatile market conditions.', 'Location': '_depositToIdle() and redeemToken() functions'}, {'Issue': 'Incorrect Share Calculation Logic and Potential Edge Case Failures', 'Severity': 'Medium', 'Description': 'The `_tokenToShares` and `_sharesToToken` functions calculate share/token conversions. Issues identified include: 1) Potential division by zero if `totalUnderlyingAssets` becomes zero while `_totalShare()` is non-zero (in `_sharesToToken`). 2) Integer division leads to truncation (rounding down), which can cause precision loss, disadvantaging users slightly on each operation, especially with small amounts potentially receiving zero shares. 3) Potential integer overflow/underflow in the intermediate multiplication step (`tokens * _totalShare()` or `shares * totalUnderlyingAssets`) if input values are extremely large, despite Solidity 0.8+ checks (which would cause reverts). 4) The initial deposit logic (`_totalShare() == 0`) assumes a 1:1 ratio, which might be slightly inaccurate if the IdleToken contract had pre-existing dust or yield before the first YieldSource deposit.', 'Impact': 'Incorrect share or token amounts calculated during deposits/redemptions, potentially leading to loss of value for users or the protocol. Division by zero would cause transactions to revert, leading to denial of service for deposit/withdrawal functions. Rounding errors can accumulate or be exploited.', 'Location': '_tokenToShares() and _sharesToToken() functions'}, {'Issue': 'Missing Check for Zero Address in `initialize` Function', 'Severity': 'Medium', 'Description': 'The `initialize` function does not validate if the provided `_idleToken` address is the zero address. Initializing the contract with `_idleToken` set to the zero address would likely render the contract unusable, as subsequent interactions attempting to use this address (e.g., determining `underlyingAsset`, calling `mintIdleToken` or `redeemIdleToken`) would fail.', 'Impact': 'The contract could become permanently unusable if initialized with a zero address for `_idleToken`, resulting in a denial of service and locking any funds potentially sent to it.', 'Location': 'initialize() function'}, {'Issue': 'Sponsor Function Issues: No Shares Minted and Potential Accounting Discrepancy', 'Severity': 'Medium', 'Description': ""The `sponsor` function allows depositing underlying assets into the Idle protocol via `_depositToIdle` but does not mint any `IdleYieldSource` shares for the sponsor, nor does it update `totalUnderlyingAssets`. This means the sponsor effectively donates assets, increasing the yield generated within Idle, but this yield potentially benefits existing shareholders without the sponsor getting representation. Furthermore, the lack of update to `totalUnderlyingAssets` creates a discrepancy between the contract's tracked assets and the actual underlying value managed via Idle."", 'Impact': ""Sponsors lose their contributed funds without receiving shares. The contract's internal accounting (`totalUnderlyingAssets`) becomes inaccurate, potentially skewing share value calculations over time as the sponsored funds generate yield."", 'Location': 'sponsor() function, _depositToIdle()'}, {'Issue': 'Potential Front-Running Vulnerability in `supplyTokenTo`', 'Severity': 'Medium', 'Description': 'The `supplyTokenTo` function takes a `to` address parameter, allowing the minted shares to be sent to an arbitrary recipient. A malicious actor could observe legitimate `supplyTokenTo` transactions in the mempool and front-run them, potentially by calling the function with the same `mintAmount` but directing the shares (`to`) to their own address, effectively stealing the deposit.', 'Impact': 'Attackers can potentially steal shares intended for legitimate depositors by front-running transactions.', 'Location': 'supplyTokenTo(uint256 mintAmount, address to)'}, {'Issue': 'Lack of Access Control on `totalUnderlyingAssets` Modification Path', 'Severity': 'Medium', 'Description': ""The `totalUnderlyingAssets` state variable is critical for share calculations. While updated within `supplyTokenTo` and `redeemToken` (which have reentrancy guards), there's no explicit check preventing potential underflow in `redeemToken` if `redeemAmount` exceeds `totalUnderlyingAssets` (even if the external Idle call prevents withdrawing more than available). Corruption or manipulation of `totalUnderlyingAssets` directly impacts the core logic."", 'Impact': 'Incorrect accounting of total underlying assets can lead to flawed share price calculations, enabling potential exploits like minting shares too cheaply or redeeming them for too much value, causing fund loss.', 'Location': 'redeemToken(), supplyTokenTo(), declaration of `totalUnderlyingAssets`'}, {'Issue': 'Unbounded Token Approval in `initialize` Function', 'Severity': 'Low', 'Description': 'The `initialize` function grants an unlimited (`type(uint256).max`) approval for the `underlyingAsset` to the `idleToken` contract. While necessary for depositing, granting infinite approval poses a potential security risk. If the `idleToken` contract were ever compromised or contained a vulnerability, it could potentially drain all `underlyingAsset` funds held by the `IdleYieldSource` contract.', 'Impact': 'Increased attack surface. If the approved `idleToken` contract is compromised, all underlying assets held by this contract could be drained.', 'Location': 'initialize() function'}, {'Issue': 'Missing Checks for Zero Amounts in `supplyTokenTo` and `redeemToken`', 'Severity': 'Low', 'Description': 'The `supplyTokenTo` and `redeemToken` functions do not explicitly check if the `mintAmount` or `redeemAmount` is zero. While transferring zero tokens usually has no effect and might be stopped by underlying ERC20 checks, explicitly checking prevents unnecessary function calls, associated gas costs, and potential edge cases in integrations or underlying token implementations.', 'Impact': 'Unnecessary gas consumption for zero-amount operations, potential for emitting events for no-op actions, and minor deviation from best practices.', 'Location': 'supplyTokenTo(), redeemToken()'}, {'Issue': 'Missing checks for zero address in `transferERC20`', 'Severity': 'Low', 'Description': 'The `transferERC20` function, callable by the owner or asset manager, does not check if the `to` address is the zero address. Transferring tokens to the zero address effectively burns them, which might not be the intended behavior and could lead to accidental loss of assets.', 'Impact': 'Accidental burning of potentially valuable ERC20 tokens held by the contract if the zero address is provided mistakenly.', 'Location': 'transferERC20 function'}], 'IssueNumber': 54, 'OutputList': 13}",281.5410785675049,"### **Summary of Matches and Gaps**

---

#### **[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource**

**Report Description**:
The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should. When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.

**Match in Response List**:
Matches with the issue titled **""Incorrect Accounting of `totalUnderlyingAssets` during Redemption""**.

**Validation**:
**Partially Correct**. The response identifies the issue with incorrect accounting of `totalUnderlyingAssets` during redemption but does not explicitly mention the use of `redeemedShare` instead of `redeemAmount`. While the response highlights the broader issue of accounting discrepancies, it misses the specific detail of the incorrect parameter usage, which is critical to understanding the vulnerability.

---

#### **[H-05] IdleYieldSource doesn't use mantissa calculations**

**Report Description**:
Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given. For example, say I deposit 1 token, expecting 1 share in return. On L95, if the `totalUnderlyingAssets` is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares. Recommend implementing mantissa calculations like in the contract for the AAVE yield.

**Match in Response List**:
Matches with the issue titled **""Incorrect Share Calculation Logic and Potential Edge Case Failures""**.

**Validation**:
**Correct**. The response accurately identifies the issue with incorrect share calculation logic, including the potential for division by zero and precision loss due to integer division. It also mentions the risk of edge case failures, which aligns with the issue report's concern about the lack of mantissa calculations. The response covers the core issue and its potential impact.

---

#### **[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits**

**Report Description**:
Function `timelockDepositTo`. The contract uses `_msgSender()` to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be. While the code handles this separation of role in most cases, it misses doing so in `timelockDepositTo()` function where it accounts the `_timelockBalances` to the operator address instead of the user specified `to` address. It assumes they are the same. The corresponding usage in `_mintTimelock()` which is called from `withdrawWithTimelockFrom()` uses the user specified 'from' address and not the `_msgSender()`. Therefore the corresponding usage in `timelockDepositTo()` should be the same. In the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operator’s address does not have the required amount of `_timelockBalances`.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address this issue. The issue highlights a critical assumption in the `timelockDepositTo` function that could lead to failed deposits in meta-transaction scenarios. This is a significant oversight, as it directly impacts the functionality of the contract in a common use case.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-05] IdleYieldSource doesn't use mantissa calculations**

**Partially Correct Matches**:

- **[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource**

**Missed Issues from Issue Report**:

- **[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits**

--- 

This analysis highlights that while some issues in the report are correctly or partially addressed in the response list, there are critical gaps, particularly in the handling of meta-transactions and assumptions about operator and user addresses. These gaps should be addressed to ensure comprehensive coverage of the vulnerabilities.","```
1. Incorrect Share Calculation Logic and Potential Edge Case Failures
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Share Calculation Logic and Potential Edge Case Failures"".
   - This issue appears at rank 6 in the ranked list of predictions.

2. **Calculate the precision at rank 6 (\( P@6 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 6, there is only 1 true positive.
   - \( P@6 = \frac{1}{6} \approx 0.1667 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.1667 \).

**Average Precision (AP)**: 0.1667"
YearnV2YieldSource.sol,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.6.12;

import ""../interfaces/IYieldSource.sol"";
import ""../external/yearn/IYVaultV2.sol"";

import ""@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";


/// @title Yield source for a PoolTogether prize pool that generates yield by depositing into Yearn Vaults.
/// @dev This contract inherits from the ERC20 implementation to keep track of users deposits
/// @dev This is a generic contract that will work with main Yearn Vaults. Vaults using v0.3.2 to v0.3.4 included
/// @dev are not compatible, as they had dips in shareValue due to a small miscalculation
/// @notice Yield Source Prize Pools subclasses need to implement this interface so that yield can be generated.
contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint;
    
    /// @notice Yearn Vault which manages `token` to generate yield
    IYVaultV2 public vault;
    /// @dev Deposit Token contract address
    IERC20Upgradeable internal token; 
    /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS
    uint256 public maxLosses = 0; // 100% would be 10_000

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed user,
        uint256 amount
    );
    
    /// @notice Emitted when the yield source is initialized
    event YieldSourceYearnV2Initialized(
        IYVaultV2 vault,
        IERC20Upgradeable token
    );

    /// @notice Emitted when the Max Losses accepted when withdrawing from yVault are changed
    event MaxLossesChanged(
        uint256 newMaxLosses
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Initializes the yield source with 
    /// @param _vault YearnV2 Vault in which the Yield Source will deposit `token` to generate Yield
    /// @param _token Underlying Token / Deposit Token
    function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        // NOTE: Vaults from 0.3.2 to 0.3.4 have dips in shareValue
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }

    function setMaxLosses(uint256 _maxLosses) external onlyOwner {
        require(_maxLosses <= 10_000, ""YearnV2YieldSource:: losses set too high"");

        maxLosses = _maxLosses;

        emit MaxLossesChanged(_maxLosses);
    }

    /// @notice Returns the ERC20 asset token used for deposits
    /// @return The ERC20 asset token address
    function depositToken() external view override returns (address) {
        return address(token);
    }

    /// @notice Returns user total balance (in asset tokens). This includes the deposits and interest.
    /// @param addr User address
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Supplies asset tokens to the yield source
    /// @dev Shares corresponding to the number of tokens supplied are mint to the user's balance
    /// @dev Asset tokens are supplied to the yield source, then deposited into Aave
    /// @param _amount The amount of asset tokens to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {
        uint256 shares = _tokenToShares(_amount);

        _mint(to, shares);

        // NOTE: we have to deposit after calculating shares to mint
        token.safeTransferFrom(msg.sender, address(this), _amount);

        _depositInVault();

        emit SuppliedTokenTo(msg.sender, shares, _amount, to);
    }

    /// @notice Redeems asset tokens from the yield source
    /// @dev Shares corresponding to the number of tokens withdrawn are burnt from the user's balance
    /// @dev Asset tokens are withdrawn from Yearn's Vault, then transferred from the yield source to the user's wallet
    /// @param amount The amount of asset tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed
    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
        uint256 shares = _tokenToShares(amount);

        uint256 withdrawnAmount = _withdrawFromVault(amount);

        _burn(msg.sender, shares);

        token.safeTransfer(msg.sender, withdrawnAmount);

        emit RedeemedToken(msg.sender, shares, amount);
        return withdrawnAmount;
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external nonReentrant {
        token.safeTransferFrom(msg.sender, address(this), amount);

        _depositInVault();

        emit Sponsored(msg.sender, amount);
    }

    // ************************ INTERNAL FUNCTIONS ************************

    /// @notice Deposits full balance (or max available deposit) into Yearn's Vault
    /// @dev if deposit limit is reached, tokens will remain in the Yield Source and
    /// @dev they will be queued for retries in subsequent deposits
    /// @return The actual amount of shares that were received for the deposited tokens
    function _depositInVault() internal returns (uint256) {
        IYVaultV2 v = vault; // NOTE: for gas usage
        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {
            token.safeApprove(address(v), type(uint256).max);
        }
        // this will deposit full balance (for cases like not enough room in Vault)
        return v.deposit();
    }

    /// @notice Withdraws requested amount from Vault
    /// @dev Vault withdrawal function required amount of shares to be redeemed
    /// @dev Losses are accepted by the Yield Source to avoid funds being locked in the Vault if something happened
    /// @param amount amount of asset tokens to be redeemed
    /// @return Tokens received from the Vault
    function _withdrawFromVault(uint amount) internal returns (uint256) {
        uint256 yShares = _tokenToYShares(amount);
        uint256 previousBalance = token.balanceOf(address(this));
        // we accept losses to avoid being locked in the Vault (if losses happened for some reason)
        if(maxLosses != 0) {
            vault.withdraw(yShares, address(this), maxLosses);
        } else {
            vault.withdraw(yShares);
        }
        uint256 currentBalance = token.balanceOf(address(this));

        return previousBalance.sub(currentBalance);
    }

    /// @notice Returns the amount of shares of yearn's vault that the Yield Source holds
    /// @return Balance of vault's shares holded by Yield Source
    function _balanceOfYShares() internal view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    /// @notice Ratio between yShares and underlying token
    /// @dev use this to convert from shares to deposit tokens and viceversa
    /// @dev (see _tokenToYShares & _ySharesToToken)
    /// @return Price per vault's share
    function _pricePerYShare() internal view returns (uint256) {
        return vault.pricePerShare();
    }

    /// @notice Balance of deposit token held in the Yield Source
    /// @return balance of deposit token
    function _balanceOfToken() internal view returns (uint256) {
        return token.balanceOf(address(this));
    }

    /// @notice Total Assets under Management by Yield Source, denominated in Deposit Token
    /// @dev amount of deposit token held in Yield Source + investment (amount held in Yearn's Vault)
    /// @return Total AUM denominated in deposit Token
    function _totalAssetsInToken() internal view returns (uint256) {
        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));
    }

    /// @notice Support function to retrieve used by Vault
    /// @dev used to correctly scale prices 
    /// @return decimals of vault's shares (and underlying token)
    function _vaultDecimals() internal view returns (uint256) {
        return vault.decimals();
    }

    // ************************ CALCS ************************

    /// @notice Converter from deposit token to yShares (yearn vault's shares)
    /// @param tokens Amount of tokens to be converted
    /// @return yShares to redeem to receive `tokens` deposit token
    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {
        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());
    }

    /// @notice Converter from deposit yShares (yearn vault's shares) to token 
    /// @param yShares Vault's shares to be converted
    /// @return tokens that will be received if yShares shares are redeemed
    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {
        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());
    }

    /// @notice Function to calculate the amount of Yield Source shares equivalent to a deposit tokens amount
    /// @param tokens amount of tokens to be converted
    /// @return shares number of shares equivalent to the amount of tokens
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(totalSupply() == 0) {
            shares = tokens;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            shares = tokens.mul(totalSupply()).div(_totalTokens);
        }
    }

    /// @notice Function to calculate the amount of Deposit Tokens equivalent to a Yield Source shares amount
    /// @param shares amount of Yield Source shares to be converted
    /// @dev used to calculate how many shares to mint / burn when depositing / withdrawing
    /// @return tokens number of tokens equivalent (in value) to the amount of Yield Source shares
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {
        if(totalSupply() == 0) {
            tokens = shares;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            tokens = shares.mul(_totalTokens).div(totalSupply());
        }
    }

    /// @notice Pure support function to compare strings
    /// @param a One string
    /// @param b Another string
    /// @return Whether or not the strings are the same or not
    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}
",2782,280,"[H-02] YearnV2YieldSource wrong subtraction in withdraw
When withdrawing function `_withdrawFromVault` from the vault, one redeems yTokens for tokens, thus the token balance of the contract should increase after withdrawal. But the contract subtracts the currentBalance from the previousBalance:
``` uint256 yShares = _tokenToYShares(amount);
uint256 previousBalance = token.balanceOf(address(this));
// we accept losses to avoid being locked in the Vault (if losses happened for some reason)
if(maxLosses != 0) {
    vault.withdraw(yShares, address(this), maxLosses);
} else {
    vault.withdraw(yShares);
}
uint256 currentBalance = token.balanceOf(address(this));
// @audit-issue this seems wrong
return previousBalance.sub(currentBalance);
```
All vault withdrawals fail due to the integer underflow as the previousBalance is less than currentBalance. Users won't be able to get back their investment.
  [M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS

The `_depositInVault()` function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract’s token balance.
However, the safeApprove function prevents changing an allowance between non-zero values to mitigate a possible front-running attack. It reverts if that is the case. Instead, the safeIncreaseAllowance and safeDecreaseAllowance functions should be used. Comment from the OZ library for this function:
“// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and ‘safeDecreaseAllowance'""
If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user’s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible. See similar Medium-severity finding M03.
",2,"pragma solidity 0.6.12;

import ""../interfaces/IYieldSource.sol"";
import ""../external/yearn/IYVaultV2.sol"";

import ""@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";







contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint;
    
    
    IYVaultV2 public vault;
    
    IERC20Upgradeable internal token; 
    
    uint256 public maxLosses = 0; 

    
    event Sponsored(
        address indexed user,
        uint256 amount
    );
    
    
    event YieldSourceYearnV2Initialized(
        IYVaultV2 vault,
        IERC20Upgradeable token
    );

    
    event MaxLossesChanged(
        uint256 newMaxLosses
    );

    
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    
    
    
    function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }

    function setMaxLosses(uint256 _maxLosses) external onlyOwner {
        require(_maxLosses <= 10_000, ""YearnV2YieldSource:: losses set too high"");

        maxLosses = _maxLosses;

        emit MaxLossesChanged(_maxLosses);
    }

    
    
    function depositToken() external view override returns (address) {
        return address(token);
    }

    
    
    
    function balanceOfToken(address addr) external override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    
    
    
    
    
    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {
        uint256 shares = _tokenToShares(_amount);

        _mint(to, shares);

        
        token.safeTransferFrom(msg.sender, address(this), _amount);

        _depositInVault();

        emit SuppliedTokenTo(msg.sender, shares, _amount, to);
    }

    
    
    
    
    
    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
        uint256 shares = _tokenToShares(amount);

        uint256 withdrawnAmount = _withdrawFromVault(amount);

        _burn(msg.sender, shares);

        token.safeTransfer(msg.sender, withdrawnAmount);

        emit RedeemedToken(msg.sender, shares, amount);
        return withdrawnAmount;
    }

    
    
    
    function sponsor(uint256 amount) external nonReentrant {
        token.safeTransferFrom(msg.sender, address(this), amount);

        _depositInVault();

        emit Sponsored(msg.sender, amount);
    }

    

    
    
    
    
    function _depositInVault() internal returns (uint256) {
        IYVaultV2 v = vault; 
        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {
            token.safeApprove(address(v), type(uint256).max);
        }
        
        return v.deposit();
    }

    
    
    
    
    
    function _withdrawFromVault(uint amount) internal returns (uint256) {
        uint256 yShares = _tokenToYShares(amount);
        uint256 previousBalance = token.balanceOf(address(this));
        
        if(maxLosses != 0) {
            vault.withdraw(yShares, address(this), maxLosses);
        } else {
            vault.withdraw(yShares);
        }
        uint256 currentBalance = token.balanceOf(address(this));

        return previousBalance.sub(currentBalance);
    }

    
    
    function _balanceOfYShares() internal view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    
    
    
    
    function _pricePerYShare() internal view returns (uint256) {
        return vault.pricePerShare();
    }

    
    
    function _balanceOfToken() internal view returns (uint256) {
        return token.balanceOf(address(this));
    }

    
    
    
    function _totalAssetsInToken() internal view returns (uint256) {
        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));
    }

    
    
    
    function _vaultDecimals() internal view returns (uint256) {
        return vault.decimals();
    }

    

    
    
    
    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {
        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());
    }

    
    
    
    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {
        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());
    }

    
    
    
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(totalSupply() == 0) {
            shares = tokens;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            shares = tokens.mul(totalSupply()).div(_totalTokens);
        }
    }

    
    
    
    
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {
        if(totalSupply() == 0) {
            tokens = shares;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            tokens = shares.mul(_totalTokens).div(totalSupply());
        }
    }

    
    
    
    
    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",1523,1,1,"{'task_list': [{'Area': 'Initialization and Upgradeability', 'Tasks': ['Verify that the `initializer` modifier is used correctly to prevent re-initialization of the contract.', 'Confirm that the `initialize` function sets all necessary state variables correctly, including vault, token, and owner.', 'Analyze the proxy contract (if applicable) and its interaction with this contract to understand upgradeability implications.', 'Ensure that any upgrade process considers the state of the Yearn vault and underlying token to avoid data corruption or unexpected behavior.', 'Check that the `_token.safeApprove(address(vault), type(uint256).max)` call in `initialize` is acceptable from a security perspective, given the unlimited approval.']}, {'Area': 'Vault Compatibility', 'Tasks': ['Research and document the potential impacts of using unsupported Yearn Vault API versions.', 'Investigate whether the excluded Yearn vault API versions (0.3.2, 0.3.3, 0.3.4) have known vulnerabilities or incompatibilities that justify the checks.', 'Evaluate the risk of future Yearn vault API updates rendering this contract incompatible and propose a mechanism for handling such scenarios (e.g., upgradeable logic, configurable vault address).', 'Consider adding a check for minimum required Yearn Vault API version, in addition to excluding known incompatible ones.']}, {'Area': 'Withdrawal Loss Tolerance', 'Tasks': ['Confirm that the `maxLosses` value is interpreted as basis points (1/100th of 1%).', 'Analyze the potential impact of setting a non-zero `maxLosses` on user withdrawals, particularly during periods of high volatility or impermanent loss in the Yearn vault.', 'Consider the impact of `maxLosses` during a Yearn vault exploit; could setting this higher than zero increase the amount lost by users of the YieldSource contract?', ""Review the Yearn vault's documentation to understand how `maxLosses` is used during withdrawals and potential edge cases."", 'If maxLosses is zero, clarify if the Yearn Vault function still charges fees or if those fees would be errors that would cause a revert. If a revert occurs, what is the best way to handle it?']}, {'Area': 'Reentrancy Vulnerabilities', 'Tasks': ['Although `nonReentrant` modifier is used, carefully review all external calls, particularly interactions with the Yearn vault (`vault.deposit()`, `vault.withdraw()`) and token contract (`token.safeTransfer`, `token.safeTransferFrom`), to ensure no reentrancy attack vectors exist.', ""Consider cross-function reentrancy, where one protected function calls another, and that second function has a vulnerability that is bypassed by the first function's reentrancy guard."", 'Simulate potential reentrancy scenarios to verify the effectiveness of the `nonReentrant` modifier.']}, {'Area': 'Access Control', 'Tasks': ['Verify that only the owner can call the `setMaxLosses` function.', 'Evaluate the potential impact of a compromised owner account and propose mitigation strategies (e.g., multi-sig, time-lock).', 'Confirm that there are no unintended access control loopholes that could allow unauthorized users to modify critical contract parameters.']}, {'Area': 'Sponsor Function', 'Tasks': ['Clarify the intended use case for the `sponsor` function and document it clearly.', 'Analyze the potential impact of large `sponsor` deposits on existing share holders, especially in scenarios with low or zero `totalSupply()`.', 'Consider whether there should be a mechanism to distribute the benefits of `sponsor` deposits more equitably among share holders (e.g., minting shares to a community fund).']}, {'Area': 'Gas Optimization', 'Tasks': [""Review the contract's code for potential gas inefficiencies, such as redundant calculations or unnecessary state variable reads/writes."", 'Consider caching frequently used values (e.g., `_pricePerYShare()`) to reduce gas consumption.', 'Profile gas usage of key functions (`supplyTokenTo`, `redeemToken`) and identify areas for optimization.']}, {'Area': 'SafeERC20 Usage', 'Tasks': ['Verify that `SafeERC20Upgradeable` is used consistently for all ERC20 token interactions.', 'Double-check the return values of `safeTransfer` and `safeTransferFrom` are correctly handled (even though SafeERC20 reverts on failure), and that no assumptions are made about successful transfers without checking return data (which is required for some tokens).', 'Consider the implications of approving the Yearn vault with `type(uint256).max`. While convenient, it poses a risk if the Yearn vault is compromised. Evaluate if a smaller, more specific approval amount would be more secure, bearing in mind Yearn V2 vaults can have increasing deposit limits over time.']}]}","{'ReviewingTheCode': ""The contract `YearnV2YieldSource` acts as an adapter and yield source built on top of a Yearn V2 vault (`IYVaultV2`). It allows users to deposit an underlying ERC20 token (`token`) and receive shares in this contract. This contract, in turn, deposits the underlying tokens into the specified Yearn vault to generate yield. It implements the `IYieldSource` interface, is itself an ERC20 token representing claims on the deposited assets + yield, is ownable, uses reentrancy protection, and leverages OpenZeppelin's upgradeable contracts framework and safety libraries (SafeMath, SafeERC20). Key features include deposit (`supplyTokenTo`), withdrawal (`redeemToken`), sponsoring (direct deposit without share minting), and configurable loss tolerance (`maxLosses`) for Yearn vault withdrawals."", 'IdentifyingKeyComponents': {'ContractName': 'YearnV2YieldSource', 'Purpose': 'To serve as a standardized yield source (`IYieldSource`) by wrapping a specific Yearn V2 Vault. It abstracts the interaction with the Yearn vault, manages deposits and withdrawals, and represents user deposits plus accrued yield as ERC20 shares of this contract.', 'InheritanceAndImports': {'InheritsFrom': ['IYieldSource', 'ERC20Upgradeable', 'OwnableUpgradeable', 'ReentrancyGuardUpgradeable'], 'Imports': ['../interfaces/IYieldSource.sol', '../external/yearn/IYVaultV2.sol', '@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol', '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol']}, 'StateVariables': [{'Name': 'vault', 'Type': 'IYVaultV2', 'Purpose': 'Stores the instance of the underlying Yearn V2 vault contract.'}, {'Name': 'token', 'Type': 'IERC20Upgradeable', 'Purpose': 'Stores the instance of the underlying ERC20 token that is deposited into the Yearn vault.'}, {'Name': 'maxLosses', 'Type': 'uint256', 'Purpose': 'Maximum acceptable loss percentage (likely in basis points, e.g., 100 = 1%) when withdrawing from the Yearn vault. Defaults to 0.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the contract state, setting the vault, token, owner, and approving the vault to spend the token. Includes checks for vault compatibility.', 'Parameters': ['IYVaultV2 _vault', 'IERC20Upgradeable _token'], 'Returns': []}, {'Name': 'setMaxLosses', 'Visibility': 'external', 'Purpose': 'Allows the owner to set the maximum loss tolerance for vault withdrawals.', 'Parameters': ['uint256 _maxLosses'], 'Returns': []}, {'Name': 'depositToken', 'Visibility': 'external view override', 'Purpose': 'Returns the address of the underlying token used for deposits, fulfilling the IYieldSource interface.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balanceOfToken', 'Visibility': 'external override', 'Purpose': 'Calculates and returns the underlying token balance corresponding to the shares held by a specific address in this contract.', 'Parameters': ['address addr'], 'Returns': ['uint256']}, {'Name': 'supplyTokenTo', 'Visibility': 'external override', 'Purpose': 'Handles user deposits. User transfers `_amount` of `token`, and `shares` are minted to the `to` address. The contract then deposits the received tokens into the Yearn vault.', 'Parameters': ['uint256 _amount', 'address to'], 'Returns': []}, {'Name': 'redeemToken', 'Visibility': 'external override', 'Purpose': 'Handles user withdrawals. User specifies the `amount` of underlying token to redeem, the corresponding `shares` are burned, and the contract withdraws from the Yearn vault to transfer the token back to the user.', 'Parameters': ['uint256 amount'], 'Returns': ['uint256 withdrawnAmount']}, {'Name': 'sponsor', 'Visibility': 'external', 'Purpose': 'Allows anyone to deposit `token` into the contract, which is then deposited into the Yearn vault. This increases the total assets without minting new shares, effectively boosting the value per share for existing holders.', 'Parameters': ['uint256 amount'], 'Returns': []}, {'Name': '_depositInVault', 'Visibility': 'internal', 'Purpose': ""Helper function to deposit the contract's current balance of `token` into the Yearn vault. Ensures sufficient allowance first."", 'Parameters': [], 'Returns': ['uint256 (vault shares received, though unused by callers)']}, {'Name': '_withdrawFromVault', 'Visibility': 'internal', 'Purpose': 'Helper function to withdraw a specified `amount` of the underlying `token` from the Yearn vault, respecting the `maxLosses` parameter.', 'Parameters': ['uint amount'], 'Returns': ['uint256 (actual amount withdrawn)']}, {'Name': '_balanceOfYShares', 'Visibility': 'internal view', 'Purpose': ""Returns the contract's balance of shares in the underlying Yearn vault."", 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_pricePerYShare', 'Visibility': 'internal view', 'Purpose': 'Returns the current price per share from the Yearn vault.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_balanceOfToken', 'Visibility': 'internal view', 'Purpose': ""Returns the contract's current balance of the underlying `token` held directly by the contract."", 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_totalAssetsInToken', 'Visibility': 'internal view', 'Purpose': 'Calculates the total value of assets managed by the contract (direct balance + vault balance) in terms of the underlying `token`.', 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_vaultDecimals', 'Visibility': 'internal view', 'Purpose': ""Returns the decimals used by the Yearn vault's shares."", 'Parameters': [], 'Returns': ['uint256']}, {'Name': '_tokenToYShares', 'Visibility': 'internal view', 'Purpose': 'Converts an amount of the underlying `token` to the equivalent amount of Yearn vault shares.', 'Parameters': ['uint256 tokens'], 'Returns': ['uint256']}, {'Name': '_ySharesToToken', 'Visibility': 'internal view', 'Purpose': 'Converts an amount of Yearn vault shares to the equivalent amount of the underlying `token`.', 'Parameters': ['uint256 yShares'], 'Returns': ['uint256']}, {'Name': '_tokenToShares', 'Visibility': 'internal view', 'Purpose': ""Converts an amount of the underlying `token` to the equivalent amount of this contract's shares."", 'Parameters': ['uint256 tokens'], 'Returns': ['uint256 shares']}, {'Name': '_sharesToToken', 'Visibility': 'internal view', 'Purpose': ""Converts an amount of this contract's shares to the equivalent amount of the underlying `token`."", 'Parameters': ['uint256 shares'], 'Returns': ['uint256 tokens']}, {'Name': 'areEqualStrings', 'Visibility': 'internal pure', 'Purpose': 'Helper function to compare two strings.', 'Parameters': ['string memory a', 'string memory b'], 'Returns': ['bool']}, {'Name': 'nonReentrant', 'Visibility': 'modifier', 'Purpose': 'Prevents reentrant calls to the function it modifies.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyOwner', 'Visibility': 'modifier', 'Purpose': 'Restricts function execution to the contract owner.', 'Parameters': [], 'Returns': []}, {'Name': 'initializer', 'Visibility': 'modifier', 'Purpose': 'Ensures a function can only be called once during initialization (for upgradeable contracts).', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['Interacts with the specified Yearn V2 Vault (`IYVaultV2`) contract to deposit/withdraw funds, get price per share, balance, decimals, API version, etc.', 'Interacts with the underlying ERC20 token (`IERC20Upgradeable`) contract to transfer tokens (`safeTransferFrom`, `safeTransfer`), check balances (`balanceOf`), manage approvals (`safeApprove`), and check allowances (`allowance`).'], 'SpecialMechanisms': ['**Upgradeable Contract:** Uses OpenZeppelin Upgradeable contracts and the `initializer` pattern, indicating deployment via a proxy.', '**Yield Aggregation Adapter:** Wraps a Yearn V2 Vault, providing a standardized `IYieldSource` interface.', '**Internal Share Token:** Acts as an ERC20 token itself, where shares represent proportional claims on the total assets managed (primarily those deposited in the Yearn vault).', '**Reentrancy Protection:** Uses the `ReentrancyGuardUpgradeable` modifier on external state-changing functions.', '**Safety Libraries:** Employs `SafeMathUpgradeable` for arithmetic operations and `SafeERC20Upgradeable` for token interactions.', '**Sponsorship:** Includes a `sponsor` function allowing for capital injection without minting shares.', '**Loss Tolerance:** Features a configurable `maxLosses` parameter for managing slippage during Yearn vault withdrawals.', '**Vault Version Check:** Performs checks against specific known incompatible Yearn vault API versions during initialization.'], 'Questions': ['What unit does `maxLosses` represent? Basis points (1/100th of 1%) seem likely given the check `_maxLosses <= 10_000`, but confirmation is needed.', 'The vault compatibility check in `initialize` excludes specific older versions. How are newer, potentially incompatible, future versions handled? Is there an assumption of backward compatibility?', 'Are potential minor rounding errors from the multiple division operations in share/token conversion functions (`_tokenToShares`, `_sharesToToken`, etc.) acceptable?', 'Is the primary intended use case for the `sponsor` function documented (e.g., treasury management, donations)?', 'The `_depositInVault` function re-approves `type(uint256).max` if allowance is insufficient. Is the security implication of infinite approval on the vault contract acceptable?']}","{'Findings': [{'Issue': 'Reentrancy Vulnerability During Vault Withdrawal', 'Severity': 'High', 'Description': 'The `_withdrawFromVault` function interacts with the external `vault.withdraw()` function, creating a potential reentrancy point. Although external functions like `redeemToken` use the `nonReentrant` modifier, this protection might not cover callbacks originating from the `vault.withdraw` call itself, especially if the vault or underlying token has malicious callbacks or hooks. An attacker could potentially re-enter the `YearnV2YieldSource` contract during the withdrawal process (before state updates like balance calculation or share burning are complete), manipulating state or draining funds. The risk exists regardless of whether `maxLosses` is zero or non-zero, as different `vault.withdraw` overloads are called.', 'Impact': 'An attacker could potentially drain funds from the contract, withdraw more tokens than entitled, or manipulate internal accounting (like share balances or total assets) by re-entering during the external vault withdrawal call. This could lead to significant loss of funds for users or the protocol.', 'Location': 'YearnV2YieldSource.sol:_withdrawFromVault, YearnV2YieldSource.sol:redeemToken, YearnV2YieldSource.sol:158, YearnV2YieldSource.sol:205, YearnV2YieldSource.sol:207, YearnV2YieldSource.sol:218, YearnV2YieldSource.sol:159, YearnV2YieldSource.sol:127, YearnV2YieldSource.sol:176'}, {'Issue': 'Incorrect Calculation of Withdrawn Amount', 'Severity': 'High', 'Description': ""The `_withdrawFromVault` function calculates the amount withdrawn using `previousBalance.sub(currentBalance)`. This logic is incorrect because the `vault.withdraw` call deposits tokens *into* the contract, meaning `currentBalance` should be greater than `previousBalance`. The correct calculation should be `currentBalance.sub(previousBalance)`. Furthermore, this calculation method is vulnerable to manipulation if the contract's token balance changes between the two balance checks due to external transfers or callbacks (e.g., ERC777 hooks) during the `vault.withdraw` call."", 'Impact': 'The function returns an incorrect (likely zero or underflowing) withdrawn amount. This breaks the `redeemToken` function, causing incorrect token transfers to the user (potentially reverting the transaction or transferring zero tokens) and inaccurate event emissions, leading to loss of funds or contract malfunction.', 'Location': 'YearnV2YieldSource.sol:_withdrawFromVault, YearnV2YieldSource.sol:201-210, YearnV2YieldSource.sol:134, YearnV2YieldSource.sol:226-229, YearnV2YieldSource.sol:204'}, {'Issue': 'Potential Front-Running to Manipulate Share Price', 'Severity': 'Medium', 'Description': ""The calculation of shares in `supplyTokenTo` and `redeemToken` depends on `_totalAssetsInToken()`, which relies on `vault.pricePerShare()` and the vault's balance. An attacker can manipulate `_totalAssetsInToken` by front-running deposit (`supplyTokenTo`) or withdrawal (`redeemToken`) transactions with small deposits or donations directly to the vault. This manipulation can artificially inflate or deflate the perceived asset value at the time of conversion, causing legitimate users to receive fewer shares on deposit or fewer underlying tokens on withdrawal than expected."", 'Impact': 'Users may receive an unfair amount of shares when supplying tokens or an unfair amount of underlying tokens when redeeming shares, leading to financial losses due to manipulated exchange rates within the Yield Source.', 'Location': 'YearnV2YieldSource.sol:supplyTokenTo, YearnV2YieldSource.sol:redeemToken, YearnV2YieldSource.sol:_tokenToShares, YearnV2YieldSource.sol:_sharesToToken, YearnV2YieldSource.sol:105, YearnV2YieldSource.sol:127, YearnV2YieldSource.sol:228, YearnV2YieldSource.sol:241'}, {'Issue': 'Stale or Manipulated `pricePerShare` Leading to Incorrect Calculations', 'Severity': 'Medium', 'Description': 'The contract relies heavily on `vault.pricePerShare()` for conversions between the underlying token and shares (`_tokenToShares`, `_sharesToToken`) and yShares (`_tokenToYShares`, `_ySharesToToken`). If the `pricePerShare` reported by the vault is stale (not recently updated) or manipulated externally, all conversion calculations within the Yield Source will be inaccurate.', 'Impact': 'Users may receive significantly incorrect amounts of shares upon deposit or underlying tokens upon redemption, leading to loss of funds. If the price can be manipulated, it could be exploited to drain value from the contract.', 'Location': 'YearnV2YieldSource.sol:_pricePerYShare, YearnV2YieldSource.sol:_tokenToYShares, YearnV2YieldSource.sol:_ySharesToToken, YearnV2YieldSource.sol:_tokenToShares, YearnV2YieldSource.sol:_sharesToToken'}, {'Issue': 'Incomplete Vault Version Compatibility Check', 'Severity': 'Medium', 'Description': ""The `initialize` function checks for specific incompatible Yearn vault API versions ('0.3.2', '0.3.3', '0.3.4') using a denylist approach. This check is only performed once during initialization and does not guarantee compatibility with future vault versions or even current versions not explicitly listed. Using an incompatible vault could lead to unexpected behavior as the Yield Source relies on specific vault function signatures and behaviors."", 'Impact': 'The contract might be deployed with an incompatible Yearn vault version, or a future vault upgrade could break compatibility, leading to unexpected behavior, failed transactions, or potential loss of funds due to reliance on incorrect vault APIs.', 'Location': 'YearnV2YieldSource.sol:initialize, YearnV2YieldSource.sol:81, YearnV2YieldSource.sol:65-67'}, {'Issue': 'Unsafe Token Approval Practices', 'Severity': 'Medium', 'Description': 'The contract grants an unbounded (`type(uint256).max`) allowance to the vault contract in `initialize` and potentially resets it in `_depositInVault`. Unbounded approvals are generally discouraged as they allow the approved contract (the vault) to withdraw the entire token balance if compromised. Additionally, the approval logic in `_depositInVault` (checking allowance and re-approving if less than balance) is redundant given the initial max approval and is susceptible to race conditions where front-running transactions could interfere with the approval amount, potentially causing deposits to fail.', 'Impact': 'If the vault contract is compromised or malicious, it could drain all underlying tokens held by the Yield Source contract due to the unbounded allowance. Race conditions in the deposit approval logic could lead to failed user transactions and denial of service.', 'Location': 'YearnV2YieldSource.sol:initialize, YearnV2YieldSource.sol:_depositInVault, YearnV2YieldSource.sol:78, YearnV2YieldSource.sol:153, YearnV2YieldSource.sol:203-205, YearnV2YieldSource.sol:192, YearnV2YieldSource.sol#138'}, {'Issue': 'Potential Integer Overflow/Underflow in Token/yShare Conversions', 'Severity': 'Medium', 'Description': 'The `_tokenToYShares` and `_ySharesToToken` functions perform conversions involving multiplication and division (`tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare())` and `yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals())`). While SafeMath is used for individual operations, the intermediate result of the multiplication (e.g., `tokens.mul(10 ** _vaultDecimals())`) could potentially exceed the maximum value of `uint256` before the division occurs, especially if token amounts, vault decimals, or `pricePerShare` are very large. This would lead to an overflow/underflow and an incorrect conversion result.', 'Impact': 'Incorrect calculation of yShares or token amounts during conversions, potentially leading to users receiving incorrect amounts upon deposit/withdrawal, loss of funds, or transaction reverts.', 'Location': 'YearnV2YieldSource.sol:_tokenToYShares, YearnV2YieldSource.sol:_ySharesToToken, YearnV2YieldSource.sol:239, YearnV2YieldSource.sol:245, YearnV2YieldSource.sol:256, YearnV2YieldSource.sol:262, YearnV2YieldSource.sol#192, YearnV2YieldSource.sol#200'}, {'Issue': 'Lack of Slippage Control During Withdrawals', 'Severity': 'Medium', 'Description': ""The `redeemToken` function, via `_withdrawFromVault`, withdraws underlying assets from the Yearn vault based on a calculated share amount. However, it lacks a user-defined slippage parameter to ensure the user receives a minimum expected amount of tokens. If the `pricePerShare` of the vault decreases significantly between transaction submission and execution (due to market volatility or manipulation), the user might receive far fewer tokens than anticipated. While the `maxLosses` parameter offers some protection when non-zero, it's owner-controlled and not used when zero."", 'Impact': ""Users may suffer significant losses when redeeming shares if the vault's share price drops unexpectedly, as they are not protected against slippage. This can lead to receiving fewer underlying tokens than expected."", 'Location': 'YearnV2YieldSource.sol:redeemToken, YearnV2YieldSource.sol:_withdrawFromVault, YearnV2YieldSource.sol:194, YearnV2YieldSource.sol:161'}, {'Issue': 'Inconsistent Handling of `maxLosses` Parameter', 'Severity': 'Medium', 'Description': ""The `_withdrawFromVault` function calls different overloads of the `vault.withdraw` function based on whether the `maxLosses` state variable is zero or non-zero (`vault.withdraw(yShares)` vs `vault.withdraw(yShares, address(this), maxLosses)`). This inconsistent logic means the withdrawal behavior, particularly regarding slippage tolerance and loss handling within the vault, can differ significantly depending on the `maxLosses` setting. This could lead to unexpected reverts or losses for users if the two vault functions have different underlying mechanics or requirements (e.g., one might revert on minor slippage if `maxLosses` isn't used)."", 'Impact': ""Users may experience inconsistent withdrawal behavior. Transactions might unexpectedly revert due to slippage when `maxLosses` is zero, or users might incur losses they weren't anticipating depending on the vault's implementation of the different `withdraw` function signatures. This inconsistency obscures the actual loss protection provided."", 'Location': 'YearnV2YieldSource.sol:_withdrawFromVault, YearnV2YieldSource.sol:203-207'}, {'Issue': 'Centralized Control Over Maximum Withdrawal Losses', 'Severity': 'Medium', 'Description': 'The `maxLosses` parameter, which dictates the acceptable slippage or loss during vault withdrawals when calling `vault.withdraw(..., maxLosses)`, is set exclusively by the contract owner via the `setMaxLosses` function. Users have no control over this parameter.', 'Impact': 'Users are exposed to the risk tolerance set by the owner. A high `maxLosses` value could expose users to significant unexpected losses during vault withdrawals, while a very low value might cause withdrawals to fail frequently in volatile conditions. This centralization reduces user control over their withdrawal risk.', 'Location': 'YearnV2YieldSource.sol:setMaxLosses'}, {'Issue': 'Inconsistent Decimal Handling Between Token and Vault', 'Severity': 'Medium', 'Description': ""The contract performs conversions (`_tokenToYShares`, `_ySharesToToken`) using `_vaultDecimals()` but implicitly assumes the underlying `token` might have a different number of decimals (often 18). If the actual decimals of the underlying token and the vault's internal representation differ, the calculations involving `10 ** _vaultDecimals()` and `_pricePerYShare` can lead to significant precision errors or incorrect conversion rates."", 'Impact': 'Incorrect token-to-share or share-to-token conversions can lead to users receiving inaccurate amounts during deposits or withdrawals, potentially causing loss of funds, especially if decimal differences are large.', 'Location': 'YearnV2YieldSource.sol:_tokenToYShares, YearnV2YieldSource.sol:_ySharesToToken, YearnV2YieldSource.sol:_vaultDecimals, YearnV2YieldSource.sol#192, YearnV2YieldSource.sol#200'}, {'Issue': 'Potential Loss of Precision in Share Calculation (`_tokenToShares` / `_sharesToToken`)', 'Severity': 'Low', 'Description': ""The `_tokenToShares` and `_sharesToToken` functions calculate PT shares based on the contract's total supply and total underlying assets. These calculations involve multiplication and division (`tokens.mul(totalSupply()).div(_totalAssetsInToken())` and `shares.mul(_totalAssetsInToken()).div(totalSupply())`) which can lead to loss of precision due to integer division (rounding errors), especially when dealing with large numbers or when the ratio results in fractional shares."", 'Impact': 'Users might receive slightly fewer shares or tokens than mathematically expected due to rounding down during integer division. This can lead to minor discrepancies or dust amounts accumulating over time.', 'Location': 'YearnV2YieldSource.sol:_tokenToShares, YearnV2YieldSource.sol:_sharesToToken, YearnV2YieldSource.sol#214, YearnV2YieldSource.sol#228'}, {'Issue': 'Missing Zero Address Check for Recipient in `supplyTokenTo`', 'Severity': 'Low', 'Description': 'The `supplyTokenTo` function mints shares to a specified `to` address but does not validate if this address is the zero address (`address(0)`). Sending tokens or shares to the zero address effectively burns them.', 'Impact': 'If `supplyTokenTo` is called with the zero address as the recipient due to user error or integration issues, the newly minted shares (representing the deposited value) will be irrecoverably lost.', 'Location': 'YearnV2YieldSource.sol:supplyTokenTo, YearnV2YieldSource.sol#97'}, {'Issue': 'Missing Zero Amount Checks in Core Functions', 'Severity': 'Low', 'Description': 'The `supplyTokenTo` and `redeemToken` functions do not explicitly check if the input amount (`_amount` or `amount`) is zero. While underlying ERC20 transfers or internal mint/burn functions might handle zero amounts safely, allowing these operations can lead to unnecessary gas consumption and potential edge cases.', 'Impact': 'Users can accidentally or intentionally initiate transactions with zero amounts, wasting gas. While likely not directly exploitable, adding zero amount checks improves clarity and prevents unnecessary operations.', 'Location': 'YearnV2YieldSource.sol:supplyTokenTo, YearnV2YieldSource.sol:redeemToken, YearnV2YieldSource.sol:178, YearnV2YieldSource.sol:162, YearnV2YieldSource.sol:176'}, {'Issue': 'Lack of Input Validation for `_amount` in `supplyTokenTo`', 'Severity': 'Low', 'Description': 'The `supplyTokenTo` function does not validate that the input `_amount` is greater than zero. While the subsequent `token.safeTransferFrom` would likely handle this or revert if the amount is zero or invalid, adding an explicit `require(_amount > 0)` check can prevent unnecessary gas usage and clarify intent.', 'Impact': 'Transactions with `_amount` as zero will consume gas before potentially reverting or completing uselessly.', 'Location': 'YearnV2YieldSource.sol:178'}, {'Issue': 'Inconsistent Handling of Initial Supply/Empty Vault State', 'Severity': 'Low', 'Description': 'The `_tokenToShares` and `_sharesToToken` functions handle the initial deposit (`totalSupply() == 0`) by returning a 1:1 conversion (`tokens` or `shares`). This implicitly assumes the underlying Yearn vault is also empty or that the initial share price is exactly 1. If the vault already contains assets or has a non-1 initial price-per-share when the first Yield Source deposit occurs, this 1:1 conversion will be incorrect.', 'Impact': 'The first depositor might receive an incorrect (potentially unfair) amount of shares relative to their deposited tokens if the initial vault state is not empty or has a non-unity share price.', 'Location': 'YearnV2YieldSource.sol:_tokenToShares, YearnV2YieldSource.sol:_sharesToToken, YearnV2YieldSource.sol:268, YearnV2YieldSource.sol:279'}, {'Issue': 'Lack of Access Control for `sponsor` Function', 'Severity': 'Low', 'Description': 'The `sponsor` function allows anyone (`msg.sender`) to deposit tokens into the Yield Source contract, which are then deposited into the underlying Yearn vault. There is no access control restricting who can call this function.', 'Impact': 'While seemingly benign (allowing donations), this allows arbitrary addresses to contribute funds that are then managed by the vault. If the vault strategy were malicious or exploitable, this could potentially increase the attack surface or impact, although direct loss from this function alone is unlikely unless contract logic incorrectly assumes it controls all deposits.', 'Location': 'YearnV2YieldSource.sol:sponsor'}, {'Issue': 'Missing Events for Internal Vault Interactions', 'Severity': 'Info', 'Description': 'Critical internal functions that interact with the vault, specifically `_depositInVault` and `_withdrawFromVault`, do not emit events. While external functions like `supplyTokenTo` and `redeemToken` emit events, these lack details about the amounts deposited/withdrawn from the vault itself, or the prevailing `pricePerShare` at the time.', 'Impact': ""Reduced off-chain traceability and auditability of the contract's interactions with the underlying Yearn vault, making debugging and monitoring more difficult."", 'Location': 'YearnV2YieldSource.sol:_depositInVault, YearnV2YieldSource.sol:_withdrawFromVault, YearnV2YieldSource.sol:190, YearnV2YieldSource.sol:201, YearnV2YieldSource.sol:147, YearnV2YieldSource.sol:164'}, {'Issue': 'Hardcoded Limit in `setMaxLosses`', 'Severity': 'Info', 'Description': ""The `setMaxLosses` function includes a hardcoded requirement `_maxLosses <= 10_000`. This limits the owner's ability to set the maximum loss parameter beyond this value (presumably 100% represented in basis points)."", 'Impact': 'Limits the flexibility for the owner to configure the maximum loss tolerance, which might be necessary under certain vault or market conditions. The fixed limit might not be suitable for all scenarios.', 'Location': 'YearnV2YieldSource.sol:setMaxLosses'}, {'Issue': 'Inconsistent Naming Convention in `redeemToken` Event', 'Severity': 'Info', 'Description': 'The `redeemToken` function takes a parameter `amount` (representing underlying tokens to redeem) but calculates `shares` to burn. The emitted `RedeemedToken` event includes `(msg.sender, shares, amount)`. While technically correct, using `amount` for the input token value and also for the output event parameter representing the same input token value, while `shares` is the intermediate calculated value, could be slightly confusing.', 'Impact': 'Minor reduction in code readability and clarity regarding the parameters in the `RedeemedToken` event.', 'Location': 'YearnV2YieldSource.sol:redeemToken, YearnV2YieldSource.sol:182'}], 'IssueNumber': 57, 'OutputList': 20}",303.5404086112976,"### **Comparison of Issue Report and Response List**

---

#### **[H-02] YearnV2YieldSource Wrong Subtraction in Withdraw**

**Report Description**:  
The `_withdrawFromVault` function in the YearnV2YieldSource contract incorrectly calculates the withdrawn amount by subtracting the `currentBalance` from the `previousBalance`. This logic is flawed because the `vault.withdraw` call deposits tokens into the contract, making `currentBalance` greater than `previousBalance`. This results in an integer underflow, causing all withdrawals to fail and preventing users from retrieving their investments.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Calculation of Withdrawn Amount""**.

**Validation**:  
**Correct**. The response accurately identifies the incorrect calculation in the `_withdrawFromVault` function. It correctly explains that the subtraction logic is flawed and highlights the potential for integer underflow, which aligns with the issue report. The response also mentions the impact of this error, including transaction reverts and loss of funds, which is consistent with the report.

---

#### **[M-01] safeApprove() for Yearn Vault May Revert Preventing Deposits Causing DoS**

**Report Description**:  
The `_depositInVault` function uses `safeApprove()` from OpenZeppelin's SafeERC20 library to grant allowance to the Yearn Vault. However, `safeApprove()` reverts if the allowance is changed from a non-zero value, which can occur if the vault's balance limit prevents a full deposit. This behavior can cause deposits to fail, leading to denial-of-service (DoS) for users. The recommended solution is to use `safeIncreaseAllowance` or `safeDecreaseAllowance` instead.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Token Approval Practices""**.

**Validation**:  
**Partially Correct**. The response identifies the use of `safeApprove()` and mentions the risks of unbounded allowances and race conditions. However, it does not explicitly address the specific issue of `safeApprove()` reverting when changing a non-zero allowance, which is the core problem described in the report. While the response covers related risks, it misses the critical detail of the DoS vulnerability caused by `safeApprove()`'s behavior.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] YearnV2YieldSource Wrong Subtraction in Withdraw**

**Partially Correct Matches**:

- **[M-01] safeApprove() for Yearn Vault May Revert Preventing Deposits Causing DoS**

**Missed Issues from Issue Report**:

- *None*

---

### **Conclusion**

The response list effectively covers the high-severity issue **[H-02]** with accurate identification and explanation. However, the medium-severity issue **[M-01]** is only partially addressed, as the response misses the specific DoS vulnerability caused by `safeApprove()` reverting on non-zero allowance changes. Overall, the response list demonstrates good coverage of the issues but could benefit from more detailed analysis of specific edge cases like the one in **[M-01]**.","```
1. Incorrect Calculation of Withdrawn Amount
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Calculation of Withdrawn Amount"".
   - From the ranked list of predictions, this issue appears at **rank 2**.

2. **Calculate Precision at rank 2 (P@2)**:
   - Precision at rank 2 is the number of true positives up to rank 2 divided by 2.
   - There is 1 true positive up to rank 2.
   - \( P@2 = \frac{1}{2} = 0.5 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at its rank.
   - \( AP = 0.5 \).

**Output**:
```
0.5
```"
BagerYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";

/// @title A pooltogether yield source for badger sett
/// @author Steffel Fenix, 0xkarl
contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param amount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.
    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}
",830,83,"[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong
Function `balanceOfToken` When suppling to the BadgerYieldSource, some amount of badger is deposited to badgerSett and one receives badgerSett share tokens in return which are stored in the balances mapping of the user. So far this is correct.
The balanceOfToken function should then return the redeemable balance in badger for the user's badgerSett balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of badgerSett) on the badger in the vault:
balances[addr].mul(
  badger.balanceOf(address(badgerSett))
).div(
  badgerSett.totalSupply()
)

However, badger.balanceOf(address(badgerSett)) is only a small amount of badger that is deployed in the vault (""Sett"") due to most of the capital being deployed to the strategies. Therefore, it under-reports the actual balance:
Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. Badger Docs
Any contract or user calling the balanceOf function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.
 [M-02] Return values of ERC20 transfer and transferFrom are unchecked
In the contracts BadgerYieldSource and SushiYieldSource, the return values of ERC20 transfer and transferFrom are not checked to be true, which could be false if the transferred tokens are not ERC20-compliant (e.g., BADGER). In that case, the transfer fails without being noticed by the calling contract.
If warden's understanding of the BadgerYieldSource is correct, the badger variable should be the BADGER token at address 0x3472a5a71965499acd81997a54bba8d852c6e53d. However, this implementation of BADGER is not ERC20-compliant, which returns false when the sender does not have enough token to transfer (both for transfer and transferFrom). See the source code on Etherscan (at line 226) for more details.
 [M-03] SafeMath not completely used in yield source contracts (overflow) SafeMath is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: 	line 67 in BadgerYieldSource
(amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            )
",3,"pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";



contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    
    
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    
    
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    
    
    
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    
    
    
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}",624,1,2,"{'task_list': [{'Area': 'Arithmetic and Calculation Accuracy', 'Tasks': ['Analyze the `requiredShares` calculation in `redeemToken` (`((amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)`) to confirm its intended behavior (ceiling division or other).', 'Simulate scenarios in `redeemToken` with different values for `amount`, `totalShares`, and `badgerSettBadgerBalance` to understand the impact of `requiredShares.sub(1)` on the withdrawn amount.', 'Compare the values returned by `badgerSett.balance()` (used in `redeemToken`) and `badger.balanceOf(address(badgerSett))` (used in `balanceOfToken`) under different conditions to verify their consistency. Review the code of `badgerSett` to understand how `balance()` is implemented.', 'Assess the potential for precision loss in the integer division within `balanceOfToken` and `redeemToken`.  Calculate the maximum possible loss in realistic scenarios and determine if it is acceptable.', 'Write unit tests to check edge cases and boundary conditions for the calculation of `requiredShares` and the subsequent share withdrawal in `redeemToken`.']}, {'Area': 'Share Accounting and Balance Consistency', 'Tasks': ['Verify that the `balances` mapping accurately reflects the shares owned by each user within the `BadgerYieldSource` contract. Trace the flow of shares from deposit to redemption.', ""Analyze the impact of the potentially incorrect `requiredSharesBalance` calculation in `redeemToken` on the user's `balances[msg.sender]`. Write a test case to demonstrate the scenario where user ends up with incorrect `balances[msg.sender]`"", 'Audit the `supplyTokenTo` function to ensure that the `balanceDiff` calculation and subsequent update to `balances[to]` are accurate, especially considering potential rounding errors during the deposit into the Sett.', 'Check for any potential inconsistencies between the total supply of the `badgerSett` and the sum of the `balances` mapping in the `BadgerYieldSource` contract.', 'Explore scenarios where a user might manipulate deposits and withdrawals to exploit vulnerabilities in the share accounting mechanism.']}, {'Area': 'External Interactions and Trust Assumptions', 'Tasks': ['Review the interfaces `IBadgerSett` and `IBadger` to fully understand the functions being called and their potential side effects.', 'Evaluate the trust assumptions made regarding the behavior of the `badgerSett` and `badger` contracts. Consider scenarios where these contracts might behave unexpectedly.', 'Check if the contract adequately handles errors or reverts that might occur during calls to `badger.transferFrom`, `badger.approve`, `badgerSett.deposit`, and `badgerSett.withdraw`.', 'Assess the potential impact of changes to the `badgerSett` or `badger` contracts on the functionality of the `BadgerYieldSource` contract.', 'Consider the impact of reentrancy attacks when interacting with external contracts. Analyze the need for reentrancy guards, even if deemed not necessary due to external contracts protecting themselves. Document justification for the final decision.']}, {'Area': 'Security Vulnerabilities', 'Tasks': ['Verify that the use of `SafeMath` is sufficient to prevent arithmetic overflows and underflows in all calculations.', 'Analyze the contract for potential reentrancy vulnerabilities, especially in the `supplyTokenTo` and `redeemToken` functions when interacting with external contracts.', 'Check for any potential denial-of-service (DoS) vulnerabilities, such as those that could arise from extremely large values or unexpected states in the `badgerSett` or `badger` contracts.', ""Assess the contract's vulnerability to front-running attacks, particularly in the `supplyTokenTo` and `redeemToken` functions, and implement mitigation strategies if necessary."", 'Ensure proper input validation for all parameters, especially `amount` in `supplyTokenTo` and `redeemToken`, to prevent unexpected behavior.']}, {'Area': 'Gas Optimization', 'Tasks': ['Identify and eliminate redundant calculations or state variable reads.', 'Optimize the order of operations to minimize gas consumption.', 'Consider using more gas-efficient data types where appropriate.', 'Review the use of immutable variables and constants to reduce storage costs.', 'Assess the gas costs of different execution paths and prioritize optimization efforts accordingly.']}, {'Area': 'Code Quality and Best Practices', 'Tasks': ['Remove the `hardhat/console.sol` import and any associated `console.log` statements before deployment to production.', 'Ensure that the code is well-documented and easy to understand.', 'Follow established Solidity coding conventions and best practices.', 'Write comprehensive unit tests to cover all functionalities and edge cases.', 'Conduct a static analysis of the code using tools like Slither to identify potential vulnerabilities and code quality issues.']}]}","{'ReviewingTheCode': 'The contract `BadgerYieldSource` acts as an adapter for a Badger Sett vault (`IBadgerSett`), making it compliant with the `IYieldSource` interface, likely for integration with systems like PoolTogether. It allows users to deposit Badger tokens (`IBadger`) into the Sett via this contract, tracks their respective shares internally, and allows redemption of the underlying Badger tokens. It uses SafeMath for arithmetic operations.', 'IdentifyingKeyComponents': {'ContractName': 'BadgerYieldSource', 'Purpose': 'To wrap a Badger Sett vault (`IBadgerSett`) and expose it as an `IYieldSource`, allowing deposits and withdrawals of the underlying Badger token (`IBadger`) while tracking user shares.', 'InheritanceAndImports': {'InheritsFrom': ['IYieldSource'], 'Imports': ['IYieldSource', 'SafeMath', 'IBadgerSett', 'IBadger', 'hardhat/console.sol']}, 'StateVariables': [{'Name': 'badgerSett', 'Type': 'IBadgerSett private immutable', 'Purpose': 'Reference to the Badger Sett contract where assets are deposited.'}, {'Name': 'badger', 'Type': 'IBadger private immutable', 'Purpose': 'Reference to the Badger ERC20 token contract, which is the deposit asset.'}, {'Name': 'balances', 'Type': 'mapping(address => uint256) private', 'Purpose': 'Tracks the amount of Badger Sett shares owned by each user *through this contract*.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the immutable references to the Badger Sett and Badger token contracts.', 'Parameters': ['address badgerSettAddr', 'address badgerAddr'], 'Returns': []}, {'Name': 'depositToken', 'Visibility': 'public view override', 'Purpose': 'Returns the address of the underlying token that can be deposited (Badger token). Implements IYieldSource.', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balanceOfToken', 'Visibility': 'public override', 'Purpose': 'Calculates the amount of underlying Badger token corresponding to the shares held by a user within this contract. Implements IYieldSource.', 'Parameters': ['address addr'], 'Returns': ['uint256']}, {'Name': 'supplyTokenTo', 'Visibility': 'public override', 'Purpose': 'Receives Badger tokens from the caller, deposits them into the Badger Sett, and updates the internal share balance for the specified recipient (`to`). Implements IYieldSource.', 'Parameters': ['uint256 amount', 'address to'], 'Returns': []}, {'Name': 'redeemToken', 'Visibility': 'public override', 'Purpose': ""Calculates the required shares for a given amount of underlying Badger token, withdraws those shares from the Badger Sett, updates the caller's internal share balance, and transfers the withdrawn Badger tokens to the caller. Implements IYieldSource."", 'Parameters': ['uint256 amount'], 'Returns': ['uint256']}]}, 'ExternalInteractions': ['IBadgerSett: Calls `totalSupply()`, `balanceOf(address)`, `deposit(uint256)`, `withdraw(uint256)`, `balance()`.', 'IBadger (ERC20): Calls `balanceOf(address)`, `transferFrom(address,address,uint256)`, `approve(address,uint256)`, `transfer(address,uint256)`.', 'SafeMath: Used for uint256 arithmetic.', 'hardhat/console.sol: Potentially used for debugging via `console.log` (should be removed in production).'], 'SpecialMechanisms': ['Adapter Pattern: Adapts `IBadgerSett` to the `IYieldSource` interface.', 'Internal Share Tracking: Uses the `balances` mapping to attribute shares held by this contract in the Badger Sett to individual users.', 'Immutable State Variables: `badgerSett` and `badger` addresses are set once at deployment.', 'SafeMath Usage: Protects against arithmetic overflow/underflow (standard for Solidity < 0.8.0).'], 'Questions': ['The calculation for `requiredShares` in `redeemToken` `((amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)` seems unusual. Is this intended ceiling division or a potential miscalculation? It appears different from standard ceiling division patterns and might calculate shares for `amount + 1`.', 'In `redeemToken`, why is `requiredSharesBalance` calculated as `requiredShares.sub(1)` before calling `badgerSett.withdraw()`? Subtracting 1 seems likely to result in withdrawing fewer shares than necessary, potentially causing the user to receive less than the requested `amount`.', 'What is the difference between `badgerSett.balance()` used in `redeemToken` and `badger.balanceOf(address(badgerSett))` used in `balanceOfToken`? Do they return the same value (total underlying Badger tokens held by the Sett)? Consistency should be ensured.', 'Could precision loss due to integer division in `balanceOfToken` and `redeemToken` calculations be significant?', ""Is there a risk of the user's internal share balance (`balances[msg.sender]`) becoming inaccurate in `redeemToken` due to the potentially incorrect calculation of `requiredSharesBalance`?"", 'The import and potential usage of `hardhat/console.sol` should be removed for production deployment.']}","{'Findings': [{'Issue': 'Incorrect Calculation and Rounding Error in `redeemToken` Leading to Potential Fund Loss or Drain', 'Severity': 'High', 'Description': ""The `redeemToken` function calculates `requiredShares` using `((amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)` and then calculates `requiredSharesBalance` as `requiredShares.sub(1)`. This logic is flawed: the addition before division is an incorrect way to handle rounding, and the subsequent subtraction of 1 significantly underestimates the shares needed. This can cause users to receive fewer underlying tokens than expected (loss of funds). More critically, if the initial calculation results in `requiredShares` being 0 (possible in edge cases or due to manipulation), the `requiredShares.sub(1)` operation will cause an integer underflow, wrapping to a massive value. Although there's a check `if (requiredShares == 0) return 0;`, the subtraction happens *after* this check in some reported versions, potentially allowing a user to withdraw an extremely large amount, draining the contract. The calculation should accurately determine shares without unnecessary additions or subtractions that introduce errors and vulnerabilities."", 'Impact': ""Users may lose funds by receiving fewer tokens than entitled upon redemption due to rounding errors. A potential integer underflow vulnerability could allow an attacker to drain the contract's funds entirely. Incorrect logic leaves dust amounts."", 'Location': 'BadgerYieldSource.sol: redeemToken function'}, {'Issue': 'Potential Integer Overflow in `redeemToken` Calculation', 'Severity': 'Medium', 'Description': 'In the `redeemToken` function, the calculation `amount.mul(totalShares)` could potentially overflow if both `amount` and `totalShares` are very large. If `amount.mul(totalShares)` overflows, the subsequent addition of `totalShares` might still result in a small number, leading to an incorrect and underestimated `requiredShares` value. This could allow a user to withdraw more badger tokens than they are entitled to based on their actual share.', 'Impact': 'An overflow could lead to users withdrawing more tokens than their share allows, causing losses for other users and potentially enabling theft of funds from the contract.', 'Location': 'BadgerYieldSource.sol: redeemToken function - Calculation of requiredShares'}, {'Issue': 'Unnecessary/Unsafe Approval in `supplyTokenTo` Function', 'Severity': 'Medium', 'Description': 'The `supplyTokenTo` function first transfers tokens from the user, then approves the `badgerSett` contract address for the full `amount`. This approval is unnecessary because the subsequent `badgerSett.deposit(amount)` call typically handles the token transfer into the sett. While the `transferFrom` happens first, mitigating some front-running risks related to the approval itself, granting an explicit approval to the `badgerSett` address is redundant and could pose a security risk if the `badgerSett` contract address were ever compromised or contained a vulnerability related to approvals. It also increases gas costs slightly.', 'Impact': ""Slightly increased gas costs. Introduces a potential (though perhaps unlikely given immutability) attack vector if the `badgerSett` contract were compromised, potentially allowing draining of the `BadgerYieldSource`'s badger balance up to the approved amount."", 'Location': 'BadgerYieldSource.sol: supplyTokenTo function'}, {'Issue': 'Missing Zero Address Validation in Constructor', 'Severity': 'Medium', 'Description': 'The constructor accepts `badgerSettAddr` and `badgerAddr` but does not validate that these addresses are not the zero address (0x00...00). Deploying the contract with a zero address for either dependency would likely render the contract non-functional or lead to unexpected reverts during operation, potentially causing issues for users or locking funds if interactions are attempted.', 'Impact': 'Contract may be deployed in a non-functional state, leading to failed transactions, wasted gas, or inability to use the yield source as intended. Potential for unexpected behavior if operations are attempted on a zero address.', 'Location': 'BadgerYieldSource.sol: Constructor'}, {'Issue': 'Potential Reentrancy Vulnerability via External Calls', 'Severity': 'Medium', 'Description': 'The `supplyTokenTo` and `redeemToken` functions make external calls to `badgerSett.deposit()` and `badgerSett.withdraw()` respectively. If the `BadgerSett` contract is malicious or contains a vulnerability allowing reentrancy, an attacker could potentially call back into the `BadgerYieldSource` contract before the state updates (like balance changes) are complete. This could lead to inconsistent states and potential exploits like draining funds.', 'Impact': 'If the external `BadgerSett` contract is vulnerable to reentrancy, an attacker could potentially steal funds or manipulate the state of the `BadgerYieldSource` contract during deposit or redemption.', 'Location': 'BadgerYieldSource.sol: supplyTokenTo and redeemToken functions (external calls to badgerSett)'}, {'Issue': 'Potential Front-Running Vulnerability in `supplyTokenTo` and `redeemToken`', 'Severity': 'Medium', 'Description': ""The `supplyTokenTo` and `redeemToken` functions interact with the external `badgerSett` contract. An attacker could observe pending deposit or redeem transactions in the mempool and execute their own transaction (front-running) to manipulate the state of the `badgerSett` (e.g., its share price or balance) just before the user's transaction executes. This could result in the user receiving fewer shares on deposit or fewer underlying tokens on redemption than expected."", 'Impact': 'Users may experience unfavorable exchange rates when depositing or redeeming due to front-running, leading to potential loss of value.', 'Location': 'BadgerYieldSource.sol: supplyTokenTo and redeemToken functions'}, {'Issue': 'Balance Calculation Susceptible to Manipulation', 'Severity': 'Medium', 'Description': ""The `balanceOfToken` function calculates the underlying token balance represented by shares based on `badgerSett.totalSupply()` and `badger.balanceOf(address(badgerSett))`. If an attacker can manipulate either of these values (e.g., through flash loans affecting the Sett's balance or supply, or manipulating an underlying oracle if the Sett relies on one), they could temporarily inflate or deflate the perceived value of shares. This could be exploited during redemption or potentially in other interacting contracts relying on this view function."", 'Impact': 'An attacker could manipulate the reported share value, potentially allowing them to claim more underlying assets than they are entitled to during redemption, or causing other protocols interacting with this view function to behave incorrectly.', 'Location': 'BadgerYieldSource.sol: balanceOfToken function'}, {'Issue': 'Lack of Slippage Control in `redeemToken`', 'Severity': 'Medium', 'Description': ""The `redeemToken` function calculates the amount of shares to withdraw based on the current state but does not include a parameter for minimum output amount expected. If the state of the `badgerSett` changes significantly (e.g., due to large deposits/withdrawals or underlying asset volatility) between transaction submission and execution, the `badgerSett.withdraw()` call might succeed but return fewer underlying tokens than the user anticipated, or it could revert if the Sett's balance changes unfavorably."", 'Impact': 'Users might receive significantly fewer tokens than expected upon redemption without warning, or their transactions might revert frequently in volatile conditions, leading to poor user experience.', 'Location': 'BadgerYieldSource.sol: redeemToken function'}, {'Issue': 'Potential Division by Zero in `balanceOfToken`', 'Severity': 'Low', 'Description': ""The `balanceOfToken` function performs division by `totalShares` (`badgerSett.totalSupply()`). While it checks if the user's balance (`balances[addr]`) is zero, it does not explicitly check if `totalShares` is zero before the division. If `totalShares` becomes zero (e.g., if all shares are redeemed), subsequent calls to `balanceOfToken` for any address would revert due to division by zero."", 'Impact': 'The `balanceOfToken` view function could become temporarily unusable, causing reverts for callers if the total supply of the badgerSett ever reaches zero.', 'Location': 'BadgerYieldSource.sol: balanceOfToken function'}, {'Issue': 'Lack of Access Control on Public Functions', 'Severity': 'Low', 'Description': 'The `supplyTokenTo` and `redeemToken` functions are public as required by the `IYieldSource` interface and lack specific access control modifiers. While intended for general use, this design assumes that any caller is legitimate. In complex integrations, ensuring that only intended actors (users or specific contracts) interact with these functions might require checks within the functions themselves or in the calling contracts.', 'Impact': 'No direct vulnerability, but increases the attack surface. If the contract were intended to be restricted within a larger system, the lack of explicit access control could lead to unintended interactions or misuse.', 'Location': 'BadgerYieldSource.sol: supplyTokenTo and redeemToken functions'}, {'Issue': 'Missing Event Emissions for Key State Changes', 'Severity': 'Low', 'Description': 'The contract does not emit events for critical operations like depositing (`supplyTokenTo`) and redeeming (`redeemToken`). Events are essential for off-chain services (like block explorers, analytics platforms, and user interfaces) to monitor contract activity, track user balances, and index historical data efficiently.', 'Impact': 'Reduced transparency and auditability. Makes it harder for users and external tools to track deposits, withdrawals, and balance changes related to this yield source.', 'Location': 'BadgerYieldSource.sol: supplyTokenTo, redeemToken functions'}, {'Issue': 'Inconsistent Use of Balance Reporting Methods', 'Severity': 'Low', 'Description': 'The contract uses `badger.balanceOf(address(badgerSett))` in `balanceOfToken` to get the underlying balance, but `badgerSett.balance()` in `redeemToken`. While these should ideally return the same value representing the total underlying tokens held by the Sett, relying on two different methods introduces potential inconsistency if the `BadgerSett` implementation has nuances between these two functions. Best practice suggests using a single consistent method.', 'Impact': 'Potential for minor discrepancies or unexpected behavior if `badgerSett.balance()` and `badger.balanceOf(address(badgerSett))` do not behave identically in all scenarios.', 'Location': 'BadgerYieldSource.sol: balanceOfToken and redeemToken functions'}], 'IssueNumber': 27, 'OutputList': 12}",199.9503960609436,"### **Comparison of Issue Report and Response List**

---

#### **[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong**

**Report Description**:
The `balanceOfToken` function in `BadgerYieldSource` calculates the redeemable balance of `badger` tokens based on the user's `badgerSett` balance. However, it uses `badger.balanceOf(address(badgerSett))`, which only reflects the small reserve of `badger` tokens in the vault, not the total deployed capital in strategies. This under-reports the actual balance, leading to incorrect computations in integrations.

**Match in Response List**:
Matches with the issue titled **""Balance Calculation Susceptible to Manipulation""**.

**Validation**:
**Partially Correct**. The response identifies the issue with the `balanceOfToken` calculation but focuses on potential manipulation rather than the core problem of under-reporting due to ignoring deployed capital in strategies. While the response touches on the calculation's susceptibility to manipulation, it misses the critical detail that the function inherently under-reports balances.

---

#### **[M-02] Return values of ERC20 transfer and transferFrom are unchecked**

**Report Description**:
In `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked. This is particularly problematic for non-ERC20-compliant tokens like `BADGER`, which return `false` on failure instead of reverting. This oversight could allow failed transfers to go unnoticed.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address the unchecked return values of ERC20 `transfer` and `transferFrom` calls, which is a significant security concern.

---

#### **[M-03] SafeMath not completely used in yield source contracts (overflow)**

**Report Description**:
In `BadgerYieldSource`, the calculation `(amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)` does not fully utilize `SafeMath`, potentially leading to arithmetic overflow or underflow. This could result in incorrect share calculations and vulnerabilities.

**Match in Response List**:
Matches with the issue titled **""Potential Integer Overflow in `redeemToken` Calculation""**.

**Validation**:
**Correct**. The response accurately identifies the potential for integer overflow in the `redeemToken` calculation. It explains the risks associated with the arithmetic operation and aligns with Solidity best practices for using `SafeMath` to prevent overflow/underflow vulnerabilities.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-03] SafeMath not completely used in yield source contracts (overflow)**

**Partially Correct Matches**:

- **[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong**

**Missed Issues from Issue Report**:

- **[M-02] Return values of ERC20 transfer and transferFrom are unchecked**

---

### **Analysis of Gaps**

1. **Unchecked ERC20 Return Values**:
   - The response list fails to address the unchecked return values of ERC20 `transfer` and `transferFrom` calls, which is a critical security issue. This oversight could lead to silent failures in token transfers, especially with non-ERC20-compliant tokens like `BADGER`.

2. **Under-Reporting in `balanceOfToken`**:
   - While the response list identifies the susceptibility of the `balanceOfToken` calculation to manipulation, it does not address the core issue of under-reporting due to ignoring deployed capital in strategies. This gap could lead to incorrect integrations and user losses.

### **Recommendations**

1. **Add a Response for Unchecked ERC20 Return Values**:
   - Include a response that highlights the risks of not checking the return values of ERC20 `transfer` and `transferFrom` calls, especially for non-ERC20-compliant tokens.

2. **Clarify the `balanceOfToken` Issue**:
   - Expand the existing response for `balanceOfToken` to address the under-reporting issue caused by ignoring deployed capital in strategies. This will provide a more comprehensive understanding of the vulnerability.

3. **Ensure Full Coverage of Arithmetic Vulnerabilities**:
   - While the response list covers potential integer overflow in `redeemToken`, it should also explicitly mention the importance of using `SafeMath` consistently throughout the contract to prevent arithmetic vulnerabilities.

By addressing these gaps, the response list can provide a more accurate and comprehensive evaluation of the issues in the `BadgerYieldSource` contract.","```
1. Potential Integer Overflow in `redeemToken` Calculation
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is `Potential Integer Overflow in `redeemToken` Calculation`.
   - This issue appears at rank 2 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 2 (\( P@2 \)) is calculated as the number of true positives up to rank 2 divided by the rank itself.
   - Since there is only one true positive up to rank 2, \( P@2 = \frac{1}{2} = 0.5 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 0.5 \).

**Output**:
```
0.5
```"
PrizePool.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";

/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.
/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.
/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens
abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  /// @dev Emitted when an instance is initialized
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  /// @dev Event emitted when controlled token is added
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  /// @dev Emitted when reserve is captured.
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  /// @dev Event emitted when assets are deposited
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  /// @dev Event emitted when timelocked funds are re-deposited
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when interest is awarded to a winner
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are awarded to a winner
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are transferred out
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC721s are awarded to a winner
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  /// @dev Event emitted when assets are withdrawn instantly
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  /// @dev Event emitted upon a withdrawal with timelock
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  /// @dev Event emitted when timelocked funds are swept back to a user
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  /// @dev Event emitted when the Liquidity Cap is set
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  /// @dev Event emitted when the Credit plan is set
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  /// @dev Event emitted when the Prize Strategy is set
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  /// @dev Emitted when credit is minted
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  /// @dev Emitted when credit is burned
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  /// @dev Reserve to which reserve fees are sent
  RegistryInterface public reserveRegistry;

  /// @dev A linked list of all the controlled tokens
  MappedSinglyLinkedList.Mapping internal _tokens;

  /// @dev The Prize Strategy that this Prize Pool is bound to.
  TokenListenerInterface public prizeStrategy;

  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.
  /// For example, if the maxExitFeeMantissa is ""0.1 ether"", then the maximum exit fee for a withdrawal of 100 Dai will be 10 Dai
  uint256 public maxExitFeeMantissa;

  /// @dev The maximum possible timelock duration for a timelocked withdrawal (in seconds).
  uint256 public maxTimelockDuration;

  /// @dev The total funds that are timelocked.
  uint256 public timelockTotalSupply;

  /// @dev The total funds that have been allocated to the reserve
  uint256 public reserveTotalSupply;

  /// @dev The total amount of funds that the prize pool can hold.
  uint256 public liquidityCap;

  /// @dev the The awardable balance
  uint256 internal _currentAwardBalance;

  /// @dev The timelocked balances for each user
  mapping(address => uint256) internal _timelockBalances;

  /// @dev The unlock timestamps for each user
  mapping(address => uint256) internal _unlockTimestamps;

  /// @dev Stores the credit plan for each token.
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  /// @dev Stores each users balance of credit per token.
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  /// @notice Initializes the Prize Pool
  /// @param _controlledTokens Array of ControlledTokens that are controlled by this Prize Pool.
  /// @param _maxExitFeeMantissa The maximum exit fee size
  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  /// @dev Returns the address of the underlying ERC20 asset
  /// @return The address of the asset
  function token() external override view returns (address) {
    return address(_token());
  }

  /// @dev Returns the total underlying balance of all assets. This includes both principal and interest.
  /// @return The underlying balance of assets
  function balance() external returns (uint256) {
    return _balance();
  }

  /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.
  /// @param to The address receiving the tokens
  /// @param amount The amount of timelocked assets to re-deposit
  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  /// @notice Deposit assets into the Prize Pool in exchange for tokens
  /// @param to The address receiving the newly minted tokens
  /// @param amount The amount of assets to deposit
  /// @param controlledToken The address of the type of token the user is minting
  /// @param referrer The referrer of the deposit
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.
  /// @param from The address to redeem tokens from.
  /// @param amount The amount of tokens to redeem for assets.
  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)
  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.
  /// @return The actual exit fee paid
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    // burn the credit
    _burnCredit(from, controlledToken, burnedCredit);

    // burn the tickets
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    // redeem the tickets less the fee
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  /// @notice Limits the exit fee to the maximum as hard-coded into the contract
  /// @param withdrawalAmount The amount that is attempting to be withdrawn
  /// @param exitFee The exit fee to check against the limit
  /// @return The passed exit fee if it is less than the maximum, otherwise the maximum fee is returned.
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.
  /// The timelock is used to ensure that the tickets have contributed their fair share of the prize.
  /// @dev Note that if the user has previously timelocked funds then this contract will try to sweep them.
  /// If the existing timelocked funds are still locked, then the incoming
  /// balance is added to their existing balance and the new timelock unlock timestamp will overwrite the old one.
  /// @param from The address to withdraw from
  /// @param amount The amount to withdraw
  /// @param controlledToken The type of token being withdrawn
  /// @return The timestamp from which the funds can be swept
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    // return the block at which the funds will be available
    return unlockTimestamp;
  }

  /// @notice Adds to a user's timelock balance.  It will attempt to sweep before updating the balance.
  /// Note that this will overwrite the previous unlock timestamp.
  /// @param user The user whose timelock balance should increase
  /// @param amount The amount to increase by
  /// @param timestamp The new unlock timestamp
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    // Sweep the old balance, if any
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    // if the funds should already be unlocked
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  /// @notice Updates the Prize Strategy when tokens are transferred between holders.
  /// @param from The address the tokens are being transferred from (0 if minting)
  /// @param to The address the tokens are being transferred to (0 if burning)
  /// @param amount The amount of tokens being trasferred
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      // first accrue credit for their old balance
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        // if they are sending funds to someone else, we need to limit their accrued credit to their new balance
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    // if we aren't minting
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  /// @notice Returns the balance that is available to award.
  /// @dev captureAwardBalance() should be called first
  /// @return The total amount of assets to be awarded for the current prize
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  /// @notice Captures any available interest as award balance.
  /// @dev This function also captures the reserve fees.
  /// @return The total amount of assets to be awarded for the current prize
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  /// @notice Called by the prize strategy to award prizes.
  /// @dev The amount awarded must be less than the awardBalance()
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of assets to be awarded
  /// @param controlledToken The address of the asset token being awarded
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens
  /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  /// @notice Called by the Prize-Strategy to award external ERC20 prizes
  /// @dev Used to award any arbitrary tokens held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.
  /// @param to The user who is receiving the tokens
  /// @param amount The amount of tokens they are receiving
  /// @param controlledToken The token that is going to be minted
  /// @param referrer The user who referred the minting
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  /// @notice Called by the prize strategy to award external ERC721 prizes
  /// @dev Used to award any arbitrary NFTs held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param externalToken The address of the external NFT token being awarded
  /// @param tokenIds An array of NFT Token IDs to be transferred
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  /// @notice Calculates the reserve portion of the given amount of funds.  If there is no reserve address, the portion will be zero.
  /// @param amount The prize amount
  /// @return The size of the reserve portion of the prize
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts
  /// @param users An array of account addresses to sweep balances for
  /// @return The total amount of assets swept from the Prize Pool
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  /// @notice Sweep available timelocked balances to their owners.  The full balances will be swept to the owners.
  /// @param users An array of owner addresses
  /// @return The total amount of assets swept from the Prize Pool
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    // if there is nothing to do, just quit
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  /// @notice Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  /// @dev Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  /// @return burnedCredit The credit that was burned
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  /// @notice Calculates the early exit fee for the given amount
  /// @param from The user who is withdrawing
  /// @param controlledToken The type of collateral being withdrawn
  /// @param amount The amount of collateral to be withdrawn
  /// @return exitFee The exit fee
  /// @return burnedCredit The user's credit that was burned
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  /// @dev Calculates the early exit fee for the given amount
  /// @param amount The amount of collateral to be withdrawn
  /// @return Exit fee
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    // interest = credit rate * principal * time
    // => time = interest / (credit rate * principal)
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  /// @notice Burns a users credit.
  /// @param user The user whose credit should be burned
  /// @param credit The amount of credit to burn
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  /// @notice Accrues ticket credit for a user assuming their current balance is the passed balance.  May burn credit if they exceed their limit.
  /// @param user The user for whom to accrue credit
  /// @param controlledToken The controlled token whose balance we are checking
  /// @param controlledTokenBalance The balance to use for the user
  /// @param extra Additional credit to be added
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  /// @notice Applies the credit limit to a credit balance.  The balance cannot exceed the credit limit.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The users ticket balance (used to calculate credit limit)
  /// @param creditBalance The new credit balance to be checked
  /// @return The users new credit balance.  Will not exceed the credit limit.
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  /// @notice Calculates the accrued interest for a user
  /// @param user The user whose credit should be calculated.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The user's current balance of the controlled tokens.
  /// @return The credit that has accrued since the last credit update.
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.
  /// @param user The user whose credit balance should be returned
  /// @return The balance of the users credit
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  /// @notice Sets the rate at which credit accrues per second.  The credit rate is a fixed point 18 number (like Ether).
  /// @param _controlledToken The controlled token for whom to set the credit plan
  /// @param _creditRateMantissa The credit rate to set.  Is a fixed point 18 decimal (like Ether).
  /// @param _creditLimitMantissa The credit limit to set.  Is a fixed point 18 decimal (like Ether).
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  /// @notice Returns the credit rate of a controlled token
  /// @param controlledToken The controlled token to retrieve the credit rates for
  /// @return creditLimitMantissa The credit limit fraction.  This number is used to calculate both the credit limit and early exit fee.
  /// @return creditRateMantissa The credit rate. This is the amount of tokens that accrue per second.
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  /// @notice Calculate the early exit for a user given a withdrawal amount.  The user's credit is taken into account.
  /// @param from The user who is withdrawing
  /// @param controlledToken The token they are withdrawing
  /// @param amount The amount of funds they are withdrawing
  /// @return earlyExitFee The additional exit fee that should be charged.
  /// @return creditBurned The amount of credit that will be burned
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    /*
    The credit is used *last*.  Always charge the fees up-front.

    How to calculate:

    Calculate their remaining exit fee.  I.e. full exit fee of their balance less their credit.

    If the exit fee on their withdrawal is greater than the remaining exit fee, then they'll have to pay the difference.
    */

    // Determine available usable credit based on withdraw amount
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    // Determine amount of credit to burn and amount of fees required
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  /// @notice Allows the Governor to set a cap on the amount of liquidity that he pool can hold
  /// @param _liquidityCap The new liquidity cap for the prize pool
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  /// @notice Adds a new controlled token
  /// @param _controlledToken The controlled token to add.  Cannot be a duplicate.
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  /// @notice An array of the Tokens controlled by the Prize Pool (ie. Tickets, Sponsorship)
  /// @return An array of controlled token addresses
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  /// @dev Gets the current time as represented by the current block
  /// @return The timestamp of the current block
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  /// @notice The timestamp at which an account's timelocked balance will be made available to sweep
  /// @param user The address of an account with timelocked assets
  /// @return The timestamp at which the locked assets will be made available
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  /// @notice The balance of timelocked assets for an account
  /// @param user The address of an account with timelocked assets
  /// @return The amount of assets that have been timelocked
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  /// @notice Delegate the votes for a Compound COMP-like token held by the prize pool
  /// @param compLike The COMP-like token held by the prize pool that should be delegated
  /// @param to The address to delegate to 
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  /// @dev Checks if the Prize Pool can receive liquidity based on the current cap
  /// @param _amount The amount of liquidity to be added to the Prize Pool
  /// @return True if the Prize Pool can receive the specified amount of liquidity
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  /// @dev Checks if a specific token is controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  /// @return True if the token is a controlled token, false otherwise
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  /// @notice Determines whether the passed token can be transferred out as an external award.
  /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
  /// prize strategy should not be allowed to move those tokens.
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return The ERC20 asset token
  function _token() internal virtual view returns (IERC20Upgradeable);

  /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
  /// @return The underlying balance of asset tokens
  function _balance() internal virtual returns (uint256);

  /// @notice Supplies asset tokens to the yield source.
  /// @param mintAmount The amount of asset tokens to be supplied
  function _supply(uint256 mintAmount) internal virtual;

  /// @notice Redeems asset tokens from the yield source.
  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed
  /// @return The actual amount of tokens that were redeemed.
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  /// @dev Function modifier to ensure usage of tokens controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  /// @dev Function modifier to ensure caller is the prize-strategy
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}

",10191,1131,"[H-04] withdraw timelock can be circumvented
One can withdraw the entire PrizePool deposit by circumventing the timelock. Assume the user has no credits for ease of computation:
user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This ""mints"" an equivalent amount of timelock and resets _unlockTimestamps[user] = timestamp = blockTime + lockDuration.
user calls withdrawWithTimelockFrom(user, amount=0) again but this time withdrawing 0 amount. This will return a lockDuration of 0 and thus unlockTimestamp = blockTime. The inner _mintTimelock now resets _unlockTimestamps[user] = unlockTimestamp
As if (timestamp <= _currentTime())  is true, the full users amount is now transferred out to the user in the _sweepTimelockBalances call.
Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.
 [M-07] Using transferFrom on ERC721 tokens
In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of safeTransferFrom. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.",2,"pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";




abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  
  RegistryInterface public reserveRegistry;

  
  MappedSinglyLinkedList.Mapping internal _tokens;

  
  TokenListenerInterface public prizeStrategy;

  
  
  uint256 public maxExitFeeMantissa;

  
  uint256 public maxTimelockDuration;

  
  uint256 public timelockTotalSupply;

  
  uint256 public reserveTotalSupply;

  
  uint256 public liquidityCap;

  
  uint256 internal _currentAwardBalance;

  
  mapping(address => uint256) internal _timelockBalances;

  
  mapping(address => uint256) internal _unlockTimestamps;

  
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  
  
  
  
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  
  
  function token() external override view returns (address) {
    return address(_token());
  }

  
  
  function balance() external returns (uint256) {
    return _balance();
  }

  
  
  
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  
  
  
  
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  
  
  
  
  
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  
  
  
  
  
  
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    
    _burnCredit(from, controlledToken, burnedCredit);

    
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  
  
  
  
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  
  
  
  
  
  
  
  
  
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    
    return unlockTimestamp;
  }

  
  
  
  
  
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  
  
  
  
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  
  
  
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  
  
  
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  
  
  
  
  
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  
  
  
  
  
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  
  
  
  
  
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  
  
  
  
  
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  
  
  
  
  
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  
  
  
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  
  
  
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  
  
  
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  
  
  
  
  
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  
  
  
  
  
  
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  
  
  
  
  
  
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  
  
  
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  
  
  
  
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  
  
  
  
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    
    
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  
  
  
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  
  
  
  
  
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  
  
  
  
  
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  
  
  
  
  
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  
  
  
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  
  
  
  
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  
  
  
  
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  
  
  
  
  
  
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    

    
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  
  
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  
  
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  
  
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  
  
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  
  
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  
  
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  
  
  
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  
  
  
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  
  
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  
  
  
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  
  
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  
  
  
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  
  
  
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  
  
  
  
  
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  
  
  function _token() internal virtual view returns (IERC20Upgradeable);

  
  
  function _balance() internal virtual returns (uint256);

  
  
  function _supply(uint256 mintAmount) internal virtual;

  
  
  
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  
  
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}",6300,1,1,"{'task_list': [{'Area': 'Access Control and Authorization', 'Tasks': ['Verify that only the owner can call `setCreditPlanOf`, `setLiquidityCap`, and `setPrizeStrategy` functions.', 'Confirm that `onlyControlledToken` modifier correctly restricts access to functions based on the `_isControlled` check.', 'Ensure the `onlyPrizeStrategy` modifier accurately restricts access to functions intended only for the prize strategy contract.', 'Verify that the `onlyReserve` modifier restricts access to the `withdrawReserve` function to the address returned by `reserveRegistry.lookup()`.', 'Analyze the `compLikeDelegate` function to determine if owner-only access is appropriate and if any restrictions should be added.']}, {'Area': 'Credit System and Early Exit Fees', 'Tasks': ['Analyze the `_calculateEarlyExitFeeLessBurnedCredit` function to ensure the correct calculation of early exit fees and burned credits, especially considering edge cases where `availableCredit > totalExitFee` and the subtraction order.', 'Verify that `_estimateCreditAccrualTime` function correctly calculates the time required to accrue a certain amount of credit and is resistant to division by zero.', 'Investigate potential rounding errors or precision loss in the `FixedPoint` calculations used within the credit system, especially related to `creditRateMantissa` and `creditLimitMantissa`.', 'Analyze the logic in `_calculateCreditBalance` and `_updateCreditBalance` to ensure credits are correctly accrued and burned based on the balance, timestamp, and configured rates.', 'Simulate scenarios where users deposit and withdraw frequently to assess the long-term behavior of the credit system and prevent unintended consequences.']}, {'Area': 'Timelocked Withdrawals and Sweep Functionality', 'Tasks': ['Analyze the `_sweepTimelockBalances` function to ensure that it correctly transfers tokens to users whose timelocks have expired and handles edge cases where the total withdrawal amount is zero.', 'Assess the gas cost of the `_sweepTimelockBalances` function, especially with large user arrays. Consider implementing pagination or other gas optimization techniques to prevent denial-of-service.', 'Verify that the `_mintTimelock` function correctly sets the `unlockTimestamp` and updates the `timelockTotalSupply`.', 'Confirm that the `_calculateTimelockDuration` function accurately calculates the required timelock duration and respects the `maxTimelockDuration` limit.', 'Analyze the interaction between timelocked withdrawals and the credit system to prevent users from exploiting the timelock mechanism to gain unfair advantages.']}, {'Area': 'Liquidity Cap and Deposit/Withdrawal Mechanics', 'Tasks': ['Ensure the `canAddLiquidity` modifier accurately enforces the `liquidityCap` during deposits and timelock deposits.', ""Verify that `depositTo` and `timelockDepositTo` functions correctly mint controlled tokens and update the pool's total supply."", 'Analyze the `withdrawInstantlyFrom` function to prevent users from withdrawing more than their balance and to ensure that exit fees are correctly calculated and applied.', 'Check for potential reentrancy vulnerabilities in the deposit and withdrawal functions, even though `nonReentrant` modifier is used, due to external calls.', 'Confirm that the `_supply` and `_redeem` abstract functions are implemented correctly in derived contracts to maintain accurate accounting of the underlying token balance.']}, {'Area': 'External Interactions and Prize Strategy', 'Tasks': ['Verify that the `reserveRegistry` contract correctly resolves to a valid `ReserveInterface` and that the `calculateReserveFee` function calculates the fee accurately.', 'Assess the trust assumptions and security implications of using an external `prizeStrategy` contract, as it has significant permissions within the PrizePool.', 'Ensure that the `award`, `awardExternalERC20`, `transferExternalERC20`, and `awardExternalERC721` functions can only be called by the `prizeStrategy` contract.', 'Analyze the `beforeTokenTransfer` hook to ensure that it correctly updates credit balances and notifies the prize strategy without introducing vulnerabilities related to token transfers.', 'Examine the implementation of `_canAwardExternal` in derived contracts to prevent awarding of malicious or unintended tokens.', 'Confirm the usage of `safeTransfer` and `safeTransferFrom` from SafeERC20 library to avoid stuck tokens.']}, {'Area': 'Accounting and Award Balance', 'Tasks': ['Verify that the `captureAwardBalance` function correctly calculates yield earned and allocates the reserve fee before updating the `_currentAwardBalance`.', 'Ensure that the `awardBalance` function returns the correct amount of tokens available for awards.', 'Check for potential integer overflow/underflow issues in the calculation of total interest and unaccounted prize balance within the `captureAwardBalance` function.', 'Confirm the correct implementation of `_tokenTotalSupply` in derived contracts and verify the total supply is accounted for across controlled tokens, timelocks, and reserve.']}, {'Area': 'Upgradability Considerations', 'Tasks': ['Review the initialization logic in the `initialize` function to ensure proper setup of state variables and prevent re-initialization vulnerabilities.', 'Verify that all state variables are properly initialized and that the contract is compatible with upgradeable contract patterns.', ""Ensure that the contract's logic can be seamlessly upgraded without disrupting existing user deposits or timelocked withdrawals.""]}]}","{'ReviewingTheCode': ""The contract `PrizePool` is an abstract base contract designed to manage deposits, withdrawals (both instant and timelocked), prize distribution, and associated mechanics like exit fees and credits within a PoolTogether-like system. It interacts with 'controlled' tokens (representing user deposits in the pool), an underlying asset token, a reserve mechanism, and a separate prize strategy contract. It leverages OpenZeppelin upgradeable contracts for ownership, reentrancy protection, safe math, and safe ERC20/721 interactions. Key features include a credit system to potentially offset early withdrawal fees, timelocked withdrawals, prize capture from yield, and management of external token awards."", 'IdentifyingKeyComponents': {'ContractName': 'PrizePool (abstract)', 'Purpose': 'To serve as the core logic for a prize savings pool, managing user deposits, calculating and distributing yield-generated prizes, handling withdrawals with potential fees or timelocks, and interacting with controlled deposit tokens and external reward tokens.', 'InheritanceAndImports': {'InheritsFrom': ['PrizePoolInterface', 'OwnableUpgradeable', 'ReentrancyGuardUpgradeable', 'TokenControllerInterface'], 'Imports': ['@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol', '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol', '@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol', '@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol', '@pooltogether/fixed-point/contracts/FixedPoint.sol', '../external/compound/ICompLike.sol', '../reserve/RegistryInterface.sol', '../reserve/ReserveInterface.sol', '../token/TokenListenerInterface.sol', '../token/TokenListenerLibrary.sol', '../token/ControlledToken.sol', '../token/TokenControllerInterface.sol', '../utils/MappedSinglyLinkedList.sol', './PrizePoolInterface.sol']}, 'StateVariables': [{'Name': 'reserveRegistry', 'Type': 'RegistryInterface', 'Purpose': 'Points to a contract registry to find the current reserve address.'}, {'Name': '_tokens', 'Type': 'MappedSinglyLinkedList.Mapping', 'Purpose': ""Stores the addresses of the 'controlled tokens' managed by this prize pool.""}, {'Name': 'prizeStrategy', 'Type': 'TokenListenerInterface', 'Purpose': 'Address of the contract responsible for prize distribution logic.'}, {'Name': 'maxExitFeeMantissa', 'Type': 'uint256', 'Purpose': 'Maximum percentage (as mantissa) charged as an early withdrawal fee.'}, {'Name': 'maxTimelockDuration', 'Type': 'uint256', 'Purpose': 'Maximum duration (in seconds) a withdrawal can be timelocked.'}, {'Name': 'timelockTotalSupply', 'Type': 'uint256', 'Purpose': 'Total amount of underlying tokens currently locked in timelock withdrawals.'}, {'Name': 'reserveTotalSupply', 'Type': 'uint256', 'Purpose': 'Total amount of underlying tokens accumulated as reserve fees, available for withdrawal by the reserve.'}, {'Name': 'liquidityCap', 'Type': 'uint256', 'Purpose': 'Maximum total supply (deposits + timelocks + reserve) allowed in the pool.'}, {'Name': '_currentAwardBalance', 'Type': 'uint256', 'Purpose': 'Amount of underlying tokens currently available to be awarded as prizes.'}, {'Name': '_timelockBalances', 'Type': 'mapping(address => uint256)', 'Purpose': 'Tracks the amount of tokens each user has in a timelocked state.'}, {'Name': '_unlockTimestamps', 'Type': 'mapping(address => uint256)', 'Purpose': ""Tracks the timestamp when each user's timelocked balance becomes available for sweeping.""}, {'Name': '_tokenCreditPlans', 'Type': 'mapping(address => CreditPlan)', 'Purpose': 'Stores the credit rate and limit configuration for each controlled token.'}, {'Name': '_tokenCreditBalances', 'Type': 'mapping(address => mapping(address => CreditBalance))', 'Purpose': 'Tracks the accrued credit balance for each user per controlled token.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'public', 'Purpose': 'Initializes the contract state (for upgradeable contracts).', 'Parameters': ['_reserveRegistry', '_controlledTokens', '_maxExitFeeMantissa', '_maxTimelockDuration'], 'Returns': []}, {'Name': 'token', 'Visibility': 'external override view', 'Purpose': 'Returns the address of the underlying deposit token (abstract).', 'Parameters': [], 'Returns': ['address']}, {'Name': 'balance', 'Visibility': 'external', 'Purpose': 'Returns the current balance of the underlying token held by the contract (abstract).', 'Parameters': [], 'Returns': ['uint256']}, {'Name': 'canAwardExternal', 'Visibility': 'external view', 'Purpose': 'Checks if a specific external token can be awarded (abstract).', 'Parameters': ['_externalToken'], 'Returns': ['bool']}, {'Name': 'timelockDepositTo', 'Visibility': 'external', 'Purpose': ""Allows depositing into the pool by transferring from a user's timelock balance."", 'Parameters': ['to', 'amount', 'controlledToken'], 'Returns': []}, {'Name': 'depositTo', 'Visibility': 'external override', 'Purpose': 'Deposits underlying tokens into the pool, minting controlled tokens for the recipient.', 'Parameters': ['to', 'amount', 'controlledToken', 'referrer'], 'Returns': []}, {'Name': 'withdrawInstantlyFrom', 'Visibility': 'external override', 'Purpose': 'Withdraws underlying tokens immediately, potentially incurring an exit fee (reduced by credits).', 'Parameters': ['from', 'amount', 'controlledToken', 'maximumExitFee'], 'Returns': ['uint256 exitFee']}, {'Name': 'withdrawWithTimelockFrom', 'Visibility': 'external override', 'Purpose': 'Initiates a timelocked withdrawal, burning controlled tokens and setting an unlock timestamp.', 'Parameters': ['from', 'amount', 'controlledToken'], 'Returns': ['uint256 unlockTimestamp']}, {'Name': 'sweepTimelockBalances', 'Visibility': 'external override', 'Purpose': 'Transfers underlying tokens to users whose timelocks have expired.', 'Parameters': ['users'], 'Returns': ['uint256 totalSwept']}, {'Name': 'beforeTokenTransfer', 'Visibility': 'external override', 'Purpose': 'Hook called by controlled tokens before a transfer, used to update credit balances and notify the prize strategy.', 'Parameters': ['from', 'to', 'amount'], 'Returns': []}, {'Name': 'captureAwardBalance', 'Visibility': 'external override', 'Purpose': 'Calculates yield earned (interest), allocates reserve fee, and updates the awardable balance.', 'Parameters': [], 'Returns': ['uint256 currentAwardBalance']}, {'Name': 'withdrawReserve', 'Visibility': 'external override', 'Purpose': 'Allows the reserve address to withdraw accumulated reserve fees.', 'Parameters': ['to'], 'Returns': ['uint256 redeemedAmount']}, {'Name': 'award', 'Visibility': 'external override', 'Purpose': 'Called by the prize strategy to award prizes by minting controlled tokens to the winner.', 'Parameters': ['to', 'amount', 'controlledToken'], 'Returns': []}, {'Name': 'awardExternalERC20', 'Visibility': 'external override', 'Purpose': 'Called by the prize strategy to award external ERC20 tokens.', 'Parameters': ['to', 'externalToken', 'amount'], 'Returns': []}, {'Name': 'transferExternalERC20', 'Visibility': 'external override', 'Purpose': 'Called by the prize strategy to transfer external ERC20 tokens (e.g., for operational costs).', 'Parameters': ['to', 'externalToken', 'amount'], 'Returns': []}, {'Name': 'awardExternalERC721', 'Visibility': 'external override', 'Purpose': 'Called by the prize strategy to award external ERC721 tokens.', 'Parameters': ['to', 'externalToken', 'tokenIds'], 'Returns': []}, {'Name': 'calculateReserveFee', 'Visibility': 'public view', 'Purpose': 'Calculates the reserve fee based on an amount and the current reserve rate.', 'Parameters': ['amount'], 'Returns': ['uint256 fee']}, {'Name': 'calculateTimelockDuration', 'Visibility': 'external override', 'Purpose': 'Calculates the required timelock duration for a given withdrawal amount based on potential exit fees and credits.', 'Parameters': ['from', 'controlledToken', 'amount'], 'Returns': ['durationSeconds', 'burnedCredit']}, {'Name': 'calculateEarlyExitFee', 'Visibility': 'external override', 'Purpose': 'Calculates the early exit fee and the amount of credit that would be burned for an instant withdrawal.', 'Parameters': ['from', 'controlledToken', 'amount'], 'Returns': ['exitFee', 'burnedCredit']}, {'Name': 'estimateCreditAccrualTime', 'Visibility': 'external override view', 'Purpose': 'Estimates the time needed to accrue a certain amount of credit (interest) on a principal.', 'Parameters': ['_controlledToken', '_principal', '_interest'], 'Returns': ['durationSeconds']}, {'Name': 'balanceOfCredit', 'Visibility': 'external override', 'Purpose': 'Returns the current credit balance of a user for a specific controlled token after accruing.', 'Parameters': ['user', 'controlledToken'], 'Returns': ['uint256']}, {'Name': 'setCreditPlanOf', 'Visibility': 'external override', 'Purpose': 'Sets the credit rate and limit for a controlled token (Owner only).', 'Parameters': ['_controlledToken', '_creditRateMantissa', '_creditLimitMantissa'], 'Returns': []}, {'Name': 'creditPlanOf', 'Visibility': 'external override view', 'Purpose': 'Returns the credit rate and limit for a controlled token.', 'Parameters': ['controlledToken'], 'Returns': ['creditLimitMantissa', 'creditRateMantissa']}, {'Name': 'setLiquidityCap', 'Visibility': 'external override', 'Purpose': 'Sets the maximum liquidity cap for the pool (Owner only).', 'Parameters': ['_liquidityCap'], 'Returns': []}, {'Name': 'setPrizeStrategy', 'Visibility': 'external override', 'Purpose': 'Sets the prize strategy contract address (Owner only).', 'Parameters': ['_prizeStrategy'], 'Returns': []}, {'Name': 'tokens', 'Visibility': 'external override view', 'Purpose': 'Returns an array of all controlled token addresses.', 'Parameters': [], 'Returns': ['address[]']}, {'Name': 'timelockBalanceAvailableAt', 'Visibility': 'external override view', 'Purpose': ""Returns the timestamp when a user's timelocked balance unlocks."", 'Parameters': ['user'], 'Returns': ['uint256 timestamp']}, {'Name': 'timelockBalanceOf', 'Visibility': 'external override view', 'Purpose': 'Returns the amount of tokens a user has in the timelock state.', 'Parameters': ['user'], 'Returns': ['uint256 balance']}, {'Name': 'accountedBalance', 'Visibility': 'external override view', 'Purpose': 'Returns the total balance accounted for by the pool (controlled tokens + timelocks + reserve).', 'Parameters': [], 'Returns': ['uint256 total']}, {'Name': 'compLikeDelegate', 'Visibility': 'external', 'Purpose': 'Allows the owner to delegate voting power of COMP-like tokens held by the contract.', 'Parameters': ['compLike', 'to'], 'Returns': []}, {'Name': 'onlyControlledToken', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions requiring a valid controlled token address.', 'Parameters': ['controlledToken'], 'Returns': []}, {'Name': 'onlyPrizeStrategy', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions that should only be called by the prize strategy contract.', 'Parameters': [], 'Returns': []}, {'Name': 'canAddLiquidity', 'Visibility': 'modifier', 'Purpose': 'Checks if adding a certain amount would exceed the liquidity cap.', 'Parameters': ['_amount'], 'Returns': []}, {'Name': 'onlyReserve', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions that should only be called by the reserve address.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['ControlledTokenInterface (ERC20-like): Calls `controllerMint`, `controllerBurnFrom`, `balanceOf`, `totalSupply`.', 'Underlying Token (IERC20Upgradeable, via abstract `_token()`): Calls `safeTransferFrom`, `safeTransfer`, potentially `balanceOf` (indirectly via `_balance()`).', 'ReserveRegistryInterface: Calls `lookup()` to find the reserve address.', 'ReserveInterface: Calls `reserveRateMantissa()` to calculate reserve fees.', 'PrizeStrategy (TokenListenerInterface): Calls `beforeTokenMint`, `beforeTokenTransfer`. Is called *by* the prize strategy for awarding.', 'External ERC20 Tokens (IERC20Upgradeable): Calls `safeTransfer` for awards/transfers.', 'External ERC721 Tokens (IERC721Upgradeable): Calls `transferFrom` for awards.', 'Compound-like Governance Token (ICompLike): Calls `balanceOf`, `delegate`.', 'OpenZeppelin Libraries/Contracts: Utilizes SafeMath, SafeERC20, Ownable, ReentrancyGuard logic.'], 'SpecialMechanisms': ['Upgradeable Contract Pattern: Uses OpenZeppelin Upgradeable contracts and `initialize` pattern.', 'Abstract Contract: Defines an interface and shared logic, requiring concrete implementations for `_token()`, `_balance()`, `_supply()`, `_redeem()`, `_canAwardExternal()`.', 'Credit System: Accrues credits over time based on deposit balance and rate, which can be used to offset instant withdrawal fees. Involves `CreditPlan`, `CreditBalance`, time-based calculations (`_currentTime`, `timestamp`), and fixed-point math.', 'Timelocked Withdrawals: Allows users to withdraw without fees by locking funds for a calculated duration. Managed via `_timelockBalances`, `_unlockTimestamps`, and `sweepTimelockBalances`.', 'Prize Strategy Separation: Delegates prize calculation and distribution logic to an external `prizeStrategy` contract.', 'Reserve Fee Mechanism: Captures a percentage of the generated yield/interest for a reserve.', 'Liquidity Cap: Enforces a maximum total value locked in the pool.', 'Reentrancy Protection: Uses `ReentrancyGuardUpgradeable`.', 'Token Controller Pattern: The PrizePool acts as the controller for the `ControlledToken`s, authorizing minting and burning.', 'MappedSinglyLinkedList: Used for managing the list of controlled tokens.', 'Fixed-Point Math: Uses `@pooltogether/fixed-point` library for mantissa-based calculations (fees, rates, credits).'], 'Questions': ['What is the exact mechanism for yield generation? The contract calculates yield (`captureAwardBalance`) based on `_balance()` exceeding `_tokenTotalSupply()`, but the source of yield (e.g., lending protocol integration) is implemented in the concrete contract via abstract methods like `_supply()` and `_redeem()`.', 'How are the abstract methods (`_token`, `_balance`, `_supply`, `_redeem`, `_canAwardExternal`) intended to be implemented in derived contracts? Understanding their specifics is crucial.', 'What are the trust assumptions regarding the `prizeStrategy` contract? It has significant permissions (awarding tokens, transferring external assets).', 'How is the `reserveRegistry` and the associated `ReserveInterface` contract managed and secured?', 'Are there potential precision issues or edge cases with the `FixedPoint` math used for credits, fees, and timelock calculations, especially concerning division or time differences?', 'What prevents potential griefing attacks where someone repeatedly triggers `sweepTimelockBalances` with large user arrays, causing high gas costs?', 'The `beforeTokenTransfer` hook updates credit based on balances *before* the transfer completes. Is this interaction robust against potential race conditions or complex transfer scenarios (e.g., flash loans if applicable to controlled tokens)?', 'How does the `compLikeDelegate` function integrate with the overall system purpose? Is it just for managing governance tokens earned passively?', 'Are there limits on the number of controlled tokens that can be added via `_addControlledToken` due to gas costs associated with iterating the list (e.g., in `_tokenTotalSupply`)?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in `sweepTimelockBalances` Function', 'Severity': 'High', 'Description': 'The `_sweepTimelockBalances` function iterates through users, transferring tokens via an external call (`safeTransfer`). If a recipient is a malicious contract, it can call back into the PrizePool before the loop finishes or state updates are complete. Although the function has a `nonReentrant` modifier, this external call can bypass it, allowing manipulation of state (e.g., `timelockTotalSupply`) or multiple withdrawals, potentially draining funds.', 'Impact': 'An attacker could potentially drain the PrizePool by re-entering the contract during the sweeping process, manipulating state, leading to loss of funds for other users.', 'Location': 'PrizePool.sol:_sweepTimelockBalances'}, {'Issue': 'Unbounded Loop in `sweepTimelockBalances` function can cause out of gas', 'Severity': 'High', 'Description': 'The `_sweepTimelockBalances` function iterates through a user-provided array (`users`) without bounds checks. If this array is excessively large, the gas cost can exceed the block limit, causing the transaction to revert. This results in a Denial of Service (DoS), preventing users (including potentially the caller) from sweeping their timelocked balances. Malicious actors or even legitimate high usage could trigger this.', 'Impact': 'Denial of service; Users might not be able to claim their timelocked balances due to out-of-gas errors. Malicious users or a Prize Pool Owner could potentially grief the contract by intentionally providing large arrays.', 'Location': 'PrizePool.sol:_sweepTimelockBalances'}, {'Issue': 'Potential Reentrancy Vulnerability in `withdrawInstantlyFrom` Function', 'Severity': 'High', 'Description': 'The `withdrawInstantlyFrom` function transfers redeemed tokens to the user via an external call (`safeTransfer`). If the recipient (`from`) is a malicious contract, it can call back into the PrizePool after receiving tokens but before the function completes internal state updates. This reentrancy, occurring despite the `nonReentrant` modifier on the entry point, could allow manipulation of balances or withdrawal of more funds than entitled.', 'Impact': 'An attacker could potentially drain the PrizePool by re-entering the contract during the withdrawal process, leading to loss of funds for other users.', 'Location': 'PrizePool.sol:withdrawInstantlyFrom'}, {'Issue': 'Potential Reentrancy Attack in `captureAwardBalance` via Reserve Callback', 'Severity': 'High', 'Description': 'The `captureAwardBalance` function calculates fees by calling `calculateReserveFee`, which may involve an external call to `reserve.reserveRateMantissa`. If the configured Reserve contract is malicious or exploited, this external call could re-enter the PrizePool, potentially manipulating state variables during the fee calculation, leading to incorrect award amounts and potential fund loss.', 'Impact': 'Incorrect calculation of award balance and reserve fee, potential loss of funds, and manipulation of PrizePool state due to reentrancy via the reserve contract.', 'Location': 'PrizePool.sol:captureAwardBalance'}, {'Issue': 'Potential Overflow/Underflow in Credit Calculation Logic', 'Severity': 'Medium', 'Description': ""Credit calculations involve `uint128` for balances/limits and `uint32` for timestamps. While `SafeMathUpgradeable` is used for basic operations, intermediate calculations (like `deltaTime * creditPerSecond` or summing credits) within functions like `_calculateAccruedCredit` and `_calculateCreditBalance` can exceed `uint256`'s maximum value before being truncated down to `uint128` or `uint192`. This truncation of an already overflowed value leads to incorrect results. Large time deltas or high rates exacerbate this. This can result in inaccurate credit balances, affecting withdrawal fees, timelock durations, and potentially allowing users to bypass intended mechanisms."", 'Impact': 'Incorrect credit calculation, potentially leading to users receiving less credit than they should, underflowing balances, or bypassing fees/timelocks, affecting fairness and fund integrity.', 'Location': 'PrizePool.sol:_calculateAccruedCredit, PrizePool.sol:_updateCreditBalance, PrizePool.sol:_calculateCreditBalance, PrizePool.CreditBalance Struct, PrizePool.CreditPlan Struct'}, {'Issue': 'Reliance on Block Timestamp for Time-Sensitive Operations', 'Severity': 'Medium', 'Description': 'The contract uses `block.timestamp` for critical time-sensitive operations like calculating timelock durations, credit accrual, and checking unlock times in functions such as `_currentTime`, `_sweepTimelockBalances`, `_calculateTimelockDuration`, and `withdrawWithTimelockFrom`. Miners have limited ability to manipulate `block.timestamp`, potentially allowing slight alterations to timelock periods or affecting when balances can be swept.', 'Impact': 'Minor manipulation of timelock durations or credit accrual periods is possible, potentially leading to minor discrepancies or unfairness.', 'Location': 'PrizePool.sol:_currentTime, PrizePool.sol:_sweepTimelockBalances, PrizePool.sol:_calculateTimelockDuration, PrizePool.sol:withdrawWithTimelockFrom, PrizePool.sol:_mintTimelock'}, {'Issue': 'Potential Front-Running Vulnerability in `sweepTimelockBalances`', 'Severity': 'Medium', 'Description': ""The `sweepTimelockBalances` function can be front-run. A malicious actor monitoring the mempool can see a pending sweep transaction for a user (or multiple users) and submit their own transaction with higher gas to sweep the target user's balance first. This could be used to steal funds if sweeping for others is possible, or simply allow the attacker to receive their own funds slightly earlier than others in a batch sweep."", 'Impact': ""Minor inconvenience for users whose balances are swept later in a batch transaction, or potential loss of funds if an attacker can front-run and sweep another user's balance to themselves."", 'Location': 'PrizePool.sol:_sweepTimelockBalances'}, {'Issue': 'Unbounded Loop in `awardExternalERC721` can lead to DoS', 'Severity': 'Medium', 'Description': 'The `awardExternalERC721` function iterates through a `tokenIds` array, performing an external `transferFrom` call for each ID. If the array is very large, the cumulative gas cost, especially due to external calls in each iteration, can exceed the block gas limit, causing the transaction to fail and resulting in a Denial of Service (DoS) for awarding these NFTs.', 'Impact': 'Potential denial-of-service (DoS) attack due to high gas consumption when awarding a large number of ERC721 tokens, preventing recipients from receiving NFTs.', 'Location': 'PrizePool.sol:awardExternalERC721'}, {'Issue': 'Lack of Input Validation in `setCreditPlanOf` for Mantissa Values', 'Severity': 'Medium', 'Description': 'The `setCreditPlanOf` function (callable by the owner) sets `creditRateMantissa` and `creditLimitMantissa` without validating if these values are within reasonable bounds (e.g., mantissas typically represent fractions less than or equal to 1, i.e., 1e18). Setting extremely high values could lead to excessive credit accrual or limits, distorting intended mechanics like exit fees and potentially creating economic exploits or breaking core functionality.', 'Impact': ""Setting unreasonable credit parameters could lead to unexpected behavior, potential exploitation of the credit system (e.g., near-zero exit fees or excessively high fees), and disruption of the prize pool's economic balance."", 'Location': 'PrizePool.sol:setCreditPlanOf'}, {'Issue': 'Potential Front-Running Vulnerability in `captureAwardBalance`', 'Severity': 'Medium', 'Description': ""The `captureAwardBalance` function's outcome depends on the current pool state (e.g., `tokenTotalSupply`). A malicious actor could front-run this transaction by making a large deposit or withdrawal just before it executes, manipulating the calculated `unaccountedPrizeBalance` and thus affecting the amount of prize awarded, potentially reducing the captured amount to the detriment of prize winners."", 'Impact': 'Unfair prize distribution, where large depositors or malicious actors can influence and potentially reduce the overall prize pool amount captured.', 'Location': 'PrizePool.sol:captureAwardBalance'}, {'Issue': 'Potential Loss of Funds in `withdrawReserve` due to Redemption Rate', 'Severity': 'Medium', 'Description': 'The `withdrawReserve` function redeems the entire `reserveTotalSupply` using `_redeem(amount)`. If the underlying redemption mechanism implemented in `_redeem` results in a rate where the amount of underlying token received is less than the `amount` of prize pool tokens redeemed (rate < 1:1), the recipient will receive fewer underlying tokens than the `reserveTotalSupply` value implies, leading to a loss of funds intended for the reserve.', 'Impact': 'The receiver of reserve funds may receive less than the intended amount if the redemption rate is unfavorable, resulting in a loss of funds belonging to the reserve.', 'Location': 'PrizePool.sol:withdrawReserve'}, {'Issue': 'Potential Division by Zero in `_estimateCreditAccrualTime`', 'Severity': 'Medium', 'Description': 'The `_estimateCreditAccrualTime` function calculates `accruedPerSecond` based on principal and credit rate. If either the `_principal` or the `creditRateMantissa` for the token is zero, `accruedPerSecond` becomes zero. The function then attempts to divide by `accruedPerSecond`, leading to a division-by-zero error, causing the transaction (and any function calling it, like withdrawal estimations) to revert.', 'Impact': 'Potential denial of service (DoS) if a user attempts an operation (like estimating timelock withdrawal time) under conditions where principal or credit rate is zero, leading to transaction failure.', 'Location': 'PrizePool.sol:_estimateCreditAccrualTime'}, {'Issue': 'Liquidity Cap Can Be Bypassed By Awards', 'Severity': 'Medium', 'Description': 'While the `depositTo` function checks against a `liquidityCap` via the `canAddLiquidity` modifier, the `award` and `awardExternalERC20` functions, used by the prize strategy, can mint new prize pool tokens or transfer external ERC20s into the pool without respecting this cap. This allows the total liquidity to exceed the intended limit set by the owner.', 'Impact': 'The intended liquidity cap can be bypassed by the prize strategy awarding mechanisms, potentially leading to the pool growing larger than desired or configured.', 'Location': 'PrizePool.sol:award, PrizePool.sol:awardExternalERC20'}, {'Issue': 'Lack of checks-effects-interactions pattern in `captureAwardBalance`', 'Severity': 'Low', 'Description': 'The `captureAwardBalance` function updates state (`reserveTotalSupply`) before potentially interacting with external contracts (currently a read call `reserve.reserveRateMantissa`). While not currently exploitable due to `nonReentrant` and the nature of the call, it deviates from the Checks-Effects-Interactions (CEI) pattern. Modifying this function later without adhering to CEI could introduce vulnerabilities if state-modifying external calls were added after effects.', 'Impact': 'Potential for future vulnerabilities if the function is modified incorrectly. Adhering to CEI is a best practice that enhances code safety and maintainability.', 'Location': 'PrizePool.sol:captureAwardBalance'}, {'Issue': 'Lack of slippage control in `withdrawReserve`', 'Severity': 'Low', 'Description': 'The `withdrawReserve` function calls `_redeem(amount)` to convert prize pool tokens to the underlying asset before transferring. This redemption process might be subject to price changes (slippage) between transaction submission and execution. The function lacks a parameter for the reserve recipient to specify acceptable slippage, potentially resulting in receiving fewer underlying tokens than expected during volatile market conditions.', 'Impact': 'The reserve recipient may receive less underlying token than anticipated due to slippage, especially for large withdrawals or during market volatility.', 'Location': 'PrizePool.sol:withdrawReserve'}, {'Issue': 'Possible rounding errors in calculations', 'Severity': 'Low', 'Description': 'Functions like `_calculateEarlyExitFeeLessBurnedCredit` and `_calculateTimelockDuration` use `FixedPoint` math, which involves approximations and potential truncation. This can lead to minor rounding errors, causing users to pay slightly different exit fees or experience slightly different timelock durations than theoretically calculated.', 'Impact': 'Small discrepancies in exit fees and timelock durations due to rounding, potentially leading to minor user dissatisfaction or negligible financial differences.', 'Location': 'PrizePool.sol:_calculateEarlyExitFeeLessBurnedCredit, PrizePool.sol:_calculateTimelockDuration'}, {'Issue': 'Lack of Input Validation in `initialize` for Max Values', 'Severity': 'Low', 'Description': 'The `initialize` function sets `maxExitFeeMantissa` and `maxTimelockDuration` but lacks validation to ensure these owner-set values are within reasonable bounds. Extremely high or zero values could lead to unexpected behavior or render parts of the protocol unusable (e.g., an extremely high exit fee effectively blocking withdrawals).', 'Impact': 'Setting inappropriate maximum values during initialization could disrupt the normal operation of the PrizePool or lead to unintended economic consequences.', 'Location': 'PrizePool.initialize'}, {'Issue': 'Potential Front-Running Vulnerability in Timelock Withdrawals', 'Severity': 'Low', 'Description': 'The `withdrawWithTimelockFrom` function calculates the `unlockTimestamp` based on `block.timestamp`. A miner or sophisticated user could potentially influence the timestamp slightly when mining the transaction, thereby slightly manipulating the resulting timelock duration.', 'Impact': 'Slight manipulation of timelock duration is theoretically possible, although the impact is limited by `maxTimelockDuration`.', 'Location': 'PrizePool.sol:withdrawWithTimelockFrom'}, {'Issue': 'Lack of check for address(0) in `_addControlledToken`', 'Severity': 'Low', 'Description': 'The internal `_addControlledToken` function does not check if the `_controlledToken` address being added is the zero address (`address(0)`). Adding the zero address could cause errors in subsequent functions that interact with the list of controlled tokens or rely on it being a valid contract address.', 'Impact': 'Potential for unexpected behavior and transaction failures if the zero address is inadvertently added as a controlled token.', 'Location': 'PrizePool.sol:_addControlledToken'}, {'Issue': '`beforeTokenTransfer` Hook Logic Might Cause Unexpected Behaviour', 'Severity': 'Low', 'Description': ""The `beforeTokenTransfer` hook attempts to update credit balances based on token transfers. It uses `IERC20Upgradeable(msg.sender).balanceOf(...)` to fetch balances. `msg.sender` here is the token contract calling the hook. This logic might misinterpret balance changes or fetch incorrect balances if the token contract address is not what's expected, potentially leading to inaccurate credit updates (minting/burning)."", 'Impact': 'Potentially inaccurate credit calculation and minting/burning due to flawed logic in the token transfer hook.', 'Location': 'PrizePool.sol:beforeTokenTransfer'}, {'Issue': 'Potential DoS in `captureAwardBalance` due to division by zero in FixedPoint Math', 'Severity': 'Low', 'Description': 'The `captureAwardBalance` function uses `FixedPoint` math involving multiplications and potentially divisions when calculating reserve fees (`FixedPoint.multiplyUintByMantissa`). If edge cases in the reserve rate or balances lead to internal division by zero within the `FixedPoint` library operations, the transaction could revert.', 'Impact': 'The `captureAwardBalance` function might fail unexpectedly due to division by zero within the FixedPoint library, potentially hindering the distribution of awards.', 'Location': 'PrizePool.sol:captureAwardBalance'}, {'Issue': 'Inconsistent Use of `_msgSender()` vs `msg.sender`', 'Severity': 'Low', 'Description': ""The contract codebase inconsistently uses both `_msgSender()` (from OpenZeppelin's Context) and the native `msg.sender`. While functionally similar in standard contexts, using one consistently improves readability and maintainability."", 'Impact': 'Reduced code clarity and consistency. May cause confusion for developers and auditors.', 'Location': 'PrizePool.sol (Throughout contract)'}], 'IssueNumber': 43, 'OutputList': 22}",287.5870521068573,"### **Output**

---

**[H-04] Withdraw Timelock Can Be Circumvented**

**Report Description**:
The `withdrawWithTimelockFrom` function in the `PrizePool` contract allows users to circumvent the timelock mechanism. By first calling `withdrawWithTimelockFrom(user, amount=userBalance)` and then calling `withdrawWithTimelockFrom(user, amount=0)`, a user can reset the `_unlockTimestamps[user]` to the current block timestamp, effectively bypassing the timelock. This allows users to withdraw their entire deposit immediately without waiting for the timelock period to expire. This undermines the protocol's intended mechanics, as users can join the prize pool before awards are distributed and leave immediately after without contributing to the pool's strategy or earning interest.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of circumventing the timelock mechanism in the `withdrawWithTimelockFrom` function. The responses focus on reentrancy vulnerabilities, unbounded loops, and other issues but do not cover the described exploit. This is a significant oversight, as the issue directly impacts the protocol's security and fairness.

---

**[M-07] Using `transferFrom` on ERC721 Tokens**

**Report Description**:
In the `awardExternalERC721` function of the `PrizePool` contract, the `transferFrom` keyword is used instead of `safeTransferFrom` when awarding external ERC721 tokens to winners. If the recipient is a contract that is not aware of incoming ERC721 tokens, the tokens could be permanently locked, as the contract may not implement the necessary `onERC721Received` function to handle the transfer.

**Match in Response List**:
Matches with the issue titled **""Unbounded Loop in `awardExternalERC721` can lead to DoS""**.

**Validation**:
**Partially Correct**. The response identifies the `awardExternalERC721` function and mentions the potential for a Denial of Service (DoS) due to unbounded loops. However, it does not address the core issue of using `transferFrom` instead of `safeTransferFrom`, which could lead to tokens being locked in contracts that do not support ERC721. The response partially covers the issue but misses the critical vulnerability related to token handling.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-07] Using `transferFrom` on ERC721 Tokens**

**Missed Issues from Issue Report**:
- **[H-04] Withdraw Timelock Can Be Circumvented**

---

### **Conclusion**
The response list fails to adequately address the critical issue of circumventing the timelock mechanism in the `withdrawWithTimelockFrom` function, which is a significant security vulnerability. Additionally, while the response list partially covers the issue of using `transferFrom` for ERC721 tokens, it misses the core vulnerability related to token locking. The response list would benefit from a more comprehensive review of the issues to ensure all vulnerabilities are identified and addressed.","```
None.
```",0.0
