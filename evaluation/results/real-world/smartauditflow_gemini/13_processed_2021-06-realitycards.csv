nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
RCTreasury.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";

/// @title Reality Cards Treasury
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {
    /*╔═════════════════════════════════╗
      ║             VARIABLES           ║
      ╚═════════════════════════════════╝*/
    /// @dev orderbook instance, to remove users bids on foreclosure
    IRCOrderbook public orderbook;
    /// @dev nfthub instance, to query current card owner
    IRCNftHubL2 public nfthub;
    /// @dev token contract
    IERC20 public override erc20;
    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet
    address public override bridgeAddress;
    /// @dev address of the Factory so only the Factory can add new markets
    address public override factoryAddress;
    /// @dev so only markets can use certain functions
    mapping(address => bool) public override isMarket;
    /// @dev sum of all deposits
    uint256 public override totalDeposits;
    /// @dev the rental payments made in each market
    mapping(address => uint256) public override marketPot;
    /// @dev sum of all market pots
    uint256 public override totalMarketPots;
    /// @dev rent taken and allocated to a particular market
    uint256 public marketBalance;
    /// @dev a quick check if a uesr is foreclosed
    mapping(address => bool) public override isForeclosed;
    /// @dev to keep track of the size of the rounding issue between rent collections
    uint256 marketBalanceDiscrepancy;

    /// @param deposit the users current deposit in wei
    /// @param rentalRate the daily cost of the cards the user current owns
    /// @param bidRate the sum total of all placed bids
    /// @param lastRentCalc The timestamp of the users last rent calculation
    /// @param lastRentalTime The timestamp the user last made a rental
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    /*╔═════════════════════════════════╗
      ║      GOVERNANCE VARIABLES       ║
      ╚═════════════════════════════════╝*/
    /// @dev only parameters that need to be are here, the rest are in the Factory
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public override minRentalDayDivisor;
    /// @dev max deposit balance, to minimise funds at risk
    uint256 public override maxContractBalance;
    /// @dev whitelist to only allow certain addresses to deposit
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;

    /*╔═════════════════════════════════╗
      ║             SAFETY              ║
      ╚═════════════════════════════════╝*/
    /// @dev if true, cannot deposit, withdraw or rent any cards across all events
    bool public override globalPause;
    /// @dev if true, cannot rent any cards for specific market
    mapping(address => bool) public override marketPaused;

    /*╔═════════════════════════════════╗
      ║            UBER OWNER           ║
      ╚═════════════════════════════════╝*/
    /// @dev high level owner who can change the factory address
    address public override uberOwner;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    constructor(address _tokenAddress) {
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        // at initiation, uberOwner and owner will be the same
        uberOwner = msgSender();

        // initialise adjustable parameters
        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes
        setMaxContractBalance(1000000 ether); // 1m
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @notice check that funds haven't gone missing during this function call
    modifier balancedBooks {
        _;
        // using >= not == in case anyone sends tokens direct to contract
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    /// @notice only allow markets to call these functions
    modifier onlyMarkets {
        require(isMarket[msgSender()], ""Not authorised"");
        _;
    }

    /// @notice only allow orderbook to call these functions
    modifier onlyOrderbook {
        require(msgSender() == address(orderbook), ""Not authorised"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║           ADD MARKETS           ║
      ╚═════════════════════════════════╝*/

    /// @dev so only markets can move funds from deposits to marketPots and vice versa
    function addMarket(address _newMarket) external override {
        require(msgSender() == factoryAddress, ""Not factory"");
        isMarket[_newMarket] = true;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/

    /// @dev all functions should be onlyOwner
    // min rental event emitted by market. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUTOR - PUBLIC  │
      └────────────────────────────────────┘*/

    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    /// @param _newDivisor the divisor to set
    function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

    /// @notice set max deposit balance, to minimise funds at risk
    /// @param _newBalanceLimit the max balance to set in wei
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyOwner
    {
        maxContractBalance = _newBalanceLimit;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  │
      └──────────────────────────────────────────┘*/

    /// @notice if true, cannot deposit, withdraw or rent any cards
    function changeGlobalPause() external override onlyOwner {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    /// @notice if true, cannot make a new rental for a specific market
    function changePauseMarket(address _market) external override onlyOwner {
        require(isMarket[_market], ""This isn't a market"");
        marketPaused[_market] = !marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    /*╔═════════════════════════════════╗
      ║      WHITELIST FUNCTIONS        ║
      ╚═════════════════════════════════╝*/

    /// @notice if true, users must be on the whitelist to deposit
    function toggleWhitelist() external override onlyOwner {
        whitelistEnabled = !whitelistEnabled;
    }

    /// @notice Add a user to the whitelist
    function addToWhitelist(address _user) public override {
        IRCFactory factory = IRCFactory(factoryAddress);
        require(factory.isGovernor(msgSender()), ""Not authorised"");
        isAllowed[_user] = !isAllowed[_user];
    }

    /// @notice Add multiple users to the whitelist
    function batchAddToWhitelist(address[] calldata _users) public override {
        for (uint256 index = 0; index < _users.length; index++) {
            addToWhitelist(_users[index]);
        }
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev deploying and setting a new factory is effectively an upgrade
    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governanace functions

    function setFactoryAddress(address _newFactory) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newFactory != address(0), ""Must set an address"");
        factoryAddress = _newFactory;
    }

    function setOrderbookAddress(address _newOrderbook) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newOrderbook != address(0), ""Must set an address"");
        orderbook = IRCOrderbook(_newOrderbook);
    }

    function setNftHubAddress(address _NFTHubAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_NFTHubAddress != address(0), ""Must set an address"");
        nfthub = IRCNftHubL2(_NFTHubAddress);
    }

    function setTokenAddress(address _newToken) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    function changeUberOwner(address _newUberOwner) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0), ""Must set an address"");
        uberOwner = _newUberOwner;
    }

    /*╔═════════════════════════════════╗
      ║ DEPOSIT AND WITHDRAW FUNCTIONS  ║
      ╚═════════════════════════════════╝*/

    /// @notice deposit tokens into RealityCards
    /// @dev it is passed the user instead of using msg.sender because might be called
    /// @dev ... via contract (newRental) or Layer1->Layer2 bot
    /// @param _user the user to credit the deposit to
    /// @param _amount the amount to deposit, must be approved
    function deposit(uint256 _amount, address _user)
        public
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(isAllowed[msgSender()], ""Not in whitelist"");
        }
        erc20.transferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        if (
            (user[_user].deposit + _amount) >
            (user[_user].bidRate / minRentalDayDivisor)
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
        return true;
    }

    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet
    /// @dev this is the only function where funds leave the contract
    /// @param _amount the amount to withdraw
    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // stpe 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }

    /// @notice to increase the market balance
    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues
    function topupMarketBalance(uint256 _amount) external override {
        erc20.transferFrom(msgSender(), address(this), _amount);
        if (_amount > marketBalanceDiscrepancy) {
            marketBalanceDiscrepancy = 0;
        } else {
            marketBalanceDiscrepancy -= _amount;
        }
        marketBalance += _amount;
    }

    /*╔═════════════════════════════════╗
      ║         ERC20 helpers           ║
      ╚═════════════════════════════════╝*/

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    /*╔═════════════════════════════════╗
      ║        MARKET CALLABLE          ║
      ╚═════════════════════════════════╝*/
    // only markets can call these functions

    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,
    /// @notice ..called by _collectRent in the market
    /// @param _amount amount of rent to pay in wei
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            marketBalanceDiscrepancy += _amount - marketBalance;
            _amount -= (_amount - marketBalance);
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;

        return true;
    }

    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)
    /// @param _user the user to query
    /// @param _amount amount to payout in wei
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        assert(marketPot[msgSender()] >= _amount);
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent
    function refundUser(address _user, uint256 _refund)
        external
        override
        onlyMarkets
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        if (
            isForeclosed[_user] &&
            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win (called by market sponsor function).
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.transferFrom(_sponsor, address(this), _amount);
        marketPot[msgSender()] += _amount;
        totalMarketPots += _amount;
        return true;
    }

    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,
    /// @notice ..thus bypassing minimum rental duration
    /// @param _user the user to query
    function updateLastRentalTime(address _user)
        external
        override
        onlyMarkets
        returns (bool)
    {
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        if (user[_user].lastRentCalc == 0) {
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
        return true;
    }

    /*╔═════════════════════════════════╗
      ║        MARKET HELPERS           ║
      ╚═════════════════════════════════╝*/

    /// @notice provides the sum total of a users bids accross all markets (whether active or not)
    /// @param _user the user address to query
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    /// @notice provide the users remaining deposit
    /// @param _user the user address to query
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    /*╔═════════════════════════════════╗
      ║      ORDERBOOK CALLABLE         ║
      ╚═════════════════════════════════╝*/

    /// @notice updates users rental rates when ownership changes
    /// @dev rentalRate = sum of all active bids
    /// @param _oldOwner the address of the user losing ownership
    /// @param _newOwner the address of the user gaining ownership
    /// @param _oldPrice the price the old owner was paying
    /// @param _newPrice the price the new owner will be paying
    /// @param _timeOwnershipChanged the timestamp of this event
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyOrderbook {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !isMarket[_newOwner]
        ) {
            // The new owners rent must be collected before adjusting their rentalRate
            // See if the new owner has had a rent collection before or after this ownership change
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                // the new owner has a more recent rent collection

                uint256 _additionalRentOwed =
                    rentOwedBetweenTimestmaps(
                        block.timestamp,
                        _timeOwnershipChanged,
                        _newPrice
                    );
                collectRentUser(_newOwner, block.timestamp);

                // they have enough funds, just collect the extra
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
            } else {
                // the new owner has an old rent collection, do they own anything else?
                if (user[_newOwner].rentalRate != 0) {
                    // rent collect upto ownership change time
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    // first card owned, set start time
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                }
            }
        }
        // Must add before subtract, to avoid underflow in the case a user is only updating their price.
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    /// @dev increase bidRate when new bid entered
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    /// @dev decrease bidRate when bid removed
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    /// @dev called when all a user's bids have been removed, disables foreclosure state
    function resetUser(address _user) external override onlyOrderbook {
        isForeclosed[_user] = false;
    }

    /*╔═════════════════════════════════╗
      ║      RENT CALC HELPERS          ║
      ╚═════════════════════════════════╝*/

    /// @notice returns the rent due between the users last rent calcualtion and
    /// @notice ..the current block.timestamp for all cards a user owns
    /// @param _user the user to query
    /// @param _timeOfCollection calculate upto a given time
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    /// @notice calcualtes the rent owed between the given timestamps
    /// @param _time1 one of the timestamps
    /// @param _time2 the second timestamp
    /// @param _price the rental rate for this time period
    /// @param _rent the rent due for this time period
    /// @dev the timestamps can be given in any order
    function rentOwedBetweenTimestmaps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    /// @notice returns the amount of deposit a user is able to withdraw
    /// @notice ..after considering rent due to be paid
    /// @param _user the user to query
    function depositAbleToWithdraw(address _user)
        internal
        view
        returns (uint256)
    {
        uint256 collection = rentOwedUser(_user, block.timestamp);
        if (collection >= user[_user].deposit) {
            return 0;
        } else {
            return uint256(user[_user].deposit) - (collection);
        }
    }

    /// @notice returns the current estimate of the users foreclosure time
    /// @param _user the user to query
    /// @param _newBid calculate foreclosure including a new card
    /// @param _timeOfNewBid timestamp of when a new card was gained
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            // timeLeftOfDeposit = deposit / (totalUserDailyRent / 1 day)
            //                   = (deposit * 1day) / totalUserDailyRent
            uint256 timeLeftOfDeposit =
                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard =
                user[_user].lastRentCalc + timeLeftOfDeposit;

            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {
                // calculate how long they can own the new card for
                uint256 _rentAlreadyOwed =
                    rentOwedBetweenTimestmaps(
                        user[_user].lastRentCalc,
                        _timeOfNewBid,
                        totalUserDailyRent
                    );
                uint256 _depositAtTimeOfNewBid =
                    user[_user].deposit - _rentAlreadyOwed;
                uint256 _timeLeftOfDepositWithNewBid =
                    (_depositAtTimeOfNewBid * 1 days) /
                        (totalUserDailyRent + _newBid);
                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            // if no rentals they'll foreclose after the heat death of the universe
            return type(uint256).max;
        }
    }

    /// @notice call for a rent collection on the given user
    /// @notice IF the user doesn't have enough deposit, returns foreclosure time
    /// @notice ..otherwise returns zero
    /// @param _user the user to query
    /// @param _timeToCollectTo the timestamp to collect rent upto
    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        assert(_timeToCollectTo != 0);
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                // The User has run out of deposit already.
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                /*
            timeTheirDepsitLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)
                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)
            */
                uint256 timeUsersDepositLasts =
                    ((_timeToCollectTo - previousCollectionTime) *
                        uint256(user[_user].deposit)) / rentOwedByUser;
                /*
            Users last collection time = previousCollectionTime + timeTheirDepsitLasted
            */
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                // User has enough deposit to pay rent.
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    /// moving from the user deposit to the markets availiable balance
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",7143,761,"[H-01] Unchecked ERC20 transfers can cause lock up
Some major tokens went live before ERC20 was finalized, resulting in a discrepancy whether the transfer functions should (A) return a boolean or (B) revert/fail on error. The current best practice is that they should revert, but return “true” on success. However, not every token claiming ERC20-compatibility is doing this — some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.
Today many tools, including OpenZeppelin, offer a wrapper for “safe ERC20 transfer”:
RealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the balancedBooks modifier:
``` modifier balancedBooks {
    _;
    // using >= not == in case anyone sends tokens direct to contract
    require(
        erc20.balanceOf(address(this)) >=
            totalDeposits + marketBalance + totalMarketPots,
        ""Books are unbalanced!""
    );
}
```
This modifier is present on most functions, but is missing on topupMarketBalance:
``` function topupMarketBalance(uint256 _amount) external override {
    erc20.transferFrom(msgSender(), address(this), _amount);
    if (_amount > marketBalanceDiscrepancy) {
        marketBalanceDiscrepancy = 0;
    } else {
        marketBalanceDiscrepancy -= _amount;
    }
    marketBalance += _amount;
}
```
In the case where an ERC20 token which is not reverting on failures is used, a malicious actor could call topupMarketBalance with a failing transfer, but also move the value of marketBalance above the actual holdings. After this, deposit, withdrawDeposit, payRent, payout, sponsor, etc. could be locked up and always failing with “Books are unbalanced”.
 [H-02] Can access cards of other markets
Within `RCMarket.sol` the functions ownerOf and onlyTokenOwner do not check if the _cardId/_token is smaller than numberOfCards. So it's possible to supply a larger number and access cards of other markets. The most problematic seems to be upgradeCard. Here the check for isMarketApproved can be circumvented by trying to move the card via another market.
You can still only move cards you own.
``` // https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards
        return nfthub.ownerOf(_tokenId);
    }

https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313
  modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner""); // _token could be higher than numberOfCards,
        _;
    }

function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,
    _checkState(States.WITHDRAW);
    require(
        !factory.trapIfUnapproved() ||
            factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market
        ""Upgrade blocked""
    );
    uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market
    _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
    nfthub.withdrawWithMetadata(_tokenId);
    emit LogNftUpgraded(_card, _tokenId);
} ```   [H-04] Anyone can affect deposits of any user and turn the owner of the token
On RCTreasury, we have the method collectRentUser. This method is public, so anyone can call it using whatever user and whatever timestamp. So, calling this method using user = XXXXX and _timeToCollectTo = type(uint256).max), would make isForeclosed[user] = true.
See issue page for referenced code
Now, we can do the same for all the users bidding for a specific token. Finally, I can become the owner of the token by just calling newRental and using a small price. newRental will iterate over all the previous bid and will remove them because there are foreclosed.
Recommend that collectRentUser should be private and create a new public method with onlyOrderbook modifier.
 [M-01] payout doesn't fix isForeclosed state
The function `payout` of RCTreasury.sol doesn't undo the isForeclosed state of a user. This would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.
For example the function refundUser doesn't check and update the isForeclosed status in RCTreasury on L429 and line 447.
Recommend checking and updating the isForeclosed state in the payout function.
 [M-02] Critical uberOwner address changes should be a two-step process
As specified, uberOwners of Factory, Orderbook and Treasury have the highest privileges in the system because they can upgrade contracts of market, Nfthub, order book, treasury, token and factory which form the critical components of the protocol.
 The contracts allow for `uberOwners` to be changed to a different address from the contract owner/deployer using the changeUberOwner() function which is callable by the current uberOwner. While this function checks for zero-address, there is no validation of the new address being correct. If the current uberOwner incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the uberOwner cannot be corrected and none of the other functions that require uberOwner caller can be executed.
  [M-03] Missing balancedBooks modifier could result in failed system insolvency detection
The `balancedBooks` modifier is used to “check that funds haven't gone missing during this function call” and is applied to deposit, withdrawDeposit, payRent, payout and sponsor Treasury functions which move funds in and out of the Treasury or adjust its market/user balances.
However, this modifier is missing in the refundUser() and topupMarketBalance() functions which also perform similar actions. The impact is that any miscalculations in these functions will lead to the system becoming insolvent.
  [M-16] Deposits can be denied by abusing maxContractBalance
The treasury implements a max contract balance check in the `deposit` function: ```
require(
    (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
    ""Limit hit""
);
```
A whale can stop anyone from depositing by front-running a user's deposit with a deposit that pushes the contract balance to the maxContractBalance limit first. The user's deposit will then fail in the check. Afterwards, the whale can withdraw again.
  [M-17] Function foreclosureTimeUser returns a shorter user's foreclosure time than expected
The function `foreclosureTimeUser` of RCTreasury underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.
The variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable timeLeftOfDeposit indicates the time left of deposit, starting from now. However, at line 672, the foreclosureTimeWithoutNewCard is calculated by timeLeftOfDeposit plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.",8,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""hardhat/console.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCBridge.sol"";




contract RCTreasury is Ownable, NativeMetaTransaction, IRCTreasury {
    
    
    IRCOrderbook public orderbook;
    
    IRCNftHubL2 public nfthub;
    
    IERC20 public override erc20;
    
    address public override bridgeAddress;
    
    address public override factoryAddress;
    
    mapping(address => bool) public override isMarket;
    
    uint256 public override totalDeposits;
    
    mapping(address => uint256) public override marketPot;
    
    uint256 public override totalMarketPots;
    
    uint256 public marketBalance;
    
    mapping(address => bool) public override isForeclosed;
    
    uint256 marketBalanceDiscrepancy;

    
    
    
    
    
    struct User {
        uint128 deposit;
        uint128 rentalRate;
        uint128 bidRate;
        uint64 lastRentCalc;
        uint64 lastRentalTime;
    }
    mapping(address => User) public user;

    
    
    
    uint256 public override minRentalDayDivisor;
    
    uint256 public override maxContractBalance;
    
    mapping(address => bool) public isAllowed;
    bool public whitelistEnabled;

    
    
    bool public override globalPause;
    
    mapping(address => bool) public override marketPaused;

    
    
    address public override uberOwner;

    

    event LogUserForeclosed(address indexed user, bool indexed foreclosed);
    event LogAdjustDeposit(
        address indexed user,
        uint256 indexed amount,
        bool increase
    );
    event LogMarketPaused(address market, bool paused);
    event LogGlobalPause(bool paused);

    

    constructor(address _tokenAddress) {
        
        _initializeEIP712(""RealityCardsTreasury"", ""1"");

        
        uberOwner = msgSender();

        
        setMinRental(24 * 6); 
        setMaxContractBalance(1000000 ether); 
        setTokenAddress(_tokenAddress);
        whitelistEnabled = true;
    }

    

    
    modifier balancedBooks {
        _;
        
        require(
            erc20.balanceOf(address(this)) >=
                totalDeposits + marketBalance + totalMarketPots,
            ""Books are unbalanced!""
        );
    }

    
    modifier onlyMarkets {
        require(isMarket[msgSender()], ""Not authorised"");
        _;
    }

    
    modifier onlyOrderbook {
        require(msgSender() == address(orderbook), ""Not authorised"");
        _;
    }

    

    
    function addMarket(address _newMarket) external override {
        require(msgSender() == factoryAddress, ""Not factory"");
        isMarket[_newMarket] = true;
    }

    

    
    

    

    
    
    function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

    
    
    function setMaxContractBalance(uint256 _newBalanceLimit)
        public
        override
        onlyOwner
    {
        maxContractBalance = _newBalanceLimit;
    }

    

    
    function changeGlobalPause() external override onlyOwner {
        globalPause = !globalPause;
        emit LogGlobalPause(globalPause);
    }

    
    function changePauseMarket(address _market) external override onlyOwner {
        require(isMarket[_market], ""This isn't a market"");
        marketPaused[_market] = !marketPaused[_market];
        emit LogMarketPaused(_market, marketPaused[_market]);
    }

    

    
    function toggleWhitelist() external override onlyOwner {
        whitelistEnabled = !whitelistEnabled;
    }

    
    function addToWhitelist(address _user) public override {
        IRCFactory factory = IRCFactory(factoryAddress);
        require(factory.isGovernor(msgSender()), ""Not authorised"");
        isAllowed[_user] = !isAllowed[_user];
    }

    
    function batchAddToWhitelist(address[] calldata _users) public override {
        for (uint256 index = 0; index < _users.length; index++) {
            addToWhitelist(_users[index]);
        }
    }

    
    
    
    
    

    function setFactoryAddress(address _newFactory) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newFactory != address(0), ""Must set an address"");
        factoryAddress = _newFactory;
    }

    function setOrderbookAddress(address _newOrderbook) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newOrderbook != address(0), ""Must set an address"");
        orderbook = IRCOrderbook(_newOrderbook);
    }

    function setNftHubAddress(address _NFTHubAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_NFTHubAddress != address(0), ""Must set an address"");
        nfthub = IRCNftHubL2(_NFTHubAddress);
    }

    function setTokenAddress(address _newToken) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newToken != address(0), ""Must set an address"");
        erc20 = IERC20(_newToken);
    }

    function setBridgeAddress(address _newBridge) public override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newBridge != address(0), ""Must set an address"");
        bridgeAddress = _newBridge;
        erc20.approve(_newBridge, type(uint256).max);
    }

    function changeUberOwner(address _newUberOwner) external override {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0), ""Must set an address"");
        uberOwner = _newUberOwner;
    }

    

    
    
    
    
    
    function deposit(uint256 _amount, address _user)
        public
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(isAllowed[msgSender()], ""Not in whitelist"");
        }
        erc20.transferFrom(msgSender(), address(this), _amount);

        
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        
        if (
            (user[_user].deposit + _amount) >
            (user[_user].bidRate / minRentalDayDivisor)
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
        return true;
    }

    
    
    
    
    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        
        
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        
        collectRentUser(_msgSender, block.timestamp);

        
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }

    
    
    function topupMarketBalance(uint256 _amount) external override {
        erc20.transferFrom(msgSender(), address(this), _amount);
        if (_amount > marketBalanceDiscrepancy) {
            marketBalanceDiscrepancy = 0;
        } else {
            marketBalanceDiscrepancy -= _amount;
        }
        marketBalance += _amount;
    }

    

    function checkSponsorship(address sender, uint256 _amount)
        external
        view
        override
    {
        require(
            erc20.allowance(sender, address(this)) >= _amount,
            ""Insufficient Allowance""
        );
        require(erc20.balanceOf(sender) >= _amount, ""Insufficient Balance"");
    }

    
    

    
    
    
    function payRent(uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Rentals are disabled"");
        if (marketBalance < _amount) {
            marketBalanceDiscrepancy += _amount - marketBalance;
            _amount -= (_amount - marketBalance);
        }
        address _market = msgSender();
        marketBalance -= _amount;
        marketPot[_market] += _amount;
        totalMarketPots += _amount;

        return true;
    }

    
    
    
    function payout(address _user, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Payouts are disabled"");
        assert(marketPot[msgSender()] >= _amount);
        user[_user].deposit += SafeCast.toUint128(_amount);
        marketPot[msgSender()] -= _amount;
        totalMarketPots -= _amount;
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);
        return true;
    }

    
    function refundUser(address _user, uint256 _refund)
        external
        override
        onlyMarkets
    {
        marketBalance -= _refund;
        user[_user].deposit += SafeCast.toUint128(_refund);
        totalDeposits += _refund;
        emit LogAdjustDeposit(_user, _refund, true);
        if (
            isForeclosed[_user] &&
            user[_user].deposit > user[_user].bidRate / minRentalDayDivisor
        ) {
            isForeclosed[_user] = false;
            emit LogUserForeclosed(_user, false);
        }
    }

    
    function sponsor(address _sponsor, uint256 _amount)
        external
        override
        balancedBooks
        onlyMarkets
        returns (bool)
    {
        require(!globalPause, ""Global Pause is Enabled"");
        require(
            erc20.allowance(_sponsor, address(this)) >= _amount,
            ""Not approved to send this amount""
        );
        erc20.transferFrom(_sponsor, address(this), _amount);
        marketPot[msgSender()] += _amount;
        totalMarketPots += _amount;
        return true;
    }

    
    
    
    function updateLastRentalTime(address _user)
        external
        override
        onlyMarkets
        returns (bool)
    {
        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);
        if (user[_user].lastRentCalc == 0) {
            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);
        }
        return true;
    }

    

    
    
    function userTotalBids(address _user)
        external
        view
        override
        returns (uint256)
    {
        return user[_user].bidRate;
    }

    
    
    function userDeposit(address _user)
        external
        view
        override
        returns (uint256)
    {
        return uint256(user[_user].deposit);
    }

    

    
    
    
    
    
    
    
    function updateRentalRate(
        address _oldOwner,
        address _newOwner,
        uint256 _oldPrice,
        uint256 _newPrice,
        uint256 _timeOwnershipChanged
    ) external override onlyOrderbook {
        if (
            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&
            !isMarket[_newOwner]
        ) {
            
            
            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {
                

                uint256 _additionalRentOwed =
                    rentOwedBetweenTimestmaps(
                        block.timestamp,
                        _timeOwnershipChanged,
                        _newPrice
                    );
                collectRentUser(_newOwner, block.timestamp);

                
                _increaseMarketBalance(_additionalRentOwed, _newOwner);
            } else {
                
                if (user[_newOwner].rentalRate != 0) {
                    
                    collectRentUser(_newOwner, _timeOwnershipChanged);
                } else {
                    
                    user[_newOwner].lastRentCalc = SafeCast.toUint64(
                        _timeOwnershipChanged
                    );
                }
            }
        }
        
        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);
        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);
    }

    
    function increaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate += SafeCast.toUint128(_price);
    }

    
    function decreaseBidRate(address _user, uint256 _price)
        external
        override
        onlyOrderbook
    {
        user[_user].bidRate -= SafeCast.toUint128(_price);
    }

    
    function resetUser(address _user) external override onlyOrderbook {
        isForeclosed[_user] = false;
    }

    

    
    
    
    
    function rentOwedUser(address _user, uint256 _timeOfCollection)
        internal
        view
        returns (uint256 rentDue)
    {
        return
            (user[_user].rentalRate *
                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);
    }

    
    
    
    
    
    
    function rentOwedBetweenTimestmaps(
        uint256 _time1,
        uint256 _time2,
        uint256 _price
    ) internal pure returns (uint256 _rent) {
        if (_time1 < _time2) {
            (_time1, _time2) = (_time2, _time1);
        }
        _rent = (_price * (_time1 - _time2)) / (1 days);
    }

    
    
    
    function depositAbleToWithdraw(address _user)
        internal
        view
        returns (uint256)
    {
        uint256 collection = rentOwedUser(_user, block.timestamp);
        if (collection >= user[_user].deposit) {
            return 0;
        } else {
            return uint256(user[_user].deposit) - (collection);
        }
    }

    
    
    
    
    function foreclosureTimeUser(
        address _user,
        uint256 _newBid,
        uint256 _timeOfNewBid
    ) external view override returns (uint256) {
        uint256 totalUserDailyRent = user[_user].rentalRate;
        if (totalUserDailyRent > 0) {
            
            
            uint256 timeLeftOfDeposit =
                (depositAbleToWithdraw(_user) * 1 days) / totalUserDailyRent;

            uint256 foreclosureTimeWithoutNewCard =
                user[_user].lastRentCalc + timeLeftOfDeposit;

            if (foreclosureTimeWithoutNewCard > _timeOfNewBid) {
                
                uint256 _rentAlreadyOwed =
                    rentOwedBetweenTimestmaps(
                        user[_user].lastRentCalc,
                        _timeOfNewBid,
                        totalUserDailyRent
                    );
                uint256 _depositAtTimeOfNewBid =
                    user[_user].deposit - _rentAlreadyOwed;
                uint256 _timeLeftOfDepositWithNewBid =
                    (_depositAtTimeOfNewBid * 1 days) /
                        (totalUserDailyRent + _newBid);
                return _timeOfNewBid + _timeLeftOfDepositWithNewBid;
            } else {
                return user[_user].lastRentCalc + timeLeftOfDeposit;
            }
        } else {
            
            return type(uint256).max;
        }
    }

    
    
    
    
    
    
    function collectRentUser(address _user, uint256 _timeToCollectTo)
        public
        override
        returns (uint256 newTimeLastCollectedOnForeclosure)
    {
        require(!globalPause, ""Global pause is enabled"");
        assert(_timeToCollectTo != 0);
        if (user[_user].lastRentCalc < _timeToCollectTo) {
            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);

            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {
                
                uint256 previousCollectionTime = user[_user].lastRentCalc;

                
                uint256 timeUsersDepositLasts =
                    ((_timeToCollectTo - previousCollectionTime) *
                        uint256(user[_user].deposit)) / rentOwedByUser;
                
                rentOwedByUser = uint256(user[_user].deposit);
                newTimeLastCollectedOnForeclosure =
                    previousCollectionTime +
                    timeUsersDepositLasts;
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(
                    newTimeLastCollectedOnForeclosure
                );
                assert(user[_user].deposit == 0);
                isForeclosed[_user] = true;
                emit LogUserForeclosed(_user, true);
            } else {
                
                _increaseMarketBalance(rentOwedByUser, _user);
                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);
            }
            emit LogAdjustDeposit(_user, rentOwedByUser, false);
        }
    }

    
    function _increaseMarketBalance(uint256 rentCollected, address _user)
        internal
    {
        marketBalance += rentCollected;
        user[_user].deposit -= SafeCast.toUint128(rentCollected);
        totalDeposits -= rentCollected;
    }
    
}",4101,3,5,"{'task_list': [{'Area': 'Access Control and Authorization', 'Tasks': ['Verify that only the `uberOwner` can set critical contract addresses (Factory, Orderbook, NFTHub, Token, Bridge).', 'Confirm that `onlyOwner` modifier restricts access to sensitive functions like `setMinRental`, `setMaxContractBalance`, `changeGlobalPause`, `changePauseMarket`, and `toggleWhitelist`.', 'Ensure that only `factoryAddress` can call the `addMarket` function.', 'Verify the logic within `addToWhitelist` and `batchAddToWhitelist` to ensure only authorized `factory` governors can add/remove users from the whitelist.', 'Investigate potential vulnerabilities if `uberOwner` is compromised, as they can modify core contract dependencies.', 'Analyze the `NativeMetaTransaction` implementation and ensure proper signature verification to prevent unauthorized access via meta-transactions. Identify the functions intended to be usable with meta-transactions.', 'Check for any unintended access to functions through incorrect modifier usage or missing access control checks.']}, {'Area': 'ERC20 Token Interactions and Balance Management', 'Tasks': ['Scrutinize the `deposit` function to prevent potential reentrancy attacks during the `erc20.transferFrom` call. Consider using a reentrancy guard.', ""Verify that the contract's ERC20 balance is accurately maintained across all deposit, withdrawal, rent collection, and payout operations."", ""Analyze the `balancedBooks` modifier to ensure it effectively detects discrepancies between the contract's ERC20 balance and internal state variables (`totalDeposits`, `marketBalance`, `totalMarketPots`). Note: This modifier only checks, it doesn't correct discrepancies. Develop test cases where the state variables become out of sync."", 'Investigate the `marketBalanceDiscrepancy` variable and the conditions under which it is updated. Determine if it can lead to loss of funds or unexpected behavior.', 'Confirm that the `maxContractBalance` limit is properly enforced in the `deposit` function and that no bypass mechanisms exist.', 'Assess the impact of ERC20 token decimals on calculations within the contract, ensuring no precision loss or unexpected rounding occurs.', 'Verify that the approval to the `bridgeAddress` is set to `type(uint256).max` only once and cannot be maliciously altered.', ""Analyze how the `collectRentUser` function handles cases where `rentOwedByUser` exceeds the user's deposit. Confirm that the foreclosure logic and subsequent actions are correct.""]}, {'Area': 'Rent Calculation and Foreclosure Logic', 'Tasks': ['Examine the rent calculation logic in `rentOwedUser` and `rentOwedBetweenTimestmaps` to ensure accuracy and prevent potential under- or over-charging of rent.', 'Analyze the foreclosure logic in `collectRentUser` and the impact of the `minRentalDayDivisor` on foreclosure timing. Develop test cases with varying rental rates and deposit amounts to ensure the logic is sound.', 'Investigate potential edge cases in the `foreclosureTimeUser` function, particularly when calculating the time left before foreclosure with a new bid. Verify that the returned time is always accurate.', 'Assess the interaction between the `orderbook.removeUserFromOrderbook` function and the `isForeclosed` state variable. Ensure that users are properly removed from the orderbook upon foreclosure and that the `isForeclosed` state is updated accordingly. Clarify the return value specification of `orderbook.removeUserFromOrderbook(address)`.', 'Evaluate if rapid, successive calls to `updateRentalRate` for the same user could lead to unexpected behavior, especially concerning the timestamp comparisons (`_timeOwnershipChanged` vs `user[_newOwner].lastRentCalc`). Create a test case.', 'Confirm that the `updateLastRentalTime` is called correctly by markets and that the `lastRentalTime` and `lastRentCalc` variables are updated appropriately.', 'Check for potential integer overflow or underflow issues in the rent calculation formulas.']}, {'Area': 'External Interactions and Dependencies', 'Tasks': ['Review the interactions with the `IRCOrderbook` contract, including the `removeOldBids`, `removeUserFromOrderbook`, `updateRentalRate`, `increaseBidRate`, `decreaseBidRate`, and `resetUser` functions. Ensure that these interactions are secure and do not introduce vulnerabilities.', 'Analyze the interactions with the `IRCFactory` contract, particularly the `isGovernor` function. Verify that the factory contract is properly authorized to add new markets.', 'Examine the interactions with the `IRCBridge` contract, specifically the `withdrawToMainnet` function. Ensure that withdrawals are handled securely and that the bridge contract is trusted.', 'Investigate the role of the `IRCNftHubL2` contract and its interaction with the `RCTreasury` contract. Determine if any security risks exist due to this interaction.', 'Assess the potential impact of malicious or compromised external contracts on the `RCTreasury` contract. Implement safeguards to mitigate these risks.', 'Check for proper error handling and revert conditions when interacting with external contracts.']}, {'Area': 'Pause Mechanisms and Emergency Stops', 'Tasks': ['Verify that the `globalPause` mechanism effectively halts all critical operations, including deposits, withdrawals, rent collection, and payouts.', 'Ensure that the `marketPaused` mechanism correctly pauses operations specific to a given market.', ""Assess the potential impact of pausing/unpausing on the contract's overall functionality and security."", 'Evaluate whether the `owner` can quickly and effectively pause the contract in the event of an emergency.', 'Consider adding more granular pause mechanisms to halt specific functionalities.']}, {'Area': 'Gas Optimization', 'Tasks': ['Analyze the gas costs of frequently called functions, such as `deposit`, `withdrawDeposit`, `payRent`, and `collectRentUser`. Identify opportunities to reduce gas consumption.', 'Optimize data storage by minimizing the number of state variables and using efficient data types. The struct `User` uses `uint128` which might be less efficient than `uint256` depending on the EVM implementation (consider packing with `uint64` if feasible).', 'Review the use of loops and conditional statements to identify potential gas inefficiencies.', 'Evaluate the use of assembly code for gas optimization, but be mindful of the increased complexity and potential security risks.', 'Consider using immutable variables where appropriate to save gas costs.']}]}","{'ReviewingTheCode': ""The contract `RCTreasury` acts as a central vault for user deposits in an ERC20 token within a larger system, likely related to NFT bidding or rentals (suggested by terms like 'rent', 'bid', 'market', 'orderbook', 'nfthub'). It manages user balances, collects rent based on usage rates potentially determined by an external Orderbook contract, handles payouts originating from Market contracts, enforces solvency rules (foreclosure), and interacts with a Bridge for L2/L1 transfers. It features role-based access control (Owner, UberOwner, Factory Governors), pause mechanisms, and optional whitelisting. It also supports EIP712 meta-transactions."", 'IdentifyingKeyComponents': {'ContractName': 'RCTreasury', 'Purpose': 'To manage user deposits (ERC20), collect rent, handle market payouts/sponsorships, manage user solvency (foreclosure), and interact with other components (Orderbook, Markets, Factory, Bridge) in a decentralized application ecosystem.', 'InheritanceAndImports': {'InheritsFrom': ['@openzeppelin/contracts/access/Ownable.sol', './lib/NativeMetaTransaction.sol', './interfaces/IRCTreasury.sol'], 'Imports': ['@openzeppelin/contracts/access/Ownable.sol', '@openzeppelin/contracts/utils/math/SafeCast.sol', '@openzeppelin/contracts/token/ERC20/IERC20.sol', 'hardhat/console.sol', './lib/NativeMetaTransaction.sol', './interfaces/IRCTreasury.sol', './interfaces/IRCMarket.sol', './interfaces/IRCOrderbook.sol', './interfaces/IRCNftHubL2.sol', './interfaces/IRCFactory.sol', './interfaces/IRCBridge.sol']}, 'StateVariables': [{'Name': 'orderbook', 'Type': 'IRCOrderbook', 'Purpose': 'Reference to the external Orderbook contract.'}, {'Name': 'nfthub', 'Type': 'IRCNftHubL2', 'Purpose': 'Reference to the external NftHub contract (L2).'}, {'Name': 'erc20', 'Type': 'IERC20', 'Purpose': 'The ERC20 token used for deposits, rent, and payouts.'}, {'Name': 'bridgeAddress', 'Type': 'address', 'Purpose': 'Address of the bridge contract for L2/L1 interactions.'}, {'Name': 'factoryAddress', 'Type': 'address', 'Purpose': 'Address of the factory contract, responsible for creating markets.'}, {'Name': 'isMarket', 'Type': 'mapping(address => bool)', 'Purpose': 'Tracks authorized market contract addresses.'}, {'Name': 'totalDeposits', 'Type': 'uint256', 'Purpose': 'Sum of all current user deposits held by the Treasury.'}, {'Name': 'marketPot', 'Type': 'mapping(address => uint256)', 'Purpose': 'Funds held per market, typically from rent or sponsorships, available for payout.'}, {'Name': 'totalMarketPots', 'Type': 'uint256', 'Purpose': 'Sum of all funds held across all market pots.'}, {'Name': 'marketBalance', 'Type': 'uint256', 'Purpose': 'General balance available for rent collection, distinct from user deposits and market pots.'}, {'Name': 'isForeclosed', 'Type': 'mapping(address => bool)', 'Purpose': ""Tracks if a user's deposit is insufficient to cover potential rent/bids.""}, {'Name': 'marketBalanceDiscrepancy', 'Type': 'uint256', 'Purpose': 'Tracks potential shortfalls in the marketBalance when rent is paid.'}, {'Name': 'user', 'Type': 'mapping(address => User)', 'Purpose': 'Stores individual user data including deposit, rental/bid rates, and timing info.'}, {'Name': 'minRentalDayDivisor', 'Type': 'uint256', 'Purpose': 'Divisor used to calculate minimum rental/withdrawal time limits.'}, {'Name': 'maxContractBalance', 'Type': 'uint256', 'Purpose': 'Maximum total ERC20 balance allowed in the contract.'}, {'Name': 'isAllowed', 'Type': 'mapping(address => bool)', 'Purpose': 'Whitelist mapping for users when whitelistEnabled is true.'}, {'Name': 'whitelistEnabled', 'Type': 'bool', 'Purpose': 'Flag to enable/disable deposit whitelisting.'}, {'Name': 'globalPause', 'Type': 'bool', 'Purpose': 'Flag to pause major functions like deposits, withdrawals, rent, payouts.'}, {'Name': 'marketPaused', 'Type': 'mapping(address => bool)', 'Purpose': 'Flag to pause interactions specific to a single market.'}, {'Name': 'uberOwner', 'Type': 'address', 'Purpose': 'A super-admin role with privileges beyond the regular owner, primarily for setting critical contract addresses.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract, sets up EIP712, uberOwner, initial settings, and token address.', 'Parameters': ['address _tokenAddress'], 'Returns': []}, {'Name': 'balancedBooks', 'Visibility': 'modifier', 'Purpose': ""Checks if the contract's ERC20 balance matches its internal accounting."", 'Parameters': [], 'Returns': []}, {'Name': 'onlyMarkets', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions callable only by registered market contracts.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyOrderbook', 'Visibility': 'modifier', 'Purpose': 'Restricts access to functions callable only by the registered orderbook contract.', 'Parameters': [], 'Returns': []}, {'Name': 'addMarket', 'Visibility': 'external', 'Purpose': 'Allows the factory contract to register a new market.', 'Parameters': ['address _newMarket'], 'Returns': []}, {'Name': 'setMinRental', 'Visibility': 'public', 'Purpose': 'Owner sets the minimum rental period divisor.', 'Parameters': ['uint256 _newDivisor'], 'Returns': []}, {'Name': 'setMaxContractBalance', 'Visibility': 'public', 'Purpose': 'Owner sets the maximum total ERC20 balance limit.', 'Parameters': ['uint256 _newBalanceLimit'], 'Returns': []}, {'Name': 'changeGlobalPause', 'Visibility': 'external', 'Purpose': 'Owner toggles the global pause state.', 'Parameters': [], 'Returns': []}, {'Name': 'changePauseMarket', 'Visibility': 'external', 'Purpose': 'Owner toggles the pause state for a specific market.', 'Parameters': ['address _market'], 'Returns': []}, {'Name': 'toggleWhitelist', 'Visibility': 'external', 'Purpose': 'Owner enables/disables the deposit whitelist.', 'Parameters': [], 'Returns': []}, {'Name': 'addToWhitelist', 'Visibility': 'public', 'Purpose': 'Adds/removes a user from the whitelist (callable by factory governors).', 'Parameters': ['address _user'], 'Returns': []}, {'Name': 'batchAddToWhitelist', 'Visibility': 'public', 'Purpose': 'Adds multiple users to the whitelist.', 'Parameters': ['address[] calldata _users'], 'Returns': []}, {'Name': 'setFactoryAddress', 'Visibility': 'external', 'Purpose': 'UberOwner sets the factory address.', 'Parameters': ['address _newFactory'], 'Returns': []}, {'Name': 'setOrderbookAddress', 'Visibility': 'external', 'Purpose': 'UberOwner sets the orderbook address.', 'Parameters': ['address _newOrderbook'], 'Returns': []}, {'Name': 'setNftHubAddress', 'Visibility': 'external', 'Purpose': 'UberOwner sets the NFT Hub address.', 'Parameters': ['address _NFTHubAddress'], 'Returns': []}, {'Name': 'setTokenAddress', 'Visibility': 'public', 'Purpose': 'UberOwner sets the ERC20 token address.', 'Parameters': ['address _newToken'], 'Returns': []}, {'Name': 'setBridgeAddress', 'Visibility': 'public', 'Purpose': 'UberOwner sets the bridge address and approves max allowance.', 'Parameters': ['address _newBridge'], 'Returns': []}, {'Name': 'changeUberOwner', 'Visibility': 'external', 'Purpose': 'UberOwner transfers the uberOwner role.', 'Parameters': ['address _newUberOwner'], 'Returns': []}, {'Name': 'deposit', 'Visibility': 'public', 'Purpose': 'Allows a user (or someone on their behalf) to deposit ERC20 tokens.', 'Parameters': ['uint256 _amount', 'address _user'], 'Returns': ['bool']}, {'Name': 'withdrawDeposit', 'Visibility': 'external', 'Purpose': 'Allows a user to withdraw their available deposit, locally or to mainnet via bridge.', 'Parameters': ['uint256 _amount', 'bool _localWithdrawal'], 'Returns': []}, {'Name': 'topupMarketBalance', 'Visibility': 'external', 'Purpose': 'Allows adding funds to the general market balance, potentially covering discrepancies.', 'Parameters': ['uint256 _amount'], 'Returns': []}, {'Name': 'checkSponsorship', 'Visibility': 'external', 'Purpose': 'View function to check if a potential sponsor has sufficient balance and allowance.', 'Parameters': ['address sender', 'uint256 _amount'], 'Returns': []}, {'Name': 'payRent', 'Visibility': 'external', 'Purpose': ""Called by markets to transfer collected rent from `marketBalance` to the market's `marketPot`."", 'Parameters': ['uint256 _amount'], 'Returns': ['bool']}, {'Name': 'payout', 'Visibility': 'external', 'Purpose': ""Called by markets to transfer funds from their `marketPot` to a user's deposit."", 'Parameters': ['address _user', 'uint256 _amount'], 'Returns': ['bool']}, {'Name': 'refundUser', 'Visibility': 'external', 'Purpose': ""Called by markets to refund an amount from `marketBalance` back to a user's deposit."", 'Parameters': ['address _user', 'uint256 _refund'], 'Returns': []}, {'Name': 'sponsor', 'Visibility': 'external', 'Purpose': ""Called by markets to process a sponsorship, transferring funds from a sponsor to the market's `marketPot`."", 'Parameters': ['address _sponsor', 'uint256 _amount'], 'Returns': ['bool']}, {'Name': 'updateLastRentalTime', 'Visibility': 'external', 'Purpose': ""Called by markets to update a user's `lastRentalTime`."", 'Parameters': ['address _user'], 'Returns': ['bool']}, {'Name': 'userTotalBids', 'Visibility': 'external', 'Purpose': ""View function to get a user's total bid rate."", 'Parameters': ['address _user'], 'Returns': ['uint256']}, {'Name': 'userDeposit', 'Visibility': 'external', 'Purpose': ""View function to get a user's current deposit amount."", 'Parameters': ['address _user'], 'Returns': ['uint256']}, {'Name': 'updateRentalRate', 'Visibility': 'external', 'Purpose': 'Called by the orderbook to update user rental rates upon ownership changes, collecting rent if necessary.', 'Parameters': ['address _oldOwner', 'address _newOwner', 'uint256 _oldPrice', 'uint256 _newPrice', 'uint256 _timeOwnershipChanged'], 'Returns': []}, {'Name': 'increaseBidRate', 'Visibility': 'external', 'Purpose': ""Called by the orderbook to increase a user's total bid rate."", 'Parameters': ['address _user', 'uint256 _price'], 'Returns': []}, {'Name': 'decreaseBidRate', 'Visibility': 'external', 'Purpose': ""Called by the orderbook to decrease a user's total bid rate."", 'Parameters': ['address _user', 'uint256 _price'], 'Returns': []}, {'Name': 'resetUser', 'Visibility': 'external', 'Purpose': ""Called by the orderbook to reset a user's foreclosure status."", 'Parameters': ['address _user'], 'Returns': []}, {'Name': 'rentOwedUser', 'Visibility': 'internal', 'Purpose': 'Calculates rent owed by a user up to a specific time.', 'Parameters': ['address _user', 'uint256 _timeOfCollection'], 'Returns': ['uint256 rentDue']}, {'Name': 'rentOwedBetweenTimestmaps', 'Visibility': 'internal', 'Purpose': 'Calculates rent owed for a given rate between two timestamps.', 'Parameters': ['uint256 _time1', 'uint256 _time2', 'uint256 _price'], 'Returns': ['uint256 _rent']}, {'Name': 'depositAbleToWithdraw', 'Visibility': 'internal', 'Purpose': ""Calculates the portion of a user's deposit available for withdrawal after accounting for owed rent."", 'Parameters': ['address _user'], 'Returns': ['uint256']}, {'Name': 'foreclosureTimeUser', 'Visibility': 'external', 'Purpose': 'View function to estimate when a user will be foreclosed, considering a potential new bid.', 'Parameters': ['address _user', 'uint256 _newBid', 'uint256 _timeOfNewBid'], 'Returns': ['uint256']}, {'Name': 'collectRentUser', 'Visibility': 'public', 'Purpose': 'Calculates and collects rent owed by a user, updating balances and foreclosure status.', 'Parameters': ['address _user', 'uint256 _timeToCollectTo'], 'Returns': ['uint256 newTimeLastCollectedOnForeclosure']}, {'Name': '_increaseMarketBalance', 'Visibility': 'internal', 'Purpose': ""Helper function to handle accounting when rent is collected from a user's deposit."", 'Parameters': ['uint256 rentCollected', 'address _user'], 'Returns': []}]}, 'ExternalInteractions': ['IERC20 (Token): `transferFrom`, `transfer`, `balanceOf`, `approve`, `allowance`.', 'IRCOrderbook: Calls `removeOldBids`, `removeUserFromOrderbook`. Is called by Orderbook via `updateRentalRate`, `increaseBidRate`, `decreaseBidRate`, `resetUser`.', 'IRCFactory: Calls `isGovernor`. Is called by Factory via `addMarket`.', 'IRCBridge: Calls `withdrawToMainnet`.', 'IRCMarket: Is called by Market contracts via `payRent`, `payout`, `refundUser`, `sponsor`, `updateLastRentalTime`. Treasury uses `isMarket` mapping and `onlyMarkets` modifier to authorize these calls.', 'IRCNftHubL2: Address is stored, but no direct calls made from this contract snippet.', 'NativeMetaTransaction (EIP712 Infrastructure): Implicit interaction for potentially gasless transactions via `_msgSender()` override.'], 'SpecialMechanisms': ['Meta-transactions (EIP712): Inherits `NativeMetaTransaction` for gasless tx support.', 'Two-Tier Admin Roles: `owner` for standard operations, `uberOwner` for critical configuration.', 'Foreclosure Logic: Manages user solvency based on deposits vs. rental/bid rates, interacting with the Orderbook.', 'Time-Based Rent Calculation: Rent accrues based on `rentalRate` and time elapsed.', 'Whitelisting: Optional access control for deposits.', 'Pause Mechanisms: Global and per-market pauses for critical functions.', 'Internal Accounting Checks: `balancedBooks` modifier attempts to verify ERC20 balance against internal state. `marketBalanceDiscrepancy` tracks potential deviations.', ""SafeCasting: Uses OpenZeppelin's `SafeCast` to prevent overflow when storing `uint256` values in smaller `User` struct fields."", 'Interface-Based Interaction: Relies heavily on interfaces (`IRCMarket`, `IRCOrderbook`, etc.) for interacting with other system components.'], 'Questions': ['What specific actions or scenarios lead to the `marketBalanceDiscrepancy` occurring?', 'What is the precise logic within `orderbook.removeOldBids(user)` and why is it necessary during `deposit`?', 'Are there scenarios where a user might call `collectRentUser` directly, and is this intended or potentially problematic?', 'Could rapid, successive calls to `updateRentalRate` for the same user lead to unexpected behavior or race conditions, especially concerning the timestamp comparisons (`_timeOwnershipChanged` vs `user[_newOwner].lastRentCalc`)?', ""What prevents `totalDeposits`, `totalMarketPots`, and `marketBalance` from drifting out of sync with the actual `erc20.balanceOf(address(this))`, despite the `balancedBooks` modifier (which only checks, doesn't correct)?"", 'What is the exact return value specification for `orderbook.removeUserFromOrderbook(address)`? Does it indicate success, or the resulting foreclosure status?', ""What role does the `IRCNftHubL2` contract play in the overall system, as it's referenced but not directly used here?"", 'Which specific functions within this contract are intended to be usable via meta-transactions through the `NativeMetaTransaction` inheritance?', 'Is the `marketBalance` purely funded by rent collection (`_increaseMarketBalance`) and `topupMarketBalance`, or are there other mechanisms?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in `withdrawDeposit` Function', 'Severity': 'High', 'Description': ""The `withdrawDeposit` function performs external calls (`erc20.transfer` or `bridge.withdrawToMainnet`) after updating the user's deposit (`user[_msgSender].deposit`) and `totalDeposits`, but potentially before other state changes like foreclosure status (`isForeclosed`) are finalized. If the external contract (token or bridge) allows re-entering the `RCTreasury` contract, an attacker could potentially call `withdrawDeposit` again or manipulate the contract state before the initial call fully completes. This could lead to bypassing checks and withdrawing more funds than entitled, despite the `balancedBooks` modifier which might not cover all reentrancy scenarios depending on the callback mechanism."", 'Impact': 'Significant financial risk due to potential unauthorized withdrawals, draining of contract funds.', 'Location': 'RCTreasury.sol: withdrawDeposit (approx. lines 288-378 across different versions)'}, {'Issue': 'Incorrect Calculation and Logic in `collectRentUser`', 'Severity': 'High', 'Description': ""The `collectRentUser` function contains flawed logic for handling situations where a user's rent owed exceeds their deposit. The calculation of `timeUsersDepositLasts` uses integer division which can lead to precision loss, potentially causing users to be foreclosed prematurely. Additionally, the logic for updating `user[_user].lastRentCalc` based on `timeUsersDepositLasts` appears incorrect, as it adds a duration calculated relative to `_timeToCollectTo` back to the `previousCollectionTime`. Furthermore, an `assert(user[_user].deposit == 0)` exists without explicitly setting the deposit to zero beforehand in that specific code path, which will cause transactions to revert, leading to a DoS. This combination of issues can result in incorrect accounting, premature foreclosures, loss of funds due to uncollected rent during dormant periods, and transaction failures."", 'Impact': 'Premature foreclosure of users, loss of funds for users or the protocol, inaccurate accounting, denial of service due to failing asserts, potential exploitation.', 'Location': 'RCTreasury.sol: collectRentUser (approx. lines 605-716 across different versions)'}, {'Issue': 'Centralized Control via `uberOwner`', 'Severity': 'High', 'Description': ""The `uberOwner` address possesses significant control over critical contract addresses (`factoryAddress`, `orderbook`, `nfthub`, `erc20`, `bridgeAddress`) and parameters (fees). Compromise of the `uberOwner` private key would allow an attacker to redirect funds, manipulate core functionalities, change fees arbitrarily, or potentially render the system unusable by setting invalid addresses. There's a lack of checks to ensure the addresses being set are valid contracts or implement expected interfaces."", 'Impact': 'Complete system compromise, potential theft of all funds, malicious manipulation of core parameters and addresses if the `uberOwner` account is compromised or malicious.', 'Location': 'RCTreasury.sol: setFactoryAddress, setOrderbookAddress, setNftHubAddress, setTokenAddress, setBridgeAddress, changeUberOwner, other owner-controlled functions (approx. lines 185-278 across versions)'}, {'Issue': 'Potential Integer Overflow/Underflow in Rent Calculations', 'Severity': 'Medium', 'Description': 'Multiple functions involved in calculating rent (`rentOwedBetweenTimestmaps`, `rentOwedUser`, `collectRentUser`, `updateRentalRate`) perform arithmetic operations (multiplication, division, subtraction) on potentially large numbers like rental rates and timestamp differences. While Solidity 0.8+ provides default checks, intermediate calculations, especially `price * time_difference` before division by `1 days`, could still theoretically overflow `uint256`. Subtraction of timestamps (`_time1 - _time2`) without ensuring `_time1 >= _time2` could lead to underflow, resulting in extremely large incorrect rent values. These inaccuracies affect rent collection and foreclosure logic.', 'Impact': 'Incorrect rent calculation leading to financial discrepancies, unfair charges or payouts, erroneous foreclosures, and potential financial loss for users or the protocol.', 'Location': 'RCTreasury.sol: rentOwedBetweenTimestmaps, rentOwedUser, collectRentUser, updateRentalRate (approx. lines 486, 506-533, 559-651 across versions)'}, {'Issue': 'Unsafe Downcasting and Potential Precision Loss', 'Severity': 'Medium', 'Description': ""Several functions use `SafeCast.toUint128` to convert `uint256` values (often related to deposits, amounts, or rates) to `uint128`. While `SafeCast` prevents silent truncation by reverting if the value exceeds `uint128.max`, the contract logic doesn't explicitly handle these potential reversions in all cases. Furthermore, calculations involving division, especially in rent calculation (`rentOwed...`) and foreclosure time estimation (`collectRentUser`, `foreclosureTimeUser`), suffer from potential precision loss due to integer division, which can become significant when dealing with small deposits or rates, potentially leading to premature foreclosures or incorrect accounting."", 'Impact': 'Loss of precision in calculations, potential transaction reverts if values exceed uint128 limits, unexpected behavior, incorrect accounting, and potentially premature foreclosures due to rounding errors.', 'Location': 'RCTreasury.sol: deposit, withdrawDeposit, payout, refundUser, updateRentalRate, increaseBidRate, decreaseBidRate, collectRentUser, foreclosureTimeUser (multiple locations)'}, {'Issue': 'Market Balance Discrepancy Management Issues', 'Severity': 'Medium', 'Description': ""The logic for managing `marketBalanceDiscrepancy` in `topupMarketBalance` and `payRent` is potentially problematic. In `topupMarketBalance`, setting the discrepancy to 0 when the top-up amount exceeds it might mask larger underlying issues. There's no upper bound on how large the discrepancy can become (e.g., via `payRent` if `marketBalance` is insufficient), and no clear mechanism for markets to resolve a discrepancy once created. Direct transfers to the contract can also increase `marketBalance` without affecting the discrepancy, complicating reconciliation."", 'Impact': 'Inaccurate tracking of market balances and discrepancies, masking of underlying accounting errors, difficult reconciliation, potential for manipulation or exploitation of discrepancy logic.', 'Location': 'RCTreasury.sol: topupMarketBalance, payRent (approx. lines 314-321, 398, 424-439 across versions)'}, {'Issue': 'Potential Denial of Service (DoS) Vectors', 'Severity': 'Medium', 'Description': 'Several potential DoS vectors exist: 1) `batchAddToWhitelist` iterates through an unbounded user list, risking exceeding the block gas limit. 2) `assert` statements in `payout` and `collectRentUser` will revert and consume all gas if their conditions fail, potentially blocking functionality if the state leads to consistent failures. 3) Extremely high rental rates could make calculations in `foreclosureTimeUser` or rent collection within `withdrawDeposit` computationally expensive, potentially hitting gas limits. 4) `withdrawDeposit` calls `collectRentUser` and potentially `orderbook.removeUserFromOrderbook`, which could fail or be gas-intensive, blocking withdrawals.', 'Impact': 'Users may be prevented from using certain functions (whitelist batching, payouts, withdrawals), potentially locking funds or access due to gas limits or unavoidable reverts.', 'Location': 'RCTreasury.sol: batchAddToWhitelist, payout, collectRentUser, foreclosureTimeUser, withdrawDeposit (multiple locations)'}, {'Issue': 'Inconsistent Access Control and Authorization Logic', 'Severity': 'Medium', 'Description': ""Access control relies on different mechanisms with potential weaknesses: 1) Whitelist management (`addToWhitelist`) depends on `factory.isGovernor(msgSender())`, linking its security to the external factory contract. 2) Some critical setters (`setOrderbookAddress`, `setNftHubAddress`) are restricted only to `uberOwner`, while others might involve the factory, creating inconsistency. 3) The `batchAddToWhitelist` function calls `addToWhitelist` internally but doesn't reimplement the governor check directly at the batch level, relying on the internal call's check."", 'Impact': 'Potential bypass of intended access control if the factory contract is compromised or if inconsistencies are exploited. Unauthorized modification of whitelist or critical contract addresses.', 'Location': 'RCTreasury.sol: addToWhitelist, batchAddToWhitelist, setOrderbookAddress, setNftHubAddress, other setters (approx. lines 171-278 across versions)'}, {'Issue': 'Foreclosure Logic Inconsistencies and Potential Errors', 'Severity': 'Medium', 'Description': 'The logic determining foreclosure status (`isForeclosed`) and timing (`foreclosureTimeUser`) has several potential issues: 1) The check in `deposit` to potentially un-foreclose a user might not trigger correctly for small deposits due to the order of operations or comparison logic. 2) `withdrawDeposit` contains complex logic to set `isForeclosed` based on comparisons and the return value of an external call (`orderbook.removeUserFromOrderbook`), which could lead to incorrect status updates. 3) `foreclosureTimeUser` calculation might be inaccurate, especially when considering rent already owed, potentially leading to incorrect foreclosure time predictions.', 'Impact': 'Users might be incorrectly marked as foreclosed (or not foreclosed), leading to improper bid removal/retention, inaccurate system state, and potential financial disadvantage.', 'Location': 'RCTreasury.sol: deposit, withdrawDeposit, foreclosureTimeUser, collectRentUser (multiple locations)'}, {'Issue': 'Lack of Input Validation on Critical Parameters and Addresses', 'Severity': 'Low', 'Description': ""Several functions lack robust input validation: 1) Setters like `setFactoryAddress`, `setOrderbookAddress`, `setNftHubAddress`, `setTokenAddress`, `setBridgeAddress` check against zero address but don't validate if the address is a contract or implements the expected interface. 2) `setMinRental` and `setMaxContractBalance` lack checks for reasonable values (e.g., setting `minRentalDayDivisor` to 0 would cause division-by-zero errors). 3) The constructor might lack zero-address checks for initially set addresses. 4) `topupMarketBalance` lacks slippage protection if transfers involve DEX interactions indirectly, and has no upper bound check on the amount. 5) `refundUser` doesn't check if `marketBalance` is sufficient before subtraction. 6) Whitelist functions lack checks for duplicate entries."", 'Impact': 'Potential for misconfiguration, denial-of-service (division by zero), unexpected behavior, runtime errors, wasted gas, minor financial loss due to slippage, accounting inconsistencies.', 'Location': 'RCTreasury.sol: constructor, set...Address functions, setMinRental, setMaxContractBalance, topupMarketBalance, refundUser, addToWhitelist, batchAddToWhitelist (multiple locations)'}, {'Issue': 'Reliance on `block.timestamp`', 'Severity': 'Low', 'Description': 'The contract heavily relies on `block.timestamp` for critical logic like rent calculation and foreclosure timing. While generally reliable on L2s, miners/sequencers have a limited ability to influence timestamps. This could potentially be exploited for minor advantages in foreclosure timing, although significant manipulation is unlikely on major networks. There are no sanity checks on time variables (e.g., ensuring monotonicity).', 'Impact': 'Minor inaccuracies in rent/foreclosure timing; low potential for manipulation.', 'Location': 'Multiple locations involving time-based calculations (rentOwedUser, collectRentUser, foreclosureTimeUser, etc.)'}, {'Issue': 'Potential Front-Running in Whitelist Management', 'Severity': 'Low', 'Description': 'The `addToWhitelist` and `batchAddToWhitelist` functions, callable by the factory governor, are susceptible to front-running. A malicious actor observing the transaction pool could potentially anticipate a user being added to the whitelist and execute transactions (e.g., deposits, if other conditions allow) exploiting this knowledge or simply add their own address first if the governor role is compromised.', 'Impact': 'Unfair advantage for front-runners, potential for minor DoS or griefing by filling whitelist slots. Limited impact unless combined with other vulnerabilities.', 'Location': 'RCTreasury.sol: addToWhitelist, batchAddToWhitelist (approx. lines 170-191, 225-231 across versions)'}], 'IssueNumber': 78, 'OutputList': 12}",323.823477983475,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Unchecked ERC20 transfers can cause lock up**

**Report Description**:  
The issue highlights that some ERC20 tokens do not revert on transfer failures, which can lead to discrepancies in token balances. The `topupMarketBalance` function lacks the `balancedBooks` modifier, allowing malicious actors to manipulate `marketBalance` without actual token transfers, potentially locking up key functions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the specific issue of unchecked ERC20 transfers or the missing `balancedBooks` modifier in `topupMarketBalance`. This is a critical oversight, as the issue directly impacts contract functionality and security.

---

#### **[H-02] Can access cards of other markets**

**Report Description**:  
The `ownerOf` and `onlyTokenOwner` functions in `RCMarket.sol` do not validate if `_cardId` is within the bounds of `numberOfCards`. This allows access to cards from other markets, potentially bypassing market approval checks in `upgradeCard`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of out-of-bounds access to cards in other markets. This is a significant security vulnerability that could lead to unauthorized actions.

---

#### **[H-04] Anyone can affect deposits of any user and turn the owner of the token**

**Report Description**:  
The `collectRentUser` function is public, allowing anyone to foreclose users by calling it with arbitrary parameters. This can be exploited to manipulate token ownership by foreclosing all bidders and placing a low bid.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Calculation and Logic in `collectRentUser`""**.

**Validation**:  
**Partially Correct**. The response identifies issues with `collectRentUser` but focuses on incorrect calculations and logic rather than the public accessibility and foreclosure exploitation. The core issue of unauthorized foreclosure is not fully addressed.

---

#### **[M-01] payout doesn't fix `isForeclosed` state**

**Report Description**:  
The `payout` function does not update the `isForeclosed` state of a user, even though receiving funds could resolve their foreclosure status. This inconsistency could lead to incorrect system behavior.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of the `isForeclosed` state not being updated in the `payout` function. This is a medium-severity issue that could lead to incorrect accounting.

---

#### **[M-02] Critical `uberOwner` address changes should be a two-step process**

**Report Description**:  
The `changeUberOwner` function allows the `uberOwner` to change their address without validation, risking system lockup if an invalid address is used. A two-step process is recommended to prevent this.

**Match in Response List**:  
Matches with the issue titled **""Centralized Control via `uberOwner`""**.

**Validation**:  
**Correct**. The response accurately identifies the risks associated with the `uberOwner` address change and the lack of validation. It aligns with the issue's concerns about centralized control and potential system lockup.

---

#### **[M-03] Missing `balancedBooks` modifier could result in failed system insolvency detection**

**Report Description**:  
The `balancedBooks` modifier is missing in `refundUser` and `topupMarketBalance`, which could lead to undetected insolvency if funds are mismanaged.

**Match in Response List**:  
Matches with the issue titled **""Market Balance Discrepancy Management Issues""**.

**Validation**:  
**Partially Correct**. The response discusses issues with `marketBalanceDiscrepancy` but does not explicitly address the missing `balancedBooks` modifier in `refundUser` and `topupMarketBalance`. The core issue of insolvency detection is partially covered.

---

#### **[M-16] Deposits can be denied by abusing `maxContractBalance`**

**Report Description**:  
A whale can front-run deposits to push the contract balance to the `maxContractBalance` limit, preventing other users from depositing. The whale can then withdraw, allowing them to control deposit access.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of deposit denial through `maxContractBalance` abuse. This is a medium-severity issue that could lead to unfair access control.

---

#### **[M-17] Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected**

**Report Description**:  
The `foreclosureTimeUser` function underestimates the foreclosure time due to incorrect calculations, potentially leading to premature foreclosures and incorrect card ownership determinations.

**Match in Response List**:  
Matches with the issue titled **""Foreclosure Logic Inconsistencies and Potential Errors""**.

**Validation**:  
**Correct**. The response accurately identifies issues with foreclosure logic, including incorrect calculations in `foreclosureTimeUser`. It aligns with the issue's concerns about premature foreclosures and inaccurate timing.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-02] Critical `uberOwner` address changes should be a two-step process**
- **[M-17] Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected**

**Partially Correct Matches**:

- **[H-04] Anyone can affect deposits of any user and turn the owner of the token**
- **[M-03] Missing `balancedBooks` modifier could result in failed system insolvency detection**

**Missed Issues from Issue Report**:

- **[H-01] Unchecked ERC20 transfers can cause lock up**
- **[H-02] Can access cards of other markets**
- **[M-01] payout doesn't fix `isForeclosed` state**
- **[M-16] Deposits can be denied by abusing `maxContractBalance`**

---

### **Conclusion**

The response list covers some issues accurately but misses several critical vulnerabilities, particularly those related to unchecked ERC20 transfers, out-of-bounds access, and deposit denial. Additionally, some matches are only partially correct, as they do not fully address the core issues described in the report. Improvements are needed to ensure comprehensive coverage of all identified vulnerabilities.","```
1. Critical `uberOwner` address changes should be a two-step process
2. Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected
```",0.0
RCMarket.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";

/// @title Reality Cards Market
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    // CONTRACT SETUP
    /// @dev = how many outcomes/teams/NFTs etc
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    /// @dev type of event.
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    /// @dev so the Factory can check it's a market
    bool public constant override isMarket = true;
    /// @dev counts the total NFTs minted across all events at the time market created
    /// @dev nft tokenId = card Id + totalNftMintCount
    uint256 public totalNftMintCount;

    // CONTRACT VARIABLES
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    // PRICE, DEPOSITS, RENT
    /// @dev in wei
    mapping(uint256 => uint256) public cardPrice;
    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.
    mapping(address => uint256) public rentCollectedPerUser;
    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout
    mapping(uint256 => uint256) public rentCollectedPerCard;
    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    /// @dev an easy way to track the above across all cards
    uint256 public totalRentCollected;
    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)
    mapping(address => uint256) public exitedTimestamp;

    // PARAMETERS
    /// @dev read from the Factory upon market creation, can not be changed for existing market
    /// @dev the minimum required price increase in %
    uint256 public minimumPriceIncreasePercent;
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public minRentalDayDivisor;
    /// @dev maximum number of times to calcualte rent in one transaction
    uint256 public maxRentIterations;

    // TIME
    /// @dev how many seconds each user has held each card for, for determining winnings
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld
    mapping(uint256 => uint256) public totalTimeHeld;
    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.
    mapping(uint256 => uint256) public timeLastCollected;
    /// @dev to track the max timeheld of each card (for giving NFT to winner)
    mapping(uint256 => uint256) public longestTimeHeld;
    /// @dev to track who has owned it the most (for giving NFT to winner)
    mapping(uint256 => address) public longestOwner;
    /// @dev to track the card timeHeldLimit for the current owner
    mapping(uint256 => uint256) public cardTimeLimit;

    // TIMESTAMPS
    /// @dev when the market opens
    uint32 public marketOpeningTime;
    /// @dev when the market locks
    uint32 public override marketLockingTime;
    /// @dev when the question can be answered on realitio
    /// @dev only needed for circuit breaker
    uint32 public oracleResolutionTime;

    // PAYOUT VARIABLES
    uint256 public winningOutcome;
    /// @dev prevent users withdrawing twice
    mapping(address => bool) public userAlreadyWithdrawn;
    /// @dev prevent users claiming twice
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool
    /// @dev the artist
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    /// @dev the affiliate
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    /// @dev the winner
    uint256 public winnerCut;
    /// @dev the market creator
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    /// @dev card specific recipients
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    // ORACLE VARIABLES
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _numberOfCards how many Cards in this market
    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _marketCreatorAddress where to send market creator's cut, if any
    /// @param _realitioQuestion the question posted to the Oracle
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        // external contract variables:
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        // get adjustable parameters from the factory/treasury
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        // initialiiize!
        winningOutcome = MAX_UINT256; // default invalid

        // assign arguments to public variables
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        // reduce artist cut to zero if zero adddress set
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        // reduce affiliate cut to zero if zero adddress set
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        // check the validity of card affiliate array.
        // if not valid, reduce payout to zero
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        // if winner takes all mode, set winnerCut to max
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        // post question to Oracle
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        // move to OPEN immediately if market opening time in the past
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    /*╔═════════════════════════════════╗
      ║            MODIFIERS            ║
      ╚═════════════════════════════════╝*/

    /// @notice automatically opens market if appropriate
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    /// @notice automatically locks market if appropriate
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    /// @dev can only be called by Card owners
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║     NFT HUB CONTRACT CALLS      ║
      ╚═════════════════════════════════╝*/

    /// @notice send NFT to mainnet
    /// @dev upgrades not possible if market not approved
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    /// @notice gets the owner of the NFT via their Card Id
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    /// @notice gets tokenURI via their Card Id
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called internally during contract open state
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called externaly by Orderbook during contract open state
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    /*╔═════════════════════════════════╗
      ║        ORACLE FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @dev called within initializer only
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    /// @notice has the oracle finalised
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    /// @dev sets the winning outcome
    /// @dev market.setWinner() will revert if done twice, because wrong state
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        // check market state to prevent market closing early
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        // call the market
        setWinner(uint256(_winningOutcome));
    }

    /// @dev admin override of the oracle
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    /*╔═════════════════════════════════╗
      ║  MARKET RESOLUTION FUNCTIONS    ║
      ╚═════════════════════════════════╝*/

    /// @notice checks whether the competition has ended, if so moves to LOCKED state
    /// @dev can be called by anyone
    /// @dev public because called within autoLock modifier & setWinner
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        // do a final rent collection before the contract is locked down

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                // bring the cards back to the market so the winners get the satisfcation of claiming them
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    /// @notice called by getWinnerFromOracle, sets the winner
    /// @param _winningOutcome the index of the winning card
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            // change the locking time to allow lockMarket to lock
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            // get the winner. This will revert if answer is not resolved.
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    /// @notice pays out winnings, or returns funds
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    /// @notice the longest owner of each NFT gets to keep it
    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known
    /// @param _card the id of the card, the index
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    /// @notice pays winnings
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        // calculate longest owner's extra winnings, if relevant
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            // return all rent paid on winning card
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            // calculate normal winnings, if any
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    /// @notice returns all funds to users in case of invalid outcome
    function _returnRent() internal {
        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    /// @notice all payouts happen through here
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)
    /// @dev they are not called within setWinner() because of the risk of an
    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings
    /// @dev [hangover from when ether was native currency, keeping in case we return to this]

    /// @notice pay artist
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    /// @notice pay market creator
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    /// @notice pay affiliate
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    /// @notice pay card affiliate
    /// @dev does not call _processStakeholderPayment because it works differently
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             EXTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @dev basically functions that have _checkState(States.OPEN) on first line

    /// @notice collects rent for all cards
    /// @dev cannot be external because it is called within the lockMarket function, therefore public
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    /// @notice rent every Card at the minimum price
    /// @param _maxSumOfPrices a limit to the sum of the bids to place
    function rentAllCards(uint256 _maxSumOfPrices) external {
        // check that not being front run
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    /// @notice to rent a Card
    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate
    /// @param _newPrice the price to rent the card for
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _startingPosition where to start looking to insert the bid into the orderbook
    /// @param _card the index of the card to update
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    // the owner may only increase by more than X% or reduce their price
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                // do some cleaning up before we collect rent or check their bidRate
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                // check sufficient deposit
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                // replaces _newBid and _updateBid
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    /// @notice to change your timeHeldLimit without having to re-rent
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _card the index of the card to update
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    /// @notice stop renting all cards
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    /// @notice stop renting a card and/or remove from orderbook
    /// @dev public because called by exitAll()
    /// @dev doesn't need to be current owner so user can prevent ownership returning to them
    /// @dev does not apply minimum rental duration, because it returns ownership to the next user
    /// @param _card The card index to exit
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        // block frontrunning attack
        exitedTimestamp[_msgSender] = block.timestamp;

        // collectRent first
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            // if current owner, find a new one
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            // if not owner, just delete from orderbook
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by user, sponsor is msgSender
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    /// @dev actually processes the sponsorship
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        // send tokens to the Treasury
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        // just so user can get it back if invalid outcome
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        // allocate equally to each card, in case card specific affiliates
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             INTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @notice collects rent for a specific card
    /// @dev also calculates and updates how long the current user has held the card for
    /// @dev is not a problem if called externally, but making internal over public to save gas
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        // don't collect rent beyond the locking time
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)
        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            // Calculate the card timeLimitTimestamp
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            // input bools
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            // outputs
            bool _newOwner;
            uint256 _refundTime; // seconds of rent to refund the user

            /* Permutations of the events: Foreclosure, Time limit and Market Locking
            ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐
            │Case       │1│2│3│4│5│6│7│8│
            ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤
            │Foreclosure│0│0│0│0│1│1│1│1│
            │Time Limit │0│0│1│1│0│0│1│1│
            │Market Lock│0│1│0│1│0│1│0│1│
            └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘
            */

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 1
                // didn't foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN simple rent collect, same owner
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                // CASE 2
                // didn't foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN refund rent between locking and now
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                // CASE 3
                // didn't foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN refund rent between time limit and now
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                // CASE 4
                // didn't foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN refund rent between the earliest event and now
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    // time limit hit before market locked
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    // market locked before time limit hit
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 5
                // did foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN rent OK, find new owner
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                // CASE 6
                // did foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN if foreclosed first rent ok, otherwise refund after locking
                if (_timeUserForeclosed < marketLockingTime) {
                    // user foreclosed before market locked
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // market locked before user foreclosed
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                // CASE 7
                // did foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN if foreclosed first rent ok, otherwise refund after limit
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    // user foreclosed before time limit
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // time limit hit before user foreclosed
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                // CASE 8
                // did foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN (╯°益°)╯彡┻━┻
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    // user foreclosed first (or at same time as time limit)
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    // time limit hit first
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    // market locked first
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking
            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls
    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    /// @dev processes actual rent collection and updates the state
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        // if the user has a timeLimit, adjust it as necessary
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        // longest owner tracking
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    /// @dev should only be called thrice
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    /*╔═════════════════════════════════╗
      ║        CIRCUIT BREAKER          ║
      ╚═════════════════════════════════╝*/

    /// @dev in case Oracle never resolves for any reason
    /// @dev does not set a winner so same as invalid outcome
    /// @dev market does not need to be locked, just in case lockMarket bugs out
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",10267,1122,"[H-03] anyone can call function sponsor

Submitted by paulius.eth, also found by 0xRajeev, cmichel, and shw
This function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:
```     /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }
``  [M-07] maxSumOfPrices check is broken
`rentAllCards()` requires the sender to specify a _maxSumOfPrices parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.
However, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total number of bids placed greater than the _maxSumOfPrices specified.
The impact of this is that the user may not have sufficient deposited, be foreclosed upon and/or impacted on other bids/markets.
  [M-13] Wrong calculation on _collectRentAction
The method _collectRentAction contains the following code:
in case 6, it is doing: ```
_refundTime = block.timestamp - marketLockingTime;
```
instead of: ```
_refundTime = _timeUserForeclosed - marketLockingTime;
```",3,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";




contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    

    
    
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    
    bool public constant override isMarket = true;
    
    
    uint256 public totalNftMintCount;

    
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    
    
    mapping(uint256 => uint256) public cardPrice;
    
    mapping(address => uint256) public rentCollectedPerUser;
    
    mapping(uint256 => uint256) public rentCollectedPerCard;
    
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    
    uint256 public totalRentCollected;
    
    mapping(address => uint256) public exitedTimestamp;

    
    
    
    uint256 public minimumPriceIncreasePercent;
    
    uint256 public minRentalDayDivisor;
    
    uint256 public maxRentIterations;

    
    
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    
    mapping(uint256 => uint256) public totalTimeHeld;
    
    mapping(uint256 => uint256) public timeLastCollected;
    
    mapping(uint256 => uint256) public longestTimeHeld;
    
    mapping(uint256 => address) public longestOwner;
    
    mapping(uint256 => uint256) public cardTimeLimit;

    
    
    uint32 public marketOpeningTime;
    
    uint32 public override marketLockingTime;
    
    
    uint32 public oracleResolutionTime;

    
    uint256 public winningOutcome;
    
    mapping(address => bool) public userAlreadyWithdrawn;
    
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; 
    
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    
    uint256 public winnerCut;
    
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    

    
    
    
    
    
    
    
    
    
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        
        winningOutcome = MAX_UINT256; 

        
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        
        
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    

    
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    

    
    
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); 
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    
    
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    
    
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    

    
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    
    
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        
        setWinner(uint256(_winningOutcome));
    }

    
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    

    
    
    
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    
    
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    
    
    
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    
    function _returnRent() internal {
        
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    
    
    
    

    
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    
    
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    

    

    
    
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    
    
    function rentAllCards(uint256 _maxSumOfPrices) external {
        
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    
    
    
    
    
    
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    
    
    
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    
    
    
    
    
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        
        exitedTimestamp[_msgSender] = block.timestamp;

        
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    
    
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    
    
    
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    

    
    
    
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        
        
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            
            bool _newOwner;
            uint256 _refundTime; 

            

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                
                
                
                
                
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                
                
                
                
                
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                
                
                
                
                
                if (_timeUserForeclosed < marketLockingTime) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                
                
                
                
                
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                
                
                
                
                
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); 

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            
            
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    
    
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    

    
    
    
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    
}",6724,1,2,"{'task_list': [{'Area': 'Access Control and Authorization', 'Tasks': ['Verify that only the `orderbook` contract can call the `transferCard` function.', 'Confirm that the `factory.owner()` address is the only address authorized to call `setAmicableResolution`.', 'Analyze the `circuitBreaker` function to ensure the time delay is sufficient to prevent abuse and the consequences of triggering the circuit breaker are acceptable.', 'Verify that access to functions modifying critical market parameters (e.g., stakeholder cuts) is restricted to authorized roles/addresses within the `factory` contract and that these parameters cannot be maliciously altered after market initialization.']}, {'Area': 'Rent Collection Logic & Potential Exploits', 'Tasks': ['Thoroughly analyze the `_collectRentAction` function to identify potential vulnerabilities related to the complex conditional logic for foreclosure, time limits, and market locking. Specifically, ensure that all edge cases and combinations of conditions are correctly handled to prevent unintended behavior or loss of funds.', 'Investigate the gas cost implications of the `_collectRent` loop, especially when it reaches `maxRentIterations`. Determine if it can lead to out-of-gas errors, potentially halting the market, and if it can be used as a griefing vector. Consider adding gas limits or alternative logic to mitigate this risk.', 'Examine the interactions between `_collectRentAction` and `treasury.collectRentUser`. What happens if `treasury.collectRentUser` reverts or fails? Does the `RCMarket` contract handle this gracefully, or could it lead to inconsistencies or loss of funds?', 'Analyze the potential impact of manipulating `cardPrice` values on the rent collection process. Can a malicious user artificially inflate or deflate prices to exploit the rent distribution mechanism?', 'Verify that the `minRentalDayDivisor` cannot be set to zero to avoid division by zero errors when calculating deposit requirements.']}, {'Area': 'State Management and Market Progression', 'Tasks': ['Review the state transition logic (`_incrementState`) to ensure it is robust and cannot be manipulated to prematurely advance or revert the market state.', 'Verify the correct behavior of `autoUnlock` and `autoLock` modifiers to ensure market transitions occur as intended based on timestamps.', 'Analyze the potential consequences of the `marketLockingTime` being manipulated or set to a value in the past. How does this affect rent collection, oracle resolution, and payouts?', 'Determine if the `questionFinalised` flag accurately reflects the finalization status of the oracle question, and if there are any scenarios where the market can proceed without proper oracle resolution.']}, {'Area': 'External Interactions & Reentrancy', 'Tasks': ['Conduct a thorough reentrancy analysis of the `_collectRentAction` function, paying close attention to its interactions with the `treasury` and `orderbook` contracts. Determine if any reentrancy vulnerabilities exist, and implement appropriate safeguards (e.g., reentrancy guard locks) if necessary.', 'Examine the trust assumptions related to the external contracts (`factory`, `treasury`, `nfthub`, `orderbook`, `realitio`). Ensure that these contracts are trustworthy and do not contain vulnerabilities that could be exploited by the `RCMarket` contract.', 'Analyze the data flow between `RCMarket` and `NftHub` during the `upgradeCard` process. Verify that the correct NFT is being transferred and that there are no opportunities for malicious users to steal or manipulate NFTs.', 'Assess the potential risks associated with relying on `realitio` for oracle resolution. Are there any known vulnerabilities or limitations in `realitio` that could affect the integrity of the market?']}, {'Area': 'Payout Logic & Stakeholder Cuts', 'Tasks': [""Carefully examine the payout logic in `_payoutWinnings` and `_returnRent` to ensure that funds are distributed fairly and accurately according to the market's rules and stakeholder agreements."", 'Verify that the calculations for stakeholder cuts (artist, creator, affiliate, card affiliate) are correct and cannot be manipulated to favor certain parties.', 'Analyze the impact of different `Mode` settings on payout calculations. Ensure that the payout logic for `CLASSIC`, `WINNER_TAKES_ALL`, and `SAFE_MODE` is well-defined and functions as intended.', 'Investigate the potential for rounding errors in payout calculations and their impact on fund distribution. Implement appropriate rounding strategies to minimize discrepancies and prevent loss of funds.', 'Verify that the `userAlreadyWithdrawn` and `userAlreadyClaimed` mappings prevent users from withdrawing or claiming multiple times, and that this mechanism cannot be bypassed.']}, {'Area': 'Oracle Integrity and Dispute Resolution', 'Tasks': ['Verify the integrity of the oracle resolution process and the handling of the `winningOutcome`. Ensure that the outcome is determined fairly and accurately, and that there are no opportunities for malicious users to manipulate the oracle or the resolution process.', ""Analyze the potential consequences of a delayed or failed oracle resolution. How does this affect the market's progression, payouts, and the ability for users to withdraw their funds?"", 'Evaluate the dispute resolution mechanisms provided by `realitio` and ensure that they are sufficient to address any potential disputes or disagreements related to the oracle outcome.', 'Verify that the `setAmicableResolution` function is only callable by the intended authorized address (factory owner) and that it cannot be used to maliciously override the oracle outcome.']}, {'Area': 'Sponsorship Functionality', 'Tasks': ['Review the sponsor function for unintended behavior. Ensure it can not be used maliciously.', 'Check the sponsorship integration with the rent collection logic.']}, {'Area': 'Tokenomics and Price Manipulation', 'Tasks': ['Analyze the potential for price manipulation by users repeatedly renting and exiting cards to influence rent distribution.', 'Assess the impact of large sponsorship amounts on the overall rent distribution and fairness of the market.']}]}","{'ReviewingTheCode': ""The RCMarket contract implements a prediction market based on a continuous rental (Harberger tax) mechanism using NFTs. Users place bids representing the price they'd pay to own/rent an NFT representing a specific outcome. The current owner pays rent based on their set price. Rent accumulates in a central pot. The market has distinct phases (Closed, Open, Locked, Withdraw) controlled by timestamps and an external oracle (Realitio) for outcome resolution. Funds are distributed post-resolution based on time held, the winning outcome, and pre-defined stakeholder cuts. It heavily interacts with other contracts (Factory, Treasury, NftHub, Orderbook) for core functionality like NFT management, fund handling, and bid management."", 'IdentifyingKeyComponents': {'ContractName': 'RCMarket', 'Purpose': 'To manage a prediction market where participants rent NFTs representing outcomes, paying based on a self-assessed price (Harberger Tax). It handles the market lifecycle, rent collection, outcome resolution via an oracle, and distribution of the collected rent.', 'InheritanceAndImports': {'InheritsFrom': ['Initializable', 'NativeMetaTransaction', 'IRCMarket'], 'Imports': ['@openzeppelin/contracts/proxy/utils/Initializable.sol', '@openzeppelin/contracts/utils/math/SafeCast.sol', 'hardhat/console.sol', './interfaces/IRealitio.sol', './interfaces/IRCFactory.sol', './interfaces/IRCTreasury.sol', './interfaces/IRCMarket.sol', './interfaces/IRCNftHubL2.sol', './interfaces/IRCOrderbook.sol', './lib/NativeMetaTransaction.sol']}, 'StateVariables': [{'Name': 'numberOfCards', 'Type': 'uint256', 'Purpose': 'Total number of distinct outcome NFTs in this market.'}, {'Name': 'state', 'Type': 'States (enum)', 'Purpose': 'Current state of the market (CLOSED, OPEN, LOCKED, WITHDRAW).'}, {'Name': 'mode', 'Type': 'Mode (enum)', 'Purpose': 'Determines the payout logic (CLASSIC, WINNER_TAKES_ALL, SAFE_MODE).'}, {'Name': 'totalNftMintCount', 'Type': 'uint256', 'Purpose': 'Offset used to calculate the global ERC721 token ID for cards specific to this market.'}, {'Name': 'treasury', 'Type': 'IRCTreasury', 'Purpose': 'Reference to the Treasury contract managing deposits and fund movements.'}, {'Name': 'factory', 'Type': 'IRCFactory', 'Purpose': 'Reference to the Factory contract used for initialization and settings.'}, {'Name': 'nfthub', 'Type': 'IRCNftHubL2', 'Purpose': 'Reference to the NFT Hub contract managing the ERC721 tokens.'}, {'Name': 'orderbook', 'Type': 'IRCOrderbook', 'Purpose': 'Reference to the Orderbook contract managing bids and owner transitions.'}, {'Name': 'cardPrice', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Stores the current self-assessed price (rental rate basis) for each card.'}, {'Name': 'rentCollected*', 'Type': 'mappings/uint256', 'Purpose': 'Track total rent collected, per user, per card, and per user per card.'}, {'Name': 'timeHeld*', 'Type': 'mappings/uint256', 'Purpose': 'Track time each user held each card, total time held per card, and last collection time.'}, {'Name': 'longestOwner/longestTimeHeld', 'Type': 'mapping(uint256 => address)/mapping(uint256 => uint256)', 'Purpose': 'Tracks the user who held each card for the longest duration.'}, {'Name': 'cardTimeLimit', 'Type': 'mapping(uint256 => uint256)', 'Purpose': 'Stores the remaining time limit for the current owner of a card, if set.'}, {'Name': 'marketOpeningTime/marketLockingTime/oracleResolutionTime', 'Type': 'uint32', 'Purpose': 'Timestamps defining market phases and oracle deadline.'}, {'Name': 'winningOutcome', 'Type': 'uint256', 'Purpose': 'Stores the outcome determined by the oracle or resolution process.'}, {'Name': 'userAlreadyWithdrawn/userAlreadyClaimed', 'Type': 'mappings', 'Purpose': 'Flags to prevent users from withdrawing winnings or claiming NFTs multiple times.'}, {'Name': 'artist/affiliate/creator/cardAffiliate *', 'Type': 'address/uint256/bool/address[]', 'Purpose': 'Stores stakeholder addresses, their percentage cuts, and payment status.'}, {'Name': 'questionId/questionFinalised/realitio/arbitrator/timeout', 'Type': 'bytes32/bool/IRealitio/address/uint32', 'Purpose': 'Variables related to the Realitio oracle question and its resolution.'}], 'FunctionsAndModifiers': [{'Name': 'initialize', 'Visibility': 'external', 'Purpose': ""Sets up the market's initial state, parameters, dependencies, and posts the question to the oracle. Called once by the factory."", 'Parameters': ['_mode', '_timestamps', '_numberOfCards', '_totalNftMintCount', '_artistAddress', '_affiliateAddress', '_cardAffiliateAddresses', '_marketCreatorAddress', '_realitioQuestion'], 'Returns': []}, {'Name': 'autoUnlock / autoLock', 'Visibility': 'internal (modifier)', 'Purpose': 'Modifiers to automatically transition the market state based on time.', 'Parameters': [], 'Returns': []}, {'Name': 'onlyTokenOwner', 'Visibility': 'internal (modifier)', 'Purpose': 'Restricts function access to the owner of a specific card NFT.', 'Parameters': ['_token'], 'Returns': []}, {'Name': 'upgradeCard', 'Visibility': 'external', 'Purpose': 'Allows the final owner of a card to upgrade it to a permanent NFT after the market concludes.', 'Parameters': ['_card'], 'Returns': []}, {'Name': 'ownerOf / tokenURI', 'Visibility': 'public view', 'Purpose': 'Retrieves NFT owner or metadata URI by delegating to NftHub.', 'Parameters': ['_cardId'], 'Returns': ['address / string']}, {'Name': '_transferCard', 'Visibility': 'internal', 'Purpose': 'Helper function to transfer card NFTs via NftHub.', 'Parameters': ['_from', '_to', '_cardId'], 'Returns': []}, {'Name': 'transferCard', 'Visibility': 'external', 'Purpose': 'Called ONLY by the Orderbook contract to finalize an ownership change, updating price and time limit.', 'Parameters': ['_from', '_to', '_cardId', '_price', '_timeLimit'], 'Returns': []}, {'Name': 'getWinnerFromOracle / setAmicableResolution / setWinner', 'Visibility': 'external / external / internal', 'Purpose': ""Functions to determine and set the market's winning outcome based on Realitio or authorized override."", 'Parameters': ['various'], 'Returns': []}, {'Name': 'lockMarket', 'Visibility': 'public', 'Purpose': 'Transitions the market to the LOCKED state after the locking time, collecting final rent and transferring NFTs to the contract.', 'Parameters': [], 'Returns': []}, {'Name': 'withdraw', 'Visibility': 'external', 'Purpose': 'Allows users to withdraw their share of the winnings or returned rent after the market is resolved.', 'Parameters': [], 'Returns': []}, {'Name': 'claimCard', 'Visibility': 'external', 'Purpose': ""Allows the user identified as the 'longest owner' of a card to claim the NFT after the market concludes."", 'Parameters': ['_card'], 'Returns': []}, {'Name': 'payArtist / payMarketCreator / payAffiliate / payCardAffiliate', 'Visibility': 'external', 'Purpose': 'Functions for stakeholders to claim their respective cuts of the collected rent.', 'Parameters': ['optional _card'], 'Returns': []}, {'Name': 'collectRentAllCards / _collectRent / _collectRentAction', 'Visibility': 'public / internal / internal', 'Purpose': 'Functions implementing the core rent collection logic, handling time calculations, potential foreclosures, time limits, and interactions with Treasury and Orderbook.', 'Parameters': ['optional _card'], 'Returns': ['bool']}, {'Name': 'newRental', 'Visibility': 'public', 'Purpose': 'Allows a user to place a new bid (rental offer) on a card, potentially taking ownership.', 'Parameters': ['_newPrice', '_timeHeldLimit', '_startingPosition', '_card'], 'Returns': []}, {'Name': 'updateTimeHeldLimit', 'Visibility': 'external', 'Purpose': 'Allows a user to update their desired holding time limit for a card.', 'Parameters': ['_timeHeldLimit', '_card'], 'Returns': []}, {'Name': 'exit / exitAll', 'Visibility': 'public / external', 'Purpose': 'Allows a user to withdraw their bids from a specific card or all cards.', 'Parameters': ['optional _card'], 'Returns': []}, {'Name': 'sponsor', 'Visibility': 'external', 'Purpose': ""Allows users or other contracts to add funds (sponsorship) directly to the market's rent pot."", 'Parameters': ['_amount / _sponsorAddress, _amount'], 'Returns': []}, {'Name': 'circuitBreaker', 'Visibility': 'external', 'Purpose': 'Emergency function to force the market into the WITHDRAW state if oracle resolution fails after a long period.', 'Parameters': [], 'Returns': []}, {'Name': '_checkState / _checkNotState / _incrementState', 'Visibility': 'internal', 'Purpose': ""Helper functions for managing and validating the contract's state machine."", 'Parameters': ['currentState / newState'], 'Returns': []}]}, 'ExternalInteractions': ['IRCFactory: Used in `initialize` to get addresses of other core contracts (Treasury, NftHub, Orderbook), settings (cuts, oracle details, rent parameters), and potentially check market approval status. `owner()` can call `setAmicableResolution`.', 'IRCTreasury: Handles all monetary aspects: collecting rent (`payRent`), distributing payouts (`payout`), managing user deposits (`userDeposit`), checking foreclosure status (`isForeclosed`, `collectRentUser`), handling sponsorships (`sponsor`, `checkSponsorship`), refunds (`refundUser`), and tracking user bid totals (`userTotalBids`).', 'IRCNftHubL2: Manages the ERC721 tokens representing cards. Used for ownership checks (`ownerOf`), metadata (`tokenURI`), transfers (`transferNft`), and post-market NFT upgrades (`withdrawWithMetadata`).', 'IRCOrderbook: Manages the bidding logic. Used to add/remove bids (`addBidToOrderbook`, `removeOldBids`, `removeBidFromOrderbook`), find new owners when current ones exit/foreclose (`findNewOwner`), manage time limits (`setTimeHeldlimit`), and close the market (`closeMarket`). It is the sole caller of `transferCard`.', 'IRealitio: External oracle contract used to ask the market question (`askQuestion`), check finalization status (`isFinalized`), and retrieve the result (`resultFor`).'], 'SpecialMechanisms': [""Initializable Pattern: Uses OpenZeppelin's Initializable for proxy compatibility."", 'NativeMetaTransaction: Inherits functionality for gasless transactions via EIP-712 signatures.', 'Harberger Tax (Rental) Mechanism: Core economic model where owners pay rent based on self-assessed price.', 'State Machine: Market progresses through defined states (CLOSED, OPEN, LOCKED, WITHDRAW).', 'Oracle Integration (Realitio): Relies on an external oracle for decentralized outcome resolution.', 'NFT Representation: Market positions/outcomes are represented by ERC721 tokens managed externally.', 'Stakeholder Payout Structure: Predefined percentage cuts for artist, creator, affiliates.', 'Multiple Payout Modes: `Mode` enum affects winner determination and fund distribution.', 'Rent Collection Loop: `_collectRent` can iterate (`maxRentIterations`) to handle cascading ownership changes within one transaction.', 'Time Limits: Users can set maximum holding durations, triggering ownership changes.', 'Sponsorship: Allows direct injection of funds into the prize pool.', 'Circuit Breaker: Emergency mechanism for unresolved oracles.'], 'Questions': ['What are the precise mathematical differences in payout calculations between `Mode.CLASSIC`, `Mode.WINNER_TAKES_ALL`, and `Mode.SAFE_MODE`?', 'What are the gas cost implications of the `_collectRent` loop hitting `maxRentIterations`? Could this lead to out-of-gas errors or be a potential griefing vector?', ""Are there implicit re-entrancy protections assumed (e.g., within Treasury/Orderbook calls, or via OpenZeppelin defaults), or should explicit guards be considered, especially around `_collectRentAction`'s interactions?"", 'The complex conditional logic in `_collectRentAction` determining `_timeOfThisCollection`, `_newOwner`, `_refundTime` requires careful review. Are all edge cases involving simultaneous foreclosure, time limit expiry, and market locking correctly handled?', 'What mechanism prevents the `factory` address from being changed after deployment, ensuring the integrity of initial setup parameters accessed via `factory`?', 'How is the `_startingPosition` parameter in `newRental` used by the `orderbook`?', 'Is there potential for front-running attacks, particularly around the `newRental` function or oracle interactions?', 'What happens if `treasury.collectRentUser` reverts or fails during the `_collectRentAction` process?']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability in Payout Functions', 'Severity': 'High', 'Description': 'The `_payout` function, used by `payArtist`, `payMarketCreator`, `payAffiliate`, and `payCardAffiliate` (via `_processStakeholderPayment`), makes an external call to `treasury.payout`. If the `treasury` contract is malicious or vulnerable, it could re-enter the `RCMarket` contract during the payout process, potentially allowing an attacker to drain funds or manipulate contract state before internal state updates (like marking the stakeholder as paid) occur.', 'Impact': 'Potential for loss of funds through multiple payouts to the same stakeholder or manipulation of contract state via re-entrant calls.', 'Location': 'RCMarket.sol:_payout, RCMarket.sol:payArtist, RCMarket.sol:payMarketCreator, RCMarket.sol:payAffiliate, RCMarket.sol:payCardAffiliate, RCMarket.sol:_processStakeholderPayment'}, {'Issue': 'Potential Reentrancy Vulnerability in Rent Collection', 'Severity': 'High', 'Description': 'The `_collectRentAction` function, called within a loop by `_collectRent` and `collectRentAllCards`, interacts with the external `treasury` contract via `treasury.collectRentUser` and `treasury.refundUser`. If the `treasury` contract allows re-entrancy, a malicious user (or a compromised treasury) could potentially call back into the `RCMarket` contract (e.g., calling `exit` or `newRental`) before state changes like `timeLastCollected[_card]` are updated. This could lead to inconsistent states, multiple rent collections, or fund manipulation.', 'Impact': 'Potential for unauthorized rent collection, manipulation of ownership or foreclosure status, denial of service, or draining of contract/treasury funds.', 'Location': 'RCMarket.sol:_collectRentAction, RCMarket.sol:_collectRent, RCMarket.sol:collectRentAllCards'}, {'Issue': 'Potential Denial of Service via Gas Limit Exhaustion in Loops', 'Severity': 'High', 'Description': 'Functions like `collectRentAllCards` and `rentAllCards` iterate through all cards (`numberOfCards`). Inside `collectRentAllCards`, `_collectRent` is called, which itself contains a `while` loop iterating up to `maxRentIterations`. If `numberOfCards` or `maxRentIterations` is large, or if the logic within the loops (especially external calls in `_collectRentAction`) becomes complex or costly, executing these functions could exceed the block gas limit. This would cause transactions to revert, potentially preventing critical state transitions like market locking or preventing users from renting multiple cards.', 'Impact': 'Denial of service, preventing the market from locking (`collectRentAllCards` failure), blocking payouts, or hindering user interactions (`rentAllCards` failure). A single card causing `_collectRent` to fail repeatedly could halt `collectRentAllCards` entirely.', 'Location': 'RCMarket.sol:collectRentAllCards, RCMarket.sol:_collectRent, RCMarket.sol:_collectRentAction, RCMarket.sol:rentAllCards'}, {'Issue': 'Improper Use of `assert` and Missing Failure Checks', 'Severity': 'High', 'Description': 'The contract uses `assert` in several places (`_incrementState`, `_transferCard`, `_payout`) to check for conditions like state bounds or the success of external calls (e.g., `nfthub.transferNft`). `assert` is intended for invariant checking and consumes all remaining gas upon failure, which is inappropriate for validating external conditions or potential failures like NFT transfers. Furthermore, the return value of `nfthub.transferNft` within `_transferCard` (called by `lockMarket`) is not checked, meaning a failed transfer might go unnoticed, leading to state inconsistencies.', 'Impact': 'Unexpected reverts consuming all gas if `assert` fails on external conditions. Potential for inconsistent contract state (e.g., NFT ownership) if external call failures are not properly handled or checked, potentially leading to incorrect payouts or stuck NFTs.', 'Location': 'RCMarket.sol:_transferCard, RCMarket.sol:_incrementState, RCMarket.sol:_payout, RCMarket.sol:lockMarket'}, {'Issue': 'Centralization Risk and Improper Access Control on `setAmicableResolution`', 'Severity': 'High', 'Description': ""The `setAmicableResolution` function allows setting the market's winning outcome, bypassing the oracle. Access is restricted solely to `factory.owner()`. This creates a significant centralization risk, as a compromised or malicious factory owner can unilaterally dictate the market outcome, potentially manipulating payouts for personal gain. There is also no validation on the `_winningOutcome` parameter itself."", 'Impact': 'Potential for market manipulation and unfair distribution of funds if the factory owner is compromised or acts maliciously. Undermines the trust and decentralization of the market resolution process.', 'Location': 'RCMarket.sol:setAmicableResolution'}, {'Issue': 'Lack of Comprehensive Input Validation', 'Severity': 'Medium', 'Description': 'Several critical inputs lack sufficient validation, primarily in the `initialize` function. Missing checks include: ensuring `_timestamps` array contains elements in logical order (`marketOpeningTime <= marketLockingTime <= oracleResolutionTime`); verifying critical addresses (`_marketCreatorAddress`, `arbitrator`) are not zero; ensuring the sum of distribution cuts (`artistCut`, `creatorCut`, etc.) does not exceed 1000 (to prevent underflow in `winnerCut`); validating `_cardAffiliateAddresses` length matches `_numberOfCards` and contains no zero addresses; ensuring `numberOfCards` is greater than zero (relevant for `_sponsor`). Other functions like `setAmicableResolution` lack bounds checking for `_winningOutcome`, and `newRental` lacks an upper bound check for `_newPrice`.', 'Impact': 'Contract can be initialized in an invalid or unpredictable state, leading to incorrect market behavior, locked funds, denial of service, division by zero errors (`_sponsor`), or potential manipulation.', 'Location': 'RCMarket.sol:initialize, RCMarket.sol:_sponsor, RCMarket.sol:setAmicableResolution, RCMarket.sol:newRental'}, {'Issue': 'Potential Arithmetic Vulnerabilities (Overflow/Underflow/Precision Loss/Rounding/Division by Zero)', 'Severity': 'Medium', 'Description': 'The contract performs various arithmetic operations without consistent use of SafeMath or explicit checks, creating risks: 1) Integer Underflow: Calculating `winnerCut` in `initialize` or `_remainingCut` in payout functions (`_payoutWinnings`, `_returnRent`) can underflow if the sum of other cuts exceeds 1000. 2) Precision Loss/Rounding: Rent calculations in `_processRentCollection` (`cardPrice * timeDiff / 1 days`) and `_returnRent` (`rentCollected * cut / 1000`) use integer division, which truncates results and can lead to significant precision loss, especially with small amounts or time differences. Rent owed could round down to zero. 3) Division by Zero: `_payoutWinnings` divides by `totalTimeHeld[winningOutcome]`, which could be zero if the winner held the card for zero time (though partially mitigated by a require check). `_sponsor` divides by `numberOfCards`.', 'Impact': 'Incorrect calculation of cuts, rent owed, refunds, or winnings, leading to unfair distribution, potential loss of funds for stakeholders/users, or transaction reverts due to division by zero.', 'Location': 'RCMarket.sol:initialize, RCMarket.sol:_processRentCollection, RCMarket.sol:_returnRent, RCMarket.sol:_payoutWinnings, RCMarket.sol:_collectRentAction, RCMarket.sol:_sponsor'}, {'Issue': 'Lack of Granular Access Control on Critical Functions', 'Severity': 'Medium', 'Description': 'Several functions lack appropriate access control beyond basic state checks: 1) `circuitBreaker`: Can be called by any address once the time condition (`block.timestamp > oracleResolutionTime + 12 weeks`) is met, allowing potentially premature or disruptive state transition to `WITHDRAW`. 2) Stakeholder Payments (`payArtist`, `payMarketCreator`, `payAffiliate`, `payCardAffiliate`): Can be called by any address once the market is in the `WITHDRAW` state, potentially allowing repeated calls or triggering by unauthorized parties (although double payment is prevented by flags). 3) `exitAll`: Can be called by any user at any time, potentially enabling spamming/griefing attacks.', 'Impact': 'Unauthorized state transitions, potential for griefing or unnecessary gas expenditure by triggering payments, potential spamming leading to increased network congestion or costs for users.', 'Location': 'RCMarket.sol:circuitBreaker, RCMarket.sol:payArtist, RCMarket.sol:payMarketCreator, RCMarket.sol:payAffiliate, RCMarket.sol:payCardAffiliate, RCMarket.sol:exitAll'}, {'Issue': 'Potential Front-Running Vulnerabilities', 'Severity': 'Medium', 'Description': 'Certain actions are susceptible to front-running: 1) `newRental`: An attacker observing a `newRental` transaction in the mempool could submit their own transaction with a higher gas price to rent the card first or influence the price. The state increment logic within `newRental` based on `block.timestamp` could also be front-run, though potentially mitigated by `autoUnlock`. Bypassing the exit check using front-running is also possible. 2) `getWinnerFromOracle`: An attacker monitoring the oracle can call this function immediately after the result is available, front-running others to trigger the `setWinner` function and potentially gaining an advantage from knowing the outcome first (e.g., related MEV opportunities).', 'Impact': 'Users may fail to rent desired cards or pay higher prices due to front-running. Attackers could gain an unfair advantage by being the first to react to oracle results or specific timestamp conditions.', 'Location': 'RCMarket.sol:newRental, RCMarket.sol:getWinnerFromOracle'}, {'Issue': 'Fragile State Transition Logic', 'Severity': 'Medium', 'Description': ""The contract's state machine has potential weaknesses: 1) The `circuitBreaker` function transitions the state directly to `WITHDRAW` based only on a time delay, without checks for intermediate states or cleanup actions. It also increments the state before setting it explicitly, which is unusual. 2) The internal `_incrementState` function relies on callers (`lockMarket`, `setWinner`, `initialize`, `circuitBreaker`) to enforce correct transition conditions. A flaw in a calling function or front-running (e.g., calling `circuitBreaker` before `setWinner` determines the outcome) could lead to unexpected or incorrect state transitions."", 'Impact': 'Incorrect state transitions could bypass intended market phases (like locking or payout calculation), lead to inconsistent internal states, or allow premature withdrawals.', 'Location': 'RCMarket.sol:circuitBreaker, RCMarket.sol:_incrementState, RCMarket.sol:lockMarket, RCMarket.sol:setWinner'}, {'Issue': 'Incorrect Refund Logic in Rent Collection', 'Severity': 'Medium', 'Description': 'The `_collectRentAction` function calculates refunds (`_refundAmount`) in scenarios like foreclosure or hitting the time limit. The logic uses time differences involving `block.timestamp` and event timestamps (`_timeUserForeclosed`, `_timeLimitExpired`) in ways that may not accurately reflect the period for which a refund is due. For instance, calculating refund time based on time *after* an event seems incorrect.', 'Impact': 'Users may receive incorrect refund amounts, potentially leading to loss of funds for users or the protocol.', 'Location': 'RCMarket.sol:_collectRentAction'}, {'Issue': 'Time Dependency Risks', 'Severity': 'Medium', 'Description': 'The contract relies on `block.timestamp` for several critical state transitions and calculations (`lockMarket`, `getWinnerFromOracle`, `circuitBreaker`, `_processRentCollection`). While `block.timestamp` is generally reliable, it is subject to minor manipulation by miners (within seconds). This dependency could potentially be exploited in edge cases to influence when the market locks, resolves, or enters the circuit breaker state, or affect rent calculations slightly.', 'Impact': 'Minor potential for manipulation of market timing or rent calculations, potentially affecting outcomes or payouts in very specific circumstances.', 'Location': 'RCMarket.sol:lockMarket, RCMarket.sol:getWinnerFromOracle, RCMarket.sol:circuitBreaker, RCMarket.sol:_processRentCollection'}], 'IssueNumber': 63, 'OutputList': 12}",243.228338003159,"### **[H-03] anyone can call function sponsor**

**Report Description**:
The `sponsor` function should only be called by the factory, but it lacks any access control checks. This allows anyone to call it with an arbitrary `_sponsorAddress` and transfer tokens from them if the allowance is greater than 0. This oversight could lead to unauthorized token transfers and potential exploitation if malicious actors exploit this vulnerability.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper access control in the `sponsor` function. The issue is entirely missed, and no corresponding response is provided to address the vulnerability.

---

### **[M-07] maxSumOfPrices check is broken**

**Report Description**:
The `rentAllCards` function requires the sender to specify a `_maxSumOfPrices` parameter, which is intended to limit the sum of the bids placed. However, the function implementation does not enforce this constraint, allowing the total number of bids placed to exceed the specified `_maxSumOfPrices`. This could lead to users not having sufficient funds deposited, resulting in foreclosure or impacts on other bids/markets.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of the broken `_maxSumOfPrices` check in the `rentAllCards` function. The issue is entirely missed, and no corresponding response is provided to address the vulnerability.

---

### **[M-13] Wrong calculation on _collectRentAction**

**Report Description**:
The `_collectRentAction` method contains an incorrect calculation in case 6. It calculates `_refundTime` as `block.timestamp - marketLockingTime` instead of `_timeUserForeclosed - marketLockingTime`. This incorrect calculation could lead to inaccurate refund amounts, potentially causing users to lose funds or receive incorrect refunds.

**Match in Response List**:
Matches with the issue titled **""Incorrect Refund Logic in Rent Collection""**.

**Validation**:
**Partially Correct**. The response identifies the issue with incorrect refund logic in the `_collectRentAction` function. However, it does not specifically address the exact calculation error described in the issue report. The response is somewhat generic and misses the specific detail of the incorrect time calculation.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-13] Wrong calculation on _collectRentAction**

**Missed Issues from Issue Report**:
- **[H-03] anyone can call function sponsor**
- **[M-07] maxSumOfPrices check is broken**

---

The response list fails to address two critical issues ([H-03] and [M-07]) and provides only a partially correct response for [M-13]. This indicates significant gaps in the coverage and accuracy of the responses provided.","```
None.
```",0.0
RCFactory.sol,"// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";

/// @title Reality Cards Factory
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {
    /*╔═════════════════════════════════╗
      ║           VARIABLES             ║
      ╚═════════════════════════════════╝*/

    //≡≡≡≡≡≡≡ CONTRACT VARIABLES ≡≡≡≡≡≡≡//
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRealitio public realitio;

    ///// CONTRACT ADDRESSES /////
    /// @dev reference contract
    address public referenceContractAddress;
    /// @dev increments each time a new reference contract is added
    uint256 public referenceContractVersion;
    /// @dev market addresses, mode // address
    /// @dev these are not used for anything, just an easy way to get markets
    mapping(uint256 => address[]) public marketAddresses;
    mapping(address => bool) public mappingOfMarkets;

    ///// GOVERNANCE VARIABLES- OWNER /////
    /// @dev artist / winner / market creator / affiliate / card affiliate
    uint256[5] public potDistribution;
    /// @dev minimum tokens that must be sent when creating market which forms iniital pot
    uint256 public sponsorshipRequired;
    /// @dev adjust required price increase (in %)
    uint256 public override minimumPriceIncreasePercent;
    /// @dev market opening time must be at least this many seconds in the future
    uint32 public advancedWarning;
    /// @dev market closing time must be no more than this many seconds in the future
    uint32 public maximumDuration;
    /// @dev list of governors
    mapping(address => bool) public governors;
    /// @dev if false, anyone can create markets
    bool public marketCreationGovernorsOnly = true;
    /// @dev if false, anyone can be an affiliate
    bool public approvedAffilliatesOnly = true;
    /// @dev if false, anyone can be an artist
    bool public approvedArtistsOnly = true;
    /// @dev if true, cards are burnt at the end of events for hidden markets to enforce scarcity
    bool public override trapIfUnapproved = true;
    /// @dev high level owner who can change the factory address
    address public uberOwner;
    /// @dev the maximum number of rent collections to perform in a single transaction
    uint256 public override maxRentIterations;
    /// @dev the address of the arbitrator
    address public arbitrator;
    /// @dev the time allowed to dispute the oracle answer
    uint32 public timeout;

    ///// GOVERNANCE VARIABLES- GOVERNORS /////
    /// @dev unapproved markets hidden from the interface
    mapping(address => bool) public override isMarketApproved;
    /// @dev allows artist to receive cut of total rent
    mapping(address => bool) public isArtistApproved;
    /// @dev allows affiliate to receive cut of total rent
    mapping(address => bool) public isAffiliateApproved;
    /// @dev allows card affiliate to receive cut of total rent
    mapping(address => bool) public isCardAffiliateApproved;
    /// @dev a limit to the number of NFTs to mint per market
    uint256 public nftMintingLimit;

    ///// OTHER /////
    /// @dev counts the total NFTs minted across all events
    /// @dev ... so the appropriate token id is used when upgrading to mainnet
    uint256 public totalNftMintCount;

    /*╔═════════════════════════════════╗
      ║            EVENTS               ║
      ╚═════════════════════════════════╝*/

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        uint32 mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool hidden);
    event LogAdvancedWarning(uint256 _newAdvancedWarning);
    event LogMaximumDuration(uint256 _newMaximumDuration);

    /*╔═════════════════════════════════╗
      ║          CONSTRUCTOR            ║
      ╚═════════════════════════════════╝*/

    /// @dev Treasury must be deployed before Factory
    constructor(
        IRCTreasury _treasuryAddress,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasuryAddress) != address(0));
        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        // at initiation, uberOwner and owner will be the same
        uberOwner = msgSender();

        // initialise contract variable
        treasury = _treasuryAddress;

        // initialise adjustable parameters
        // artist // winner // creator // affiliate // card affiliates
        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate
        setminimumPriceIncreasePercent(10); // 10%
        setNFTMintingLimit(60); // current gas limit (12.5m) allows for 60 NFTs to be minted
        setMaxRentIterations(35); // limit appears to be 41, set safe at 35 for now.
        // oracle
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); // 24 hours
    }

    /*╔═════════════════════════════════╗
      ║          VIEW FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @notice Fetch the address of the most recently created market
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return the address of the most recent market in the given mode
    function getMostRecentMarket(uint256 _mode)
        external
        view
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    /// @notice Fetch all the market addresses for a given mode
    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode
    /// @return an array of all markets in a given mode
    function getAllMarkets(uint256 _mode)
        external
        view
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    /// @notice Returns the currently set pot distribution
    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    /*╔═════════════════════════════════╗
      ║           MODIFIERS             ║
      ╚═════════════════════════════════╝*/

    /// @dev include the owner as a governor
    modifier onlyGovernors() {
        require(
            governors[msgSender()] || owner() == msgSender(),
            ""Not approved""
        );
        _;
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - OWNER (SETUP)  ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier

    /// @notice where the NFTs live
    /// @dev nftMintCount will probably need to be reset to zero if new nft contract, but
    /// @dev ... keeping flexible in case returning to previous contract
    /// @param _newAddress the address to set
    /// @param _newNftMintCount the number of NFTs this contract has minted, in order to keep them unique
    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)
        external
        onlyOwner
    {
        require(address(_newAddress) != address(0));
        nfthub = _newAddress;
        totalNftMintCount = _newNftMintCount;
    }

    /// @notice set the address of the orderbook contract
    /// @param _newAddress the address to set
    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {
        require(address(_newAddress) != address(0));
        orderbook = _newAddress;
    }

    /*╔═════════════════════════════════╗
      ║       GOVERNANCE - OWNER        ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyOwner modifier
    // Min price increase & pot distribution emitted by Market.
    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.

    /*┌────────────────────────────────────┐
      │ CALLED WITHIN CONSTRUTOR - PUBLIC  │
      └────────────────────────────────────┘*/

    /// @notice update stakeholder payouts
    /// @dev in basis points (so 1000 = 100%)
    /// @param _artistCut The artist that designed the card
    /// @param _winnerCut Extra cut for the longest owner
    /// @param _creatorCut The creator of the market
    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts
    /// @param _cardAffiliateCut An affiliate cur for specific cards
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                1000,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    /// @notice how much above the current price a user must bid, in %
    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%
    function setminimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    /// @notice A limit to the number of NFTs to mint per market
    /// @dev to avoid gas limits
    /// @param _mintLimit the limit to set
    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {
        nftMintingLimit = _mintLimit;
    }

    /// @notice A limit to the number of rent collections per transaction
    /// @dev to avoid gas limits
    /// @param _rentLimit the limit to set
    function setMaxRentIterations(uint256 _rentLimit)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
    }

    /// @notice set the address of the reality.eth contracts
    /// @param _newAddress the address to set
    function setRealitioAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    /// @notice address of the arbitrator, in case of continued disputes on reality.eth
    /// @param _newAddress the address to set
    function setArbitrator(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    /// @notice set how long reality.eth waits for disputes before finalising
    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs
    function setTimeout(uint32 _newTimeout) public onlyOwner {
        timeout = _newTimeout;
    }

    /*┌──────────────────────────────────────────┐
      │ NOT CALLED WITHIN CONSTRUTOR - EXTERNAL  │
      └──────────────────────────────────────────┘*/

    /// @notice whether or not only governors can create the market
    function changeMarketCreationGovernorsOnly() external onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    /// @notice whether or not anyone can be an artist
    function changeApprovedArtistsOnly() external onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    /// @notice whether or not anyone can be an affiliate
    function changeApprovedAffilliatesOnly() external onlyOwner {
        approvedAffilliatesOnly = !approvedAffilliatesOnly;
    }

    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot
    /// @param _amount the sponsorship required in wei
    function setSponsorshipRequired(uint256 _amount) external onlyOwner {
        sponsorshipRequired = _amount;
    }

    /// @notice if true, Cards in unapproved markets can't be upgraded
    function changeTrapCardsIfUnapproved() external onlyOwner {
        trapIfUnapproved = !trapIfUnapproved;
    }

    /// @notice market opening time must be at least this many seconds in the future
    /// @param _newAdvancedWarning the warning time to set in seconds
    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {
        advancedWarning = _newAdvancedWarning;
        emit LogAdvancedWarning(_newAdvancedWarning);
    }

    /// @notice market closing time must be no more than this many seconds in the future
    /// @param _newMaximumDuration the duration limit to set in seconds
    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {
        maximumDuration = _newMaximumDuration;
        emit LogMaximumDuration(_newMaximumDuration);
    }

    /// @notice to fetch the owner of the contract
    /// @dev used to specifiy the Ownable contract instead of the interface
    function owner()
        public
        view
        override(IRCFactory, Ownable)
        returns (address)
    {
        return Ownable.owner();
    }

    /// @notice check if an address is a governor
    /// @param _user the address to query
    /// @return boolean return if true or false
    function isGovernor(address _user) external view override returns (bool) {
        return governors[_user];
    }

    // EDIT GOVERNORS

    /// @notice add or remove an address from market creator whitelist
    /// @param _governor the address to change approval for
    /// @dev recommended to check isGovernor() afterwards to confirm the desired outcome
    function changeGovernorApproval(address _governor) external onlyOwner {
        require(_governor != address(0));
        governors[_governor] = !governors[_governor];
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - GOVERNORS      ║
      ╚═════════════════════════════════╝*/
    /// @dev all functions should have onlyGovernors modifier

    /// @notice markets are default hidden from the interface, this reveals them
    /// @param _market the market address to change approval for
    function changeMarketApproval(address _market) external onlyGovernors {
        require(_market != address(0));
        // check it's an RC contract
        IRCMarket _marketToApprove = IRCMarket(_market);
        assert(_marketToApprove.isMarket());
        isMarketApproved[_market] = !isMarketApproved[_market];
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    /// @notice artistAddress, passed in createMarket, must be approved
    /// @param _artist the artist address to change approval for
    function changeArtistApproval(address _artist) external onlyGovernors {
        require(_artist != address(0));
        isArtistApproved[_artist] = !isArtistApproved[_artist];
    }

    /// @notice affiliateAddress, passed in createMarket, must be approved
    /// @param _affiliate the affiliate address to change approval for
    function changeAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];
    }

    /// @notice cardAffiliateAddress, passed in createMarket, must be approved
    /// @param _affiliate the card affiliate address to change approval for
    function changeCardAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[
            _affiliate
        ];
    }

    /*╔═════════════════════════════════╗
      ║     GOVERNANCE - UBER OWNER     ║
      ╠═════════════════════════════════╣
      ║  ******** DANGER ZONE ********  ║
      ╚═════════════════════════════════╝*/
    /// @dev uber owner required for upgrades
    /// @dev this is seperated so owner so can be set to multisig, or burn address to relinquish upgrade ability
    /// @dev ... while maintaining governance over other governanace functions

    /// @notice change the reference contract for the contract logic
    function setReferenceContractAddress(address _newAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newAddress != address(0));
        // check it's an RC contract
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        assert(newContractVariable.isMarket());
        // set
        referenceContractAddress = _newAddress;
        // increment version
        referenceContractVersion += 1;
    }

    /// @notice to change or renounce ownership of the uberOwner role
    function changeUberOwner(address _newUberOwner) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0));
        uberOwner = _newUberOwner;
    }

    /*╔═════════════════════════════════╗
      ║         MARKET CREATION         ║
      ╚═════════════════════════════════╝*/

    /// @notice Creates a new market with the given parameters
    /// @param _mode 0 = normal, 1 = winner takes all, 2 = hot potato
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _tokenURIs location of NFT metadata
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _realitioQuestion the details of the event to send to the oracle
    /// @param _sponsorship amount of sponsorship to create the market with
    /// @return The address of the new market
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address) {
        address _creator = msgSender();

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                isArtistApproved[_artistAddress] ||
                    _artistAddress == address(0),
                ""Artist not approved""
            );
        }
        // affiliate
        if (approvedAffilliatesOnly) {
            require(
                isAffiliateApproved[_affiliateAddress] ||
                    _affiliateAddress == address(0),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||
                        _cardAffiliateAddresses[i] == address(0),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(governors[_creator] || owner() == _creator, ""Not approved"");
        }

        // check timestamps
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        // check market opening time
        if (advancedWarning != 0) {
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        // check market locking time
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        // check oracle resolution time (no more than 1 week after market locking to get result)
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );

        // check the number of NFTs to mint is within limits
        require(
            _tokenURIs.length <= nftMintingLimit,
            ""Too many tokens to mint""
        );

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            _mode,
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            totalNftMintCount
        );

        // tell Treasury, Orderbook, and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress);
        nfthub.addMarket(_newAddress);
        orderbook.addMarket(
            _newAddress,
            _tokenURIs.length,
            minimumPriceIncreasePercent
        );

        // update internals
        marketAddresses[_mode].push(_newAddress);
        mappingOfMarkets[_newAddress] = true;

        // initialize the market
        IRCMarket(_newAddress).initialize({
            _mode: _mode,
            _timestamps: _timestamps,
            _numberOfTokens: _tokenURIs.length,
            _totalNftMintCount: totalNftMintCount,
            _artistAddress: _artistAddress,
            _affiliateAddress: _affiliateAddress,
            _cardAffiliateAddresses: _cardAffiliateAddresses,
            _marketCreatorAddress: _creator,
            _realitioQuestion: _realitioQuestion
        });

        // create the NFTs
        require(address(nfthub) != address(0), ""Nfthub not set"");
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            uint256 _tokenId = i + totalNftMintCount;
            require(
                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
                ""Nft Minting Failed""
            );
        }

        // increment totalNftMintCount
        totalNftMintCount = totalNftMintCount + _tokenURIs.length;

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    /// @dev called by the market upon initialise
    /// @dev not passed to initialise to avoid stack too deep error
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }
    /*
         ▲  
        ▲ ▲ 
              */
}",5732,635,"[M-05] RCFactory.createMarket() does not enforce _timestamps and _timestamps being larger than _timestamps, even though proper functioning requires them to be so
`RCFactory.createMarket()` does not enforce `_timestamps[1]` and `_timestamps[2]` being larger than _timestamps[0], even though proper functioning requires them to be so.
IRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. (1)
The comments explicitly state that _incrementState() should be called ""thrice"" (2)
However, it is possible to create a market where these events do not occur sequentially.
You can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.
This is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0] (3)
This is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. (4)
Thus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.
When calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0] (5)",1,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/proxy/Clones.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";
import ""./interfaces/IRealitio.sol"";




contract RCFactory is Ownable, NativeMetaTransaction, IRCFactory {
    

    
    IRCTreasury public override treasury;
    IRCNftHubL2 public override nfthub;
    IRCOrderbook public override orderbook;
    IRealitio public realitio;

    
    
    address public referenceContractAddress;
    
    uint256 public referenceContractVersion;
    
    
    mapping(uint256 => address[]) public marketAddresses;
    mapping(address => bool) public mappingOfMarkets;

    
    
    uint256[5] public potDistribution;
    
    uint256 public sponsorshipRequired;
    
    uint256 public override minimumPriceIncreasePercent;
    
    uint32 public advancedWarning;
    
    uint32 public maximumDuration;
    
    mapping(address => bool) public governors;
    
    bool public marketCreationGovernorsOnly = true;
    
    bool public approvedAffilliatesOnly = true;
    
    bool public approvedArtistsOnly = true;
    
    bool public override trapIfUnapproved = true;
    
    address public uberOwner;
    
    uint256 public override maxRentIterations;
    
    address public arbitrator;
    
    uint32 public timeout;

    
    
    mapping(address => bool) public override isMarketApproved;
    
    mapping(address => bool) public isArtistApproved;
    
    mapping(address => bool) public isAffiliateApproved;
    
    mapping(address => bool) public isCardAffiliateApproved;
    
    uint256 public nftMintingLimit;

    
    
    
    uint256 public totalNftMintCount;

    

    event LogMarketCreated1(
        address contractAddress,
        address treasuryAddress,
        address nftHubAddress,
        uint256 referenceContractVersion
    );
    event LogMarketCreated2(
        address contractAddress,
        uint32 mode,
        string[] tokenURIs,
        string ipfsHash,
        uint32[] timestamps,
        uint256 totalNftMintCount
    );
    event LogMarketApproved(address market, bool hidden);
    event LogAdvancedWarning(uint256 _newAdvancedWarning);
    event LogMaximumDuration(uint256 _newMaximumDuration);

    

    
    constructor(
        IRCTreasury _treasuryAddress,
        address _realitioAddress,
        address _arbitratorAddress
    ) {
        require(address(_treasuryAddress) != address(0));
        
        _initializeEIP712(""RealityCardsFactory"", ""1"");

        
        uberOwner = msgSender();

        
        treasury = _treasuryAddress;

        
        
        setPotDistribution(20, 0, 0, 20, 100); 
        setminimumPriceIncreasePercent(10); 
        setNFTMintingLimit(60); 
        setMaxRentIterations(35); 
        
        setArbitrator(_arbitratorAddress);
        setRealitioAddress(_realitioAddress);
        setTimeout(86400); 
    }

    

    
    
    
    function getMostRecentMarket(uint256 _mode)
        external
        view
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }

    
    
    
    function getAllMarkets(uint256 _mode)
        external
        view
        returns (address[] memory)
    {
        return marketAddresses[_mode];
    }

    
    
    function getPotDistribution()
        external
        view
        override
        returns (uint256[5] memory)
    {
        return potDistribution;
    }

    

    
    modifier onlyGovernors() {
        require(
            governors[msgSender()] || owner() == msgSender(),
            ""Not approved""
        );
        _;
    }

    
    

    
    
    
    
    
    function setNftHubAddress(IRCNftHubL2 _newAddress, uint256 _newNftMintCount)
        external
        onlyOwner
    {
        require(address(_newAddress) != address(0));
        nfthub = _newAddress;
        totalNftMintCount = _newNftMintCount;
    }

    
    
    function setOrderbookAddress(IRCOrderbook _newAddress) external onlyOwner {
        require(address(_newAddress) != address(0));
        orderbook = _newAddress;
    }

    
    
    
    

    

    
    
    
    
    
    
    
    function setPotDistribution(
        uint256 _artistCut,
        uint256 _winnerCut,
        uint256 _creatorCut,
        uint256 _affiliateCut,
        uint256 _cardAffiliateCut
    ) public onlyOwner {
        require(
            _artistCut +
                _winnerCut +
                _creatorCut +
                _affiliateCut +
                _cardAffiliateCut <=
                1000,
            ""Cuts too big""
        );
        potDistribution[0] = _artistCut;
        potDistribution[1] = _winnerCut;
        potDistribution[2] = _creatorCut;
        potDistribution[3] = _affiliateCut;
        potDistribution[4] = _cardAffiliateCut;
    }

    
    
    function setminimumPriceIncreasePercent(uint256 _percentIncrease)
        public
        override
        onlyOwner
    {
        minimumPriceIncreasePercent = _percentIncrease;
    }

    
    
    
    function setNFTMintingLimit(uint256 _mintLimit) public override onlyOwner {
        nftMintingLimit = _mintLimit;
    }

    
    
    
    function setMaxRentIterations(uint256 _rentLimit)
        public
        override
        onlyOwner
    {
        maxRentIterations = _rentLimit;
    }

    
    
    function setRealitioAddress(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        realitio = IRealitio(_newAddress);
    }

    
    
    function setArbitrator(address _newAddress) public onlyOwner {
        require(_newAddress != address(0), ""Must set an address"");
        arbitrator = _newAddress;
    }

    
    
    function setTimeout(uint32 _newTimeout) public onlyOwner {
        timeout = _newTimeout;
    }

    

    
    function changeMarketCreationGovernorsOnly() external onlyOwner {
        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;
    }

    
    function changeApprovedArtistsOnly() external onlyOwner {
        approvedArtistsOnly = !approvedArtistsOnly;
    }

    
    function changeApprovedAffilliatesOnly() external onlyOwner {
        approvedAffilliatesOnly = !approvedAffilliatesOnly;
    }

    
    
    function setSponsorshipRequired(uint256 _amount) external onlyOwner {
        sponsorshipRequired = _amount;
    }

    
    function changeTrapCardsIfUnapproved() external onlyOwner {
        trapIfUnapproved = !trapIfUnapproved;
    }

    
    
    function setAdvancedWarning(uint32 _newAdvancedWarning) external onlyOwner {
        advancedWarning = _newAdvancedWarning;
        emit LogAdvancedWarning(_newAdvancedWarning);
    }

    
    
    function setMaximumDuration(uint32 _newMaximumDuration) external onlyOwner {
        maximumDuration = _newMaximumDuration;
        emit LogMaximumDuration(_newMaximumDuration);
    }

    
    
    function owner()
        public
        view
        override(IRCFactory, Ownable)
        returns (address)
    {
        return Ownable.owner();
    }

    
    
    
    function isGovernor(address _user) external view override returns (bool) {
        return governors[_user];
    }

    

    
    
    
    function changeGovernorApproval(address _governor) external onlyOwner {
        require(_governor != address(0));
        governors[_governor] = !governors[_governor];
    }

    
    

    
    
    function changeMarketApproval(address _market) external onlyGovernors {
        require(_market != address(0));
        
        IRCMarket _marketToApprove = IRCMarket(_market);
        assert(_marketToApprove.isMarket());
        isMarketApproved[_market] = !isMarketApproved[_market];
        emit LogMarketApproved(_market, isMarketApproved[_market]);
    }

    
    
    function changeArtistApproval(address _artist) external onlyGovernors {
        require(_artist != address(0));
        isArtistApproved[_artist] = !isArtistApproved[_artist];
    }

    
    
    function changeAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isAffiliateApproved[_affiliate] = !isAffiliateApproved[_affiliate];
    }

    
    
    function changeCardAffiliateApproval(address _affiliate)
        external
        onlyGovernors
    {
        require(_affiliate != address(0));
        isCardAffiliateApproved[_affiliate] = !isCardAffiliateApproved[
            _affiliate
        ];
    }

    
    
    
    

    
    function setReferenceContractAddress(address _newAddress) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newAddress != address(0));
        
        IRCMarket newContractVariable = IRCMarket(_newAddress);
        assert(newContractVariable.isMarket());
        
        referenceContractAddress = _newAddress;
        
        referenceContractVersion += 1;
    }

    
    function changeUberOwner(address _newUberOwner) external {
        require(msgSender() == uberOwner, ""Extremely Verboten"");
        require(_newUberOwner != address(0));
        uberOwner = _newUberOwner;
    }

    

    
    
    
    
    
    
    
    
    
    
    function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string calldata _realitioQuestion,
        uint256 _sponsorship
    ) external returns (address) {
        address _creator = msgSender();

        
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        
        
        if (approvedArtistsOnly) {
            require(
                isArtistApproved[_artistAddress] ||
                    _artistAddress == address(0),
                ""Artist not approved""
            );
        }
        
        if (approvedAffilliatesOnly) {
            require(
                isAffiliateApproved[_affiliateAddress] ||
                    _affiliateAddress == address(0),
                ""Affiliate not approved""
            );
            
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    isCardAffiliateApproved[_cardAffiliateAddresses[i]] ||
                        _cardAffiliateAddresses[i] == address(0),
                    ""Card affiliate not approved""
                );
            }
        }

        
        if (marketCreationGovernorsOnly) {
            require(governors[_creator] || owner() == _creator, ""Not approved"");
        }

        
        require(_timestamps.length == 3, ""Incorrect number of array elements"");
        
        if (advancedWarning != 0) {
            require(
                _timestamps[0] >= block.timestamp,
                ""Market opening time not set""
            );
            require(
                _timestamps[0] - advancedWarning > block.timestamp,
                ""Market opens too soon""
            );
        }
        
        if (maximumDuration != 0) {
            require(
                _timestamps[1] < block.timestamp + maximumDuration,
                ""Market locks too late""
            );
        }
        
        require(
            _timestamps[1] + (1 weeks) > _timestamps[2] &&
                _timestamps[1] <= _timestamps[2],
            ""Oracle resolution time error""
        );

        
        require(
            _tokenURIs.length <= nftMintingLimit,
            ""Too many tokens to mint""
        );

        
        
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            _mode,
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            totalNftMintCount
        );

        
        
        treasury.addMarket(_newAddress);
        nfthub.addMarket(_newAddress);
        orderbook.addMarket(
            _newAddress,
            _tokenURIs.length,
            minimumPriceIncreasePercent
        );

        
        marketAddresses[_mode].push(_newAddress);
        mappingOfMarkets[_newAddress] = true;

        
        IRCMarket(_newAddress).initialize({
            _mode: _mode,
            _timestamps: _timestamps,
            _numberOfTokens: _tokenURIs.length,
            _totalNftMintCount: totalNftMintCount,
            _artistAddress: _artistAddress,
            _affiliateAddress: _affiliateAddress,
            _cardAffiliateAddresses: _cardAffiliateAddresses,
            _marketCreatorAddress: _creator,
            _realitioQuestion: _realitioQuestion
        });

        
        require(address(nfthub) != address(0), ""Nfthub not set"");
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            uint256 _tokenId = i + totalNftMintCount;
            require(
                nfthub.mint(_newAddress, _tokenId, _tokenURIs[i]),
                ""Nft Minting Failed""
            );
        }

        
        totalNftMintCount = totalNftMintCount + _tokenURIs.length;

        
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }

    
    
    function getOracleSettings()
        external
        view
        override
        returns (
            IRealitio,
            address,
            uint32
        )
    {
        return (realitio, arbitrator, timeout);
    }
    
}",3005,0,1,"{'task_list': [{'Area': 'Access Control and Authorization', 'Tasks': ['Verify that only the `uberOwner` can call `setReferenceContractAddress` and `changeUberOwner`.', 'Confirm that the `onlyGovernors` modifier correctly restricts access to `changeMarketApproval`, `changeArtistApproval`, `changeAffiliateApproval`, and `changeCardAffiliateApproval` functions.', 'Ensure that the `owner()` function, inherited from `Ownable`, is correctly implemented and returns the expected owner address.', 'Analyze the impact of `marketCreationGovernorsOnly`, `approvedArtistsOnly`, and `approvedAffilliatesOnly` flags on market creation, and confirm they function as intended.', 'Review the logic within the `createMarket` function to ensure that access control checks for artist, affiliate, and card affiliate approvals are correctly implemented and cannot be bypassed.', 'Investigate the use of `NativeMetaTransaction` and confirm that `_msgSender()` is correctly resolving the actual sender address, preventing unauthorized access.']}, {'Area': 'Market Creation Logic and Cloning', 'Tasks': ['Carefully examine the `createMarket` function to ensure that all parameters are validated correctly, especially `_timestamps`, `_tokenURIs`, `_artistAddress`, `_affiliateAddress`, and `_cardAffiliateAddresses`.', 'Analyze the usage of `Clones.clone` and confirm that it correctly creates a new `RCMarket` instance without unintended side effects or storage collisions.', 'Verify that the `initialize` function of the cloned `RCMarket` contract is called with the correct parameters and that the initialization logic is secure.', 'Review the integration with `treasury`, `nfthub`, and `orderbook` during market creation to ensure that the new market is correctly registered and configured in each system.', ""Check the `nftMintingLimit` and ensure that the number of NFTs minted in `createMarket` does not exceed this limit. Also, assess the impact of a very large number of NFTs minted over time on the contract's state."", 'Analyze the timestamp constraints in the createMarket function. Evaluate if these constraints are reasonable, and if unexpected timestamp values could brick the market creation.', 'Investigate potential vulnerabilities in the initialization of the cloned market. Ensure that the initialize function in IRCMarket is only callable once and cannot be re-initialized by an attacker.']}, {'Area': 'External Interactions and Dependencies', 'Tasks': ['Analyze the interactions with `IRCTreasury`, `IRCNftHubL2`, `IRCOrderbook`, and `IRealitio` to identify potential vulnerabilities, such as reentrancy or unexpected behavior in external calls.', 'Confirm that the `checkSponsorship` function in `IRCTreasury` is implemented securely and prevents malicious users from circumventing sponsorship requirements.', 'Ensure that the `mint` function in `IRCNftHubL2` is secure and prevents unauthorized minting of NFTs.', 'Review the `getOracleSettings` function to ensure that the returned `realitio`, `arbitrator`, and `timeout` values are consistent and reliable.', 'Assess the risks associated with using the `Realitio` oracle and verify that the contract is resilient to oracle manipulation or incorrect data feeds.', 'Analyze how `arbitrator` is used in the IRCMarket contracts, looking for potential vulnerabilities related to dispute resolution.']}, {'Area': 'State Management and Arithmetic', 'Tasks': ['Examine the `potDistribution` array and ensure that the sum of its elements never exceeds 1000. Verify that the `setPotDistribution` function enforces this constraint correctly.', 'Analyze the `totalNftMintCount` variable and ensure that it is updated correctly after each market creation. Also, consider the potential for integer overflows or other arithmetic errors.', 'Review the `minimumPriceIncreasePercent` variable and confirm that it is used correctly in the `RCMarket` contract to prevent front-running or price manipulation.', 'Assess the impact of changing key parameters like `sponsorshipRequired`, `advancedWarning`, and `maximumDuration` on existing markets and future market creation.', 'Evaluate if the current implementation of referencing markets via `marketAddresses[_mode].push(_newAddress)` is safe against out-of-bounds access in `getMostRecentMarket`.']}, {'Area': 'Gas Optimization', 'Tasks': ['Identify potential areas for gas optimization, such as reducing storage reads/writes, using more efficient data structures, or optimizing loop iterations.', 'Evaluate the gas costs associated with the `createMarket` function and identify potential areas for reducing deployment costs.', 'Assess the gas efficiency of the approval mechanisms and consider alternative implementations that may reduce gas consumption.', 'Analyze the gas costs of meta-transactions and ensure that they are implemented efficiently.', 'Verify that unnecessary data is not being stored on-chain, contributing to unnecessary cost.']}, {'Area': 'Error Handling and Assertions', 'Tasks': ['Analyze the use of `require` statements throughout the contract to ensure that they provide informative error messages and prevent unexpected behavior.', 'Examine the use of `assert` statements and determine if they are used appropriately for internal consistency checks. Assess the potential impact of `assert` failures on contract functionality.', 'Ensure that the contract handles unexpected errors or exceptions gracefully and prevents denial-of-service attacks.', 'Review the events emitted by the contract and ensure that they provide sufficient information for off-chain monitoring and analysis.']}, {'Area': 'Upgradeability and Future Proofing', 'Tasks': [""Assess the upgradeability of the contract and identify potential challenges or limitations in upgrading the contract's logic or data structures."", 'Review the `referenceContractVersion` variable and ensure that it is updated correctly when the `referenceContractAddress` is changed. Assess the potential impact of version mismatches on market functionality.', ""Evaluate the contract's design for future extensibility and consider potential modifications that may be required to support new features or functionality."", 'Determine if the current design is resilient to potential changes in external dependencies or standards.']}, {'Area': 'Uninitialized Storage Variables', 'Tasks': ['Carefully analyze all state variables to ensure that they are properly initialized in the constructor or through other initialization functions. Pay close attention to complex data structures like mappings and arrays.']}, {'Area': 'Denial of Service', 'Tasks': ['Analyze the `changeMarketApproval`, `changeArtistApproval`, `changeAffiliateApproval`, and `changeCardAffiliateApproval` functions. Verify if adding/removing a large number of approvals can cause a denial of service due to gas limits.']}, {'Area': 'Logic Errors', 'Tasks': ['Verify the logic surrounding sponsorship checks in `createMarket` to ensure it correctly validates the _sponsorship amount against `sponsorshipRequired` and interacts with `treasury.checkSponsorship()` appropriately.', 'Check that `_timestamps[1] + (1 weeks) > _timestamps[2] && _timestamps[1] <= _timestamps[2]` logic in `createMarket` is implemented correctly, covers all possible cases and valid ranges to avoid logical errors that could prevent proper function of the market.']}]}","{'ReviewingTheCode': 'The contract `RCFactory` serves as a central point for creating and managing Reality Cards market contracts (`RCMarket`). It utilizes the Clones pattern for efficient deployment, manages various settings (fees, timing, approvals), tracks deployed markets, and interacts with several external system components like a Treasury, NFT Hub, Orderbook, and Realitio oracle. It implements multiple layers of access control (`Ownable`, `Governors`, `uberOwner`) and supports meta-transactions via `NativeMetaTransaction`.', 'IdentifyingKeyComponents': {'ContractName': 'RCFactory', 'Purpose': 'To deploy and manage instances of RCMarket contracts, configure global settings, handle approvals (markets, artists, affiliates), and serve as a registry for created markets.', 'InheritanceAndImports': {'InheritsFrom': ['Ownable', 'NativeMetaTransaction', 'IRCFactory'], 'Imports': ['@openzeppelin/contracts/access/Ownable.sol', '@openzeppelin/contracts/proxy/Clones.sol', 'hardhat/console.sol', './interfaces/IRCFactory.sol', './interfaces/IRCTreasury.sol', './interfaces/IRCMarket.sol', './interfaces/IRCNftHubL2.sol', './interfaces/IRCOrderbook.sol', './lib/NativeMetaTransaction.sol', './interfaces/IRealitio.sol']}, 'StateVariables': [{'Name': 'treasury', 'Type': 'IRCTreasury', 'Purpose': ""Reference to the system's Treasury contract.""}, {'Name': 'nfthub', 'Type': 'IRCNftHubL2', 'Purpose': ""Reference to the system's NFT Hub contract (L2).""}, {'Name': 'orderbook', 'Type': 'IRCOrderbook', 'Purpose': ""Reference to the system's Orderbook contract.""}, {'Name': 'realitio', 'Type': 'IRealitio', 'Purpose': 'Reference to the Realitio oracle contract.'}, {'Name': 'referenceContractAddress', 'Type': 'address', 'Purpose': 'The address of the RCMarket implementation contract used as a template for cloning.'}, {'Name': 'referenceContractVersion', 'Type': 'uint256', 'Purpose': 'A version counter, incremented when the reference contract address changes.'}, {'Name': 'marketAddresses', 'Type': 'mapping(uint256 => address[])', 'Purpose': 'Stores lists of created market addresses, potentially categorized by mode.'}, {'Name': 'mappingOfMarkets', 'Type': 'mapping(address => bool)', 'Purpose': 'Tracks whether an address corresponds to a market created by this factory.'}, {'Name': 'potDistribution', 'Type': 'uint256[5]', 'Purpose': 'Defines the percentage distribution of market funds (artist, winner, creator, affiliate, card affiliate).'}, {'Name': 'sponsorshipRequired', 'Type': 'uint256', 'Purpose': 'Minimum sponsorship amount required to create a new market.'}, {'Name': 'minimumPriceIncreasePercent', 'Type': 'uint256', 'Purpose': 'Minimum percentage increase required for placing a new higher bid in markets.'}, {'Name': 'advancedWarning', 'Type': 'uint32', 'Purpose': 'Minimum time required between market creation and market opening.'}, {'Name': 'maximumDuration', 'Type': 'uint32', 'Purpose': 'Maximum allowed duration from market creation until market lock time.'}, {'Name': 'governors', 'Type': 'mapping(address => bool)', 'Purpose': 'Stores addresses authorized as governors with specific administrative privileges.'}, {'Name': 'marketCreationGovernorsOnly', 'Type': 'bool', 'Purpose': 'Flag indicating if only governors/owner can create markets.'}, {'Name': 'approvedAffilliatesOnly', 'Type': 'bool', 'Purpose': 'Flag indicating if only approved affiliates can be used in market creation.'}, {'Name': 'approvedArtistsOnly', 'Type': 'bool', 'Purpose': 'Flag indicating if only approved artists can be used in market creation.'}, {'Name': 'trapIfUnapproved', 'Type': 'bool', 'Purpose': 'Flag influencing behavior related to unapproved participants (likely within market logic).'}, {'Name': 'uberOwner', 'Type': 'address', 'Purpose': 'A special owner address with higher privileges than the regular owner, specifically for changing the reference contract and the uberOwner itself.'}, {'Name': 'maxRentIterations', 'Type': 'uint256', 'Purpose': 'A limit related to rent collection iterations, likely passed to market contracts.'}, {'Name': 'arbitrator', 'Type': 'address', 'Purpose': 'The address of the arbitrator contract used in conjunction with Realitio.'}, {'Name': 'timeout', 'Type': 'uint32', 'Purpose': 'The timeout period used for Realitio oracle resolution.'}, {'Name': 'isMarketApproved', 'Type': 'mapping(address => bool)', 'Purpose': 'Stores approval status for individual market contracts.'}, {'Name': 'isArtistApproved', 'Type': 'mapping(address => bool)', 'Purpose': 'Stores approval status for artist addresses.'}, {'Name': 'isAffiliateApproved', 'Type': 'mapping(address => bool)', 'Purpose': 'Stores approval status for general affiliate addresses.'}, {'Name': 'isCardAffiliateApproved', 'Type': 'mapping(address => bool)', 'Purpose': 'Stores approval status for card-specific affiliate addresses.'}, {'Name': 'nftMintingLimit', 'Type': 'uint256', 'Purpose': 'Maximum number of NFTs (tokens) allowed per market creation.'}, {'Name': 'totalNftMintCount', 'Type': 'uint256', 'Purpose': 'A global counter used to assign unique token IDs across all markets minted via this factory.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract, setting Treasury, Realitio, Arbitrator, EIP712 domain, uberOwner, and default configurations.', 'Parameters': ['IRCTreasury _treasuryAddress', 'address _realitioAddress', 'address _arbitratorAddress'], 'Returns': []}, {'Name': 'getMostRecentMarket', 'Visibility': 'external', 'Purpose': 'Returns the address of the most recently created market for a given mode.', 'Parameters': ['uint256 _mode'], 'Returns': ['address']}, {'Name': 'getAllMarkets', 'Visibility': 'external', 'Purpose': 'Returns an array of all market addresses created for a given mode.', 'Parameters': ['uint256 _mode'], 'Returns': ['address[] memory']}, {'Name': 'getPotDistribution', 'Visibility': 'external', 'Purpose': 'Returns the current pot distribution percentages.', 'Parameters': [], 'Returns': ['uint256[5] memory']}, {'Name': 'onlyGovernors', 'Visibility': 'internal', 'Purpose': 'Modifier to restrict function access to governors or the contract owner.', 'Parameters': [], 'Returns': []}, {'Name': 'setNftHubAddress', 'Visibility': 'external', 'Purpose': 'Sets the NFT Hub contract address and the initial NFT mint count (owner only).', 'Parameters': ['IRCNftHubL2 _newAddress', 'uint256 _newNftMintCount'], 'Returns': []}, {'Name': 'setOrderbookAddress', 'Visibility': 'external', 'Purpose': 'Sets the Orderbook contract address (owner only).', 'Parameters': ['IRCOrderbook _newAddress'], 'Returns': []}, {'Name': 'setPotDistribution', 'Visibility': 'public', 'Purpose': 'Sets the pot distribution percentages (owner only).', 'Parameters': ['uint256 _artistCut', 'uint256 _winnerCut', 'uint256 _creatorCut', 'uint256 _affiliateCut', 'uint256 _cardAffiliateCut'], 'Returns': []}, {'Name': 'setminimumPriceIncreasePercent', 'Visibility': 'public', 'Purpose': 'Sets the minimum price increase percentage for markets (owner only).', 'Parameters': ['uint256 _percentIncrease'], 'Returns': []}, {'Name': 'setNFTMintingLimit', 'Visibility': 'public', 'Purpose': 'Sets the maximum number of NFTs allowed per market (owner only).', 'Parameters': ['uint256 _mintLimit'], 'Returns': []}, {'Name': 'setMaxRentIterations', 'Visibility': 'public', 'Purpose': 'Sets the maximum rent iterations limit (owner only).', 'Parameters': ['uint256 _rentLimit'], 'Returns': []}, {'Name': 'setRealitioAddress', 'Visibility': 'public', 'Purpose': 'Sets the Realitio oracle contract address (owner only).', 'Parameters': ['address _newAddress'], 'Returns': []}, {'Name': 'setArbitrator', 'Visibility': 'public', 'Purpose': 'Sets the Arbitrator contract address (owner only).', 'Parameters': ['address _newAddress'], 'Returns': []}, {'Name': 'setTimeout', 'Visibility': 'public', 'Purpose': 'Sets the Realitio timeout period (owner only).', 'Parameters': ['uint32 _newTimeout'], 'Returns': []}, {'Name': 'changeMarketCreationGovernorsOnly', 'Visibility': 'external', 'Purpose': 'Toggles whether market creation is restricted to governors/owner (owner only).', 'Parameters': [], 'Returns': []}, {'Name': 'changeApprovedArtistsOnly', 'Visibility': 'external', 'Purpose': 'Toggles whether only approved artists can be used (owner only).', 'Parameters': [], 'Returns': []}, {'Name': 'changeApprovedAffilliatesOnly', 'Visibility': 'external', 'Purpose': 'Toggles whether only approved affiliates can be used (owner only).', 'Parameters': [], 'Returns': []}, {'Name': 'setSponsorshipRequired', 'Visibility': 'external', 'Purpose': 'Sets the minimum sponsorship required for market creation (owner only).', 'Parameters': ['uint256 _amount'], 'Returns': []}, {'Name': 'changeTrapCardsIfUnapproved', 'Visibility': 'external', 'Purpose': ""Toggles the 'trapIfUnapproved' flag (owner only)."", 'Parameters': [], 'Returns': []}, {'Name': 'setAdvancedWarning', 'Visibility': 'external', 'Purpose': 'Sets the advanced warning period for market creation (owner only).', 'Parameters': ['uint32 _newAdvancedWarning'], 'Returns': []}, {'Name': 'setMaximumDuration', 'Visibility': 'external', 'Purpose': 'Sets the maximum duration allowed for markets (owner only).', 'Parameters': ['uint32 _newMaximumDuration'], 'Returns': []}, {'Name': 'owner', 'Visibility': 'public', 'Purpose': 'Returns the current owner address (from Ownable).', 'Parameters': [], 'Returns': ['address']}, {'Name': 'isGovernor', 'Visibility': 'external', 'Purpose': 'Checks if a given address is a governor.', 'Parameters': ['address _user'], 'Returns': ['bool']}, {'Name': 'changeGovernorApproval', 'Visibility': 'external', 'Purpose': 'Adds or removes governor status for an address (owner only).', 'Parameters': ['address _governor'], 'Returns': []}, {'Name': 'changeMarketApproval', 'Visibility': 'external', 'Purpose': 'Toggles the approval status of a specific market contract (governors only).', 'Parameters': ['address _market'], 'Returns': []}, {'Name': 'changeArtistApproval', 'Visibility': 'external', 'Purpose': 'Toggles the approval status of an artist address (governors only).', 'Parameters': ['address _artist'], 'Returns': []}, {'Name': 'changeAffiliateApproval', 'Visibility': 'external', 'Purpose': 'Toggles the approval status of a general affiliate address (governors only).', 'Parameters': ['address _affiliate'], 'Returns': []}, {'Name': 'changeCardAffiliateApproval', 'Visibility': 'external', 'Purpose': 'Toggles the approval status of a card-specific affiliate address (governors only).', 'Parameters': ['address _affiliate'], 'Returns': []}, {'Name': 'setReferenceContractAddress', 'Visibility': 'external', 'Purpose': 'Sets the RCMarket implementation address for cloning (uberOwner only).', 'Parameters': ['address _newAddress'], 'Returns': []}, {'Name': 'changeUberOwner', 'Visibility': 'external', 'Purpose': 'Changes the uberOwner address (uberOwner only).', 'Parameters': ['address _newUberOwner'], 'Returns': []}, {'Name': 'createMarket', 'Visibility': 'external', 'Purpose': 'Creates a new RCMarket instance by cloning the reference contract, initializes it, registers it with system components (Treasury, NftHub, Orderbook), mints associated NFTs, and applies sponsorship.', 'Parameters': ['uint32 _mode', 'string memory _ipfsHash', 'uint32[] memory _timestamps', 'string[] memory _tokenURIs', 'address _artistAddress', 'address _affiliateAddress', 'address[] memory _cardAffiliateAddresses', 'string calldata _realitioQuestion', 'uint256 _sponsorship'], 'Returns': ['address']}, {'Name': 'getOracleSettings', 'Visibility': 'external', 'Purpose': 'Returns the configured Realitio, Arbitrator, and timeout settings.', 'Parameters': [], 'Returns': ['IRealitio', 'address', 'uint32']}]}, 'ExternalInteractions': ['Clones.clone: Deploys new RCMarket proxy contracts.', 'IRCTreasury (treasury): Calls `checkSponsorship`, `addMarket`.', 'IRCNftHubL2 (nfthub): Calls `addMarket`, `mint`.', 'IRCOrderbook (orderbook): Calls `addMarket`.', 'IRCMarket (newly created instances): Calls `initialize`, `sponsor`, and `isMarket` (via assert).', 'IRealitio (realitio): Address is stored and passed to markets.', 'NativeMetaTransaction: Inherited functionality for EIP-712 meta-transactions (`_msgSender`).'], 'SpecialMechanisms': ['Factory Pattern: Uses OpenZeppelin Clones (minimal proxies) for gas-efficient market deployment.', 'Multi-level Access Control: `Ownable` owner, `Governors` group, and a high-privilege `uberOwner`.', 'Meta-transaction Support: Inherits `NativeMetaTransaction` and initializes EIP-712.', 'Dependency Injection: Core system components (Treasury, NftHub, Orderbook, Realitio, Arbitrator) are set via external functions and stored as interfaces.', 'Approval System: Manages boolean approval flags for markets, artists, and affiliates.', 'Versioning: Tracks the `referenceContractVersion` when the template contract is updated.'], 'Questions': ['What is the specific meaning and usage of the `_mode` parameter in `createMarket` and related mappings?', 'Is the use of `assert()` on the result of `isMarket()` in `changeMarketApproval` and `setReferenceContractAddress` safe? Could a malicious or faulty external contract cause these functions to fail irrecoverably?', 'Why is `hardhat/console.sol` imported? Should it be removed for production deployment?', 'What is the exact purpose of the `trapIfUnapproved` flag and how does it affect market behavior?', 'What prevents the `totalNftMintCount` from potentially exceeding limits if a very large number of markets with many tokens are created?', 'Are there mechanisms for upgrading the `RCFactory` contract itself or migrating state if needed?', 'Is there a way to deactivate or remove markets listed in `marketAddresses` if they become obsolete or problematic?', 'How is the `_msgSender()` context managed for meta-transactions? Does it rely on a trusted forwarder compliant with EIP-2771?']}","{'Findings': [{'Issue': 'Insufficient Access Control on Critical `uberOwner` Functions', 'Severity': 'High', 'Description': 'The `uberOwner` role holds significant power, notably through `setReferenceContractAddress` (which defines the template for new markets) and `changeUberOwner`. These functions are only protected by `require(msgSender() == uberOwner)`. Compromise of the `uberOwner` key allows an attacker to set a malicious reference contract (the `isMarket()` check is insufficient protection) or immediately transfer ownership. There are no time-locks or multi-sig requirements for changing the owner. Additionally, setting the `uberOwner` to `msg.sender` in the constructor without further checks means the deployer gains full control, which could be an attack vector if deployment is compromised.', 'Impact': ""Complete compromise of the factory's integrity and security. Allows creation of malicious markets, potential theft of funds from users interacting with new markets, permanent loss of control if ownership is transferred maliciously, and denial of service."", 'Location': 'RCFactory.sol: Functions `setReferenceContractAddress` (approx. lines 325, 379, 400, 418-431, 502-515), `changeUberOwner` (approx. lines 332, 343, 433-437), and `constructor`.'}, {'Issue': 'Reentrancy Risk in `createMarket` Due to External Calls', 'Severity': 'High', 'Description': 'The `createMarket` function makes several external calls (`treasury.checkSponsorship`, `nfthub.mint`, `treasury.addMarket`, `nfthub.addMarket`, `orderbook.addMarket`). If any of these external contracts (especially the `treasury` or `nfthub`) have vulnerabilities or malicious logic allowing re-entry into the `RCFactory`, an attacker could potentially manipulate state, bypass checks, mint extra NFTs, or disrupt market creation before the initial transaction completes.', 'Impact': 'Potential for reentrancy attacks leading to inconsistent state, data corruption, unauthorized fund transfers, double spending/minting, or other unexpected contract behavior depending on the specifics of the external contracts.', 'Location': 'RCFactory.sol: `createMarket` function, specifically external calls around lines 401, 474, 476, 528.'}, {'Issue': 'Missing Input Validation in `setPotDistribution` Function', 'Severity': 'Medium', 'Description': 'The `setPotDistribution` function checks that the *sum* of distribution cuts (`_artistCut`, `_winnerCut`, `_creatorCut`, `_affiliateCut`, `_cardAffiliateCut`) is less than or equal to 1000 (representing 100%). However, it fails to validate individual cuts. Specifically, it does not check if each cut is non-negative, nor does it prevent an individual cut from exceeding 1000 (although the sum check prevents the total from exceeding 1000). Setting one cut very high could starve others, and large values could theoretically cause overflow issues during the summation before the final check, bypassing it.', 'Impact': 'Unexpected calculation results in profit distribution, potentially leading to unfair rewards, financial discrepancies, contract malfunction if downstream contracts expect valid individual percentages, or potential exploits related to manipulating reward calculations.', 'Location': 'RCFactory.sol: Function `setPotDistribution` (approx. lines 150, 166-190, 172-188, 185-206, 195-214, 304)'}, {'Issue': 'Insufficient Input Validation for Timestamps in `createMarket`', 'Severity': 'Medium', 'Description': 'The `createMarket` function has insufficient validation for the `_timestamps` array. Issues include: not checking if lock (`_timestamps[1]`) or resolution (`_timestamps[2]`) times are in the past (only opening time `_timestamps[0]` is checked); not ensuring logical order (`_timestamps[0] < _timestamps[1] < _timestamps[2]`); potential overflow when adding `1 weeks` to `_timestamps[1]` for checks, which could bypass duration logic; the `maximumDuration` check compares against `block.timestamp` instead of `_timestamps[0]`, allowing locks further in the future than intended; allowing potentially excessively large future timestamps which could cause griefing or issues with long-term calculations.', 'Impact': 'Creation of markets with invalid, illogical, or immediately expired/resolved states. Markets might behave unexpectedly regarding locking, resolution, or duration checks. Potential for user griefing or financial loss if interacting with improperly configured markets.', 'Location': 'RCFactory.sol: Function `createMarket` timestamp validation logic (approx. lines 408, 439, 465, 472-478, 495-498, 568)'}, {'Issue': 'Unchecked Return Value of `nfthub.mint()` Can Lead to Inconsistent State', 'Severity': 'Medium', 'Description': ""In the `createMarket` function, the `nfthub.mint()` call is made inside a loop. While there's a `require` statement checking the return value, if the `mint` function adheres to standards where it might return `false` without reverting (e.g., some safe ERC721 implementations), the loop execution continues. This increments `totalNftMintCount` even if the mint failed, leading to a discrepancy between the factory's count and the actual NFTs minted in the NftHub."", 'Impact': 'Inconsistent state between the factory and the NFT hub, incorrect `totalNftMintCount`, potential failure of future minting operations due to incorrect counts, possibility of double minting or other unexpected behavior related to NFT accounting.', 'Location': 'RCFactory.sol: `createMarket` function, `nfthub.mint` call (approx. lines 472, 474, 482)'}, {'Issue': 'Potential Denial-of-Service (DoS) in `createMarket` due to Unbounded Array Loops', 'Severity': 'Medium', 'Description': 'The `createMarket` function iterates over the `_cardAffiliateAddresses` array. There is no explicit limit on the size of this array. A malicious user could provide a very large array, causing the gas cost for the loop (checking approvals) to exceed the block gas limit, preventing market creation. This constitutes a potential DoS vector.', 'Impact': 'Market creation could be blocked or significantly hindered by transactions submitting very large `_cardAffiliateAddresses` arrays, leading to denial of service for legitimate users.', 'Location': 'RCFactory.sol: `createMarket` function, loop over `_cardAffiliateAddresses` (approx. lines 416-422, 459-469, 474-480)'}, {'Issue': 'Sponsorship Requirement Can Be Bypassed', 'Severity': 'Medium', 'Description': ""A user can call `createMarket` with `_sponsorship` set to zero (if `sponsorshipRequired` is zero or bypassed), creating the market without providing initial sponsorship through the factory. They could then potentially call the `sponsor` method directly on the created market contract, bypassing the factory's `treasury.checkSponsorship` mechanism if the market's own `sponsor` function lacks sufficient checks. This allows market creation without fulfilling the intended sponsorship flow."", 'Impact': 'Users could create markets without paying the required sponsorship, potentially draining resources or abusing the system. The intended economic model for market creation sponsorship is circumvented.', 'Location': 'RCFactory.sol: `createMarket` function sponsorship check (approx. lines 399-402, 464) and `treasury.checkSponsorship` call (approx. line 528)'}, {'Issue': 'Assertion Failures Can Halt Critical Functions', 'Severity': 'Medium', 'Description': 'The `changeMarketApproval` function uses `assert(_marketToApprove.isMarket())`. Assertions are typically disabled in production or consume all gas upon failure. If an invalid address (not implementing `isMarket()`) is passed, the assertion failure could halt the approval/disapproval process entirely, potentially causing a denial of service for managing market approvals.', 'Impact': 'Potential Denial of Service for market approval management if faulty contract addresses are submitted. Transactions might revert unexpectedly, consuming all gas.', 'Location': 'RCFactory.sol: `changeMarketApproval` function (approx. lines 280, 314, 337, 394)'}, {'Issue': 'Uncontrolled NFT Minting Limit Can Lead to Resource Exhaustion', 'Severity': 'Medium', 'Description': 'The `setNFTMintingLimit` function allows the owner to set `nftMintingLimit` without an upper bound. While individual market creations respect this limit (`_tokenURIs.length <= nftMintingLimit`), setting an extremely high limit could allow a single market creation (or cumulative creations) to mint a vast number of NFTs, potentially leading to excessive gas consumption, transaction failures, or other resource exhaustion issues on the network or dependent systems.', 'Impact': 'Potential for denial-of-service by exhausting gas or other resources during market creation if `nftMintingLimit` is set maliciously high.', 'Location': 'RCFactory.sol: `setNFTMintingLimit` (approx. lines 196-208), `createMarket` usage (approx. line 420, 514)'}, {'Issue': 'Potential Integer Overflow/Underflow Issues', 'Severity': 'Low', 'Description': 'Several areas have potential (though often mitigated by Solidity >=0.8.0) overflow/underflow risks: 1) `totalNftMintCount` increment (`totalNftMintCount + _tokenURIs.length`) lacks explicit SafeMath-style checks. 2) Timestamp calculations in `createMarket` (e.g., `_timestamps[1] + (1 weeks)`) could theoretically overflow `uint32` if timestamps are near max value. 3) `setPotDistribution` summation could overflow *during* calculation if individual cuts are extremely large, potentially bypassing the `<= 1000` check.', 'Impact': 'Incorrect tracking of `totalNftMintCount`, unexpected timestamp logic behavior, or incorrect pot distribution percentages if overflows occur. Risk is generally low with modern Solidity versions but explicit checks improve clarity and safety.', 'Location': 'RCFactory.sol: `createMarket` (lines 439, 525, 529, 659), `setPotDistribution` (lines 150, 177, 304)'}, {'Issue': 'Missing Zero Address Checks', 'Severity': 'Low', 'Description': 'Several functions lack explicit checks preventing critical addresses from being set to `address(0)`. This includes `setOrderbookAddress`, `setRealitioAddress`. While `change...Approval` functions prevent setting approvals *for* the zero address, `createMarket` allows `_artistAddress`, `_affiliateAddress`, and addresses within `_cardAffiliateAddresses` to be `address(0)` if the corresponding `...ApprovedOnly` flag is false. While this might be intended, it can cause confusion, potential issues with off-chain systems, or halt contract logic if a required component address is set to zero.', 'Impact': 'Possible confusion, potential interaction issues with off-chain systems, or contract becoming unusable if essential addresses like `orderbook` or `realitio` are set to zero. Allows potentially invalid affiliate addresses in market data.', 'Location': 'RCFactory.sol: `setOrderbookAddress` (line 136), `setRealitioAddress`, `createMarket` (lines 373, 379, 384, 406-422, 459-469, 556), `change...Approval` functions (lines 335-364)'}, {'Issue': 'Inconsistent `assert` Usage', 'Severity': 'Low', 'Description': 'Functions `changeMarketApproval` and `setReferenceContractAddress` use `assert` for checks (`isMarket()`). `assert` is intended for internal invariants and may be disabled or behave differently (consuming all gas on failure) in production environments compared to `require`, which is standard for validating external inputs or conditions.', 'Impact': 'Checks might not be enforced in production environments, potentially leading to unexpected behavior if invalid data is passed. Gas may be wasted unnecessarily if assertions fail.', 'Location': 'RCFactory.sol: `changeMarketApproval` (line 337), `setReferenceContractAddress` (line 379)'}, {'Issue': 'Lack of Input Validation in `setMaxRentIterations`', 'Severity': 'Low', 'Description': 'The `setMaxRentIterations` function (similar to `setNFTMintingLimit`) lacks input validation. An owner could set an extremely high value, potentially leading to excessive gas consumption or DoS in downstream functions that rely on this limit for looping or calculations.', 'Impact': 'Potential denial-of-service (DoS), increased gas costs, and unexpected application behavior if `maxRentIterations` is set unreasonably high.', 'Location': 'RCFactory.sol: `setMaxRentIterations` (approx. lines 196-208)'}, {'Issue': 'Missing Check for Market Existence Before Approval Change', 'Severity': 'Low', 'Description': 'The `changeMarketApproval` function does not verify if the `_marketToApprove` address corresponds to an actual market created by the factory before changing its approval status in the `isMarketApproved` mapping.', 'Impact': 'The `isMarketApproved` mapping can be altered for arbitrary addresses, potentially polluting state with entries for non-existent markets. Low direct impact but indicates incomplete state management.', 'Location': 'RCFactory.sol: `changeMarketApproval` (approx. line 299)'}, {'Issue': 'Potential Replay Attack Vulnerability via NativeMetaTransaction', 'Severity': 'Medium', 'Description': 'The contract implements `NativeMetaTransaction`, enabling gasless transactions. If the nonce management (`_useNonce`) is not robustly implemented and consistently applied, especially when users interact both directly and via meta-transactions, it could open avenues for replay attacks where a signed meta-transaction is submitted multiple times.', 'Impact': 'Meta-transactions could be replayed, leading to unauthorized actions, duplicate operations, or state inconsistencies.', 'Location': 'RCFactory.sol: Implementation of `NativeMetaTransaction` (contract-wide)'}, {'Issue': 'Lack of Access Control on `totalNftMintCount` Update Mechanism', 'Severity': 'Low', 'Description': ""While `totalNftMintCount` is incremented internally during `createMarket`, one report noted it's set by the owner via `setNftHubAddress`. This seems incorrect based on typical usage, but if an owner *could* directly set `totalNftMintCount` (perhaps via an external call not shown or a misunderstanding of `setNftHubAddress`), it would lack fine-grained control beyond `onlyOwner`."", 'Impact': 'If the owner could directly manipulate `totalNftMintCount`, it could lead to incorrect NFT ID assignment or bypass minting limits.', 'Location': 'RCFactory.sol: (Potentially line 201, if interpretation is correct, otherwise primarily line 525/529/659)'}, {'Issue': 'Potential Race Condition on `totalNftMintCount`', 'Severity': 'Medium', 'Description': 'If multiple `createMarket` transactions are processed concurrently (e.g., in the same block), they might read the same `totalNftMintCount`, increment it, and then mint NFTs based on overlapping ID ranges before the state change from the first transaction is fully committed. This lacks explicit mutex/locking.', 'Impact': 'Possible NFT ID collisions or gaps if `createMarket` is called concurrently, leading to issues with NFT uniqueness and ownership.', 'Location': 'RCFactory.sol: `createMarket` function, `totalNftMintCount` update (approx. lines 459, 470, 525, 529, 659)'}, {'Issue': 'Missing Check for Duplicate Card Affiliate Addresses', 'Severity': 'Low', 'Description': ""The `createMarket` function iterates through `_cardAffiliateAddresses` but doesn't check if the same address appears multiple times in the input array. This could allow a creator to list the same affiliate multiple times, potentially causing them to receive multiple shares of the affiliate cut."", 'Impact': 'Potential abuse of the affiliate reward system, allowing specific affiliates to receive disproportionately large rewards if listed multiple times.', 'Location': 'RCFactory.sol: `createMarket`, loop over `_cardAffiliateAddresses` (approx. lines 474-480)'}, {'Issue': 'Missing Input Validation for Contract Address Type', 'Severity': 'Info', 'Description': 'Functions like `setNftHubAddress`, `setOrderbookAddress`, and `setRealitioAddress` check for the zero address but do not validate that the provided `_newAddress` is actually a contract address (using `extcodesize > 0`). Setting these to an Externally Owned Account (EOA) could lead to transaction failures when the factory attempts to interact with them.', 'Impact': 'Potential transaction failures if critical component addresses are set to EOAs instead of contracts, hindering factory operations.', 'Location': 'RCFactory.sol: `setNftHubAddress`, `setOrderbookAddress`, `setRealitioAddress` (approx. lines 268, 274, 341)'}, {'Issue': 'Missing Sponsorship Check when Sponsorship is Zero', 'Severity': 'Info', 'Description': 'The `createMarket` function checks `_sponsorship >= sponsorshipRequired`. If `sponsorshipRequired` is 0, providing `_sponsorship` as 0 passes the check. This simply means markets can be created without an initial sponsorship deposit via the factory if the requirement is set to zero.', 'Impact': 'None, informational. Confirms that zero sponsorship is allowed if configured.', 'Location': 'RCFactory.sol: `createMarket` function (approx. line 464)'}], 'IssueNumber': 67, 'OutputList': 21}",323.666009187698,"### **[M-05] RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0]**

**Report Description**:  
The `RCFactory.createMarket()` function does not enforce that `_timestamps[1]` (market locking time) and `_timestamps[2]` (oracle resolution time) are larger than `_timestamps[0]` (market opening time). This is critical because the `IRCMarket` contract defines a sequence of events (CLOSED, OPEN, LOCKED, WITHDRAW) that must occur in order. Without proper validation, it is possible to create a market where the locking and resolution times occur before the opening time, leading to unexpected behavior and potential security vulnerabilities. Additionally, the function does not enforce minimum values for `_timestamps[1]` and `_timestamps[2]`, allowing users to set these timestamps to 0 or other invalid values.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Input Validation for Timestamps in `createMarket`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with insufficient timestamp validation in the `createMarket` function. It highlights the lack of checks for logical order (`_timestamps[0] < _timestamps[1] < _timestamps[2]`) and the potential for invalid or illogical timestamps, which aligns with the issue described in the report. The response also correctly explains the risks associated with this oversight, such as the creation of markets with invalid states and potential user griefing.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-05] RCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0]**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- *None*

--- 

This evaluation confirms that the response list adequately addresses the issue described in the report, providing a correct and comprehensive analysis of the vulnerability.","```
1. Insufficient Input Validation for Timestamps in `createMarket`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is: `Insufficient Input Validation for Timestamps in \`createMarket\``.
   - This issue appears at **rank 4** in the ranked list of predictions.

2. **Calculate the precision at rank 4 (P@4)**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 4, there is **1 true positive**.
   - \( P@4 = \frac{1}{4} = 0.25 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only **1 true positive**, the AP is simply the precision at its rank.
   - \( AP = 0.25 \).

**Output**:
```
0.25
```"
