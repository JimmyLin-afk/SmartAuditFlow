nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NameWrapper.sol,"//SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    //A contract address to a new upgraded contract if any
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        /* Burn PARENT_CANNOT_CONTROL and CANNOT_UNWRAP fuses for ROOT_NODE and ETH_NODE */

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /* ERC1155 */

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    /* Metadata service */

    /**
     * @notice Set the metadata service. Only the owner can do this
     */

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    /**
     * @notice Get the metadata uri
     * @return String uri of the metadata service
     */

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    /**
     * @notice Set the address of the upgradeContract of the contract. only admin can do this
     * @dev The default value of upgradeContract is the 0 address. Use the 0 address at any time
     * to make the contract not upgradable.
     * @param _upgradeAddress address of an upgraded contract
     */

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    /**
     * @notice Checks if msg.sender is the owner or approved by the owner of a name
     * @param node namehash of the name to check
     */

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    /**
     * @notice Checks if owner or approved by owner
     * @param node namehash of the name to check
     * @param addr which address to check permissions for
     * @return whether or not is owner or approved
     */

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    /**
     * @notice Gets fuse permissions for a specific name
     * @dev Fuses are represented by a uint32 where each permission is represented by 1 bit
     *      The interface has predefined fuses for all registry permissions, but additional
     *      fuses can be added for other use cases
     *      Also returns expiry, which is when the fuses are set to expire.
     * @param node namehash of the name to check
     * @return fuses A number that represents the permissions a name has. Returns 0 when expiry < block.timestamp
     * @return expiry Unix time of when the name expires and fuses are to expire
     */
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    /**
     * @notice Wraps a .eth domain, creating a new token and sending the original ERC721 token to this contract
     * @dev Can be called by the owner of the name on the .eth registrar or an authorised caller on the registrar
     * @param label label as a string of the .eth domain to wrap
     * @param wrappedOwner Owner of the name in this contract
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @param resolver resolver contract address
     */

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        // transfer the token from the user to this contract
        registrar.transferFrom(registrant, address(this), tokenId);

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Registers a new .eth second-level domain and wraps it.
     *      Only callable by authorised controllers.
     * @param label The label to register (Eg, 'foo' for 'foo.eth').
     * @param wrappedOwner The owner of the wrapped name.
     * @param duration The duration, in seconds, to register the name for.
     * @param resolver The resolver address to set on the ENS registry (optional).
     * @param fuses initial fuses to set
     * @param expiry when the fuses will expire
     * @return registrarExpiry The expiry date of the new name on the .eth registrar, in seconds since the Unix epoch.
     */

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    /**
     * @dev Renews a .eth second-level domain.
     *      Only callable by authorised controllers.
     * @param tokenId The hash of the label to register (eg, `keccak256('foo')`, for 'foo.eth').
     * @param duration The number of seconds to renew the name for.
     * @return expires The expiry date of the name on the .eth registrar, in seconds since the Unix epoch.
     */
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    /**
     * @notice Wraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the registry or an authorised caller in the registry
     * @param name The name to wrap, in DNS format
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract address
     */

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    /**
     * @notice Unwraps a .eth domain. e.g. vitalik.eth
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param labelhash labelhash of the .eth domain
     * @param newRegistrant sets the owner in the .eth registrar to this address
     * @param newController sets the owner in the registry to this address
     */

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    /**
     * @notice Unwraps a non .eth domain, of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner in the wrapper or an authorised caller in the wrapper
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param newController sets the owner in the registry to this address
     */

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    /**
     * @notice Sets fuses of a name
     * @param node namehash of the name
     * @param fuses fuses to burn (cannot burn PARENT_CANOT_CONTROL)
     */

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            // Only the parent can burn the PARENT_CANNOT_CONTROL fuse.
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    /**
     * @notice Upgrades a .eth wrapped domain by calling the wrapETH2LD function of the upgradeContract
     *     and burning the token of this contract
     * @dev Can be called by the owner of the name in this contract
     * @param label Label as a string of the .eth name to upgrade
     * @param wrappedOwner The owner of the wrapped name
     */

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    /**
     * @notice Upgrades a non .eth domain of any kind. Could be a DNSSEC name vitalik.xyz or a subdomain
     * @dev Can be called by the owner or an authorised caller
     * Requires upgraded Namewrapper to permit old Namewrapper to call `setSubnodeRecord` for all names
     * @param parentNode namehash of the parent name
     * @param label Label as a string of the name to upgrade
     * @param wrappedOwner Owner of the name in this contract
     * @param resolver resolver contract for this name
     */

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    /* @notice Sets fuses of a name that you own the parent of. Can also be called by the owner of a .eth name
     * @param parentNode parent namehash of the name e.g. vitalik.xyz would be namehash('xyz')
     * @param labelhash labelhash of the name, e.g. vitalik.xyz would be keccak256('vitalik')
     * @param fuses fuses to burn
     * @param expiry when the fuses will expire
     */

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            // max expiry is set to the expiry on the registrar
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            // max expiry is set to the expiry of the parent
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        // if PARENT_CANNOT_CONTROL has been burned and fuses have changed
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    /**
     * @notice Sets the subdomain owner in the registry and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry when the fuses will expire
     */

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets the subdomain owner in the registry with records and then wraps the subdomain
     * @param parentNode parent namehash of the subdomain
     * @param label label of the subdomain as a string
     * @param newOwner newOwner in the registry
     * @param resolver resolver contract in the registry
     * @param ttl ttl in the regsitry
     * @param fuses initial fuses for the wrapped subdomain
     * @param expiry expiry date for the domain
     */

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    /**
     * @notice Sets records for the name in the ENS Registry
     * @param node namehash of the name to set a record for
     * @param owner newOwner in the registry
     * @param resolver the resolver contract
     * @param ttl ttl in the registry
     */

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    /**
     * @notice Sets resolver contract in the registry
     * @param node namehash of the name
     * @param resolver the resolver contract
     */

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    /**
     * @notice Sets TTL in the registry
     * @param node namehash of the name
     * @param ttl TTL in the registry
     */

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    /**
     * @dev Allows an operation only if none of the specified fuses are burned.
     * @param node The namehash of the name to check fuses on.
     * @param fuseMask A bitmask of fuses that must not be burned.
     */

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    /**
     * @notice Check whether a name can call setSubnodeOwner/setSubnodeRecord
     * @dev Checks both canCreateSubdomain and canReplaceSubdomain and whether not they have been burnt
     *      and checks whether the owner of the subdomain is 0x0 for creating or already exists for
     *      replacing a subdomain. If either conditions are true, then it is possible to call
     *      setSubnodeOwner
     * @param node namehash of the name to check
     * @param labelhash labelhash of the name to check
     */

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    /**
     * @notice Checks all Fuses in the mask are burned for the node
     * @param node namehash of the name
     * @param fuseMask the fuses you want to check
     * @return Boolean of whether or not all the selected fuses are burned
     */

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        //check if it's the eth registrar ERC721
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        // transfer the ens record back to the new owner (this contract)
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    /***** Internal functions */

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            // burn and unwrap old token of old owner
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        // burn token and fuse data
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    // wrapper function for stack limit
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        // Expiry cannot be more than maximum allowed
        // .eth names will check registrar, non .eth check parent
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        // Expiry cannot be less than old expiry
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        // Mint a new ERC1155 token with fuses
        // Set PARENT_CANNOT_REPLACE to reflect wrapper + registrar control over the 2LD
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        // Burn token and fuse data
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",7024,963,"[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper
Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to do some stuff in onERC1155Received right after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fake ERC1155 NameWrapper token for domain, which is not owned by NameWrapper.
  [H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy
By design, the child node's expiry can only be extended up to the parent's current one. Adding these restrictions means that the ENS users only have to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand what guarantees the users have.
When a parent node tries to `setSubnodeOwner / setSubnodeRecord`, the following code is used to guarantee that the new expiry can only be extended up to the current one.   [H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node
By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner.
However, this contraint can be bypassed by a parent node maliciously unwrapping itself. As long as the hacker becomes the ENS owner of the parent node, he can leverage ENSRegistry::setSubnodeOwner to re-set himself as the ENS owner of the subdomain, and thus re-invoking the function `wrap` can rewrite the fuses and wrapper owner of the given subdoamin.   [M-01] wrapETH2LD permissioning is over-extended
Current permissioning for the function `wrapETH2LD` allows `msg.senders` who are not owner to call it if they are EITHER approved for all on the ERC721 registrar or approved on the wrapper. Allowing users who are approved for the ERC721 registrar makes sense. By giving them approval, you are giving them approval to do what they wish with the token.   [M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry
There is a general incorrect logic of allowing to burn only `PARENT_CANNOT_CONTROL` fuse without burning `CANNOT_UNWRAP` fuse. If only `PARENT_CANNOT_CONTROL` fuse is burnt, then domain can be unwrapped by its owner and then wrapped again, which clears `PARENT_CANNOT_CONTROL` fuse, making it possible for parent to bypass the limitation of parent control before the expiry.


",5,,"pragma solidity ^0.8.4;

import ""./ERC1155Fuse.sol"";
import ""./Controllable.sol"";
import ""./INameWrapper.sol"";
import ""./INameWrapperUpgrade.sol"";
import ""./IMetadataService.sol"";
import ""../registry/ENS.sol"";
import ""../ethregistrar/IBaseRegistrar.sol"";
import ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./BytesUtil.sol"";

error Unauthorised(bytes32 node, address addr);
error NameNotFound();
error IncompatibleParent();
error IncompatibleName(bytes name);
error IncorrectTokenType();
error LabelMismatch(bytes32 labelHash, bytes32 expectedLabelhash);
error LabelTooShort();
error LabelTooLong(string label);
error IncorrectTargetOwner(address owner);
error CannotUpgrade();
error InvalidExpiry(bytes32 node, uint64 expiry);

contract NameWrapper is
    Ownable,
    ERC1155Fuse,
    INameWrapper,
    Controllable,
    IERC721Receiver
{
    using BytesUtils for bytes;
    ENS public immutable override ens;
    IBaseRegistrar public immutable override registrar;
    IMetadataService public override metadataService;
    mapping(bytes32 => bytes) public override names;

    bytes32 private constant ETH_NODE =
        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;
    bytes32 private constant ROOT_NODE =
        0x0000000000000000000000000000000000000000000000000000000000000000;

    
    INameWrapperUpgrade public upgradeContract;
    uint64 private constant MAX_EXPIRY = type(uint64).max;

    constructor(
        ENS _ens,
        IBaseRegistrar _registrar,
        IMetadataService _metadataService
    ) {
        ens = _ens;
        registrar = _registrar;
        metadataService = _metadataService;

        

        _setData(
            uint256(ETH_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        _setData(
            uint256(ROOT_NODE),
            address(0),
            uint32(PARENT_CANNOT_CONTROL | CANNOT_UNWRAP),
            MAX_EXPIRY
        );
        names[ROOT_NODE] = ""\x00"";
        names[ETH_NODE] = ""\x03eth\x00"";
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Fuse, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(INameWrapper).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    

    function ownerOf(uint256 id)
        public
        view
        override(ERC1155Fuse, INameWrapper)
        returns (address owner)
    {
        return super.ownerOf(id);
    }

    

    

    function setMetadataService(IMetadataService _newMetadataService)
        public
        onlyOwner
    {
        metadataService = _newMetadataService;
    }

    

    function uri(uint256 tokenId) public view override returns (string memory) {
        return metadataService.uri(tokenId);
    }

    

    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress)
        public
        onlyOwner
    {
        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), false);
            ens.setApprovalForAll(address(upgradeContract), false);
        }

        upgradeContract = _upgradeAddress;

        if (address(upgradeContract) != address(0)) {
            registrar.setApprovalForAll(address(upgradeContract), true);
            ens.setApprovalForAll(address(upgradeContract), true);
        }
    }

    

    modifier onlyTokenOwner(bytes32 node) {
        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        _;
    }

    

    function isTokenOwnerOrApproved(bytes32 node, address addr)
        public
        view
        override
        returns (bool)
    {
        address owner = ownerOf(uint256(node));
        return owner == addr || isApprovedForAll(owner, addr);
    }

    
    function getFuses(bytes32 node)
        public
        view
        override
        returns (uint32 fuses, uint64 expiry)
    {
        (, fuses, expiry) = getData(uint256(node));
        if (fuses == 0 && expiry == 0) {
            bytes memory name = names[node];
            if (name.length == 0) {
                revert NameNotFound();
            }
        }
    }

    

    function wrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) public override returns (uint64) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        address registrant = registrar.ownerOf(tokenId);
        if (
            registrant != msg.sender &&
            !isApprovedForAll(registrant, msg.sender) &&
            !registrar.isApprovedForAll(registrant, msg.sender)
        ) {
            revert Unauthorised(
                _makeNode(ETH_NODE, bytes32(tokenId)),
                msg.sender
            );
        }

        
        registrar.transferFrom(registrant, address(this), tokenId);

        
        registrar.reclaim(tokenId, address(this));

        return _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    

    function registerAndWrapETH2LD(
        string calldata label,
        address wrappedOwner,
        uint256 duration,
        address resolver,
        uint32 fuses,
        uint64 expiry
    ) external override onlyController returns (uint256 registrarExpiry) {
        uint256 tokenId = uint256(keccak256(bytes(label)));
        registrarExpiry = registrar.register(tokenId, address(this), duration);
        _wrapETH2LD(label, wrappedOwner, fuses, expiry, resolver);
    }

    
    function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }

    

    function wrap(
        bytes calldata name,
        address wrappedOwner,
        address resolver
    ) public override {
        (bytes32 labelhash, uint256 offset) = name.readLabel(0);
        bytes32 parentNode = name.namehash(offset);
        bytes32 node = _makeNode(parentNode, labelhash);

        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }

        address owner = ens.owner(node);

        if (
            owner != msg.sender &&
            !isApprovedForAll(owner, msg.sender) &&
            !ens.isApprovedForAll(owner, msg.sender)
        ) {
            revert Unauthorised(node, msg.sender);
        }

        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        ens.setOwner(node, address(this));

        _wrap(node, name, wrappedOwner, 0, 0);
    }

    

    function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }

    

    function unwrap(
        bytes32 parentNode,
        bytes32 labelhash,
        address newController
    ) public override onlyTokenOwner(_makeNode(parentNode, labelhash)) {
        if (parentNode == ETH_NODE) {
            revert IncompatibleParent();
        }
        _unwrap(_makeNode(parentNode, labelhash), newController);
    }

    

    function setFuses(bytes32 node, uint32 fuses)
        public
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_BURN_FUSES)
        returns (uint32)
    {
        if (fuses & PARENT_CANNOT_CONTROL != 0) {
            
            revert Unauthorised(node, msg.sender);
        }

        (address owner, uint32 oldFuses, uint64 expiry) = getData(
            uint256(node)
        );

        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
        return fuses;
    }

    

    function upgradeETH2LD(
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);

        upgradeContract.wrapETH2LD(
            label,
            wrappedOwner,
            fuses,
            expiry,
            resolver
        );
    }

    

    function upgrade(
        bytes32 parentNode,
        string calldata label,
        address wrappedOwner,
        address resolver
    ) public {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (uint32 fuses, uint64 expiry) = _prepareUpgrade(node);
        upgradeContract.setSubnodeRecord(
            parentNode,
            label,
            wrappedOwner,
            resolver,
            0,
            fuses,
            expiry
        );
    }

    

    function setChildFuses(
        bytes32 parentNode,
        bytes32 labelhash,
        uint32 fuses,
        uint64 expiry
    ) public {
        bytes32 node = _makeNode(parentNode, labelhash);
        (address owner, uint32 oldFuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        uint64 maxExpiry;
        if (parentNode == ETH_NODE) {
            if (!isTokenOwnerOrApproved(node, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }
            
            maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));
        } else {
            if (!isTokenOwnerOrApproved(parentNode, msg.sender)) {
                revert Unauthorised(node, msg.sender);
            }

            
            (, , maxExpiry) = getData(uint256(parentNode));
        }

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);

        
        if (
            oldFuses & PARENT_CANNOT_CONTROL != 0 &&
            oldFuses | fuses != oldFuses
        ) {
            revert OperationProhibited(node);
        }
        fuses |= oldFuses;
        _setFuses(node, owner, fuses, expiry);
    }

    

    function setSubnodeOwner(
        bytes32 parentNode,
        string calldata label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
        returns (bytes32 node)
    {
        bytes32 labelhash = keccak256(bytes(label));
        node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);

        if (ens.owner(node) != address(this)) {
            ens.setSubnodeOwner(parentNode, labelhash, address(this));
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setSubnodeRecord(
        bytes32 parentNode,
        string memory label,
        address newOwner,
        address resolver,
        uint64 ttl,
        uint32 fuses,
        uint64 expiry
    )
        public
        onlyTokenOwner(parentNode)
        canCallSetSubnodeOwner(parentNode, keccak256(bytes(label)))
    {
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(parentNode, labelhash);
        (, , expiry) = _getDataAndNormaliseExpiry(parentNode, node, expiry);
        if (ens.owner(node) != address(this)) {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _addLabelAndWrap(parentNode, node, label, newOwner, fuses, expiry);
        } else {
            ens.setSubnodeRecord(
                parentNode,
                labelhash,
                address(this),
                resolver,
                ttl
            );
            _transferAndBurnFuses(node, newOwner, fuses, expiry);
        }
    }

    

    function setRecord(
        bytes32 node,
        address owner,
        address resolver,
        uint64 ttl
    )
        public
        override
        onlyTokenOwner(node)
        operationAllowed(
            node,
            CANNOT_TRANSFER | CANNOT_SET_RESOLVER | CANNOT_SET_TTL
        )
    {
        ens.setRecord(node, address(this), resolver, ttl);
        (address oldOwner, , ) = getData(uint256(node));
        _transfer(oldOwner, owner, uint256(node), 1, """");
    }

    

    function setResolver(bytes32 node, address resolver)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_RESOLVER)
    {
        ens.setResolver(node, resolver);
    }

    

    function setTTL(bytes32 node, uint64 ttl)
        public
        override
        onlyTokenOwner(node)
        operationAllowed(node, CANNOT_SET_TTL)
    {
        ens.setTTL(node, ttl);
    }

    

    modifier operationAllowed(bytes32 node, uint32 fuseMask) {
        (, uint32 fuses, ) = getData(uint256(node));
        if (fuses & fuseMask != 0) {
            revert OperationProhibited(node);
        }
        _;
    }

    

    modifier canCallSetSubnodeOwner(bytes32 node, bytes32 labelhash) {
        bytes32 subnode = _makeNode(node, labelhash);
        address owner = ens.owner(subnode);

        if (owner == address(0)) {
            (, uint32 fuses, ) = getData(uint256(node));
            if (fuses & CANNOT_CREATE_SUBDOMAIN != 0) {
                revert OperationProhibited(node);
            }
        } else {
            (, uint32 subnodeFuses, ) = getData(uint256(subnode));
            if (subnodeFuses & PARENT_CANNOT_CONTROL != 0) {
                revert OperationProhibited(node);
            }
        }

        _;
    }

    

    function allFusesBurned(bytes32 node, uint32 fuseMask)
        public
        view
        override
        returns (bool)
    {
        (, uint32 fuses, ) = getData(uint256(node));
        return fuses & fuseMask == fuseMask;
    }

    function onERC721Received(
        address to,
        address,
        uint256 tokenId,
        bytes calldata data
    ) public override returns (bytes4) {
        
        if (msg.sender != address(registrar)) {
            revert IncorrectTokenType();
        }

        (
            string memory label,
            address owner,
            uint32 fuses,
            uint64 expiry,
            address resolver
        ) = abi.decode(data, (string, address, uint32, uint64, address));

        bytes32 labelhash = bytes32(tokenId);
        bytes32 labelhashFromData = keccak256(bytes(label));

        if (labelhashFromData != labelhash) {
            revert LabelMismatch(labelhashFromData, labelhash);
        }

        
        registrar.reclaim(uint256(labelhash), address(this));

        _wrapETH2LD(label, owner, fuses, expiry, resolver);

        return IERC721Receiver(to).onERC721Received.selector;
    }

    

    function _canTransfer(uint32 fuses) internal pure override returns (bool) {
        return fuses & CANNOT_TRANSFER == 0;
    }

    function _makeNode(bytes32 node, bytes32 labelhash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked(node, labelhash));
    }

    function _addLabel(string memory label, bytes memory name)
        internal
        pure
        returns (bytes memory ret)
    {
        if (bytes(label).length < 1) {
            revert LabelTooShort();
        }
        if (bytes(label).length > 255) {
            revert LabelTooLong(label);
        }
        return abi.encodePacked(uint8(bytes(label).length), label, name);
    }

    function _mint(
        bytes32 node,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal override {
        address oldWrappedOwner = ownerOf(uint256(node));
        _canFusesBeBurned(node, fuses);
        if (oldWrappedOwner != address(0)) {
            
            _burn(uint256(node));
            emit NameUnwrapped(node, address(0));
        }
        super._mint(node, wrappedOwner, fuses, expiry);
    }

    function _wrap(
        bytes32 node,
        bytes memory name,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        names[node] = name;
        _mint(node, wrappedOwner, fuses, expiry);
        emit NameWrapped(node, name, wrappedOwner, fuses, expiry);
    }

    function _addLabelAndWrap(
        bytes32 parentNode,
        bytes32 node,
        string memory label,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        bytes memory name = _addLabel(label, names[parentNode]);
        _wrap(node, name, newOwner, fuses, expiry);
    }

    function _prepareUpgrade(bytes32 node)
        private
        returns (uint32 fuses, uint64 expiry)
    {
        if (address(upgradeContract) == address(0)) {
            revert CannotUpgrade();
        }

        if (!isTokenOwnerOrApproved(node, msg.sender)) {
            revert Unauthorised(node, msg.sender);
        }

        (fuses, expiry) = getFuses(node);

        
        _burn(uint256(node));
    }

    function _transferAndBurnFuses(
        bytes32 node,
        address newOwner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        (address owner, , ) = getData(uint256(node));
        _transfer(owner, newOwner, uint256(node), 1, """");
        _setFuses(node, newOwner, fuses, expiry);
    }

    
    function _getDataAndNormaliseExpiry(
        bytes32 parentNode,
        bytes32 node,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        (, , uint64 maxExpiry) = getData(uint256(parentNode));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _getETH2LDDataAndNormaliseExpiry(
        bytes32 node,
        bytes32 labelhash,
        uint64 expiry
    )
        internal
        view
        returns (
            address owner,
            uint32 fuses,
            uint64
        )
    {
        uint64 oldExpiry;
        (owner, fuses, oldExpiry) = getData(uint256(node));
        uint64 maxExpiry = uint64(registrar.nameExpires(uint256(labelhash)));

        expiry = _normaliseExpiry(expiry, oldExpiry, maxExpiry);
        return (owner, fuses, expiry);
    }

    function _normaliseExpiry(
        uint64 expiry,
        uint64 oldExpiry,
        uint64 maxExpiry
    ) internal pure returns (uint64) {
        
        
        if (expiry > maxExpiry) {
            expiry = maxExpiry;
        }
        
        if (expiry < oldExpiry) {
            expiry = oldExpiry;
        }

        return expiry;
    }

    function _wrapETH2LD(
        string memory label,
        address wrappedOwner,
        uint32 fuses,
        uint64 expiry,
        address resolver
    ) private returns (uint64) {
        
        
        bytes32 labelhash = keccak256(bytes(label));
        bytes32 node = _makeNode(ETH_NODE, labelhash);

        (, , expiry) = _getETH2LDDataAndNormaliseExpiry(
            node,
            labelhash,
            expiry
        );

        _addLabelAndWrap(
            ETH_NODE,
            node,
            label,
            wrappedOwner,
            fuses | PARENT_CANNOT_CONTROL,
            expiry
        );
        if (resolver != address(0)) {
            ens.setResolver(node, resolver);
        }

        return expiry;
    }

    function _unwrap(bytes32 node, address newOwner) private {
        if (newOwner == address(0x0) || newOwner == address(this)) {
            revert IncorrectTargetOwner(newOwner);
        }

        if (allFusesBurned(node, CANNOT_UNWRAP)) {
            revert OperationProhibited(node);
        }

        
        _burn(uint256(node));
        ens.setOwner(node, newOwner);

        emit NameUnwrapped(node, newOwner);
    }

    function _setFuses(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _setData(node, owner, fuses, expiry);
        emit FusesSet(node, fuses, expiry);
    }

    function _setData(
        bytes32 node,
        address owner,
        uint32 fuses,
        uint64 expiry
    ) internal {
        _canFusesBeBurned(node, fuses);
        super._setData(uint256(node), owner, fuses, expiry);
    }

    function _canFusesBeBurned(bytes32 node, uint32 fuses) internal pure {
        if (
            fuses & ~PARENT_CANNOT_CONTROL != 0 &&
            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=
            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)
        ) {
            revert OperationProhibited(node);
        }
    }
}",4828,3,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the contract owner can call `setMetadataService` and `setUpgradeContract`."",
        ""Confirm that the `onlyController` modifier correctly restricts access to `registerAndWrapETH2LD` and `renew` functions to authorized controller addresses."",
        ""Analyze the logic within the `onlyTokenOwner` modifier to ensure it accurately identifies the token owner or an approved address for a given node. Check for potential bypasses."",
        ""Investigate the `isTokenOwnerOrApproved` function to verify that approval checks function correctly, considering both standard approvals and registrar approvals."",
        ""Examine the `operationAllowed` modifier and ensure that the fuse masks are correctly applied and prevent unauthorized operations as intended."",
        ""Check all functions using modifiers such as `onlyTokenOwner`, `onlyController`, `operationAllowed` to guarantee proper usage and prevent unintended access."",
        ""Review `canCallSetSubnodeOwner` modifier to ensure access control to subnode creation and modification is correctly handled based on parent and subnode fuses.""
      ]
    },
    {
      ""Area"": ""Fuse Logic and Permissions"",
      ""Tasks"": [
        ""Carefully analyze the `ERC1155Fuse.sol` contract to understand the exact meaning and implications of each fuse bitmask (e.g., `PARENT_CANNOT_CONTROL`, `CANNOT_UNWRAP`, `CANNOT_BURN_FUSES`)."",
        ""Trace the usage of fuse flags throughout the contract to ensure they are applied consistently and as intended."",
        ""Specifically, audit the `setFuses` function to confirm that it only allows burning (adding) new restrictions and doesn't allow lifting existing restrictions (unburning fuses), except where specifically intended."",
        ""Examine the `setChildFuses` function to ensure the parent's permissions and expiry are correctly enforced on child nodes. Pay close attention to how `_normaliseExpiry` interacts with the registrar's expiry."",
        ""Verify that the `allFusesBurned` function provides accurate information about the status of fuse flags."",
        ""Analyze the `_canFusesBeBurned` function to confirm that certain fuses can't be burned without satisfying some conditions."",
        ""Investigate the interaction of `PARENT_CANNOT_CONTROL` fuse, specifically in `setChildFuses` function, to understand the restriction implications and potential bypass.""
      ]
    },
    {
      ""Area"": ""Expiry Management and Renewal"",
      ""Tasks"": [
        ""Thoroughly examine the `_normaliseExpiry` function to confirm that it correctly handles edge cases and prevents invalid expiry values (expiry exceeding maxExpiry or being less than oldExpiry)."",
        ""Analyze the `renew` function to ensure that the renewal process correctly updates the expiry and respects the maximum expiry from the registrar."",
        ""Investigate the `wrapETH2LD` and `registerAndWrapETH2LD` functions to confirm that the expiry is properly set and normalized when wrapping .eth 2LDs."",
        ""Review the `setChildFuses` function and the `_getDataAndNormaliseExpiry`/`_getETH2LDDataAndNormaliseExpiry` functions to ensure the expiration inheritance and constraints are correctly enforced from parent to child nodes and .eth 2LD, respectively."",
        ""Assess the risk of DoS if `maxExpiry` is close to block.timestamp or now, and the `expiry` parameter is not properly handled causing failure when setting the fuse."",
        ""Check for any potential vulnerabilities where an incorrect `expiry` value could lead to unexpected behavior or loss of functionality.""
      ]
    },
    {
      ""Area"": ""Wrapping and Unwrapping Logic"",
      ""Tasks"": [
        ""Carefully review the `wrapETH2LD` and `wrap` functions to ensure that they correctly interact with the ENS registry and registrar, and that all state is updated consistently."",
        ""Analyze the `unwrapETH2LD` and `unwrap` functions to ensure that they correctly revert ownership to the specified addresses and that all necessary state is cleared."",
        ""Verify that the `onERC721Received` function correctly handles incoming .eth 2LD tokens from the registrar and wraps them according to the provided data."",
        ""Examine the edge cases in `unwrap` and `unwrapETH2LD` functions where `newOwner` or `newRegistrant` are address(0) or the contract's address. Ensure the expected behaviour is achieved."",
        ""Inspect the flow within `wrapETH2LD` starting from `registrar.transferFrom` to prevent race conditions where the wrapped owner can change while the token has been transferred to the contract.""
      ]
    },
    {
      ""Area"": ""Upgrade Mechanism"",
      ""Tasks"": [
        ""Thoroughly analyze the `setUpgradeContract` function to verify that it correctly sets the address of the upgrade contract and grants necessary approvals."",
        ""Examine the `upgradeETH2LD` and `upgrade` functions to ensure that they correctly prepare the name for migration and call the upgrade contract with the appropriate data."",
        ""Assess the atomicity of the upgrade process. Since `_prepareUpgrade` burns the token before calling the external `upgradeContract`, what happens if the external call fails? Is there a mechanism to recover the name?"",
        ""Verify that the `upgradeContract` has proper checks and controls to prevent unauthorized upgrades or malicious behavior."",
        ""Check for replay attack vulnerabilities during the upgrade process where old upgrade requests can be replayed with the same parameters.""
      ]
    },
    {
      ""Area"": ""External Interactions and Data Validation"",
      ""Tasks"": [
        ""Review all external calls to the ENS registry (`ens`), the registrar (`registrar`), and the metadata service (`metadataService`) to ensure that the calls are made correctly and that the returned data is properly validated."",
        ""Specifically examine how the `BytesUtils` library is used and whether it properly handles all edge cases and potential malformed name data, preventing potential vulnerabilities such as buffer overflows or unexpected behavior."",
        ""Check the `onERC721Received` to ensure all data is properly validated (label, owner, fuses, expiry, resolver) to prevent any manipulation before wrapping the ETH2LD."",
        ""Audit the `registerAndWrapETH2LD` and `renew` functions to assess the security risks and trust assumptions associated with designated controller addresses.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify potential gas inefficiencies in the contract, such as redundant storage reads/writes, unnecessary loops, or inefficient data structures."",
        ""Analyze the gas costs of key functions (e.g., `wrap`, `unwrap`, `setFuses`, `setSubnodeRecord`) and identify opportunities for optimization."",
        ""Examine the use of calldata vs. memory for function parameters and local variables to minimize gas consumption."",
        ""Review the contract's storage layout to identify opportunities to reduce storage costs through packing or other techniques."",
        ""Use static analysis tools (e.g., Slither, Mythril) to identify potential gas vulnerabilities or inefficiencies.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The `NameWrapper` contract is a complex system for wrapping Ethereum Name Service (ENS) names into ERC1155 tokens. It interacts heavily with the core ENS registry and the `.eth` Base Registrar. The contract introduces a layer of features on top of ENS, including granular permissions (fuses), expiry management linked to parent nodes or registrar expiry, and the ability to manage subdomains and records directly through the wrapper interface. It also includes mechanisms for administration (ownership, controllers) and a pathway for upgrading wrapped names to a new contract version. The code utilizes inheritance extensively and relies on several external interfaces and a bytes utility library."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NameWrapper"",
    ""Purpose"": ""To wrap ENS names (.eth 2LDs and other domains/subdomains) into ERC1155 tokens, providing enhanced features like permissions (fuses), expiry management, and streamlined subdomain control, while acting as the owner of the name in the underlying ENS registry or registrar."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Ownable"",
        ""ERC1155Fuse"",
        ""INameWrapper"",
        ""Controllable"",
        ""IERC721Receiver""
      ],
      ""Imports"": [
        ""./ERC1155Fuse.sol"",
        ""./Controllable.sol"",
        ""./INameWrapper.sol"",
        ""./INameWrapperUpgrade.sol"",
        ""./IMetadataService.sol"",
        ""../registry/ENS.sol"",
        ""../ethregistrar/IBaseRegistrar.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""./BytesUtil.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""ens"",
        ""Type"": ""ENS"",
        ""Purpose"": ""Reference to the ENS registry contract.""
      },
      {
        ""Name"": ""registrar"",
        ""Type"": ""IBaseRegistrar"",
        ""Purpose"": ""Reference to the ENS Base Registrar contract (for .eth 2LDs).""
      },
      {
        ""Name"": ""metadataService"",
        ""Type"": ""IMetadataService"",
        ""Purpose"": ""Reference to a contract that provides token URI metadata.""
      },
      {
        ""Name"": ""names"",
        ""Type"": ""mapping(bytes32 => bytes)"",
        ""Purpose"": ""Stores the full ENS name (DNS encoded) associated with a node hash (tokenId).""
      },
      {
        ""Name"": ""ETH_NODE"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Constant storing the node hash for the '.eth' TLD.""
      },
      {
        ""Name"": ""ROOT_NODE"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Constant storing the node hash for the ENS root.""
      },
      {
        ""Name"": ""upgradeContract"",
        ""Type"": ""INameWrapperUpgrade"",
        ""Purpose"": ""Address of a potential newer version of the NameWrapper contract for migrating names.""
      },
      {
        ""Name"": ""MAX_EXPIRY"",
        ""Type"": ""uint64"",
        ""Purpose"": ""Constant representing the maximum possible expiry value.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with ENS, Registrar, and MetadataService addresses, and sets initial data for root nodes."",
        ""Parameters"": [""ENS _ens"", ""IBaseRegistrar _registrar"", ""IMetadataService _metadataService""],
        ""Returns"": []
      },
      {
        ""Name"": ""supportsInterface"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""ERC165 interface detection."",
        ""Parameters"": [""bytes4 interfaceId""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""ownerOf"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the owner of a wrapped name (token). Overrides ERC1155Fuse."",
        ""Parameters"": [""uint256 id""],
        ""Returns"": [""address owner""]
      },
      {
        ""Name"": ""setMetadataService"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the contract owner to update the metadata service address."",
        ""Parameters"": [""IMetadataService _newMetadataService""],
        ""Returns"": []
      },
      {
        ""Name"": ""uri"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the metadata URI for a given token ID by calling the metadataService."",
        ""Parameters"": [""uint256 tokenId""],
        ""Returns"": [""string memory""]
      },
      {
        ""Name"": ""setUpgradeContract"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the contract owner to set the address for contract upgrades and grants approvals."",
        ""Parameters"": [""INameWrapperUpgrade _upgradeAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyTokenOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts access to functions to the owner of the wrapped name (token) or an approved address."",
        ""Parameters"": [""bytes32 node""],
        ""Returns"": []
      },
      {
        ""Name"": ""isTokenOwnerOrApproved"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if an address is the owner or approved for a specific wrapped name."",
        ""Parameters"": [""bytes32 node"", ""address addr""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""getFuses"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Retrieves the fuse bitmap and expiry for a wrapped name."",
        ""Parameters"": [""bytes32 node""],
        ""Returns"": [""uint32 fuses"", ""uint64 expiry""]
      },
      {
        ""Name"": ""wrapETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Wraps an existing .eth second-level domain (ERC721) into an ERC1155 token."",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""uint32 fuses"", ""uint64 expiry"", ""address resolver""],
        ""Returns"": [""uint64""]
      },
      {
        ""Name"": ""registerAndWrapETH2LD"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Registers a new .eth 2LD (via controller) and wraps it."",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""uint256 duration"", ""address resolver"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": [""uint256 registrarExpiry""]
      },
      {
        ""Name"": ""renew"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Renews the registration of an underlying .eth 2LD (via controller) and updates the wrapper expiry."",
        ""Parameters"": [""uint256 tokenId"", ""uint256 duration"", ""uint64 expiry""],
        ""Returns"": [""uint256 expires""]
      },
      {
        ""Name"": ""wrap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Wraps an existing ENS name (non-.eth 2LD) into an ERC1155 token."",
        ""Parameters"": [""bytes calldata name"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""unwrapETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Unwraps a .eth 2LD, returning control of the ERC721 to a specified address."",
        ""Parameters"": [""bytes32 labelhash"", ""address newRegistrant"", ""address newController""],
        ""Returns"": []
      },
      {
        ""Name"": ""unwrap"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Unwraps a non-.eth 2LD, returning control in the ENS registry to a specified address."",
        ""Parameters"": [""bytes32 parentNode"", ""bytes32 labelhash"", ""address newController""],
        ""Returns"": []
      },
      {
        ""Name"": ""setFuses"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the token owner to burn additional fuses (add restrictions) on a wrapped name."",
        ""Parameters"": [""bytes32 node"", ""uint32 fuses""],
        ""Returns"": [""uint32""]
      },
      {
        ""Name"": ""upgradeETH2LD"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Prepares a wrapped .eth 2LD for migration to the `upgradeContract`."",
        ""Parameters"": [""string calldata label"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""upgrade"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Prepares a wrapped non-.eth 2LD for migration to the `upgradeContract`."",
        ""Parameters"": [""bytes32 parentNode"", ""string calldata label"", ""address wrappedOwner"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""setChildFuses"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the parent name owner to set fuses and expiry on a child wrapped name, respecting permissions and parent expiry."",
        ""Parameters"": [""bytes32 parentNode"", ""bytes32 labelhash"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""setSubnodeOwner"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Creates or updates a subnode, setting its owner within the wrapper. Can wrap the subnode if not already wrapped."",
        ""Parameters"": [""bytes32 parentNode"", ""string calldata label"", ""address newOwner"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": [""bytes32 node""]
      },
      {
        ""Name"": ""setSubnodeRecord"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Creates or updates a subnode, setting owner, resolver, and TTL within the wrapper/ENS."",
        ""Parameters"": [""bytes32 parentNode"", ""string memory label"", ""address newOwner"", ""address resolver"", ""uint64 ttl"", ""uint32 fuses"", ""uint64 expiry""],
        ""Returns"": []
      },
      {
        ""Name"": ""setRecord"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the owner, resolver, and TTL for a wrapped name, respecting fuses."",
        ""Parameters"": [""bytes32 node"", ""address owner"", ""address resolver"", ""uint64 ttl""],
        ""Returns"": []
      },
      {
        ""Name"": ""setResolver"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the resolver for a wrapped name, respecting fuses."",
        ""Parameters"": [""bytes32 node"", ""address resolver""],
        ""Returns"": []
      },
      {
        ""Name"": ""setTTL"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the TTL for a wrapped name, respecting fuses."",
        ""Parameters"": [""bytes32 node"", ""uint64 ttl""],
        ""Returns"": []
      },
      {
        ""Name"": ""operationAllowed"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Checks if a specific fuse (or set of fuses) is *not* burned, reverting if the operation is prohibited."",
        ""Parameters"": [""bytes32 node"", ""uint32 fuseMask""],
        ""Returns"": []
      },
      {
        ""Name"": ""canCallSetSubnodeOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Checks if the caller is allowed to create or modify a subnode based on parent/subnode fuses."",
        ""Parameters"": [""bytes32 node"", ""bytes32 labelhash""],
        ""Returns"": []
      },
      {
        ""Name"": ""allFusesBurned"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Checks if a specific set of fuses has been burned for a node."",
        ""Parameters"": [""bytes32 node"", ""uint32 fuseMask""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""onERC721Received"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Handles receiving an ERC721 token (specifically from the Base Registrar) to automatically wrap a .eth 2LD."",
        ""Parameters"": [""address to"", ""address"", ""uint256 tokenId"", ""bytes calldata data""],
        ""Returns"": [""bytes4""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ENS Registry (`ens`): Reads/writes ownership, records (resolver, TTL), and approvals."",
    ""Base Registrar (`registrar`): Reads/writes ownership, transfers/reclaims ERC721 tokens, handles registration/renewal, reads expiry, and manages approvals."",
    ""Metadata Service (`metadataService`): Called to retrieve token URIs."",
    ""Upgrade Contract (`upgradeContract`): Called during the name migration process to wrap/set records in the new contract."",
    ""Controller Addresses (via `Controllable`): External addresses authorized to call specific functions like `registerAndWrapETH2LD` and `renew`.""
  ],
  ""SpecialMechanisms"": [
    ""ERC1155 Tokenization: Represents ENS names as ERC1155 tokens where `tokenId` == `node`."",
    ""Fuse System (Permissions): Uses `ERC1155Fuse` for granular, burnable permissions controlling actions on wrapped names."",
    ""Expiry Normalization: Ensures wrapped name expiry respects parent node expiry or registrar expiry."",
    ""Upgrade Path: Facilitates migration of wrapped names to a new contract instance."",
    ""Controller Pattern: Restricts certain sensitive operations (registration, renewal) to authorized controller contracts/addresses."",
    ""Automatic Wrapping: `onERC721Received` allows wrapping .eth 2LDs by directly transferring them from the registrar."",
    ""Ownable Pattern: Administrative functions are restricted to the contract owner.""
  ],
  ""Questions"": [
    ""What are the specific bitmasks/values for the fuse constants (e.g., `PARENT_CANNOT_CONTROL`, `CANNOT_UNWRAP`, `CANNOT_BURN_FUSES`) defined in `ERC1155Fuse.sol`?"",
    ""What are the security considerations and trust assumptions regarding the designated Controller addresses?"",
    ""Are there potential gas limits issues with complex operations involving multiple external calls (e.g., `setSubnodeRecord`, `wrapETH2LD`)?"",
    ""How is the atomicity handled during the upgrade process (`_prepareUpgrade` burning the token before calling the external `upgradeContract`)? What happens if the external call fails?"",
    ""What prevents the owner of a parent node from setting an arbitrarily short expiry on a child node via `setChildFuses`, potentially griefing the child owner (within the limits of the parent's own expiry)? The `_normaliseExpiry` only prevents setting expiry *higher* than maxExpiry or *lower* than oldExpiry."",
    ""How does the `BytesUtils` library handle potential edge cases or malformed name data?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unprotected Upgrade Function Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The `upgradeETH2LD` and `upgrade` functions allow anyone to trigger the upgrade process for any name, burning the existing token and calling a function on `upgradeContract` to mint a new one. If `upgradeContract` is malicious or compromised, it could mint tokens to an attacker, bypassing access controls or introducing unexpected state changes. There is no check to verify `msg.sender`\'s approval for the `upgradeContract` address, and any approvals of the `upgradeContract` are removed before updating the `upgradeContract` address, creating a potential window of opportunity for exploits."",
      ""Impact"": ""Complete compromise of the NameWrapper contract. Attackers could gain unauthorized control over names, potentially stealing or manipulating them. Could result in significant financial loss and reputational damage; DoS by burning node and calling upgrade."",
      ""Location"": ""Functions `upgradeETH2LD` and `upgrade`, `setUpgradeContract`""
    },
    {
      ""Issue"": ""Unbounded loop vulnerability in `onERC721Received`"",
      ""Severity"": ""High"",
      ""Description"": ""The contract calls `IERC721Receiver(to).onERC721Received.selector;` in the `onERC721Received` function. This implies an external call to an arbitrary address `to`, which is not validated. If the `to` address is a contract that reverts or is malicious, the entire transaction could revert, effectively causing a denial-of-service."",
      ""Impact"": ""Denial-of-service. An attacker can provide a malicious address for `to` to cause the transaction to always revert. This blocks legitimate ERC-721 transfers to this NameWrapper"",
      ""Location"": ""Function `onERC721Received`""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `onERC721Received`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `onERC721Received` function receives an ERC721 token (from the registrar) and then calls `IERC721Receiver(to).onERC721Received.selector`. This allows the external `to` contract to execute arbitrary code which can introduce reentrancy issues. A malicious contract can re-enter and manipulate the contract's state before it completes. This is particularly critical due to the state modifications happening before the external call."",
      ""Impact"": ""Possible exploitation through reentrancy, allowing attackers to manipulate state variables or perform unauthorized actions, such as repeatedly wrapping and unwrapping a domain or unwrapping a name they don't own."",
      ""Location"": ""Line 521 in `onERC721Received`, Function `onERC721Received`""
    },
    {
      ""Issue"": ""Incorrect Expiry Calculation and Uncontrolled Expiry Values"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `renew` function updates the expiry of a name using `_normaliseExpiry`, but depends on external data which, if manipulated, could lead to incorrect expiry. `setChildFuses` normalizes expiry but user-provided `maxExpiry` from `getData(uint256(parentNode))` can be manipulated for non-ETH_NODE parents, bypassing intended expiry restrictions. Also, `registerAndWrapETH2LD` and `renew` take an expiry parameter directly from the user which leads to unexpected expiry values."",
      ""Impact"": ""Incorrect name expiry calculations, potentially leading to names expiring sooner than expected and becoming available for others to register; Allow setting arbitrarily long expiries on child nodes; Incorrect expiry values could lead to names expiring sooner or later than intended."",
      ""Location"": ""Function `renew`, NameWrapper.sol:462-501, NameWrapper.sol:211-214, NameWrapper.sol:228-232""
    },
    {
      ""Issue"": ""Incorrect Use of `PARENT_CANNOT_CONTROL` Flag and Inconsistent Fuse Checks"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `_wrapETH2LD`, the `PARENT_CANNOT_CONTROL` fuse is always applied, potentially limiting user flexibility. In `setChildFuses`, a check prevents increasing fuses if the parent cannot control the child, but this check is absent in `setFuses`, potentially allowing users to bypass intended restrictions."",
      ""Impact"": ""Unexpected limitations on how users can manage fuse settings; Users might be able to set fuses that they shouldn't be able to set, circumventing intended limitations."",
      ""Location"": ""Line 640 in `_wrapETH2LD`, NameWrapper.sol:487-492, NameWrapper.sol:409-417""
    },
    {
      ""Issue"": ""Lack of Input Validation in `setChildFuses` leading to inconsistent state."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setChildFuses` function combines new and old fuses using a bitwise OR, which could lead to unintended side effects. No explicit check prevents setting `expiry` to 0 or a past value, which can create an inconsistent state where the fuse is active but effectively expired."",
      ""Impact"": ""Unintended fuses can be set, limiting future functionality, or creating a state that bypasses critical restrictions.  Incorrect expiry values could lead to names expiring sooner or later than intended, causing disruption for users."",
      ""Location"": ""NameWrapper.sol:312-328""
    },
    {
      ""Issue"": ""Possible inconsistency between NameWrapper and ENS records after upgrade"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `upgradeETH2LD` and `upgrade` functions burn the existing NameWrapper token and then call a function on the `upgradeContract`. If the upgrade contract fails to properly recreate the token with the correct settings and links to ENS, there may be an inconsistency."",
      ""Impact"": ""Users might lose access to their names or experience incorrect resolution if the upgrade process is not carefully implemented in the upgrade contract."",
      ""Location"": ""NameWrapper.sol:274-300""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability through ENS Interaction"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `setSubnodeOwner`, `setSubnodeRecord`, `setRecord`, `setResolver`, and `setTTL` interact with the `ens` contract via external calls. These interactions involve modifying the state of the ENS registry and introduces the possibility of reentrancy attacks."",
      ""Impact"": ""A successful reentrancy attack could allow an attacker to bypass authorization checks, mint or burn tokens unexpectedly, or perform other unauthorized actions."",
      ""Location"": ""Functions interacting with the `ens` contract""
    },
    {
      ""Issue"": ""Potential Denial-of-Service in `upgradeETH2LD` and `upgrade` due to `upgradeContract`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `upgradeETH2LD` and `upgrade` functions rely on calling external `upgradeContract` to perform the actual upgrading. If the external contract call fails or gas limits are exceeded, the `_burn` is already executed which will make names inaccessible/unusable."",
      ""Impact"": ""Names will be unusable, funds can be locked."",
      ""Location"": ""Functions `upgradeETH2LD`, `upgrade`""
    },
    {
      ""Issue"": ""Unprotected `upgradeETH2LD` and `upgrade` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `upgradeETH2LD` and `upgrade` functions lack proper access control and rely on an external upgrade contract that could be malicious. The `upgradeContract`'s functions `wrapETH2LD` and `setSubnodeRecord` are then called without any additional access controls allowing for a potential takeover of the name if the `upgradeContract` does not correctly validate the input parameters or has vulnerabilities."",
      ""Impact"": ""Potential takeover of an ENS name by a malicious or compromised upgrade contract."",
      ""Location"": ""Functions `upgradeETH2LD` and `upgrade`""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `_normaliseExpiry`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_normaliseExpiry` function attempts to normalize the expiry value, potentially capping it at `maxExpiry` and ensuring it's not less than `oldExpiry`. While it checks `expiry > maxExpiry` and `expiry < oldExpiry`, it doesn't explicitly check for potential integer overflows when these values are close to the maximum or minimum values of `uint64`."",
      ""Impact"": ""If an integer overflow occurs, the `expiry` value could wrap around, leading to unexpected behavior in the contract, potentially allowing names to expire earlier or later than intended. This can have implications for name ownership and control."",
      ""Location"": ""Function `_normaliseExpiry`, NameWrapper.sol:718-735""
    },
    {
      ""Issue"": ""Unchecked Return Value in `_wrapETH2LD`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `_wrapETH2LD` calls `_addLabelAndWrap`. It's important to ensure that the state changes caused by internal function calls are always successful. Although `_addLabelAndWrap` doesn\'t return a value, deeper inspection reveals that `_mint` is called within `_addLabelAndWrap`. `_mint` in `ERC1155Fuse` is abstract and implemented in the `ERC1155` contract, this will revert if it tries to mint to the zero address."",
      ""Impact"": ""The operation may fail silently if the internal function calls fails, potentially leading to unexpected state and DoS."",
      ""Location"": ""Line 642 in `_wrapETH2LD`""
    },
    {
      ""Issue"": ""Missing Input Validation in `setSubnodeOwner` and `setSubnodeRecord` for label"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setSubnodeOwner` and `setSubnodeRecord` functions accept a `string memory label` as input without explicit length validation within these functions themselves before modifier checks. A malicious user could attempt to send a very long or short label, consuming gas due to modifier checks, only for the transaction to ultimately fail due to the label check in `_addLabel`."",
      ""Impact"": ""A malicious user could waste gas due to modifier checks when providing invalid labels."",
      ""Location"": ""Lines 411 and 439 in `setSubnodeOwner` and `setSubnodeRecord` respectively""
    },
    {
      ""Issue"": ""Missing Input Validation on `setChildFuses`"",
      ""Severity"": ""Low"",
      ""Description"": ""In `setChildFuses`, the check `oldFuses | fuses != oldFuses` is performed after retrieving the `oldFuses`. Fuses are ORed here, so a user may be able to overwrite an older fuse with a new one. Also, the expiry time can be overwritten, so a user might be able to reduce the expiry time of an existing fuse."",
      ""Impact"": ""Incorrect name configurations, unexpected errors."",
      ""Location"": ""Function `setChildFuses`""
    },
    {
      ""Issue"": ""Potential Denial of Service in setUpgradeContract"",
      ""Severity"": ""Low"",
      ""Description"": ""The setUpgradeContract function attempts to set approval for all to the new upgrade contract, after removing the old upgrade contract\'s approval. If the new upgrade contract is a contract that reverts when setApprovalForAll is called on it, the owner will not be able to update the upgrade contract. The old upgrade contract may have been malicious, so this can allow a malicious upgrade contract to exist in perpetuity."",
      ""Impact"": ""Denial of Service if the owner cannot update a compromised or malicious upgrade contract."",
      ""Location"": ""Function `setUpgradeContract`""
    },
    {
      ""Issue"": ""Potential Reentrancy in `setUpgradeContract`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setUpgradeContract` function updates the `upgradeContract` address and sets or unsets approval for `upgradeContract` on both the `registrar` and `ens` contracts. Setting the approval may trigger a callback to the `upgradeContract` if it's a smart contract, potentially leading to reentrancy issues if the `upgradeContract` is malicious. Although this is mitigated by the use of `setApprovalForAll` rather than direct calls, any reentrancy vector via untrusted contracts should still be considered."",
      ""Impact"": ""Reentrancy attack leading to unexpected state changes if the `upgradeContract` is malicious."",
      ""Location"": ""NameWrapper.sol:161-175""
    },
    {
      ""Issue"": ""Unprotected Upgrade Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The upgradeETH2LD and upgrade functions are `public` and can be called by anyone. A malicious actor could call these functions unnecessarily, causing the burning of the node and potentially other unintended effects."",
      ""Impact"": ""DoS by burning node and calling upgrade"",
      ""Location"": ""NameWrapper.sol:422, NameWrapper.sol:441""
    },
    {
      ""Issue"": ""Inconsistent Approval Handling in `setUpgradeContract`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setUpgradeContract` function first revokes approvals for the previous `upgradeContract` and then sets approvals for the new `upgradeContract`.  There\'s a potential race condition or unexpected behavior if the `upgradeContract` is set to the zero address and then immediately set to a valid address within a short timeframe."",
      ""Impact"": ""Minor risk of race condition or unexpected behavior when setting/resetting upgradeContract."",
      ""Location"": ""NameWrapper.sol: `setUpgradeContract` function""
    },
    {
      ""Issue"": ""Missing Input Validation for `duration` Parameter in `registerAndWrapETH2LD` and `renew`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `registerAndWrapETH2LD` and `renew` functions take a `duration` parameter which is passed directly to the `registrar`. It is important that the `NameWrapper` contract validates the `duration` parameter to prevent accidental locking of the names for very long periods of time."",
      ""Impact"": ""Accidental locking of names for very long periods of time."",
      ""Location"": ""NameWrapper.sol: `registerAndWrapETH2LD` and `renew` functions""
    },
    {
      ""Issue"": ""Centralization Risk in `setMetadataService` and `setUpgradeContract` Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setMetadataService` and `setUpgradeContract` functions are `onlyOwner`, meaning only the contract owner can change the metadata service and upgrade contract addresses. This introduces a centralization risk."",
      ""Impact"": ""Compromised metadata service could lead to incorrect or malicious metadata being displayed for wrapped names. A malicious upgrade contract could potentially take control of user names or perform other unauthorized actions. While `setUpgradeContract` does include a check that removes `setApprovalForAll` for the old upgrade contract, if the upgrade contract implements a backdoor prior to being replaced, this will not mitigate the risk."",
      ""Location"": ""Functions `setMetadataService` and `setUpgradeContract`""
    },
    {
      ""Issue"": ""Inconsistent use of `name` vs `label` in regards to the `names` mapping"",
      ""Severity"": ""Low"",
      ""Description"": ""Some functions expect and use a `label` parameter, which is concatenated into the `names` mapping. Other functions expect a `name` to be built up over time and then directly stored into the mapping. This inconsistency may be confusing or lead to unexpected edge cases"",
      ""Impact"": ""The naming inconsistency could lead to confusion. While it is not necessarily a security vulnerability, it makes debugging harder, and increases the chances of a vulnerability due to the complex logic."",
      ""Location"": ""Functions `_addLabel`, `_addLabelAndWrap`, `wrap`, `wrapETH2LD`""
    },
    {
      ""Issue"": ""Lack of access control on name retrieval."",
      ""Severity"": ""Low"",
      ""Description"": ""The `names` mapping is public, which means that anyone can query the name by providing the nodehash. The nodehash can be calculated if you know the parent node and the label, which means the information is publicly available."",
      ""Impact"": ""While the `names` mapping is public, it exposes the cleartext labels, which may present a privacy issue."",
      ""Location"": ""Public mapping `names`""
    },
    {
      ""Issue"": ""Missing Input Validation in `renew` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `renew` function doesn\'t validate that the `expiry` parameter is within a reasonable range *before* calling `_normaliseExpiry`. While `_normaliseExpiry` will clamp the expiry to the registrar expiry, it is possible for the caller to set `expiry` to an arbitrary value and observe the `expires` value returned from the registrar after the renewal."",
      ""Impact"": ""The caller can influence the reported expiry timestamp, potentially confusing users or other contracts that rely on the expiry timestamp."",
      ""Location"": ""Function `renew`""
    },
    {
      ""Issue"": ""Inconsistent handling of expiry normalization in `setSubnodeOwner` and `setSubnodeRecord`"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `setSubnodeOwner` and `setSubnodeRecord` call `_getDataAndNormaliseExpiry` which returns the normalized expiry. However, the return value is discarded and the unnormalized `expiry` parameter is used when calling `_addLabelAndWrap`."",
      ""Impact"": ""Potential inconsistency in expiry value, leading to unexpected behavior with subdomain management."",
      ""Location"": ""Functions `setSubnodeOwner` and `setSubnodeRecord`""
    },
    {
      ""Issue"": ""Missing Zero Address Checks in Constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor does not perform zero address checks on the input parameters `_ens`, `_registrar`, and `_metadataService`."",
      ""Impact"": ""Contract may become unusable if initialized with invalid addresses."",
      ""Location"": ""Constructor""
    }
  ],
  ""IssueNumber"": 31,
  ""OutputList"": 24
}",223.36637163162231,4412.0,29.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**

**Report Description**:  
Due to re-entrancy possibility in `NameWrapper._transferAndBurnFuses` (called from `setSubnodeOwner` and `setSubnodeRecord`), it is possible to execute arbitrary code in `onERC1155Received` right after transfer but before new owner and new fuses are set. This allows unwrapping the subdomain, but the owner and fuses will still be set even for the unwrapped domain, creating a fake ERC1155 NameWrapper token for a domain not owned by NameWrapper.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability through ENS Interaction""**.

**Validation**:  
**Correct**. The response identifies the reentrancy risk in functions like `setSubnodeOwner` and `setSubnodeRecord`, which aligns with the issue description. It correctly highlights the potential for state manipulation during external calls, addressing the core concern of creating fake tokens.

---

#### **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**

**Report Description**:  
By design, the child node's expiry can only be extended up to the parent's current one. However, when a parent node tries to `setSubnodeOwner` or `setSubnodeRecord`, the code does not enforce this restriction, allowing the child node's expiry to exceed the parent's expiry. This violates the guarantee policy that users should only need to look at the name itself's fuses and expiry (without traversing the hierarchy) to understand the guarantees.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Expiry Calculation and Uncontrolled Expiry Values""**.

**Validation**:  
**Correct**. The response accurately describes the issue with incorrect expiry calculations and the potential for bypassing expiry restrictions. It covers the risk of child nodes having longer expiries than their parents, which aligns with the issue description.

---

#### **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**

**Report Description**:  
By design, for any subdomain, as long as its `PARENT_CANNOT_CONTROL` fuse is burnt (and does not expire), its parent should not be able to burn its fuses or change its owner. However, this constraint can be bypassed by a parent node maliciously unwrapping itself. If the hacker becomes the ENS owner of the parent node, they can leverage `ENSRegistry::setSubnodeOwner` to re-set themselves as the ENS owner of the subdomain, and re-invoking the `wrap` function can rewrite the fuses and wrapper owner of the given subdomain.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Use of `PARENT_CANNOT_CONTROL` Flag and Inconsistent Fuse Checks""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `PARENT_CANNOT_CONTROL` and inconsistent fuse checks but does not explicitly mention the bypass mechanism through unwrapping the parent node. It misses the critical detail of how the parent node can maliciously regain control.

---

#### **[M-01] `wrapETH2LD` permissioning is over-extended**

**Report Description**:  
Current permissioning for the function `wrapETH2LD` allows `msg.senders` who are not the owner to call it if they are either approved for all on the ERC721 registrar or approved on the wrapper. Allowing users who are approved for the ERC721 registrar makes sense, but extending this to users approved on the wrapper is over-permissive and could lead to unintended consequences.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the over-extended permissioning in `wrapETH2LD`.

---

#### **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry**

**Report Description**:  
There is a general incorrect logic of allowing the burning of only the `PARENT_CANNOT_CONTROL` fuse without burning the `CANNOT_UNWRAP` fuse. If only `PARENT_CANNOT_CONTROL` is burnt, the domain can be unwrapped by its owner and then wrapped again, which clears the `PARENT_CANNOT_CONTROL` fuse, making it possible for the parent to bypass the limitation of parent control before the expiry.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Use of `PARENT_CANNOT_CONTROL` Flag and Inconsistent Fuse Checks""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `PARENT_CANNOT_CONTROL` and inconsistent fuse checks but does not explicitly describe the unwrap-and-wrap bypass mechanism. It misses the critical detail of how the parent can regain control before expiry.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] It is possible to create fake ERC1155 NameWrapper token for subdomain, which is not owned by NameWrapper**
- **[H-02] The expiry of the parent node can be smaller than the one of a child node, violating the guarantee policy**

**Partially Correct Matches**:

- **[H-03] `PARENT_CANNOT_CONTROL` can be bypassed by maliciously unwrapping parent node**
- **[M-07] If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry**

**Missed Issues from Issue Report**:

- **[M-01] `wrapETH2LD` permissioning is over-extended**

--- 

This analysis highlights the coverage, accuracy, and sufficiency of the responses in addressing the issues reported. While most issues are either correctly or partially addressed, the over-extended permissioning in `wrapETH2LD` is entirely missed.","```
1. Potential Reentrancy Vulnerability through ENS Interaction
2. Incorrect Expiry Calculation and Uncontrolled Expiry Values
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives**:
   - ""Potential Reentrancy Vulnerability through ENS Interaction"" appears at rank 8.
   - ""Incorrect Expiry Calculation and Uncontrolled Expiry Values"" appears at rank 4.

2. **Calculate the precision at each rank**:
   - For rank 4: \( P@4 = \frac{1}{4} = 0.25 \)
   - For rank 8: \( P@8 = \frac{2}{8} = 0.25 \)

3. **Average the precision values**:
   - \( AP = \frac{0.25 + 0.25}{2} = 0.25 \)

**Average Precision (AP)**: 0.25"
ByteUtil.sol,"pragma solidity ^0.8.4;

library BytesUtils {
    /*
    * @dev Returns the keccak-256 hash of a byte range.
    * @param self The byte string to hash.
    * @param offset The position to start hashing at.
    * @param len The number of bytes to hash.
    * @return The hash of the byte range.
    */
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal.
    * @param self The first bytes to compare.
    * @param other The second bytes to compare.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    /*
    * @dev Returns a positive number if `other` comes lexicographically after
    *      `self`, a negative number if it comes before, or zero if the
    *      contents of the two bytes are equal. Comparison is done per-rune,
    *      on unicode codepoints.
    * @param self The first bytes to compare.
    * @param offset The offset of self.
    * @param len    The length of self.
    * @param other The second bytes to compare.
    * @param otheroffset The offset of the other string.
    * @param otherlen    The length of the other string.
    * @return The result of the comparison.
    */
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                // Mask out irrelevant bytes and check again
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @param len The number of bytes to compare
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    /*
    * @dev Returns true if the two byte ranges are equal with offsets.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @param otherOffset The offset into the second byte range.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    /*
    * @dev Compares a range of 'self' to all of 'other' and returns True iff
    *      they are equal.
    * @param self The first byte range to compare.
    * @param offset The offset into the first byte range.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    /*
    * @dev Returns true if the two byte ranges are equal.
    * @param self The first byte range to compare.
    * @param other The second byte range to compare.
    * @return True if the byte ranges are equal, false otherwise.
    */
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    /*
    * @dev Returns the 8-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 8 bits of the string, interpreted as an integer.
    */
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    /*
    * @dev Returns the 16-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 16 bits of the string, interpreted as an integer.
    */
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    /*
    * @dev Returns the 32-bit number at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bits of the string, interpreted as an integer.
    */
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    /*
    * @dev Returns the 32 byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes
    * @return The specified 32 bytes of the string.
    */
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    /*
    * @dev Returns the n byte value at the specified index of self.
    * @param self The byte string.
    * @param idx The index into the bytes.
    * @param len The number of bytes.
    * @return The specified 32 bytes of the string.
    */
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        // Copy word-length chunks while possible
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        // Copy remaining bytes
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    /*
    * @dev Copies a substring into a new byte string.
    * @param self The byte string to copy from.
    * @param offset The offset to start copying at.
    * @param len The number of bytes to copy.
    */
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    // Maps characters from 0x30 to 0x7A to their base32 values.
    // 0xFF represents invalid characters in that range.
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    /**
     * @dev Decodes unpadded base32 data of up to one word in length.
     * @param self The data to decode.
     * @param off Offset into the string to start at.
     * @param len Number of characters to decode.
     * @return The decoded data, left aligned.
     */
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            // Multiple of 8 characters, no padding
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            // Two extra characters - 1 byte
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            // Four extra characters - 2 bytes
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            // Five extra characters - 3 bytes
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            // Seven extra characters - 4 bytes
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    /**
     * @dev Finds the first occurrence of the byte `needle` in `self`.
     * @param self The string to search
     * @param off The offset to start searching at 
     * @param len The number of bytes to search
     * @param needle The byte to search for
     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.
     */
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",2905,320,"[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters
Due to incorrect condition in `ByteUtil.compare` function, irrelevant characters are masked out only for strings shorter than 32 characters. However, they must be masked out for strings of all lengths in the last pass of the loop (when remainder of the string is 32 characters or less). This leads to incorrect comparision of strings longer than 32 characters where len or otherlen is smaller than string length (characters beyond provided length are still accounted for in the comparision in this case while they should be ignored).
  [M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths
Compare will return false answer without reverting when the inputs are not valid.
  [M-08] Wrong Equals Logic
The function `equals` with offset might return true when equals without offset returns false.
",3,,"pragma solidity ^0.8.4;

library BytesUtils {
    
    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {
        require(offset + len <= self.length);
        assembly {
            ret := keccak256(add(add(self, 32), offset), len)
        }
    }


    
    function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

    
    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

    
    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

    
    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }

    
    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {
        return uint8(self[idx]);
    }

    
    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {
        require(idx + 2 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)
        }
    }

    
    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {
        require(idx + 4 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)
        }
    }

    
    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {
        require(idx + 32 <= self.length);
        assembly {
            ret := mload(add(add(self, 32), idx))
        }
    }

    
    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {
        require(idx + 20 <= self.length);
        assembly {
            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)
        }
    }

    
    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {
        require(len <= 32);
        require(idx + len <= self.length);
        assembly {
            let mask := not(sub(exp(256, sub(32, len)), 1))
            ret := and(mload(add(add(self, 32), idx)),  mask)
        }
    }

    function memcpy(uint dest, uint src, uint len) private pure {
        
        for (; len >= 32; len -= 32) {
            assembly {
                mstore(dest, mload(src))
            }
            dest += 32;
            src += 32;
        }

        
        unchecked {
            uint mask = (256 ** (32 - len)) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask))
                let destpart := and(mload(dest), mask)
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

    
    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {
        require(offset + len <= self.length);

        bytes memory ret = new bytes(len);
        uint dest;
        uint src;

        assembly {
            dest := add(ret, 32)
            src := add(add(self, 32), offset)
        }
        memcpy(dest, src, len);

        return ret;
    }

    
    
    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';

    
    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {
        require(len <= 52);

        uint ret = 0;
        uint8 decoded;
        for(uint i = 0; i < len; i++) {
            bytes1 char = self[off + i];
            require(char >= 0x30 && char <= 0x7A);
            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);
            require(decoded <= 0x20);
            if(i == len - 1) {
                break;
            }
            ret = (ret << 5) | decoded;
        }

        uint bitlen = len * 5;
        if(len % 8 == 0) {
            
            ret = (ret << 5) | decoded;
        } else if(len % 8 == 2) {
            
            ret = (ret << 3) | (decoded >> 2);
            bitlen -= 2;
        } else if(len % 8 == 4) {
            
            ret = (ret << 1) | (decoded >> 4);
            bitlen -= 4;
        } else if(len % 8 == 5) {
            
            ret = (ret << 4) | (decoded >> 1);
            bitlen -= 1;
        } else if(len % 8 == 7) {
            
            ret = (ret << 2) | (decoded >> 3);
            bitlen -= 3;
        } else {
            revert();
        }

        return bytes32(ret << (256 - bitlen));
    }

    
    function find(bytes memory self, uint256 off, uint256 len, bytes1 needle) internal pure returns(uint256) {
        for(uint256 idx = off; idx < off + len; idx++) {
            if(self[idx] == needle) {
                return idx;
            }
        }
        return type(uint256).max;
    }
}",1636,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review all assembly code for potential gas inefficiencies. Evaluate if Solidity code could achieve similar results with comparable gas costs."",
        ""Analyze the frequency of use of each function in the library.  Functions used infrequently might be better implemented directly where needed to avoid the cost of library calls."",
        ""Examine the `equals` functions. Determine if using `keccak256` is always the most gas-efficient approach for all potential bytes array sizes. Compare the gas cost with a direct byte-by-byte comparison, especially for small arrays."",
        ""Evaluate the use of `unchecked` blocks in `memcpy` and other functions. Verify the conditions under which overflow/underflow are impossible and confirm that these conditions always hold during execution."",
        ""Consider using calldata instead of memory for immutable data passed as arguments to internal functions, where appropriate.""
      ]
    },
    {
      ""Area"": ""Potential Integer Overflow/Underflow"",
      ""Tasks"": [
        ""Although the compiler version is >= 0.8.0 and performs implicit checks, explicitly audit all arithmetic operations within assembly blocks and unchecked blocks, particularly in functions such as `memcpy` and `base32HexDecodeWord`, to guarantee the absence of overflow/underflow. Focus on the `len -= 32` loop condition in `memcpy` and ensure `len` cannot become negative."",
        ""Verify the validity of using `type(uint256).max` and other type-related maximum/minimum values in assembly context, ensuring they align with Solidity's understanding of these types.""
      ]
    },
    {
      ""Area"": ""Memory Corruption Vulnerabilities"",
      ""Tasks"": [
        ""Carefully examine all assembly code that uses pointer arithmetic (`add`, `sub`) and memory access (`mload`, `mstore`). Verify that memory accesses are always within the bounds of the allocated memory. Pay special attention to offsets and lengths used in `keccak`, `compare`, `readUint*`, `memcpy`, and `substring` functions."",
        ""In the `memcpy` function, ensure `dest` and `src` pointers are valid and point to memory regions owned by the contract/caller. Verify that `len` does not exceed available memory at `src` or `dest`."",
        ""In the `substring` function, verify that the size of allocated memory `bytes memory ret = new bytes(len)` is sufficient and that the `memcpy` operation does not write beyond the allocated memory bounds.""
      ]
    },
    {
      ""Area"": ""Logic Errors in `compare` Function"",
      ""Tasks"": [
        ""Thoroughly review the masking logic in the `compare` function, especially when `shortest > 32`. Confirm that the mask correctly isolates the bytes to be compared in the final partial word. Construct test cases with byte arrays of varying lengths, including lengths that are multiples of 32, and lengths that leave a remainder when divided by 32. Verify the function returns the correct result in all cases."",
        ""Specifically, create test cases where `shortest` is slightly larger than a multiple of 32 (e.g., 33, 65) and confirm the masking isolates only the relevant bytes for comparison."",
        ""Investigate the performance impact of using a full 32-byte load and subsequent masking versus a more targeted byte-by-byte comparison for the final partial word.""
      ]
    },
    {
      ""Area"": ""Logic Errors in `readUint16` and `readUint32` Functions"",
      ""Tasks"": [
        ""Verify that the memory offsets in `readUint16` and `readUint32` are correct. The standard `bytes memory` offset is 32 bytes, so the assembly code should use `add(add(self, 32), idx)`. Create test cases that read `uint16` and `uint32` values from various positions within a bytes array and confirm that the correct values are returned."",
        ""Analyze if the masking operations (`and(..., 0xFFFF)` and `and(..., 0xFFFFFFFF)`) are sufficient to retrieve the correct values given that `mload` reads 32 bytes at a time. Consider whether right-shifting is required to align the result correctly."",
        ""Test reading `uint16` and `uint32` values that are located at the beginning, middle, and end of the bytes array. Pay close attention to edge cases where the `uint16` or `uint32` spans across multiple 32-byte words in memory.""
      ]
    },
    {
      ""Area"": ""Base32Hex Decoding Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the character validation logic in `base32HexDecodeWord`. Confirm that the `require(char >= 0x30 && char <= 0x7A)` and `require(decoded <= 0x20)` checks are sufficient to prevent invalid characters from being processed. Construct test cases with various invalid characters and ensure that the function reverts as expected."",
        ""Verify the bit manipulation logic for handling padding and trailing bits in `base32HexDecodeWord`. Construct test cases with different input lengths and ensure that the decoded values are correct in all cases."",
        ""Ensure that the length check `require(len <= 52)` is appropriate given the intended use cases of the function. Evaluate the maximum allowable input length based on the Base32Hex encoding scheme and adjust the require statement if necessary."",
        ""Test with boundary conditions such as empty strings and strings with maximum allowed length. ""
      ]
    },
    {
      ""Area"": ""Input Validation and Boundary Conditions"",
      ""Tasks"": [
        ""Review all `require` statements to ensure that input parameters (offsets, lengths) are properly validated. Confirm that offsets and lengths are always within the bounds of the bytes array."",
        ""Create test cases that exercise boundary conditions, such as zero-length bytes arrays, offsets equal to the length of the bytes array, and lengths that extend beyond the end of the bytes array. Verify that the functions handle these cases correctly and do not cause unexpected behavior."",
        ""Specifically, test cases with `offset + len > self.length` in functions like `keccak`, `compare`, `equals`, `readUint*`, `substring` and `find`.""
      ]
    },
    {
      ""Area"": ""Unused Return Values"",
      ""Tasks"": [
        ""Identify any instances where return values from functions in `BytesUtils` are not used by the caller. If a return value is not used, consider whether the function can be modified to avoid returning the value, potentially saving gas.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines a Solidity library `BytesUtils` containing various internal pure functions for manipulating `bytes memory` arrays. It heavily utilizes assembly for gas optimization in operations like hashing, comparison, reading numerical types, memory copying, and substring extraction. It also includes Base32 Hex decoding and a byte search function. Several potential issues were identified, particularly in the `compare` function's masking logic for partial words and in the memory address calculation and bit manipulation within `readUint16` and `readUint32`."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BytesUtils (Library)"",
    ""Purpose"": ""To provide a collection of gas-optimized utility functions for common operations on dynamic bytes arrays (`bytes memory`) within Solidity smart contracts."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [],
      ""Imports"": []
    },
    ""StateVariables"": [
      {
        ""Name"": ""base32HexTable"",
        ""Type"": ""bytes constant"",
        ""Purpose"": ""Lookup table used for Base32 Hex decoding.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""keccak"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Computes the keccak256 hash of a specified slice within a bytes array."",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""uint len""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""compare (2 params)"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Compares two bytes arrays lexicographically."",
        ""Parameters"": [""bytes memory self"", ""bytes memory other""],
        ""Returns"": [""int""]
      },
      {
        ""Name"": ""compare (6 params)"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Compares specified slices of two bytes arrays lexicographically, word by word using assembly. Potential bug identified in masking logic for the last partial word."",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""uint len"", ""bytes memory other"", ""uint otheroffset"", ""uint otherlen""],
        ""Returns"": [""int""]
      },
      {
        ""Name"": ""equals (5 params)"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if two specified slices of bytes arrays are equal by comparing their keccak256 hashes."",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""bytes memory other"", ""uint otherOffset"", ""uint len""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""equals (4 params)"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if two slices (from specified offsets to the end) of bytes arrays are equal by comparing their keccak256 hashes."",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""bytes memory other"", ""uint otherOffset""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""equals (3 params)"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if a slice of the first bytes array (starting at offset, length matching the second array) is equal to the second bytes array by comparing keccak256 hashes."",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""bytes memory other""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""equals (2 params)"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if two bytes arrays are equal by comparing lengths and then their keccak256 hashes."",
        ""Parameters"": [""bytes memory self"", ""bytes memory other""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""readUint8"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint8 (byte) from a specified index in a bytes array."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint8 ret""]
      },
      {
        ""Name"": ""readUint16"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint16 from a specified index in a bytes array using assembly. Potential bug identified in memory addressing and/or bit manipulation."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint16 ret""]
      },
      {
        ""Name"": ""readUint32"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a uint32 from a specified index in a bytes array using assembly. Potential bug identified in memory addressing and/or bit manipulation."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""uint32 ret""]
      },
      {
        ""Name"": ""readBytes32"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a bytes32 from a specified index in a bytes array using assembly."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""readBytes20"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads a bytes20 (e.g., address) from a specified index in a bytes array using assembly, returning it left-aligned in a bytes32."",
        ""Parameters"": [""bytes memory self"", ""uint idx""],
        ""Returns"": [""bytes20 ret""]
      },
      {
        ""Name"": ""readBytesN"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Reads 'len' bytes (up to 32) from a specified index, returning them left-aligned in a bytes32."",
        ""Parameters"": [""bytes memory self"", ""uint idx"", ""uint len""],
        ""Returns"": [""bytes32 ret""]
      },
      {
        ""Name"": ""memcpy"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal helper function to copy memory efficiently using assembly."",
        ""Parameters"": [""uint dest"", ""uint src"", ""uint len""],
        ""Returns"": []
      },
      {
        ""Name"": ""substring"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Extracts a slice (substring) from a bytes array into a new bytes array."",
        ""Parameters"": [""bytes memory self"", ""uint offset"", ""uint len""],
        ""Returns"": [""bytes memory""]
      },
      {
        ""Name"": ""base32HexDecodeWord"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Decodes a Base32 Hex encoded string slice (up to 52 chars) into a left-aligned bytes32 value."",
        ""Parameters"": [""bytes memory self"", ""uint off"", ""uint len""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""find"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Finds the index of the first occurrence of a single byte (needle) within a specified slice of a bytes array."",
        ""Parameters"": [""bytes memory self"", ""uint256 off"", ""uint256 len"", ""bytes1 needle""],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [],
  ""SpecialMechanisms"": [
    ""Extensive use of inline assembly (`assembly {}`) for optimized memory access (`mload`, `mstore`, pointer arithmetic), hashing (`keccak256`), and bitwise operations."",
    ""Hashing for Equality: The `equals` functions use `keccak256` comparison as a gas-saving proxy for byte-wise equality checking."",
    ""Bit Manipulation: Heavy use of bitwise operations (AND, OR, NOT, shifts) for masking and data extraction/combination, especially in read/copy/compare functions."",
    ""Base32Hex Decoding: Implements RFC 4648 Base32 Hex decoding logic, including handling of padding/trailing bits.""
  ],
  ""Questions"": [
    ""Potential Bug in `compare`: The masking logic within the `compare` function (`if (shortest > 32) { mask = type(uint256).max; }`) appears incorrect when comparing the final partial word of slices longer than 32 bytes. It seems to compare the full 32 bytes instead of masking to the actual remaining length (`shortest - idx`), potentially leading to incorrect comparison results."",
    ""Potential Bugs in `readUint16`/`readUint32`: The assembly code uses memory offsets like `add(add(self, 2), idx)` and `add(add(self, 4), idx)`. Standard practice for accessing `bytes memory` data is `add(add(self, 32), idx)`. Additionally, the masking/shifting logic (`and(..., 0xFFFF)` or `and(..., 0xFFFFFFFF)`) seems incorrect for reading the *first* N bytes from the specified index, as `mload` typically returns data left-aligned in the 32-byte word. Right-shifting might be required instead."",
    ""Hashing vs Equality in `equals`: Confirm that using keccak256 hashing for equality checks in the `equals` functions is an intended optimization and the negligible risk of collision is acceptable for the library's use cases."",
    ""Base32Hex Character Validation: The initial character check `require(char >= 0x30 && char <= 0x7A)` seems broader than the Base32Hex alphabet. Is this intentional, relying solely on the subsequent table lookup and `require(decoded <= 0x20)` check for validation?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unchecked Subtraction in `memcpy` leads to out of bounds memory access"",
      ""Severity"": ""High"",
      ""Description"": ""The `memcpy` function uses `unchecked` arithmetic when handling remaining bytes after processing 32-byte chunks. If `len` is 0, `32 - len` will be 32, and `256 ** 32` will cause an overflow, leading to an incorrect mask value and potential for reading from and writing to arbitrary memory locations."",
      ""Impact"": ""Potential for reading from and writing to arbitrary memory locations, leading to contract corruption, denial of service, or potentially exploitable vulnerabilities."",
      ""Location"": ""BytesUtils.memcpy, lines 151-157 and BytesUtils.sol:144-152""
    },
    {
      ""Issue"": ""Potential Revert on division by zero in base32HexDecodeWord"",
      ""Severity"": ""High"",
      ""Description"": ""The `base32HexDecodeWord` function may revert depending on length. The code performs right bit shifts such as `decoded >> 2` and so on, depending on whether `len % 8 == 2, 4, 5, or 7`. It should perform a check before performing that type of operation, or the decode may revert."",
      ""Impact"": ""The decode may revert."",
      ""Location"": ""BytesUtils.sol:209-221""
    },
    {
      ""Issue"": ""Unchecked Arithmetic in `memcpy` Function (Solidity < 0.8.0)"",
      ""Severity"": ""High"",
      ""Description"": ""The `memcpy` function contains an `unchecked` block where `uint mask = (256 ** (32 - len)) - 1;` could cause incorrect behavior if len = 0 or len > 32, leading to incorrect data or memory corruption. While this snippet requires `len >= 32`, the logic could be copy-pasted and misused elsewhere with incorrect bounds checks. Even if the code itself functions correctly in isolation, the use of `unchecked` represents a potential maintenance risk if the code is modified or refactored in the future."",
      ""Impact"": ""Memory corruption, unexpected program behavior, and potential security vulnerabilities."",
      ""Location"": ""BytesUtils.sol: `memcpy` function, specifically the `unchecked` block and `mask` calculation.""
    },
    {
      ""Issue"": ""Missing Input Validation and Out-of-Bounds Access in `base32HexDecodeWord`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `base32HexDecodeWord` function has incomplete input validation. It partially checks if the character is a valid base32hex character but doesn't fully validate. Specifically, it doesn't prevent lowercase, and characters outside the valid base32 range. This can lead to reverts and unexpected behavior, especially if `base32HexTable` is modified or length is not a multiple of 8. Integer overflows may occur if `len` is sufficiently large. Additionally, if `off + len` exceeds the length of `self`, it leads to an out-of-bounds read."",
      ""Impact"": ""An attacker could craft a `bytes` input containing characters outside the valid base32hex range, which could lead to unexpected behavior, incorrect decoded values, or denial of service. Incorrectly encoded bytes could lead to unexpected program behavior, potentially causing critical errors or incorrect calculations that can be exploited. Can also cause out-of-bounds read."",
      ""Location"": ""BytesUtils.sol:182-225, BytesUtils.base32HexDecodeWord, line 177 and BytesUtils.sol:174""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `memcpy` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `memcpy` function calculates a `mask` using exponentiation: `uint mask = (256 ** (32 - len)) - 1;`. If `len` is close to 32, the value of `(32 - len)` becomes small, possibly 0 or 1, resulting in a zero mask. If `len` is greater than 32, the expression `(32-len)` will cause an underflow, and the value would wrap around to a very large number, potentially leading to incorrect `mask` value. Subsequent bitwise operations with this incorrect mask could lead to data corruption."",
      ""Impact"": ""If the `len` value calculation is incorrect, the `mask` might not be computed correctly which leads to memory corruption. Memory corruption can be exploited. Data corruption during memory copy operations. This could lead to unpredictable behavior, depending on the data being copied and how it is used subsequently."",
      ""Location"": ""BytesUtils.sol:154 and BytesUtils.sol:166-174""
    },
    {
      ""Issue"": ""Insufficient Range Validation in `readBytesN` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `readBytesN` checks if `len <= 32` and `idx + len <= self.length`. However, it doesn't validate if `idx` itself is within the bounds of the `self` bytes array. If `idx` is close to `self.length`, even if `idx + len <= self.length`, the access `mload(add(add(self, 32), idx))` could still result in an out-of-bounds read, as it reads 32 bytes starting from `idx`. It is important to validate the lower range `idx` also. The current vulnerability happens when `self.length >= idx + len` is true but `idx + 32 > self.length`."",
      ""Impact"": ""Out-of-bounds memory access could lead to unpredictable behavior or information leakage. An attacker could potentially craft inputs that read sensitive data."",
      ""Location"": ""BytesUtils.sol:120""
    },
    {
      ""Issue"": ""Use of Assembly Without Thorough Safety Checks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The library makes extensive use of inline assembly, which bypasses Solidity's built-in safety checks. Functions like `keccak`, `readUint16`, etc., read directly from memory using assembly, which can lead to vulnerabilities if indices are not properly validated to ensure they remain within the bounds of the `self` byte array, even though there is require statement present. This is especially critical when dealing with external data or user-supplied inputs, as it might be possible to craft inputs that trigger out-of-bounds reads."",
      ""Impact"": ""Potential for out-of-bounds memory access, data corruption, and unpredictable behavior."",
      ""Location"": ""BytesUtils.sol: functions `keccak`, `readUint16`, `readUint32`, `readBytes32`, `readBytes20`, `readBytesN` and other assembly usage.""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow in `memcpy`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `memcpy` function calculates `mask = (256 ** (32 - len)) - 1` within an unchecked block. If `len` is 0, `32 - len` will be 32, and `256 ** 32` will cause an overflow, potentially wrapping around and leading to an incorrect mask value. This incorrect mask can then lead to memory corruption as arbitrary data could be copied."",
      ""Impact"": ""Potential memory corruption, leading to unpredictable behavior or denial of service. If an attacker can control the `len` parameter to `substring`, they could cause this overflow in memcpy."",
      ""Location"": ""BytesUtils.sol:144-152""
    },
    {
      ""Issue"": ""Incorrect input validation in base32HexDecodeWord"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `base32HexDecodeWord` checks if characters are within the range 0x30 to 0x7A, but this check also includes characters that are not part of the base32hex alphabet. For instance, characters like \':\' (0x3A) fall within this range but are invalid base32hex characters. The check `require(decoded <= 0x20)` is meant to compensate, but it can lead to misleading error reporting. Also, the library constant contains many 0xff values, so if those chars are fed to the function, it will proceed without failing but will not function as expected, it could be possible to exploit this."",
      ""Impact"": ""The validation logic is not strict enough, it might result in unexpected data and could allow attackers to craft invalid inputs. This is crucial because the function directly translates these characters to bits in a bit stream. The resulting `bytes32` might contain incorrect or unexpected data."",
      ""Location"": ""BytesUtils.sol:167, BytesUtils.sol:169""
    },
    {
      ""Issue"": ""Missing Input Validation in `base32HexDecodeWord` for `len`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `base32HexDecodeWord` function contains a `require(len <= 52)`. Although a reasonable constraint, not all values less than 52 are safe from vulnerabilities. The logic within this function is based on `len % 8`, so any number that isn't covered within the other if statements that handle the `% 8` cases could result in an incorrect result. For example, if `len` were equal to 1, all conditional statements that handle `len % 8` would be skipped causing a potential miscalculation"",
      ""Impact"": ""Incorrect decoding of base32Hex encoded data. This can lead to unexpected program behavior or security vulnerabilities if the decoded data is used for access control or other critical operations."",
      ""Location"": ""BytesUtils.base32HexDecodeWord""
    },
    {
      ""Issue"": ""Potential Denial of Service in `find` function due to large inputs"",
      ""Severity"": ""Low"",
      ""Description"": ""The `find` function iterates through the input `bytes` array from offset `off` to `off + len`. If `len` is very large, or if `off + len` exceeds the maximum value of `uint256`, this loop could consume a significant amount of gas, potentially leading to a denial-of-service (DoS) attack if a user can control the `off` and `len` parameters. The `find` function has a loop that iterates from `off` to `off + len`. If `off + len` exceeds the length of the `self` byte array, the access `self[idx]` will revert. However, if `off + len` is a large number, the loop will still iterate for a long time before the out-of-bounds access occurs."",
      ""Impact"": ""The `find` function can become unusable with very large input sizes, causing a denial of service. Denail of Service (DoS). Unintended loop execution if `off + len` overflows."",
      ""Location"": ""BytesUtils.sol: `find` function and BytesUtils.sol:227""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `memcpy` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `memcpy` function\'s unchecked block calculates `mask = (256 ** (32 - len)) - 1`. If `len` is equal to 32, then `32 - len` will be zero, so `256 ** 0` will equal 1. Then, `1 - 1` will equal zero.  The issue is, 256 ** (32-len) could cause an overflow. However, since len can only decrease in 32 sized chunks, len cannot be less than zero, or greater than 32. Therefore this shouldn\'t actually be exploitable."",
      ""Impact"": ""Incorrect memory manipulation if the calculation of the mask overflows, leading to potentially corrupted data. Although, this case is nearly impossible given the preceeding condition."",
      ""Location"": ""BytesUtils.sol:156-163""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `memcpy`\'s `unchecked` block"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `memcpy` function, within the `unchecked` block, the expression `(256 ** (32 - len)) - 1` could potentially lead to an integer overflow if `len` is close to 32. While `len` is derived from the initial function parameters and the loop condition, a large initial value of len might cause `32-len` to be small enough to cause the exponentiation to return zero.  This would make `mask` to be `0-1` which equals `type(uint).max`.  If `len` is zero at the last execution of the loop, this also leads to a similar condition. This could lead to unexpected behavior when masking the `srcpart` and `destpart` values."",
      ""Impact"": ""The overflow could cause `mask` to have an incorrect value, leading to incorrect data being copied during the memory copy operation. The function could overwrite unexpected memory."",
      ""Location"": ""BytesUtils.sol:158-164""
    },
    {
      ""Issue"": ""Incomplete Bounds Checking in `find` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `find` function iterates from `off` to `off + len`. While it's intended to search within a defined range, there's no explicit check to ensure that `off + len` doesn't exceed the total length of the `self` bytes array. The loop condition `idx < off + len` will cause the program to read past the boundary of the byte array `self` if `off + len > self.length`. This causes the VM to revert."",
      ""Impact"": ""Out-of-bounds read, which leads to Revert."",
      ""Location"": ""BytesUtils.sol:220-225""
    },
    {
      ""Issue"": ""Potential Denial of Service in `compare` function due to unbounded loop"",
      ""Severity"": ""Low"",
      ""Description"": ""The `compare` function iterates up to `shortest` bytes. If the input `bytes` arrays are extremely long, this loop could consume a significant amount of gas, potentially leading to a denial-of-service (DoS) if the gas cost exceeds the block limit. Although gas costs per iteration are low, the accumulation for very long inputs can be substantial. Furthermore, the logic branches for when `shortest` is greater than 32 or not doesn't have a clear explanation."",
      ""Impact"": ""Denial-of-service due to high gas consumption when comparing extremely long byte arrays."",
      ""Location"": ""BytesUtils.compare, lines 31-55""
    },
    {
      ""Issue"": ""Lack of boundary checks in `find` function can cause gas exhaustion"",
      ""Severity"": ""Low"",
      ""Description"": ""The `find` function has a loop that iterates from `off` to `off + len`. If `off + len` exceeds the length of the `self` byte array, the access `self[idx]` will revert. However, if `off + len` is a large number, the loop will still iterate for a long time before the out-of-bounds access occurs. This can consume a significant amount of gas, especially if the `needle` is not found within the bounds of the byte array."",
      ""Impact"": ""Potential gas exhaustion due to unnecessary loop iterations when searching for a `needle` in a `bytes` array with large `off` and `len` values. This can effectively lead to DoS attacks."",
      ""Location"": ""BytesUtils.find, line 232""
    },
    {
      ""Issue"": ""Unsafe Type Conversion in compare function"",
      ""Severity"": ""Low"",
      ""Description"": ""In the compare function, `int(len) - int(otherlen)` is returned at the end. This could lead to unexpected results if the difference between `len` and `otherlen` is outside the representable range of `int`. Since both `len` and `otherlen` are of type `uint`, their difference could be larger than the maximum value of `int`."",
      ""Impact"": ""Incorrect comparison result due to potential integer overflow/underflow during type conversion. Could cause incorrect behaviour in functions that rely on the `compare` function."",
      ""Location"": ""BytesUtils.sol:40""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `substring` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `substring` function calculates the size of the new `bytes` array using `len`.  While there\'s a require statement `require(offset + len <= self.length)`, preventing out-of-bounds access, there isn\'t an explicit check that `len` itself doesn\'t exceed the maximum `bytes` size. This could technically lead to an extremely large allocation if `len` is close to `type(uint).max`, causing denial of service. However, given the gas limits and the cost of memory allocation, this is unlikely to be practically exploitable."",
      ""Impact"": ""Potential denial-of-service due to excessive memory allocation. Very low probability."",
      ""Location"": ""BytesUtils.substring""
    },
    {
      ""Issue"": ""Unsafe Type Conversion in `readUint8`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `readUint8` performs a simple type conversion from `bytes1` to `uint8`: `return uint8(self[idx]);`. While this seems safe, there is no check that the `idx` is within the bounds of the input `bytes` array.  If `idx` is greater than or equal to `self.length`, the access to `self[idx]` will result in an out-of-bounds read that can result in unpredictable behavior or transaction reversion due to the way solidity handles out-of-bounds access on dynamically sized arrays"",
      ""Impact"": ""Out-of-bounds access leading to unpredictable behavior or transaction reversion."",
      ""Location"": ""BytesUtils.readUint8""
    },
    {
      ""Issue"": ""Potential Out-of-Bounds Read in `find` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `find` function iterates through the byte array `self` from index `off` for a length of `len`, searching for the `needle` byte.  The loop condition is `idx < off + len`, which could potentially lead to an out-of-bounds read if `off + len` exceeds the length of the `self` byte array. While the function returns `type(uint256).max` if the needle is not found, a malicious caller could craft inputs where `off + len > self.length` causing unexpected behaviour or transaction failure if the byte array is modified externally between the function calls"",
      ""Impact"": ""Potential out-of-bounds read and transaction revert"",
      ""Location"": ""BytesUtils.find""
    },
    {
      ""Issue"": ""Missing zero-length check in `substring` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `substring` function creates a new `bytes` array of length `len`. If `len` is zero, the function will allocate a zero-length bytes array. Although valid, adding a check `if (len == 0) return new bytes(0);` at the beginning will optimize for gas."",
      ""Impact"": ""Slight gas inefficiency."",
      ""Location"": ""BytesUtils.sol:144-154 and BytesUtils.sol:140""
    },
    {
      ""Issue"": ""Potential ReDoS vulnerability in base32HexDecodeWord due to Missing Validation on input chars"",
      ""Severity"": ""Low"",
      ""Description"": ""The `base32HexDecodeWord` function iterates through input `len` characters and performs bitwise operations to decode base32hex-encoded data. The validation logic (require char >= 0x30 && char <= 0x7A) does not prevent against multiple identical chars in the string. This allows an attacker to generate an input string (specially crafted to exploit the iterative nature of the decoding) with excessive computation requirements. "",
      ""Impact"": ""Denial of Service (DoS) for contracts using `base32HexDecodeWord`, as excessive gas consumption could block legitimate operations. Attackers can create inputs that take an extremely long time to process on the EVM, potentially leading to block gas limit issues if this functionality is called in critical path."",
      ""Location"": ""BytesUtils.sol:164-211""
    },
     {
      ""Issue"": ""Inconsistent handling of bounds checks"",
      ""Severity"": ""Low"",
      ""Description"": ""Some functions perform bounds checks using `require` statements (e.g., `readUint16`, `readUint32`, `readBytes32`, `readBytes20`, `readBytesN`, `substring`), while others, like `readUint8` and `find` do not. This inconsistency could lead to confusion and potential vulnerabilities if developers forget to perform explicit checks when using functions that lack them."",
      ""Impact"": ""Increased risk of out-of-bounds access due to inconsistent API design."",
      ""Location"": ""Multiple functions""
    },
    {
      ""Issue"": ""Magic number in `readBytes20`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `readBytes20` uses a magic number `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000` for masking. This makes the code less readable and maintainable. It would be better to use a named constant or derive the mask programmatically to improve clarity."",
      ""Impact"": ""Reduced code readability and maintainability."",
      ""Location"": ""BytesUtils.readBytes20""
    },
      {
      ""Issue"": ""Mask calculation could be improved in `readBytesN`"",
      ""Severity"": ""Gas Optimization"",
      ""Description"": ""The mask calculation in `readBytesN` uses `exp(256, sub(32, len))`. The `exp` operation is generally more expensive than bitwise operations. For better gas efficiency, consider calculating the mask directly using bitwise shifts and subtractions."",
      ""Impact"": ""Increased gas consumption.  Using bitwise operations can reduce gas costs."",
      ""Location"": ""BytesUtils.sol:114""
    },
    {
      ""Issue"": ""Unnecessary Complexity and Potential Gas Waste in `base32HexDecodeWord`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `base32HexDecodeWord` function has complex conditional logic depending on `len % 8`. While the function likely aims to optimize bitwise operations, the resulting complexity might increase gas costs due to more complex branching and instructions. Furthermore, the revert in else block `revert()` is not informative."",
      ""Impact"": ""Slightly increased gas costs during execution. Unnecessary branching makes the code harder to read and debug."",
      ""Location"": ""BytesUtils.sol:180-213""
    },
    {
      ""Issue"": ""Unused constant base32HexTable values"",
      ""Severity"": ""Info"",
      ""Description"": ""Some values in `base32HexTable` aren\'t used by the function because the allowed input values for chars are `0x30 <= char <= 0x7A` after subtracting 0x30 this results in `0 <= index <= 0x4a`. So the values for index `10-15` and `40-255` are never used."",
      ""Impact"": ""Wasted space in the constant variable"",
      ""Location"": ""BytesUtils.sol:174""
    },
        {
      ""Issue"": ""No Overflow/Underflow Checks in Assembly blocks"",
      ""Severity"": ""Informational"",
      ""Description"": ""The code uses inline assembly blocks, which do not benefit from Solidity\'s built-in overflow/underflow checks. Operations like `add`, `sub`, and `mul` within the assembly blocks could potentially lead to unexpected behavior if overflows or underflows occur.  While the surrounding Solidity code might have checks, the assembly code bypasses them."",
      ""Impact"": ""Potential for incorrect calculations due to unchecked arithmetic operations. This can lead to unexpected program behavior or security vulnerabilities."",
      ""Location"": ""Multiple functions using assembly, including `keccak`, `compare`, `readUint16`, `readUint32`, `readBytes32`, `readBytesN`, `memcpy`""
    },
    {
      ""Issue"": ""Unnecessary `require` statement in equals functions"",
      ""Severity"": ""Info"",
      ""Description"": ""In the `equals` functions, the code performs checks like `self.length >= offset + other.length` before calling another `equals` function with specific parameters. However, the called `equals` function already contains `require` statements that perform similar or identical checks. This redundancy increases gas consumption without adding significant security."",
      ""Impact"": ""Increased gas costs. The additional require statements are redundant and consume unnecessary gas."",
      ""Location"": ""BytesUtils.sol:52-60""
    },
    {
      ""Issue"": ""Improper length checking on find."",
      ""Severity"": ""High"",
      ""Description"": ""The `find` function loops through the bytes. If the `needle` is not found, the return is `type(uint256).max`, the maximum value of a 256-bit unsigned integer. If the type is bytes, then the length may not be that long, which would cause a revert. "",
      ""Impact"": ""The loop may revert."",
      ""Location"": ""BytesUtils.sol:229-235""
    }
  ],
  ""IssueNumber"": 41,
  ""OutputList"": 29
}",263.3315598964691,4198.0,32.0,"### **Comparison of Issue Report and Response List**

---

#### **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**

**Report Description**:  
The `ByteUtil.compare` function incorrectly masks irrelevant characters only for strings shorter than 32 characters. For strings longer than 32 characters, the function fails to mask irrelevant characters in the last pass of the loop (when the remainder of the string is 32 characters or less). This leads to incorrect comparisons of strings longer than 32 characters, especially when `len` or `otherlen` is smaller than the string length. Characters beyond the provided length are still accounted for in the comparison, which should be ignored.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The issue is not addressed in the `response_list`. The response list focuses on other vulnerabilities like unchecked arithmetic, out-of-bounds access, and gas inefficiencies but does not cover the specific logic flaw in the `compare` function for strings longer than 32 characters.

---

#### **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**

**Report Description**:  
The `compare` function returns an incorrect result without reverting when the inputs are invalid (e.g., `offset` and `len` exceed the bytes length). This behavior could lead to incorrect comparisons and potential security vulnerabilities if the function is used in critical operations.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The `response_list` does not address this issue. While it covers out-of-bounds access and gas inefficiencies in other functions, it does not mention the lack of input validation in the `compare` function.

---

#### **[M-08] Wrong Equals Logic**

**Report Description**:  
The `equals` function with an offset might return `true` when the `equals` function without an offset returns `false`. This inconsistency in logic could lead to incorrect equality checks, potentially causing security vulnerabilities if the function is used for access control or other critical operations.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The `response_list` does not address this issue. It focuses on other vulnerabilities like unchecked arithmetic, out-of-bounds access, and gas inefficiencies but does not cover the logic flaw in the `equals` function.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-04] BytesUtil.compare returns wrong result on some strings longer than 32 characters**  
- **[M-06] BytesUtils: compare will not revert when the `offset` and `len` exceeds the bytes lengths**  
- **[M-08] Wrong Equals Logic**

---

### **Conclusion**  
The `response_list` does not address any of the issues in the `issue` report. The issues in the report focus on logical flaws and incorrect behavior in the `compare` and `equals` functions, while the `response_list` primarily covers vulnerabilities related to unchecked arithmetic, out-of-bounds access, and gas inefficiencies. There is a significant gap in the coverage of logical flaws and input validation issues in the `response_list`.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is zero, and the average of these values is also zero."
