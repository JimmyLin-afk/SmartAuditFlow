nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
LongShort.sol,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/ITokenFactory.sol"";
import ""./interfaces/ISyntheticToken.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IYieldManager.sol"";
import ""./interfaces/IOracleManager.sol"";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, ""only admin"");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], ""market doesn't exist"");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Up "", syntheticName)),
      string(abi.encodePacked(""fu"", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Down "", syntheticName)),
      string(abi.encodePacked(""fd"", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      ""Insufficient market seed""
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], ""already initialized"");
    require(marketIndex <= latestMarket, ""index too high"");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - ""Pending"" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - ""Confirmed"" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - ""Settled"" - there is no more computation left for the user.
        - ""Non-existant"" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}

",13680,1243,"[H-01] copy paste error in _batchConfirmOutstandingPendingActions`
The function `_batchConfirmOutstandingPendingActions` of LongShort.sol processes the variable batched_amountSyntheticToken_toShiftAwayFrom_marketSide, and sets it to 0 after processing. However, probably due to a copy/paste error, in the second instance, where batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed, the wrong version is set to 0: batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0
This means the next time the batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.
  [M-01] latestMarket used where marketIndex should have been used
 The functions `initializeMarket` and `_seedMarketInitially` use the variable latestMarket. If these functions would be called seperately from createNewSyntheticMarket, then latestMarket would have the same value for each call of initializeMarket and _seedMarketInitially
This would mean that the latestMarket is initialized multiple times and the previous market(s) are not initialized properly. Note: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.
Note: the functions can only be called by the admin, so if createNewSyntheticMarket and initializeMarket are called in combination, then it would not lead to problems, but in future release of the software the calls to createNewSyntheticMarket and initializeMarket might get separated.  [M-06] Prevent markets getting stuck when prices don't move
 Suppose there is a synthetic token where the price stays constant, for example:
synthetic DAI (with a payment token of DAI the price will not move)
binary option token (for example tracking the USA elections; after the election results there will be no more price movements)
In that case assetPriceHasChanged will never be true (again) and marketUpdateIndex[marketIndex] will never increase. This means the _executeOutstandingNextPrice* functions will never be executed, which means the market effectively will be stuck.
 LongShort.sol L669
function `_updateSystemStateInternal`(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {

",3,,"pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/ITokenFactory.sol"";
import ""./interfaces/ISyntheticToken.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IYieldManager.sol"";
import ""./interfaces/IOracleManager.sol"";









contract LongShort is ILongShort, Initializable {
  

  
  
  
  
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  
  
  uint256[45] private __constantsGap;

  
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, ""only admin"");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], ""market doesn't exist"");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  

  
  
  
  
  
  
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  

  
  
  
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  
  
  
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  
  
  
  
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    
    
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  

  
  
  
  
  
  
  
  
  
  
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Up "", syntheticName)),
      string(abi.encodePacked(""fu"", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Down "", syntheticName)),
      string(abi.encodePacked(""fd"", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  
  
  
  
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      
      initialMarketSeedForEachMarketSide >= 1e18,
      ""Insufficient market seed""
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  
  
  
  
  
  
  
  
  
  
  
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], ""already initialized"");
    require(marketIndex <= latestMarket, ""index too high"");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    
    marketUpdateIndex[marketIndex] = 1;

    
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  

  
  
  
  
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  
  
  
  
  
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  
  
  
  
  
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  
  
  
  
  
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  
  
  
  
  
  
  
  
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    
    
    
    
    
    
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    
    
    
    
    
    
    
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    
    
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  

  
  
  
  
  
  
  
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      
      
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      
      
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  
  
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  
  
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  

  
  
  
  
  
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  

  
  
  
  
  
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  
  
  
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  
  
  
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  

  
  
  
  
  
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  
  
  
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  
  
  
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  

  
  
  
  
  
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  
  
  
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  
  
  
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  

  
  
  
  
  
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  
  
  
  
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  
  
  
  
  
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  
  
  
  
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  
  
  
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  
  
  
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  

  
  
  
  
  
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      
      
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  
  
  
  
  
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}",7793,1,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the `admin` address can call functions protected by the `adminOnly` modifier."",
        ""Confirm that the `initialize` function can only be called once using the OpenZeppelin `initializer` modifier."",
        ""Check if the `adminOnlyModifierLogic` function can be overridden, and if so, analyze the implications."",
        ""Investigate the potential for privilege escalation if the `admin` address is compromised."",
        ""Verify that the `treasury` address can only be changed by the `admin`."",
        ""Assess the impact of changing the `treasury` address on existing yield and market state.""
      ]
    },
    {
      ""Area"": ""Market Initialization and Configuration"",
      ""Tasks"": [
        ""Ensure that markets can only be initialized once via the `initializeMarket` function. Verify the `marketExists` mapping update."",
        ""Validate that the `marketIndex` in `initializeMarket` cannot be greater than `latestMarket` preventing initialization of non-existent markets."",
        ""Review the parameter ranges and constraints for `kInitialMultiplier`, `kPeriod`, `unstakeFee_e18`, `initialMarketSeedForEachMarketSide`, `balanceIncentiveCurve_exponent`, `balanceIncentiveCurve_equilibriumOffset`, and `_marketTreasurySplitGradient_e18` in `initializeMarket` to prevent unintended behavior or exploits."",
        ""Analyze the implications of setting a low `initialMarketSeedForEachMarketSide`. Confirm the require statement catches insufficient values."",
        ""Check that the `PERMANENT_INITIAL_LIQUIDITY_HOLDER` address is a valid burn address or an address with no known private key, preventing access to the initial seed liquidity. Consider implications if this assumption is broken."",
         ""Verify that `createNewSyntheticMarket` correctly assigns the long and short token addresses in the `syntheticTokens` mapping."",
        ""Confirm that `createNewSyntheticMarket` uses the correct arguments when calling the `ITokenFactory.createSyntheticToken` function, including appropriate names, symbols, and the correct `staker` address.""
      ]
    },
    {
      ""Area"": ""Next Price Execution and Settlement"",
      ""Tasks"": [
        ""Analyze the `_updateSystemStateInternal` function to ensure that the price update from the `IOracleManager` is handled correctly and that the updated price is stored in the `assetPrice` mapping."",
        ""Verify that the `marketUpdateIndex` is incremented correctly in `_updateSystemStateInternal` and that this index is used consistently for price snapshots and settlement."",
        ""Examine the `executeOutstandingNextPriceSettlements` modifier and the `_executeOutstandingNextPriceSettlements` function to ensure that pending user actions are settled correctly based on the stored price snapshots."",
        ""Check for potential race conditions or manipulation vulnerabilities in the 'next price' execution model, particularly related to oracle updates and user action submissions."",
        ""Assess the gas costs associated with `executeOutstandingNextPriceSettlementsUserMulti` and consider potential denial-of-service vulnerabilities if a user has pending actions in a large number of markets."",
        ""Verify that the correct synthetic token price is used to calculate the amount of tokens to mint or redeem in `_executeOutstandingNextPriceMints` and `_executeOutstandingNextPriceRedeems`. Double-check the correct retrieval from `syntheticToken_priceSnapshot`."",
        ""Analyze the logic in `_batchConfirmOutstandingPendingActions` to ensure that deposits, redemptions, and shifts are processed correctly and that the resulting changes in market value and token supply are calculated accurately.  Pay specific attention to potential integer overflow/underflow issues."",
        ""Ensure the `_handleTotalPaymentTokenValueChangeForMarketWithYieldManager` handles zero value changes correctly, so that `depositPaymentToken` or `removePaymentTokenFromMarket` is not called with zero, potentially triggering unwanted logic within the Yield Manager.""
      ]
    },
    {
      ""Area"": ""Yield Distribution and Market Rebalancing"",
      ""Tasks"": [
        ""Review the `_claimAndDistributeYieldThenRebalanceMarket` function to ensure that yield is distributed fairly between the treasury and the market, based on the imbalance between long and short sides."",
        ""Assess the potential for manipulation of the market imbalance to influence yield distribution."",
        ""Analyze the impact of the `marketTreasurySplitGradient_e18` parameter on yield distribution and market rebalancing."",
        ""Verify that the rebalancing logic in `_claimAndDistributeYieldThenRebalanceMarket` correctly adjusts the pool values based on asset price changes, paying particular attention to the calculation of `valueChange`."",
        ""Address the division by `oldAssetPrice` and `totalValueLockedInMarket` which may be zero, causing a divide by zero."",
        ""Investigate if `_claimAndDistributeYieldThenRebalanceMarket` can be called with parameters that would result in shortValue becoming negative and underflowing, and ensure this is handled gracefully."",
        ""Verify that the yield split calculation and allocation mechanism via IYieldManager is secure and resistant to manipulation. Understand the assumptions this contract makes on the IYieldManager implementation.""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Thoroughly audit the interfaces (`ITokenFactory`, `IOracleManager`, `IYieldManager`, `ISyntheticToken`, `IERC20`, `IStaker`) to ensure compatibility and prevent unexpected behavior."",
        ""Analyze the potential risks associated with calling external contracts, such as reentrancy vulnerabilities or failures that could disrupt the system."",
        ""Implement checks and safeguards to handle potential errors or reverts from external contract calls."",
        ""Review the trust assumptions made about the external contracts and assess the potential impact if those assumptions are violated."",
        ""Investigate the security and reliability of the oracle mechanism provided by the `IOracleManager` contract."",
        ""Assess the potential for manipulation of the oracle price feed and implement safeguards to mitigate this risk."",
        ""Confirm that all token transfers using `IERC20` are handled securely, including proper allowance management and error handling."",
        ""Verify that the `IYieldManager` contract correctly handles deposits and withdrawals of payment tokens and that yield is distributed fairly."",
        ""Assess the potential risks associated with the `IStaker` contract and ensure that it is resistant to manipulation or exploits."",
        ""Analyze the data flow between this contract and the external contracts to identify potential vulnerabilities or inefficiencies.""
      ]
    },
    {
      ""Area"": ""Integer Overflow/Underflow"",
      ""Tasks"": [
        ""Despite using Solidity 0.8.x, carefully review all arithmetic operations for potential overflow/underflow issues, especially when dealing with large numbers or extreme price swings. Focus on calculations related to token amounts, price changes, and yield distribution."",
        ""Pay close attention to type conversions and ensure that they do not lead to loss of precision or unexpected behavior."",
        ""Use SafeMath libraries or other mitigation techniques to prevent integer overflow/underflow vulnerabilities where necessary.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, such as loops, storage access, and external contract calls."",
        ""Consider using more efficient data structures or algorithms to reduce gas costs."",
        ""Evaluate the potential benefits of using assembly code for critical functions."",
        ""Analyze the gas costs associated with different user actions and ensure that they are reasonable."",
        ""Review the storage variable layout to minimize gas costs associated with storage access (e.g., packing variables)."",
        ""Assess the impact of upgradeability on gas costs and consider potential optimizations to reduce overhead.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `LongShort` serves as the core logic for a synthetic asset trading system. It allows administrators to create markets for specific assets, where users can then mint, redeem, or shift between long and short synthetic tokens pegged to the underlying asset's price. The system employs a 'next price' execution model, batching user actions (deposits, redemptions, shifts) and settling them based on the asset price determined during the subsequent state update. It interacts with external contracts for token creation (TokenFactory), price feeds (OracleManager), yield generation (YieldManager), and potentially staking rewards (Staker). The contract is upgradeable using the OpenZeppelin Initializable pattern."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LongShort"",
    ""Purpose"": ""Manages synthetic long/short token markets, handling minting, redeeming, position shifting, price updates, rebalancing, and yield distribution based on a 'next price' execution model."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ILongShort"",
        ""Initializable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""./interfaces/ITokenFactory.sol"",
        ""./interfaces/ISyntheticToken.sol"",
        ""./interfaces/IStaker.sol"",
        ""./interfaces/ILongShort.sol"",
        ""./interfaces/IYieldManager.sol"",
        ""./interfaces/IOracleManager.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""PERMANENT_INITIAL_LIQUIDITY_HOLDER"",
        ""Type"": ""address constant"",
        ""Purpose"": ""A designated address to hold the initial seed liquidity, effectively locking it.""
      },
      {
        ""Name"": ""admin"",
        ""Type"": ""address"",
        ""Purpose"": ""The administrative address with privileges to manage markets and system parameters.""
      },
      {
        ""Name"": ""treasury"",
        ""Type"": ""address"",
        ""Purpose"": ""The address receiving a portion of the generated yield.""
      },
      {
        ""Name"": ""latestMarket"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Counter for the index of the most recently created market.""
      },
      {
        ""Name"": ""staker"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the Staker contract, likely involved in reward distribution or related mechanics.""
      },
      {
        ""Name"": ""tokenFactory"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the factory contract used to create synthetic tokens.""
      },
      {
        ""Name"": ""marketExists"",
        ""Type"": ""mapping(uint32 => bool)"",
        ""Purpose"": ""Tracks whether a market with a given index has been initialized.""
      },
      {
        ""Name"": ""assetPrice"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Stores the last known asset price for each market.""
      },
      {
        ""Name"": ""marketUpdateIndex"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Tracks the current price/state update index for each market.""
      },
      {
        ""Name"": ""paymentTokens"",
        ""Type"": ""mapping(uint32 => address)"",
        ""Purpose"": ""Stores the address of the payment token (e.g., USDC) used for each market.""
      },
      {
        ""Name"": ""yieldManagers"",
        ""Type"": ""mapping(uint32 => address)"",
        ""Purpose"": ""Stores the address of the YieldManager contract associated with each market.""
      },
      {
        ""Name"": ""oracleManagers"",
        ""Type"": ""mapping(uint32 => address)"",
        ""Purpose"": ""Stores the address of the OracleManager contract providing prices for each market.""
      },
      {
        ""Name"": ""marketTreasurySplitGradient_e18"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Parameter influencing the split of yield between market rebalancing and the treasury, based on market imbalance (scaled by 1e18).""
      },
      {
        ""Name"": ""syntheticTokens"",
        ""Type"": ""mapping(uint32 => mapping(bool => address))"",
        ""Purpose"": ""Stores the addresses of the long (true) and short (false) synthetic tokens for each market.""
      },
      {
        ""Name"": ""marketSideValueInPaymentToken"",
        ""Type"": ""mapping(uint32 => mapping(bool => uint256))"",
        ""Purpose"": ""Tracks the total value (in payment tokens) backing the long (true) and short (false) sides of each market.""
      },
      {
        ""Name"": ""syntheticToken_priceSnapshot"",
        ""Type"": ""mapping(uint32 => mapping(bool => mapping(uint256 => uint256)))"",
        ""Purpose"": ""Stores snapshots of synthetic token prices (long/short) at specific market update indices, used for settling 'next price' actions.""
      },
      {
        ""Name"": ""batched_amountPaymentToken_deposit"",
        ""Type"": ""mapping(uint32 => mapping(bool => uint256))"",
        ""Purpose"": ""Accumulates total payment tokens deposited (for long/short minting) within a single update interval, before settlement.""
      },
      {
        ""Name"": ""batched_amountSyntheticToken_redeem"",
        ""Type"": ""mapping(uint32 => mapping(bool => uint256))"",
        ""Purpose"": ""Accumulates total synthetic tokens submitted for redemption (long/short) within a single update interval, before settlement.""
      },
      {
        ""Name"": ""batched_amountSyntheticToken_toShiftAwayFrom_marketSide"",
        ""Type"": ""mapping(uint32 => mapping(bool => uint256))"",
        ""Purpose"": ""Accumulates total synthetic tokens submitted for shifting *from* a side (long/short) within a single update interval, before settlement.""
      },
      {
        ""Name"": ""userNextPrice_currentUpdateIndex"",
        ""Type"": ""mapping(uint32 => mapping(address => uint256))"",
        ""Purpose"": ""Stores the market update index at which a user's pending actions should be settled.""
      },
      {
        ""Name"": ""userNextPrice_paymentToken_depositAmount"",
        ""Type"": ""mapping(uint32 => mapping(bool => mapping(address => uint256)))"",
        ""Purpose"": ""Tracks individual user deposits (payment tokens for long/short minting) pending settlement.""
      },
      {
        ""Name"": ""userNextPrice_syntheticToken_redeemAmount"",
        ""Type"": ""mapping(uint32 => mapping(bool => mapping(address => uint256)))"",
        ""Purpose"": ""Tracks individual user redemptions (synthetic tokens for long/short) pending settlement.""
      },
      {
        ""Name"": ""userNextPrice_syntheticToken_toShiftAwayFrom_marketSide"",
        ""Type"": ""mapping(uint32 => mapping(bool => mapping(address => uint256)))"",
        ""Purpose"": ""Tracks individual user shifts (synthetic tokens moving *from* long/short) pending settlement.""
      },
      {
        ""Name"": ""__constantsGap"",
        ""Type"": ""uint256[45]"",
        ""Purpose"": ""Storage gap for upgradeability (constants section).""
      },
      {
        ""Name"": ""__globalStateGap"",
        ""Type"": ""uint256[45]"",
        ""Purpose"": ""Storage gap for upgradeability (global state section).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract state upon deployment or upgrade."",
        ""Parameters"": [""_admin"", ""_treasury"", ""_tokenFactory"", ""_staker""],
        ""Returns"": []
      },
      {
        ""Name"": ""adminOnly"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the admin address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""requireMarketExists"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the specified market has been initialized."",
        ""Parameters"": [""marketIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""executeOutstandingNextPriceSettlements"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Settles any pending user actions for the given market before executing the modified function."",
        ""Parameters"": [""user"", ""marketIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateSystemStateMarket"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates the system state (price, rebalancing) for the given market before executing the modified function."",
        ""Parameters"": [""marketIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeAdmin"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the current admin to transfer admin privileges."",
        ""Parameters"": [""_admin""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeTreasury"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the admin to change the treasury address."",
        ""Parameters"": [""_treasury""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateMarketOracle"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the admin to update the OracleManager for a market."",
        ""Parameters"": [""marketIndex"", ""_newOracleManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeMarketTreasurySplitGradient"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the admin to change the yield split parameter for a market."",
        ""Parameters"": [""marketIndex"", ""_marketTreasurySplitGradient_e18""],
        ""Returns"": []
      },
      {
        ""Name"": ""createNewSyntheticMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to create a new synthetic market (long/short tokens, associated contracts)."",
        ""Parameters"": [""syntheticName"", ""syntheticSymbol"", ""_paymentToken"", ""_oracleManager"", ""_yieldManager""],
        ""Returns"": []
      },
      {
        ""Name"": ""initializeMarket"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to initialize and seed a newly created market."",
        ""Parameters"": [""marketIndex"", ""kInitialMultiplier"", ""kPeriod"", ""unstakeFee_e18"", ""initialMarketSeedForEachMarketSide"", ""balanceIncentiveCurve_exponent"", ""balanceIncentiveCurve_equilibriumOffset"", ""_marketTreasurySplitGradient_e18""],
        ""Returns"": []
      },
      {
        ""Name"": ""getAmountSyntheticTokenToMintOnTargetSide"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the amount of target-side synthetic tokens receivable when shifting from the origin side, based on historical prices."",
        ""Parameters"": [""marketIndex"", ""amountSyntheticToken_redeemOnOriginSide"", ""isShiftFromLong"", ""priceSnapshotIndex""],
        ""Returns"": [""amountSyntheticTokensToMintOnTargetSide""]
      },
      {
        ""Name"": ""getUsersConfirmedButNotSettledSynthBalance"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates a user's pending synthetic token balance from deposits and shifts that are confirmed but not yet settled."",
        ""Parameters"": [""user"", ""marketIndex"", ""isLong""],
        ""Returns"": [""confirmedButNotSettledBalance""]
      },
      {
        ""Name"": ""updateSystemState"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Triggers a state update (price fetch, rebalancing, settlement batching) for a single market."",
        ""Parameters"": [""marketIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateSystemStateMulti"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Triggers state updates for multiple markets."",
        ""Parameters"": [""marketIndexes""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintLongNextPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""User function to deposit payment tokens to mint long synthetic tokens at the next price update."",
        ""Parameters"": [""marketIndex"", ""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintShortNextPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""User function to deposit payment tokens to mint short synthetic tokens at the next price update."",
        ""Parameters"": [""marketIndex"", ""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""redeemLongNextPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""User function to submit long synthetic tokens for redemption into payment tokens at the next price update."",
        ""Parameters"": [""marketIndex"", ""tokens_redeem""],
        ""Returns"": []
      },
      {
        ""Name"": ""redeemShortNextPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""User function to submit short synthetic tokens for redemption into payment tokens at the next price update."",
        ""Parameters"": [""marketIndex"", ""tokens_redeem""],
        ""Returns"": []
      },
      {
        ""Name"": ""shiftPositionFromLongNextPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""User function to submit long synthetic tokens to shift into short synthetic tokens at the next price update."",
        ""Parameters"": [""marketIndex"", ""amountSyntheticTokensToShift""],
        ""Returns"": []
      },
      {
        ""Name"": ""shiftPositionFromShortNextPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""User function to submit short synthetic tokens to shift into long synthetic tokens at the next price update."",
        ""Parameters"": [""marketIndex"", ""amountSyntheticTokensToShift""],
        ""Returns"": []
      },
      {
        ""Name"": ""executeOutstandingNextPriceSettlementsUser"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user (or anyone) to trigger the settlement of that user's pending actions for a specific market."",
        ""Parameters"": [""user"", ""marketIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""executeOutstandingNextPriceSettlementsUserMulti"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows settlement of a user's pending actions across multiple markets."",
        ""Parameters"": [""user"", ""marketIndexes""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateSystemStateInternal"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Core logic for updating market state: fetches price, rebalances pools, handles yield, batches pending actions, updates snapshots."",
        ""Parameters"": [""marketIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""_claimAndDistributeYieldThenRebalanceMarket"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles claiming yield from the YieldManager, distributing it, and rebalancing market side values based on price changes."",
        ""Parameters"": [""marketIndex"", ""newAssetPrice"", ""oldAssetPrice""],
        ""Returns"": [""longValue"", ""shortValue""]
      },
      {
        ""Name"": ""_batchConfirmOutstandingPendingActions"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Processes the globally batched deposits, redemptions, and shifts, calculating net changes in market values and synthetic token supplies."",
        ""Parameters"": [""marketIndex"", ""syntheticTokenPrice_inPaymentTokens_long"", ""syntheticTokenPrice_inPaymentTokens_short""],
        ""Returns"": [""long_changeInMarketValue_inPaymentToken"", ""short_changeInMarketValue_inPaymentToken""]
      },
      {
        ""Name"": ""_executeOutstandingNextPriceSettlements"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Core logic for settling an individual user's pending mints, redeems, and shifts based on stored snapshot prices."",
        ""Parameters"": [""user"", ""marketIndex""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ITokenFactory: Called via `tokenFactory` address to create new `ISyntheticToken` instances."",
    ""IOracleManager: Called via `oracleManagers[marketIndex]` addresses to fetch/update asset prices."",
    ""IYieldManager: Called via `yieldManagers[marketIndex]` addresses to deposit/withdraw payment tokens and distribute yield."",
    ""ISyntheticToken: Interacts with long/short token contracts (stored in `syntheticTokens`) for minting, burning, transfers, and getting total supply."",
    ""IERC20 (Payment Token): Interacts with payment token contracts (stored in `paymentTokens`) for `transferFrom` during user deposits."",
    ""IStaker: Called via `staker` address to initialize staking parameters for new markets and push price updates potentially used for staking calculations.""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract: Uses OpenZeppelin `Initializable` pattern and includes storage gaps (`__*Gap`) for managing storage layout across upgrades."",
    ""Next Price Execution: User actions (mint, redeem, shift) are queued and executed based on prices determined in a subsequent block/state update, mitigating front-running risks related to oracle updates."",
    ""Batched Processing: Actions within one update interval are batched globally (`batched_*` variables) before being processed during the `_updateSystemStateInternal` call."",
    ""Individual Settlement: User actions are tracked individually (`userNextPrice_*` variables) and settled based on the specific price snapshot corresponding to when their action was queued."",
    ""Market Rebalancing: Pool values (`marketSideValueInPaymentToken`) are adjusted based on asset price changes and yield injection, using the lesser-valued side (`underbalancedSideValue`) as the basis for price change impact."",
    ""Dynamic Yield Split: Yield generated externally (via `IYieldManager`) is split between the Treasury and market rebalancing based on the degree of imbalance between the long and short sides, configurable via `marketTreasurySplitGradient_e18`."",
    ""Permanent Seed Liquidity: Initial liquidity is minted to a specific, potentially unrecoverable, address (`PERMANENT_INITIAL_LIQUIDITY_HOLDER`).""
  ],
  ""Questions"": [
    ""What is the specific mechanism within the `IStaker` contract that utilizes the pushed market prices? How does it influence 'float issuance'?"",
    ""What are the assumptions about the `IYieldManager` implementation regarding yield generation and security?"",
    ""Are there explicit checks within the `IOracleManager` interface or expected implementation to prevent stale or manipulated prices (e.g., heartbeat, deviation checks)?"",
    ""How is the `PERMANENT_INITIAL_LIQUIDITY_HOLDER` address generated or controlled? Is it guaranteed to be a burn address?"",
    ""Could `totalValueLockedInMarket` in `_getYieldSplit` potentially become zero under certain edge cases (e.g., extreme market conditions, bugs), leading to division by zero?"",
    ""Could `oldAssetPrice` in `_claimAndDistributeYieldThenRebalanceMarket` be zero if a market is initialized with a zero price, leading to division by zero?"",
    ""Are there any scenarios where integer overflows/underflows could occur in price or amount calculations, despite using Solidity 0.8.x (e.g., during extreme price swings or very large/small token amounts)?"",
    ""Is there a mechanism to pause or halt trading/settlements in specific markets or globally in case of emergencies?"",
    ""What happens if the external calls (e.g., to Oracle, Yield Manager, Staker) fail or revert during critical operations like `_updateSystemStateInternal`?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerabilities"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions interact with external contracts (Oracles, Stakers, Yield Managers, ERC20 tokens) without consistent application of reentrancy guards (like the Checks-Effects-Interactions pattern). Specifically, `_updateSystemStateInternal` calls external contracts (`IOracleManager`, `IStaker`, `IYieldManager`, `ISyntheticToken`) and `_transferPaymentTokensFromUserToYieldManager` calls `transferFrom` on potentially untrusted ERC20 tokens. If any of these external contracts are malicious or compromised, they could call back into the `LongShort` contract before the initial state update is complete, leading to manipulation of market state, prices, token balances, or potential fund theft."",
      ""Impact"": ""Malicious external contracts (Oracle, Staker, Yield Manager, Payment Token) could re-enter the system to manipulate prices, market state, token balances, or drain funds, leading to significant financial losses and disruption of market functionality."",
      ""Location"": ""`_updateSystemStateInternal` (calls to `IOracleManager.updatePrice`, `IStaker.pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`, `IYieldManager.distributeYieldForTreasuryAndReturnMarketAllocation`, `ISyntheticToken.mint/burn`), `_transferPaymentTokensFromUserToYieldManager` (call to `IERC20.transferFrom`), potentially other functions interacting with `IYieldManager` like `_claimAndDistributeYieldThenRebalanceMarket`, `_batchConfirmOutstandingPendingActions`.""
    },
    {
      ""Issue"": ""Incorrect Value Assignment in `_batchConfirmOutstandingPendingActions`"",
      ""Severity"": ""High"",
      ""Description"": ""In the function `_batchConfirmOutstandingPendingActions`, the line `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;` appears twice. The second instance should likely target the `false` (short side) index: `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0;`. This error leads to the short side's pending shifts not being cleared correctly after execution, resulting in incorrect accounting of synthetic tokens and potential financial loss or gain for users involved in subsequent shift operations for that market."",
      ""Impact"": ""Critical error in token accounting for position shifts, leading to incorrect balances and direct financial losses or unfair gains for users."",
      ""Location"": ""`_batchConfirmOutstandingPendingActions` function""
    },
    {
      ""Issue"": ""Use of `transferFrom` Without Explicit Allowance Check"",
      ""Severity"": ""High"",
      ""Description"": ""The `_transferPaymentTokensFromUserToYieldManager` function calls `IERC20.transferFrom(msg.sender, yieldManagers[marketIndex], amount)` without first verifying that the `LongShort` contract has sufficient allowance from `msg.sender` to spend the specified `amount` of the payment token. If the user has not granted the necessary allowance beforehand, the `transferFrom` call will revert, causing the entire user action (like minting or shifting) to fail."",
      ""Impact"": ""User transactions (mint, shift) will unexpectedly revert if the required ERC20 allowance hasn't been pre-approved, leading to failed operations, wasted gas, and poor user experience."",
      ""Location"": ""`_transferPaymentTokensFromUserToYieldManager` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow and Precision Issues in Rebalancing"",
      ""Severity"": ""High"",
      ""Description"": ""The `_claimAndDistributeYieldThenRebalanceMarket` function calculates `valueChange` using `int256` arithmetic involving asset price differences: `((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;`. Significant price swings (`newAssetPrice - oldAssetPrice`) combined with large `underbalancedSideValue` or small `oldAssetPrice` could lead to integer overflow or underflow within the `int256` calculation, even with Solidity 0.8 checks (due to the nature of signed integers and division). Furthermore, converting a potentially large negative `valueChange` (resulting from underflow or a large price drop) to `uint256` before adding/subtracting from `longValue`/`shortValue` can lead to very large incorrect positive values being used, or transaction reverts if the subtraction leads to a negative result in `uint256` variables (`shortValue -= uint256(valueChange)`). This could cause incorrect market rebalancing, inaccurate token pricing, or Denial of Service (DoS) if rebalancing reverts."",
      ""Impact"": ""Incorrect market rebalancing, inaccurate distribution of value, financial loss for users due to incorrect calculations, and potential DoS preventing market updates if calculations revert."",
      ""Location"": ""`_claimAndDistributeYieldThenRebalanceMarket` function (specifically lines calculating and applying `valueChange`)""
    },
    {
      ""Issue"": ""Unprotected or Insufficiently Protected Admin Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several critical administrative functions (`updateMarketOracle`, `changeAdmin`, `changeTreasury`, `changeMarketTreasurySplitGradient`, `createNewSyntheticMarket`, `initializeMarket`) are protected only by an `adminOnly` modifier. If the single admin key is compromised, an attacker gains full control over market creation, parameter changes, oracle manipulation, and treasury redirection. This centralization poses a significant risk. A more robust mechanism like multi-signature control or a time-locked governance process is recommended for such sensitive operations."",
      ""Impact"": ""A compromised admin can manipulate market parameters, set malicious oracles leading to price manipulation and fund theft, change treasury address to steal yield, or disrupt the entire system. Total loss of user funds and protocol integrity is possible."",
      ""Location"": ""Functions using `adminOnly` modifier: `changeAdmin`, `changeTreasury`, `updateMarketOracle`, `changeMarketTreasurySplitGradient`, `createNewSyntheticMarket`, `initializeMarket`""
    },
    {
      ""Issue"": ""Lack of Slippage Control for Next Price Actions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Functions like `mintLongNextPrice`, `mintShortNextPrice`, `redeemLongNextPrice`, `redeemShortNextPrice`, `shiftPositionFromLongNextPrice`, and `shiftPositionFromShortNextPrice` allow users to commit to an action executed at the *next* oracle price update. However, users cannot specify a maximum acceptable slippage or a minimum output amount. If the price moves significantly between the user's transaction submission and the execution (`_updateSystemStateInternal`), the user might receive far fewer tokens (on mint/shift) or pay far more (on redeem/shift) than anticipated, especially during high volatility."",
      ""Impact"": ""Users are exposed to price volatility between transaction submission and execution, potentially leading to significant financial losses due to unfavorable execution prices (slippage) without any user-defined limits."",
      ""Location"": ""`mintLongNextPrice`, `mintShortNextPrice`, `redeemLongNextPrice`, `redeemShortNextPrice`, `shiftPositionFromLongNextPrice`, `shiftPositionFromShortNextPrice` functions""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in Next Price Actions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The \""Next Price\"" mechanism (`mint*NextPrice`, `redeem*NextPrice`, `shift*NextPrice` functions) creates an opportunity for front-running attacks. Malicious actors observing pending user transactions in the mempool can submit their own transactions (e.g., manipulating the oracle price indirectly if possible, or performing actions that affect market balance) with higher gas fees to execute just before the user's action is settled by `_updateSystemStateInternal`. This allows the attacker to profit from the price impact caused by the user's trade or force the user into a less favorable execution price."",
      ""Impact"": ""Users initiating \""Next Price\"" actions can be exploited by front-runners, leading to worse execution prices and financial losses."",
      ""Location"": ""`mintLongNextPrice`, `mintShortNextPrice`, `redeemLongNextPrice`, `redeemShortNextPrice`, `shiftPositionFromLongNextPrice`, `shiftPositionFromShortNextPrice` functions""
    },
    {
      ""Issue"": ""Lack of Access Control on Public State Update Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `updateSystemState` and `updateSystemStateMulti` functions are `external` and lack explicit access control (beyond checking if a market exists internally). Anyone can call these functions. While necessary for keeping the system updated, this allows potential griefing attacks where an attacker could repeatedly call these functions unnecessarily, consuming gas and potentially interfering with legitimate updates or exploiting the front-running window more easily. It also opens up the `updateSystemStateMulti` function to gas limit DoS attacks."",
      ""Impact"": ""Potential for gas griefing attacks, denial-of-service by hitting gas limits (especially with `updateSystemStateMulti`), and facilitation of front-running by allowing anyone to trigger state updates."",
      ""Location"": ""`updateSystemState`, `updateSystemStateMulti` functions""
    },
    {
      ""Issue"": ""Centralization Risk: Reliance on External Oracles and Yield Managers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The protocol heavily relies on external `IOracleManager` contracts for asset prices and `IYieldManager` contracts for yield management and fund transfers. The security and correctness of the `LongShort` contract are directly dependent on the reliability and security of these external components. A compromised, malicious, or faulty oracle/yield manager could provide incorrect data or execute transfers improperly, leading to severe financial consequences within the `LongShort` system."",
      ""Impact"": ""Incorrect asset prices from a faulty oracle can lead to mass incorrect liquidations or unfair mint/redeem values. A faulty yield manager could mismanage or steal user funds deposited for yield."",
      ""Location"": ""Throughout the contract, particularly in `_updateSystemStateInternal`, `_claimAndDistributeYieldThenRebalanceMarket`, `_transferPaymentTokensFromUserToYieldManager`, `_executeOutstandingNextPriceRedeems` etc.""
    },
    {
      ""Issue"": ""Missing Input Validation for Critical Parameters and Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions lack sufficient input validation: \n1. `createNewSyntheticMarket`: Does not validate if `_oracleManager` and `_yieldManager` are contract addresses (could be EOAs).\n2. `initializeMarket`: Critical parameters like `kInitialMultiplier`, `kPeriod`, `unstakeFee_e18`, `balanceIncentiveCurve_exponent`, `balanceIncentiveCurve_equilibriumOffset`, `_marketTreasurySplitGradient_e18` are not checked for reasonableness (e.g., non-zero `kPeriod`, fees within bounds, gradient <= 1e18).\n3. Admin functions (`changeAdmin`, `changeTreasury`): Do not check if the provided address is non-zero or potentially a burn address.\n4. `changeMarketTreasurySplitGradient`: Does not explicitly check if `_marketTreasurySplitGradient_e18` is <= 1e18 (though `_getYieldSplit` caps it)."",
      ""Impact"": ""Providing invalid addresses (EOAs) can cause transactions to fail later. Setting unreasonable parameters during initialization or via admin functions can lead to unusable markets, locked funds (high fees), incorrect yield distribution, or unexpected contract behavior."",
      ""Location"": ""`createNewSyntheticMarket`, `initializeMarket`, `changeAdmin`, `changeTreasury`, `changeMarketTreasurySplitGradient`, `_seedMarketInitially` (lack of upper bound check)""
    },
    {
      ""Issue"": ""Unprotected `_seedMarketInitially` Function Logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""While `_seedMarketInitially` is internal, it's called by the `adminOnly` `initializeMarket`. The primary concern is not re-entrancy but the admin's ability to potentially call `initializeMarket` multiple times or with specific seed amounts to manipulate the initial market state, potentially creating unfair advantages, although `requireMarketDoesNotExist` prevents re-initialization of the *same* market index."",
      ""Impact"": ""Potential for admin manipulation of initial market conditions if market indices can be reused or manipulated, although existing checks mitigate direct re-initialization."",
      ""Location"": ""`_seedMarketInitially` function (called via `initializeMarket`)""
    },
    {
      ""Issue"": ""Inconsistent Usage of `latestMarket` vs `marketIndex`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses both `latestMarket` (an incrementing counter) and `marketIndex` (passed as a parameter, seemingly intended as an ID). There's potential for confusion and errors. For instance, `initializeMarket` uses `latestMarket` when calling `IStaker(staker).addNewStakingFund(latestMarket)`, but uses `marketIndex` for other mappings related to the market being initialized. If `marketIndex` provided by the admin doesn't align with the current `latestMarket` value, this could lead to the staking fund being associated with the wrong market ID in the `Staker` contract, or other mapping inconsistencies."",
      ""Impact"": ""Potential for incorrect market initialization, association of staking funds with wrong markets, and errors in managing market-specific data due to confusing or mismatched index usage."",
      ""Location"": ""Multiple locations, notably `initializeMarket` (e.g., LongShort.sol:292 vs other uses of `marketIndex`)""
    },
    {
      ""Issue"": ""Denial of Service (DoS) Risk via Unbounded Loops"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions `updateSystemStateMulti` and `executeOutstandingNextPriceSettlementsUserMulti` iterate through user-provided arrays (`marketIndexes`) without limiting the array size. A malicious user could provide an extremely large array, causing the transaction's gas cost to exceed the block gas limit. This would cause the transaction to revert, potentially preventing legitimate batch updates or settlements and leading to a Denial of Service."",
      ""Impact"": ""Temporary inability to update multiple market states or settle multiple user actions simultaneously, disrupting functionality and potentially delaying user operations."",
      ""Location"": ""`updateSystemStateMulti` (LongShort.sol:473), `executeOutstandingNextPriceSettlementsUserMulti` (LongShort.sol:723)""
    },
    {
      ""Issue"": ""Rounding Errors in Price and Amount Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract performs various calculations involving division for determining synthetic token prices, payment token amounts, and equivalent token amounts (e.g., in `_getSyntheticTokenPrice`, `_getAmountPaymentToken`, `_getAmountSyntheticToken`, `_getEquivalentAmountSyntheticTokensOnTargetSide`). Integer division truncates remainders, which can lead to small precision losses (rounding errors). While often minor individually, these errors can accumulate over many transactions or time, potentially leading to slight discrepancies in value accounting and potentially favoring the protocol or one side of a trade consistently."",
      ""Impact"": ""Minor inaccuracies in calculated prices and amounts, which could accumulate over time, leading to small, potentially unfair, value discrepancies for users or the protocol."",
      ""Location"": ""`_getSyntheticTokenPrice`, `_getAmountPaymentToken`, `_getAmountSyntheticToken`, `_getEquivalentAmountSyntheticTokensOnTargetSide`, `_claimAndDistributeYieldThenRebalanceMarket` (division for `valueChange`), `getAmountSyntheticTokenToMintOnTargetSide`""
    },
    {
      ""Issue"": ""Uninitialized Storage Gaps"",
      ""Severity"": ""Minor"",
      ""Description"": ""The contract declares storage gap variables (`__constantsGap`, `__globalStateGap`) intended for upgradeability, but they are not explicitly initialized (e.g., in an initializer function). While Solidity generally zero-initializes storage, relying on this implicitly for upgradeability patterns can sometimes be risky if future upgrade logic makes assumptions about non-zero initial gap states. Explicit initialization is safer."",
      ""Impact"": ""Potential unexpected behavior in future contract upgrades if implicit zero-initialization is relied upon and proves insufficient for the upgrade mechanism."",
      ""Location"": ""Declaration of `__constantsGap` and `__globalStateGap`""
    },
    {
      ""Issue"": ""Use of Constant Address for Initial Liquidity Holder"",
      ""Severity"": ""Informational"",
      ""Description"": ""The contract uses `PERMANENT_INITIAL_LIQUIDITY_HOLDER` to hold initially minted synthetic tokens during seeding. It's important to ensure this address is either a burn address (like address(0) or a known dead address) or controlled securely (e.g., by a multi-sig or governance contract). If it's a standard EOA that could be compromised, the initial liquidity could be accessed or dumped."",
      ""Impact"": ""If the holder address is controllable and compromised, the initial seed liquidity could be moved or sold, potentially manipulating the market, especially in its early stages."",
      ""Location"": ""Declaration and use of `PERMANENT_INITIAL_LIQUIDITY_HOLDER` in `_seedMarketInitially`""
    },
    {
      ""Issue"": ""Unnecessary Use of `virtual` Keyword"",
      ""Severity"": ""Informational"",
      ""Description"": ""The internal utility function `_getMin` is marked as `virtual` but is unlikely to require overriding in potential inheriting contracts. Removing the `virtual` keyword can save a small amount of deployment gas."",
      ""Impact"": ""Minor gas inefficiency during deployment."",
      ""Location"": ""`_getMin` function definition""
    }
  ],
  ""IssueNumber"": 56,
  ""OutputList"": 18
}",300.36399006843567,4535.0,30.0,"### **Output**

---

**[H-01] Copy/Paste Error in `_batchConfirmOutstandingPendingActions`**

**Report Description**:
The function `_batchConfirmOutstandingPendingActions` in `LongShort.sol` processes the variable `batched_amountSyntheticToken_toShiftAwayFrom_marketSide` and sets it to 0 after processing. However, due to a copy/paste error, in the second instance, where `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false]` is processed, the wrong version is set to 0: `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0`. This means the next time `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false]` is processed, it is never reset, leading to incorrect internal administration and far too many tokens being shifted from SHORT to LONG.

**Match in Response List**:
Matches with the issue titled **""Incorrect Value Assignment in `_batchConfirmOutstandingPendingActions`""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the incorrect value assignment in the `_batchConfirmOutstandingPendingActions` function. It correctly explains the risks associated with the copy/paste error, which aligns with the issue report.

---

**[M-01] `latestMarket` Used Where `marketIndex` Should Have Been Used**

**Report Description**:
The functions `initializeMarket` and `_seedMarketInitially` use the variable `latestMarket`. If these functions are called separately from `createNewSyntheticMarket`, then `latestMarket` would have the same value for each call of `initializeMarket` and `_seedMarketInitially`. This would mean that `latestMarket` is initialized multiple times, and the previous market(s) are not initialized properly. Note: the call to `addNewStakingFund` could have prevented this issue, but also allows this. The functions can only be called by the admin, so if `createNewSyntheticMarket` and `initializeMarket` are called in combination, then it would not lead to problems, but in future releases of the software, the calls to `createNewSyntheticMarket` and `initializeMarket` might get separated.

**Match in Response List**:
Matches with the issue titled **""Inconsistent Usage of `latestMarket` vs `marketIndex`""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the inconsistent usage of `latestMarket` and `marketIndex`. It correctly explains the risks associated with the potential for incorrect market initialization, which aligns with the issue report.

---

**[M-06] Prevent Markets Getting Stuck When Prices Don't Move**

**Report Description**:
Suppose there is a synthetic token where the price stays constant, for example, synthetic DAI (with a payment token of DAI, the price will not move) or a binary option token (for example, tracking the USA elections; after the election results, there will be no more price movements). In that case, `assetPriceHasChanged` will never be true (again), and `marketUpdateIndex[marketIndex]` will never increase. This means the `_executeOutstandingNextPrice*` functions will never be executed, which means the market effectively will be stuck.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of markets getting stuck when prices don't move. This is a significant oversight, as it could lead to markets becoming non-functional, which is a critical issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] Copy/Paste Error in `_batchConfirmOutstandingPendingActions`**
- **[M-01] `latestMarket` Used Where `marketIndex` Should Have Been Used**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-06] Prevent Markets Getting Stuck When Prices Don't Move**

---

### **Conclusion**

The response list effectively addresses the issues related to the copy/paste error in `_batchConfirmOutstandingPendingActions` and the inconsistent usage of `latestMarket` vs `marketIndex`. However, it fails to address the issue of markets getting stuck when prices don't move, which is a significant oversight. This gap should be addressed to ensure comprehensive coverage of all potential vulnerabilities in the smart contract.","```
1. Incorrect Value Assignment in `_batchConfirmOutstandingPendingActions`
2. Inconsistent Usage of `latestMarket` vs `marketIndex`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Incorrect Value Assignment in `_batchConfirmOutstandingPendingActions`"" appears at **rank 2**.
   - ""Inconsistent Usage of `latestMarket` vs `marketIndex`"" appears at **rank 12**.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 12: \( P@12 = \frac{2}{12} \approx 0.1667 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.5 + 0.1667}{2} = \frac{0.6667}{2} = 0.33335
   \]

**Average Precision (AP)**: 0.33335"
Staker.sol,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";

import ""./interfaces/IFloatToken.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ISyntheticToken.sol"";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, ""not admin"");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, ""not valid synth"");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), ""not valid market"");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), ""not long short"");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, ""marketLaunchIncentiveMultiplier must be >= 1e18"");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      ""balanceIncentiveCurve_exponent out of bounds""
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      ""balanceIncentiveCurve_equilibriumOffset out of bounds""
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, ""Not enough tokens to shift"");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, ""nothing to withdraw"");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        ""Outstanding next price stake shifts too great""
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}

",10095,986,"[H-02] 2 variables not indexed by marketIndex
Function `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`
In the token contract: `batched_stakerNextTokenShiftIndex` is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.
stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex. So the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping can be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex[market2]
This will lead to weird results in _calculateAccumulatedFloat, allocating too much or too little float.
``` function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    ...
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;
...
) ```  [H-03] Users could shift tokens on Staker with more than he has staked
 The `shiftTokens` function of Staker checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the shiftTokens function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked. Staker.sol#L885
Recommend adding checks on userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long and userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short to ensure that the sum of the two variables does not exceed user's stake balance.
  [M-04] Staker.sol: Wrong values returned in edge cases of _calculateFloatPerSecond()

In `_calculateFloatPerSecond()`, the edge cases where full rewards go to either the long or short token returns
return (1e18 * k * longPrice, 0); and
return (0, 1e18 * k * shortPrice); respectively.
This is however 1e18 times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. longRewardUnscaled = 0 and shortRewardUnscaled = 1e18. Plugging this into the calculation below,
return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); results in
(0, 1e18 * k * shortPrice / 1e18) or (0, k * shortPrice).
As we can see, this would result in an extremely large float token issuance rate, which would be disastrous.
The edge cases should return (k * longPrice, 0) and (0, k * shortPrice) in the cases where rewards should go fully to long and short token holders respectively.
 ",3,,"pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";

import ""./interfaces/IFloatToken.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ISyntheticToken.sol"";

contract Staker is IStaker, Initializable {
  

  
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  
  
  
  uint256 public constant safeExponentBitShifting = 52;

  
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  
  mapping(uint32 => uint256) public marketLaunchIncentive_period; 
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; 
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  
  
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, ""not admin"");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, ""not valid synth"");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), ""not valid market"");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), ""not long short"");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  

  
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  

  
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); 
    floatPercentage = newFloatPercentage;
  }

  
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); 
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, ""marketLaunchIncentiveMultiplier must be >= 1e18"");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      ""balanceIncentiveCurve_exponent out of bounds""
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      ""balanceIncentiveCurve_equilibriumOffset out of bounds""
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  

  
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  

  
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; 
    }
  }

  
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    
    
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    
    
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    
    
    
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        
        
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        
        
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted 
  ) external override onlyLongShort {
    

    
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  

  
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    
    
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  

  
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, ""Not enough tokens to shift"");

    
    
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  

  
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, ""nothing to withdraw"");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      
      
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        ""Outstanding next price stake shifts too great""
      );
    }
  }

  
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}",6409,2,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze all external function calls (IFloatToken.mint, ILongShort.updateSystemState/..., IERC20.transfer) for potential reentrancy vulnerabilities. Specifically, examine the order of operations and state updates surrounding these calls in `withdraw`, `claimFloatCustom`, `claimFloatCustomFor`, and `_stake`."",
        ""Inspect the `_calculateFloatPerSecond` function for potential arithmetic overflows or underflows, particularly in the exponentiation and division operations. Consider using SafeMath or similar libraries to mitigate these risks."",
        ""Examine the `_calculateAccumulatedFloat` function for potential integer truncation issues in the reward calculation, especially when dividing by `FLOAT_ISSUANCE_FIXED_DECIMAL`. Verify that the fixed-point arithmetic is implemented correctly to maintain sufficient precision."",
        ""Assess the potential for denial-of-service (DoS) attacks in the `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations` function, specifically related to unbounded loops or excessive gas consumption when processing a large number of shifts. Investigate the scalability of the batched shift processing mechanism."",
        ""Verify that all input values are properly validated to prevent unexpected behavior or vulnerabilities. Pay close attention to the range checks for `newFloatPercentage`, `newMarketUnstakeFee_e18`, `_balanceIncentiveCurve_exponent`, and `_balanceIncentiveCurve_equilibriumOffset`."",
        ""Analyze the potential for front-running attacks, particularly in the `shiftTokens` function. Consider implementing a commit-reveal scheme or other mitigation techniques to prevent users from manipulating market prices to their advantage."",
         ""Check for timestamp dependence vulnerabilities, especially within the `_getKValue` function. Determine the impact of block timestamp manipulation.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyAdmin` modifier is correctly implemented and used to protect sensitive administrative functions, such as `changeAdmin`, `changeFloatPercentage`, `changeUnstakeFee`, `changeMarketLaunchIncentiveParameters`, `changeBalanceIncentiveExponent`, and `changeBalanceIncentiveEquilibriumOffset`."",
        ""Ensure that the `onlyLongShort` modifier is correctly implemented and used to restrict access to functions intended to be called only by the `LongShort` contract, such as `addNewStakingFund` and `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`."",
        ""Confirm that the `admin` address is properly initialized during contract deployment and that only the designated admin can perform administrative actions."",
        ""Investigate the potential impact of a compromised `LongShort` contract on the `Staker` contract, given the reliance on the `onlyLongShort` modifier.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms"",
      ""Tasks"": [
        ""Thoroughly review the `_calculateFloatPerSecond` function to ensure that the reward calculation formula is implemented correctly and produces the intended results under various market conditions. Pay attention to the impact of the `balanceIncentiveCurve_exponent` and `balanceIncentiveCurve_equilibriumOffset` parameters on reward distribution."",
        ""Analyze the logic for handling token shifts in the `shiftTokens`, `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`, and `_calculateAccumulatedFloat` functions. Ensure that shifts are processed correctly and that users receive the appropriate rewards after a shift."",
        ""Evaluate the accuracy and efficiency of the snapshot reward system implemented using `accumulativeFloatPerSyntheticTokenSnapshots`. Verify that snapshots are created and updated correctly and that users receive the correct accumulated rewards."",
        ""Examine the time complexity of the reward calculation and claiming processes. Identify potential bottlenecks or inefficiencies that could impact performance or gas costs.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that the `Staker` contract correctly interacts with the `IFloatToken` contract when minting rewards. Ensure that the correct amount of FLOAT tokens is minted and distributed to users and the `floatCapital` address."",
        ""Thoroughly review the interactions with the `ILongShort` contract, including the calls to `updateSystemState`, `getAmountSyntheticTokenToMintOnTargetSide`, and `shiftPositionFromLongNextPrice`/`shiftPositionFromShortNextPrice`. Ensure that these calls are made with the correct parameters and that the `Staker` contract handles the responses appropriately."",
        ""Confirm that the `Staker` contract correctly transfers tokens to the `floatTreasury` address when users withdraw staked tokens with fees."",
        ""Assess the potential impact of failures or vulnerabilities in the external contracts on the `Staker` contract. Implement appropriate error handling and mitigation strategies."",
        ""Analyze the trust assumptions associated with the external contracts and their owners. Consider the potential for malicious behavior or unintended consequences.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify opportunities to reduce gas costs in the `_calculateFloatPerSecond` function, such as using more efficient arithmetic operations or caching intermediate results."",
        ""Minimize the number of state variable reads and writes in frequently called functions, such as `stakeFromUser`, `withdraw`, and `claimFloatCustom`."",
        ""Optimize the storage layout of state variables to reduce gas costs associated with storage access."",
        ""Use calldata instead of memory for function parameters where appropriate."",
        ""Evaluate the gas costs associated with the snapshot reward system and identify opportunities to reduce storage overhead or computational complexity."",
         ""Examine functions involving loops (e.g., `_mintAccumulatedFloatMulti`) and see if gas costs can be reduced by limiting loop iterations or using more efficient data structures.""
      ]
    },
     {
      ""Area"": ""Delayed Token Shifting"",
      ""Tasks"": [
        ""Simulate scenarios where a user requests a token shift and the market prices change significantly between the request and the `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations` call. Verify that the user receives the correct amount of tokens and rewards under these conditions. Address the question: 'In `_calculateAccumulatedFloat`, how does `getAmountSyntheticTokenToMintOnTargetSide` (called on `longShort`) handle potential slippage or price changes between when the shift was requested and when it's calculated?'"",
        ""Analyze the potential for a user to exploit the delayed token shift mechanism by strategically timing their shift requests to take advantage of favorable market conditions."",
        ""Examine the impact of pending token shifts on reward distribution. Ensure that users with pending shifts receive the correct rewards based on their original and shifted positions."",
        ""Verify that the state variables and mappings related to token shifts are properly updated and maintained to prevent inconsistencies or errors."",
        ""Assess the risks associated with a potential failure in the `LongShort` contract during the processing of a token shift. Implement appropriate error handling and recovery mechanisms."",
        ""Investigate the scenario where `userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender]` is greater than 0, but somehow also greater than or equal to `batched_stakerNextTokenShiftIndex[marketIndex]`. Though unlikely, what would be the consequences and how can the code be made more robust to prevent this state?""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The Staker contract manages the staking of synthetic long and short tokens associated with different markets within a larger DeFi protocol (likely the 'LongShort' contract system). It calculates and distributes rewards in the form of FLOAT tokens to stakers based on complex factors including the relative balance of long/short staked value within a market, time-based launch incentives, and market prices. It also handles user requests to shift their staked position between long and short sides (executed at the next price update) and processes withdrawals with potential fees."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Staker"",
    ""Purpose"": ""To manage staking of synthetic tokens, calculate and distribute FLOAT token rewards based on market dynamics and incentive mechanisms, handle withdrawals, and facilitate shifting between long/short positions."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IStaker"",
        ""Initializable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"",
        ""./interfaces/IFloatToken.sol"",
        ""./interfaces/ILongShort.sol"",
        ""./interfaces/IStaker.sol"",
        ""./interfaces/ISyntheticToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""FLOAT_ISSUANCE_FIXED_DECIMAL"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""A large fixed decimal value (1e42) used likely for high-precision calculations involving cumulative reward rates.""
      },
      {
        ""Name"": ""safeExponentBitShifting"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""A constant (52) used for bit shifting in reward calculations, likely for scaling or fixed-point arithmetic related to exponentiation.""
      },
      {
        ""Name"": ""admin"",
        ""Type"": ""address"",
        ""Purpose"": ""The address authorized to perform administrative actions like changing parameters.""
      },
      {
        ""Name"": ""floatCapital"",
        ""Type"": ""address"",
        ""Purpose"": ""Address receiving a percentage of minted FLOAT rewards.""
      },
      {
        ""Name"": ""floatTreasury"",
        ""Type"": ""address"",
        ""Purpose"": ""Address receiving withdrawal fees.""
      },
      {
        ""Name"": ""floatPercentage"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The percentage (e18) of minted FLOAT rewards directed to floatCapital.""
      },
      {
        ""Name"": ""longShort"",
        ""Type"": ""address"",
        ""Purpose"": ""The address of the associated LongShort contract, which manages markets and prices.""
      },
      {
        ""Name"": ""floatToken"",
        ""Type"": ""address"",
        ""Purpose"": ""The address of the FLOAT ERC20 token contract used for rewards.""
      },
      {
        ""Name"": ""marketLaunchIncentive_period"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Duration of the launch incentive period for each market.""
      },
      {
        ""Name"": ""marketLaunchIncentive_multipliers"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Initial reward multiplier during the launch incentive period for each market (decays linearly).""
      },
      {
        ""Name"": ""marketUnstakeFee_e18"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Withdrawal fee percentage (e18) for each market.""
      },
      {
        ""Name"": ""balanceIncentiveCurve_exponent"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Exponent used in the reward calculation formula to incentivize balancing long/short positions for each market.""
      },
      {
        ""Name"": ""balanceIncentiveCurve_equilibriumOffset"",
        ""Type"": ""mapping(uint32 => int256)"",
        ""Purpose"": ""Offset applied in the reward calculation to adjust the target equilibrium between long/short positions for each market.""
      },
      {
        ""Name"": ""syntheticTokens"",
        ""Type"": ""mapping(uint32 => mapping(bool => address))"",
        ""Purpose"": ""Maps market index and side (true=long, false=short) to the synthetic token address.""
      },
      {
        ""Name"": ""marketIndexOfToken"",
        ""Type"": ""mapping(address => uint32)"",
        ""Purpose"": ""Maps a synthetic token address back to its market index.""
      },
      {
        ""Name"": ""latestRewardIndex"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Tracks the index of the latest reward snapshot for each market.""
      },
      {
        ""Name"": ""accumulativeFloatPerSyntheticTokenSnapshots"",
        ""Type"": ""mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))"",
        ""Purpose"": ""Stores historical snapshots of cumulative FLOAT rewards per staked long/short token for each market.""
      },
      {
        ""Name"": ""userIndexOfLastClaimedReward"",
        ""Type"": ""mapping(uint32 => mapping(address => uint256))"",
        ""Purpose"": ""Tracks the reward snapshot index up to which a user has claimed rewards for a specific market.""
      },
      {
        ""Name"": ""userAmountStaked"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Tracks the amount of each synthetic token staked by each user.""
      },
      {
        ""Name"": ""batched_stakerNextTokenShiftIndex"",
        ""Type"": ""mapping(uint32 => uint256)"",
        ""Purpose"": ""Tracks the next index to be used for pending token shifts within a market.""
      },
      {
        ""Name"": ""stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping"",
        ""Type"": ""mapping(uint256 => uint256)"",
        ""Purpose"": ""Maps a token shift index to the corresponding reward snapshot index created *after* the shift price was set.""
      },
      {
        ""Name"": ""stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping"",
        ""Type"": ""mapping(uint256 => uint256)"",
        ""Purpose"": ""Maps a token shift index to the corresponding price snapshot index in the LongShort contract used for the shift.""
      },
      {
        ""Name"": ""userNextPrice_stakedSyntheticTokenShiftIndex"",
        ""Type"": ""mapping(uint32 => mapping(address => uint256))"",
        ""Purpose"": ""Stores the shift index associated with a user's pending token shift request.""
      },
      {
        ""Name"": ""userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long"",
        ""Type"": ""mapping(uint32 => mapping(address => uint256))"",
        ""Purpose"": ""Stores the amount of long tokens a user has requested to shift (pending execution).""
      },
      {
        ""Name"": ""userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short"",
        ""Type"": ""mapping(uint32 => mapping(address => uint256))"",
        ""Purpose"": ""Stores the amount of short tokens a user has requested to shift (pending execution).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyAdmin"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the admin address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyValidSynthetic"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the provided address is a valid synthetic token associated with a market."",
        ""Parameters"": [""_synth""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyValidMarket"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the provided market index corresponds to a valid, added market."",
        ""Parameters"": [""marketIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyLongShort"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the longShort contract address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the contract state (for upgradeable pattern)."",
        ""Parameters"": [""_admin"", ""_longShort"", ""_floatToken"", ""_floatTreasury"", ""_floatCapital"", ""_floatPercentage""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeAdmin"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the current admin to set a new admin."",
        ""Parameters"": [""_admin""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeFloatPercentage"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows admin to change the percentage of rewards sent to floatCapital."",
        ""Parameters"": [""newFloatPercentage""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeUnstakeFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows admin to change the withdrawal fee for a market."",
        ""Parameters"": [""marketIndex"", ""newMarketUnstakeFee_e18""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeMarketLaunchIncentiveParameters"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows admin to change the launch incentive parameters (period, multiplier) for a market."",
        ""Parameters"": [""marketIndex"", ""period"", ""initialMultiplier""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeBalanceIncentiveExponent"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows admin to change the balance incentive curve exponent for a market."",
        ""Parameters"": [""marketIndex"", ""_balanceIncentiveCurve_exponent""],
        ""Returns"": []
      },
      {
        ""Name"": ""changeBalanceIncentiveEquilibriumOffset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows admin to change the balance incentive curve equilibrium offset for a market."",
        ""Parameters"": [""marketIndex"", ""_balanceIncentiveCurve_equilibriumOffset""],
        ""Returns"": []
      },
      {
        ""Name"": ""addNewStakingFund"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by LongShort contract to register a new market and its synthetic tokens."",
        ""Parameters"": [""marketIndex"", ""longToken"", ""shortToken"", ""kInitialMultiplier"", ""kPeriod"", ""unstakeFee_e18"", ""_balanceIncentiveCurve_exponent"", ""_balanceIncentiveCurve_equilibriumOffset""],
        ""Returns"": []
      },
      {
        ""Name"": ""_calculateFloatPerSecond"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates the instantaneous FLOAT reward rate per second for long and short stakers based on market state and incentives."",
        ""Parameters"": [""marketIndex"", ""longPrice"", ""shortPrice"", ""longValue"", ""shortValue""],
        ""Returns"": [""longFloatPerSecond"", ""shortFloatPerSecond""]
      },
      {
        ""Name"": ""_setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and stores a new snapshot of cumulative rewards based on current rates and time elapsed since the last snapshot."",
        ""Parameters"": [""marketIndex"", ""longPrice"", ""shortPrice"", ""longValue"", ""shortValue""],
        ""Returns"": []
      },
      {
        ""Name"": ""pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by LongShort contract to provide updated market data (prices, values) and trigger reward snapshot updates. Also handles linking shift indices to snapshot indices if a shift was executed."",
        ""Parameters"": [""marketIndex"", ""longPrice"", ""shortPrice"", ""longValue"", ""shortValue"", ""stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted""],
        ""Returns"": []
      },
      {
        ""Name"": ""_calculateAccumulatedFloat"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the total unclaimed FLOAT rewards for a user in a specific market, handling pending token shifts."",
        ""Parameters"": [""marketIndex"", ""user""],
        ""Returns"": [""floatReward""]
      },
      {
        ""Name"": ""_mintAccumulatedFloat"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and mints unclaimed FLOAT rewards for a user in a specific market."",
        ""Parameters"": [""marketIndex"", ""user""],
        ""Returns"": []
      },
      {
        ""Name"": ""_mintAccumulatedFloatMulti"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and mints unclaimed FLOAT rewards for a user across multiple markets."",
        ""Parameters"": [""marketIndexes"", ""user""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimFloatCustom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to claim their accumulated FLOAT rewards for specified markets."",
        ""Parameters"": [""marketIndexes""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimFloatCustomFor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to trigger reward claiming for another user for specified markets."",
        ""Parameters"": [""marketIndexes"", ""user""],
        ""Returns"": []
      },
      {
        ""Name"": ""stakeFromUser"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Handles staking of synthetic tokens transferred *from* another user (requires token approval). Called on the token contract, likely via transferAndCall or similar pattern not fully shown."",
        ""Parameters"": [""from"", ""amount""],
        ""Returns"": []
      },
       {
        ""Name"": ""_stake"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic for recording a user's stake, potentially minting pending rewards first."",
        ""Parameters"": [""token"", ""amount"", ""user""],
        ""Returns"": []
      },
      {
        ""Name"": ""shiftTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to request shifting a portion of their staked tokens from one side (long/short) to the other *at the next price update*."",
        ""Parameters"": [""amountSyntheticTokensToShift"", ""marketIndex"", ""isShiftFromLong""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw a specific amount of staked tokens, applying fees."",
        ""Parameters"": [""token"", ""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawAll"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw all their staked tokens of a specific type (excluding amounts pending shift)."",
        ""Parameters"": [""token""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IFloatToken: Calls `mint` to create new FLOAT reward tokens."",
    ""ILongShort: Relies heavily on this contract. Receives market/token additions (`addNewStakingFund`), receives price/value updates (`pushUpdatedMarketPrices...`), calls `updateSystemState`/`updateSystemStateMulti` before user actions, calls `getAmountSyntheticTokenToMintOnTargetSide` to calculate shift outcomes, and calls `shiftPositionFromLongNextPrice`/`shiftPositionFromShortNextPrice` to initiate shifts in the LongShort contract."",
    ""ISyntheticToken (via IERC20): Calls `transfer` to send staked tokens back to the user during withdrawal and to send fees to the `floatTreasury`."",
    ""floatTreasury: Receives tokens transferred as withdrawal fees."",
    ""floatCapital: Receives a percentage of minted FLOAT tokens.""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract: Uses OpenZeppelin's `Initializable` pattern."",
    ""Snapshot Reward System: Uses `accumulativeFloatPerSyntheticTokenSnapshots` to track rewards over time without iterating through history."",
    ""Dynamic Reward Calculation: Implements a complex formula (`_calculateFloatPerSecond`) to adjust reward rates based on the relative balance of staked long vs. short value, market prices, and time-based incentives (K-value decay)."",
    ""Delayed Token Shifting: Users initiate shifts (`shiftTokens`), but the actual change in staked amounts and reward basis occurs only after the next price update processed via `pushUpdatedMarketPrices...` and is resolved during reward calculation (`_calculateAccumulatedFloat`). This involves multiple state variables and mappings to track pending shifts."",
    ""Role-Based Access Control: Uses `onlyAdmin` and `onlyLongShort` modifiers to restrict sensitive operations.""
  ],
  ""Questions"": [
    ""What is the precise mechanism or reason for using `safeExponentBitShifting = 52` in the reward calculation? Is it for fixed-point math precision matching a specific library or format?"",
    ""The reward calculation formula (`_calculateFloatPerSecond`) is complex. What are the bounds and expected ranges for `longValue`, `shortValue`, `longPrice`, `shortPrice` to ensure the calculation does not overflow or lead to unexpected results, especially with the exponentiation and division?"",
    ""How is potential manipulation of the balance (longValue vs shortValue) near the `equilibriumOffset` handled, especially given the potentially sharp changes in reward distribution caused by the exponent?"",
    ""Are there potential reentrancy vulnerabilities, particularly in functions like `withdraw` or `claimFloat` that involve external calls (`updateSystemState`, `mint`, `transfer`)? (Requires checking order of operations vs state changes)."",
    ""Could the `batched_stakerNextTokenShiftIndex` grow indefinitely? Is there a risk related to its size?"",
    ""The constant `FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42` is very large. What's the rationale for this specific value? How does it ensure precision without causing overflow issues when multiplied by `accumDelta`?"",
    ""In `_calculateAccumulatedFloat`, how does `getAmountSyntheticTokenToMintOnTargetSide` (called on `longShort`) handle potential slippage or price changes between when the shift was requested and when it's calculated?"",
    ""The `stakeFromUser` function implies it's called *by* the token contract. What mechanism (e.g., ERC777 `tokensReceived`, custom `transferAndCall`) is used, and does it introduce any security considerations?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Incorrect Logic and Potential Vulnerabilities in `withdrawAll` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdrawAll` function calculates the amount to withdraw by subtracting `amountToShiftForThisToken` from `userAmountStaked[token][msg.sender]`. This logic is flawed as it doesn't account for accumulated rewards and can lead to several issues: 1. If `amountToShiftForThisToken` is greater than the initially staked amount (possible if `shiftTokens` was called with a larger amount), the subtraction will underflow due to unchecked arithmetic, potentially allowing users to claim excessive FLOAT rewards by manipulating state in `_mintAccumulatedFloat`. 2. Even without underflow, the calculation doesn't include accumulated rewards, meaning users might not be able to withdraw their full balance if rewards have accrued. 3. The function might leave the `amountToShiftForThisToken` amount staked if shifting fails or is not possible, potentially locking user funds."",
      ""Impact"": ""User cannot withdraw their full staked amount plus rewards. Potential for attackers to manipulate state and mint excessive FLOAT tokens due to arithmetic underflow. Potential for user funds (`amountToShiftForThisToken`) to become permanently locked."",
      ""Location"": ""`withdrawAll(address token)` function""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability During FLOAT Claiming"",
      ""Severity"": ""High"",
      ""Description"": ""The `claimFloatCustom` and `claimFloatCustomFor` functions execute external calls before completing state changes, creating potential reentrancy vectors. Specifically, they call `ILongShort(longShort).updateSystemStateMulti(marketIndexes)` before minting rewards via `_mintAccumulatedFloatMulti`. Furthermore, `_mintAccumulatedFloatMulti` calls `_mintFloat`, which in turn calls `IFloatToken(floatToken).mint()`. If either the `longShort` contract or the `floatToken` contract allows callbacks into the `Staker` contract during these external calls, an attacker could re-enter the claiming functions. This could potentially allow manipulating reward calculations, double-claiming FLOAT tokens, or corrupting contract state before the initial transaction completes."",
      ""Impact"": ""Potential for attackers to drain FLOAT tokens by claiming multiple times or manipulating reward calculations. State corruption leading to unexpected contract behavior."",
      ""Location"": ""`claimFloatCustom`, `claimFloatCustomFor`, `_mintAccumulatedFloatMulti`, `_mintFloat` functions, specifically around calls to `longShort.updateSystemStateMulti` and `floatToken.mint`""
    },
    {
      ""Issue"": ""Missing Zero-Address Checks During Initialization"",
      ""Severity"": ""High"",
      ""Description"": ""The `initialize` function does not validate that critical address parameters (`_admin`, `_longShort`, `_floatToken`, `_floatTreasury`, `_floatCapital`) are not the zero address. Initializing the contract with the zero address for any of these roles or dependencies can lead to irreversible errors, loss of administrative control, inability to interact with essential components (like LongShort or FLOAT token), or funds being sent to the zero address."",
      ""Impact"": ""Potential loss of funds, permanent contract inoperability, loss of admin control, inability to mint or distribute rewards."",
      ""Location"": ""`initialize(address _admin, address _longShort, address _floatToken, address _floatTreasury, address _floatCapital, uint256 _floatPercentage)` function""
    },
    {
      ""Issue"": ""Lack of Access Control on `stakeFromUser` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `stakeFromUser` function allows staking tokens on behalf of another user (`from` address) and only validates that `msg.sender` is a valid synthetic token address using `onlyValidSynthetic`. It lacks a crucial access control check to ensure that `msg.sender` is authorized to manage funds for the specified `from` address (e.g., checking if `msg.sender == from` or if `msg.sender` is an approved contract). This allows anyone knowing a valid synthetic token address to potentially stake tokens from any `from` address if they have obtained prior ERC20 approval, potentially manipulating staking amounts and rewards for victims."",
      ""Impact"": ""Unauthorized staking on behalf of users, potentially leading to reward manipulation, griefing, or interference with user fund management if ERC20 approvals are misused."",
      ""Location"": ""`stakeFromUser(address from, uint256 amount)` function""
    },
    {
      ""Issue"": ""Stale Price Data Vulnerabilities Affecting Shifts and Rewards"",
      ""Severity"": ""High"",
      ""Description"": ""The contract's reward calculation (`_calculateFloatPerSecond`) and token shifting mechanism (`shiftTokens`, `_calculateAccumulatedFloat`) rely heavily on price and value data (`longPrice`, `shortPrice`, `longValue`, `shortValue`) provided by the `ILongShort` contract via `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`. If these updates are infrequent or delayed, calculations will use stale data. This creates vulnerabilities: 1. **Reward Manipulation:** Attackers could observe stale prices, manipulate the underlying market, stake/withdraw/shift based on the outdated information, and profit before the price is updated. 2. **Incorrect Shifts:** The `shiftTokens` function uses a 'next price' mechanism linked to price snapshot indices. If the `ILongShort` contract fails to provide the correct historical price for the shift index, `getAmountSyntheticTokenToMintOnTargetSide` can return incorrect values, leading to user losses during shifts. 3. **Front-Running Shifts:** Malicious users can front-run `shiftTokens` transactions, manipulating market conditions or consuming shift indices to ensure the victim's shift executes at a less favorable price."",
      ""Impact"": ""Incorrect FLOAT reward distribution, potentially benefiting attackers who exploit stale data. Financial loss for users shifting tokens due to inaccurate pricing or front-running. Loss of funds for the protocol due to inaccurate reward issuance."",
      ""Location"": ""`_calculateFloatPerSecond`, `shiftTokens`, `_calculateAccumulatedFloat`, `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`, and interactions with `ILongShort` for price data.""
    },
    {
      ""Issue"": ""Arithmetic Issues and Potential Division by Zero in `_calculateFloatPerSecond`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_calculateFloatPerSecond` function contains several arithmetic risks: 1. **Integer Overflow/Underflow:** Exponentiation (`**balanceIncentiveCurve_exponent`) and other calculations involving potentially large values (e.g., `totalLocked`, scaled offsets) could overflow or underflow, even with Solidity >=0.8.0 checks, especially when combined with large bit shifts (`safeExponentBitShifting = 52`). 2. **Division by Zero:** The `denominator` calculation `((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex])` can result in zero if `totalLocked` is small relative to the bit shift and the exponent is non-zero. Subsequent divisions by this `denominator` when calculating `longRewardUnscaled` or `shortRewardUnscaled` would cause a transaction revert. 3. **Precision Loss:** Right bit shifting (`>>`) significantly reduces precision, especially `totalLocked >> safeExponentBitShifting`, potentially truncating values to zero and leading to inaccurate (likely reduced) reward calculations."",
      ""Impact"": ""Incorrect FLOAT reward calculations (potentially excessive or insufficient rewards). Complete halt of reward distribution if division-by-zero occurs. Unfair reward distribution due to precision loss."",
      ""Location"": ""`_calculateFloatPerSecond` function, specifically calculations involving exponentiation, bit shifting, and division.""
    },
    {
      ""Issue"": ""Lack of Access Control and Input Validation on `addNewStakingFund`"",
      ""Severity"": ""High"",
      ""Description"": ""The `addNewStakingFund` function is protected by `onlyLongShort`, meaning only the `longShort` contract can call it. However, it lacks internal validation for crucial parameters like `unstakeFee_e18`, `_balanceIncentiveCurve_exponent`, and `_balanceIncentiveCurve_equilibriumOffset`. If the `longShort` contract is compromised or has vulnerabilities, an attacker could call this function with malicious or out-of-range parameters, potentially setting up markets with broken reward mechanics, excessive fees, or denial-of-service conditions."",
      ""Impact"": ""Complete manipulation of a market's staking parameters if the `longShort` contract is compromised, leading to unfair advantages, potential DoS, or theft of future rewards."",
      ""Location"": ""`addNewStakingFund` function""
    },
    {
      ""Issue"": ""Unbounded Loop in `_mintAccumulatedFloatMulti` Leading to Gas Exhaustion"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_mintAccumulatedFloatMulti` function iterates through the `marketIndexes` array provided as calldata (via `claimFloatCustom` or `claimFloatCustomFor`) without checking its length. A malicious user could provide a very large array, causing the loop's gas cost to exceed the block gas limit. This constitutes a Denial of Service (DoS) vulnerability, preventing users (including the attacker) from claiming rewards for multiple markets in a single transaction."",
      ""Impact"": ""Denial of Service (DoS) for claiming rewards across multiple markets. Users may be forced to claim rewards individually, increasing gas costs and potentially making claims uneconomical."",
      ""Location"": ""`_mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, ...)` function""
    },
    {
      ""Issue"": ""Missing Input Validation for Market Indices"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions accept a `marketIndex` (uint32) parameter but lack sufficient validation to ensure it corresponds to an existing, valid market or stays within reasonable bounds. While some functions use the `onlyValidMarket` modifier, others (like `changeMarketLaunchIncentiveParameters`, `changeBalanceIncentiveExponent`, etc., and internal functions) may not consistently apply such checks. Using an invalid or excessively large `marketIndex` could lead to accessing uninitialized storage slots in mappings (e.g., `syntheticTokens`, `accumulativeFloatPerSyntheticTokenSnapshots`), potentially causing unexpected behavior, state corruption, denial of service, or excessive gas consumption due to storage expansion."",
      ""Impact"": ""Unexpected behavior, potential state corruption, denial of service, or excessive gas costs if invalid market indices are processed."",
      ""Location"": ""Multiple functions accepting `marketIndex`, including but not limited to: `changeUnstakeFee`, `changeMarketLaunchIncentiveParameters`, `changeBalanceIncentiveExponent`, `changeBalanceIncentiveEquilibriumOffset`, `_getKValue`, `_calculateFloatPerSecond`, `_calculateAccumulatedFloatInRange`, `_mintAccumulatedFloatMulti`, etc.""
    },
    {
      ""Issue"": ""Insufficient Input Validation for `_floatPercentage`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_changeFloatPercentage` function checks `newFloatPercentage <= 1e18 && newFloatPercentage > 0`, but does not prevent setting it to a value extremely close to zero or exactly zero (if the `> 0` check is bypassed or removed). A percentage very close to zero could starve the `floatCapital` address of its intended share of minted FLOAT. A value of exactly zero would disable the `floatCapital` allocation entirely. Furthermore, there's no reasonable minimum enforced, allowing the possibility of near-zero rewards for stakers if the percentage is set close to 1e18 (meaning almost all FLOAT goes to `floatCapital`). Extreme values could lead to unbalanced token distribution."",
      ""Impact"": ""Incorrect or unintended distribution of FLOAT tokens between stakers and the `floatCapital` address. Potential starving of `floatCapital` or stakers depending on the value. Can affect protocol economics and trust."",
      ""Location"": ""`_changeFloatPercentage` function, impacting calculations in `_mintFloat`""
    },
    {
      ""Issue"": ""Potential Overflow and Rounding Errors in `_withdraw` Fee Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The withdrawal fee `amountFees` in the `_withdraw` function is calculated as `(amount * marketUnstakeFee_e18[marketIndex]) / 1e18;`. While `marketUnstakeFee_e18` is capped (`<= 5e16`), the multiplication `amount * marketUnstakeFee_e18[marketIndex]` could still overflow if `amount` is sufficiently large, causing the transaction to revert due to Solidity 0.8.0+ checks. Additionally, the division by `1e18` truncates the result, leading to rounding errors where the actual fee collected might be slightly less than intended, marginally benefiting the withdrawer at the expense of the treasury."",
      ""Impact"": ""Withdrawals may revert due to overflow if large amounts are withdrawn with high fees. Minor loss of fee revenue for the treasury due to rounding down."",
      ""Location"": ""`_withdraw` function""
    },
    {
      ""Issue"": ""Potential Inaccuracies in Reward Calculation Due to Precision Loss or Overflow"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_calculateAccumulatedFloatInRange` function calculates rewards based on the difference between accumulative issuance snapshots. The calculation `(accumDelta * amountStaked) / FLOAT_ISSUANCE_FIXED_DECIMAL` can suffer from precision loss if `accumDelta * amountStaked` is small relative to `FLOAT_ISSUANCE_FIXED_DECIMAL`, potentially rounding rewards down to zero. Conversely, the multiplication `accumDelta * amountStaked` could theoretically overflow if both the delta and the staked amount are extremely large, although this is less likely given the denominator."",
      ""Impact"": ""Potential for inaccurate reward distribution, possibly rounding small rewards down to zero or, less likely, calculating incorrect rewards due to overflow."",
      ""Location"": ""`_calculateAccumulatedFloatInRange` function""
    },
    {
      ""Issue"": ""Inconsistent Use or Justification of `safeExponentBitShifting`"",
      ""Severity"": ""Low"",
      ""Description"": ""The constant `safeExponentBitShifting = 52` is used for right bit shifting in reward calculations (`_calculateFloatPerSecond`) without clear justification within the code comments for this specific value. Arbitrary bit shifting can lead to unexpected scaling issues or precision loss, potentially impacting the fairness and accuracy of reward calculations if the value isn't carefully chosen based on expected input ranges and desired precision."",
      ""Impact"": ""Potential for inaccurate reward calculations due to suboptimal scaling or excessive precision loss from the chosen bit shift value."",
      ""Location"": ""`_calculateFloatPerSecond` and other potential uses of `safeExponentBitShifting`""
    },
    {
      ""Issue"": ""Inconsistent Checks or Delays in Reward Claim Eligibility"",
      ""Severity"": ""Low"",
      ""Description"": ""Reward claim eligibility relies on comparing `userIndexOfLastClaimedReward` with `latestRewardIndex`. However, `latestRewardIndex` is only updated during specific events (like price updates or token shifts). If these events are infrequent, significant rewards might accumulate over time, but users cannot claim them until the next event updates `latestRewardIndex`. This creates potential delays and minor inconsistencies, as rewards are calculated based on potentially outdated snapshots until the index is updated."",
      ""Impact"": ""Delays in users' ability to claim accrued rewards. Minor potential inaccuracies in reward amounts if calculated long after accrual but before index updates."",
      ""Location"": ""Functions involving `latestRewardIndex`, such as `_mintAccumulatedFloat`, `_stake`, `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`""
    },
    {
      ""Issue"": ""Potential Gas Limit Issues in `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations` function may call `_setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot`, which adds entries to the `accumulativeFloatPerSyntheticTokenSnapshots` mapping and emits an event. Frequent calls, especially with many active stakers or markets, could cause this mapping to grow large, increasing the gas cost of this function and potentially related functions over time. This could eventually lead to transactions hitting the block gas limit."",
      ""Impact"": ""Increasing gas costs for price updates over time. Potential for transactions to fail due to gas limits, hindering price updates and reward calculations."",
      ""Location"": ""`pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations` function""
    },
    {
      ""Issue"": ""Lack of Transparency in `SyntheticTokensShifted` Event"",
      ""Severity"": ""Informational"",
      ""Description"": ""The `SyntheticTokensShifted` event is emitted when `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations` is called (triggered by `longShort`), but it contains no information about which tokens were shifted, the amounts, or the users involved. Adding details like the market index, user address, and amount shifted would significantly improve off-chain monitoring, auditing, and transparency."",
      ""Impact"": ""Reduced ability for off-chain systems and users to track token shifts effectively, hindering monitoring and auditing."",
      ""Location"": ""`SyntheticTokensShifted` event emission in `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`""
    },
    {
      ""Issue"": ""Unnecessary `assert` Statement in `_getKValue`"",
      ""Severity"": ""Informational"",
      ""Description"": ""The `_getKValue` function contains `assert(kInitialMultiplier >= 1e18);`. However, the `_changeMarketLaunchIncentiveParameters` function, which sets the underlying value `marketLaunchIncentive_initialMultiplier`, already includes `require(initialMultiplier >= 1e18, ...);`. Since the `require` statement would revert the transaction if the condition isn't met, the `assert` statement in `_getKValue` is redundant and will never be triggered under normal circumstances where the `require` fails."",
      ""Impact"": ""Adds unnecessary bytecode and minor gas cost during deployment without providing additional security."",
      ""Location"": ""`_getKValue` function""
    }
  ],
  ""IssueNumber"": 55,
  ""OutputList"": 17
}",293.0024349689484,4347.0,29.0,"### **[H-02] 2 variables not indexed by marketIndex**

**Report Description**:
In the function `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`, the variables `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` and `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping` are not indexed by `marketIndex`. This can lead to overwriting of values if `batched_stakerNextTokenShiftIndex[market1] == batched_stakerNextTokenShiftIndex[market2]`. This issue can cause incorrect calculations in `_calculateAccumulatedFloat`, leading to improper allocation of float rewards.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of variables not being indexed by `marketIndex`. This is a critical oversight that can lead to incorrect reward calculations and potential financial losses.

### **[H-03] Users could shift tokens on Staker with more than he has staked**

**Report Description**:
The `shiftTokens` function in `Staker.sol` checks if the user has staked at least the number of tokens he wants to shift. However, a user could call this function multiple times before the next price update, allowing them to shift more tokens than they have staked. This could lead to manipulation of the staking mechanism and incorrect reward distribution.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of users being able to shift more tokens than they have staked. This is a significant vulnerability that could be exploited to manipulate the staking mechanism.

### **[M-04] Staker.sol: Wrong values returned in edge cases of _calculateFloatPerSecond()**

**Report Description**:
In the `_calculateFloatPerSecond()` function, the edge cases where full rewards go to either the long or short token return values that are `1e18` times too large. This can lead to extremely large float token issuance rates, which would be disastrous for the protocol. The correct values should be `(k * longPrice, 0)` and `(0, k * shortPrice)`.

**Match in Response List**:
Matches with the issue titled **""Arithmetic Issues and Potential Division by Zero in `_calculateFloatPerSecond`""**.

**Validation**:
**Partially Correct**. The response identifies arithmetic issues in `_calculateFloatPerSecond`, but it does not specifically address the edge cases where the returned values are `1e18` times too large. This is a critical detail that is missed in the response.

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-04] Staker.sol: Wrong values returned in edge cases of _calculateFloatPerSecond()**

**Missed Issues from Issue Report**:
- **[H-02] 2 variables not indexed by marketIndex**
- **[H-03] Users could shift tokens on Staker with more than he has staked**

---

**Conclusion**:
The response list does not adequately cover the issues reported in the `issue` list. Specifically, the issues related to variables not being indexed by `marketIndex` and users being able to shift more tokens than they have staked are completely missed. The response that partially matches the issue regarding `_calculateFloatPerSecond()` does not address the critical edge cases. Overall, the response list needs significant improvement to cover the vulnerabilities and risks identified in the issue report.","```
None.
```",0.0
