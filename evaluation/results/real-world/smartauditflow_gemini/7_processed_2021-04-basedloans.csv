nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
UniswapConfig.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.6.10;
pragma experimental ABIEncoderV2;

import ""openzeppelin-solidity/contracts/access/Ownable.sol"";

interface CErc20 {
    function underlying() external view returns (address);
}

contract UniswapConfig is Ownable {
    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.
    enum PriceSource {
        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)
        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)
        REPORTER   /// implies the price is set by the reporter
    }

    /// @dev Describe how the USD price should be determined for an asset.
    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.
    struct TokenConfig {
        address cToken;
        address underlying;
        bytes32 symbolHash;
        uint256 baseUnit;
        PriceSource priceSource;
        uint256 fixedPrice;
        address uniswapMarket;
        bool isUniswapReversed;
    }

    mapping(uint => TokenConfig) public tokens;
    mapping(address => uint) public cTokenIndex;
    mapping(address => uint) public underlyingIndex;
    mapping(bytes32 => uint) public symbolHashIndex;

    /// @notice The number of tokens this contract actually supports
    uint public numTokens;

    function _addTokensInternal(TokenConfig[] memory configs) internal {
        for (uint i = 0; i < configs.length; i++) {
            uint index = i + numTokens;
            tokens[index] = configs[i];
            cTokenIndex[configs[i].cToken] = index;
            underlyingIndex[configs[i].underlying] = index;
            symbolHashIndex[configs[i].symbolHash] = index;
        }

        numTokens = numTokens + configs.length;
    }

    function getCTokenIndex(address cToken) internal view returns (uint) {
        return cTokenIndex[cToken];
    }

    function getUnderlyingIndex(address underlying) internal view returns (uint) {
        return underlyingIndex[underlying];
    }

    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {
        return symbolHashIndex[symbolHash];
    }

    /**
     * @notice Get the i-th config, according to the order they were passed in originally
     * @param i The index of the config to get
     * @return The config object
     */
    function getTokenConfig(uint i) public view returns (TokenConfig memory) {
        require(i < numTokens, ""token config not found"");

        return tokens[i];
    }

    /**
     * @notice Get the config for symbol
     * @param symbol The symbol of the config to get
     * @return The config object
     */
    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {
        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));
    }

    /**
     * @notice Get the config for the symbolHash
     * @param symbolHash The keccack256 of the symbol of the config to get
     * @return The config object
     */
    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {
        uint index = getSymbolHashIndex(symbolHash);
        if (index != uint(-1)) {
            return getTokenConfig(index);
        }

        revert(""token config not found"");
    }

    /**
     * @notice Get the config for the cToken
     * @dev If a config for the cToken is not found, falls back to searching for the underlying.
     * @param cToken The address of the cToken of the config to get
     * @return The config object
     */
    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {
        uint index = getCTokenIndex(cToken);
        if (index != uint(-1)) {
            return getTokenConfig(index);
        }

        return getTokenConfigByUnderlying(CErc20(cToken).underlying());
    }

    /**
     * @notice Get the config for an underlying asset
     * @param underlying The address of the underlying asset of the config to get
     * @return The config object
     */
    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {
        uint index = getUnderlyingIndex(underlying);
        if (index != uint(-1)) {
            return getTokenConfig(index);
        }

        revert(""token config not found"");
    }
}

",979,129,"[H-01] UniswapConfig getters return wrong token config if token config does not exist
The UniswapConfig.getTokenConfigBySymbolHash function does not work as getSymbolHashIndex returns 0 if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with -1. The same issue occurs also for:
getTokenConfigByCToken
getTokenConfigByUnderlying  [H-02] uint(-1) index for not found
Functions `getTokenConfigBySymbolHash`, `getTokenConfigByCToken` and `getTokenConfigByUnderlying` check returned index against max uint: index != uint(-1)
-1 should indicate that the index is not found, however, a default value for an uninitialized uint is 0, so it is impossible to get -1. What is even weirder is that 0 will be returned for non-existing configs but 0 is a valid index for the 1st config.
One of the solutions would be to reserve 0 for a not found index and use it when searching in mappings. Then normal indexes should start from 1. Another solution would be to introduce a new mapping with a boolean value that indicates if this index is initialized or not but this may be a more gas costly way.

",2,"pragma solidity ^0.6.10;
pragma experimental ABIEncoderV2;

import ""openzeppelin-solidity/contracts/access/Ownable.sol"";

interface CErc20 {
    function underlying() external view returns (address);
}

contract UniswapConfig is Ownable {
    
    enum PriceSource {
        FIXED_ETH, 
        FIXED_USD, 
        REPORTER   
    }

    
    
    struct TokenConfig {
        address cToken;
        address underlying;
        bytes32 symbolHash;
        uint256 baseUnit;
        PriceSource priceSource;
        uint256 fixedPrice;
        address uniswapMarket;
        bool isUniswapReversed;
    }

    mapping(uint => TokenConfig) public tokens;
    mapping(address => uint) public cTokenIndex;
    mapping(address => uint) public underlyingIndex;
    mapping(bytes32 => uint) public symbolHashIndex;

    
    uint public numTokens;

    function _addTokensInternal(TokenConfig[] memory configs) internal {
        for (uint i = 0; i < configs.length; i++) {
            uint index = i + numTokens;
            tokens[index] = configs[i];
            cTokenIndex[configs[i].cToken] = index;
            underlyingIndex[configs[i].underlying] = index;
            symbolHashIndex[configs[i].symbolHash] = index;
        }

        numTokens = numTokens + configs.length;
    }

    function getCTokenIndex(address cToken) internal view returns (uint) {
        return cTokenIndex[cToken];
    }

    function getUnderlyingIndex(address underlying) internal view returns (uint) {
        return underlyingIndex[underlying];
    }

    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {
        return symbolHashIndex[symbolHash];
    }

    
    function getTokenConfig(uint i) public view returns (TokenConfig memory) {
        require(i < numTokens, ""token config not found"");

        return tokens[i];
    }

    
    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {
        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));
    }

    
    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {
        uint index = getSymbolHashIndex(symbolHash);
        if (index != uint(-1)) {
            return getTokenConfig(index);
        }

        revert(""token config not found"");
    }

    
    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {
        uint index = getCTokenIndex(cToken);
        if (index != uint(-1)) {
            return getTokenConfig(index);
        }

        return getTokenConfigByUnderlying(CErc20(cToken).underlying());
    }

    
    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {
        uint index = getUnderlyingIndex(underlying);
        if (index != uint(-1)) {
            return getTokenConfig(index);
        }

        revert(""token config not found"");
    }
}",640,2,0,"{'task_list': [{'Area': 'Access Control', 'Tasks': ['Verify that the `onlyOwner` modifier is correctly applied to functions intended to be restricted to the contract owner (specifically, a function that calls `_addTokensInternal`).', 'Confirm the initial owner is set correctly and that the ownership transfer mechanism functions as expected.', 'Analyze the impact of potential owner key compromise and develop mitigation strategies.']}, {'Area': 'Input Validation', 'Tasks': ['Implement zero-address checks for `cToken`, `underlying`, and `uniswapMarket` addresses within the `TokenConfig` struct during the token addition process.', 'Investigate potential vulnerabilities related to large input arrays passed to `_addTokensInternal` that could exceed gas limits.', 'Consider implementing checks to prevent duplicate token configurations based on `cToken`, `underlying`, or `symbolHash`.']}, {'Area': 'Logic Errors & Data Consistency', 'Tasks': [""Correct the flawed logic in `getTokenConfigBySymbolHash`, `getTokenConfigByCToken`, and `getTokenConfigByUnderlying` to properly handle 'token not found' scenarios. The current `index != uint(-1)` check is insufficient and should be replaced with a mechanism that definitively distinguishes between a valid index of 0 and a non-existent index. Consider using a separate `exists` mapping or checking against `numTokens` after ensuring `index` is not zero."", 'Verify that the `cTokenIndex`, `underlyingIndex`, and `symbolHashIndex` mappings are consistently updated when new tokens are added or removed (if removal functionality is added later).', ""Write unit tests to specifically test the 'not found' cases in `getTokenConfigBySymbolHash`, `getTokenConfigByCToken`, and `getTokenConfigByUnderlying` after fixing the flawed logic."", ""Analyze the potential impact of symbol hash collisions. Evaluate if mitigations like symbol uniqueness checks are needed depending on the system's tolerance to such collisions.""]}, {'Area': 'External Call Risks', 'Tasks': ['Assess the potential risks associated with the external call `CErc20(cToken).underlying()` in `getTokenConfigByCToken`. Specifically, analyze how the contract behaves if the `cToken` contract does not conform to the `CErc20` interface or reverts during the `underlying()` call. Implement robust error handling to prevent unexpected reverts and consider using `try/catch` (available in newer Solidity versions) for safer external calls or require that the `cToken` contract address implements a token standard that is well documented.', ""Evaluate the trust assumptions related to the `CErc20` interface. Ensure the interface accurately reflects the expected behavior of cToken contracts. Verify the underlying token address can't be manipulated.""]}, {'Area': 'Gas Optimization', 'Tasks': ['Analyze gas costs of adding tokens via `_addTokensInternal`, especially with large `configs` arrays. Suggest optimizations like batching or alternative data structures if gas costs are excessive.', 'Review the gas efficiency of the lookup functions (`getTokenConfigBySymbolHash`, `getTokenConfigByCToken`, `getTokenConfigByUnderlying`).']}, {'Area': 'Mutability and Upgradeability', 'Tasks': ['Evaluate the long-term maintainability of the contract. Consider whether mechanisms for updating or removing token configurations are necessary. If so, design and implement appropriate functions with proper access control.', 'Assess whether the contract should be designed to be upgradeable in the future to accommodate potential changes in token standards or pricing mechanisms.']}]}","{'ReviewingTheCode': ""The contract `UniswapConfig` serves as a registry for token configurations, likely used within a larger DeFi system involving Compound-style cTokens and Uniswap. It uses OpenZeppelin's `Ownable` for access control (presumably for adding tokens via the internal function). It stores configurations in a struct (`TokenConfig`) and provides multiple ways to retrieve this configuration: by numerical index, token symbol (hashed), cToken address, or underlying token address. It includes an interface definition for cTokens (`CErc20`) to fetch the underlying asset address."", 'IdentifyingKeyComponents': {'ContractName': 'UniswapConfig', 'Purpose': 'To store and retrieve configuration data for various tokens, including their cToken addresses, underlying addresses, symbols, price sources, and Uniswap market details.', 'InheritanceAndImports': {'InheritsFrom': ['Ownable'], 'Imports': ['openzeppelin-solidity/contracts/access/Ownable.sol', 'CErc20 (Interface defined within the contract)']}, 'StateVariables': [{'Name': 'PriceSource', 'Type': 'enum', 'Purpose': ""Defines the possible sources for determining a token's price (Fixed ETH, Fixed USD, Reporter).""}, {'Name': 'TokenConfig', 'Type': 'struct', 'Purpose': 'Holds all configuration parameters for a single token.'}, {'Name': 'tokens', 'Type': 'mapping(uint => TokenConfig)', 'Purpose': 'Stores TokenConfig structs, indexed by a sequential uint ID.'}, {'Name': 'cTokenIndex', 'Type': 'mapping(address => uint)', 'Purpose': 'Maps a cToken address to its corresponding index in the `tokens` mapping.'}, {'Name': 'underlyingIndex', 'Type': 'mapping(address => uint)', 'Purpose': 'Maps an underlying token address to its corresponding index in the `tokens` mapping.'}, {'Name': 'symbolHashIndex', 'Type': 'mapping(bytes32 => uint)', 'Purpose': 'Maps the keccak256 hash of a token symbol to its corresponding index in the `tokens` mapping.'}, {'Name': 'numTokens', 'Type': 'uint', 'Purpose': 'Counts the total number of tokens configured in the contract.'}], 'FunctionsAndModifiers': [{'Name': '_addTokensInternal', 'Visibility': 'internal', 'Purpose': 'Adds a batch of new token configurations. Updates `tokens`, index mappings, and `numTokens`. Expected to be called by an owner-controlled function.', 'Parameters': ['TokenConfig[] memory configs'], 'Returns': []}, {'Name': 'getCTokenIndex', 'Visibility': 'internal view', 'Purpose': 'Retrieves the index associated with a given cToken address from the `cTokenIndex` mapping.', 'Parameters': ['address cToken'], 'Returns': ['uint']}, {'Name': 'getUnderlyingIndex', 'Visibility': 'internal view', 'Purpose': 'Retrieves the index associated with a given underlying token address from the `underlyingIndex` mapping.', 'Parameters': ['address underlying'], 'Returns': ['uint']}, {'Name': 'getSymbolHashIndex', 'Visibility': 'internal view', 'Purpose': 'Retrieves the index associated with a given symbol hash from the `symbolHashIndex` mapping.', 'Parameters': ['bytes32 symbolHash'], 'Returns': ['uint']}, {'Name': 'getTokenConfig', 'Visibility': 'public view', 'Purpose': 'Retrieves the full TokenConfig struct for a given numerical index. Reverts if index is out of bounds.', 'Parameters': ['uint i'], 'Returns': ['TokenConfig memory']}, {'Name': 'getTokenConfigBySymbol', 'Visibility': 'public view', 'Purpose': 'Retrieves the TokenConfig struct by hashing the provided symbol string and looking up the hash.', 'Parameters': ['string memory symbol'], 'Returns': ['TokenConfig memory']}, {'Name': 'getTokenConfigBySymbolHash', 'Visibility': 'public view', 'Purpose': 'Retrieves the TokenConfig struct using a pre-computed symbol hash. Contains potentially flawed logic for checking if index exists.', 'Parameters': ['bytes32 symbolHash'], 'Returns': ['TokenConfig memory']}, {'Name': 'getTokenConfigByCToken', 'Visibility': 'public view', 'Purpose': 'Retrieves the TokenConfig struct using a cToken address. If not found directly, it attempts to find it using the underlying address obtained via an external call to the cToken. Contains potentially flawed logic for checking if index exists.', 'Parameters': ['address cToken'], 'Returns': ['TokenConfig memory']}, {'Name': 'getTokenConfigByUnderlying', 'Visibility': 'public view', 'Purpose': 'Retrieves the TokenConfig struct using an underlying token address. Contains potentially flawed logic for checking if index exists.', 'Parameters': ['address underlying'], 'Returns': ['TokenConfig memory']}]}, 'ExternalInteractions': ['The `getTokenConfigByCToken` function makes an external view call to the `underlying()` function of the provided `cToken` address, assuming it conforms to the `CErc20` interface. This introduces a dependency on the availability and correctness of that external contract.'], 'SpecialMechanisms': [""Ownable Pattern: Uses OpenZeppelin's `Ownable` for access control over configuration changes (assumed via `_addTokensInternal`)."", 'Multiple Indexing Mappings: Uses `cTokenIndex`, `underlyingIndex`, and `symbolHashIndex` for efficient lookups.', 'Structs for Data Aggregation: Uses `TokenConfig` struct to group related configuration data.', 'Enums for Categorization: Uses `PriceSource` enum.', 'Symbol Hashing: Uses `keccak256(abi.encodePacked(symbol))` for symbol-based lookups.', 'ABIEncoderV2: Explicitly enabled to allow returning structs from public/external functions.'], 'Questions': [""Index Mapping 'Not Found' Check: The check `if (index != uint(-1))` used in `getTokenConfigBySymbolHash`, `getTokenConfigByCToken`, and `getTokenConfigByUnderlying` appears flawed. Mappings return the default value (0 for uint) for non-existent keys. Since index 0 is a valid token index (tokens are added starting from index 0), this check fails to distinguish between 'token at index 0' and 'token not found'. This could lead to returning incorrect data (config for index 0) or reverting incorrectly when a lookup fails. How should 'not found' cases be reliably detected?"", 'Gas Limit on `_addTokensInternal`: Adding a large array of `configs` in `_addTokensInternal` could potentially exceed the block gas limit. Are there controls or considerations for batch sizes?', 'Mutability: The contract currently only supports adding tokens via the internal function. Is there a requirement or plan for updating or removing token configurations?', 'External Call Failure: How should failures (e.g., revert) in the external call `CErc20(cToken).underlying()` within `getTokenConfigByCToken` be handled? Currently, it will cause the entire function call to revert.', 'Initialization Context: How is `_addTokensInternal` intended to be called? Presumably by an owner-only function not shown in the snippet?', 'Symbol Hash Collisions: Is the (low) risk of `keccak256` hash collisions for token symbols considered acceptable?', 'Zero Address Checks: Should inputs like `cToken`, `underlying`, and `uniswapMarket` within `TokenConfig` structs be checked against the zero address during addition?']}","{'Findings': [{'Issue': 'Unchecked Return Value from External Call in `getTokenConfigByCToken`', 'Severity': 'High', 'Description': 'The `getTokenConfigByCToken` function calls `CErc20(cToken).underlying()`. If this external call fails (e.g., the `cToken` address is invalid, not a contract, or reverts), the error is not handled. The function proceeds assuming the call was successful, potentially using a zero address or garbage data returned by the failed call. This can lead to incorrect token configurations being retrieved or used.', 'Impact': 'Incorrect token configurations retrieved, potential denial of service, unexpected behavior, potential loss of funds if incorrect configurations are used in critical operations.', 'Location': '`getTokenConfigByCToken` function'}, {'Issue': 'Missing Input Validation in `_addTokensInternal`', 'Severity': 'High', 'Description': 'The `_addTokensInternal` function does not validate the input `TokenConfig` array. Specifically, it lacks checks for: 1) Uniqueness of `cToken`, `underlying`, and `symbolHash` values against existing entries and within the input array itself. 2) Zero addresses for `cToken` and `underlying`. 3) Validity of other parameters like `baseUnit` or `fixedPrice`. Adding duplicate, zero-address, or invalid configurations can lead to mapping inconsistencies, incorrect lookups, unexpected reverts, pricing errors, and potential exploits.', 'Impact': 'Inconsistent or incorrect token configuration, potential for denial of service, mapping collisions, incorrect price calculations, unexpected behavior, and potential manipulation.', 'Location': '`_addTokensInternal` function'}, {'Issue': 'Potential Integer Overflow in `_addTokensInternal`', 'Severity': 'Medium', 'Description': 'The `_addTokensInternal` function increments `numTokens` via `numTokens = numTokens + configs.length;` and calculates indices using `i + numTokens`. If `numTokens` is large, either operation could lead to an integer overflow (especially on Solidity < 0.8.0 which wraps). This can cause incorrect token counts, corrupt mapping indices (leading to overwrites or incorrect lookups), and unexpected behavior in functions relying on `numTokens`.', 'Impact': 'Incorrect token indexing, potential overwrites in mappings, incorrect token configuration retrieval, denial of service due to failed assertions or unexpected reverts in dependent functions.', 'Location': '`_addTokensInternal` function, specifically index calculation and `numTokens` increment.'}, {'Issue': 'Reentrancy and External Call Risks in `getTokenConfigByCToken`', 'Severity': 'Medium', 'Description': 'The `getTokenConfigByCToken` function makes an external call to `CErc20(cToken).underlying()`. This introduces risks: 1) Reentrancy: A malicious `cToken` contract could call back into the `UniswapConfig` contract during the `underlying()` execution, potentially leading to unexpected state changes if non-view functions were called. 2) Malicious External Contract: The `cToken` contract could be malicious, return incorrect data, revert unexpectedly causing DoS, or consume excessive gas.', 'Impact': 'Potential reentrancy (though impact limited by view nature of calling function), Denial of Service (DoS), misconfiguration if malicious contract returns wrong data.', 'Location': '`getTokenConfigByCToken` function'}, {'Issue': 'Missing Access Control for `_addTokensInternal` Function', 'Severity': 'Medium', 'Description': ""The `_addTokensInternal` function is `internal`, restricting calls to the contract itself or derived contracts. However, there's no finer-grained access control (like `onlyOwner`). If this contract is inherited, a derived contract (potentially malicious) could call this function freely, allowing unauthorized addition or modification of token configurations."", 'Impact': 'Unauthorized modification or addition of token configurations, leading to incorrect pricing, system disruption, or potential exploitation.', 'Location': '`_addTokensInternal` function'}, {'Issue': 'Unbounded Loop in `_addTokensInternal` May Cause Gas Exhaustion', 'Severity': 'Medium', 'Description': ""The `_addTokensInternal` function iterates through the `configs` array without checks on the array's length. If a very large `configs` array is provided, the loop could consume more gas than the block gas limit, causing the transaction to fail and leading to a denial of service for adding tokens."", 'Impact': 'Denial of service (DoS) for token addition functionality.', 'Location': '`_addTokensInternal` function, the `for` loop.'}, {'Issue': 'Potential for Hash Collision with Symbol Hash', 'Severity': 'Low', 'Description': 'The contract uses `keccak256(abi.encodePacked(symbol))` to generate `symbolHash`. While extremely unlikely, hash collisions are theoretically possible, meaning two different symbols could produce the same hash. This would cause `getTokenConfigBySymbol` or `getTokenConfigBySymbolHash` to return incorrect configuration data for one of the colliding symbols.', 'Impact': 'Incorrect token configuration retrieval for tokens with colliding symbol hashes.', 'Location': '`getTokenConfigBySymbol` function and usage of `symbolHashIndex` mapping.'}, {'Issue': 'Missing Input Validation for `fixedPrice` in `TokenConfig`', 'Severity': 'Low', 'Description': 'The `fixedPrice` field within the `TokenConfig` struct is not validated when tokens are added via `_addTokensInternal`. An unreasonably large, small, or zero value could be set, leading to incorrect price calculations when `priceSource` is `FIXED_ETH` or `FIXED_USD`.', 'Impact': 'Potential pricing errors and incorrect financial calculations within systems using these configurations.', 'Location': 'Assignment of `TokenConfig` values within `_addTokensInternal`.'}, {'Issue': 'Potential Front Running Vulnerability', 'Severity': 'Low', 'Description': '1) Owner Front-Running: The owner can change token configurations via `_addTokensInternal` (likely via an external owner-controlled function). They could potentially front-run significant events by changing configurations just before they occur. 2) Symbol Hash Front-Running: A user calling `getTokenConfigBySymbol` could potentially pre-calculate hashes for different symbols to find one that benefits them, although the practical impact is likely minimal.', 'Impact': 'Potential for owner to gain unfair advantage; minimal risk of user manipulation via symbol hash prediction.', 'Location': '`_addTokensInternal` function (owner action), `getTokenConfigBySymbol` function (user action).'}, {'Issue': 'Inconsistent Error Handling / Logic in Token Retrieval Functions', 'Severity': 'Low', 'Description': ""Token configuration retrieval functions handle non-existent entries differently: `getTokenConfigBySymbolHash` and `getTokenConfigByUnderlying` revert (implicitly via require on index lookups after checking `index != uint(-1)`), while `getTokenConfigByCToken` attempts a fallback lookup via underlying address if the cToken index isn't found directly. This inconsistency makes contract behavior less predictable. Additionally, checking `index != uint(-1)` might incorrectly succeed for `index = 0` if 0 is a valid index but the key wasn't actually found (mappings return default 0)."", 'Impact': 'Unpredictable behavior, potential masking of issues (in `getTokenConfigByCToken`), difficult debugging, possibility of returning default/incorrect config when index is 0.', 'Location': '`getTokenConfigBySymbolHash`, `getTokenConfigByCToken`, `getTokenConfigByUnderlying` functions.'}, {'Issue': 'Inefficient String Hashing in `getTokenConfigBySymbol`', 'Severity': 'Low', 'Description': 'The `getTokenConfigBySymbol` function recalculates `keccak256(abi.encodePacked(symbol))` on every call. For repeated lookups of the same symbol, this is less gas-efficient than computing it once and using the stored `symbolHash` directly, as done in `getTokenConfigBySymbolHash`.', 'Impact': 'Slightly increased gas costs for symbol-based lookups compared to hash-based lookups.', 'Location': '`getTokenConfigBySymbol` function.'}], 'IssueNumber': 34, 'OutputList': 11}",186.9711208343506,"### **[H-01] UniswapConfig getters return wrong token config if token config does not exist**

**Report Description**:
The `UniswapConfig.getTokenConfigBySymbolHash` function does not work as `getSymbolHashIndex` returns `0` if there is no config token for that symbol (uninitialized map value), but the outer function implements the non-existence check with `-1`. The same issue occurs for `getTokenConfigByCToken` and `getTokenConfigByUnderlying`. This inconsistency can lead to incorrect token configurations being returned when a token config does not exist, potentially causing unexpected behavior or vulnerabilities in the system.

**Match in Response List**:
Matches with the issue titled **""Inconsistent Error Handling / Logic in Token Retrieval Functions""**.

**Validation**:
**Correct**. The response accurately identifies the issue with inconsistent error handling in token retrieval functions, specifically mentioning the use of `index != uint(-1)` and the potential for incorrect behavior when `index = 0`. This aligns with the issue described in the report, which highlights the mismatch between the expected non-existence check (`-1`) and the default uninitialized map value (`0`).

---

### **[H-02] uint(-1) index for not found**

**Report Description**:
Functions `getTokenConfigBySymbolHash`, `getTokenConfigByCToken`, and `getTokenConfigByUnderlying` check the returned index against `uint(-1)` to determine if the index is not found. However, a default value for an uninitialized `uint` is `0`, making it impossible to get `-1`. This creates a logical inconsistency because `0` is a valid index for the first config, but it can also be returned for non-existing configs. One solution is to reserve `0` for a not found index and start normal indexes from `1`. Another solution is to introduce a new mapping with a boolean value to indicate if an index is initialized, though this may be more gas costly.

**Match in Response List**:
Matches with the issue titled **""Inconsistent Error Handling / Logic in Token Retrieval Functions""**.

**Validation**:
**Correct**. The response correctly identifies the issue with the use of `uint(-1)` for checking non-existent entries and the potential for incorrect behavior when `index = 0`. The response also mentions the inconsistency in error handling across different token retrieval functions, which aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] UniswapConfig getters return wrong token config if token config does not exist**
- **[H-02] uint(-1) index for not found**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

---

### **Overall Evaluation**

The `response_list` effectively covers the issues described in the `issue` report. Both issues are correctly identified and addressed in the response list, with accurate descriptions of the vulnerabilities and their potential impacts. The responses align with Solidity best practices and security standards, providing a thorough analysis of the issues. No gaps or missed issues were identified in the evaluation.","```
1. Inconsistent Error Handling / Logic in Token Retrieval Functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is: `Inconsistent Error Handling / Logic in Token Retrieval Functions`.
   - This issue appears at rank 11 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 11 (\( P@11 \)) is calculated as the number of true positives up to rank 11 divided by 11.
   - Since there is only one true positive up to rank 11, \( P@11 = \frac{1}{11} \).

3. **Average the precision values**:
   - Since there is only one true positive, the AP is simply \( P@11 \).

4. **Compute the Average Precision (AP)**:
   - \( AP = \frac{1}{11} \approx 0.0909 \).

**Output**:
```
0.0909
```"
Comptroller.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""./CToken.sol"";
import ""./ErrorReporter.sol"";
import ""./Exponential.sol"";
import ""./PriceOracle.sol"";
import ""./ComptrollerInterface.sol"";
import ""./ComptrollerStorage.sol"";
import ""./Unitroller.sol"";
import ""./Governance/Blo.sol"";

/**
 * @title Compound's Comptroller Contract
 * @author Compound
 */
contract Comptroller is ComptrollerV4Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {
    /// @notice Emitted when an admin supports a market
    event MarketListed(CToken cToken);

    /// @notice Emitted when an account enters a market
    event MarketEntered(CToken cToken, address account);

    /// @notice Emitted when an account exits a market
    event MarketExited(CToken cToken, address account);

    /// @notice Emitted when close factor is changed by admin
    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);

    /// @notice Emitted when a collateral factor is changed by admin
    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);

    /// @notice Emitted when liquidation incentive is changed by admin
    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);

    /// @notice Emitted when maxAssets is changed by admin
    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);

    /// @notice Emitted when price oracle is changed
    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);

    /// @notice Emitted when pause guardian is changed
    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);

    /// @notice Emitted when an action is paused globally
    event ActionPaused(string action, bool pauseState);

    /// @notice Emitted when an action is paused on a market
    event ActionPaused(CToken cToken, string action, bool pauseState);

    /// @notice Emitted when market comped status is changed
    event MarketComped(CToken cToken, bool isComped);

    /// @notice Emitted when COMP rate is changed
    event NewCompRate(uint oldCompRate, uint newCompRate);

    /// @notice Emitted when a new COMP speed is calculated for a market
    event CompSpeedUpdated(CToken indexed cToken, uint newSpeed);

    /// @notice Emitted when COMP is distributed to a supplier
    event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);

    /// @notice Emitted when COMP is distributed to a borrower
    event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);

    /// @notice Emitted when borrow cap for a cToken is changed
    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);

    /// @notice Emitted when borrow cap guardian is changed
    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);

    /// @notice The threshold above which the flywheel transfers COMP, in wei
    uint public constant compClaimThreshold = 0.001e18;

    /// @notice The initial COMP index for a market
    uint224 public constant compInitialIndex = 1e36;

    // closeFactorMantissa must be strictly greater than this value
    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05

    // closeFactorMantissa must not exceed this value
    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9

    // No collateralFactorMantissa may exceed this value
    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9

    // liquidationIncentiveMantissa must be no less than this value
    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0

    // liquidationIncentiveMantissa must be no greater than this value
    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5

    constructor() public {
        admin = msg.sender;
    }

    /*** Assets You Are In ***/

    /**
     * @notice Returns the assets an account has entered
     * @param account The address of the account to pull assets for
     * @return A dynamic list with the assets the account has entered
     */
    function getAssetsIn(address account) external view returns (CToken[] memory) {
        CToken[] memory assetsIn = accountAssets[account];

        return assetsIn;
    }

    /**
     * @notice Returns whether the given account is entered in the given asset
     * @param account The address of the account to check
     * @param cToken The cToken to check
     * @return True if the account is in the asset, otherwise false.
     */
    function checkMembership(address account, CToken cToken) external view returns (bool) {
        return markets[address(cToken)].accountMembership[account];
    }

    /**
     * @notice Add assets to be included in account liquidity calculation
     * @param cTokens The list of addresses of the cToken markets to be enabled
     * @return Success indicator for whether each corresponding market was entered
     */
    function enterMarkets(address[] memory cTokens) public override returns (uint[] memory) {
        uint len = cTokens.length;

        uint[] memory results = new uint[](len);
        for (uint i = 0; i < len; i++) {
            CToken cToken = CToken(cTokens[i]);

            results[i] = uint(addToMarketInternal(cToken, msg.sender));
        }

        return results;
    }

    /**
     * @notice Add the market to the borrower's ""assets in"" for liquidity calculations
     * @param cToken The market to enter
     * @param borrower The address of the account to modify
     * @return Success indicator for whether the market was entered
     */
    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {
        Market storage marketToJoin = markets[address(cToken)];

        if (!marketToJoin.isListed) {
            // market is not listed, cannot join
            return Error.MARKET_NOT_LISTED;
        }

        if (marketToJoin.accountMembership[borrower] == true) {
            // already joined
            return Error.NO_ERROR;
        }

        if (accountAssets[borrower].length >= maxAssets)  {
            // no space, cannot join
            return Error.TOO_MANY_ASSETS;
        }

        // survived the gauntlet, add to list
        // NOTE: we store these somewhat redundantly as a significant optimization
        //  this avoids having to iterate through the list for the most common use cases
        //  that is, only when we need to perform liquidity checks
        //  and not whenever we want to check if an account is in a particular market
        marketToJoin.accountMembership[borrower] = true;
        accountAssets[borrower].push(cToken);

        emit MarketEntered(cToken, borrower);

        return Error.NO_ERROR;
    }

    /**
     * @notice Removes asset from sender's account liquidity calculation
     * @dev Sender must not have an outstanding borrow balance in the asset,
     *  or be providing necessary collateral for an outstanding borrow.
     * @param cTokenAddress The address of the asset to be removed
     * @return Whether or not the account successfully exited the market
     */
    function exitMarket(address cTokenAddress) external override returns (uint) {
        CToken cToken = CToken(cTokenAddress);
        /* Get sender tokensHeld and amountOwed underlying from the cToken */
        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);
        require(oErr == 0, ""exitMarket: getAccountSnapshot failed""); // semi-opaque error code

        /* Fail if the sender has a borrow balance */
        if (amountOwed != 0) {
            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);
        }

        /* Fail if the sender is not permitted to redeem all of their tokens */
        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);
        if (allowed != 0) {
            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);
        }

        Market storage marketToExit = markets[address(cToken)];

        /* Return true if the sender is not already ‘in’ the market */
        if (!marketToExit.accountMembership[msg.sender]) {
            return uint(Error.NO_ERROR);
        }

        /* Set cToken account membership to false */
        delete marketToExit.accountMembership[msg.sender];

        /* Delete cToken from the account’s list of assets */
        // load into memory for faster iteration
        CToken[] memory userAssetList = accountAssets[msg.sender];
        uint len = userAssetList.length;
        uint assetIndex = len;
        for (uint i = 0; i < len; i++) {
            if (userAssetList[i] == cToken) {
                assetIndex = i;
                break;
            }
        }

        // We *must* have found the asset in the list or our redundant data structure is broken
        assert(assetIndex < len);

        // copy last item in list to location of item to be removed, reduce length by 1
        CToken[] storage storedList = accountAssets[msg.sender];
        storedList[assetIndex] = storedList[storedList.length - 1];
        storedList.pop();

        emit MarketExited(cToken, msg.sender);

        return uint(Error.NO_ERROR);
    }

    /*** Policy Hooks ***/

    /**
     * @notice Checks if the account should be allowed to mint tokens in the given market
     * @param cToken The market to verify the mint against
     * @param minter The account which would get the minted tokens
     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens
     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)
     */
    function mintAllowed(address cToken, address minter, uint mintAmount) external override returns (uint) {
        // Pausing is a very serious situation - we revert to sound the alarms
        require(!mintGuardianPaused[cToken], ""mint is paused"");

        // Shh - currently unused
        minter;
        mintAmount;

        if (!markets[cToken].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        // Keep the flywheel moving
        updateCompSupplyIndex(cToken);
        distributeSupplierComp(cToken, minter, false);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Validates mint and reverts on rejection. May emit logs.
     * @param cToken Asset being minted
     * @param minter The address minting the tokens
     * @param actualMintAmount The amount of the underlying asset being minted
     * @param mintTokens The number of tokens being minted
     */
    function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) external override {
        // Shh - currently unused
        cToken;
        minter;
        actualMintAmount;
        mintTokens;

        // Shh - we don't ever want this hook to be marked pure
        if (false) {
            maxAssets = maxAssets;
        }
    }

    /**
     * @notice Checks if the account should be allowed to redeem tokens in the given market
     * @param cToken The market to verify the redeem against
     * @param redeemer The account which would redeem the tokens
     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market
     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)
     */
    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external override returns (uint) {
        uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);
        if (allowed != uint(Error.NO_ERROR)) {
            return allowed;
        }

        // Keep the flywheel moving
        updateCompSupplyIndex(cToken);
        distributeSupplierComp(cToken, redeemer, false);

        return uint(Error.NO_ERROR);
    }

    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal returns (uint) {
        if (!markets[cToken].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */
        if (!markets[cToken].accountMembership[redeemer]) {
            return uint(Error.NO_ERROR);
        }

        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */
        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);
        if (err != Error.NO_ERROR) {
            return uint(err);
        }
        if (shortfall > 0) {
            return uint(Error.INSUFFICIENT_LIQUIDITY);
        }

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Validates redeem and reverts on rejection. May emit logs.
     * @param cToken Asset being redeemed
     * @param redeemer The address redeeming the tokens
     * @param redeemAmount The amount of the underlying asset being redeemed
     * @param redeemTokens The number of tokens being redeemed
     */
    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external override {
        // Shh - currently unused
        cToken;
        redeemer;

        // Require tokens is zero or amount is also zero
        if (redeemTokens == 0 && redeemAmount > 0) {
            revert(""redeemTokens zero"");
        }
    }

    /**
     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market
     * @param cToken The market to verify the borrow against
     * @param borrower The account which would borrow the asset
     * @param borrowAmount The amount of underlying the account would borrow
     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)
     */
    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external override returns (uint) {
        // Pausing is a very serious situation - we revert to sound the alarms
        require(!borrowGuardianPaused[cToken], ""borrow is paused"");

        if (!markets[cToken].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        if (!markets[cToken].accountMembership[borrower]) {
            // only cTokens may call borrowAllowed if borrower not in market
            require(msg.sender == cToken, ""sender must be cToken"");

            // attempt to add borrower to the market
            Error err = addToMarketInternal(CToken(msg.sender), borrower);
            if (err != Error.NO_ERROR) {
                return uint(err);
            }

            // it should be impossible to break the important invariant
            assert(markets[cToken].accountMembership[borrower]);
        }

        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {
            return uint(Error.PRICE_ERROR);
        }


        uint borrowCap = borrowCaps[cToken];
        // Borrow cap of 0 corresponds to unlimited borrowing
        if (borrowCap != 0) {
            uint totalBorrows = CToken(cToken).totalBorrows();
            (MathError mathErr, uint nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);
            require(mathErr == MathError.NO_ERROR, ""total borrows overflow"");
            require(nextTotalBorrows < borrowCap, ""market borrow cap reached"");
        }

        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);
        if (err != Error.NO_ERROR) {
            return uint(err);
        }
        if (shortfall > 0) {
            return uint(Error.INSUFFICIENT_LIQUIDITY);
        }

        // Keep the flywheel moving
        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});
        updateCompBorrowIndex(cToken, borrowIndex);
        distributeBorrowerComp(cToken, borrower, borrowIndex, false);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Validates borrow and reverts on rejection. May emit logs.
     * @param cToken Asset whose underlying is being borrowed
     * @param borrower The address borrowing the underlying
     * @param borrowAmount The amount of the underlying asset requested to borrow
     */
    function borrowVerify(address cToken, address borrower, uint borrowAmount) external override {
        // Shh - currently unused
        cToken;
        borrower;
        borrowAmount;

        // Shh - we don't ever want this hook to be marked pure
        if (false) {
            maxAssets = maxAssets;
        }
    }

    /**
     * @notice Checks if the account should be allowed to repay a borrow in the given market
     * @param cToken The market to verify the repay against
     * @param payer The account which would repay the asset
     * @param borrower The account which would borrowed the asset
     * @param repayAmount The amount of the underlying asset the account would repay
     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)
     */
    function repayBorrowAllowed(
        address cToken,
        address payer,
        address borrower,
        uint repayAmount) external override returns (uint) {
        // Shh - currently unused
        payer;
        borrower;
        repayAmount;

        if (!markets[cToken].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        // Keep the flywheel moving
        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});
        updateCompBorrowIndex(cToken, borrowIndex);
        distributeBorrowerComp(cToken, borrower, borrowIndex, false);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Validates repayBorrow and reverts on rejection. May emit logs.
     * @param cToken Asset being repaid
     * @param payer The address repaying the borrow
     * @param borrower The address of the borrower
     * @param actualRepayAmount The amount of underlying being repaid
     */
    function repayBorrowVerify(
        address cToken,
        address payer,
        address borrower,
        uint actualRepayAmount,
        uint borrowerIndex) external override {
        // Shh - currently unused
        cToken;
        payer;
        borrower;
        actualRepayAmount;
        borrowerIndex;

        // Shh - we don't ever want this hook to be marked pure
        if (false) {
            maxAssets = maxAssets;
        }
    }

    /**
     * @notice Checks if the liquidation should be allowed to occur
     * @param cTokenBorrowed Asset which was borrowed by the borrower
     * @param cTokenCollateral Asset which was used as collateral and will be seized
     * @param liquidator The address repaying the borrow and seizing the collateral
     * @param borrower The address of the borrower
     * @param repayAmount The amount of underlying being repaid
     */
    function liquidateBorrowAllowed(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint repayAmount) external override returns (uint) {
        // Shh - currently unused
        liquidator;

        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        /* The borrower must have shortfall in order to be liquidatable */
        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);
        if (err != Error.NO_ERROR) {
            return uint(err);
        }
        if (shortfall == 0) {
            return uint(Error.INSUFFICIENT_SHORTFALL);
        }

        /* The liquidator may not repay more than what is allowed by the closeFactor */
        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);
        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);
        if (mathErr != MathError.NO_ERROR) {
            return uint(Error.MATH_ERROR);
        }
        if (repayAmount > maxClose) {
            return uint(Error.TOO_MUCH_REPAY);
        }

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.
     * @param cTokenBorrowed Asset which was borrowed by the borrower
     * @param cTokenCollateral Asset which was used as collateral and will be seized
     * @param liquidator The address repaying the borrow and seizing the collateral
     * @param borrower The address of the borrower
     * @param actualRepayAmount The amount of underlying being repaid
     */
    function liquidateBorrowVerify(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint actualRepayAmount,
        uint seizeTokens) external override {
        // Shh - currently unused
        cTokenBorrowed;
        cTokenCollateral;
        liquidator;
        borrower;
        actualRepayAmount;
        seizeTokens;

        // Shh - we don't ever want this hook to be marked pure
        if (false) {
            maxAssets = maxAssets;
        }
    }

    /**
     * @notice Checks if the seizing of assets should be allowed to occur
     * @param cTokenCollateral Asset which was used as collateral and will be seized
     * @param cTokenBorrowed Asset which was borrowed by the borrower
     * @param liquidator The address repaying the borrow and seizing the collateral
     * @param borrower The address of the borrower
     * @param seizeTokens The number of collateral tokens to seize
     */
    function seizeAllowed(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint seizeTokens) external override returns (uint) {
        // Pausing is a very serious situation - we revert to sound the alarms
        require(!seizeGuardianPaused, ""seize is paused"");

        // Shh - currently unused
        seizeTokens;

        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {
            return uint(Error.COMPTROLLER_MISMATCH);
        }

        // Keep the flywheel moving
        updateCompSupplyIndex(cTokenCollateral);
        distributeSupplierComp(cTokenCollateral, borrower, false);
        distributeSupplierComp(cTokenCollateral, liquidator, false);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Validates seize and reverts on rejection. May emit logs.
     * @param cTokenCollateral Asset which was used as collateral and will be seized
     * @param cTokenBorrowed Asset which was borrowed by the borrower
     * @param liquidator The address repaying the borrow and seizing the collateral
     * @param borrower The address of the borrower
     * @param seizeTokens The number of collateral tokens to seize
     */
    function seizeVerify(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint seizeTokens) external override {
        // Shh - currently unused
        cTokenCollateral;
        cTokenBorrowed;
        liquidator;
        borrower;
        seizeTokens;

        // Shh - we don't ever want this hook to be marked pure
        if (false) {
            maxAssets = maxAssets;
        }
    }

    /**
     * @notice Checks if the account should be allowed to transfer tokens in the given market
     * @param cToken The market to verify the transfer against
     * @param src The account which sources the tokens
     * @param dst The account which receives the tokens
     * @param transferTokens The number of cTokens to transfer
     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)
     */
    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external override returns (uint) {
        // Pausing is a very serious situation - we revert to sound the alarms
        require(!transferGuardianPaused, ""transfer is paused"");

        // Currently the only consideration is whether or not
        //  the src is allowed to redeem this many tokens
        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);
        if (allowed != uint(Error.NO_ERROR)) {
            return allowed;
        }

        // Keep the flywheel moving
        updateCompSupplyIndex(cToken);
        distributeSupplierComp(cToken, src, false);
        distributeSupplierComp(cToken, dst, false);

        return uint(Error.NO_ERROR);
    }

    /**
     * @notice Validates transfer and reverts on rejection. May emit logs.
     * @param cToken Asset being transferred
     * @param src The account which sources the tokens
     * @param dst The account which receives the tokens
     * @param transferTokens The number of cTokens to transfer
     */
    function transferVerify(address cToken, address src, address dst, uint transferTokens) external override {
        // Shh - currently unused
        cToken;
        src;
        dst;
        transferTokens;

        // Shh - we don't ever want this hook to be marked pure
        if (false) {
            maxAssets = maxAssets;
        }
    }

    /*** Liquidity/Liquidation Calculations ***/

    /**
     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.
     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,
     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.
     */
    struct AccountLiquidityLocalVars {
        uint sumCollateral;
        uint sumBorrowPlusEffects;
        uint cTokenBalance;
        uint borrowBalance;
        uint exchangeRateMantissa;
        uint oraclePriceMantissa;
        Exp collateralFactor;
        Exp exchangeRate;
        Exp oraclePrice;
        Exp tokensToDenom;
    }

    /**
     * @notice Determine the current account liquidity wrt collateral requirements
     * @return (possible error code (semi-opaque),
                account liquidity in excess of collateral requirements,
     *          account shortfall below collateral requirements)
     */
    function getAccountLiquidity(address account) public returns (uint, uint, uint) {
        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);

        return (uint(err), liquidity, shortfall);
    }

    /**
     * @notice Determine the current account liquidity wrt collateral requirements
     * @return (possible error code,
                account liquidity in excess of collateral requirements,
     *          account shortfall below collateral requirements)
     */
    function getAccountLiquidityInternal(address account) internal returns (Error, uint, uint) {
        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
    }

    /**
     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed
     * @param cTokenModify The market to hypothetically redeem/borrow in
     * @param account The account to determine liquidity for
     * @param redeemTokens The number of tokens to hypothetically redeem
     * @param borrowAmount The amount of underlying to hypothetically borrow
     * @return (possible error code (semi-opaque),
                hypothetical account liquidity in excess of collateral requirements,
     *          hypothetical account shortfall below collateral requirements)
     */
    function getHypotheticalAccountLiquidity(
        address account,
        address cTokenModify,
        uint redeemTokens,
        uint borrowAmount) public returns (uint, uint, uint) {
        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);
        return (uint(err), liquidity, shortfall);
    }

    /**
     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed
     * @param cTokenModify The market to hypothetically redeem/borrow in
     * @param account The account to determine liquidity for
     * @param redeemTokens The number of tokens to hypothetically redeem
     * @param borrowAmount The amount of underlying to hypothetically borrow
     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,
     *  without calculating accumulated interest.
     * @return (possible error code,
                hypothetical account liquidity in excess of collateral requirements,
     *          hypothetical account shortfall below collateral requirements)
     */
    function getHypotheticalAccountLiquidityInternal(
        address account,
        CToken cTokenModify,
        uint redeemTokens,
        uint borrowAmount) internal returns (Error, uint, uint) {

        AccountLiquidityLocalVars memory vars; // Holds all our calculation results
        uint oErr;
        MathError mErr;

        // For each asset the account is in
        CToken[] memory assets = accountAssets[account];
        for (uint i = 0; i < assets.length; i++) {
            CToken asset = assets[i];

            // Read the balances and exchange rate from the cToken
            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);
            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades
                return (Error.SNAPSHOT_ERROR, 0, 0);
            }
            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});
            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});

            // Get the normalized price of the asset
            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);
            if (vars.oraclePriceMantissa == 0) {
                return (Error.PRICE_ERROR, 0, 0);
            }
            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});

            // Pre-compute a conversion factor from tokens -> ether (normalized price value)
            (mErr, vars.tokensToDenom) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);
            if (mErr != MathError.NO_ERROR) {
                return (Error.MATH_ERROR, 0, 0);
            }

            // sumCollateral += tokensToDenom * cTokenBalance
            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);
            if (mErr != MathError.NO_ERROR) {
                return (Error.MATH_ERROR, 0, 0);
            }

            // sumBorrowPlusEffects += oraclePrice * borrowBalance
            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);
            if (mErr != MathError.NO_ERROR) {
                return (Error.MATH_ERROR, 0, 0);
            }

            // Calculate effects of interacting with cTokenModify
            if (asset == cTokenModify) {
                // redeem effect
                // sumBorrowPlusEffects += tokensToDenom * redeemTokens
                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);
                if (mErr != MathError.NO_ERROR) {
                    return (Error.MATH_ERROR, 0, 0);
                }

                // borrow effect
                // sumBorrowPlusEffects += oraclePrice * borrowAmount
                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);
                if (mErr != MathError.NO_ERROR) {
                    return (Error.MATH_ERROR, 0, 0);
                }
            }
        }

        // These are safe, as the underflow condition is checked first
        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {
            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);
        } else {
            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);
        }
    }

    /**
     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount
     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)
     * @param cTokenBorrowed The address of the borrowed cToken
     * @param cTokenCollateral The address of the collateral cToken
     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens
     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)
     */
    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) external override returns (uint, uint) {
        /* Read oracle prices for borrowed and collateral markets */
        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));
        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));
        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {
            return (uint(Error.PRICE_ERROR), 0);
        }

        /*
         * Get the exchange rate and calculate the number of collateral tokens to seize:
         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral
         *  seizeTokens = seizeAmount / exchangeRate
         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)
         */
        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error
        uint seizeTokens;
        Exp memory numerator;
        Exp memory denominator;
        Exp memory ratio;
        MathError mathErr;

        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);
        if (mathErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0);
        }

        (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);
        if (mathErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0);
        }

        (mathErr, ratio) = divExp(numerator, denominator);
        if (mathErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0);
        }

        (mathErr, seizeTokens) = mulScalarTruncate(ratio, actualRepayAmount);
        if (mathErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0);
        }

        return (uint(Error.NO_ERROR), seizeTokens);
    }

    /*** Admin Functions ***/

    /**
      * @notice Sets a new price oracle for the comptroller
      * @dev Admin function to set a new price oracle
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);
        }

        // Track the old oracle for the comptroller
        PriceOracle oldOracle = oracle;

        // Set comptroller's oracle to newOracle
        oracle = newOracle;

        // Emit NewPriceOracle(oldOracle, newOracle)
        emit NewPriceOracle(oldOracle, newOracle);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets the closeFactor used when liquidating borrows
      * @dev Admin function to set closeFactor
      * @param newCloseFactorMantissa New close factor, scaled by 1e18
      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
      */
    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);
        }

        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});
        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});
        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {
            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);
        }

        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});
        if (lessThanExp(highLimit, newCloseFactorExp)) {
            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);
        }

        uint oldCloseFactorMantissa = closeFactorMantissa;
        closeFactorMantissa = newCloseFactorMantissa;
        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets the collateralFactor for a market
      * @dev Admin function to set per-market collateralFactor
      * @param cToken The market to set the factor on
      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18
      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
      */
    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);
        }

        // Verify market is listed
        Market storage market = markets[address(cToken)];
        if (!market.isListed) {
            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);
        }

        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});

        // Check collateral factor <= 0.9
        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});
        if (lessThanExp(highLimit, newCollateralFactorExp)) {
            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);
        }

        // If collateral factor != 0, fail if price == 0
        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {
            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);
        }

        // Set market's collateral factor to new collateral factor, remember old value
        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;
        market.collateralFactorMantissa = newCollateralFactorMantissa;

        // Emit event with asset, old collateral factor, and new collateral factor
        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets maxAssets which controls how many markets can be entered
      * @dev Admin function to set maxAssets
      * @param newMaxAssets New max assets
      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
      */
    function _setMaxAssets(uint newMaxAssets) external returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);
        }

        uint oldMaxAssets = maxAssets;
        maxAssets = newMaxAssets;
        emit NewMaxAssets(oldMaxAssets, newMaxAssets);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Sets liquidationIncentive
      * @dev Admin function to set liquidationIncentive
      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18
      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)
      */
    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);
        }

        // Check de-scaled min <= newLiquidationIncentive <= max
        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});
        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});
        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {
            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);
        }

        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});
        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {
            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);
        }

        // Save current value for use in log
        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;

        // Set liquidation incentive to new incentive
        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;

        // Emit event with old incentive, new incentive
        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);

        return uint(Error.NO_ERROR);
    }

    /**
      * @notice Add the market to the markets mapping and set it as listed
      * @dev Admin function to set isListed and add support for the market
      * @param cToken The address of the market (token) to list
      * @return uint 0=success, otherwise a failure. (See enum Error for details)
      */
    function _supportMarket(CToken cToken) external returns (uint) {
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);
        }

        if (markets[address(cToken)].isListed) {
            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);
        }

        cToken.isCToken(); // Sanity check to make sure its really a CToken

        markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0});

        _addMarketInternal(address(cToken));

        emit MarketListed(cToken);

        return uint(Error.NO_ERROR);
    }

    function _addMarketInternal(address cToken) internal {
        for (uint i = 0; i < allMarkets.length; i ++) {
            require(allMarkets[i] != CToken(cToken), ""market already added"");
        }
        allMarkets.push(CToken(cToken));
    }


    /**
      * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.
      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.
      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for
      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.
      */
    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {
        require(msg.sender == admin || msg.sender == borrowCapGuardian, ""not an admin"");

        uint numMarkets = cTokens.length;
        uint numBorrowCaps = newBorrowCaps.length;

        require(numMarkets != 0 && numMarkets == numBorrowCaps, ""invalid input"");

        for(uint i = 0; i < numMarkets; i++) {
            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];
            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);
        }
    }

    /**
     * @notice Admin function to change the Borrow Cap Guardian
     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian
     */
    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {
        require(msg.sender == admin, ""not an admin"");

        // Save current value for inclusion in log
        address oldBorrowCapGuardian = borrowCapGuardian;

        // Store borrowCapGuardian with value newBorrowCapGuardian
        borrowCapGuardian = newBorrowCapGuardian;

        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)
        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);
    }

    /**
     * @notice Admin function to change the Pause Guardian
     * @param newPauseGuardian The address of the new Pause Guardian
     * @return uint 0=success, otherwise a failure. (See enum Error for details)
     */
    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);
        }

        // Save current value for inclusion in log
        address oldPauseGuardian = pauseGuardian;

        // Store pauseGuardian with value newPauseGuardian
        pauseGuardian = newPauseGuardian;

        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)
        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);

        return uint(Error.NO_ERROR);
    }

    function _setMintPaused(CToken cToken, bool state) public returns (bool) {
        require(markets[address(cToken)].isListed, ""cannot pause a market that is not listed"");
        require(msg.sender == pauseGuardian || msg.sender == admin, ""only pause guardian and admin can pause"");
        require(msg.sender == admin || state == true, ""not an admin"");

        mintGuardianPaused[address(cToken)] = state;
        emit ActionPaused(cToken, ""Mint"", state);
        return state;
    }

    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {
        require(markets[address(cToken)].isListed, ""cannot pause a market that is not listed"");
        require(msg.sender == pauseGuardian || msg.sender == admin, ""only pause guardian and admin can pause"");
        require(msg.sender == admin || state == true, ""not an admin"");

        borrowGuardianPaused[address(cToken)] = state;
        emit ActionPaused(cToken, ""Borrow"", state);
        return state;
    }

    function _setTransferPaused(bool state) public returns (bool) {
        require(msg.sender == pauseGuardian || msg.sender == admin, ""only pause guardian and admin can pause"");
        require(msg.sender == admin || state == true, ""not an admin"");

        transferGuardianPaused = state;
        emit ActionPaused(""Transfer"", state);
        return state;
    }

    function _setSeizePaused(bool state) public returns (bool) {
        require(msg.sender == pauseGuardian || msg.sender == admin, ""only pause guardian and admin can pause"");
        require(msg.sender == admin || state == true, ""not an admin"");

        seizeGuardianPaused = state;
        emit ActionPaused(""Seize"", state);
        return state;
    }

    function _become(Unitroller unitroller) public {
        require(msg.sender == unitroller.admin(), ""only unitroller admin can change brains"");
        require(unitroller._acceptImplementation() == 0, ""change not authorized"");
    }

    /**
     * @notice Checks caller is admin, or this contract is becoming the new implementation
     */
    function adminOrInitializing() internal view returns (bool) {
        return msg.sender == admin || msg.sender == comptrollerImplementation;
    }

    /*** Comp Distribution ***/

    /**
     * @notice Recalculate and update COMP speeds for all COMP markets
     */
    function refreshCompSpeeds() public {
        require(msg.sender == tx.origin, ""only externally owned accounts may refresh speeds"");
        refreshCompSpeedsInternal();
    }

    function refreshCompSpeedsInternal() internal {
        CToken[] memory allMarkets_ = allMarkets;

        for (uint i = 0; i < allMarkets_.length; i++) {
            CToken cToken = allMarkets_[i];
            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
            updateCompSupplyIndex(address(cToken));
            updateCompBorrowIndex(address(cToken), borrowIndex);
        }

        Exp memory totalUtility = Exp({mantissa: 0});
        Exp[] memory utilities = new Exp[](allMarkets_.length);
        for (uint i = 0; i < allMarkets_.length; i++) {
            CToken cToken = allMarkets_[i];
            if (markets[address(cToken)].isComped) {
                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(cToken)});
                Exp memory utility = mul_(assetPrice, cToken.totalBorrows());
                utilities[i] = utility;
                totalUtility = add_(totalUtility, utility);
            }
        }

        for (uint i = 0; i < allMarkets_.length; i++) {
            CToken cToken = allMarkets[i];
            uint newSpeed = totalUtility.mantissa > 0 ? mul_(compRate, div_(utilities[i], totalUtility)) : 0;
            compSpeeds[address(cToken)] = newSpeed;
            emit CompSpeedUpdated(cToken, newSpeed);
        }
    }

    /**
     * @notice Accrue COMP to the market by updating the supply index
     * @param cToken The market whose supply index to update
     */
    function updateCompSupplyIndex(address cToken) internal {
        CompMarketState storage supplyState = compSupplyState[cToken];
        uint supplySpeed = compSpeeds[cToken];
        uint blockNumber = getBlockNumber();
        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));
        if (deltaBlocks > 0 && supplySpeed > 0) {
            uint supplyTokens = CToken(cToken).totalSupply();
            uint compAccrued = mul_(deltaBlocks, supplySpeed);
            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});
            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);
            compSupplyState[cToken] = CompMarketState({
                index: safe224(index.mantissa, ""new index exceeds 224 bits""),
                block: safe32(blockNumber, ""block number exceeds 32 bits"")
            });
        } else if (deltaBlocks > 0) {
            supplyState.block = safe32(blockNumber, ""block number exceeds 32 bits"");
        }
    }

    /**
     * @notice Accrue COMP to the market by updating the borrow index
     * @param cToken The market whose borrow index to update
     */
    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {
        CompMarketState storage borrowState = compBorrowState[cToken];
        uint borrowSpeed = compSpeeds[cToken];
        uint blockNumber = getBlockNumber();
        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));
        if (deltaBlocks > 0 && borrowSpeed > 0) {
            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);
            uint compAccrued = mul_(deltaBlocks, borrowSpeed);
            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});
            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);
            compBorrowState[cToken] = CompMarketState({
                index: safe224(index.mantissa, ""new index exceeds 224 bits""),
                block: safe32(blockNumber, ""block number exceeds 32 bits"")
            });
        } else if (deltaBlocks > 0) {
            borrowState.block = safe32(blockNumber, ""block number exceeds 32 bits"");
        }
    }

    /**
     * @notice Calculate COMP accrued by a supplier and possibly transfer it to them
     * @param cToken The market in which the supplier is interacting
     * @param supplier The address of the supplier to distribute COMP to
     */
    function distributeSupplierComp(address cToken, address supplier, bool distributeAll) internal {
        CompMarketState storage supplyState = compSupplyState[cToken];
        Double memory supplyIndex = Double({mantissa: supplyState.index});
        Double memory supplierIndex = Double({mantissa: compSupplierIndex[cToken][supplier]});
        compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;

        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {
            supplierIndex.mantissa = compInitialIndex;
        }

        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);
        uint supplierTokens = CToken(cToken).balanceOf(supplier);
        uint supplierDelta = mul_(supplierTokens, deltaIndex);
        uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);
        compAccrued[supplier] = transferComp(supplier, supplierAccrued, distributeAll ? 0 : compClaimThreshold);
        emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);
    }

    /**
     * @notice Calculate COMP accrued by a borrower and possibly transfer it to them
     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.
     * @param cToken The market in which the borrower is interacting
     * @param borrower The address of the borrower to distribute COMP to
     */
    function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex, bool distributeAll) internal {
        CompMarketState storage borrowState = compBorrowState[cToken];
        Double memory borrowIndex = Double({mantissa: borrowState.index});
        Double memory borrowerIndex = Double({mantissa: compBorrowerIndex[cToken][borrower]});
        compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;

        if (borrowerIndex.mantissa > 0) {
            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);
            uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);
            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);
            uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);
            compAccrued[borrower] = transferComp(borrower, borrowerAccrued, distributeAll ? 0 : compClaimThreshold);
            emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);
        }
    }

    /**
     * @notice Transfer COMP to the user, if they are above the threshold
     * @dev Note: If there is not enough COMP, we do not perform the transfer all.
     * @param user The address of the user to transfer COMP to
     * @param userAccrued The amount of COMP to (possibly) transfer
     * @return The amount of COMP which was NOT transferred to the user
     */
    function transferComp(address user, uint userAccrued, uint threshold) internal returns (uint) {
        if (userAccrued >= threshold && userAccrued > 0) {
            Blo blo = Blo(getCompAddress());
            uint bloRemaining = blo.balanceOf(address(this));
            if (userAccrued <= bloRemaining) {
                blo.transfer(user, userAccrued);
                return 0;
            }
        }
        return userAccrued;
    }

    /**
     * @notice Claim all the comp accrued by holder in all markets
     * @param holder The address to claim COMP for
     */
    function claimComp(address holder) public {
        return claimComp(holder, allMarkets);
    }

    /**
     * @notice Claim all the comp accrued by holder in the specified markets
     * @param holder The address to claim COMP for
     * @param cTokens The list of markets to claim COMP in
     */
    function claimComp(address holder, CToken[] memory cTokens) public {
        address[] memory holders = new address[](1);
        holders[0] = holder;
        claimComp(holders, cTokens, true, true);
    }

    /**
     * @notice Claim all comp accrued by the holders
     * @param holders The addresses to claim COMP for
     * @param cTokens The list of markets to claim COMP in
     * @param borrowers Whether or not to claim COMP earned by borrowing
     * @param suppliers Whether or not to claim COMP earned by supplying
     */
    function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i < cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, ""market must be listed"");
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j < holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j < holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }

    /*** Comp Distribution Admin ***/

    /**
     * @notice Set the COMP token address
     * @param _comp The COMP address
     */
    function _setCompAddress(address _comp) public {
        require(msg.sender == admin, ""not an admin"");
        comp = _comp;
    }

    /**
     * @notice Set the amount of COMP distributed per block
     * @param compRate_ The amount of COMP wei per block to distribute
     */
    function _setCompRate(uint compRate_) public {
        require(adminOrInitializing(), ""not an admin"");

        uint oldRate = compRate;
        compRate = compRate_;
        emit NewCompRate(oldRate, compRate_);

        refreshCompSpeedsInternal();
    }

    /**
     * @notice Add markets to compMarkets, allowing them to earn COMP in the flywheel
     * @param cTokens The addresses of the markets to add
     */
    function _addCompMarkets(address[] memory cTokens) public {
        require(adminOrInitializing(), ""not an admin"");

        for (uint i = 0; i < cTokens.length; i++) {
            _addCompMarketInternal(cTokens[i]);
        }

        refreshCompSpeedsInternal();
    }

    function _addCompMarketInternal(address cToken) internal {
        Market storage market = markets[cToken];
        require(market.isListed == true, ""comp market is not listed"");
        require(market.isComped == false, ""comp market already added"");

        market.isComped = true;
        emit MarketComped(CToken(cToken), true);

        if (compSupplyState[cToken].index == 0 && compSupplyState[cToken].block == 0) {
            compSupplyState[cToken] = CompMarketState({
                index: compInitialIndex,
                block: safe32(getBlockNumber(), ""block number exceeds 32 bits"")
            });
        }

        if (compBorrowState[cToken].index == 0 && compBorrowState[cToken].block == 0) {
            compBorrowState[cToken] = CompMarketState({
                index: compInitialIndex,
                block: safe32(getBlockNumber(), ""block number exceeds 32 bits"")
            });
        }
    }

    /**
     * @notice Remove a market from compMarkets, preventing it from earning COMP in the flywheel
     * @param cToken The address of the market to drop
     */
    function _dropCompMarket(address cToken) public {
        require(msg.sender == admin, ""not an admin"");

        Market storage market = markets[cToken];
        require(market.isComped == true, ""market is not a comp market"");

        market.isComped = false;
        emit MarketComped(CToken(cToken), false);

        refreshCompSpeedsInternal();
    }

    /**
     * @notice Return all of the markets
     * @dev The automatic getter may be used to access an individual market.
     * @return The list of market addresses
     */
    function getAllMarkets() public view returns (CToken[] memory) {
        return allMarkets;
    }

    function getBlockNumber() public view returns (uint) {
        return block.number;
    }

    /**
     * @notice Return the address of the COMP token
     * @return The address of COMP
     */
    function getCompAddress() public view returns (address) {
        return comp;
    }
}

",13666,1448,"[M-01] Reward rates can be changed through flash borrows
The rewards per market are proportional to their totalBorrows which can be changed by a large holder who deposits lots of collateral, takes out a huge borrow in the market, updates the rewards, and then unwinds the position. They'll only pay gas fees as the borrow / repay can happen in the same block.
 The `Comptroller.refreshCompSpeeds` function only checks that the single transaction is called from an EOA, but miners (or anyone if a miner offers services like flash bundles for flashbots) can still run flash-loan-like attacks by first sending a borrow tx increasing the totalBorrows, then the refreshCompSpeeds transaction, and then the repay of the borrow, as miners have full control over the transaction order of the block.
",1,"pragma solidity 0.6.12;

import ""./CToken.sol"";
import ""./ErrorReporter.sol"";
import ""./Exponential.sol"";
import ""./PriceOracle.sol"";
import ""./ComptrollerInterface.sol"";
import ""./ComptrollerStorage.sol"";
import ""./Unitroller.sol"";
import ""./Governance/Blo.sol"";


contract Comptroller is ComptrollerV4Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {
    
    event MarketListed(CToken cToken);

    
    event MarketEntered(CToken cToken, address account);

    
    event MarketExited(CToken cToken, address account);

    
    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);

    
    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);

    
    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);

    
    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);

    
    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);

    
    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);

    
    event ActionPaused(string action, bool pauseState);

    
    event ActionPaused(CToken cToken, string action, bool pauseState);

    
    event MarketComped(CToken cToken, bool isComped);

    
    event NewCompRate(uint oldCompRate, uint newCompRate);

    
    event CompSpeedUpdated(CToken indexed cToken, uint newSpeed);

    
    event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);

    
    event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);

    
    event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);

    
    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);

    
    uint public constant compClaimThreshold = 0.001e18;

    
    uint224 public constant compInitialIndex = 1e36;

    
    uint internal constant closeFactorMinMantissa = 0.05e18; 

    
    uint internal constant closeFactorMaxMantissa = 0.9e18; 

    
    uint internal constant collateralFactorMaxMantissa = 0.9e18; 

    
    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; 

    
    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; 

    constructor() public {
        admin = msg.sender;
    }

    

    
    function getAssetsIn(address account) external view returns (CToken[] memory) {
        CToken[] memory assetsIn = accountAssets[account];

        return assetsIn;
    }

    
    function checkMembership(address account, CToken cToken) external view returns (bool) {
        return markets[address(cToken)].accountMembership[account];
    }

    
    function enterMarkets(address[] memory cTokens) public override returns (uint[] memory) {
        uint len = cTokens.length;

        uint[] memory results = new uint[](len);
        for (uint i = 0; i < len; i++) {
            CToken cToken = CToken(cTokens[i]);

            results[i] = uint(addToMarketInternal(cToken, msg.sender));
        }

        return results;
    }

    
    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {
        Market storage marketToJoin = markets[address(cToken)];

        if (!marketToJoin.isListed) {
            
            return Error.MARKET_NOT_LISTED;
        }

        if (marketToJoin.accountMembership[borrower] == true) {
            
            return Error.NO_ERROR;
        }

        if (accountAssets[borrower].length >= maxAssets)  {
            
            return Error.TOO_MANY_ASSETS;
        }

        
        
        
        
        
        marketToJoin.accountMembership[borrower] = true;
        accountAssets[borrower].push(cToken);

        emit MarketEntered(cToken, borrower);

        return Error.NO_ERROR;
    }

    
    function exitMarket(address cTokenAddress) external override returns (uint) {
        CToken cToken = CToken(cTokenAddress);
        
        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);
        require(oErr == 0, ""exitMarket: getAccountSnapshot failed""); 

        
        if (amountOwed != 0) {
            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);
        }

        
        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);
        if (allowed != 0) {
            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);
        }

        Market storage marketToExit = markets[address(cToken)];

        
        if (!marketToExit.accountMembership[msg.sender]) {
            return uint(Error.NO_ERROR);
        }

        
        delete marketToExit.accountMembership[msg.sender];

        
        
        CToken[] memory userAssetList = accountAssets[msg.sender];
        uint len = userAssetList.length;
        uint assetIndex = len;
        for (uint i = 0; i < len; i++) {
            if (userAssetList[i] == cToken) {
                assetIndex = i;
                break;
            }
        }

        
        assert(assetIndex < len);

        
        CToken[] storage storedList = accountAssets[msg.sender];
        storedList[assetIndex] = storedList[storedList.length - 1];
        storedList.pop();

        emit MarketExited(cToken, msg.sender);

        return uint(Error.NO_ERROR);
    }

    

    
    function mintAllowed(address cToken, address minter, uint mintAmount) external override returns (uint) {
        
        require(!mintGuardianPaused[cToken], ""mint is paused"");

        
        minter;
        mintAmount;

        if (!markets[cToken].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        
        updateCompSupplyIndex(cToken);
        distributeSupplierComp(cToken, minter, false);

        return uint(Error.NO_ERROR);
    }

    
    function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) external override {
        
        cToken;
        minter;
        actualMintAmount;
        mintTokens;

        
        if (false) {
            maxAssets = maxAssets;
        }
    }

    
    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external override returns (uint) {
        uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);
        if (allowed != uint(Error.NO_ERROR)) {
            return allowed;
        }

        
        updateCompSupplyIndex(cToken);
        distributeSupplierComp(cToken, redeemer, false);

        return uint(Error.NO_ERROR);
    }

    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal returns (uint) {
        if (!markets[cToken].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        
        if (!markets[cToken].accountMembership[redeemer]) {
            return uint(Error.NO_ERROR);
        }

        
        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);
        if (err != Error.NO_ERROR) {
            return uint(err);
        }
        if (shortfall > 0) {
            return uint(Error.INSUFFICIENT_LIQUIDITY);
        }

        return uint(Error.NO_ERROR);
    }

    
    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external override {
        
        cToken;
        redeemer;

        
        if (redeemTokens == 0 && redeemAmount > 0) {
            revert(""redeemTokens zero"");
        }
    }

    
    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external override returns (uint) {
        
        require(!borrowGuardianPaused[cToken], ""borrow is paused"");

        if (!markets[cToken].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        if (!markets[cToken].accountMembership[borrower]) {
            
            require(msg.sender == cToken, ""sender must be cToken"");

            
            Error err = addToMarketInternal(CToken(msg.sender), borrower);
            if (err != Error.NO_ERROR) {
                return uint(err);
            }

            
            assert(markets[cToken].accountMembership[borrower]);
        }

        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {
            return uint(Error.PRICE_ERROR);
        }


        uint borrowCap = borrowCaps[cToken];
        
        if (borrowCap != 0) {
            uint totalBorrows = CToken(cToken).totalBorrows();
            (MathError mathErr, uint nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);
            require(mathErr == MathError.NO_ERROR, ""total borrows overflow"");
            require(nextTotalBorrows < borrowCap, ""market borrow cap reached"");
        }

        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);
        if (err != Error.NO_ERROR) {
            return uint(err);
        }
        if (shortfall > 0) {
            return uint(Error.INSUFFICIENT_LIQUIDITY);
        }

        
        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});
        updateCompBorrowIndex(cToken, borrowIndex);
        distributeBorrowerComp(cToken, borrower, borrowIndex, false);

        return uint(Error.NO_ERROR);
    }

    
    function borrowVerify(address cToken, address borrower, uint borrowAmount) external override {
        
        cToken;
        borrower;
        borrowAmount;

        
        if (false) {
            maxAssets = maxAssets;
        }
    }

    
    function repayBorrowAllowed(
        address cToken,
        address payer,
        address borrower,
        uint repayAmount) external override returns (uint) {
        
        payer;
        borrower;
        repayAmount;

        if (!markets[cToken].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        
        Exp memory borrowIndex = Exp({mantissa: CToken(cToken).borrowIndex()});
        updateCompBorrowIndex(cToken, borrowIndex);
        distributeBorrowerComp(cToken, borrower, borrowIndex, false);

        return uint(Error.NO_ERROR);
    }

    
    function repayBorrowVerify(
        address cToken,
        address payer,
        address borrower,
        uint actualRepayAmount,
        uint borrowerIndex) external override {
        
        cToken;
        payer;
        borrower;
        actualRepayAmount;
        borrowerIndex;

        
        if (false) {
            maxAssets = maxAssets;
        }
    }

    
    function liquidateBorrowAllowed(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint repayAmount) external override returns (uint) {
        
        liquidator;

        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        
        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);
        if (err != Error.NO_ERROR) {
            return uint(err);
        }
        if (shortfall == 0) {
            return uint(Error.INSUFFICIENT_SHORTFALL);
        }

        
        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);
        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);
        if (mathErr != MathError.NO_ERROR) {
            return uint(Error.MATH_ERROR);
        }
        if (repayAmount > maxClose) {
            return uint(Error.TOO_MUCH_REPAY);
        }

        return uint(Error.NO_ERROR);
    }

    
    function liquidateBorrowVerify(
        address cTokenBorrowed,
        address cTokenCollateral,
        address liquidator,
        address borrower,
        uint actualRepayAmount,
        uint seizeTokens) external override {
        
        cTokenBorrowed;
        cTokenCollateral;
        liquidator;
        borrower;
        actualRepayAmount;
        seizeTokens;

        
        if (false) {
            maxAssets = maxAssets;
        }
    }

    
    function seizeAllowed(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint seizeTokens) external override returns (uint) {
        
        require(!seizeGuardianPaused, ""seize is paused"");

        
        seizeTokens;

        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {
            return uint(Error.MARKET_NOT_LISTED);
        }

        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {
            return uint(Error.COMPTROLLER_MISMATCH);
        }

        
        updateCompSupplyIndex(cTokenCollateral);
        distributeSupplierComp(cTokenCollateral, borrower, false);
        distributeSupplierComp(cTokenCollateral, liquidator, false);

        return uint(Error.NO_ERROR);
    }

    
    function seizeVerify(
        address cTokenCollateral,
        address cTokenBorrowed,
        address liquidator,
        address borrower,
        uint seizeTokens) external override {
        
        cTokenCollateral;
        cTokenBorrowed;
        liquidator;
        borrower;
        seizeTokens;

        
        if (false) {
            maxAssets = maxAssets;
        }
    }

    
    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external override returns (uint) {
        
        require(!transferGuardianPaused, ""transfer is paused"");

        
        
        uint allowed = redeemAllowedInternal(cToken, src, transferTokens);
        if (allowed != uint(Error.NO_ERROR)) {
            return allowed;
        }

        
        updateCompSupplyIndex(cToken);
        distributeSupplierComp(cToken, src, false);
        distributeSupplierComp(cToken, dst, false);

        return uint(Error.NO_ERROR);
    }

    
    function transferVerify(address cToken, address src, address dst, uint transferTokens) external override {
        
        cToken;
        src;
        dst;
        transferTokens;

        
        if (false) {
            maxAssets = maxAssets;
        }
    }

    

    
    struct AccountLiquidityLocalVars {
        uint sumCollateral;
        uint sumBorrowPlusEffects;
        uint cTokenBalance;
        uint borrowBalance;
        uint exchangeRateMantissa;
        uint oraclePriceMantissa;
        Exp collateralFactor;
        Exp exchangeRate;
        Exp oraclePrice;
        Exp tokensToDenom;
    }

    
    function getAccountLiquidity(address account) public returns (uint, uint, uint) {
        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);

        return (uint(err), liquidity, shortfall);
    }

    
    function getAccountLiquidityInternal(address account) internal returns (Error, uint, uint) {
        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);
    }

    
    function getHypotheticalAccountLiquidity(
        address account,
        address cTokenModify,
        uint redeemTokens,
        uint borrowAmount) public returns (uint, uint, uint) {
        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);
        return (uint(err), liquidity, shortfall);
    }

    
    function getHypotheticalAccountLiquidityInternal(
        address account,
        CToken cTokenModify,
        uint redeemTokens,
        uint borrowAmount) internal returns (Error, uint, uint) {

        AccountLiquidityLocalVars memory vars; 
        uint oErr;
        MathError mErr;

        
        CToken[] memory assets = accountAssets[account];
        for (uint i = 0; i < assets.length; i++) {
            CToken asset = assets[i];

            
            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);
            if (oErr != 0) { 
                return (Error.SNAPSHOT_ERROR, 0, 0);
            }
            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});
            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});

            
            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);
            if (vars.oraclePriceMantissa == 0) {
                return (Error.PRICE_ERROR, 0, 0);
            }
            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});

            
            (mErr, vars.tokensToDenom) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);
            if (mErr != MathError.NO_ERROR) {
                return (Error.MATH_ERROR, 0, 0);
            }

            
            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);
            if (mErr != MathError.NO_ERROR) {
                return (Error.MATH_ERROR, 0, 0);
            }

            
            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);
            if (mErr != MathError.NO_ERROR) {
                return (Error.MATH_ERROR, 0, 0);
            }

            
            if (asset == cTokenModify) {
                
                
                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);
                if (mErr != MathError.NO_ERROR) {
                    return (Error.MATH_ERROR, 0, 0);
                }

                
                
                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);
                if (mErr != MathError.NO_ERROR) {
                    return (Error.MATH_ERROR, 0, 0);
                }
            }
        }

        
        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {
            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);
        } else {
            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);
        }
    }

    
    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) external override returns (uint, uint) {
        
        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));
        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));
        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {
            return (uint(Error.PRICE_ERROR), 0);
        }

        
        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); 
        uint seizeTokens;
        Exp memory numerator;
        Exp memory denominator;
        Exp memory ratio;
        MathError mathErr;

        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);
        if (mathErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0);
        }

        (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);
        if (mathErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0);
        }

        (mathErr, ratio) = divExp(numerator, denominator);
        if (mathErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0);
        }

        (mathErr, seizeTokens) = mulScalarTruncate(ratio, actualRepayAmount);
        if (mathErr != MathError.NO_ERROR) {
            return (uint(Error.MATH_ERROR), 0);
        }

        return (uint(Error.NO_ERROR), seizeTokens);
    }

    

    
    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {
        
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);
        }

        
        PriceOracle oldOracle = oracle;

        
        oracle = newOracle;

        
        emit NewPriceOracle(oldOracle, newOracle);

        return uint(Error.NO_ERROR);
    }

    
    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {
        
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);
        }

        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});
        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});
        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {
            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);
        }

        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});
        if (lessThanExp(highLimit, newCloseFactorExp)) {
            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);
        }

        uint oldCloseFactorMantissa = closeFactorMantissa;
        closeFactorMantissa = newCloseFactorMantissa;
        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    
    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {
        
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);
        }

        
        Market storage market = markets[address(cToken)];
        if (!market.isListed) {
            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);
        }

        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});

        
        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});
        if (lessThanExp(highLimit, newCollateralFactorExp)) {
            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);
        }

        
        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {
            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);
        }

        
        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;
        market.collateralFactorMantissa = newCollateralFactorMantissa;

        
        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);

        return uint(Error.NO_ERROR);
    }

    
    function _setMaxAssets(uint newMaxAssets) external returns (uint) {
        
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);
        }

        uint oldMaxAssets = maxAssets;
        maxAssets = newMaxAssets;
        emit NewMaxAssets(oldMaxAssets, newMaxAssets);

        return uint(Error.NO_ERROR);
    }

    
    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {
        
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);
        }

        
        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});
        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});
        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {
            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);
        }

        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});
        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {
            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);
        }

        
        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;

        
        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;

        
        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);

        return uint(Error.NO_ERROR);
    }

    
    function _supportMarket(CToken cToken) external returns (uint) {
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);
        }

        if (markets[address(cToken)].isListed) {
            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);
        }

        cToken.isCToken(); 

        markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0});

        _addMarketInternal(address(cToken));

        emit MarketListed(cToken);

        return uint(Error.NO_ERROR);
    }

    function _addMarketInternal(address cToken) internal {
        for (uint i = 0; i < allMarkets.length; i ++) {
            require(allMarkets[i] != CToken(cToken), ""market already added"");
        }
        allMarkets.push(CToken(cToken));
    }


    
    function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {
        require(msg.sender == admin || msg.sender == borrowCapGuardian, ""not an admin"");

        uint numMarkets = cTokens.length;
        uint numBorrowCaps = newBorrowCaps.length;

        require(numMarkets != 0 && numMarkets == numBorrowCaps, ""invalid input"");

        for(uint i = 0; i < numMarkets; i++) {
            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];
            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);
        }
    }

    
    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {
        require(msg.sender == admin, ""not an admin"");

        
        address oldBorrowCapGuardian = borrowCapGuardian;

        
        borrowCapGuardian = newBorrowCapGuardian;

        
        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);
    }

    
    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {
        if (msg.sender != admin) {
            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);
        }

        
        address oldPauseGuardian = pauseGuardian;

        
        pauseGuardian = newPauseGuardian;

        
        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);

        return uint(Error.NO_ERROR);
    }

    function _setMintPaused(CToken cToken, bool state) public returns (bool) {
        require(markets[address(cToken)].isListed, ""cannot pause a market that is not listed"");
        require(msg.sender == pauseGuardian || msg.sender == admin, ""only pause guardian and admin can pause"");
        require(msg.sender == admin || state == true, ""not an admin"");

        mintGuardianPaused[address(cToken)] = state;
        emit ActionPaused(cToken, ""Mint"", state);
        return state;
    }

    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {
        require(markets[address(cToken)].isListed, ""cannot pause a market that is not listed"");
        require(msg.sender == pauseGuardian || msg.sender == admin, ""only pause guardian and admin can pause"");
        require(msg.sender == admin || state == true, ""not an admin"");

        borrowGuardianPaused[address(cToken)] = state;
        emit ActionPaused(cToken, ""Borrow"", state);
        return state;
    }

    function _setTransferPaused(bool state) public returns (bool) {
        require(msg.sender == pauseGuardian || msg.sender == admin, ""only pause guardian and admin can pause"");
        require(msg.sender == admin || state == true, ""not an admin"");

        transferGuardianPaused = state;
        emit ActionPaused(""Transfer"", state);
        return state;
    }

    function _setSeizePaused(bool state) public returns (bool) {
        require(msg.sender == pauseGuardian || msg.sender == admin, ""only pause guardian and admin can pause"");
        require(msg.sender == admin || state == true, ""not an admin"");

        seizeGuardianPaused = state;
        emit ActionPaused(""Seize"", state);
        return state;
    }

    function _become(Unitroller unitroller) public {
        require(msg.sender == unitroller.admin(), ""only unitroller admin can change brains"");
        require(unitroller._acceptImplementation() == 0, ""change not authorized"");
    }

    
    function adminOrInitializing() internal view returns (bool) {
        return msg.sender == admin || msg.sender == comptrollerImplementation;
    }

    

    
    function refreshCompSpeeds() public {
        require(msg.sender == tx.origin, ""only externally owned accounts may refresh speeds"");
        refreshCompSpeedsInternal();
    }

    function refreshCompSpeedsInternal() internal {
        CToken[] memory allMarkets_ = allMarkets;

        for (uint i = 0; i < allMarkets_.length; i++) {
            CToken cToken = allMarkets_[i];
            Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
            updateCompSupplyIndex(address(cToken));
            updateCompBorrowIndex(address(cToken), borrowIndex);
        }

        Exp memory totalUtility = Exp({mantissa: 0});
        Exp[] memory utilities = new Exp[](allMarkets_.length);
        for (uint i = 0; i < allMarkets_.length; i++) {
            CToken cToken = allMarkets_[i];
            if (markets[address(cToken)].isComped) {
                Exp memory assetPrice = Exp({mantissa: oracle.getUnderlyingPrice(cToken)});
                Exp memory utility = mul_(assetPrice, cToken.totalBorrows());
                utilities[i] = utility;
                totalUtility = add_(totalUtility, utility);
            }
        }

        for (uint i = 0; i < allMarkets_.length; i++) {
            CToken cToken = allMarkets[i];
            uint newSpeed = totalUtility.mantissa > 0 ? mul_(compRate, div_(utilities[i], totalUtility)) : 0;
            compSpeeds[address(cToken)] = newSpeed;
            emit CompSpeedUpdated(cToken, newSpeed);
        }
    }

    
    function updateCompSupplyIndex(address cToken) internal {
        CompMarketState storage supplyState = compSupplyState[cToken];
        uint supplySpeed = compSpeeds[cToken];
        uint blockNumber = getBlockNumber();
        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));
        if (deltaBlocks > 0 && supplySpeed > 0) {
            uint supplyTokens = CToken(cToken).totalSupply();
            uint compAccrued = mul_(deltaBlocks, supplySpeed);
            Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa: 0});
            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);
            compSupplyState[cToken] = CompMarketState({
                index: safe224(index.mantissa, ""new index exceeds 224 bits""),
                block: safe32(blockNumber, ""block number exceeds 32 bits"")
            });
        } else if (deltaBlocks > 0) {
            supplyState.block = safe32(blockNumber, ""block number exceeds 32 bits"");
        }
    }

    
    function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {
        CompMarketState storage borrowState = compBorrowState[cToken];
        uint borrowSpeed = compSpeeds[cToken];
        uint blockNumber = getBlockNumber();
        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));
        if (deltaBlocks > 0 && borrowSpeed > 0) {
            uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);
            uint compAccrued = mul_(deltaBlocks, borrowSpeed);
            Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa: 0});
            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);
            compBorrowState[cToken] = CompMarketState({
                index: safe224(index.mantissa, ""new index exceeds 224 bits""),
                block: safe32(blockNumber, ""block number exceeds 32 bits"")
            });
        } else if (deltaBlocks > 0) {
            borrowState.block = safe32(blockNumber, ""block number exceeds 32 bits"");
        }
    }

    
    function distributeSupplierComp(address cToken, address supplier, bool distributeAll) internal {
        CompMarketState storage supplyState = compSupplyState[cToken];
        Double memory supplyIndex = Double({mantissa: supplyState.index});
        Double memory supplierIndex = Double({mantissa: compSupplierIndex[cToken][supplier]});
        compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;

        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {
            supplierIndex.mantissa = compInitialIndex;
        }

        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);
        uint supplierTokens = CToken(cToken).balanceOf(supplier);
        uint supplierDelta = mul_(supplierTokens, deltaIndex);
        uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);
        compAccrued[supplier] = transferComp(supplier, supplierAccrued, distributeAll ? 0 : compClaimThreshold);
        emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);
    }

    
    function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex, bool distributeAll) internal {
        CompMarketState storage borrowState = compBorrowState[cToken];
        Double memory borrowIndex = Double({mantissa: borrowState.index});
        Double memory borrowerIndex = Double({mantissa: compBorrowerIndex[cToken][borrower]});
        compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;

        if (borrowerIndex.mantissa > 0) {
            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);
            uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);
            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);
            uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);
            compAccrued[borrower] = transferComp(borrower, borrowerAccrued, distributeAll ? 0 : compClaimThreshold);
            emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);
        }
    }

    
    function transferComp(address user, uint userAccrued, uint threshold) internal returns (uint) {
        if (userAccrued >= threshold && userAccrued > 0) {
            Blo blo = Blo(getCompAddress());
            uint bloRemaining = blo.balanceOf(address(this));
            if (userAccrued <= bloRemaining) {
                blo.transfer(user, userAccrued);
                return 0;
            }
        }
        return userAccrued;
    }

    
    function claimComp(address holder) public {
        return claimComp(holder, allMarkets);
    }

    
    function claimComp(address holder, CToken[] memory cTokens) public {
        address[] memory holders = new address[](1);
        holders[0] = holder;
        claimComp(holders, cTokens, true, true);
    }

    
    function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i < cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, ""market must be listed"");
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j < holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j < holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }

    

    
    function _setCompAddress(address _comp) public {
        require(msg.sender == admin, ""not an admin"");
        comp = _comp;
    }

    
    function _setCompRate(uint compRate_) public {
        require(adminOrInitializing(), ""not an admin"");

        uint oldRate = compRate;
        compRate = compRate_;
        emit NewCompRate(oldRate, compRate_);

        refreshCompSpeedsInternal();
    }

    
    function _addCompMarkets(address[] memory cTokens) public {
        require(adminOrInitializing(), ""not an admin"");

        for (uint i = 0; i < cTokens.length; i++) {
            _addCompMarketInternal(cTokens[i]);
        }

        refreshCompSpeedsInternal();
    }

    function _addCompMarketInternal(address cToken) internal {
        Market storage market = markets[cToken];
        require(market.isListed == true, ""comp market is not listed"");
        require(market.isComped == false, ""comp market already added"");

        market.isComped = true;
        emit MarketComped(CToken(cToken), true);

        if (compSupplyState[cToken].index == 0 && compSupplyState[cToken].block == 0) {
            compSupplyState[cToken] = CompMarketState({
                index: compInitialIndex,
                block: safe32(getBlockNumber(), ""block number exceeds 32 bits"")
            });
        }

        if (compBorrowState[cToken].index == 0 && compBorrowState[cToken].block == 0) {
            compBorrowState[cToken] = CompMarketState({
                index: compInitialIndex,
                block: safe32(getBlockNumber(), ""block number exceeds 32 bits"")
            });
        }
    }

    
    function _dropCompMarket(address cToken) public {
        require(msg.sender == admin, ""not an admin"");

        Market storage market = markets[cToken];
        require(market.isComped == true, ""market is not a comp market"");

        market.isComped = false;
        emit MarketComped(CToken(cToken), false);

        refreshCompSpeedsInternal();
    }

    
    function getAllMarkets() public view returns (CToken[] memory) {
        return allMarkets;
    }

    function getBlockNumber() public view returns (uint) {
        return block.number;
    }

    
    function getCompAddress() public view returns (address) {
        return comp;
    }
}",8743,0,1,"{'task_list': [{'Area': 'Access Control', 'Tasks': ['Verify that only the `admin` can call functions intended for admin use (e.g., `_setPriceOracle`, `_setCloseFactor`, `_setCollateralFactor`, `_setMaxAssets`, `_setLiquidationIncentive`, `_supportMarket`, `_setMarketBorrowCaps`, `_setBorrowCapGuardian`, `_setPauseGuardian`, `_setCompAddress`, `_setCompRate`, `_addCompMarkets`, `_dropCompMarket`).', ""Confirm that the `pauseGuardian` can only call pause-related functions (`_setMintPaused`, `_setBorrowPaused`, `_setTransferPaused`, `_setSeizePaused`) and that it can only pause and not unpause actions unless it's also the `admin`."", 'Check the logic in `_setMarketBorrowCaps` to ensure that either `admin` or `borrowCapGuardian` can call this function and that the function correctly sets the borrow caps for the given CToken addresses.', ""Analyze the `adminOrInitializing` modifier and verify it's used correctly in `_setCompRate` and `_addCompMarkets` to allow Comptroller implementation contract to initialize COMP markets and rate when the contract is deployed for the first time."", ""Verify that the Unitroller's admin is the only one who can call the `_become` function to change the Comptroller implementation.""]}, {'Area': 'Liquidity and Solvency Checks', 'Tasks': ['Thoroughly examine the `getHypotheticalAccountLiquidityInternal` function, paying close attention to the calculations and potential rounding errors in the `mulExp3` and `mulScalarTruncateAddUInt` functions.', 'Verify that the price oracle (`oracle`) returns reasonable and up-to-date prices and that a zero price is properly handled to prevent division-by-zero errors or incorrect liquidity calculations.', 'Analyze the impact of large `redeemTokens` or `borrowAmount` values on the `getHypotheticalAccountLiquidityInternal` function to ensure that calculations remain accurate and prevent potential overflows or underflows.', ""Ensure that `getAccountLiquidity` and `getHypotheticalAccountLiquidity` return consistent results when no modifications are made to the account's position (i.e., `cTokenModify` is zero, `redeemTokens` and `borrowAmount` are zero)."", 'Review all usages of `getAccountLiquidityInternal` and `getHypotheticalAccountLiquidityInternal` in the `*Allowed` functions to ensure that insufficient liquidity always prevents the corresponding action.']}, {'Area': 'COMP/BLO Distribution Mechanism', 'Tasks': ['Analyze the `refreshCompSpeedsInternal` function and verify that the COMP distribution speeds are calculated correctly based on total borrows, asset prices, and the global COMP rate.', 'Review the `updateCompSupplyIndex` and `updateCompBorrowIndex` functions to ensure that the COMP indices are updated accurately and that block number differences are handled correctly, especially in cases of infrequent or very frequent updates.', 'Examine the `distributeSupplierComp` and `distributeBorrowerComp` functions to ensure that COMP tokens are distributed fairly to suppliers and borrowers and that the accrued amounts are calculated correctly based on index changes and token balances.', 'Investigate the `transferComp` function to ensure that COMP tokens are transferred correctly from the Comptroller to users and that the `compClaimThreshold` is respected. Check for potential issues if the Comptroller runs out of COMP tokens.', 'Verify the `claimComp` function to ensure it correctly distributes accrued COMP tokens for borrowers and suppliers across multiple markets, addressing any potential reentrancy issues.', ""Check that the `compInitialIndex` (1e36) is appropriate for the exponential calculations and doesn't cause unexpected behavior, especially for new users."", 'Ensure that the `safe224` and `safe32` functions prevent overflow issues when storing the index and block numbers respectively.', 'Confirm that the COMP token address (`comp`) is correctly set and accessible through the `getCompAddress` function.', 'Review the use of `msg.sender == tx.origin` in `refreshCompSpeeds` and ensure that this restriction is justified and does not introduce unintended consequences or denial-of-service vulnerabilities. Determine if a more granular approach is possible.', 'Assess the potential for manipulation of borrow amounts or asset prices to artificially inflate COMP distribution speeds for certain markets or users.']}, {'Area': 'Market Management', 'Tasks': ['Verify that the `_supportMarket` function correctly adds a new CToken market to the `markets` mapping and the `allMarkets` array and that the `isCToken()` check prevents non-CToken contracts from being listed.', 'Ensure that the `enterMarkets` and `exitMarket` functions correctly manage user membership in markets and update the `accountAssets` mapping.', 'Check the logic in `exitMarket` to ensure that users cannot exit a market if they have an outstanding borrow balance or if the redeem is not allowed.', 'Analyze the `_setMarketBorrowCaps` function to ensure that borrow caps are correctly set and enforced and that the `borrowCapGuardian` can only set caps and not perform other administrative actions.', 'Verify that the `_addMarketInternal` function prevents adding the same market twice.', 'Review the `_setCompAddress` function to prevent setting the comp address to an arbitrary address.']}, {'Area': 'Pause Functionality', 'Tasks': ['Confirm that the `_setMintPaused`, `_setBorrowPaused`, `_setTransferPaused`, and `_setSeizePaused` functions correctly pause and unpause the corresponding actions and that the appropriate events are emitted.', 'Ensure that the pause functionality is properly integrated into the `*Allowed` functions to prevent users from performing paused actions.', 'Analyze the potential for denial-of-service attacks by pausing critical actions and determine if there are any mechanisms to prevent or mitigate such attacks.', 'Verify that only `pauseGuardian` and `admin` can pause an action but only `admin` can unpause an action.']}, {'Area': 'Arithmetic Safety', 'Tasks': [""Review all arithmetic operations (addition, subtraction, multiplication, division) to ensure that they are performed safely using libraries like SafeMath or Solidity 0.8's built-in overflow/underflow protection. Note that this code uses Solidity 0.6, so extra care is warranted."", 'Pay close attention to the `mulScalarTruncate`, `mulExp`, `divExp`, `add_`, `sub_`, and `fraction` functions and verify that they handle large numbers and potential rounding errors correctly.', 'Specifically check the calculations in `getHypotheticalAccountLiquidityInternal` and `liquidateCalculateSeizeTokens` for potential overflows or underflows.', 'Review the `safe224` and `safe32` functions to ensure data is truncated correctly and does not cause unexpected behavior.']}, {'Area': 'External Interactions', 'Tasks': ['Review all external calls to CToken contracts, the price oracle, and the COMP token contract to ensure that they are performed safely and that the Comptroller handles potential errors or reverts correctly.', 'Analyze the potential for reentrancy attacks when calling external contracts and implement appropriate safeguards, such as the checks-effects-interactions pattern.', 'Verify that the price oracle is a trusted source of price data and that the Comptroller handles stale or manipulated prices gracefully.', 'Check the potential for denial of service attacks through failed external calls, particularly with the oracle.']}, {'Area': 'Unused/Placeholder Logic', 'Tasks': ['Investigate the purpose of the `*Verify` functions (e.g., `mintVerify`, `borrowVerify`, `liquidateBorrowVerify`) and determine if they are intended for future extensions or if they can be safely removed. If they are necessary, ensure they contain appropriate logic.', 'If the `*Verify` functions are intended for future use, consider adding comments explaining their purpose and potential use cases.']}]}","{'ReviewingTheCode': ""The Comptroller contract serves as the central risk management and logic hub for a Compound-style lending protocol. It manages market listings, collateral factors, liquidation parameters, and enforces permission checks for core user actions (mint, redeem, borrow, repay, liquidate, seize, transfer) executed via CToken contracts. It calculates account liquidity to ensure solvency and orchestrates the distribution of the protocol's governance token (COMP/BLO) to suppliers and borrowers."", 'IdentifyingKeyComponents': {'ContractName': 'Comptroller', 'Purpose': 'Acts as the central controller and risk manager for the lending protocol, handling market operations, permissions, liquidity checks, and COMP token distribution.', 'InheritanceAndImports': {'InheritsFrom': ['ComptrollerV4Storage', 'ComptrollerInterface', 'ComptrollerErrorReporter', 'Exponential'], 'Imports': ['./CToken.sol', './ErrorReporter.sol', './Exponential.sol', './PriceOracle.sol', './ComptrollerInterface.sol', './ComptrollerStorage.sol', './Unitroller.sol', './Governance/Blo.sol']}, 'StateVariables': [{'Name': 'admin', 'Type': 'address', 'Purpose': 'The primary administrative address with privileges to change critical parameters.'}, {'Name': 'pauseGuardian', 'Type': 'address', 'Purpose': 'An address that can pause certain actions (mint, borrow, transfer, seize), but typically cannot unpause them.'}, {'Name': 'oracle', 'Type': 'PriceOracle', 'Purpose': 'The contract used to fetch asset prices.'}, {'Name': 'markets', 'Type': 'mapping(address => Market)', 'Purpose': 'Stores information about each CToken market, including listing status, collateral factor, and user membership.'}, {'Name': 'accountAssets', 'Type': 'mapping(address => CToken[])', 'Purpose': 'Lists the markets entered by each account for collateral.'}, {'Name': 'closeFactorMantissa', 'Type': 'uint', 'Purpose': ""The maximum fraction of a borrower's debt that can be repaid in a single liquidation event.""}, {'Name': 'liquidationIncentiveMantissa', 'Type': 'uint', 'Purpose': 'The additional collateral bonus awarded to liquidators.'}, {'Name': 'maxAssets', 'Type': 'uint', 'Purpose': 'The maximum number of markets an account can enter.'}, {'Name': 'borrowCaps', 'Type': 'mapping(address => uint)', 'Purpose': 'Optional per-market limits on total borrows.'}, {'Name': 'borrowCapGuardian', 'Type': 'address', 'Purpose': 'An address (besides admin) allowed to set borrow caps.'}, {'Name': 'mintGuardianPaused', 'Type': 'mapping(address => bool)', 'Purpose': 'Pause flag for minting specific CToken markets.'}, {'Name': 'borrowGuardianPaused', 'Type': 'mapping(address => bool)', 'Purpose': 'Pause flag for borrowing specific CToken markets.'}, {'Name': 'transferGuardianPaused', 'Type': 'bool', 'Purpose': 'Global pause flag for transferring CTokens.'}, {'Name': 'seizeGuardianPaused', 'Type': 'bool', 'Purpose': 'Global pause flag for seizing collateral in liquidations.'}, {'Name': 'comp', 'Type': 'address', 'Purpose': 'The address of the COMP/BLO token contract.'}, {'Name': 'compRate', 'Type': 'uint', 'Purpose': 'The global rate at which COMP tokens are distributed per block across all markets.'}, {'Name': 'compSpeeds', 'Type': 'mapping(address => uint)', 'Purpose': 'The rate at which COMP tokens are distributed per block for a specific market.'}, {'Name': 'compSupplyState', 'Type': 'mapping(address => CompMarketState)', 'Purpose': 'Stores the supply-side COMP distribution state (index, block) for each market.'}, {'Name': 'compBorrowState', 'Type': 'mapping(address => CompMarketState)', 'Purpose': 'Stores the borrow-side COMP distribution state (index, block) for each market.'}, {'Name': 'compAccrued', 'Type': 'mapping(address => uint)', 'Purpose': 'Stores the amount of COMP tokens accrued by each user but not yet claimed/transferred.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract by setting the admin.', 'Parameters': [], 'Returns': []}, {'Name': 'enterMarkets', 'Visibility': 'public', 'Purpose': 'Allows a user to designate multiple CToken assets as collateral.', 'Parameters': ['address[] memory cTokens'], 'Returns': ['uint[] memory']}, {'Name': 'exitMarket', 'Visibility': 'external', 'Purpose': 'Allows a user to remove a CToken asset from their collateral list, provided they have no outstanding borrow in that market and remain solvent.', 'Parameters': ['address cTokenAddress'], 'Returns': ['uint']}, {'Name': 'mintAllowed', 'Visibility': 'external', 'Purpose': 'Hook called by a CToken before minting. Checks market listing and pause status. Updates COMP distribution state.', 'Parameters': ['address cToken', 'address minter', 'uint mintAmount'], 'Returns': ['uint']}, {'Name': 'redeemAllowed', 'Visibility': 'external', 'Purpose': 'Hook called by a CToken before redeeming. Checks market listing, pause status, and account solvency (liquidity). Updates COMP distribution state.', 'Parameters': ['address cToken', 'address redeemer', 'uint redeemTokens'], 'Returns': ['uint']}, {'Name': 'borrowAllowed', 'Visibility': 'external', 'Purpose': 'Hook called by a CToken before borrowing. Checks market listing, pause status, price validity, borrow caps, and account solvency (liquidity). Updates COMP distribution state.', 'Parameters': ['address cToken', 'address borrower', 'uint borrowAmount'], 'Returns': ['uint']}, {'Name': 'repayBorrowAllowed', 'Visibility': 'external', 'Purpose': 'Hook called by a CToken before repaying a borrow. Checks market listing. Updates COMP distribution state.', 'Parameters': ['address cToken', 'address payer', 'address borrower', 'uint repayAmount'], 'Returns': ['uint']}, {'Name': 'liquidateBorrowAllowed', 'Visibility': 'external', 'Purpose': 'Hook called by a CToken before liquidating a borrow. Checks market listings, borrower shortfall, and if repay amount exceeds close factor limit.', 'Parameters': ['address cTokenBorrowed', 'address cTokenCollateral', 'address liquidator', 'address borrower', 'uint repayAmount'], 'Returns': ['uint']}, {'Name': 'seizeAllowed', 'Visibility': 'external', 'Purpose': 'Hook called by a CToken before seizing collateral. Checks market listings, pause status, and comptroller consistency. Updates COMP distribution state for involved parties.', 'Parameters': ['address cTokenCollateral', 'address cTokenBorrowed', 'address liquidator', 'address borrower', 'uint seizeTokens'], 'Returns': ['uint']}, {'Name': 'transferAllowed', 'Visibility': 'external', 'Purpose': 'Hook called by a CToken before transferring CTokens. Checks pause status and solvency of the source account. Updates COMP distribution state for involved parties.', 'Parameters': ['address cToken', 'address src', 'address dst', 'uint transferTokens'], 'Returns': ['uint']}, {'Name': 'getAccountLiquidity', 'Visibility': 'public', 'Purpose': 'Calculates the total collateral value minus total borrow value for an account, returning liquidity or shortfall.', 'Parameters': ['address account'], 'Returns': ['uint', 'uint', 'uint']}, {'Name': 'getHypotheticalAccountLiquidity', 'Visibility': 'public', 'Purpose': 'Calculates account liquidity *as if* a redeem or borrow action occurred.', 'Parameters': ['address account', 'address cTokenModify', 'uint redeemTokens', 'uint borrowAmount'], 'Returns': ['uint', 'uint', 'uint']}, {'Name': 'liquidateCalculateSeizeTokens', 'Visibility': 'external', 'Purpose': 'Calculates the number of collateral tokens a liquidator should receive based on the amount repaid, prices, exchange rate, and liquidation incentive.', 'Parameters': ['address cTokenBorrowed', 'address cTokenCollateral', 'uint actualRepayAmount'], 'Returns': ['uint', 'uint']}, {'Name': '_setPriceOracle', 'Visibility': 'public', 'Purpose': 'Admin function to set the price oracle address.', 'Parameters': ['PriceOracle newOracle'], 'Returns': ['uint']}, {'Name': '_setCollateralFactor', 'Visibility': 'external', 'Purpose': 'Admin function to set the collateral factor for a market.', 'Parameters': ['CToken cToken', 'uint newCollateralFactorMantissa'], 'Returns': ['uint']}, {'Name': '_supportMarket', 'Visibility': 'external', 'Purpose': 'Admin function to list a new CToken market.', 'Parameters': ['CToken cToken'], 'Returns': ['uint']}, {'Name': '_setPauseGuardian', 'Visibility': 'public', 'Purpose': 'Admin function to set the pause guardian address.', 'Parameters': ['address newPauseGuardian'], 'Returns': ['uint']}, {'Name': '_setMintPaused', 'Visibility': 'public', 'Purpose': 'Admin/PauseGuardian function to pause/unpause minting for a market.', 'Parameters': ['CToken cToken', 'bool state'], 'Returns': ['bool']}, {'Name': '_become', 'Visibility': 'public', 'Purpose': 'Allows the admin of the Unitroller proxy to upgrade the Comptroller implementation.', 'Parameters': ['Unitroller unitroller'], 'Returns': []}, {'Name': 'refreshCompSpeeds', 'Visibility': 'public', 'Purpose': 'Recalculates and updates COMP distribution speeds for all markets based on current borrow activity and total COMP rate. Requires call from EOA.', 'Parameters': [], 'Returns': []}, {'Name': 'claimComp(address)', 'Visibility': 'public', 'Purpose': 'Distributes accrued COMP for all markets to the specified holder.', 'Parameters': ['address holder'], 'Returns': []}, {'Name': 'claimComp(address[], CToken[], bool, bool)', 'Visibility': 'public', 'Purpose': 'Distributes accrued COMP for specified markets and user types (borrowers/suppliers) to the specified holders.', 'Parameters': ['address[] memory holders', 'CToken[] memory cTokens', 'bool borrowers', 'bool suppliers'], 'Returns': []}, {'Name': '_setCompRate', 'Visibility': 'public', 'Purpose': 'Admin function to set the global COMP distribution rate per block.', 'Parameters': ['uint compRate_'], 'Returns': []}, {'Name': '_addCompMarkets', 'Visibility': 'public', 'Purpose': 'Admin function to enable COMP distribution for specified markets.', 'Parameters': ['address[] memory cTokens'], 'Returns': []}, {'Name': '_dropCompMarket', 'Visibility': 'public', 'Purpose': 'Admin function to disable COMP distribution for a specified market.', 'Parameters': ['address cToken'], 'Returns': []}]}, 'ExternalInteractions': ['CToken Contracts: Calls various functions on CToken instances (e.g., `getAccountSnapshot`, `totalBorrows`, `borrowIndex`, `exchangeRateStored`, `balanceOf`, `totalSupply`, `comptroller`, `isCToken`). Also, CToken contracts call back into Comptroller for permission checks (e.g., `mintAllowed`, `borrowAllowed`).', 'PriceOracle Contract: Calls `getUnderlyingPrice` to fetch asset prices for liquidity calculations and setting collateral factors.', 'Blo (COMP Token) Contract: Calls `transfer` to distribute claimed COMP tokens and `balanceOf` to check available COMP for distribution.', 'Unitroller Contract: Interacts with Unitroller during the `_become` function call for proxy implementation upgrades (`unitroller.admin()`, `unitroller._acceptImplementation()`).'], 'SpecialMechanisms': ['Proxy Pattern Implementation: The `_become` function and interaction with `Unitroller` strongly suggest this contract is intended as an implementation for a Unitroller proxy, allowing for upgradeability.', 'Guardian Roles: Utilizes `pauseGuardian` and `borrowCapGuardian` for specific, limited administrative capabilities separate from the main `admin`.', 'COMP Distribution Algorithm: Implements a Compound-style distribution mechanism using per-market supply/borrow indices (`compSupplyState`, `compBorrowState`) that accrue over time based on `compSpeeds`. User rewards are calculated based on index changes and their participation.', 'Hypothetical Liquidity Calculation: Uses `getHypotheticalAccountLiquidityInternal` to check solvency *before* potentially risky actions (redeem, borrow) are executed.', ""Hook-Based Permissions: Acts as a central authority where CToken contracts 'hook' into via functions like `mintAllowed`, `borrowAllowed` etc., to get permission before executing core protocol actions.""], 'Questions': ['The `*Verify` functions (e.g., `mintVerify`, `borrowVerify`, `liquidateBorrowVerify`) appear to be largely unused or contain placeholder logic (`maxAssets = maxAssets`). What is their intended purpose? Are they for future extensions or simply to satisfy the interface?', 'The `refreshCompSpeeds` function requires `msg.sender == tx.origin`. What is the specific security reason for preventing contract-based calls to refresh speeds?', ""Is the `compInitialIndex` (1e36) value chosen specifically to interact with the `Exponential.sol` library's scaling factor, or does it have another significance in the distribution calculation, particularly for the first time a user interacts?"", 'How is atomicity handled between the CToken action (e.g., `mint`) and the Comptroller checks (`mintAllowed`, `mintVerify`)? Does the CToken call both within the same transaction?']}","{'Findings': [{'Issue': 'Centralized Control over Critical Parameters and Functions', 'Severity': 'High', 'Description': 'The `admin` role possesses extensive control over critical protocol parameters and functions. This includes setting the price oracle, COMP token address, COMP distribution rate, close factor, collateral factors, liquidation incentive, borrow caps, pausing/unpausing core functions (mint, borrow, transfer, seize), managing COMP markets (`_addCompMarkets`, `_dropCompMarket`), and setting guardians (`_setPauseGuardian`, `_setBorrowCapGuardian`). If the admin key/account is compromised, an attacker could manipulate these settings to drain funds, disrupt the protocol, freeze markets, cause unfair liquidations, or alter reward distributions significantly. The `pauseGuardian` also has significant power to halt core functions.', 'Impact': 'Complete protocol takeover, theft of funds, unfair liquidations, manipulation of reward distribution, denial of service, and significant financial loss for users if the admin or pauseGuardian key is compromised.', 'Location': 'Multiple functions including: _setPriceOracle, _setCompAddress, _setCompRate, _setCloseFactor, _setCollateralFactor, _setLiquidationIncentive, _setMarketBorrowCaps, _setPauseGuardian, _setMintPaused, _setBorrowPaused, _setTransferPaused, _setSeizePaused, _addCompMarkets, _dropCompMarket, _supportMarket, _setMaxAssets, _setBorrowCapGuardian, admin, pauseGuardian'}, {'Issue': 'Potential Reentrancy Vulnerability in COMP Reward Distribution', 'Severity': 'High', 'Description': ""The functions `distributeSupplierComp` and `distributeBorrowerComp`, often called via `claimComp`, use `transferComp` to send COMP tokens. `transferComp` performs an external call (`blo.transfer`). If the COMP token (`blo`) is malicious or has a callback mechanism, it could re-enter the Comptroller contract before the user's COMP state is fully updated (e.g., `compAccrued` is set to zero after the transfer). This could allow an attacker to drain COMP tokens by repeatedly claiming rewards within a single transaction."", 'Impact': 'Loss of COMP tokens from the Comptroller contract, incorrect reward distribution, disruption of the rewards mechanism.', 'Location': 'Comptroller.sol: claimComp, distributeSupplierComp, distributeBorrowerComp, transferComp'}, {'Issue': 'Unprotected `_setCompAddress` Function', 'Severity': 'High', 'Description': 'The `_setCompAddress` function, critical for setting the COMP token contract address used for rewards, is only protected by an `admin` check. If the admin is compromised or makes an error, an incorrect or malicious address could be set. This would prevent legitimate COMP distribution and could potentially lead to users interacting with a fraudulent token contract.', 'Impact': 'Failure of COMP reward distribution, potential loss of funds if users interact with a malicious token contract set as the COMP address.', 'Location': 'Comptroller.sol: _setCompAddress'}, {'Issue': 'Reliance on External Price Oracle', 'Severity': 'High', 'Description': 'The Comptroller heavily relies on an external `PriceOracle` contract to determine asset values for liquidity calculations, collateral requirements, and liquidations. If this oracle is compromised, manipulated, or provides inaccurate data, the entire protocol can become unstable. Incorrect prices can lead to unfair liquidations, prevent borrowing, allow undercollateralized borrowing, or skew COMP distribution calculations. Furthermore, the `admin` can change the oracle address (`_setPriceOracle`), introducing a risk if the admin is compromised.', 'Impact': 'System-wide instability, incorrect liquidations leading to user fund loss, prevention of borrowing/lending, potential protocol insolvency, manipulation of COMP distribution, and risk of setting a malicious oracle.', 'Location': 'Comptroller.sol: Multiple functions using `oracle.getUnderlyingPrice()`, getHypotheticalAccountLiquidityInternal, liquidateCalculateSeizeTokens, _setPriceOracle, refreshCompSpeedsInternal'}, {'Issue': 'Potential Division by Zero in Borrow Index Update and Distribution', 'Severity': 'High', 'Description': ""The `updateCompBorrowIndex` and `distributeBorrowerComp` functions perform divisions involving `marketBorrowIndex` (derived from `CToken.borrowIndex()`). If a market's `borrowIndex` is or becomes zero, these functions will revert due to a division-by-zero error. This would halt COMP distribution calculations for borrowers in that market."", 'Impact': 'Denial of service for COMP distribution updates and claims for borrowers in the affected market, potentially halting critical protocol functions.', 'Location': 'Comptroller.sol: updateCompBorrowIndex, distributeBorrowerComp'}, {'Issue': 'Potential Integer Overflow/Underflow in COMP Distribution and Speed Calculations', 'Severity': 'Medium', 'Description': 'Multiple functions involved in calculating and distributing COMP rewards (`updateCompSupplyIndex`, `updateCompBorrowIndex`, `distributeSupplierComp`, `distributeBorrowerComp`, `refreshCompSpeedsInternal`) perform complex arithmetic operations (multiplication, division, addition, subtraction) on potentially large values like token balances, speeds, indices, and block differences. While SafeMath-like functions (`mul_`, `div_`, `add_`, `sub_`, `safe32`) are used in places, overflows or underflows could still occur in intermediate calculations (e.g., `mul_(deltaBlocks, speed)`, `mul_(assetPrice, cToken.totalBorrows())`, `fraction` calculation) before the safe math operations are applied, or due to the nature of the fixed-point math (`Exponential.sol`). This can lead to incorrect reward amounts, precision loss, or unexpected reverts.', 'Impact': 'Incorrect COMP accrual and distribution, unfair rewards, potential reverts halting reward updates or claims, inaccurate market state updates.', 'Location': 'Comptroller.sol: updateCompSupplyIndex, updateCompBorrowIndex, distributeSupplierComp, distributeBorrowerComp, refreshCompSpeedsInternal, fraction'}, {'Issue': 'Missing Input Validation in `_setMarketBorrowCaps`', 'Severity': 'Medium', 'Description': 'The `_setMarketBorrowCaps` function checks that the input arrays `cTokens` and `newBorrowCaps` have equal non-zero lengths. However, it fails to validate that the addresses in the `cTokens` array correspond to actual, listed markets within the Comptroller or that the `newBorrowCaps` values are reasonable (e.g., non-negative). Setting caps for non-existent markets or setting extremely low caps could lead to errors or effectively freeze borrowing in legitimate markets.', 'Impact': 'Possibility of setting invalid borrow caps for non-existent or valid markets, potentially freezing markets, causing confusion, or leading to errors in external systems relying on this data.', 'Location': 'Comptroller.sol: _setMarketBorrowCaps'}, {'Issue': 'Incorrect Calculation in `getHypotheticalAccountLiquidityInternal`', 'Severity': 'Medium', 'Description': 'The `getHypotheticalAccountLiquidityInternal` function incorrectly calculates `vars.sumBorrowPlusEffects` when modifying a cToken (`asset == cTokenModify`). It appears to add the value of redeemed tokens (factoring in collateral factor) to the borrow side, which is logically incorrect. Redeemed tokens should reduce collateral (`sumCollateral`), and borrowed amounts should increase borrows (`sumBorrowPlusEffects` scaled by oracle price). The use of `mulScalarTruncateAddUInt` might also lead to inaccuracies or DOS if intermediate multiplication results overflow before addition, causing truncation.', 'Impact': 'Flawed account liquidity calculation, leading to incorrect risk assessment. This could result in wrongful liquidations, allowing overly risky borrows, or causing Denial-of-Service by incorrectly reporting shortfalls.', 'Location': 'Comptroller.sol: getHypotheticalAccountLiquidityInternal'}, {'Issue': 'Lack of Robust Access Control on `refreshCompSpeeds`', 'Severity': 'Medium', 'Description': 'The `refreshCompSpeeds` function, which recalculates COMP distribution speeds based on market conditions and oracle prices, is only restricted to Externally Owned Accounts (`msg.sender == tx.origin`). This prevents direct calls from other contracts but does not stop EOAs from potentially manipulating the timing of calls. Malicious users could front-run or repeatedly call this function, potentially manipulating market conditions just prior to the call to skew COMP distribution temporarily, grief users by increasing gas costs, or cause minor Denial-of-Service.', 'Impact': 'Potential for griefing attacks, minor manipulation of COMP distribution fairness, reduced composability, and potential DoS through excessive gas consumption.', 'Location': 'Comptroller.sol: refreshCompSpeeds, refreshCompSpeedsInternal'}, {'Issue': 'Unprotected `_setCompRate` Initialization', 'Severity': 'Medium', 'Description': 'The `_setCompRate` function can be called during the initialization phase by the `comptrollerImplementation`. If the initialization logic is flawed, compromised, or performed by a rogue implementation, the COMP distribution rate could be set to an arbitrary, potentially harmful value (e.g., excessively high or zero).', 'Impact': 'Incorrect initial COMP distribution rate leading to unfair rewards, economic imbalances, or denial of rewards if set improperly during initialization.', 'Location': 'Comptroller.sol: _setCompRate'}, {'Issue': '`claimComp` Allows Triggering Distributions for Others (Griefing Potential)', 'Severity': 'Medium', 'Description': 'The `claimComp` function permits any address to trigger COMP distribution for any other specified `holder` address(es). While potentially useful, this can be abused for griefing. A malicious actor could repeatedly call `claimComp` for a target user, forcing them to incur gas costs associated with the distribution logic, especially if the calculations are complex or involve many markets.', 'Impact': 'Potential for griefing attacks by forcing users to spend gas on unwanted `claimComp` transactions. Could contribute to network congestion or minor DoS against specific users.', 'Location': 'Comptroller.sol: claimComp'}, {'Issue': 'Unbounded Loops Leading to Potential DoS', 'Severity': 'Medium', 'Description': 'Functions like `_addMarketInternal`, `refreshCompSpeedsInternal`, and `claimComp` iterate through lists (`allMarkets`, `holders`, `cTokens`) that can potentially grow very large. If the number of markets or holders becomes substantial, the gas cost of executing these functions could exceed the block gas limit, leading to Denial of Service (DoS). Users might be unable to claim rewards, or governance might be unable to add markets or refresh speeds.', 'Impact': 'Denial of service for critical functions like claiming rewards, adding markets, or refreshing speeds if lists become too large. Scalability issues.', 'Location': 'Comptroller.sol: _addMarketInternal, refreshCompSpeedsInternal, claimComp'}, {'Issue': 'Inconsistent or Missing SafeMath Usage', 'Severity': 'Medium', 'Description': 'The contract uses a mix of custom arithmetic functions (e.g., `add_`, `sub_`, `mul_`, `div_` from `Exponential.sol`) and some SafeMath-like functions (`addUInt`, `mulScalarTruncateAddUInt`). While `Exponential.sol` likely includes checks, relying solely on a standard, well-audited SafeMath library for all arithmetic operations outside of fixed-point math would improve robustness and reduce the risk of subtle overflow/underflow bugs, especially in critical calculations involving economic parameters.', 'Impact': 'Potential for unexpected arithmetic errors (overflows/underflows) in critical calculations if custom functions have edge cases or are not universally applied, leading to incorrect protocol behavior or vulnerabilities.', 'Location': 'Multiple locations throughout the contract.'}, {'Issue': 'Unsafe Downcasting', 'Severity': 'Medium', 'Description': 'The `safe32` and `safe224` functions cast larger uint types down to `uint32` and `uint224`, respectively, reverting if the input value exceeds the maximum representable value of the target type. If functions like `updateCompSupplyIndex` or `updateCompBorrowIndex` receive unexpectedly large block numbers or other inputs leading to large intermediate values, these casts could cause reverts.', 'Impact': 'Unexpected reverts in core logic (e.g., reward index updates), leading to denial of service for reward calculations.', 'Location': 'Comptroller.sol: updateCompSupplyIndex, updateCompBorrowIndex (via safe32, safe224)'}, {'Issue': 'Unprotected `_become` Function relies on External Security', 'Severity': 'Medium', 'Description': ""The `_become` function allows the `Unitroller` (proxy) to change the Comptroller implementation address. While it checks that the caller is the `Unitroller`'s admin and that the change is authorized by the `Unitroller`, the security relies entirely on the `Unitroller` contract. A vulnerability or admin compromise in the `Unitroller` could allow a malicious implementation to be set for the Comptroller."", 'Impact': 'Potential for complete protocol takeover via malicious implementation upgrade if the Unitroller contract or its admin is compromised.', 'Location': 'Comptroller.sol: _become'}, {'Issue': '`claimComp` Does Not Handle Failed Token Transfers', 'Severity': 'Medium', 'Description': ""The `transferComp` function, called by `claimComp`, executes `Blo.transfer(user, userAccrued)` but does not check the boolean return value of the transfer. If the underlying COMP token transfer fails (e.g., insufficient Comptroller balance, user address issues, ERC20 transfer restrictions), the transaction will not revert. However, the user's `compAccrued` balance in the Comptroller will still be set to 0, causing the user to lose their claimable COMP."", 'Impact': 'Users can permanently lose their accrued COMP rewards if the `Blo.transfer` call fails silently.', 'Location': 'Comptroller.sol: transferComp'}, {'Issue': 'Potential Front-Running in `refreshCompSpeeds` or Governance Actions', 'Severity': 'Low', 'Description': 'The `refreshCompSpeeds` function recalculates COMP speeds based on current market states (prices, borrows). A knowledgeable attacker could potentially front-run this call by manipulating market conditions (e.g., large temporary borrow/supply) to briefly skew the calculated speeds in their favor. Similarly, administrative actions set via governance (e.g., changing collateral factors, price oracles) visible in the mempool could be front-run by users seeking to exploit the brief period before the change takes effect.', 'Impact': 'Minor unfairness in COMP distribution or temporary exploitation of governance changes.', 'Location': 'Comptroller.sol: refreshCompSpeeds, Multiple admin-controlled functions'}, {'Issue': 'Incorrect Usage of `lessThanOrEqualExp` and `lessThanExp`', 'Severity': 'Low', 'Description': 'The functions `_setCloseFactor` and `_setLiquidationIncentive` use `lessThanOrEqualExp` and `lessThanExp` for validating input parameters represented as `Exp` values. Comparisons involving fixed-point `Exp` values can suffer from precision issues, potentially leading to unexpected validation failures or successes depending on the exact mantissa values, even if the intended numerical comparison should pass/fail.', 'Impact': 'Validation checks for setting close factor and liquidation incentive might behave unexpectedly due to precision issues, potentially preventing valid settings or allowing invalid ones in edge cases.', 'Location': 'Comptroller.sol: _setCloseFactor, _setLiquidationIncentive'}, {'Issue': 'COMP Claim Threshold is Arbitrary Constant', 'Severity': 'Low', 'Description': 'The `compClaimThreshold` is hardcoded to `0.001e18`. This fixed value might not be optimal under varying network conditions or gas prices. A high threshold could delay claims, while a low one might encourage frequent, potentially gas-inefficient claims. Making this configurable by governance could offer more flexibility.', 'Impact': 'Suboptimal user experience regarding COMP claiming frequency and gas costs. Cannot be adjusted without contract redeployment.', 'Location': 'Comptroller.sol: compClaimThreshold'}, {'Issue': 'Usage of `assert` in `exitMarket` function', 'Severity': 'Low', 'Description': 'The `exitMarket` function uses `assert(assetIndex < len)` to validate an index. `assert` should typically be used for invariant checking, as failed asserts consume all remaining gas. If this condition were reachable due to a bug, it would revert inefficiently. A `require` statement is generally preferred for validating conditions that might arise from external inputs or state changes.', 'Impact': 'Inefficient gas consumption on revert if the asserted condition fails. Less informative error handling compared to `require`.', 'Location': 'Comptroller.sol: exitMarket'}, {'Issue': 'Incorrect `claimComp` Parameter Usage Efficiency', 'Severity': 'Low', 'Description': 'The `claimComp(address[] memory holders, CToken[] memory cTokens, ...)` function iterates through each `cToken` and then through each `holder` inside the token loop. This means it processes each holder multiple times (once per token). A more gas-efficient approach would be to iterate through `holders` first, and for each holder, iterate through the relevant `cTokens` to claim their COMP.', 'Impact': 'Excessive gas consumption when claiming COMP for multiple holders across multiple markets simultaneously.', 'Location': 'Comptroller.sol: claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers)'}, {'Issue': 'Missing Zero-Address Check in Admin/Guardian Setters', 'Severity': 'Low', 'Description': ""Functions like `_setPauseGuardian` and `_setBorrowCapGuardian` allow the admin to set addresses for these roles but do not check if the provided address is the zero address (0x0). Accidentally setting a guardian to the zero address could permanently disable that role's functionality or lead to unexpected behavior."", 'Impact': 'Potential loss of functionality or unpredictable behavior if critical roles are accidentally set to the zero address.', 'Location': 'Comptroller.sol: _setPauseGuardian, _setBorrowCapGuardian'}, {'Issue': 'Potential Manipulation of `getBlockNumber()`', 'Severity': 'Low', 'Description': ""Reward calculations rely on `block.number` (via `getBlockNumber()`) to determine `deltaBlocks`. While miners have limited control over `block.number` itself, the timing depends on the blockchain's block production. Significant, unexpected changes in block time could slightly affect the rate of COMP distribution relative to real-time."", 'Impact': 'Minor potential inaccuracies in the timing and rate of reward distribution if block production rates fluctuate significantly.', 'Location': 'Comptroller.sol: getBlockNumber, updateCompSupplyIndex, updateCompBorrowIndex'}], 'IssueNumber': 64, 'OutputList': 22}",292.00036215782166,"### **[M-01] Reward rates can be changed through flash borrows**

**Report Description**:
The rewards per market are proportional to their `totalBorrows`, which can be manipulated by a large holder who deposits lots of collateral, takes out a huge borrow in the market, updates the rewards, and then unwinds the position. They'll only pay gas fees as the borrow/repay can happen in the same block. The `Comptroller.refreshCompSpeeds` function only checks that the single transaction is called from an EOA, but miners (or anyone if a miner offers services like flash bundles for flashbots) can still run flash-loan-like attacks by first sending a borrow tx increasing the `totalBorrows`, then the `refreshCompSpeeds` transaction, and then the repay of the borrow, as miners have full control over the transaction order of the block.

**Match in Response List**:
Matches with the issue titled **""Lack of Robust Access Control on `refreshCompSpeeds`""**.

**Validation**:
**Partially Correct**. The response identifies the issue with the `refreshCompSpeeds` function being restricted to EOAs but does not fully capture the specific risk of flash-loan-like attacks that manipulate `totalBorrows` to skew reward rates. While the response correctly notes the lack of robust access control, it misses the critical detail of how miners or attackers can exploit transaction ordering to manipulate reward rates. This is a significant oversight, as the core vulnerability lies in the ability to manipulate `totalBorrows` in a single block, not just the EOA restriction.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-01] Reward rates can be changed through flash borrows**

**Missed Issues from Issue Report**:
- *None*

---

### **Analysis**:
The response partially addresses the issue by highlighting the lack of robust access control on `refreshCompSpeeds`. However, it fails to fully capture the specific attack vector involving flash-loan-like manipulations of `totalBorrows` and the role of miners in transaction ordering. This is a critical gap, as the core vulnerability lies in the ability to manipulate reward rates through temporary borrows and repayments within a single block. A more comprehensive response would have addressed both the access control issue and the specific exploit mechanism.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the AP is calculated as 0."
