nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
Wrappedlbbtc.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICoreOracle.sol"";

/*
    Wrapped Interest-Bearing Bitcoin (Non-Ethereum mainnet variant)
*/
contract WrappedIbbtc is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 

    ICoreOracle public oracle;

    event SetOracle(address oracle);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == address(oracle), ""onlyOracle"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        oracle = ICoreOracle(_oracle);
        ibbtc = ERC20Upgradeable(_ibbtc);

        emit SetOracle(_oracle);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    function setOracle(address _oracle) external onlyGovernance {
        oracle = ICoreOracle(_oracle);
        emit SetOracle(_oracle);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Current pricePerShare read live from oracle
    function pricePerShare() public view virtual returns (uint256) {
        return oracle.pricePerShare();
    }

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare()).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare()).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare());
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare()).div(1e18);
    }
}

",1204,156,"[H-01] The design of wibBTC is not fully compatible with the current Curve StableSwap pool
 variables `wibBTC`
Per the documentation, variables `wibBTC` is designed for a Curve StableSwap pool. However, the design of wibBTC makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.
Specifically, a Curve StableSwap pool will maintain the balances of its coins based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.
The pool's actual dynamic balance of wibBTC will deviate from the recorded balance in the pool contract as the pricePerShare increases.
Furthermore, there is no such way in Curve StableSwap similar to the sync() function of UNI v2, which will force sync the stored reserves to match the balances.
  [H-02] Approved spender can spend too many tokens

The `approve` function has not been overridden and therefore uses the internal shares, whereas transfer(From) uses the rebalanced amount.
Impact

The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with pricePerShare.
Many contracts also use the same amount for the approve call as for the amount they want to have transferred in a subsequent transferFrom call, and in this case, they approve an amount that is too large (as the approved shares amount yields a higher rebalanced amount).

[H-04] WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers

If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics would be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.
 [M-01] Unable to transfer WrappedIbbtc if Oracle go down

In function `WrappedIbbtc`, user will not be able to transfer if `oracle.pricePerShare()` (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().
If this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it uses the cached value in a local variable pricePerShare, which is only updated upon call to updatePricePerShare().
 [M-02] Null check in pricePerShare

Submitted by hack3r-0m, also found by defsec
oracle can 0 as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: WrappedIbbtc.sol L148) resulting in Denial Of Service.
WrappedIbbtcEth.sol L73
WrappedIbbtc.sol L123
  [M-03] hard to clear balance
Function `transfer()`
The contract does not allow users to transfer by share. Therefore, It is hard for users to clear out all the shares. There will be users using this token with Metamask and it is likely the pricePerShare would increase after the user sends transactions. I consider this is a medium-risk issue.

[M-04] No sanity check on pricePerShare might lead to lost value

Function `sharesOf`
`pricePerShare` is read either from an oracle or from ibBTC's core.
If one of these is bugged or exploited, there are no safety checks to prevent loss of funds.
",7,,"pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICoreOracle.sol"";


contract WrappedIbbtc is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 

    ICoreOracle public oracle;

    event SetOracle(address oracle);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == address(oracle), ""onlyOracle"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _oracle) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        oracle = ICoreOracle(_oracle);
        ibbtc = ERC20Upgradeable(_ibbtc);

        emit SetOracle(_oracle);
    }

    
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    function setOracle(address _oracle) external onlyGovernance {
        oracle = ICoreOracle(_oracle);
        emit SetOracle(_oracle);
    }

    
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    

    
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    

    
    function pricePerShare() public view virtual returns (uint256) {
        return oracle.pricePerShare();
    }

    
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare()).div(1e18);
    }

    
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare()).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare());
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare()).div(1e18);
    }
}",811,3,4,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `governance` address is properly initialized and cannot be maliciously changed after initialization."",
        ""Ensure the `onlyGovernance` modifier is used appropriately on all sensitive functions (e.g., `setPendingGovernance`, `setOracle`)."",
        ""Confirm that the pending governance mechanism functions as expected, allowing for a smooth and secure transfer of governance rights."",
        ""Check for potential vulnerabilities in the `acceptPendingGovernance` function that could allow unauthorized address to become the governance."",
        ""Verify that the `onlyOracle` modifier is only applied to functions that actually need oracle access. It doesn't appear to be used."",
        ""Ensure that setting pendingGovernance to address(0) is either prevented or handled safely.""
      ]
    },
    {
      ""Area"": ""Oracle Integrity"",
      ""Tasks"": [
        ""Thoroughly review the `ICoreOracle` interface and its implementation to understand how `pricePerShare` is calculated and ensure it's tamper-proof and resistant to manipulation."",
        ""Analyze the data source used by the oracle to determine its reliability and potential vulnerabilities."",
        ""Assess the potential impact of oracle downtime or inaccurate price feeds on the functionality of the `WrappedIbbtc` contract (specifically mint, burn, transfer, transferFrom, balanceOf, totalSupply functions). Consider implementing circuit breakers or fallback mechanisms."",
        ""Investigate the precision and update frequency of the `pricePerShare` value and ensure it is sufficient to maintain the integrity of the wrapped token's value.""
      ]
    },
    {
      ""Area"": ""Rounding Errors and Precision"",
      ""Tasks"": [
        ""Analyze the `balanceToShares` and `sharesToBalance` functions for potential rounding errors that could lead to loss of precision or value for users."",
        ""Determine the magnitude of potential rounding errors in different scenarios (e.g., small vs. large balances, fluctuating pricePerShare) and assess their impact."",
        ""Consider implementing mechanisms to mitigate rounding errors, such as rounding up in favor of the user or using a higher precision arithmetic library."",
        ""Specifically review if rounding errors in balanceToShares can lead to less ibbtc being transferred into the contract during minting than wibBTC shares are minted. Also review if rounding errors in sharesToBalance can lead to the contract sending less ibbtc during burning than wibBTC shares burned.""
      ]
    },
    {
      ""Area"": ""External Interactions (ibBTC Token)"",
      ""Tasks"": [
        ""Verify that the `ibbtc` address is properly initialized and points to a valid ERC20 token contract."",
        ""Analyze the `mint` and `burn` functions to ensure that they correctly handle the transfer of `ibbtc` tokens between the user and the `WrappedIbbtc` contract."",
        ""Check for potential vulnerabilities related to the `ibbtc.transferFrom` and `ibbtc.transfer` calls, such as insufficient allowance or unexpected token behavior."",
        ""Consider the potential impact of `ibbtc` token transfers failing (e.g., due to insufficient balance or transfer restrictions) and implement appropriate error handling.""
      ]
    },
    {
      ""Area"": ""Arithmetic Over/Underflows"",
      ""Tasks"": [
        ""Review all arithmetic operations for potential over/underflow vulnerabilities, especially in the `transferFrom`, `transfer`, `balanceToShares`, `sharesToBalance`, `mint`, `burn`, `balanceOf`, and `totalSupply` functions. While solidity versions >=0.8.0 revert on under/overflows, this contract uses solidity ^0.6.12 and is thus vulnerable"",
        ""Implement safe math libraries or checks to prevent over/underflows if not already present (though the openzeppelin upgradeable contracts should be doing this).""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Verify that the contract is properly initialized using the `initializer` modifier and that initialization can only be performed once."",
        ""Review the storage layout of the contract to ensure that it is compatible with future upgrades."",
        ""Assess the potential impact of upgrades on existing users and their balances."",
        ""Ensure the contract follows the upgradeable proxy pattern correctly to avoid potential storage collisions or other upgrade-related issues.""
      ]
    },
    {
      ""Area"": ""Reentrancy"",
      ""Tasks"": [
        ""Analyze the `mint` and `burn` functions for potential reentrancy vulnerabilities, especially when interacting with the `ibbtc` token.  While the OpenZeppelin contracts used *should* prevent reentrancy, it is important to audit that they are used correctly and that there is not another entry point that is vulnerable."",
        ""Consider using the `ReentrancyGuard` contract from OpenZeppelin to protect against reentrancy attacks if needed.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of the most frequently used functions (e.g., `mint`, `burn`, `transfer`, `transferFrom`) and identify potential areas for optimization."",
        ""Consider using more efficient data structures or algorithms to reduce gas consumption."",
        ""Review the use of storage variables and minimize unnecessary reads and writes."",
        ""Review `balanceOf` and `totalSupply` since they use a potentially expensive multiplication and division. If the oracle's `pricePerShare` is slow to update, this may not be a high priority issue. If the oracle updates frequently, this may be a source of high gas cost.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""This contract, `WrappedIbbtc`, is designed to wrap an interest-bearing Bitcoin token (ibBTC) and create a wrapped version (wibBTC) that represents shares in the ibBTC pool. It uses an oracle to determine the price per share and allows users to mint and burn wibBTC by transferring ibBTC into and out of the contract. Governance is implemented with a pending governance pattern."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""WrappedIbbtc"",
    ""Purpose"": ""Wraps an interest-bearing Bitcoin token (ibBTC) to create a wrapped version (wibBTC) representing shares."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""ERC20Upgradeable""
      ],
      ""Imports"": [
        ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"",
        ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"",
        ""./ICoreOracle.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""governance"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the governance contract.""
      },
      {
        ""Name"": ""pendingGovernance"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the pending governance contract, used for transferring governance.""
      },
      {
        ""Name"": ""ibbtc"",
        ""Type"": ""ERC20Upgradeable"",
        ""Purpose"": ""Address of the underlying ibBTC ERC20 token.""
      },
      {
        ""Name"": ""oracle"",
        ""Type"": ""ICoreOracle"",
        ""Purpose"": ""Address of the oracle contract providing the price per share.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, setting governance, ibbtc address, and oracle address."",
        ""Parameters"": [
          ""_governance (address)"",
          ""_ibbtc (address)"",
          ""_oracle (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setPendingGovernance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the address of the pending governance contract."",
        ""Parameters"": [
          ""_pendingGovernance (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setOracle"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the address of the oracle contract."",
        ""Parameters"": [
          ""_oracle (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""acceptPendingGovernance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Accepts the pending governance, transferring governance to the pending governance address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""mint"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Mints wibBTC by transferring ibBTC from the user to the contract and minting the corresponding shares."",
        ""Parameters"": [
          ""_shares (uint256)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""burn"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Burns wibBTC and transfers the corresponding ibBTC back to the user."",
        ""Parameters"": [
          ""_shares (uint256)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers wibBTC from one address to another, adjusting for the share price using the oracle."",
        ""Parameters"": [
          ""sender (address)"",
          ""recipient (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""bool""
        ]
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers wibBTC from the sender to the recipient, adjusting for the share price using the oracle."",
        ""Parameters"": [
          ""recipient (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [
          ""bool""
        ]
      },
      {
        ""Name"": ""pricePerShare"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the price per share of wibBTC, obtained from the oracle."",
        ""Parameters"": [],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""sharesOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the number of shares held by an account."",
        ""Parameters"": [
          ""account (address)""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the balance of an account in wibBTC, calculated using the price per share."",
        ""Parameters"": [
          ""account (address)""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""totalShares"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total number of wibBTC shares."",
        ""Parameters"": [],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""totalSupply"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total supply of wibBTC, calculated using the price per share."",
        ""Parameters"": [],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""balanceToShares"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Converts a balance (wibBTC) to shares."",
        ""Parameters"": [
            ""balance (uint256)""
        ],
        ""Returns"": [
            ""uint256""
        ]
      },
      {
          ""Name"": ""sharesToBalance"",
          ""Visibility"": ""public"",
          ""Purpose"": ""Converts shares to a balance (wibBTC)"",
          ""Parameters"": [
              ""shares (uint256)""
          ],
          ""Returns"": [
              ""uint256""
          ]
      },
      {
        ""Name"": ""onlyPendingGovernance"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the pending governance address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyGovernance"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the governance address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOracle"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the oracle address."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ERC20Upgradeable (ibbtc)"",
    ""ICoreOracle (oracle)""
  ],
  ""SpecialMechanisms"": [
    ""Uses upgradeable contracts from OpenZeppelin."",
    ""Employs a pending governance pattern for secure governance transfers."",
    ""Uses an oracle to determine the price per share, allowing the wibBTC to reflect the underlying ibBTC's value."",
    ""The transfer and transferFrom functions convert amounts to shares before calling the _transfer function.""
  ],
  ""Questions"": [
    ""What is the expected precision of the pricePerShare returned by the oracle? It seems assumed to be 1e18."",
    ""How is the ICoreOracle interface defined? It is not included in this code snippet."",
    ""Is there any risk of rounding errors in the balanceToShares and sharesToBalance functions, and how are these mitigated?"",
    ""Should there be a check to prevent `pendingGovernance` from being set to the zero address?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Oracle Manipulation Risk"",
      ""Severity"": ""High"",
      ""Description"": ""The contract relies on an external oracle (`ICoreOracle`) for the `pricePerShare`. If this oracle is compromised, the `WrappedIbbtc` contract\'s functionality will be severely affected. Malicious actors could manipulate the oracle to inflate or deflate the price, leading to unfair minting/burning ratios, incorrect share calculations in `transfer` and `transferFrom`, inaccurate token amounts being transferred or redeemed, potential draining of contract funds, and overall instability of the wrapped ibBTC token. No checks are present to validate the reasonableness or validity of the oracle's reported `pricePerShare`."",
      ""Impact"": ""Significant financial loss due to unfair minting/burning, potential draining of contract funds, complete or partial loss of functionality, inaccurate token amounts being transferred or redeemed and overall instability of the wrapped ibBTC token."",
      ""Location"": ""Reliance on `oracle.pricePerShare()` in `mint`, `burn`, `transfer`, `transferFrom`, `balanceOf`, `totalSupply`, `balanceToShares`, and `sharesToBalance` functions, `pricePerShare() function`, `setOracle()`""
    },
    {
      ""Issue"": ""Incorrect ERC20 Approval Handling in transferFrom"",
      ""Severity"": ""High"",
      ""Description"": ""The `transferFrom` function calculates `amountInShares` using `balanceToShares(amount)` and then subtracts `amountInShares` from the allowance. This is incorrect. The allowance should be reduced by the original `amount`, not the converted shares. This discrepancy can lead to users being able to transfer more tokens than they are approved for because the allowance is being reduced by a smaller value."",
      ""Impact"": ""Critical security vulnerability. Users can bypass ERC20 allowance restrictions, potentially leading to theft of funds."",
      ""Location"": ""WrappedIbbtc.sol:78-81""
    },
    {
      ""Issue"": ""ERC20Upgradeable ibbtc address might not be an ERC20 contract"",
      ""Severity"": ""High"",
      ""Description"": ""The contract assumes that `ibbtc` address is an ERC20Upgradeable contract by casting it to that type. This assumption is dangerous and might cause unexpected behavior and vulnerabilities if that address points to an address that is not an ERC20Upgradeable contract or a malicious contract. The ERC20Upgradeable casts are unchecked and can cause havoc if the passed address does not conform to the ERC20Upgradeable standards"",
      ""Impact"": ""Calling methods from a non-ERC20 contract could result in unexpected behaviour, storage corruption, or the execution of arbitrary code"",
      ""Location"": ""WrappedIbbtc.sol: initialize, mint""
    },
    {
      ""Issue"": ""Missing Access Control on `mint` and `burn` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `mint` and `burn` functions lack proper access control. Anyone can call these functions to mint or burn wibBTC tokens, potentially manipulating the total supply and devaluing existing holdings. There is no validation to ensure that the `_shares` amount is a reasonable or expected value. A failed transfer due to insufficient allowance or balance will still mint wibBTC tokens to the user, creating a discrepancy between wibBTC balance and underlying ibBTC. Also, burning a zero amount might be an unintended edge case."",
      ""Impact"": ""Unauthorized token creation or destruction, potentially leading to financial loss for users and destabilizing the wrapped asset. A malicious user could potentially drain the `ibbtc` balance of the contract by minting a large number of wibBTC tokens. Loss of funds for users if underlying ibBTC transfer fails, and discrepancy between wibBTC and underlying ibBTC balances. It can also result in accounting issues within the contract."",
      ""Location"": ""WrappedIbbtc.sol: mint, burn, WrappedIbbtc.sol:61, WrappedIbbtc.sol:67""
    },
    {
      ""Issue"": ""Lack of slippage control in `mint` and `burn` functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `mint` and `burn` functions directly transfer ibBTC to and from the contract based on the current `pricePerShare` from an external oracle without any slippage control. If the `pricePerShare` changes significantly between the time the user initiates the transaction and the time it's executed, the user may receive significantly fewer shares when minting or significantly less ibBTC when burning than expected."",
      ""Impact"": ""Users may receive less or more shares/ibBTC than anticipated, leading to potential losses if price per share fluctuates substantially between transaction creation and execution. User experience degradation due to unexpected amounts received or sent. Exploitation by malicious actors through oracle manipulation."",
      ""Location"": ""WrappedIbbtc.sol: mint, burn""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `burn` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `burn` function first burns the user's wibBTC shares and then transfers the corresponding ibBTC tokens back to the user. If the user is a contract that implements a malicious fallback function, the transfer of `ibbtc` in the `burn` function could trigger a reentrancy attack. A malicious Oracle can manipulate the result of `pricePerShare()` after the `amountInShares` is calculated but before the _transfer occurs, leading to double-spending"",
      ""Impact"": ""Potential for reentrancy attack, allowing an attacker to drain the contract's ibBTC balance or manipulate the contract's state in unintended ways."",
      ""Location"": ""WrappedIbbtc.sol: burn""
    },
    {
      ""Issue"": ""Upgradeability Considerations and Potential Initializer Replay Attack"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses the OpenZeppelin upgradeable contracts. It's crucial to ensure the initializer function is only called once. If an attacker could call the `initialize` function again, they could potentially overwrite the governance and other critical parameters, gaining control of the contract."",
      ""Impact"": ""If the `initialize` function can be called more than once, it allows an attacker to overwrite critical parameters like `governance` and `oracle`, effectively taking control of the contract."",
      ""Location"": ""WrappedIbbtc.sol: initialize""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in transferFrom and transfer functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferFrom` and `transfer` functions call `balanceToShares`, which calls `pricePerShare`, which calls an external contract (`oracle`). If the oracle contract is malicious or has a vulnerability, it could potentially re-enter the `WrappedIbbtc` contract and cause unexpected behavior or if the `ibbtc` token contract has a malicious fallback function or implements a reentrant ERC777-style hook."",
      ""Impact"": ""Loss of funds for users, potential contract state corruption. Reentrancy attack could allow attackers to mint tokens without transferring ibbtc or burn tokens and withdraw more ibbtc than they should."",
      ""Location"": ""transferFrom, transfer functions. WrappedIbbtc.sol: mint() and burn() functions""
    },
    {
      ""Issue"": ""Governance Takeover Risk during pendingGovernance period"",
      ""Severity"": ""Medium"",
      ""Description"": ""The governance update mechanism involves setting a `pendingGovernance` address and then accepting it. During the time between setting and accepting, a malicious actor could potentially front-run the `acceptPendingGovernance()` transaction if they can gain control of the `pendingGovernance` address. This could lead to unauthorized governance control."",
      ""Impact"": ""Unauthorized governance control, leading to potential system compromise."",
      ""Location"": ""WrappedIbbtc.sol: setPendingGovernance(), acceptPendingGovernance()""
    },
    {
      ""Issue"": ""Reliance on Oracle Price Feed"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on an external oracle (`ICoreOracle`) for the `pricePerShare`. The code lacks a mechanism to verify the integrity or trustworthiness of the oracle\'s price. If the oracle is compromised or provides incorrect data, the contract\'s logic will be affected, potentially leading to significant financial losses for users."",
      ""Impact"": ""If the oracle is compromised or malfunctions, the `pricePerShare` could be manipulated, leading to incorrect calculations for balance and shares, and potentially allowing attackers to exploit the system. Economic exploitation."",
      ""Location"": ""WrappedIbbtc.sol: pricePerShare, balanceOf, totalSupply, balanceToShares, sharesToBalance, WrappedIbbtc.sol: pricePerShare() function""
    },
    {
      ""Issue"": ""Lack of Input Validation and Slippage Control in transferFrom and transfer"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferFrom` and `transfer` functions convert the amount to shares, transfer the shares, and then for `transferFrom`, reduce allowance. The conversion to shares relies on the price from the oracle, `pricePerShare`. If the oracle price changes significantly between the time the user approves the transaction and when the transaction is mined, the converted shares might be significantly different than the user expects. "",
      ""Impact"": ""Users might be transferring a larger or smaller amount of underlying assets than they intended based on the oracle price change."",
      ""Location"": ""WrappedIbbtc.sol:76, WrappedIbbtc.sol:88""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `transferFrom`"",
      ""Severity"": ""Low"",
      ""Description"": ""A reentrancy vulnerability could exist if the `ICoreOracle.pricePerShare()` function calls back into this contract or if ibbtc token implements a callback mechanism. If the oracle is malicious and calls back into the contract to trigger another `transferFrom` before the initial one completes, unexpected behavior could occur. While the `_transfer` function (inherited from ERC20Upgradeable) will prevent reentrancy, it still presents a potential attack vector."",
      ""Impact"": ""Unexpected token amounts being transferred, potential for draining the contract of funds if oracle can manipulate the `pricePerShare`."",
      ""Location"": ""WrappedIbbtc.sol: `transferFrom` function""
    },
    {
      ""Issue"": ""Rounding Errors in `balanceToShares` and `sharesToBalance`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `balanceToShares` and `sharesToBalance` functions perform calculations involving `pricePerShare`. Due to integer division, there could be rounding errors that lead to slight inaccuracies in the conversion between balances and shares. Depending on the magnitude of the balance/shares being converted and the precision of `pricePerShare`, these rounding errors could accumulate over time and cause discrepancies between balances and shares."",
      ""Impact"": ""Minor inaccuracies in balance/share conversions.  May lead to small losses or gains for users during minting or burning. Minor discrepancies in balance conversions between wibBTC and ibBTC could cause accounting errors or unexpected behavior for users interacting with the contract. Users might receive slightly less or slightly more wibBTC when converting from ibbtc and vice versa."",
      ""Location"": ""WrappedIbbtc.sol: balanceToShares, sharesToBalance, WrappedIbbtc.sol:119, WrappedIbbtc.sol:123, WrappedIbbtc.sol:107, WrappedIbbtc.sol:111""
    },
    {
      ""Issue"": ""Missing Input Validation and Overflow Checks"",
      ""Severity"": ""Low"",
      ""Description"": ""The `initialize` function, `setPendingGovernance`, and `setOracle` functions do not validate the input addresses.The code uses `sub` function for safe subtraction, but there are several multiplication and division operations that are prone to overflow or underflow errors."",
      ""Impact"": ""Contract could become unusable or governance can be hijacked if the zero address is set as governance or oracle. The mint and burn functionality will break if ibbtc address is the zero address. Potential arithmetic overflow or underflow can cause unexpected behavior of the contract. If the `pricePerShare` or the `totalShares` values get large, the multiplication operations can lead to incorrect results or revert the transactions."",
      ""Location"": ""initialize, setPendingGovernance, setOracle functions. WrappedIbbtc.sol: 119, WrappedIbbtc.sol: 123, WrappedIbbtc.sol: 107, WrappedIbbtc.sol:111""
    },
    {
      ""Issue"": ""Missing Access Control for Initialization"",
      ""Severity"": ""Low"",
      ""Description"": ""The `initialize` function is protected by the `initializer` modifier which prevents re-initialization. However, it does not restrict who can call the `initialize` function in the first place."",
      ""Impact"": ""A malicious actor can take control of the contract before the intended owner does."",
      ""Location"": ""WrappedIbbtc.sol:41""
    },
        {
      ""Issue"": ""Unnecessary ERC20Upgradeable Casting"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract defines `ibbtc` as type `ERC20Upgradeable public ibbtc;` Then casts the address to `ERC20Upgradeable` when initializing. The cast is not necessary as the variable is already of the correct type."",
      ""Impact"": ""Code readability."",
      ""Location"": ""WrappedIbbtc.sol:45""
    },
    {
      ""Issue"": ""Missing Event Emission for _approve in `transferFrom`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferFrom` function reduces the allowance with `_approve`, but doesn't emit an event. While `_approve` emits the `Approval` event, it is best practice to always emit the event in the function itself."",
      ""Impact"": ""Potentially difficult to track token approvals on the blockchain."",
      ""Location"": ""WrappedIbbtc.sol: `transferFrom` function""
    }
  ],
  ""IssueNumber"": 45,
  ""OutputList"": 16
}",179.26823711395264,3683.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] The design of wibBTC is not fully compatible with the current Curve StableSwap pool**

**Report Description**:  
The design of `wibBTC` makes balances change dynamically and automatically, which is unusual for an ERC20 token and incompatible with the Curve StableSwap pool. The pool maintains balances based on token additions, removals, and exchanges, but cannot handle dynamic balance changes automatically. This discrepancy can lead to deviations between the actual dynamic balance of `wibBTC` and the recorded balance in the pool contract as `pricePerShare` increases. Additionally, there is no mechanism like UNI v2's `sync()` function to force synchronization of stored reserves.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the incompatibility between `wibBTC` and the Curve StableSwap pool. This issue is specific to the interaction between `wibBTC` and Curve's design, which is not covered in the response list.

---

#### **[H-02] Approved spender can spend too many tokens**

**Report Description**:  
The `approve` function uses internal `shares`, while `transfer(From)` uses the rebalanced amount. This discrepancy allows an approved spender to spend more tokens than intended, as the approved amount grows with `pricePerShare`. Many contracts use the same amount for `approve` and `transferFrom`, leading to approvals that are too large.

**Match in Response List**:  
Matches with the issue titled **""Incorrect ERC20 Approval Handling in transferFrom""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `transferFrom` function, where the allowance is reduced by the converted shares instead of the original amount. This aligns with the reported issue and highlights the risk of users bypassing ERC20 allowance restrictions.

---

#### **[H-04] WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers**

**Report Description**:  
The contracts do not filter out price feed outliers, which can be manipulated or result from market volatility. This exposes users to unnecessary risks, as mitigation mechanics could be implemented to ensure sustainable price movements.

**Match in Response List**:  
Matches with the issue titled **""Oracle Manipulation Risk""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of oracle manipulation but does not explicitly mention the lack of filtering for price feed outliers. While the core issue is related to oracle reliance, the specific concern about outliers is not fully addressed.

---

#### **[M-01] Unable to transfer WrappedIbbtc if Oracle goes down**

**Report Description**:  
Users cannot transfer `WrappedIbbtc` if `oracle.pricePerShare()` reverts, as `balanceToShares` is called in both `transfer` and `transferFrom`. This behavior contrasts with `WrappedIbbtcEth`, which uses a cached `pricePerShare` value updated only upon calling `updatePricePerShare()`.

**Match in Response List**:  
Matches with the issue titled **""Reliance on Oracle Price Feed""**.

**Validation**:  
**Correct**. The response highlights the reliance on the oracle for `pricePerShare`, which aligns with the reported issue. It correctly identifies the risk of contract functionality being affected if the oracle fails or is compromised.

---

#### **[M-02] Null check in pricePerShare**

**Report Description**:  
The oracle can return `0` as the price of the share, which becomes the denominator in calculations, causing reverts from SafeMath and resulting in Denial of Service.

**Match in Response List**:  
Matches with the issue titled **""Missing Input Validation and Overflow Checks""**.

**Validation**:  
**Partially Correct**. The response mentions missing input validation but does not specifically address the risk of `0` being returned by the oracle. While related, the specific issue of SafeMath reverts due to a `0` denominator is not fully covered.

---

#### **[M-03] Hard to clear balance**

**Report Description**:  
The contract does not allow users to transfer by share, making it difficult to clear out all shares. This issue is exacerbated by the likelihood of `pricePerShare` increasing after transactions are sent, particularly for users using Metamask.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the difficulty of clearing balances due to the inability to transfer by share. This issue is specific to user experience and is not covered in the response list.

---

#### **[M-04] No sanity check on pricePerShare might lead to lost value**

**Report Description**:  
There are no sanity checks on `pricePerShare`, which is read from an oracle or `ibBTC`'s core. If either is bugged or exploited, it could lead to loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Reliance on Oracle Price Feed""**.

**Validation**:  
**Correct**. The response identifies the lack of validation for `pricePerShare`, which aligns with the reported issue. It correctly highlights the risk of incorrect calculations and potential loss of funds due to oracle manipulation or malfunction.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Approved spender can spend too many tokens**
- **[M-01] Unable to transfer WrappedIbbtc if Oracle goes down**
- **[M-04] No sanity check on pricePerShare might lead to lost value**

**Partially Correct Matches**:

- **[H-04] WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers**
- **[M-02] Null check in pricePerShare**

**Missed Issues from Issue Report**:

- **[H-01] The design of wibBTC is not fully compatible with the current Curve StableSwap pool**
- **[M-03] Hard to clear balance**

--- 

The response list covers many of the issues but misses specific concerns related to `wibBTC`'s compatibility with Curve StableSwap and the difficulty of clearing balances. Additionally, some responses partially address the issues but miss critical details.","```
1. Incorrect ERC20 Approval Handling in transferFrom
2. Reliance on Oracle Price Feed
3. Reliance on Oracle Price Feed
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Incorrect ERC20 Approval Handling in transferFrom"" appears at rank 2.
   - ""Reliance on Oracle Price Feed"" appears at rank 10.
   - ""Reliance on Oracle Price Feed"" appears at rank 10.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 10: \( P@10 = \frac{2}{10} = 0.2 \)

3. **Average the precision values**:
   - AP = \( \frac{0.5 + 0.2}{2} = 0.35 \)

**Output**:
```
0.35
```"
WrappedlbbtcEth.sol,"//SPDX-License-Identifier: Unlicense
pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICore.sol"";

/*
    Wrapped Interest-Bearing Bitcoin (Ethereum mainnet variant)
*/
contract WrappedIbbtcEth is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 
    
    ICore public core;

    uint256 public pricePerShare;
    uint256 public lastPricePerShareUpdate;

    event SetCore(address core);
    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    /// ===== Modifiers =====
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _core) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        core = ICore(_core);
        ibbtc = ERC20Upgradeable(_ibbtc);

        updatePricePerShare();

        emit SetCore(_core);
    }

    /// ===== Permissioned: Governance =====
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    /// @dev The ibBTC token is technically capable of having it's Core contract changed via governance process. This allows the wrapper to adapt.
    /// @dev This function should be run atomically with setCore() on ibBTC if that eventuality ever arises.
    function setCore(address _core) external onlyGovernance {
        core = ICore(_core);
        emit SetCore(_core);
    }

    /// ===== Permissioned: Pending Governance =====
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    /// ===== Permissionless Calls =====

    /// @dev Update live ibBTC price per share from core
    /// @dev We cache this to reduce gas costs of mint / burn / transfer operations.
    /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date
    function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

    /// @dev Deposit ibBTC to mint wibBTC shares
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    /// ===== Transfer Overrides =====
    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20};
     *
     * Requirements:
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    /// ===== View Methods =====

    /// @dev Wrapped ibBTC shares of account
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /// @dev Current account shares * pricePerShare
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare).div(1e18);
    }

    /// @dev Total wrapped ibBTC shares
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    /// @dev Current total shares * pricePerShare
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare).div(1e18);
    }
}

",1337,164,"[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if updatePricePerShare wasn't run properly

Malicious user can monitor `SetPricePerShare` event and, if it was run long enough time ago and market moved, but, since there were no SetPricePerShare fired, the contract's pricePerShare is outdated, so a user can mint() with pricePerShare that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.
  [H-04] WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers

If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics would be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.
",2,,"pragma solidity ^0.6.12;

import ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"";
import ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""./ICore.sol"";


contract WrappedIbbtcEth is Initializable, ERC20Upgradeable {
    address public governance;
    address public pendingGovernance;
    ERC20Upgradeable public ibbtc; 
    
    ICore public core;

    uint256 public pricePerShare;
    uint256 public lastPricePerShareUpdate;

    event SetCore(address core);
    event SetPricePerShare(uint256 pricePerShare, uint256 updateTimestamp);
    event SetPendingGovernance(address pendingGovernance);
    event AcceptPendingGovernance(address pendingGovernance);

    
    modifier onlyPendingGovernance() {
        require(msg.sender == pendingGovernance, ""onlyPendingGovernance"");
        _;
    }

    modifier onlyGovernance() {
        require(msg.sender == governance, ""onlyGovernance"");
        _;
    }

    function initialize(address _governance, address _ibbtc, address _core) public initializer {
        __ERC20_init(""Wrapped Interest-Bearing Bitcoin"", ""wibBTC"");
        governance = _governance;
        core = ICore(_core);
        ibbtc = ERC20Upgradeable(_ibbtc);

        updatePricePerShare();

        emit SetCore(_core);
    }

    
    function setPendingGovernance(address _pendingGovernance) external onlyGovernance {
        pendingGovernance = _pendingGovernance;
        emit SetPendingGovernance(pendingGovernance);
    }

    
    
    function setCore(address _core) external onlyGovernance {
        core = ICore(_core);
        emit SetCore(_core);
    }

    
    function acceptPendingGovernance() external onlyPendingGovernance {
        governance = pendingGovernance;
        emit AcceptPendingGovernance(pendingGovernance);
    }

    

    
    
    
    function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

    
    function mint(uint256 _shares) external {
        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));
        _mint(_msgSender(), _shares);
    }

    
    function burn(uint256 _shares) external {
        _burn(_msgSender(), _shares);
        require(ibbtc.transfer(_msgSender(), _shares));
    }

    
    
    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

    
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        
        

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

    

    
    function sharesOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function balanceOf(address account) public view override returns (uint256) {
        return sharesOf(account).mul(pricePerShare).div(1e18);
    }

    
    function totalShares() public view returns (uint256) {
        return _totalSupply;
    }

    
    function totalSupply() public view override returns (uint256) {
        return totalShares().mul(pricePerShare).div(1e18);
    }

    function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }

    function sharesToBalance(uint256 shares) public view returns (uint256) {
        return shares.mul(pricePerShare).div(1e18);
    }
}",854,2,0,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Governance"",
      ""Tasks"": [
        ""Verify that the `governance` address is correctly initialized in the `initialize` function and that only the intended governance address can call the `setPendingGovernance` and `setCore` functions."",
        ""Confirm the correct functionality of the governance transfer mechanism through `setPendingGovernance` and `acceptPendingGovernance`. Ensure that the pending governance address is properly set and that only the pending governance address can accept the role."",
        ""Analyze the impact of changing the `core` address on the overall system. Evaluate if setting a malicious `core` contract can compromise the `pricePerShare` and lead to fund exploitation."",
        ""Investigate whether the zero address is handled correctly in the `setPendingGovernance` function, preventing accidental locking of the governance role."",
        ""Check if `updatePricePerShare` should be restricted to `onlyGovernance` to prevent price manipulation by malicious actors. Currently, it's a public function.""
      ]
    },
    {
      ""Area"": ""Price Per Share and Arithmetic Overflow/Underflow"",
      ""Tasks"": [
        ""Analyze the `ICore.pricePerShare()` function and ensure it cannot return manipulated, unreasonable values, causing unexpected behavior in `WrappedIbbtcEth`."",
        ""Examine the `balanceToShares` and `sharesToBalance` functions for potential overflow or underflow issues, especially when `pricePerShare` has extremely large or small values. Consider using SafeMath or similar libraries to prevent these issues."",
        ""Investigate the precision loss that could occur in the `balanceOf` and `totalSupply` functions due to the division by `1e18`. Evaluate if this loss significantly impacts the accuracy of the calculations."",
        ""Assess the vulnerability to front-running attacks when updating `pricePerShare`. Explore mitigation strategies such as time-weighted average price (TWAP) or requiring a minimum time interval between updates."",
        ""Evaluate the reliability and trustworthiness of the `ICore` contract and its `pricePerShare()` function. Consider the potential risks associated with relying on an external contract for critical price data.""
      ]
    },
    {
      ""Area"": ""Mint and Burn Functionality"",
      ""Tasks"": [
        ""Verify that the `mint` function correctly transfers ibBTC tokens from the user to the contract using `ibbtc.transferFrom`. Check if the contract has the necessary allowance to transfer the tokens."",
        ""Confirm that the `burn` function correctly burns wibBTC tokens and transfers the corresponding amount of ibBTC tokens back to the user using `ibbtc.transfer`."",
        ""Analyze the possibility of reentrancy attacks in the `mint` and `burn` functions, especially during the `ibbtc.transferFrom` and `ibbtc.transfer` calls. Implement reentrancy guards if necessary."",
        ""Ensure that the `mint` and `burn` functions prevent the creation of shares with a value of zero to avoid potential division-by-zero errors in subsequent calculations. Consider adding a require statement to prevent this."",
        ""Check for rounding errors in the conversions between balance and shares, and ensure that any rounding is handled in a way that benefits users or is at least predictable and fair.""
      ]
    },
    {
      ""Area"": ""ERC20 Compliance and Transfer Logic"",
      ""Tasks"": [
        ""Ensure the contract adheres to the ERC20 standard, paying close attention to the `transfer` and `transferFrom` functions."",
        ""Review the `transferFrom` function and verify if `_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \""ERC20: transfer amount exceeds allowance\""))` should use `amount` rather than `amountInShares`."",
        ""Analyze the potential for inconsistencies between the balance of ibBTC held by the contract and the total supply of wibBTC tokens. Implement monitoring and reconciliation mechanisms to detect and address any discrepancies."",
        ""Evaluate the need for additional events to provide better transparency and auditability of contract operations, such as minting and burning events with detailed information about the amounts and addresses involved.""
      ]
    },
    {
      ""Area"": ""Timestamp Dependency"",
      ""Tasks"": [
        ""Assess the impact of using `now` (block.timestamp) in the `updatePricePerShare` function. Determine if block timestamp manipulation could be exploited. Consider using a more robust and reliable time source if necessary."",
        ""Document the assumptions about the accuracy and reliability of block timestamps and the potential risks associated with relying on them.""
      ]
    },
    {
      ""Area"": ""Initialization"",
      ""Tasks"": [
        ""Verify that the `initializer` function can only be called once, preventing re-initialization of the contract state. Confirm that the OpenZeppelin `initializer` modifier is correctly used."",
        ""Analyze the potential risks associated with uninitialized state variables and ensure that all state variables are properly initialized in the `initialize` function.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines a `WrappedIbbtcEth` contract that wraps an interest-bearing Bitcoin token (ibBTC). It inherits from `Initializable` and `ERC20Upgradeable` from OpenZeppelin for upgradeable contracts and ERC20 token functionality. The contract allows users to mint wibBTC by depositing ibBTC and burn wibBTC to redeem ibBTC. It also includes governance features to manage contract parameters like the `core` address and price per share. The contract's core functionality revolves around converting between ibBTC balance and wibBTC shares based on the `pricePerShare` provided by an external `core` contract."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""WrappedIbbtcEth"",
    ""Purpose"": ""Wraps an interest-bearing Bitcoin token (ibBTC) allowing users to mint wibBTC and redeem ibBTC. Also includes governance functionality."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""ERC20Upgradeable""
      ],
      ""Imports"": [
        ""../deps/@openzeppelin/contracts-upgradeable/proxy/Initializable.sol"",
        ""../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"",
        ""./ICore.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""governance"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the current governance.""
      },
      {
        ""Name"": ""pendingGovernance"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the pending governance, used for governance transfers.""
      },
      {
        ""Name"": ""ibbtc"",
        ""Type"": ""ERC20Upgradeable"",
        ""Purpose"": ""Address of the underlying ibBTC token.""
      },
      {
        ""Name"": ""core"",
        ""Type"": ""ICore"",
        ""Purpose"": ""Address of the Core contract that provides the pricePerShare.""
      },
      {
        ""Name"": ""pricePerShare"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The price per share, used to calculate the value of wibBTC.""
      },
      {
        ""Name"": ""lastPricePerShareUpdate"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last pricePerShare update.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with governance, ibbtc, and core addresses."",
        ""Parameters"": [
          ""_governance (address)"",
          ""_ibbtc (address)"",
          ""_core (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setPendingGovernance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the pending governance address. Only callable by the current governance."",
        ""Parameters"": [
          ""_pendingGovernance (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setCore"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the address of the Core contract. Only callable by the current governance."",
        ""Parameters"": [
          ""_core (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""acceptPendingGovernance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Accepts the pending governance role, making the pendingGovernance the new governance."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updatePricePerShare"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the pricePerShare by calling the core contract. Can be called by anyone."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""mint"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Mints wibBTC tokens by transferring ibBTC from the sender to the contract."",
        ""Parameters"": [
          ""_shares (uint256)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""burn"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Burns wibBTC tokens and transfers ibBTC to the sender."",
        ""Parameters"": [
          ""_shares (uint256)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers wibBTC tokens from one address to another, considering the pricePerShare."",
        ""Parameters"": [
          ""sender (address)"",
          ""recipient (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers wibBTC tokens from the sender to the recipient, considering the pricePerShare."",
        ""Parameters"": [
          ""recipient (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""sharesOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the number of shares an address holds."",
        ""Parameters"": [
          ""account (address)""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the ibBTC balance of an address based on their wibBTC shares and pricePerShare."",
        ""Parameters"": [
          ""account (address)""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""totalShares"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total number of wibBTC shares."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""totalSupply"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total ibBTC supply based on the total shares and pricePerShare."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""balanceToShares"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Converts ibBTC balance to wibBTC shares based on pricePerShare."",
        ""Parameters"": [
          ""balance (uint256)""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""sharesToBalance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Converts wibBTC shares to ibBTC balance based on pricePerShare."",
        ""Parameters"": [
          ""shares (uint256)""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""onlyGovernance"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the governance address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyPendingGovernance"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the pendingGovernance address."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ICore.pricePerShare()"",
    ""ERC20Upgradeable.transferFrom()"",
    ""ERC20Upgradeable.transfer()""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract using OpenZeppelin's `Initializable` and `ERC20Upgradeable` contracts."",
    ""Uses an external `core` contract to determine the `pricePerShare` for converting between ibBTC and wibBTC."",
    ""Governance functionality for setting the core contract address and managing contract upgrades.""
  ],
  ""Questions"": [
    ""What are the specific security considerations related to using `now` as a timestamp in `updatePricePerShare`? Could manipulating block timestamps affect the contract?"",
    ""Is there a mechanism to prevent front-running of the `updatePricePerShare` function, potentially affecting the mint/burn calculations?"",
    ""What validations are present in the `ICore` contract to ensure that the `pricePerShare` is a reasonable and safe value?"",
    ""Could the `balanceToShares` and `sharesToBalance` functions overflow or underflow if pricePerShare is very large or small?"",
    ""Are there any access control restrictions on `updatePricePerShare`? If not, how is it ensured that the core contract isn't manipulated such that the price is incorrect?"",
    ""In `transferFrom`, shares are transferred, but the allowance is checked against `amountInShares` and not the intended amount. Should this be `amount` instead?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `mint` and `burn` functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `mint` and `burn` functions interact with the `ibbtc` token via `transferFrom` and `transfer` respectively. If the `ibbtc` token has a malicious callback function in its `transferFrom` or `transfer` implementation, it could trigger a reentrancy attack, potentially leading to unexpected state changes, such as double-minting or burning more shares than intended. The require statements should come after the state changes."",
      ""Impact"": ""Double-minting, burning more shares than intended, unexpected state changes leading to financial loss, draining funds from the contract or inflating the token supply."",
      ""Location"": ""WrappedIbbtcEth.sol: mint(uint256 _shares), burn(uint256 _shares)""
    },
    {
      ""Issue"": ""Missing Access Control on `updatePricePerShare` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `updatePricePerShare` function is `public`, meaning anyone can call it and manipulate the `pricePerShare` value. Since `balanceOf`, `totalSupply`, `balanceToShares`, and `sharesToBalance` all depend on `pricePerShare`, malicious manipulation of this value could lead to incorrect calculations of user balances, total supply, and conversion between balances and shares. Manipulation could lead to incorrect calculations in other functions, potentially allowing attackers to mint or burn tokens at advantageous rates. The `core` contract may also be compromised."",
      ""Impact"": ""Incorrect balance calculations, potential for theft of funds, manipulation of total supply, users receiving less wibBTC than they should when minting or losing ibBTC when burning, significant financial losses for users and reputational damage."",
      ""Location"": ""WrappedIbbtcEth.sol: updatePricePerShare function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Balance/Share Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `balanceToShares`, `sharesToBalance`, `balanceOf` and `totalSupply` use `mul` and `div` directly without overflow checks.  Also, `transferFrom` and `transfer` functions calculate the allowance after converting `amount` to shares, which can lead to overflow/underflow if `pricePerShare` is maliciously set very low.  Extreme values for `balance` or `shares` along with a very low or high `pricePerShare` could still lead to unexpected results due to limitations in the size of `uint256`."",
      ""Impact"": ""Unexpected behavior, incorrect balance and total supply calculations. Potential for the contract to become unusable. Potential loss of funds due to incorrect share calculations and allowance checks."",
      ""Location"": ""functions balanceToShares, sharesToBalance, balanceOf, totalSupply, transferFrom and transfer functions""
    },
    {
      ""Issue"": ""Missing Input Validation in `mint` and `burn` functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `mint` and `burn` functions receive `_shares` without proper input validation, including checks for zero values. Lack of validation on `_shares` can lead to unexpected behavior, such as minting or burning extremely large amounts of tokens, potentially causing issues with the accounting of shares and underlying assets."",
      ""Impact"": ""Potential for integer overflows or underflows if `_shares` is very large, leading to incorrect accounting of shares and underlying assets, or denial of service if operations become computationally expensive. Wasted gas for zero-value mint/burn transactions."",
      ""Location"": ""mint(uint256 _shares), burn(uint256 _shares)""
    },
    {
      ""Issue"": ""Potential for Denial of Service due to `transferFrom` gas costs"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferFrom` function calculates `amountInShares = balanceToShares(amount)`, then reduces the sender\'s allowance using `_allowances[sender][_msgSender()].sub(amountInShares, ...)` before finally transferring the shares. If the `balanceToShares` conversion or the subtractions throw an error, or if the ibbtc token transfer operation within mint fails after the allowance has been reduced, the allowance would be reduced, but the desired transfer might not occur. This could cause loss of funds or a denial of service."",
      ""Impact"": ""If the operations within the `transferFrom` transaction fail, an attacker could exploit this, preventing legitimate users from transfering."",
      ""Location"": ""transferFrom(address sender, address recipient, uint256 amount)""
    },
    {
      ""Issue"": ""Lack of slippage control during mint and burn operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `mint` and `burn` functions directly transfer ibbtc without considering slippage. If the price per share fluctuates significantly between the transaction initiation and execution, the user might receive less wibBTC for their ibbtc, or vice-versa, than expected. Users could be exploited through sandwich attacks."",
      ""Impact"": ""Users might lose value due to unfavorable price fluctuations during minting or burning. Vulnerable to sandwich attacks.  Users may receive fewer shares than expected when minting, or lose more ibBTC when burning, due to price fluctuations."",
      ""Location"": ""WrappedIbbtcEth.sol: Functions `mint`, `burn`""
    },
    {
      ""Issue"": ""Timestamp Dependency in `updatePricePerShare` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updatePricePerShare` function uses `now` to record the timestamp of the price per share update. `now` is deprecated and `block.timestamp` should be used instead for better readability. While the actual impact is minimal (as both provide the same value), using `block.timestamp` is the current recommended practice. Miner manipulation is possible but limited."",
      ""Impact"": ""Slightly inaccurate timestamps, potential for miner manipulation (though limited). Minor issue. Can make the code slightly less readable and goes against best practices."",
      ""Location"": ""WrappedIbbtcEth.sol: updatePricePerShare function""
    },
    {
      ""Issue"": ""Missing input validation in `initialize`, `setPendingGovernance`, and `setCore` functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `initialize`, `setPendingGovernance`, and `setCore` functions take addresses as input, but they do not validate that these addresses are not zero addresses. Passing a zero address could lead to unexpected behavior or contract malfunction later on."",
      ""Impact"": ""If addresses are the zero address, the contract may not function as expected, leading to potential loss of funds or denial of service.  Contract may become unusable if initialized with invalid addresses. Could also make governance functions inoperable."",
      ""Location"": ""WrappedIbbtcEth.sol: initialize function, setPendingGovernance, setCore""
    },
    {
      ""Issue"": ""Rounding Errors in `balanceOf`, `totalSupply`, `balanceToShares`, and `sharesToBalance`"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `balanceOf`, `totalSupply`, `balanceToShares`, and `sharesToBalance` perform multiplication and division with `pricePerShare`. Due to integer division, there might be rounding errors. While this is usually acceptable, it\'s important to understand the magnitude of potential errors, especially when dealing with large token amounts or small `pricePerShare` values. These rounding errors could accumulate and cause discrepancies between the wibBTC balance and the underlying ibBTC balance."",
      ""Impact"": ""Small discrepancies between the wibBTC balance and the underlying ibBTC balance, potentially leading to user confusion or small financial losses."",
      ""Location"": ""balanceOf(address account), totalSupply(), balanceToShares(uint256 balance), sharesToBalance(uint256 shares)""
    },
    {
      ""Issue"": ""Missing events on governance changes"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract emits events when the governance and core are set. It emits the `SetCore` event after setting the new core address in the `setCore` function. The contract emits the `SetPendingGovernance` event when setting the pending governance. While the `acceptPendingGovernance` emits the `AcceptPendingGovernance` event, the `governance` variable is not included in the event. Including the governance variable in the event will allow for easier tracking of the changes to the governance address. "",
      ""Impact"": ""Difficult to track changes to governance addresses."",
      ""Location"": ""setPendingGovernance, setCore, acceptPendingGovernance""
    },
    {
      ""Issue"": ""Inconsistent Naming Convention and Redundant virtual keyword"",
      ""Severity"": ""Informational"",
      ""Description"": ""There is inconsistent naming of state variables and parameters. Some parameters are prefixed with an underscore (e.g., `_governance`, `_ibbtc`, `_core`, `_pendingGovernance`, `_shares`), while some aren't. This inconsistency makes the code harder to read and understand. The `transferFrom` and `transfer` functions are marked as `virtual`, but since this contract inherits from `ERC20Upgradeable`, which already defines them as `virtual`, this is redundant."",
      ""Impact"": ""Readability and maintainability issues. None, stylistic suggestion."",
      ""Location"": ""Throughout the contract, Functions `transferFrom`, `transfer`""
    },
    {
      ""Issue"": ""Inconsistent ERC20 behavior due to shares representation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract stores balances in `shares`, and the `balanceOf` and `totalSupply` functions return token amounts based on `shares * pricePerShare / 1e18`. While compliant with ERC20, this deviates from the typical understanding that `balanceOf` directly reflects the token balance. Users interacting with the contract may be confused by the difference between their share balance (which isn't directly visible) and their token balance, especially if the pricePerShare changes frequently. This could be improved with better naming/documentation."",
      ""Impact"": ""Potential for user confusion and integration issues with existing ERC20 tooling that assumes a 1:1 mapping between `balanceOf` and the actual token balance. This is amplified by the use of transfer and transferFrom with an amount representing ibBTC and the internal calculation for the number of shares transferred. A better user experience could be had by providing utility functions to convert shares to ibBTC and vice-versa."",
      ""Location"": ""balanceOf(address account), totalSupply(), transfer(address recipient, uint256 amount), transferFrom(address sender, address recipient, uint256 amount)""
    }
  ],
  ""IssueNumber"": 31,
  ""OutputList"": 12
}",138.94647407531738,3372.0,26.0,"### **[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if updatePricePerShare wasn't run properly**

**Report Description**:
The `WrappedIbbtcEth` contract relies on the `pricePerShare` value for minting and burning operations. If the `updatePricePerShare` function is not called frequently enough, the `pricePerShare` value may become outdated. A malicious user can monitor the `SetPricePerShare` event and, if the price is outdated, exploit the discrepancy by minting tokens at the outdated price and then burning them after the price is updated. This allows the attacker to make a risk-free profit at the expense of the contract's holdings.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of using a stalled `pricePerShare` value for minting and burning operations. While there are responses related to the `updatePricePerShare` function (e.g., ""Missing Access Control on `updatePricePerShare` function""), none of them cover the risk of using outdated prices for minting and burning. This is a critical oversight, as the issue poses a significant financial risk to the contract.

---

### **[H-04] WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers**

**Report Description**:
The `WrappedIbbtc` and `WrappedIbbtcEth` contracts do not implement any mechanism to filter out price feed outliers. If the price feed is manipulated or experiences market volatility, the contracts will pass these anomalies directly to users. This creates a substantial attack surface, as malicious actors could exploit price outliers to manipulate minting and burning operations. Implementing mitigation mechanics would ensure that only sustainable price movements affect user economics.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of price feed outliers or the lack of filtering mechanisms. While there are responses related to price manipulation (e.g., ""Missing Access Control on `updatePricePerShare` function""), none of them specifically address the risk of price feed outliers or propose mitigation strategies. This is a significant gap, as price feed manipulation is a common attack vector in DeFi systems.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-03] WrappedIbbtcEth contract will use stalled price for mint/burn if updatePricePerShare wasn't run properly**
- **[H-04] WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers**

---

### **Conclusion**
The `response_list` fails to address two critical issues from the `issue` report: the use of stalled `pricePerShare` values and the lack of filtering for price feed outliers. These omissions represent significant gaps in the security analysis, as both issues pose substantial financial risks to the contracts and their users. Addressing these vulnerabilities should be a priority to ensure the robustness and security of the `WrappedIbbtc` and `WrappedIbbtcEth` contracts.","```
None.
```",0.0
