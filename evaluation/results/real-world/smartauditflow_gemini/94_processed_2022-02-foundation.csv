nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTMarketReserveAuction.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/// @param minAmount The minimum amount that must be bid in order for it to be accepted.
error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
/// @param reservePrice The current reserve price.
error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);
/// @param endTime The timestamp at which the auction had ended.
error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
/// @param endTime The timestamp at which the auction will end.
error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.
error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);
/// @param extensionDuration The extension duration, in seconds.
error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Not_Matching_Seller(address seller);
/// @param owner The current owner of the NFT.
error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();

/**
 * @title Allows the owner of an NFT to list it in auction.
 * @notice NFTs in auction are escrowed in the market contract.
 * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.
 * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.
 */
abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  /// @notice Stores the auction configuration for a specific NFT.
  struct ReserveAuction {
    /// @notice The address of the NFT contract.
    address nftContract;
    /// @notice The id of the NFT.
    uint256 tokenId;
    /// @notice The owner of the NFT which listed it in auction.
    address payable seller;
    /// @notice The duration for this auction.
    uint256 duration;
    /// @notice The extension window for this auction.
    uint256 extensionDuration;
    /// @notice The time at which this auction will not accept any new bids.
    /// @dev This is `0` until the first bid is placed.
    uint256 endTime;
    /// @notice The current highest bidder in this auction.
    /// @dev This is `address(0)` until the first bid is placed.
    address payable bidder;
    /// @notice The latest price of the NFT in this auction.
    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.
    uint256 amount;
  }

  /// @notice The auction configuration for a specific auction id.
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  /// @notice The auction id for a specific NFT.
  /// @dev This is deleted when an auction is finalized or canceled.
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private __gap_was_minPercentIncrementInBasisPoints;
   * uint256 private __gap_was_maxBidIncrementRequirement;
   * uint256 private __gap_was_duration;
   * uint256 private __gap_was_extensionDuration;
   * uint256 private __gap_was_goLiveDate;
   */
  uint256[5] private __gap_was_config;

  /// @notice How long an auction lasts for once the first bid has been received.
  uint256 private immutable DURATION;

  /// @notice The window for auction extensions, any bid placed in the final 15 minutes
  /// of an auction will reset the time remaining to 15 minutes.
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  /// @notice Caps the max duration that may be configured so that overflows will not occur.
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  /**
   * @notice Emitted when a bid is placed.
   * @param auctionId The id of the auction this bid was for.
   * @param bidder The address of the bidder.
   * @param amount The amount of the bid.
   * @param endTime The new end time of the auction (which may have been set or extended by this bid).
   */
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  /**
   * @notice Emitted when an auction is cancelled.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was cancelled.
   */
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  /**
   * @notice Emitted when an auction is canceled by a Foundation admin.
   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.
   * @param auctionId The id of the auction that was cancelled.
   * @param reason The reason for the cancellation.
   */
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  /**
   * @notice Emitted when an NFT is listed for auction.
   * @param seller The address of the seller.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param duration The duration of the auction (always 24-hours).
   * @param extensionDuration The duration of the auction extension window (always 15-minutes).
   * @param reservePrice The reserve price to kick off the auction.
   * @param auctionId The id of the auction that was created.
   */
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  /**
   * @notice Emitted when an auction that has already ended is finalized,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param auctionId The id of the auction that was finalized.
   * @param seller The address of the seller.
   * @param bidder The address of the highest bidder that won the NFT.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an auction is invalidated due to other market activity.
   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.
   * @param auctionId The id of the auction that was invalidated.
   */
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  /**
   * @notice Emitted when the seller for an auction has been changed to a new account.
   * @dev Account migrations require approval from both the original account and Foundation.
   * @param auctionId The id of the auction that was updated.
   * @param originalSellerAddress The original address of the auction's seller.
   * @param newSellerAddress The new address for the auction's seller.
   */
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  /**
   * @notice Emitted when the auction's reserve price is changed.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was updated.
   * @param reservePrice The new reserve price for the auction.
   */
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  /// @notice Confirms that the reserve price is not zero.
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  /**
   * @notice Configures the duration for auctions.
   * @param duration The duration for auctions, in seconds.
   */
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      // This ensures that math in this file will not overflow due to a huge duration.
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      // The auction duration configuration must be greater than the extension window of 15 minutes
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  /**
   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to
   * the seller (if not active buy price set).
   * This should only be used for extreme cases such as DMCA takedown requests.
   * @param auctionId The id of the auction to cancel.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Return the NFT to the owner.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      // Refund the highest bidder if any bids were placed in this auction.
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  /**
   * @notice Allows an NFT owner and Foundation to work together in order to update the seller
   * for auctions they have listed to a new account.
   * @dev This will gracefully skip any auctions that have already been finalized.
   * @param listedAuctionIds The ids of the auctions to update.
   * @param originalAddress The original address of the seller of these auctions.
   * @param newAddress The new address for the seller of these auctions.
   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`
   * signed by the original account.
   */
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    // Validate the owner of the original account has approved this change.
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      // The array length cannot overflow 256 bits.
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          // Only if the auction was found and not finalized before this transaction.

          if (auction.seller != originalAddress) {
            // Confirm that the signature approval was the correct owner of this auction.
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          // Update the auction's seller address.
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  /**
   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.
   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.
   * @param auctionId The id of the auction to cancel.
   */
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Transfer the NFT unless it still has a buy price set.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  /**
   * @notice Creates an auction for the given NFT.
   * The NFT is held in escrow until the auction is finalized or canceled.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reservePrice The initial reserve price for the auction.
   */
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.
    _transferToEscrow(nftContract, tokenId);

    // Store the auction details
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, // endTime is only known once the reserve price is met
      payable(0), // bidder is only known once a bid has been placed
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  /**
   * @notice Once the countdown has expired for an auction, anyone can settle the auction.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param auctionId The id of the auction to settle.
   */
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @param auctionId The id of the auction to bid on.
   */
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param auctionId The id of the auction to bid on.
   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.
   */
  /* solhint-disable-next-line code-complexity */
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow.
        uint256 delta = amount - msg.value;

        // Withdraw ETH from the buyer's account in the FETH token contract.
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      // No auction found
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      // This is the first bid, kicking off the auction.

      if (auction.amount > amount) {
        // The bid must be >= the reserve price.
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      // Notify other market tools that an auction for this NFT has been kicked off.
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      // Store the bid details.
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      // On the first bid, set the endTime to now + duration.
      unchecked {
        // Duration is always set to 24hrs so the below can't overflow.
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        // The auction has already ended.
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        // If this bid outbids another, it must be at least 10% greater than the last bid.
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      // Cache and update bidder state
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        // When a bid outbids another, check to see if a time extension should apply.
        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          // Current time plus extension duration (always 15 mins) cannot overflow.
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      // Refund the previous bidder
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  /**
   * @notice If an auction has been created but has not yet received bids, the reservePrice may be
   * changed by the seller.
   * @param auctionId The id of the auction to change.
   * @param reservePrice The new reserve price for this auction.
   */
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Update the current reserve price.
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  /**
   * @notice Settle an auction that has already ended.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding
   * redundant transfers if the NFT should remain in escrow, such as when the new owner
   * sets a buy price or lists it in a new auction.
   */
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      /*
       * Save gas by calling core directly since it cannot have another escrow requirement
       * (buy price set or another auction listed) until this one has been finalized.
       */
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev If an auction is found:
   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.
   *  - If the auction has not received a bid, it will invalidate the auction.
   *  - If the auction is in progress, this will revert.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        // The auction has not received any bids yet so it may be invalided.

        if (auction.seller != seller) {
          // The account trying to transfer the NFT is not the current owner.
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        // Remove the auction.
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        // If the auction has started, the highest bidder will be the new owner.

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        // Finalization will revert if the auction has not yet ended.
        _finalizeReserveAuction(auctionId, false);

        // Finalize includes the transfer, so we are done here.
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      // No auction was found

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      // NFT is not in auction
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    // Using storage saves gas since most of the data is not needed
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      // Reserve price set, confirm the seller is a match
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      // Auction in progress, confirm the highest bidder is a match
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended
      _finalizeReserveAuction(auctionId, true);
    }
  }

  /**
   * @notice Returns the minimum amount a bidder must spend to participate in an auction.
   * Bids must be greater than or equal to this value or they will revert.
   * @param auctionId The id of the auction to check.
   * @return minimum The minimum amount for a bid to be accepted.
   */
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  /**
   * @notice Returns auction details for a given auctionId.
   * @param auctionId The id of the auction to lookup.
   * @return auction The auction details.
   */
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  /**
   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.
   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return auctionId The id of the auction, or 0 if no auction is found.
   */
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Returns the seller that has the given NFT in escrow for an auction,
   * or bubbles the call up for other considerations.
   */
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",6797,677,"[H-01] NFT owner can create multiple auctions

  function `createReserveAuction()`
NFTMarketReserveAuction.sol#L325-L349 NFTMarketReserveAuction.sol#L596-L599
NFT owner can permanently lock funds of bidders.
Proof of Concept

Alice (the attacker) calls createReserveAuction, and creates one like normal. let this be auction id 1.
Alice calls createReserveAuction again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because _transferToEscrow doesn't revert if there's an existing auction. let this be Auction id 2.
Since nftContractToTokenIdToAuctionId[nftContract][tokenId] will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).
  [M-04] adminAccountMigration() Does Not Update buyPrice.seller

Submitted by leastwood, also found by cccz
NFTMarketReserveAuction.sol#L263-L292 NFTMarketBuyPrice.sol#L125-L141
The adminAccountMigration() function is called by the operator role to update all sellers' auctions. The auction.seller account is updated to the new address, however, the protocol fails to update buyPrice.seller. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then cancelBuyPrice() is called before migrating back.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();

error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);

error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();

error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);

error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();

error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);

error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();

error NFTMarketReserveAuction_Not_Matching_Seller(address seller);

error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();


abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  
  struct ReserveAuction {
    
    address nftContract;
    
    uint256 tokenId;
    
    address payable seller;
    
    uint256 duration;
    
    uint256 extensionDuration;
    
    
    uint256 endTime;
    
    
    address payable bidder;
    
    
    uint256 amount;
  }

  
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  
  
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  
  uint256[5] private __gap_was_config;

  
  uint256 private immutable DURATION;

  
  
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          

          if (auction.seller != originalAddress) {
            
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    
    _transferToEscrow(nftContract, tokenId);

    
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, 
      payable(0), 
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  
  
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;

        
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      

      if (auction.amount > amount) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      
      unchecked {
        
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        
        
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        

        if (auction.seller != seller) {
          
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        
        _finalizeReserveAuction(auctionId, false);

        
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      
      _finalizeReserveAuction(auctionId, true);
    }
  }

  
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  
  uint256[1000] private __gap;
}",3541,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify that all external calls within `_distributeFunds`, `_sendValueWithFallbackWithdraw`, `NFTMarketCore._transferFromEscrow`, and `feth.marketWithdrawFrom` are protected against reentrancy, especially considering potential cross-contract interactions."",
        ""Analyze the fallback logic in `_sendValueWithFallbackWithdraw` to ensure it cannot be exploited for reentrancy."",
        ""Check for reentrancy possibilities when handling ERC721 transfers in `NFTMarketCore._transferFromEscrow`.""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Thoroughly review the `onlyFoundationAdmin` and `onlyFoundationOperator` modifiers, confirming the correct assignment of roles and that only intended actors can call those functions."",
        ""Analyze the logic within `adminAccountMigration` to confirm that the signature verification (`AccountMigrationLibrary.requireAuthorizedAccountMigration`) is robust and prevents unauthorized account migrations."",
        ""Verify that `NFTMarketReserveAuction_Only_Owner_Can_Update_Auction` is triggered when non-owners try to cancel/update an auction."",
        ""Check for any potential privilege escalation vulnerabilities where a regular user could gain admin or operator privileges."",
        ""Ensure that `_getSellerFor` correctly identifies the seller in all possible scenarios, preventing unauthorized access to auction funds.""
      ]
    },
    {
      ""Area"": ""Bidding and Auction Logic"",
      ""Tasks"": [
        ""Examine the `placeBidOf` function for potential vulnerabilities related to manipulating bid amounts, especially regarding `feth.marketWithdrawFrom` and ensuring sufficient funds are available."",
        ""Analyze the auction extension mechanism in `placeBidOf` to verify its correctness and prevent manipulation of the auction end time."",
        ""Review the `_getMinIncrement` function (inherited from `NFTMarketAuction`) to ensure that it calculates the minimum bid increment correctly and prevents bids below the intended minimum."",
        ""Verify that the conditions for `NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid` are appropriate and that a bidder cannot inadvertently lock their funds."",
        ""Scrutinize the checks in place within `placeBidOf` to confirm that an appropriate reserve price is being met, preventing anyone from bidding less than the initial set price.""
      ]
    },
    {
      ""Area"": ""Fund Management and Distribution"",
      ""Tasks"": [
        ""Analyze the `_distributeFunds` function (inherited from `NFTMarketFees`) to ensure correct calculation and distribution of funds to the seller, creator, foundation, and other stakeholders."",
        ""Verify that the fallback withdrawal mechanism in `_sendValueWithFallbackWithdraw` handles different scenarios correctly and doesn't lead to loss of funds or unexpected behavior."",
        ""Confirm that `feth.marketWithdrawFrom` correctly deducts funds from the bidder's balance and that the function itself is secure."",
        ""Investigate if there are any potential issues relating to rounding errors in fee calculations within `_distributeFunds` that could lead to fund mismanagement."",
        ""Check whether the `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT` value is appropriate and sufficient to prevent out-of-gas errors during ETH transfers.""
      ]
    },
    {
      ""Area"": ""Escrow Management and NFT Transfers"",
      ""Tasks"": [
        ""Examine the `_transferToEscrow` and `_transferFromEscrow` functions for any potential vulnerabilities related to NFT ownership or double-spending of NFTs."",
        ""Verify that the checks in `_transferToEscrow` and `_transferFromEscrow` prevent unauthorized transfer of NFTs involved in active auctions."",
        ""Confirm that canceling an auction correctly returns the NFT to the seller and refunds any existing bids."",
        ""Analyze how the contract interacts with the underlying ERC721 contract (via `NFTMarketCore`) and confirm the transfer logic is sound and secure."",
        ""Check if there are any edge cases where NFTs could be permanently locked in the escrow.""
      ]
    },
    {
      ""Area"": ""Upgradability and Storage Gaps"",
      ""Tasks"": [
        ""Ensure that the storage gaps (`__gap_was_config`, `__gap`) are correctly sized and positioned to prevent storage collisions during upgrades."",
        ""Review the contract's upgrade history (if available) to identify any potential upgrade-related vulnerabilities or data migration issues."",
        ""Verify that the immutable `DURATION` variable is correctly initialized and cannot be changed after deployment.""
      ]
    },
    {
      ""Area"": ""Error Handling and Input Validation"",
      ""Tasks"": [
        ""Review all require/revert statements to ensure they provide informative error messages and cover all potential error conditions."",
        ""Check for any potential integer overflows or underflows, especially in arithmetic operations related to timestamps, bid amounts, and fee calculations, focusing on the unchecked blocks."",
        ""Verify that the `onlyValidAuctionConfig` modifier correctly prevents the creation of auctions with invalid reserve prices.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of the most frequently used functions (e.g., `placeBidOf`, `finalizeReserveAuction`) and identify potential areas for optimization."",
        ""Review the use of storage variables and mappings to minimize gas costs associated with storage reads and writes."",
        ""Evaluate whether any loops or complex calculations can be optimized to reduce gas consumption."",
        ""Determine if caching frequently accessed data can reduce gas costs. Inherited contracts might offer opportunities."",
        ""Evaluate if using calldata instead of memory for function arguments that are only read can reduce gas costs.""
      ]
    },
    {
      ""Area"": ""Denial of Service (DoS)"",
      ""Tasks"": [
        ""Assess the potential for DoS attacks, focusing on loops (`adminAccountMigration`), large state updates, and expensive computations."",
        ""Verify that the contract can handle a large number of auctions without exceeding gas limits or encountering other performance issues."",
        ""Review functions that rely on external calls (e.g., `_sendValueWithFallbackWithdraw`) for potential DoS vulnerabilities if the external call fails or becomes unresponsive.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `NFTMarketReserveAuction` implements a reserve auction mechanism for NFTs within a larger marketplace framework. It handles auction creation, bidding, finalization, cancellation, and administrative tasks like migration and admin cancellation. It inherits significant functionality from other contracts for core logic, fees, escrow, and security (like reentrancy guard). It uses a specific structure `ReserveAuction` to store auction details and mappings to track auctions by ID and by NFT. Bidding logic includes handling the initial reserve price, subsequent bids, auction extensions, and refunding previous bidders. It appears to be designed as part of an upgradeable system."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketReserveAuction"",
    ""Purpose"": ""To manage reserve-style auctions for NFTs, where bidding only effectively starts after the reserve price is met. It handles the lifecycle of these auctions, including creation, bidding, settlement, cancellation, and administration."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Constants"",
        ""FoundationTreasuryNode"",
        ""NFTMarketCore"",
        ""ReentrancyGuardUpgradeable"",
        ""SendValueWithFallbackWithdraw"",
        ""NFTMarketFees"",
        ""NFTMarketAuction""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""../libraries/AccountMigrationLibrary.sol"",
        ""./Constants.sol"",
        ""./FoundationTreasuryNode.sol"",
        ""./NFTMarketAuction.sol"",
        ""./NFTMarketCore.sol"",
        ""./NFTMarketFees.sol"",
        ""./SendValueWithFallbackWithdraw.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""ReserveAuction"",
        ""Type"": ""struct"",
        ""Purpose"": ""Defines the data structure for storing details of a specific reserve auction.""
      },
      {
        ""Name"": ""nftContractToTokenIdToAuctionId"",
        ""Type"": ""mapping(address => mapping(uint256 => uint256))"",
        ""Purpose"": ""Maps an NFT (contract address and token ID) to its corresponding active reserve auction ID.""
      },
      {
        ""Name"": ""auctionIdToAuction"",
        ""Type"": ""mapping(uint256 => ReserveAuction)"",
        ""Purpose"": ""Maps an auction ID to its detailed `ReserveAuction` struct.""
      },
      {
        ""Name"": ""__gap_was_config"",
        ""Type"": ""uint256[5]"",
        ""Purpose"": ""Storage gap likely for upgradeability, related to inherited contracts or previous versions.""
      },
      {
        ""Name"": ""DURATION"",
        ""Type"": ""uint256 immutable"",
        ""Purpose"": ""The default duration for auctions, set at contract deployment.""
      },
      {
        ""Name"": ""EXTENSION_DURATION"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""The duration by which an auction is extended if a bid is placed near the end time (15 minutes).""
      },
      {
        ""Name"": ""MAX_MAX_DURATION"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""The maximum allowed value for the immutable DURATION variable set during deployment (1000 days).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyValidAuctionConfig"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures that the reserve price provided is non-zero."",
        ""Parameters"": [""uint256 reservePrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, setting the immutable auction DURATION and validating it against bounds."",
        ""Parameters"": [""uint256 duration""],
        ""Returns"": []
      },
      {
        ""Name"": ""adminCancelReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a foundation admin to cancel an auction, requiring a reason. Handles NFT return and bid refund."",
        ""Parameters"": [""uint256 auctionId"", ""string calldata reason""],
        ""Returns"": []
      },
      {
        ""Name"": ""adminAccountMigration"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a foundation operator to migrate auction listings from an old seller address to a new one after verification."",
        ""Parameters"": [""uint256[] calldata listedAuctionIds"", ""address originalAddress"", ""address payable newAddress"", ""bytes memory signature""],
        ""Returns"": []
      },
      {
        ""Name"": ""cancelReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the seller to cancel an auction before it has received any bids (i.e., before endTime is set)."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""createReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates a new reserve auction, transfers the NFT to escrow, and sets the initial reserve price."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""uint256 reservePrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""finalizeReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Public function to trigger the finalization of an auction after its end time has passed."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""placeBid"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Payable function allowing users to place a bid using `msg.value`."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": []
      },
      {
        ""Name"": ""placeBidOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Core payable function for placing bids. Handles first bid (meeting reserve), subsequent bids, auction extension, and refunding the previous bidder. Allows bidding with `msg.value` or potentially other funds via `feth.marketWithdrawFrom`."",
        ""Parameters"": [""uint256 auctionId"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateReserveAuction"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the seller to update the reserve price of an auction before it has received any bids."",
        ""Parameters"": [""uint256 auctionId"", ""uint256 reservePrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""_finalizeReserveAuction"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic for settling an auction: deletes state, transfers NFT (unless `keepInEscrow` is true), distributes funds."",
        ""Parameters"": [""uint256 auctionId"", ""bool keepInEscrow""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromEscrow"",
        ""Visibility"": ""internal virtual override"",
        ""Purpose"": ""Overrides base contract logic. Handles NFT transfers out of escrow, potentially invalidating or finalizing the auction if the NFT is involved in one."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address recipient"", ""address seller""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFromEscrowIfAvailable"",
        ""Visibility"": ""internal virtual override"",
        ""Purpose"": ""Overrides base contract logic. Transfers NFT from escrow only if it's not currently locked in an auction."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId"", ""address recipient""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferToEscrow"",
        ""Visibility"": ""internal virtual override"",
        ""Purpose"": ""Overrides base contract logic. Handles NFT transfers into escrow, ensuring consistency if the NFT is already part of an auction (e.g., finalizing if bidder transfers back)."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMinBidAmount"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the minimum amount required for the next valid bid (either reserve price or calculated minimum increment)."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": [""uint256 minimum""]
      },
      {
        ""Name"": ""getReserveAuction"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the details of a specific reserve auction."",
        ""Parameters"": [""uint256 auctionId""],
        ""Returns"": [""ReserveAuction memory auction""]
      },
      {
        ""Name"": ""getReserveAuctionIdFor"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the auction ID associated with a specific NFT."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""uint256 auctionId""]
      },
      {
        ""Name"": ""_getSellerFor"",
        ""Visibility"": ""internal view virtual override"",
        ""Purpose"": ""Overrides base contract logic. Determines the seller of an NFT, prioritizing the auction's seller if applicable."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""address payable seller""]
      },
      {
        ""Name"": ""_isInActiveAuction"",
        ""Visibility"": ""internal view override"",
        ""Purpose"": ""Overrides base contract logic. Checks if an NFT is part of an auction that has started and not yet ended."",
        ""Parameters"": [""address nftContract"", ""uint256 tokenId""],
        ""Returns"": [""bool""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Inherited Contracts: Interacts heavily with functions from `NFTMarketCore` (escrow), `NFTMarketFees` (fund distribution), `NFTMarketAuction` (base auction logic like `_getMinIncrement`, `_afterAuctionStarted`, `_getNextAndIncrementAuctionId`), `SendValueWithFallbackWithdraw` (safe ETH transfer), `FoundationTreasuryNode`, `Constants`."",
    ""NFT Contracts (IERC721): Transfers NFTs using standard ERC721 functions (likely within `NFTMarketCore`)."",
    ""AccountMigrationLibrary: Uses `requireAuthorizedAccountMigration` for validating seller address changes."",
    ""`feth`: Interacts with `feth.marketWithdrawFrom` in `placeBidOf`, suggesting integration with a wrapped ETH or similar token system managed by the marketplace.""
  ],
  ""SpecialMechanisms"": [
    ""Reserve Auction Logic: Uses `endTime == 0` to distinguish between the pre-bid state (where `amount` is the reserve price) and the active auction state."",
    ""Auction Extension: Extends auction end time if a bid occurs within `EXTENSION_DURATION` of the current end time."",
    ""Upgradeable Design: Inherits `ReentrancyGuardUpgradeable` and uses `__gap` variables, indicating it's designed for use with a proxy pattern."",
    ""Reentrancy Protection: Uses the `nonReentrant` modifier on key state-changing functions."",
    ""NFT Escrow: Relies on inherited `NFTMarketCore` functionality to hold NFTs during auctions."",
    ""Safe ETH Transfer: Uses `_sendValueWithFallbackWithdraw` (presumably implementing checks and fallback) for refunds."",
    ""Admin Controls: Includes functions for admin cancellation and operator-controlled account migration."",
    ""Function Overrides: Overrides several internal functions from base contracts (`_transferFromEscrow`, `_transferToEscrow`, `_getSellerFor`, `_isInActiveAuction`) to tailor behavior for reserve auctions."",
    ""Hybrid Payment Potential: The use of `msg.value` alongside `feth.marketWithdrawFrom` suggests bids might be funded partially or fully through a separate balance mechanism.""
  ],
  ""Questions"": [
    ""What is the exact implementation and trust assumption for `feth.marketWithdrawFrom`? How are funds managed there?"",
    ""What specific logic is implemented in the inherited contracts (`NFTMarketCore`, `NFTMarketFees`, `NFTMarketAuction`, `SendValueWithFallbackWithdraw`), and are they audited?"",
    ""How is the creator fee calculated and retrieved within `_distributeFunds`?"",
    ""What is the mechanism and security model of `AccountMigrationLibrary.requireAuthorizedAccountMigration` (e.g., signature scheme, replay protection)?"",
    ""Are there potential gas limit issues in loops (`adminAccountMigration`) or complex internal calls (`_distributeFunds`, fallback withdrawals)? Is `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT` always sufficient?"",
    ""Is the use of `unchecked` blocks safe in all scenarios (e.g., timestamp arithmetic, bid difference calculation)?"",
    ""How is `_getNextAndIncrementAuctionId` implemented to ensure uniqueness across potentially different auction types within the market?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability due to `_sendValueWithFallbackWithdraw`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function, used for refunding bidders and distributing funds, introduces a reentrancy vulnerability. A malicious bidder contract can call back into the `placeBidOf` function or other functions during the refund process, potentially manipulating auction state, withdrawing more funds than intended, or causing a denial of service.  The vulnerability exists because external calls are made without proper reentrancy protection in the fallback function of the recipient contract."",
      ""Impact"": ""Loss of funds for bidders and sellers, auction manipulation, contract compromise, and denial of service."",
      ""Location"": ""`NFTMarketReserveAuction.placeBidOf`, `SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw`, `NFTMarketReserveAuction._finalizeReserveAuction`, `NFTMarketCore._transferFromEscrow`, `adminCancelReserveAuction`, `_distributeFunds`""
    },
    {
      ""Issue"": ""Missing Check if NFT contract supports ERC721"",
      ""Severity"": ""High"",
      ""Description"": ""The contract does not validate if the provided `nftContract` address implements the `IERC721` interface, leading to potential failures and DoS."",
      ""Impact"": ""Contract could become unusable if an invalid NFT contract address is used."",
      ""Location"": ""Functions `createReserveAuction`, `_transferToEscrow`, `_transferFromEscrow`.""
    },
    {
      ""Issue"": ""Lack of access control for `feth.marketWithdrawFrom` in `placeBidOf`"",
      ""Severity"": ""High"",
      ""Description"": ""The `placeBidOf` function calls `feth.marketWithdrawFrom(msg.sender, delta);` without any access control. This implies that the caller of `placeBidOf` needs to have an approved allowance for `feth` to withdraw from them. If the caller does not have allowance, or if `feth` is uninitialized, this will lead to transaction failure."",
      ""Impact"": ""Users may be unable to participate in auctions."",
      ""Location"": ""`placeBidOf` function, `feth.marketWithdrawFrom` call.""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `placeBidOf` when calculating `delta` and Timestamp Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `placeBidOf`, the code calculates `delta = amount - msg.value`. If `amount < msg.value`, this could lead to an underflow, resulting in a very large value for `delta`. Also,  explicit unchecked blocks are used for timestamp calculations. If `block.timestamp + auction.duration` or `block.timestamp + auction.extensionDuration` exceeds the maximum value of a `uint256`, it will wrap around to zero and cause incorrect auction end times."",
      ""Impact"": ""Unexpected fund withdrawals, auction manipulation, auctions ending prematurely or lasting much longer than intended, potential loss of funds, and unpredictable behavior."",
      ""Location"": ""`NFTMarketReserveAuction.placeBidOf`, `NFTMarketReserveAuction.sol:294` and `NFTMarketReserveAuction.sol:307`""
    },
    {
      ""Issue"": ""Insufficient Input Validation and Incorrect Logic in `adminAccountMigration`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `adminAccountMigration` function iterates through `listedAuctionIds` and updates the `auction.seller` address. It lacks validation whether the auction IDs are associated with the provided `originalAddress` or if `newAddress` is a valid, non-zero, and non-contract address. An attacker could potentially provide arbitrary auction IDs, leading to unintended modifications of auction seller addresses or sending funds to the zero address."",
      ""Impact"": ""Incorrectly updated auction seller addresses, potential loss of control over auctions, potential loss of funds if the new address is set to the zero address, potential denial of service."",
      ""Location"": ""`NFTMarketReserveAuction.adminAccountMigration`""
    },
    {
      ""Issue"": ""Potential Denial of Service in `adminCancelReserveAuction` and `_finalizeReserveAuction` due to `_sendValueWithFallbackWithdraw` and external calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""If `auction.bidder` is a contract that reverts when receiving ether, the `_sendValueWithFallbackWithdraw` call in `adminCancelReserveAuction` will fail, causing the entire transaction to revert.  Also `_finalizeReserveAuction` calls `_distributeFunds` to external calls to distribute the fund, it can cause DoS."",
      ""Impact"": ""Inability to cancel auctions, NFT locked in contract, potential griefing attack by malicious bidders, denial of service, preventing legitimate auctions from being finalized if any of the fund recipients are malicious contracts."",
      ""Location"": ""`NFTMarketReserveAuction.adminCancelReserveAuction`, `SendValueWithFallbackWithdraw._sendValueWithFallbackWithdraw`, `_finalizeReserveAuction`, `NFTMarketCore._transferFromEscrow`""
    },
    {
      ""Issue"": ""Missing Check for NFT Ownership in `createReserveAuction`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createReserveAuction` function does not explicitly verify that the `msg.sender` owns the NFT (`nftContract`, `tokenId`) being put up for auction, leading to wasted gas and potential complications."",
      ""Impact"": ""Wasted gas for users who try to create auctions for NFTs they don't own. Potential for unexpected behavior or complications during the `_transferToEscrow` process. Creation of invalid auctions, potential for market disruption."",
      ""Location"": ""`NFTMarketReserveAuction.createReserveAuction`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `placeBidOf`, `placeBid` and `createReserveAuction`"",
      ""Severity"": ""Medium"",
      ""Description"": ""A malicious actor could monitor the mempool for pending `placeBid` or `placeBidOf` transactions and front-run them with a higher bid.  Also, an attacker can monitor the mempool for `createReserveAuction` transactions and front-run them."",
      ""Impact"": ""An attacker could front-run bids to win auctions unfairly, potentially stealing NFTs from legitimate bidders. A malicious actor can disrupt NFT listings by consuming the intended `auctionId`s."",
      ""Location"": ""Functions `placeBid` and `placeBidOf`, NFTMarketReserveAuction.sol:187""
    },
    {
      ""Issue"": ""Potential Griefing Attack: Canceling Auction Right Before End Time"",
      ""Severity"": ""Medium"",
      ""Description"": ""A malicious seller can call `cancelReserveAuction` right before the auction's `endTime`, potentially griefing a bidder who intended to finalize the auction."",
      ""Impact"": ""Potential for a malicious seller to prevent a bidder from winning the auction."",
      ""Location"": ""NFTMarketReserveAuction.sol:cancelReserveAuction""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculation within `_distributeFunds`"",
      ""Severity"": ""Medium"",
      ""Description"": ""Integer overflow or underflow during fee calculations within the `_distributeFunds` function could lead to incorrect fee distribution, loss of funds for the seller or other stakeholders, or even unexpected reverts."",
      ""Impact"": ""Incorrect fee calculations can result in financial losses for the involved parties, potentially undermining trust in the platform."",
      ""Location"": ""NFTMarketReserveAuction.sol:341 (call to `_distributeFunds`)""
    },
    {
      ""Issue"": ""Incorrect `_transferToEscrow` logic after an auction has started and Inconsistent access control in `_transferFromEscrow`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_transferToEscrow` function logic allows the bidder to call this function after an auction has already started by calling `_finalizeReserveAuction`, but it doesn't check if the endTime has passed or not. Also, the `_transferFromEscrow` function has different checks depending if the auction has started or not."",
      ""Impact"": ""Potential to block the NFT being sold"",
      ""Location"": ""NFTMarketReserveAuction.sol:440-450, NFTMarketReserveAuction.sol:396-420""
    },
    {
      ""Issue"": ""Inconsistent use of `msg.value` and `amount` in `placeBidOf`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `placeBidOf` function uses `msg.value` to extract the actual amount of ether sent.  It then uses an `amount` parameter. The contract performs checks `amount < msg.value` and `amount > msg.value`. If `amount` is equal to `msg.value` then no checks are performed and everything is fine. When `amount < msg.value` it immediately reverts. When `amount > msg.value` the contract attempts to withdraw from the user\'s `feth` balance."",
      ""Impact"": ""Unexpected state changes and potentially incorrect accounting of bid amounts if `feth.marketWithdrawFrom` fails."",
      ""Location"": ""`NFTMarketReserveAuction.sol:272-282`""
    },
    {
      ""Issue"": ""Centralization of Auction Cancellation via `adminCancelReserveAuction`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `adminCancelReserveAuction` function allows the foundation admin to cancel any auction with a provided reason. This introduces a centralized point of control."",
      ""Impact"": ""Potential for unfair or malicious auction cancellations by the foundation admin, leading to financial losses and mistrust."",
      ""Location"": ""Function `adminCancelReserveAuction`.""
    },
    {
      ""Issue"": ""Potential Denial of Service with Large `listedAuctionIds` in `adminAccountMigration`"",
      ""Severity"": ""Low"",
      ""Description"": ""A large number of auction IDs in `listedAuctionIds` for `adminAccountMigration` could potentially lead to a transaction that exceeds the block gas limit, causing a denial of service (DoS)."",
      ""Impact"": ""DoS, inability for the administrator to migrate accounts in a timely manner."",
      ""Location"": ""`NFTMarketReserveAuction.sol:145-161`""
    },
    {
      ""Issue"": ""Incorrect Check for Auction Cancellation in `cancelReserveAuction`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `cancelReserveAuction` function checks `auction.endTime != 0` to ensure that the auction is not in progress before cancelling it. However, if `endTime` is zero, this means that the auction has not even started, therefore the check `auction.endTime != 0` will pass, preventing cancellation. There is no explicit check to verify that the auction actually exists before attempting to cancel it"",
      ""Impact"": ""Inability to cancel auctions that have not yet started and the incorrect display of errors. Incorrect code may result in DoS."",
      ""Location"": ""`NFTMarketReserveAuction.cancelReserveAuction`""
    },
    {
      ""Issue"": ""Lack of Validation of `newAddress` in `adminAccountMigration`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `adminAccountMigration` function updates the `seller` address for multiple auctions. There isn't explicit validation that `newAddress` is a valid and active account."",
      ""Impact"": ""Potential loss of control over auctions, funds being sent to an incorrect or unusable address."",
      ""Location"": ""`NFTMarketReserveAuction.sol:145-161`""
    },
    {
      ""Issue"": ""Unnecessary `payable` Type in `ReserveAuction` struct for `bidder`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `bidder` field in the `ReserveAuction` struct is defined as `address payable`. While technically correct, it\'s generally recommended to use `address` and then cast to `address payable` at the point of sending value."",
      ""Impact"": ""Code clarity and maintainability are slightly reduced."",
      ""Location"": ""NFTMarketReserveAuction.sol:ReserveAuction struct""
    },
    {
      ""Issue"": ""Unchecked arithmetic in `placeBidOf`"",
      ""Severity"": ""Low"",
      ""Description"": ""The lines `uint256 delta = amount - msg.value;` and `auction.endTime = block.timestamp + auction.duration;`, `auction.endTime = block.timestamp + auction.extensionDuration;` are within an unchecked block."",
      ""Impact"": ""Potential unexpected behavior or vulnerabilities in specific scenarios (though unlikely)."",
      ""Location"": ""NFTMarketReserveAuction.sol:277-280, 288, 305""
    },
    {
      ""Issue"": ""Unnecessary use of memory keyword on `ReserveAuction` structs in `cancelReserveAuction` and `adminCancelReserveAuction`"",
      ""Severity"": ""Informational"",
      ""Description"": ""The functions `cancelReserveAuction` and `adminCancelReserveAuction` define the `auction` variable as memory which causes it to copy it from storage."",
      ""Impact"": ""Minor increase in gas cost."",
      ""Location"": ""`cancelReserveAuction` and `adminCancelReserveAuction`""
    }
  ],
  ""IssueNumber"": 40,
  ""OutputList"": 18
}",224.7496490478516,4072.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] NFT owner can create multiple auctions**

**Report Description**:  
The `createReserveAuction()` function in `NFTMarketReserveAuction.sol` allows an NFT owner to create multiple auctions for the same NFT. This occurs because `_transferToEscrow` does not revert if there is an existing auction. As a result, the NFT owner can create a second auction (Auction ID 2) while the first auction (Auction ID 1) is still active. Bidders will only see Auction ID 2, potentially leading to confusion and locked funds if they bid on the wrong auction. This vulnerability allows the NFT owner to permanently lock bidders' funds.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The vulnerability described in the report is unique and not covered by any of the findings in the response list. The response list focuses on issues like reentrancy, missing ERC721 checks, and access control, but it does not mention the possibility of creating multiple auctions for the same NFT or the associated risks.

---

#### **[M-04] adminAccountMigration() Does Not Update buyPrice.seller**

**Report Description**:  
The `adminAccountMigration()` function updates the `auction.seller` address but fails to update the `buyPrice.seller` address. This inconsistency creates a deadlock where the new address cannot cancel the auction or withdraw the NFT without the compromised account first canceling the buy price. The issue is only recoverable if the new account is migrated back to the compromised account, and `cancelBuyPrice()` is called before migrating back.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Input Validation and Incorrect Logic in `adminAccountMigration`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `adminAccountMigration` but focuses on insufficient input validation and incorrect logic rather than the specific deadlock caused by not updating `buyPrice.seller`. While the response correctly highlights problems with the function, it misses the critical detail of the deadlock scenario, which is the core issue in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-04] adminAccountMigration() Does Not Update buyPrice.seller**

**Missed Issues from Issue Report**:  
- **[H-01] NFT owner can create multiple auctions**

---

### **Conclusion**  
The response list partially addresses one issue ([M-04]) but misses the critical vulnerability described in [H-01]. The response list could be improved by including findings related to the creation of multiple auctions for the same NFT and the associated risks of locking bidders' funds. Additionally, the response for [M-04] could be enhanced by explicitly mentioning the deadlock scenario caused by not updating `buyPrice.seller`.","```
None.
```",0.0
NFTMarketCreators.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();

/**
 * @title A mixin for associating creators to NFTs.
 * @dev In the future this may store creators directly in order to support NFTs created on a different platform.
 */
abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  /**
   * @notice Configures the registry allowing for royalty overrides to be defined.
   * @param _royaltyRegistry The registry to use for royalty overrides.
   */
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  /**
   * @notice Looks up the royalty payment configuration for a given NFT.
   * @dev This will check various royalty APIs on the NFT and the royalty override
   * if one was registered with the royalty registry. This aims to send royalties
   * in the manner requested by the NFT owner, regardless of where the NFT was minted.
   */
  // solhint-disable-next-line code-complexity
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented

    // 1st priority: ERC-2981
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 /* royaltyAmount */
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 2nd priority: getRoyalties
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            // The array length cannot overflow 256 bits.
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.
       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */
    // The registry requires overrides are not 0 and contracts when set.
    // If no override is set, the nftContract address is returned.
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          // The functions above are repeated here if an override is set.

          // 3rd priority: ERC-2981 override
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 /* royaltyAmount */
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }

          // 4th priority: getRoyalties override
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Ignore out of gas errors and continue using the nftContract address
      }
    }

    // 5th priority: getFee* from contract or override
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                // The array length cannot overflow 256 bits.
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch // solhint-disable-next-line no-empty-blocks
          {
            // Fall through
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          // Only pay the tokenCreator if there wasn't another royalty defined
          recipients = new address payable[](1);
          recipients[0] = _creator;
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // 7th priority: owner from contract or override
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        // Only pay the owner if there wasn't another royalty defined
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // If no valid payment address or creator is found, return 0 recipients
  }

  /**
   * @notice Returns the address of the registry allowing for royalty configuration overrides.
   * @return registry The address of the royalty registry contract.
   */
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.
   */
  uint256[500] private __gap;
}",2363,268,"[H-02] Creators can steal sale revenue from owners' sales

Submitted by IllIllI
NFTMarketCreators.sol#L158-L160 NFTMarketCreators.sol#L196-L198 NFTMarketCreators.sol#L97-L99
According to the README.md:
All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.
Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.
  [M-07] _getCreatorPaymentInfo() is Not Equipped to Handle Reverts on an Unbounded _recipients Array

Submitted by leastwood
NFTMarketCreators.sol#L49-L251
The _getCreatorPaymentInfo() function is utilised by _distributeFunds() whenever an NFT sale is made. The function uses try and catch statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a try statement, the revert is actually not handled and it will not fall through to the empty catch statement.

[M-15] Royalties can be distribution unfairly among creatorRecipients for NFT contracts with non-standard getRoyalties() returns

Submitted by WatchPug
Based on our research, getRoyalties() is not a standardized API for NFT contracts to indicate how the royalties should be distributed among the recipients.
However, in the current implementation, it always assumes that getRoyalties() return in terms of BPS.
NFTMarketCreators.sol#L85-L112
NFTMarketFees.sol#L86-L90
if (creatorShares[i] > BASIS_POINTS) {
    // If the numbers are >100% we ignore the fee recipients and pay just the first instead
    maxCreatorIndex = 0;
    break;
}

As a result, if a particular implementation is returning get Royalties() with higher precision (say 1e6 for 100% instead of 1e4/BPS), the distribution of royalties can be distorted.
",3,,"pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();


abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable 
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  
  
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    

    
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch 
      {
        
      }
    }

    
    
    
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          

          
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch 
            {
              
            }
          }

          
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch 
            {
              
            }
          }
        }
      } catch 
      {
        
      }
    }

    
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch 
          {
            
          }
        }
      } catch 
      {
        
      }
    }

    
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          
          recipients = new address payable[](1);
          recipients[0] = _creator;
          
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch 
    {
      
    }

    
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch 
    {
      
    }

    
  }

  
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  
  uint256[500] private __gap;
}",1579,1,2,"{
  ""task_list"": [
    {
      ""Area"": ""Royalty Logic and Accuracy"",
      ""Tasks"": [
        ""Verify that the fallback mechanism in `_getCreatorPaymentInfo` correctly prioritizes royalty retrieval according to the specified order (EIP-2981, IGetRoyalties, Manifold Registry, IGetFees, ITokenCreator, IOwnable)."",
        ""Analyze the logic within each royalty retrieval method in `_getCreatorPaymentInfo` to ensure correct interpretation of royalty data (addresses and basis points)."",
        ""Confirm that `splitPerRecipientInBasisPoints` is always correctly populated based on retrieved information, especially when using EIP-2981 (IRoyaltyInfo). If not, confirm the caller handles the single-recipient case correctly."",
        ""Investigate the behavior of `_getCreatorPaymentInfo` when multiple royalty interfaces return conflicting information. Determine how conflicts are resolved and whether this behavior is intended."",
        ""Analyze the gas cost of `_getCreatorPaymentInfo` in various scenarios (different royalty interfaces supported, different numbers of recipients) to identify potential gas inefficiencies."",
        ""Verify that the `READ_ONLY_GAS_LIMIT` is sufficient to prevent out-of-gas errors during external calls within `_getCreatorPaymentInfo`, while still being restrictive enough to prevent abuse.""
      ]
    },
    {
      ""Area"": ""Manifold Royalty Registry Integration"",
      ""Tasks"": [
        ""Ensure that the address passed as `_royaltyRegistry` in the constructor is a valid and trusted implementation of `IRoyaltyRegistry`."",
        ""Verify that the `getRoyaltyLookupAddress` function in the `royaltyRegistry` contract functions as expected and doesn't introduce any unexpected behavior or security risks."",
        ""Analyze the impact of the Manifold Royalty Registry override on gas costs and potential vulnerabilities (e.g., pointing to a malicious contract).""
      ]
    },
    {
      ""Area"": ""Interface Compliance and ERC165 Checks"",
      ""Tasks"": [
        ""Review the implementations of the custom interfaces (`IGetFees`, `IGetRoyalties`, `ITokenCreator`) to ensure they adhere to the expected behavior and don't introduce any vulnerabilities."",
        ""Verify that the ERC165 interface checks are used correctly to prevent calls to unsupported functions. Check that the interface IDs are correct."",
        ""Investigate the behavior of the contract if an NFT contract incorrectly claims to support a royalty interface via ERC165 but doesn't actually implement it correctly. Ensure that the `try...catch` blocks handle such cases gracefully.""
      ]
    },
    {
      ""Area"": ""Security Considerations"",
      ""Tasks"": [
        ""While `_getCreatorPaymentInfo` is a `view` function, ensure that the parent contracts using this inherit `ReentrancyGuardUpgradeable` and use it to protect state-changing functions that interact with external contracts based on results from `_getCreatorPaymentInfo`."",
        ""Verify that the `payable` type conversions are handled correctly and don't introduce any vulnerabilities."",
        ""Analyze potential integer overflow/underflow issues in calculations related to royalty splits. Although using solidity 0.8+, it's good to double check."",
        ""Assess the risk of denial-of-service attacks if any of the external calls within `_getCreatorPaymentInfo` become unresponsive or consume excessive gas.""
      ]
    },
    {
      ""Area"": ""Naming and Clarity"",
      ""Tasks"": [
        ""Rename the `isCreator` return variable in `_getCreatorPaymentInfo` to something more descriptive, such as `isSellerARecipient`, to better reflect its actual meaning."",
        ""Review the documentation and comments within the code to ensure they accurately describe the contract's functionality and intended usage.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines an abstract contract `NFTMarketCreators` intended to be inherited by NFT marketplace contracts. It provides a core internal function `_getCreatorPaymentInfo` to determine royalty recipients and their splits for a given NFT sale. It employs a sophisticated fallback mechanism, checking multiple royalty standards (EIP-2981, custom interfaces, Manifold Royalty Registry) and creator/owner information. The contract uses OpenZeppelin's ReentrancyGuard for security (though the provided function is `view`) and is designed with upgradeability in mind (indicated by `Upgradeable` suffix and `__gap`). External calls are wrapped in try-catch blocks and use gas limits."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketCreators"",
    ""Purpose"": ""To provide a standardized way for inheriting marketplace contracts to determine royalty recipients and their payment splits for NFT sales, supporting multiple royalty standards and fallback mechanisms."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Constants"",
        ""ReentrancyGuardUpgradeable""
      ],
      ""Imports"": [
        ""./OZ/ERC165Checker.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""./Constants.sol"",
        ""../interfaces/IGetFees.sol"",
        ""../interfaces/IGetRoyalties.sol"",
        ""../interfaces/IOwnable.sol"",
        ""../interfaces/IRoyaltyInfo.sol"",
        ""../interfaces/ITokenCreator.sol"",
        ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""royaltyRegistry"",
        ""Type"": ""IRoyaltyRegistry"",
        ""Purpose"": ""Stores an immutable reference to the Manifold Royalty Registry contract, used for royalty lookup overrides.""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[500]"",
        ""Purpose"": ""Storage gap to allow adding new state variables in future upgrades without causing storage layout collisions, common in upgradeable contracts.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""internal (effectively public during deployment)"",
        ""Purpose"": ""Initializes the contract by setting the `royaltyRegistry` address after verifying it supports the `IRoyaltyRegistry` interface."",
        ""Parameters"": [
          ""address _royaltyRegistry""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_getCreatorPaymentInfo"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Determines royalty recipients and splits for an NFT using a fallback strategy: 1. EIP-2981 (`IRoyaltyInfo`), 2. Custom `IGetRoyalties`, 3. Manifold Registry Override (then retry 1 & 2), 4. Custom `IGetFees`, 5. `ITokenCreator`, 6. `IOwnable`. Also checks if the seller is among the recipients."",
        ""Parameters"": [
          ""address nftContract"",
          ""uint256 tokenId"",
          ""address seller""
        ],
        ""Returns"": [
          ""address payable[] memory recipients"",
          ""uint256[] memory splitPerRecipientInBasisPoints"",
          ""bool isCreator (actually indicates if seller is a recipient)""
        ]
      },
      {
        ""Name"": ""getRoyaltyRegistry"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the configured Manifold Royalty Registry."",
        ""Parameters"": [],
        ""Returns"": [
          ""address registry""
        ]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Calls `supportsInterface` on the `_royaltyRegistry` address in the constructor."",
    ""Calls `supportsInterface` / `supportsERC165Interface` on the `nftContract` / `overrideContract` address."",
    ""Calls `royaltyInfo` on contracts supporting `IRoyaltyInfo` (EIP-2981)."",
    ""Calls `getRoyalties` on contracts supporting `IGetRoyalties`."",
    ""Calls `getRoyaltyLookupAddress` on the `royaltyRegistry` contract."",
    ""Calls `getFeeRecipients` and `getFeeBps` on contracts supporting `IGetFees`."",
    ""Calls `tokenCreator` on contracts supporting `ITokenCreator`."",
    ""Calls `owner` on contracts supporting `IOwnable`."",
    ""All external calls within `_getCreatorPaymentInfo` are limited by `READ_ONLY_GAS_LIMIT` and wrapped in `try...catch` blocks.""
  ],
  ""SpecialMechanisms"": [
    ""**Royalty Standard Fallback:** Implements a specific priority order for retrieving royalty information from various on-chain sources."",
    ""**Manifold Royalty Registry Integration:** Uses the Manifold registry to check for royalty overrides."",
    ""**ERC165 Interface Checks:** Relies heavily on ERC165 to dynamically check for supported interfaces before making external calls."",
    ""**Upgradeable Contract Structure:** Inherits `ReentrancyGuardUpgradeable` and includes a `__gap` for storage layout preservation, indicating it's designed for use within an upgradeable system."",
    ""**Gas Limiting on View Calls:** Applies a `READ_ONLY_GAS_LIMIT` to external view/pure calls."",
    ""**Error Handling:** Uses `try...catch` extensively to gracefully handle failures in external calls during the royalty lookup process."",
    ""**Custom Error:** Defines `NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry`.""
  ],
  ""Questions"": [
    ""What are the specific values for `BASIS_POINTS` and `READ_ONLY_GAS_LIMIT` defined in the imported `Constants` contract?"",
    ""What are the exact interface definitions for the custom interfaces (`IGetFees`, `IGetRoyalties`, `ITokenCreator`)?"",
    ""In the `_getCreatorPaymentInfo` function, when EIP-2981 (`IRoyaltyInfo`) provides a single receiver, the `splitPerRecipientInBasisPoints` array is not explicitly populated. Is the expectation that the caller handles this single-recipient case, assuming 100% of the royalty goes to that recipient?"",
    ""The return value `isCreator` seems misleadingly named. It actually indicates if the `seller` address matches one of the identified royalty recipients, the token creator, or the owner. Would renaming it (e.g., `isSellerARecipient`) improve clarity?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unbounded loop vulnerability in IGetRoyalties and IGetFees interface checks"",
      ""Severity"": ""High"",
      ""Description"": ""The `_getCreatorPaymentInfo` function iterates through the `_recipients` array in both IGetRoyalties and IGetFees interface checks using an unchecked loop in the IGetRoyalties Interface. If `_recipients.length` is close to the maximum `uint256` value, the loop could potentially wrap around, leading to an out-of-bounds access, denial of service (DoS) via revert, or unexpected behavior. Although the loop is not unchecked in IGetFees it stills poses a risk if a large number of recipients is passed."",
      ""Impact"": ""Potential denial of service due to gas exhaustion or out-of-bounds access. In the IGetRoyalties case there is a vulnerability due to the `unchecked` loop."",
      ""Location"": ""_getCreatorPaymentInfo function; IGetRoyalties interface check (unchecked loop); IGetFees interface check (large number of recipients).""
    },
    {
      ""Issue"": ""Missing Split Information for Token Creator and Ownable fallback mechanisms and Missing basis points initialization"",
      ""Severity"": ""Medium"",
      ""Description"": ""When the contract attempts to determine creator payment information, it uses fallbacks to `ITokenCreator` and `IOwnable` if no other royalty information is available.  If the `tokenCreator` or `owner` is found, the `_getCreatorPaymentInfo` function initializes `recipients` to an array containing the creator/owner. However, `splitPerRecipientInBasisPoints` is not populated in these cases, or in other locations where the `recipients` array is initialized. This means the default value (all zeros) will be used, potentially leading to incorrect royalty distribution, which effectively means 0 royalty."",
      ""Impact"": ""Incorrect or absent royalty distribution to creators and owners when no other royalty mechanisms are implemented or incorrect royalty splitting if only recipient addresses are populated and corresponding basis points are not."",
      ""Location"": ""NFTMarketCreators.sol:_getCreatorPaymentInfo function, specifically within the ITokenCreator and IOwnable blocks and multiple locations where `recipients` array is initialized.""
    },
    {
      ""Issue"": ""Lack of upper bound check on recipientBasisPoints in IGetRoyalties and IGetFees calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract retrieves `recipientBasisPoints` from `IGetRoyalties` and `IGetFees` calls. However, there is no check to ensure that the sum of these basis points does not exceed `BASIS_POINTS` (typically 10000). If the sum exceeds this value, the calculated royalties will be incorrect and could lead to unexpected behavior or loss of funds."",
      ""Impact"": ""Incorrect royalty calculations, potential loss of funds, or unexpected behavior."",
      ""Location"": ""NFTMarketCreators.sol, within `_getCreatorPaymentInfo` function: after retrieving `recipientBasisPoints` from `IGetRoyalties` and `IGetFees` calls.""
    },
    {
      ""Issue"": ""Unchecked Array Length in IGetRoyalties Interface Handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The code iterates through `_recipients` and `recipientBasisPoints` arrays obtained from the `IGetRoyalties` interface. Although there\'s a check to ensure that both arrays have the same length, there is no upper bound check for `_recipients.length`. An extremely large array could potentially lead to a gas exhaustion attack during the `for` loop or memory allocation issues."",
      ""Impact"": ""Potential denial-of-service due to gas exhaustion or memory allocation failure, especially if a malicious NFT contract returns very large arrays in the `getRoyalties` function."",
      ""Location"": ""NFTMarketCreators.sol:_getCreatorPaymentInfo function, IGetRoyalties interface handling""
    },
    {
      ""Issue"": ""Gas Limit on External Calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The code uses a hardcoded `READ_ONLY_GAS_LIMIT` for external calls to various interfaces. This limits the gas available for these external calls and might cause them to fail if the called contracts\' logic is more complex or consumes more gas than anticipated. The `try...catch` blocks will silently ignore such failures, potentially leading to incorrect royalty calculations or missed payments and potential DoS."",
      ""Impact"": ""Functionality might be broken or unreliable if external calls consume more gas than `READ_ONLY_GAS_LIMIT`. Royalties might not be correctly calculated or paid to creators. The `try...catch` block hides the actual reason for failure. Marketplace functionality might be disabled for specific NFTs."",
      ""Location"": ""NFTMarketCreators.sol:_getCreatorPaymentInfo function, all interface calls within try...catch blocks and all calls with `{ gas: READ_ONLY_GAS_LIMIT }`.""
    },
    {
      ""Issue"": ""Inconsistent handling of seller address in royalty/fee distribution"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_getCreatorPaymentInfo` function checks if a royalty recipient is the seller. If so, it returns immediately with `isCreator = true`. However, this logic is not consistently applied across all interfaces. The function may return before processing all the possible recipients leading to early termination. It should continue to gather all valid recipients before returning. Also if the seller is maliciously set as a recipient with an incorrect or zero basis point, the intended recipients may not receive their due royalties because the function exits early."",
      ""Impact"": ""Incorrect royalty or fee distribution if the seller is one of multiple recipients. Premature return can lead to other recipients not receiving their share, potentially causing financial loss and violating intended smart contract behavior. Royalties can be manipulated, potentially bypassing intended recipients and altering fund distribution. The seller can maliciously set themselves as royalty recipient."",
      ""Location"": ""_getCreatorPaymentInfo function; IRoyaltyInfo, IGetRoyalties, and IGetFees interface checks and checks for `receiver == seller` or `_recipients[i] == seller`.""
    },
    {
      ""Issue"": ""Potential issues with Royalty Registry override leading to unexpected behavior."",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract attempts to retrieve an `overrideContract` from `royaltyRegistry`. If it finds a different contract and uses it, the contract interacting with this function might not know it is interacting with another royalty contract, thus trusting the `nftContract` is the same. This may have unexpected issues."",
      ""Impact"": ""Trust in `nftContract` may lead to wrong royalty distribution issues since it will be interacting with `overrideContract` instead."",
      ""Location"": ""_getCreatorPaymentInfo function; check for `royaltyRegistry.getRoyaltyLookupAddress`""
    },
    {
      ""Issue"": ""Unbounded Loops could lead to denial of service"",
      ""Severity"": ""Low"",
      ""Description"": ""The loops in `_getCreatorPaymentInfo` iterating over `_recipients` could potentially lead to denial of service (DoS) if the length of `_recipients` becomes excessively large.  While it\'s expected that these arrays will be small, there is no explicit limit enforced, and malicious or poorly designed contracts could exploit this by returning very large arrays."",
      ""Impact"": ""Potential denial-of-service if an NFT contract returns excessively large arrays of recipients for royalty/fee distribution."",
      ""Location"": ""NFTMarketCreators.sol:_getCreatorPaymentInfo function, loops iterating through _recipients arrays.""
    },
    {
      ""Issue"": ""Missing checks in the constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor checks that `_royaltyRegistry` supports the `IRoyaltyRegistry` interface, but it does not check for a zero address. Sending the zero address to the constructor will brick the contract because the `royaltyRegistry` will be assigned the zero address."",
      ""Impact"": ""If the royaltyRegistry is set to zero address in the constructor, the contract may behave unexpectedly. Any call to `royaltyRegistry.getRoyaltyLookupAddress` may revert."",
      ""Location"": ""NFTMarketCreators.sol:constructor""
    },
    {
      ""Issue"": ""Seller can receive royalties if they are the creator or owner."",
      ""Severity"": ""Low"",
      ""Description"": ""The `_getCreatorPaymentInfo` function contains logic to check if the receiver of royalties is the seller. If the seller is also the creator or owner of the NFT, they will receive the royalties. This might be the intended behavior, but it\'s important to highlight as it could be unexpected in some use cases."",
      ""Impact"": ""The seller receives royalties, which may or may not be desirable."",
      ""Location"": ""NFTMarketCreators.sol, within `_getCreatorPaymentInfo` function: multiple `if (receiver == seller)` checks.""
    },
    {
      ""Issue"": ""Potential gas inefficiency due to multiple ERC165 interface checks."",
      ""Severity"": ""Low"",
      ""Description"": ""The contract repeatedly checks for ERC165 interface support using `nftContract.supportsERC165Interface(...)` for `IRoyaltyInfo`, `IGetRoyalties`, and `IGetFees`. These checks can be relatively expensive in terms of gas.  Consider caching the interface support results to reduce gas consumption and the logic for handling each interface is also very similar and could be refactored into a single function to reduce code duplication and improve readability."",
      ""Impact"": ""Increased gas costs for `_getCreatorPaymentInfo` function calls."",
      ""Location"": ""NFTMarketCreators.sol, within `_getCreatorPaymentInfo` function: multiple calls to `nftContract.supportsERC165Interface(...)` and redundant code blocks.""
    },
    {
      ""Issue"": ""Unchecked arithmetic in loops may lead to overflows"",
      ""Severity"": ""Low"",
      ""Description"": ""The `unchecked` block around the for loop in IGetRoyalties section only disables overflow checks. While the length of loop might be safe, operations inside the loop could still cause unintended arithmetic overflows, depending on input `_recipients.length` and `i` values."",
      ""Impact"": ""Potential for incorrect calculations or unexpected behavior if overflows occur."",
      ""Location"": ""NFTMarketCreators.sol, within `_getCreatorPaymentInfo` function, in the IGetRoyalties handling section, inside the `unchecked` block.""
    },
    {
      ""Issue"": ""Potential Reentrancy Risk with Payable Addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""Although the contract inherits `ReentrancyGuardUpgradeable`, the `_getCreatorPaymentInfo` function retrieves payable addresses from external contracts and uses them as recipients for royalty payments. If a malicious contract implements one of the interfaces and returns an address that can re-enter the calling contract during a payment, there\'s a risk of reentrancy."",
      ""Impact"": ""Reentrancy vulnerability if a malicious creator address gains control and can manipulate the payout logic."",
      ""Location"": ""NFTMarketCreators.sol:_getCreatorPaymentInfo function, handling of recipients array from various interfaces.""
    },
    {
      ""Issue"": ""Missing Error Handling for Registry Lookup"",
      ""Severity"": ""Low"",
      ""Description"": ""When using the `royaltyRegistry.getRoyaltyLookupAddress` function, the returned address is assigned to `nftContract`. If `getRoyaltyLookupAddress` returns address(0), the code will proceed with address(0) as the contract address and potentially fail. Although the try-catch should catch this, it will silently move on without any indication of a lookup failure or invalid address being used."",
      ""Impact"": ""Unexpected behavior if the royalty registry returns address(0) as a royalty lookup address. The royalty split logic may try to call methods on the zero address."",
      ""Location"": ""NFTMarketCreators.sol:_getCreatorPaymentInfo function, royaltyRegistry.getRoyaltyLookupAddress section.""
    },
    {
      ""Issue"": ""Lack of check for zero basis points in royalty splits."",
      ""Severity"": ""Low"",
      ""Description"": ""The code does not explicitly check if any of the `splitPerRecipientInBasisPoints` values are zero. While a zero value itself isn't inherently an issue, it could indicate a configuration error or an attempt to bypass royalty payments. A check, or a more descriptive comment, might be helpful to ensure the intended behavior is clear."",
      ""Impact"": ""Potential for unintended behavior or misconfiguration of royalty splits. Does not pose a security risk, but rather a business logic one."",
      ""Location"": ""_getCreatorPaymentInfo function; assignment of `splitPerRecipientInBasisPoints` from IGetRoyalties and IGetFees interfaces""
    },
    {
      ""Issue"": ""Lack of Explicit Zero Address Checks for Contract Addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""While most code paths handle the case where royalty recipients or the contract owner is the zero address, an explicit check at the beginning of the `_getCreatorPaymentInfo` function for `nftContract == address(0)` could prevent unexpected behavior if a zero address is somehow passed as the NFT contract address."",
      ""Impact"": ""Unpredictable behavior if the NFT contract address is zero."",
      ""Location"": ""NFTMarketCreators.sol:_getCreatorPaymentInfo function, at the beginning.""
    },
    {
      ""Issue"": ""Gas limit considerations for external calls."",
      ""Severity"": ""Informational"",
      ""Description"": ""The code uses a hardcoded `READ_ONLY_GAS_LIMIT` for external calls to royalty/fee interfaces. While this helps prevent excessive gas consumption and potential reverts, it might be insufficient for complex implementations of those interfaces. This could lead to legitimate royalty/fee calculations failing due to out-of-gas errors."",
      ""Impact"": ""Potential for legitimate royalty/fee calculations to fail, especially if the external interfaces perform complex logic. Might need dynamic gas limits or configuration options."",
      ""Location"": ""_getCreatorPaymentInfo function; all external calls to royalty/fee interfaces""
    },
    {
      ""Issue"": ""Seller as Recipient Handling"",
      ""Severity"": ""Informational"",
      ""Description"": ""The function prioritizes returning early if the seller is identified as a recipient. While this may be intentional, it could potentially bypass other valid recipients in a scenario where the seller is also a designated recipient but other recipients should also receive payments."",
      ""Impact"": ""Possible unintended consequences if multiple royalty recipients exist and the seller is one of them. Only the seller as recipient will be returned."",
      ""Location"": ""NFTMarketCreators.sol:_getCreatorPaymentInfo function, the return statements within IRoyaltyInfo and IGetRoyalties interfaces when the seller is a recipient.""
    }
  ],
  ""IssueNumber"": 32,
  ""OutputList"": 18
}",187.97507405281067,2775.0,23.0,"### **[H-02] Creators can steal sale revenue from owners' sales**

**Report Description**:  
The issue highlights that creators can manipulate royalty information using the Royalty Registry just before a sale is completed. This allows them to redirect royalty payments to themselves, effectively stealing revenue from the rightful owners. The vulnerability arises because the Royalty Registry can be updated dynamically, and the contract does not enforce checks or delays to prevent such manipulation.

**Match in Response List**:  
**No match found**. The response list does not address the specific issue of creators manipulating the Royalty Registry to redirect royalty payments.

**Validation**:  
**Incorrect**. The response list does not cover this issue, which is a significant security concern. The lack of a match indicates a gap in the response list's coverage of potential vulnerabilities related to dynamic royalty updates and manipulation.

---

### **[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array**

**Report Description**:  
The `_getCreatorPaymentInfo()` function uses `try` and `catch` statements to handle bad API endpoints. However, if a revert occurs within the `try` block (e.g., due to an unbounded `_recipients` array), the function does not properly handle the revert, leading to NFTs being locked in the contract. This could result in a denial of service (DoS) or loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Unbounded loop vulnerability in IGetRoyalties and IGetFees interface checks""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of unbounded loops and potential DoS due to large arrays, which aligns with the issue. However, it does not explicitly address the specific problem of reverts within `try` blocks not being properly handled, which is a critical aspect of the reported issue.

---

### **[M-15] Royalties can be distributed unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns**

**Report Description**:  
The issue arises because the contract assumes that `getRoyalties()` returns values in terms of basis points (BPS). If an NFT contract implements `getRoyalties()` with a different precision (e.g., 1e6 instead of 1e4), the royalty distribution will be distorted. This could lead to unfair or incorrect royalty payments.

**Match in Response List**:  
Matches with the issue titled **""Lack of upper bound check on recipientBasisPoints in IGetRoyalties and IGetFees calls""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the risk of incorrect royalty calculations due to unchecked basis points. However, it does not address the specific issue of non-standard precision in `getRoyalties()` returns, which is a key aspect of the reported vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-07] `_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array**  
- **[M-15] Royalties can be distributed unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns**

**Missed Issues from Issue Report**:  
- **[H-02] Creators can steal sale revenue from owners' sales**

---

### **Conclusion**  
The response list partially addresses some of the issues but misses critical vulnerabilities, particularly the manipulation of royalty information by creators. This indicates a need for more comprehensive coverage of potential risks in the contract's royalty handling mechanisms.","```
None.
```",0.0
NFTMarketOffer.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
/// @param currentOfferAmount The current highest offer available for this NFT.
error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);
/// @param expiry The time at which the offer had expired.
error NFTMarketOffer_Offer_Expired(uint256 expiry);
/// @param currentOfferFrom The address of the collector which has made the current highest offer.
error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);
/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.
error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();

/**
 * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.
 * @notice Funds are escrowed in the FETH ERC-20 token contract.
 */
abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  /// @notice Stores offer details for a specific NFT.
  struct Offer {
    // Slot 1: When increasing an offer, only this slot is updated.
    /// @notice The expiration timestamp of when this offer expires.
    uint32 expiration;
    /// @notice The amount, in wei, of the highest offer.
    uint96 amount;
    // 128 bits are available in slot 1

    // Slot 2: When the buyer changes, both slots need updating
    /// @notice The address of the collector who made this offer.
    address buyer;
  }

  /// @notice Stores the highest offer for each NFT.
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  /**
   * @notice Emitted when an offer is accepted,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The accepted total offer amount is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer which was accepted.
   * @param seller The address of the seller which accepted the offer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an offer is canceled by a Foundation admin.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reason The reason for the cancellation (a required field).
   */
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  /**
   * @notice Emitted when an offer is invalidated due to other market activity.
   * When this occurs, the collector which made the offer has their FETH balance unlocked
   * and the funds are available to place other offers or to be withdrawn.
   * @dev This occurs when the offer is no longer eligible to be accepted,
   * e.g. when a bid is placed in an auction for this NFT.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  /**
   * @notice Emitted when an offer is made.
   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds
   * remain available until the `expiration` date.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer to buy this NFT.
   * @param amount The amount, in wei, of the offer.
   * @param expiration The expiration timestamp for the offer.
   */
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  /**
   * @notice Accept the highest offer for an NFT.
   * @dev The offer must not be expired and the NFT owned + approved by the seller or
   * available in the market contract's escrow.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param offerFrom The address of the collector that you wish to sell to.
   * If the current highest offer is not from this user, the transaction will revert.
   * This could happen if a last minute offer was made by another collector,
   * and would require the seller to try accepting again.
   * @param minAmount The minimum value of the highest offer for it to be accepted.
   * If the value is less than this amount, the transaction will revert.
   * This could happen if the original offer expires and is replaced with a smaller offer.
   */
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    // Validate offer expiry and amount
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    // Validate the buyer
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  /**
   * @notice Allows Foundation to cancel offers.
   * This will unlock the funds in the FETH ERC-20 contract for the highest offer
   * and prevent the offer from being accepted.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.
   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    // The array length cannot overflow 256 bits
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          // Unlock from escrow and emit an event only if the offer is still active
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        // Else continue on so the rest of the batch transaction can process successfully
      }
    }
  }

  /**
   * @notice Make an offer for any NFT which is valid for 24-25 hours.
   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.
   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.
   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param amount The amount to offer for this NFT.
   * @return expiration The timestamp for when this offer will expire.
   * This is provided as a return value in case another contract would like to leverage this information,
   * user's should refer to the expiration in the `OfferMade` event log.
   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.
   */
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    // If there is a buy price set at this price or lower, accept that instead.
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      // This is a new offer for the NFT (no other offer found or the previous offer expired)

      // Lock the offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      // A previous offer exists and has not expired

      if (amount < _getMinIncrement(offer.amount)) {
        // A non-trivial increase in price is required to avoid sniping
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw
      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    // Record offer details
    offer.buyer = msg.sender;
    // The FETH contract guarantees that the expiration fits into 32 bits.
    offer.expiration = uint32(expiration);
    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  /**
   * @notice Accept the highest offer for an NFT from the `msg.sender` account.
   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.
   * @dev The caller must validate the expiry and amount before calling this helper.
   * This may invalidate other market tools, such as clearing the buy price if set.
   */
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    // Remove offer
    delete nftContractToIdToOffer[nftContract][tokenId];
    // Withdraw ETH from the buyer's account in the FETH token contract.
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    // Transfer the NFT to the buyer.
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks
    {
      // NFT was in the seller's wallet so the transfer is complete.
    } catch {
      // If the transfer fails then attempt to transfer from escrow instead.
      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.
   */
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer if it's from the same user that purchased the NFT
   * using a different market tool such as accepting the buy price.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      // The highest offer is from the same user that purchased the NFT using a different market tool.
      _invalidateOffer(nftContract, tokenId);
    }
    // For other users, the offer remains valid for consideration by the new owner.
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  /**
   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.
   */
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      // An offer was found and it has not already expired
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      // Remove offer
      delete nftContractToIdToOffer[nftContract][tokenId];
      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  /**
   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.
   * @dev Offers for this NFT which are less than this value will revert.
   * Once the previous offer has expired smaller offers can be made.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return minimum The minimum amount that must be offered for this NFT.
   */
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    // Absolute min is anything > 0
    return 1;
  }

  /**
   * @notice Returns details about the current highest offer for an NFT.
   * @dev Default values are returned if there is no offer or the offer has expired.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return buyer The address of the buyer that made the current highest offer.
   * Returns `address(0)` if there is no offer or the most recent offer has expired.
   * @return expiration The timestamp that the current highest offer expires.
   * Returns `0` if there is no offer or the most recent offer has expired.
   * @return amount The amount being offered for this NFT.
   * Returns `0` if there is no offer or the most recent offer has expired.
   */
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      // Offer not found or has expired
      return (address(0), 0, 0);
    }

    // An offer was found and it has not yet expired.
    return (offer.buyer, offer.expiration, offer.amount);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",4149,404,"[H-03] An offer made after auction end can be stolen by an auction winner

Submitted by hyh, also found by leastwood, shenwilly, and WatchPug
An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as _transferFromEscrow being called by _acceptOffer will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.
This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.

[M-13] Escrowed NFT can be stolen by anyone if no active buyPrice or auction exists for it

function makeOffer() 
If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via makeOffer, acceptOffer combination.
I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.
This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of setBuyPrice or createReserveAuction, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();

error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);

error NFTMarketOffer_Offer_Expired(uint256 expiry);

error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);

error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();


abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  
  struct Offer {
    
    
    uint32 expiration;
    
    uint96 amount;
    

    
    
    address buyer;
  }

  
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        
      }
    }
  }

  
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      

      
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      

      if (amount < _getMinIncrement(offer.amount)) {
        
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      
      
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    
    offer.buyer = msg.sender;
    
    offer.expiration = uint32(expiration);
    
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    
    delete nftContractToIdToOffer[nftContract][tokenId];
    
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) 
    {
      
    } catch {
      
      
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      
      _invalidateOffer(nftContract, tokenId);
    }
    
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      
      delete nftContractToIdToOffer[nftContract][tokenId];
      
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    
    return 1;
  }

  
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      
      return (address(0), 0, 0);
    }

    
    return (offer.buyer, offer.expiration, offer.amount);
  }

  
  uint256[1000] private __gap;
}",1815,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities: Reentrancy"",
      ""Tasks"": [
        ""Verify the effectiveness of `nonReentrant` modifier on `acceptOffer` and `adminCancelOffers`. Analyze potential reentrancy scenarios, especially concerning the interaction with the `feth` contract and ERC721 `transferFrom` or the fallback `_transferFromEscrow`."",
        ""Examine potential reentrancy issues within the inherited functions from `FoundationTreasuryNode`, `NFTMarketCore`, and `NFTMarketFees` that are called within the `nonReentrant` protected functions. If any of those functions call external contracts, analyze them for potential reentrancy vectors.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities: Fund Management and feth Interactions"",
      ""Tasks"": [
        ""Thoroughly audit the interactions with the `feth` contract. Verify that the correct amounts are locked, unlocked, changed, and withdrawn under all circumstances, including offer acceptance, cancellation by admin, offer invalidation, and potential failures during NFT transfer."",
        ""Specifically analyze the `feth.marketWithdrawLocked` call in `_acceptOffer`. If the subsequent NFT transfer fails (both `transferFrom` and `_transferFromEscrow`), is there a mechanism to return the funds to the buyer? Implement a mitigation strategy if funds are not returned on failure."",
        ""Investigate the potential for manipulation or vulnerabilities in the `feth` contract itself, as this contract is a critical dependency for fund management. This is outside the scope of *this* contract directly, but any assumptions made about `feth` must be validated."",
        ""Analyze potential denial-of-service (DoS) scenarios if the `feth` contract becomes unavailable or reverts unexpectedly. Ensure appropriate error handling and recovery mechanisms are in place.""
      ]
    },
    {
      ""Area"": ""Access Control: Admin Cancellation"",
      ""Tasks"": [
        ""Verify the proper functioning of the `onlyFoundationAdmin` modifier in the `adminCancelOffers` function. Ensure that only authorized addresses can cancel offers."",
        ""Assess the potential impact of canceling a large number of offers via `adminCancelOffers` on gas costs and block limits. Implement pagination or batching mechanisms if necessary to prevent DoS attacks."",
        ""Examine the consequences of an admin mistakenly canceling offers. Implement safeguards such as multi-signature authorization or delay periods for admin actions."",
        ""Ensure that the `reason` parameter in `adminCancelOffers` is properly handled and cannot be abused to inject malicious code or bypass access controls.""
      ]
    },
    {
      ""Area"": ""Logic Errors: Offer Management"",
      ""Tasks"": [
        ""Carefully review the logic in `makeOffer` to ensure that the correct expiration time is calculated and stored, especially when making a new offer versus increasing an existing offer. Verify that the amount and buyer are updated correctly."",
        ""Analyze the minimum increment check in `makeOffer`. Confirm that the `_getMinIncrement` function returns the expected value and that the check prevents front-running or other undesirable behavior."",
        ""Investigate the conditions under which `_cancelBuyersOffer` is called and verify that it functions as intended. Ensure that the function is only triggered when the buyer initiates a cancellation or when certain other conditions are met."",
        ""Review the expiration check logic in `acceptOffer`, `adminCancelOffers`, `getOffer`, and other functions that depend on offer expiration. Ensure that the comparisons with `block.timestamp` are accurate and prevent unexpected behavior."",
        ""Analyze the potential for race conditions when multiple users are trying to make or accept offers on the same NFT simultaneously.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review the storage usage of the `Offer` struct. Consider using smaller data types where appropriate to reduce gas costs (e.g., using `uint32` for expiration if it is sufficient)."",
        ""Optimize the loops in `adminCancelOffers` to reduce gas consumption. Consider using more efficient data structures or algorithms if possible."",
        ""Analyze the gas costs of the `_acceptOffer` function, particularly the NFT transfer and fee distribution logic. Identify potential areas for optimization, such as reducing the number of external calls."",
        ""Minimize unnecessary memory allocations and data copies to reduce gas costs.""
      ]
    },
    {
      ""Area"": ""Data Type Considerations"",
      ""Tasks"": [
        ""Assess the limitations of using `uint32` for `expiration` and `uint96` for `amount`. Ensure that these data types are sufficient to represent the expected time ranges and offer amounts. If necessary, increase the data type sizes."",
        ""Verify that the conversions between `uint256` and `uint32`/`uint96` in `makeOffer` do not lead to data loss or unexpected behavior. Implement checks to prevent overflows or underflows."",
        ""Review the use of `Offer memory offer` in several functions. If the offer data is not modified, consider using `Offer storage offer` to save gas by avoiding copying the entire struct to memory.""
      ]
    },
    {
      ""Area"": ""NFT Transfer Handling"",
      ""Tasks"": [
        ""Analyze the `try/catch` block around `IERC721(nftContract).transferFrom` in `_acceptOffer`. Ensure that the fallback mechanism (`_transferFromEscrow`) is correctly implemented and handles all potential failure scenarios."",
        ""Verify that the `_transferFromEscrow` function correctly transfers ownership of the NFT and updates any relevant state variables."",
        ""Investigate potential issues with different ERC721 implementations and ensure that the contract is compatible with a wide range of NFT standards."",
        ""Consider the case where the NFT contract has a transfer hook that reverts the transfer. Ensure that this scenario is handled gracefully and does not lead to loss of funds or other unexpected behavior.""
      ]
    },
    {
      ""Area"": ""Inherited Functions and External Dependencies"",
      ""Tasks"": [
        ""Thoroughly review the implementation of the inherited abstract functions, including `_getMinIncrement`, `_distributeFunds`, `_autoAcceptBuyPrice`, `_isInActiveAuction`, and `_transferFromEscrow`. Ensure that these functions are correctly implemented and integrated with the `NFTMarketOffer` contract."",
        ""Analyze the external dependencies on the `FoundationTreasuryNode`, `NFTMarketCore`, and `NFTMarketFees` contracts. Verify that these contracts are secure and function as expected."",
        ""Examine the potential for vulnerabilities in the external contracts and libraries that are used by the inherited functions. This is, strictly speaking, outside the scope of *this* contract, but is important for defense-in-depth. For example, are the imported OpenZeppelin contracts the latest version with all relevant security patches?""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `NFTMarketOffer` manages the creation, acceptance, and cancellation of offers for NFTs within a larger marketplace system. It integrates with core market logic, fee distribution, treasury management, and fund locking mechanisms (`feth`). It utilizes OpenZeppelin Upgradeable contracts for upgradeability and security (ReentrancyGuard). The contract handles offer state, fund interactions via `feth`, NFT transfers, and administrative controls. Custom errors are used for reverting transactions."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketOffer"",
    ""Purpose"": ""To manage the off-chain offer system for NFTs, allowing users to make binding offers by locking funds, which sellers can then accept."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""FoundationTreasuryNode"",
        ""NFTMarketCore"",
        ""ReentrancyGuardUpgradeable"",
        ""NFTMarketFees""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"",
        ""./FoundationTreasuryNode.sol"",
        ""./NFTMarketCore.sol"",
        ""./NFTMarketFees.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""nftContractToIdToOffer"",
        ""Type"": ""mapping(address => mapping(uint256 => Offer))"",
        ""Purpose"": ""Stores the current active offer for each specific NFT (identified by contract address and token ID). Contains expiration, amount, and buyer address.""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000]"",
        ""Purpose"": ""Reserved storage space for ensuring storage layout compatibility in upgradeable contracts.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""Offer (struct)"",
        ""Visibility"": ""struct (internal)"",
        ""Purpose"": ""Defines the structure for storing offer details."",
        ""Parameters"": [""expiration (uint32)"", ""amount (uint96)"", ""buyer (address)""],
        ""Returns"": []
      },
      {
        ""Name"": ""acceptOffer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the NFT owner (msg.sender) to accept an existing, valid offer."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)"", ""offerFrom (address)"", ""minAmount (uint256)""],
        ""Returns"": [],
        ""Modifiers"": [""nonReentrant""]
      },
      {
        ""Name"": ""adminCancelOffers"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a foundation admin to cancel multiple active offers, providing a reason and unlocking buyer funds."",
        ""Parameters"": [""nftContracts (address[])"", ""tokenIds (uint256[])"", ""reason (string)""],
        ""Returns"": [],
        ""Modifiers"": [""onlyFoundationAdmin"", ""nonReentrant""]
      },
      {
        ""Name"": ""makeOffer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to make a new offer or increase an existing one, locking funds via `feth`. Checks against auctions and minimum increments."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)"", ""amount (uint256)""],
        ""Returns"": [""expiration (uint256)""],
        ""Modifiers"": [""payable""]
      },
      {
        ""Name"": ""_acceptOffer"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic for handling offer acceptance: deletes offer, withdraws locked funds, distributes funds, transfers NFT."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""_afterAuctionStarted"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Hook called after an auction starts; invalidates any existing offer on the NFT."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)""],
        ""Returns"": [],
        ""Modifiers"": [""virtual"", ""override""]
      },
      {
        ""Name"": ""_transferFromEscrow"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Hook called during NFT transfer from escrow; invalidates offer if the recipient is the current offer buyer. Also acts as a fallback for NFT transfer in `_acceptOffer`."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)"", ""buyer (address)"", ""seller (address)""],
        ""Returns"": [],
        ""Modifiers"": [""virtual"", ""override""]
      },
      {
        ""Name"": ""_autoAcceptOffer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Hook to automatically accept an existing offer if it meets certain criteria (e.g., matches a buy-now price)."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)"", ""minAmount (uint256)""],
        ""Returns"": [""bool (true if accepted)""],
        ""Modifiers"": [""override""]
      },
      {
        ""Name"": ""_cancelBuyersOffer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Hook to invalidate an offer if the offer maker (msg.sender) triggers a cancellation condition."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)""],
        ""Returns"": [],
        ""Modifiers"": [""override""]
      },
      {
        ""Name"": ""_invalidateOffer"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic to cancel an active offer, delete it, unlock funds, and emit an event."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""getMinOfferAmount"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the minimum amount required for the next offer on a specific NFT."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)""],
        ""Returns"": [""minimum (uint256)""],
        ""Modifiers"": [""view""]
      },
      {
        ""Name"": ""getOffer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Retrieves the details of the current active offer for an NFT."",
        ""Parameters"": [""nftContract (address)"", ""tokenId (uint256)""],
        ""Returns"": [""buyer (address)"", ""expiration (uint256)"", ""amount (uint256)""],
        ""Modifiers"": [""view""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Calls to `feth` contract/library for fund locking/unlocking (`marketLockupFor`, `marketChangeLockup`, `marketWithdrawLocked`, `marketUnlockFor`)."",
    ""Calls to `IERC721(nftContract).transferFrom` to transfer the NFT upon offer acceptance."",
    ""Calls functions inherited from parent contracts (e.g., `_distributeFunds`, `_getMinIncrement`, `_autoAcceptBuyPrice`, `_isInActiveAuction`, `_afterAuctionStarted`, `_transferFromEscrow`, `onlyFoundationAdmin`)."",
    ""Emits events (`OfferAccepted`, `OfferCanceledByAdmin`, `OfferInvalidated`, `OfferMade`).""
  ],
  ""SpecialMechanisms"": [
    ""**Upgradeable Contract:** Uses OpenZeppelin Upgradeable library (`@openzeppelin/contracts-upgradeable`) and `__gap` for storage layout."",
    ""**Reentrancy Guard:** Employs `ReentrancyGuardUpgradeable` and the `nonReentrant` modifier to prevent reentrancy attacks on key state-changing functions."",
    ""**External Fund Locking:** Relies on an external component (`feth`) to manage the locking and releasing of funds associated with offers, separating concerns."",
    ""**Custom Errors:** Uses Solidity custom errors (e.g., `NFTMarketOffer_Offer_Expired`) for efficient error handling."",
    ""**Hook-Based Architecture:** Uses `internal override` functions (`_afterAuctionStarted`, `_transferFromEscrow`, `_autoAcceptOffer`, `_cancelBuyersOffer`) to allow interaction and state synchronization with parent/core contracts."",
    ""**Abstract Contract:** Defines an interface and partial implementation, relying on inheriting contracts to provide full functionality (e.g., for fee calculation, auction status checks)."",
    ""**NFT Transfer Fallback:** Includes a `try/catch` block around `IERC721.transferFrom` in `_acceptOffer`, attempting a fallback mechanism (`_transferFromEscrow`) if the direct transfer fails.""
  ],
  ""Questions"": [
    ""What is the precise interface and behavior of the `feth` component? How are funds secured and managed?"",
    ""What is the exact implementation logic of the inherited abstract functions like `_getMinIncrement`, `_distributeFunds`, `_autoAcceptBuyPrice`, `_isInActiveAuction`, and `_transferFromEscrow`?"",
    ""What are the specific conditions under which `_cancelBuyersOffer` is intended to be called?"",
    ""In `_acceptOffer`, funds (`feth.marketWithdrawLocked`) are withdrawn *before* the NFT transfer is attempted. If the transfer fails (both direct and via `_transferFromEscrow`), are the funds returned to the buyer? The current logic doesn't show an explicit return path in this failure case."",
    ""What is the rationale for using `uint32` for expiration and `uint96` for amount? Are the potential limitations on time duration and value acceptable?"",
    ""In `adminCancelOffers`, is there a risk of hitting block gas limits if the input arrays (`nftContracts`, `tokenIds`) are very large, potentially preventing cancellation of large batches?"",
    ""Is the default minimum offer amount of 1 (wei) in `getMinOfferAmount` appropriate or should it be configurable or based on a system parameter?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy vulnerability in `_acceptOffer` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_acceptOffer` function transfers the NFT using `IERC721(nftContract).transferFrom` or `_transferFromEscrow` before distributing funds or updating state. A malicious contract could re-enter `_acceptOffer` via a callback during the transfer, potentially draining funds, manipulating state, or causing incorrect fee calculations. While `nonReentrant` modifier is used in `acceptOffer` and `adminCancelOffers`, it doesn't cover the internal `_acceptOffer` function."",
      ""Impact"": ""Potential for theft of funds or NFTs, contract manipulation, denial of service."",
      ""Location"": ""NFTMarketOffer.sol:_acceptOffer""
    },
    {
      ""Issue"": ""Incorrect Usage of `msg.sender` in `_acceptOffer`"",
      ""Severity"": ""High"",
      ""Description"": ""In the `_acceptOffer` function, `msg.sender` is assumed to be the seller. However, the `acceptOffer` function allows any external caller to trigger the offer acceptance, as long as the `offerFrom` parameter matches the offer's buyer. Therefore, `msg.sender` can be an arbitrary address, leading to incorrect fee distribution and potential fund losses for the seller."",
      ""Impact"": ""Incorrect fee distribution, potential fund losses for the seller, and possible exploitation of the fee mechanism by malicious actors."",
      ""Location"": ""NFTMarketOffer.sol:_acceptOffer and NFTMarketOffer.sol:acceptOffer""
    },
    {
      ""Issue"": ""Potential Denial of Service (DoS) in `adminCancelOffers` due to unbounded loop"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `adminCancelOffers` function iterates through `nftContracts` and `tokenIds` arrays. If these arrays are very large, the execution of this function could exceed the block gas limit, causing the transaction to revert. This would prevent the admin from canceling offers, effectively leading to a denial of service."",
      ""Impact"": ""Administrators may be unable to cancel offers, leading to stale offers being present on the platform. Can halt market's offer management functionality."",
      ""Location"": ""NFTMarketOffer.sol:adminCancelOffers""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculation in `_distributeFunds`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_distributeFunds` function performs calculations to determine fees. If the inputs to these calculations are sufficiently large, an integer overflow or underflow could occur, leading to incorrect fee distribution and potential loss of funds for the foundation, creator, or owner."",
      ""Impact"": ""Incorrect fee distribution, potentially leading to loss of funds for the foundation, creator, or owner."",
      ""Location"": ""NFTMarketOffer.sol:_acceptOffer -> _distributeFunds and NFTMarketFees.sol (where _distributeFunds is defined)""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `acceptOffer` and `makeOffer`"",
      ""Severity"": ""Medium"",
      ""Description"": ""A malicious actor could observe pending `acceptOffer` or `makeOffer` transactions and front-run them, manipulating the state or bypassing intended mechanisms. This includes starting an auction, outbidding an offer, or preventing the auto-accept mechanism from working as expected. The `minAmount` check in `acceptOffer` is helpful, but can still be front-run. The time between checking offer validity and calling FETH may be sufficient for a better offer."",
      ""Impact"": ""The intended buyer might not be able to acquire the NFT at the agreed-upon price, bypassing auto-accept, unfair competition, or the transaction could fail, resulting in gas loss."",
      ""Location"": ""NFTMarketOffer.sol:acceptOffer, NFTMarketOffer.sol:makeOffer""
    },
    {
      ""Issue"": ""Potential Precision Loss when casting to `uint32` and `uint96`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `makeOffer` function casts the `expiration` and `amount` variables to `uint32` and `uint96` respectively. If `expiration` is greater than the maximum value of `uint32`, or `amount` is greater than the maximum value of `uint96`, a truncation will occur leading to incorrect values being stored. This can invalidate offers, or cause an attacker to make an offer for far less than intended."",
      ""Impact"": ""Incorrect storage of offer details, potentially leading to loss of funds, invalid offers, or unexpected behavior."",
      ""Location"": ""NFTMarketOffer.sol:makeOffer""
    },
    {
      ""Issue"": ""Potential loss of funds when transferFrom fails in `_acceptOffer` and `_transferFromEscrow` is used"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `_acceptOffer`, if `IERC721(nftContract).transferFrom` fails, `_transferFromEscrow` is called as a fallback. However, it is not guaranteed that `_transferFromEscrow` will always succeed. A poorly implemented or malicious `_transferFromEscrow` could lead to the NFT not being transferred to the buyer, but the funds have already been withdrawn from the buyer, effectively resulting in loss of funds for the buyer."",
      ""Impact"": ""Potential loss of funds for the buyer if NFT transfer fails."",
      ""Location"": ""NFTMarketOffer.sol:_acceptOffer""
    },
    {
      ""Issue"": ""Unprotected marketWithdrawLocked call in `adminCancelOffers`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `adminCancelOffers` function, the code calls `feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount)` if the offer hasn\'t expired. If anyone can call `marketUnlockFor`, the `adminCancelOffers` can be used to steal funds from the offer maker."",
      ""Impact"": ""Potential theft of funds locked in offers."",
      ""Location"": ""NFTMarketOffer.sol:adminCancelOffers""
    },
    {
      ""Issue"": ""Lack of Access Control on `_transferFromEscrow` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_transferFromEscrow` function is declared `internal virtual override`, which means it can be accessed by derived contracts, potentially bypassing checks. The code invalidates the offer if the buyer matches. This could lead to a denial-of-service attack if combined with another vulnerability."",
      ""Impact"": ""Circumventing offer acceptance process, bypassing fee mechanisms, potential unauthorized NFT transfers, and denial-of-service possibilities."",
      ""Location"": ""NFTMarketOffer.sol:_transferFromEscrow""
    },
    {
      ""Issue"": ""Race condition in `_autoAcceptOffer` can lead to inconsistent state"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_autoAcceptOffer` function checks if `offer.expiration < block.timestamp || offer.amount < minAmount`. If this condition is met, it returns `false`. However, between the check and the call to `_acceptOffer`, the `offer.amount` or `offer.expiration` might change, causing the offer to be accepted under potentially different conditions than intended. Offers are evaluated against stale values in `_autoAcceptOffer`."",
      ""Impact"": ""Offers can be accepted under unintended conditions if other transactions concurrently modify offer details."",
      ""Location"": ""_autoAcceptOffer function.""
    },
    {
      ""Issue"": ""Missing Input Validation for nftContracts and tokenIds arrays in `adminCancelOffers`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `adminCancelOffers` function takes two arrays, `nftContracts` and `tokenIds`, as input. There is no check to ensure that these arrays have the same length. If the lengths are different, the loop might access out-of-bounds elements, leading to unpredictable behavior."",
      ""Impact"": ""Unpredictable behavior, potential out-of-bounds access, incorrect offer cancellation."",
      ""Location"": ""NFTMarketOffer.sol:adminCancelOffers""
    },
    {
      ""Issue"": ""Unnecessary storage read in `adminCancelOffers`"",
      ""Severity"": ""Low"",
      ""Description"": ""Inside the `adminCancelOffers` function, the contract reads the offer into memory using `Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];`. However, it only uses a subset of the fields. Furthermore the variables are used *after* deletion, from memory."",
      ""Impact"": ""Slightly increased gas cost due to unnecessary storage read."",
      ""Location"": ""NFTMarketOffer.sol:adminCancelOffers""
    },
        {
      ""Issue"": ""Potential Integer Overflow in `uint32(expiration)` Assignment in `makeOffer`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `makeOffer` function assigns the return value of `feth.marketLockupFor` (which could potentially be a `uint256`) to a `uint32` variable `offer.expiration`. If the returned value exceeds the maximum value for `uint32`, an integer overflow will occur, leading to unexpected behavior related to offer expiration."",
      ""Impact"": ""Offers expiring prematurely or lasting longer than intended, leading to potential disputes and unintended consequences."",
      ""Location"": ""NFTMarketOffer.sol:makeOffer""
    },
    {
      ""Issue"": ""Inconsistent offer invalidation logic."",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `offer.expiration >= block.timestamp` in some places and `offer.expiration < block.timestamp` in other places to check offer validity. This inconsistency could lead to unexpected behavior."",
      ""Impact"": ""Unexpected behavior related to offer validity."",
      ""Location"": ""NFTMarketOffer.sol: multiple locations""
    },
    {
      ""Issue"": ""Potential for griefing in `adminCancelOffers` by providing incorrect tokenIds/nftContracts"",
      ""Severity"": ""Low"",
      ""Description"": ""An attacker may attempt to call `adminCancelOffers` with arbitrary NFT contract and token ID combinations, causing unnecessary gas consumption."",
      ""Impact"": ""Unnecessary gas usage"",
      ""Location"": ""adminCancelOffers function""
    },
    {
          ""Issue"": ""Missing check if amount is zero in `makeOffer` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `makeOffer` function does not check if the amount being offered is zero. Locking zero funds might lead to unexpected behaviors in the `feth` contract or in the state of this contract."",
      ""Impact"": ""Unexpected behaviors in the `feth` contract and in the state of this contract."",
      ""Location"": ""NFTMarketOffer.sol:makeOffer""
    },
        {
      ""Issue"": ""Missing zero-address check for NFT contract in `makeOffer`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `makeOffer` function doesn't check if `nftContract` is a zero address."",
      ""Impact"": ""Accidental or malicious burning of funds or NFTs."",
      ""Location"": ""makeOffer function, at the beginning.""
    },
        {
      ""Issue"": ""Unclear error handling in `_acceptOffer` after `transferFrom` or `_transferFromEscrow`"",
      ""Severity"": ""Low"",
      ""Description"": ""In `_acceptOffer`, the contract attempts to transfer the NFT, and if that fails, attempts to use `_transferFromEscrow`. If `_transferFromEscrow` also fails, there is no error handling."",
      ""Impact"": ""Transaction revert with unclear error message, possibly resulting in funds being locked and negative user experience."",
      ""Location"": ""_acceptOffer function""
    },
    {
      ""Issue"": ""Unchecked Arithmetic in `adminCancelOffers`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `adminCancelOffers` function uses an `unchecked` block for the loop iterating through `nftContracts` and `tokenIds`. While this can save gas, it also means that any integer overflows in the loop counter `i` will not be caught, potentially leading to unexpected behavior if `nftContracts.length` is very large."",
      ""Impact"": ""Potential for unexpected behavior if the loop counter overflows, although unlikely."",
      ""Location"": ""NFTMarketOffer.sol:adminCancelOffers""
    },
       {
      ""Issue"": ""Inconsistent usage of msg.sender in `_acceptOffer` and related functions"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_acceptOffer` function, `msg.sender` is assumed to be the seller. However, the `acceptOffer` function requires the `offerFrom` parameter to match the offer\'s buyer. This could lead to confusion and unexpected behavior."",
      ""Impact"": ""Confusion about the role of `msg.sender` when accepting an offer."",
      ""Location"": ""_acceptOffer and acceptOffer functions.""
    },
    {
      ""Issue"": ""Lack of checks on `msg.value` in `makeOffer`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `makeOffer` function allows users to send `msg.value` along with the offer. However, there are no checks to ensure `msg.value` equals `amount` in the case of `marketLockupFor`, and no check at all that `msg.value` is sufficient. If a user sends a `msg.value` that doesn't meet the `FETH` requirement this could break the transaction."",
      ""Impact"": ""Unexpected behavior if `msg.value` is not handled correctly by the `FETH` contract."",
      ""Location"": ""makeOffer function""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `Offer` struct fields"",
      ""Severity"": ""Low"",
      ""Description"": ""The `Offer` struct defines `expiration` as `uint32` and `amount` as `uint96`. While the probability is low, there\'s a risk of overflow if these values become excessively large."",
      ""Impact"": ""Unintended offer invalidation or incorrect offer amount storage, potentially leading to financial loss or unexpected contract behavior."",
      ""Location"": ""Offer struct definition""
    }
  ],
  ""IssueNumber"": 52,
  ""OutputList"": 22
}",226.46330785751343,11852.0,32.0,"### **[H-03] An offer made after auction end can be stolen by an auction winner**

**Report Description**:  
An offer made for an NFT after the auction has ended, but before the winner has received the NFT, can be stolen by the auction winner. The `_transferFromEscrow` function, called by `_acceptOffer`, transfers the NFT to the winner, finalizing the auction. However, no transfer occurs to the user who made the offer. This allows the auction winner to obtain both the NFT and the offer amount (after fees) at no additional cost, at the expense of the user who made the offer.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The described vulnerability involves a race condition where the auction winner can exploit the timing between the auction end and the offer acceptance to steal both the NFT and the offer amount. This is a critical oversight in the contract logic, but it is not covered in the response list.

---

### **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

**Report Description**:  
If an NFT is in escrow without an active `buyPrice` or auction, any user can steal it via the `makeOffer` and `acceptOffer` functions. This occurs because the NFT is only guarded by `buyPrice` and `auction` structures. If neither is initialized (e.g., if the NFT is mistakenly sent to the contract), a malicious user can exploit this to obtain the NFT for free. The severity is medium because normal usage implies that either `buyPrice` or `auction` is initialized, leaving only mistakenly sent assets exposed.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability arises from the lack of safeguards for NFTs in escrow without active `buyPrice` or `auction` structures. This oversight allows malicious users to exploit the contract to steal NFTs, but it is not mentioned in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-03] An offer made after auction end can be stolen by an auction winner**  
- **[M-13] Escrowed NFT can be stolen by anyone if no active `buyPrice` or auction exists for it**

---

### **Analysis**  
The response list does not cover the two issues from the `issue` report. Both vulnerabilities involve critical flaws in the contract logic that could lead to the theft of NFTs or funds. The response list focuses on other issues, such as reentrancy, incorrect usage of `msg.sender`, and potential integer overflows, but misses these specific race conditions and access control vulnerabilities. This indicates a significant gap in the response list's coverage of the reported issues.","```
None.
```",0.0
NFTMarketPrivateSale.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();

/**
 * @title Allows owners to offer an NFT for sale to a specific collector.
 * @notice Private sales are authorized by the seller with an EIP-712 signature.
 * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.
 */
abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  /// @dev This value was replaced with an immutable version.
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  /// @notice The domain used in EIP-712 signatures.
  /// @dev It is not a constant so that the chainId can be determined dynamically.
  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.
  bytes32 private immutable DOMAIN_SEPARATOR;

  /// @notice The hash of the private sale method signature used for EIP-712 signatures.
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  /// @notice The name used in the EIP-712 domain.
  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.
  string private constant NAME = ""FNDNFTMarket"";

  /**
   * @notice Emitted when an NFT is sold in a private sale.
   * @dev The total amount of this sale is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param seller The address of the seller.
   * @param buyer The address of the buyer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  /**
   * @notice Configures the contract to accept EIP-712 signatures.
   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.
   */
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        // Incrementing the version can be used to invalidate previously signed messages.
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `msg.value` equal to the agreed upon price.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `amount` equal to the agreed upon price.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param amount The amount to buy for, if this is more than `msg.value` funds will be
   * withdrawn from your FETH balance.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      // The signed message from the seller has expired.
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure
      // that transactions do not fail due to a minor timezone error or similar during signing.

      // This prevents malicious actors from requesting signatures that never expire.
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    // The seller must have the NFT in their wallet when this function is called,
    // otherwise the signature verification below will fail.
    address payable seller = payable(nftContract.ownerOf(tokenId));

    // Scoping this block to avoid a stack too deep error
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    // This should revert if the seller has not given the market contract approval.
    nftContract.transferFrom(seller, msg.sender, tokenId);

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1896,205,"[M-01] EIP-712 signatures can be re-used in private sales

Function `buyFromPrivateSaleFor`
NFTMarketPrivateSale.sol#L123-L174
Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call #buyFromPrivateSaleFor providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.
The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.
  [M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT

Submitted by leastwood
NFTMarketPrivateSale.sol#L143-L150
The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient ETH is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.
  [M-12] Private sale spoofing
 function buyFromPrivateSaleFor()
NFTMarketPrivateSale.sol#L156
Similar to spoofing in finance, users can create private sales with correct signatures but then frontrun the buy with a transfer to a different wallet they control.
No funds are lost as the NFT <> FETH exchange is atomic but it can be bad if third parties create a naive off-chain centralized NFT market based on this signature feature. It's also frustrating for the users if they try to accept the private sale but their transaction fails.

",3,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();


abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  
  
  
  bytes32 private immutable DOMAIN_SEPARATOR;

  
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  
  
  string private constant NAME = ""FNDNFTMarket"";

  
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      
      

      
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      

      unchecked {
        
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    
    
    address payable seller = payable(nftContract.ownerOf(tokenId));

    
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    
    nftContract.transferFrom(seller, msg.sender, tokenId);

    
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  
  uint256[1000] private __gap;
}",888,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""EIP-712 Signature Verification"",
      ""Tasks"": [
        ""Verify that the `DOMAIN_SEPARATOR` is correctly calculated in the constructor, considering the contract name, version, chain ID, and verifying contract (proxy) address. Double-check the assembly code used to retrieve the chain ID."",
        ""Confirm that the `BUY_FROM_PRIVATE_SALE_TYPEHASH` is computed correctly and matches the expected structure `BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)`. Ensure that the ABI encoding in the hash matches the struct's declared parameters."",
        ""Analyze the EIP-712 signature verification logic in `buyFromPrivateSaleFor` to ensure it correctly reconstructs the message digest and uses `ecrecover` appropriately. Verify that `ecrecover` returns the expected seller address."",
        ""Investigate the potential for signature malleability attacks and confirm if the signature verification logic is resilient to such attacks. Are `r` and `s` values validated appropriately?"",
        ""Check if the contract adheres to the EIP-712 standard completely, including the use of library functions or helper contracts.""
      ]
    },
    {
      ""Area"": ""Payment Handling and Fee Distribution"",
      ""Tasks"": [
        ""Analyze the payment logic in `buyFromPrivateSaleFor` to ensure that the correct amount is being paid. Verify the conditions under which `feth.marketWithdrawFrom` is called and assess the security implications of withdrawing funds from an external system."",
        ""Thoroughly review the implementation of `feth.marketWithdrawFrom` (if available) to understand its potential impact on user funds and contract state. Determine its authorization model and potential vulnerabilities (e.g., reentrancy, denial of service)."",
        ""Examine the `_distributeFunds` function (in `NFTMarketFees`) to understand how funds are distributed between the seller, creator, and platform. Check for potential vulnerabilities in the fund distribution logic (e.g., rounding errors, integer overflows, incorrect fee calculations, reentrancy)."",
        ""Analyze how the `amount` parameter in `buyFromPrivateSaleFor` relates to the final payout to the seller, creator, and owner. Confirm the intended fee percentages and formulas are implemented correctly within `_distributeFunds`."",
        ""Check that the contract correctly handles the case where the sale fails after `feth.marketWithdrawFrom` has been called. Ensure proper refunds are issued.""
      ]
    },
    {
      ""Area"": ""Deadline and Time-Based Restrictions"",
      ""Tasks"": [
        ""Resolve the discrepancy between the error message `NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max` (suggesting a 24-hour limit) and the code `deadline > block.timestamp + 2 days`. Determine the intended maximum sale duration and correct the code or error message accordingly."",
        ""Verify that the deadline check `deadline < block.timestamp` in `buyFromPrivateSaleFor` correctly prevents sales after the deadline has passed."",
        ""Consider the potential for clock drift or manipulation and assess its impact on the deadline checks. Are there any countermeasures in place to mitigate these risks?"",
        ""Analyze the implications of using `block.timestamp` for time-sensitive logic, considering potential miner manipulation. Consider alternative time sources (if applicable).""
      ]
    },
    {
      ""Area"": ""Access Control and Reentrancy"",
      ""Tasks"": [
        ""Ensure that the `nonReentrant` modifier (inherited) is applied correctly to all functions that modify critical contract state, particularly within `buyFromPrivateSaleFor` and any functions called by it (including within `_distributeFunds`)."",
        ""Analyze the flow of control in `buyFromPrivateSaleFor` and `_distributeFunds` to identify potential reentrancy vulnerabilities, especially when interacting with external contracts (e.g., `IERC721.transferFrom`, `feth.marketWithdrawFrom`)."",
        ""If any external contract calls are made during fund distribution, implement reentrancy protection strategies (e.g., checks-effects-interactions pattern, reentrancy guards)."",
        ""Verify that only the designated buyer (identified by `msg.sender` and the signature) can execute the private sale. Confirm that the signature verification logic prevents unauthorized users from purchasing the NFT."",
        ""Assess the risks associated with the contract being abstract and requiring inheritance. Ensure proper access controls are in place in the inheriting contract to prevent unauthorized access to sensitive functions and state variables.""
      ]
    },
    {
      ""Area"": ""Upgradeability and Proxy Pattern"",
      ""Tasks"": [
        ""Identify the specific upgradeability pattern being used (UUPS or Transparent Proxy) and verify that it is implemented correctly. Analyze the proxy contract and its interaction with the implementation contract."",
        ""Confirm that the `DOMAIN_SEPARATOR` is correctly initialized in the constructor and that it uses the address of the proxy contract as the verifying contract. This is crucial for ensuring that signatures remain valid after upgrades."",
        ""Verify that the storage gaps (`__gap_was_DOMAIN_SEPARATOR` and `__gap`) are appropriately sized and positioned to prevent storage collisions during upgrades. Ensure that they are not accidentally used for other purposes."",
        ""Analyze the impact of upgrades on the contract's state and functionality. Ensure that upgrades do not introduce new vulnerabilities or break existing functionality."",
        ""If using UUPS, verify that the `onlyOwner` modifier is used appropriately on the upgrade function and that the owner is properly managed.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify any potential gas inefficiencies in the contract, such as redundant calculations, unnecessary storage writes, or inefficient data structures."",
        ""Optimize the code to reduce gas consumption without sacrificing security or functionality."",
        ""Consider using more efficient data types or algorithms where appropriate."",
        ""Evaluate the gas cost of external calls and explore ways to minimize them."",
        ""Measure the gas cost of key functions (e.g., `buyFromPrivateSaleFor`) and compare it to acceptable levels. Document any significant gas optimizations performed.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `NFTMarketPrivateSale` is an abstract contract designed to handle private NFT sales using EIP-712 signatures. It inherits fee distribution logic from `NFTMarketFees`. A seller signs an off-chain message allowing a specific buyer to purchase their NFT at a set price before a deadline. The buyer submits this signature along with payment to execute the sale on-chain. The contract handles signature verification, payment processing (including potential withdrawal from an associated contract `feth`), NFT transfer, and fee distribution. It incorporates upgradeability patterns and uses custom errors."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketPrivateSale"",
    ""Purpose"": ""To facilitate private, off-chain signed sales of specific NFTs between a seller and a designated buyer, leveraging EIP-712 for authorization."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""NFTMarketFees""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""./NFTMarketFees.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""__gap_was_DOMAIN_SEPARATOR"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Likely a placeholder variable related to a previous state layout, possibly during development or refactoring related to upgradeability or the `DOMAIN_SEPARATOR` itself.""
      },
      {
        ""Name"": ""DOMAIN_SEPARATOR"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Immutable EIP-712 domain separator, calculated in the constructor based on contract name, version, chain ID, and the verifying contract address (proxy).""
      },
      {
        ""Name"": ""BUY_FROM_PRIVATE_SALE_TYPEHASH"",
        ""Type"": ""bytes32"",
        ""Purpose"": ""Constant EIP-712 type hash for the `BuyFromPrivateSale` struct/message format used in signature verification.""
      },
      {
        ""Name"": ""NAME"",
        ""Type"": ""string"",
        ""Purpose"": ""Constant string representing the EIP-712 domain name ('FNDNFTMarket').""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000]"",
        ""Purpose"": ""Storage gap to allow adding new state variables in future upgrades without causing storage layout collisions.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""internal (effectively, due to abstract contract)"",
        ""Purpose"": ""Initializes the contract, validates the proxy address, and computes the EIP-712 `DOMAIN_SEPARATOR`."",
        ""Parameters"": [
          ""address marketProxyAddress""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""buyFromPrivateSale"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Public entry point for a buyer to execute a private sale using `msg.value` as the full payment amount. Calls `buyFromPrivateSaleFor`."",
        ""Parameters"": [
          ""IERC721 nftContract"",
          ""uint256 tokenId"",
          ""uint256 deadline"",
          ""uint8 v"",
          ""bytes32 r"",
          ""bytes32 s""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""buyFromPrivateSaleFor"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Core logic for executing a private sale. Verifies deadline, checks payment (potentially withdrawing shortfall from `feth`), validates the seller's EIP-712 signature, transfers the NFT, and distributes funds."",
        ""Parameters"": [
          ""IERC721 nftContract"",
          ""uint256 tokenId"",
          ""uint256 amount"",
          ""uint256 deadline"",
          ""uint8 v"",
          ""bytes32 r"",
          ""bytes32 s""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_distributeFunds"",
        ""Visibility"": ""internal (inherited)"",
        ""Purpose"": ""Handles the distribution of the payment amount between the seller, creator royalty, and platform fee (inherited from NFTMarketFees)."",
        ""Parameters"": [
          ""address nftContract"",
          ""uint256 tokenId"",
          ""address seller"",
          ""uint256 amount""
        ],
        ""Returns"": [
          ""uint256 f8nFee"",
          ""uint256 creatorFee"",
          ""uint256 ownerRev""
        ]
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier (inherited)"",
        ""Purpose"": ""Prevents reentrant calls into the function it modifies."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC721(nftContract).ownerOf(tokenId): Reads the owner of the specified NFT."",
    ""IERC721(nftContract).transferFrom(seller, msg.sender, tokenId): Transfers the NFT from the seller to the buyer."",
    ""AddressUpgradeable.isContract() (on marketProxyAddress): Checks if the provided proxy address is a contract."",
    ""ecrecover(digest, v, r, s): Precompiled contract used to recover the signer's address from an EIP-712 signature."",
    ""feth.marketWithdrawFrom(msg.sender, delta): Interacts with an external contract/system aliased as `feth` to withdraw funds on behalf of the buyer (`msg.sender`). The nature of `feth` is not defined in this snippet."",
    ""_distributeFunds: Internal/inherited function which likely involves sending Ether/value to seller, creator, and platform addresses.""
  ],
  ""SpecialMechanisms"": [
    ""EIP-712 Off-Chain Signatures: Used to authorize the private sale without requiring an on-chain transaction from the seller beforehand."",
    ""Upgradeability: Use of `AddressUpgradeable`, storage gaps (`__gap`), and immutable `DOMAIN_SEPARATOR` calculated using a proxy address strongly indicates the contract is designed for proxy-based upgradeability (likely UUPS or Transparent Proxy)."",
    ""Custom Errors: Utilizes custom error types (e.g., `NFTMarketPrivateSale_Sale_Expired()`) for reverting transactions, enhancing efficiency and clarity over require strings."",
    ""Abstract Contract: Designed to be inherited by a concrete implementation contract, likely because `NFTMarketFees` or other dependencies define abstract functions (e.g., `_distributeFunds`, potentially the definition of `feth`)."",
    ""Reentrancy Guard: Employs the `nonReentrant` modifier (presumably inherited) to mitigate reentrancy risks during payment and transfer operations.""
  ],
  ""Questions"": [
    ""What is the implementation and security model of the `feth.marketWithdrawFrom` function? How does it interact with user funds?"",
    ""What is the exact implementation of the `_distributeFunds` function inherited from `NFTMarketFees`?"",
    ""There is a discrepancy: The error `NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max` suggests a 24-hour maximum deadline, but the code checks `deadline > block.timestamp + 2 days`. Which is the intended behavior?"",
    ""Confirm the specific upgradeability pattern being used (UUPS, Transparent Proxy)."",
    ""Is the `nonReentrant` modifier applied appropriately considering all potential external calls within `buyFromPrivateSaleFor` and `_distributeFunds`?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Replay Attack Vulnerability in buyFromPrivateSaleFor Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `buyFromPrivateSaleFor` function uses EIP-712/ECDSA signatures for authorization, but lacks explicit nonce management or signature invalidation, making it susceptible to replay attacks. An attacker could potentially reuse a valid signature within the deadline to execute the sale multiple times if the conditions (deadline, price, tokenId) are still met. This is mitigated by the deadline, domain separator and amount verification."",
      ""Impact"": ""An attacker could potentially purchase the same NFT multiple times using a single valid signature, leading to unauthorized transfers and financial loss for the seller or buyer.  Other side effects, such as incorrect accounting or external calls could be exploited."",
      ""Location"": ""NFTMarketPrivateSale.sol: buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Unclear Handling of Excess Ether Sent and Reliance on `feth.marketWithdrawFrom`"",
      ""Severity"": ""High"",
      ""Description"": ""The `buyFromPrivateSaleFor` function's logic for handling discrepancies between `amount` and `msg.value` is flawed and potentially dangerous. If `amount > msg.value`, the code attempts to withdraw funds from an external `feth` contract using `feth.marketWithdrawFrom(msg.sender, delta)`, but the function definition is not provided and it relies on external contract. If `amount < msg.value`, the transaction reverts with `NFTMarketPrivateSale_Too_Much_Value_Provided()`, forcing users to send exact value. There is no error handling for if the `feth.marketWithdrawFrom` call fails."",
      ""Impact"": ""Locked ether if exact price not sent. Dependence on external `feth` contract without a clear definition which may lead to unpredictable consequences and fund loss if `feth.marketWithdrawFrom` is ever called. The NFT may be transferred while funds are not properly withdrawn, causing loss for the seller/buyer, or the NFT could be stuck."",
      ""Location"": ""NFTMarketPrivateSale.sol: buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Reliance on `transferFrom` without allowance check"",
      ""Severity"": ""High"",
      ""Description"": ""The code assumes that the seller has already approved the marketplace contract to transfer the NFT using `transferFrom`. If the seller hasn't granted the necessary approval, the transaction will revert, leading to a failed sale and a potential loss of gas for the buyer. The seller must first approve the marketplace contract using `approve` or `setApprovalForAll` functions of the NFT contract."",
      ""Impact"": ""The transaction will revert if the seller has not approved the marketplace contract to transfer the NFT, causing frustration for the buyer and potentially wasted gas fees."",
      ""Location"": ""NFTMarketPrivateSale.sol: buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in buyFromPrivateSaleFor"",
      ""Severity"": ""Medium"",
      ""Description"": ""A malicious actor can observe a transaction calling `buyFromPrivateSaleFor` in the mempool and attempt to front-run it by submitting their own transaction with a higher gas price. While the signature protects key parameters, the attacker could still steal the NFT purchase opportunity."",
      ""Impact"": ""The attacker could steal the NFT purchase opportunity, forcing the original intended buyer to pay more gas and potentially losing the chance to buy the NFT at the agreed-upon price."",
      ""Location"": ""NFTMarketPrivateSale.sol: buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Inconsistent Deadline Enforcement and Unbounded Loophole"",
      ""Severity"": ""Medium"",
      ""Description"": ""The code checks if the `deadline` is within 2 days from the current block timestamp (`deadline > block.timestamp + 2 days`), but the error message `NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max()` suggests a 24-hour limit, creating a discrepancy. This condition also means that private sale can extend beyond the intended `24hrs` period for a duration up to `2 days`."",
      ""Impact"": ""Users may believe the private sale deadline is shorter than it actually is, leading to misinterpretations. A malicious seller could specify a longer deadline than intended."",
      ""Location"": ""NFTMarketPrivateSale.sol: buyFromPrivateSaleFor function, deadline validation logic""
    },
    {
      ""Issue"": ""Insufficient Input Validation for `amount` Parameter"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `buyFromPrivateSaleFor` lacks explicit validation to ensure that the `amount` is a reasonable or expected value for the NFT. Although the signature ties the amount to the trade, an attacker could potentially manipulate off-chain data to generate a valid signature with a very low `amount` and then exploit the market."",
      ""Impact"": ""An attacker might be able to purchase the NFT for a price lower than intended, exploiting a vulnerability in the amount validation."",
      ""Location"": ""NFTMarketPrivateSale.sol: buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Incorrect Deadline Check: Maximum Duration Allowed"",
      ""Severity"": ""Low"",
      ""Description"": ""The code checks if the `deadline` exceeds `block.timestamp + 2 days`.  The error message suggests it should be `24 hours`.  This discrepancy could lead to confusion and unintended behavior if the intention was actually 24 hours."",
      ""Impact"": ""Users might set deadlines they believe are valid but are rejected, or vice versa. Potential for incorrect private sales duration."",
      ""Location"": ""buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Lack of Input Validation on `marketProxyAddress` in Constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor only checks if `marketProxyAddress` is a contract, but not its functionality or if it is the *expected* contract. This could lead to the `DOMAIN_SEPARATOR` being calculated with a malicious contract, which could potentially be used to craft signatures."",
      ""Impact"": ""A malicious actor could deploy a dummy contract at `marketProxyAddress` and have the `DOMAIN_SEPARATOR` calculated using that address."",
      ""Location"": ""NFTMarketPrivateSale.sol: constructor""
    },
    {
      ""Issue"": ""Potential Integer Overflow in Deadline Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `deadline > block.timestamp + 2 days` check might be vulnerable to an integer overflow if `block.timestamp` is close to the maximum value of `uint256`. Although unlikely, it's good practice to use SafeMath-like libraries."",
      ""Impact"": ""Incorrect deadline validation might occur when block.timestamp is close to the max uint256 value"",
      ""Location"": ""buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Missing Checks for Zero Addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""The code doesn\'t explicitly check for zero addresses in sensitive functions or constructors. Although the `marketProxyAddress` is checked to be a contract, other addresses like the seller address obtained from `nftContract.ownerOf(tokenId)` are not validated to ensure they are not the zero address."",
      ""Impact"": ""If a zero address is accidentally used as an NFT owner, it could lead to unexpected behavior or loss of funds. The NFT may be locked forever."",
      ""Location"": ""NFTMarketPrivateSale.sol: constructor, buyFromPrivateSaleFor function""
    },
    {
      ""Issue"": ""Potential Gas Limit Issues with Large Gap Variables"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract contains a large `uint256[1000] private __gap;` variable. While it is good practice, very large gap variables can increase deployment costs and potentially cause issues with gas limits."",
      ""Impact"": ""Increased deployment costs and potential gas limit issues."",
      ""Location"": ""NFTMarketPrivateSale.sol: end of contract""
    },
    {
      ""Issue"": ""Missing `address(nftContract)` Validation"",
      ""Severity"": ""Low"",
      ""Description"": ""There is no check if `address(nftContract)` is the zero address. If `address(nftContract)` is the zero address, unexpected behavior may occur during the smart contract execution."",
      ""Impact"": ""Unexpected behavior due to invalid NFT contract address."",
      ""Location"": ""NFTMarketPrivateSale.sol: buyFromPrivateSaleFor function""
    },
        {
      ""Issue"": ""Immutable DOMAIN_SEPARATOR can be computed off-chain"",
      ""Severity"": ""Informational"",
      ""Description"": ""The `DOMAIN_SEPARATOR` is computed within the constructor and is immutable. This allows anyone to compute the `DOMAIN_SEPARATOR` off-chain given the contract address and chain ID, which might simplify certain types of attacks or monitoring, although it doesn't introduce a direct vulnerability on its own."",
      ""Impact"": ""Slightly increased transparency, which could be helpful for attackers to understand the signature scheme, but it's a standard practice and not a significant issue."",
      ""Location"": ""Constructor.""
    },
    {
      ""Issue"": ""Inconsistent use of address type in DOMAIN_SEPARATOR construction"",
      ""Severity"": ""Info"",
      ""Description"": ""In the DOMAIN_SEPARATOR calculation, the `verifyingContract` which is `marketProxyAddress` is implicitly cast to `address`. Even though this works fine as is, it might be better to explicitly cast using `address(marketProxyAddress)` for clarity and consistency."",
      ""Impact"": ""Minor code style issue that could improve readability."",
      ""Location"": ""NFTMarketPrivateSale.sol: constructor""
    }
  ],
  ""IssueNumber"": 30,
  ""OutputList"": 14
}",172.26144123077393,3911.0,26.0,"### **[M-01] EIP-712 signatures can be re-used in private sales**

**Report Description**:
The `buyFromPrivateSaleFor` function in `NFTMarketPrivateSale.sol` allows buyers to purchase NFTs using EIP-712 signatures provided by sellers. However, the function lacks checks to prevent the reuse of these signatures within a small time window. If the seller regains ownership of the NFT, the same signature can be reused, leading to unauthorized NFT transfers. This vulnerability arises because the function does not track or invalidate used signatures.

**Match in Response List**:
Matches with the issue titled **""Potential Replay Attack Vulnerability in buyFromPrivateSaleFor Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue with EIP-712 signatures being reused, which aligns with the report's description of the vulnerability. The response correctly explains the risks of replay attacks due to the lack of nonce management or signature invalidation, which is consistent with Solidity best practices for secure contract interactions.

---

### **[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**

**Report Description**:
The `buyFromPrivateSaleFor` function attempts to withdraw the difference between the `amount` and `msg.value` from the buyer's unlocked balance if `amount > msg.value`. However, if the buyer has an open offer on the same NFT, the funds remain locked until the offer expires. This prevents the buyer from using these funds for the private sale, leading to transaction failures and potential frustration for users.

**Match in Response List**:
Matches with the issue titled **""Unclear Handling of Excess Ether Sent and Reliance on `feth.marketWithdrawFrom`""**.

**Validation**:
**Partially Correct**. The response identifies the issue with handling discrepancies between `amount` and `msg.value` and the reliance on the external `feth` contract. However, it does not explicitly mention the specific scenario where funds are locked due to an open offer on the same NFT, which is a critical detail in the report. The response covers the broader issue but misses this specific nuance.

---

### **[M-12] Private sale spoofing**

**Report Description**:
The `buyFromPrivateSaleFor` function is vulnerable to spoofing attacks, where a user can create a private sale with a valid signature and then frontrun the transaction by transferring the NFT to a different wallet they control. While no funds are lost due to the atomic nature of the NFT <> FETH exchange, this can be problematic for third-party off-chain NFT markets that rely on this signature feature. It can also frustrate users if their transactions fail due to such frontrunning.

**Match in Response List**:
Matches with the issue titled **""Potential Front-Running Vulnerability in buyFromPrivateSaleFor""**.

**Validation**:
**Correct**. The response accurately identifies the front-running vulnerability in the `buyFromPrivateSaleFor` function. It correctly explains the risk of an attacker stealing the NFT purchase opportunity by submitting a transaction with a higher gas price, which aligns with the report's description of the spoofing issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] EIP-712 signatures can be re-used in private sales**
- **[M-12] Private sale spoofing**

**Partially Correct Matches**:

- **[M-06] buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT**

**Missed Issues from Issue Report**:

- *None*

---

The responses in the `response_list` generally align well with the issues reported, with only one partially correct match due to a missed specific detail. Overall, the coverage of the issues is comprehensive, and the responses accurately address the core vulnerabilities.","```
1. Potential Replay Attack Vulnerability in buyFromPrivateSaleFor Function
2. Potential Front-Running Vulnerability in buyFromPrivateSaleFor
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Potential Replay Attack Vulnerability in buyFromPrivateSaleFor Function"" appears at rank **1**.
   - ""Potential Front-Running Vulnerability in buyFromPrivateSaleFor"" appears at rank **4**.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 4: \( P@4 = \frac{2}{4} = 0.5 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 0.5}{2} = 0.75
   \]

**Output**:
```
0.75
```"
SendValueWithFallbackWithdraw.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();

/**
 * @title A mixin for sending ETH with a fallback withdraw mechanism.
 * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance
 * for future withdrawal instead.
 */
abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  /// @dev Tracks the amount of ETH that is stored in escrow for future withdrawal.
  mapping(address => uint256) private pendingWithdrawals;

  /**
   * @notice Emitted when an attempt to send ETH fails or runs out of gas and the value is stored in escrow instead.
   * @param user The account which has escrowed ETH to withdraw.
   * @param amount The amount of ETH which has been added to the user's escrow balance.
   */
  event WithdrawPending(address indexed user, uint256 amount);
  /**
   * @notice Emitted when escrowed funds are withdrawn.
   * @param user The account which has withdrawn ETH.
   * @param amount The amount of ETH which has been withdrawn.
   */
  event Withdrawal(address indexed user, uint256 amount);

  /**
   * @notice Allows a user to manually withdraw funds which originally failed to transfer to themselves.
   */
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  /**
   * @notice Allows anyone to manually trigger a withdrawal of funds which originally failed to transfer for a user.
   * @param user The account which has escrowed ETH to withdraw.
   */
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  /**
   * @dev Attempt to send a user or contract ETH and if it fails store the amount owned for later withdrawal.
   */
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully
    // solhint-disable-next-line avoid-low-level-calls
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      // Record failed sends for a withdrawal later
      // Transfers could fail if sent to a multisig with non-trivial receiver logic
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  /**
   * @notice Returns how much funds are available for manual withdraw due to failed transfers.
   * @param user The account to check the escrowed balance of.
   * @return balance The amount of funds which are available for withdrawal for the given user.
   */
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[499] private __gap;
}",802,94,"[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals

Function `withdrawFor()`
The `NFTMarketFees` contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.
",1,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();


abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  
  mapping(address => uint256) private pendingWithdrawals;

  
  event WithdrawPending(address indexed user, uint256 amount);
  
  event Withdrawal(address indexed user, uint256 amount);

  
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    
    
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      
      
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  
  uint256[499] private __gap;
}",353,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the `nonReentrant` modifier from `ReentrancyGuardUpgradeable` effectively prevents reentrancy attacks on the `withdrawFor` function. Specifically, analyze potential call flows from the `user.sendValue(amount)` call to ensure no malicious contract can re-enter `withdrawFor` during the Ether transfer."",
        ""Analyze the fallback function of any contract that might receive Ether via `withdrawFor`. Confirm that a malicious fallback function cannot re-enter the contract during the `sendValue` call."",
        ""Consider scenarios where the `user` address in `withdrawFor` is a smart contract that attempts to call back into the contract, even if not directly into `withdrawFor`. Confirm the `nonReentrant` modifier protects against all such reentrancy paths.""
      ]
    },
    {
      ""Area"": ""Integer Overflow/Underflow"",
      ""Tasks"": [
        ""Carefully review the `unchecked` block in `_sendValueWithFallbackWithdraw` where `pendingWithdrawals[user] += amount` occurs. Analyze the possible range of values for `amount` and `pendingWithdrawals[user]` to confirm that overflows are impossible or their occurrence is acceptable by design."",
        ""Consider the maximum potential value of `pendingWithdrawals[user]` after numerous failed `_sendValueWithFallbackWithdraw` calls. Ensure that adding further `amount` values will not lead to unexpected behavior due to wrapping."",
        ""Check for underflow vulnerabilities when `pendingWithdrawals[user]` is set to 0 within `withdrawFor`.""
      ]
    },
    {
      ""Area"": ""Denial of Service (DoS)"",
      ""Tasks"": [
        ""Analyze potential DoS scenarios where `_sendValueWithFallbackWithdraw` is repeatedly called with a `gasLimit` value that always causes the transfer to fail. Evaluate the impact of accumulating large values in `pendingWithdrawals` on contract storage and gas costs for withdrawals."",
        ""Investigate potential DoS scenarios related to the `withdrawFor` function. Consider whether an attacker could repeatedly call `withdrawFor` on multiple accounts with small pending withdrawals to exhaust gas limits or increase storage costs."",
        ""Evaluate the gas costs of calling `getPendingWithdrawal` when `pendingWithdrawals` mapping contains a large number of entries. Ensure that the gas cost remains within reasonable limits."",
        ""If inheriting contract manages funds, assess the risk of the contract running out of funds, preventing legitimate withdrawals."",
        ""Check if the `user.sendValue(amount)` call in `withdrawFor` can cause a DoS if the recipient contract requires excessive gas or reverts. If so, consider implementing a safeguard, perhaps by using a low-level `call` and checking the return status or limiting gas forwarding.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of the `_sendValueWithFallbackWithdraw` function, particularly the use of `user.call{ value: amount, gas: gasLimit }(\""\"")`. Determine if alternative approaches, such as forwarding all available gas, would be more gas-efficient in certain scenarios."",
        ""Evaluate the gas efficiency of the `withdrawFor` function, considering the cost of reading from and writing to the `pendingWithdrawals` mapping and emitting events."",
        ""Review the storage usage of the `__gap` variable. Ensure that its size is sufficient for future upgrades but not unnecessarily large, wasting storage space."",
        ""Determine the gas cost for withdrawing very small amounts. Are there cases where it's better to not make an initial transfer attempt with a small gasLimit due to the gas overhead of storing the pending withdrawal?""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Analyze the implications of the `withdrawFor` function being `public`. Consider potential risks associated with allowing anyone to withdraw funds on behalf of any user, such as griefing or unintended consequences."",
        ""If access control is needed for `withdrawFor`, evaluate different options, such as restricting it to the user themselves (requiring a signature) or an administrator role."",
        ""If the contract is intended to be upgradeable, verify proper access control is implemented for upgrade functionality in the proxy contract or the contract inheriting from this one."",
        ""If the contract holds substantial funds, consider implementing some kind of pause mechanism to mitigate risks of exploits.""
      ]
    },
    {
      ""Area"": ""External Call Safety"",
      ""Tasks"": [
        ""Review the use of `user.sendValue(amount)` in `withdrawFor`. Given that `sendValue` reverts the entire transaction if the recipient's fallback function fails, consider switching to a low-level `call` with a gas limit to provide more robustness and allow the withdrawal to succeed even if the recipient's logic has issues."",
        ""If a low-level call is used instead of `sendValue` in `withdrawFor`, verify the return value is checked and appropriate action is taken if the call fails. Specifically, log the failure and potentially revert depending on intended behavior.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Confirm that the contract is initialized correctly using an initializer function (not shown in the snippet) and that all state variables, including those inherited from `ReentrancyGuardUpgradeable`, are properly initialized."",
        ""Verify the presence and correct implementation of the UUPS or Transparent proxy pattern for upgradeability. This includes ensuring that the proxy contract correctly delegates calls to the implementation contract and that access control for upgrades is properly configured."",
        ""Assess the impact of future upgrades on the `pendingWithdrawals` mapping. Ensure that upgrades do not inadvertently invalidate or corrupt the data stored in this mapping."",
        ""Consider potential upgrade risks related to the `__gap` variable. Verify that upgrades do not introduce storage collisions with this variable.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines an abstract, upgradeable contract `SendValueWithFallbackWithdraw` designed to handle Ether transfers. It provides a mechanism where an initial Ether transfer attempt (using `_sendValueWithFallbackWithdraw`) can specify a gas limit. If this transfer fails, the amount is recorded in `pendingWithdrawals`, allowing the recipient to manually withdraw the funds later using `withdraw` or `withdrawFor`. The contract utilizes OpenZeppelin's upgradeable contracts for reentrancy protection (`ReentrancyGuardUpgradeable`) and safer Ether transfers (`AddressUpgradeable`). It includes basic event logging for pending and completed withdrawals."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""SendValueWithFallbackWithdraw"",
    ""Purpose"": ""To provide a robust mechanism for sending Ether, allowing for a fallback withdrawal option if the initial transfer (potentially with a limited gas stipend) fails. It's designed as an abstract base contract to be inherited."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ReentrancyGuardUpgradeable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""pendingWithdrawals"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Stores the amount of Ether pending withdrawal for each user address, populated when an initial transfer via `_sendValueWithFallbackWithdraw` fails."",
        ""Visibility"": ""private""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[499]"",
        ""Purpose"": ""Reserved storage slots for upgradeability, following the OpenZeppelin UUPS/Transparent proxy pattern."",
        ""Visibility"": ""private""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor / initializer"",
        ""Visibility"": ""N/A (implicit)"",
        ""Purpose"": ""As an abstract contract using upgradeable pattern, it likely relies on an `initializer` function (not shown) to set up state, including the `ReentrancyGuardUpgradeable`."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user (`msg.sender`) to withdraw their pending Ether balance."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows any caller to trigger the withdrawal of pending Ether for a specified user. Protected against reentrancy."",
        ""Parameters"": [
          ""address payable user""
        ],
        ""Returns"": [],
        ""Modifiers"": [""nonReentrant""]
      },
      {
        ""Name"": ""_sendValueWithFallbackWithdraw"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Attempts to send Ether to a user with a specified gas limit. If the transfer fails, it records the amount in `pendingWithdrawals` for later withdrawal."",
        ""Parameters"": [
          ""address payable user"",
          ""uint256 amount"",
          ""uint256 gasLimit""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""getPendingWithdrawal"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the pending withdrawal balance for a given user."",
        ""Parameters"": [
          ""address user""
        ],
        ""Returns"": [
          ""uint256 balance""
        ]
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier (inherited)"",
        ""Purpose"": ""Prevents reentrant calls into functions marked with this modifier."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""The `withdrawFor` function interacts with the `user` address by calling `user.sendValue(amount)`. This sends Ether using the `AddressUpgradeable` library function, which forwards all available gas and reverts on failure."",
    ""The `_sendValueWithFallbackWithdraw` function interacts with the `user` address by using a low-level `call{ value: amount, gas: gasLimit }(\""\"")`. This sends Ether with a caller-specified `gasLimit` and returns a boolean success status instead of reverting on failure.""
  ],
  ""SpecialMechanisms"": [
    ""**Upgradeable Contract Pattern:** Uses OpenZeppelin Upgradeable contracts (`@openzeppelin/contracts-upgradeable`) and includes a `__gap` variable, indicating it's designed to be deployed behind a proxy."",
    ""**Reentrancy Guard:** Employs the `nonReentrant` modifier from `ReentrancyGuardUpgradeable` on the `withdrawFor` function to prevent reentrancy attacks during withdrawal."",
    ""**Fallback Withdrawal Pattern:** Implements a common pattern where a potentially failing Ether transfer (e.g., due to gas limits) results in the funds being held internally, allowing the recipient to pull them later."",
    ""**Low-Level Call:** Uses `address.call{...}` for fine-grained control over gas forwarding in `_sendValueWithFallbackWithdraw`."",
    ""**Custom Errors:** Uses a custom error (`SendValueWithFallbackWithdraw_No_Funds_Available`) for gas efficiency and clarity upon failed withdrawal attempts due to zero balance."",
    ""**Unchecked Arithmetic:** Uses an `unchecked` block when incrementing `pendingWithdrawals`. This assumes overflows are not possible or are acceptable."",
    ""**Library Usage:** Uses `AddressUpgradeable` library for the `sendValue` utility function.""
  ],
  ""Questions"": [
    ""What is the intended source of funds for this contract? Since it's abstract, the inheriting contract must manage receiving Ether to cover both initial sends and pending withdrawals."",
    ""Why is `withdrawFor` `public` instead of restricting it (e.g., `internal`, or `onlyOwner`, or only callable by the `user` themselves)? Allowing anyone to trigger a withdrawal for any user might be used for griefing (forcing gas costs or unwanted contract interactions on the recipient)."",
    ""What is the expected `gasLimit` to be passed into `_sendValueWithFallbackWithdraw`? Is it intended to be low (like the deprecated `transfer` limit) or dynamically determined?"",
    ""Is the use of `unchecked` when adding to `pendingWithdrawals` safe under all circumstances? Could malicious input or unexpected scenarios lead to an overflow, even with `uint256`?"",
    ""How does the `user.sendValue(amount)` call in `withdrawFor` handle recipients that might require significant gas (more than forwarded) or intentionally revert? `sendValue` reverts the *entire* `withdrawFor` call if the recipient fails, which might prevent users from withdrawing if their receiving address has problematic fallback logic. Would a low-level call (perhaps forwarding all gas but checking success) be more robust here?"",
    ""Is there any mechanism planned (perhaps in the inheriting contract) to handle potential DOS situations where `_sendValueWithFallbackWithdraw` is repeatedly called with failing parameters, potentially filling storage but never leading to successful withdrawals?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Risk in `_sendValueWithFallbackWithdraw` and `withdrawFor`"",
      ""Severity"": ""High"",
      ""Description"": ""The `user.sendValue(amount)` call in `withdrawFor` and the fallback mechanism in `_sendValueWithFallbackWithdraw` introduce a reentrancy risk, even with `nonReentrant`. A malicious user's fallback/receive function can call back into the contract, potentially bypassing the `nonReentrant` modifier on subsequent calls within the same transaction or manipulating state before the transaction completes. A vulnerable contract implementing this logic and using functions relying on the pending withdrawals could be vulnerable. The `user.call` could revert but still consume gas, leaving the contract vulnerable."",
      ""Impact"": ""Potential loss of funds due to malicious reentrancy attacks; Unexpected state changes or denial of service if a malicious contract deliberately causes the `_sendValueWithFallbackWithdraw` to always fail, filling up its `pendingWithdrawals` balance."",
      ""Location"": ""`_sendValueWithFallbackWithdraw` function, specifically the fallback mechanism after the `user.call` and the `withdrawFor` function.""
    },
    {
      ""Issue"": ""Potential Denial of Service (DoS) via `_sendValueWithFallbackWithdraw`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function's fallback mechanism can lead to DoS. Repeated call failures (e.g., due to reverts, insufficient gas, or non-contract addresses) cause unbounded growth of `pendingWithdrawals`. This can hinder future operations, render withdrawals impossible, and cause gas exhaustion.  This requires manual intervention to resolve, impacting usability and trust."",
      ""Impact"": ""Users may be unable to withdraw funds if a malicious contract continuously reverts value transfers, leading to a denial of service; Potentially higher gas costs and the direct transfer mechanism becomes non-functional; Hinders normal operations or renders withdrawals impossible."",
      ""Location"": ""`_sendValueWithFallbackWithdraw` function""
    },
    {
      ""Issue"": ""Gas Limit Configuration Issues in `_sendValueWithFallbackWithdraw`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function relies on a user-provided `gasLimit` for `user.call`. An insufficient `gasLimit` causes call failures and accumulation in `pendingWithdrawals`. An excessively high `gasLimit` wastes gas and opens the door for denial-of-service attacks. There is no explicit check or restriction on the size of `gasLimit`."",
      ""Impact"": ""Potential for denial of service or manipulation of `pendingWithdrawals` by controlling the `gasLimit` value; If user specifies high value of `gasLimit`, it can lead to denial of service for sender."",
      ""Location"": ""`_sendValueWithFallbackWithdraw` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `pendingWithdrawals`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `unchecked` block in `_sendValueWithFallbackWithdraw` disables overflow checks when adding the amount to `pendingWithdrawals[user]`. A large enough `amount` or repeated additions could cause an integer overflow, leading to incorrect accounting or unexpected behavior, especially if `pendingWithdrawals[user]` is very close to `type(uint256).max`.  When pendingWithdrawals reaches its maximum value, further calls to function `_sendValueWithFallbackWithdraw` to the same user may result in unexpected behavior or even revert due to overflow when using addition outside the `unchecked` block."",
      ""Impact"": ""Incorrect accounting of pending withdrawals; Potential loss of funds for users; Unexpected behavior during withdrawal."",
      ""Location"": ""`_sendValueWithFallbackWithdraw` function, inside the `unchecked` block where `pendingWithdrawals[user] += amount;`""
    },
    {
      ""Issue"": ""Potential Denial of Service in `withdrawFor` if `sendValue` fails repeatedly"",
      ""Severity"": ""Low"",
      ""Description"": ""If the `user.sendValue(amount)` call in `withdrawFor` consistently fails, the user's funds remain stuck in `pendingWithdrawals`. The withdrawal is blocked. If the user is a malicious contract, they can cause a denial of service by always reverting, preventing the victim from withdrawing their funds.  No clear mitigation is provided in the given code."",
      ""Impact"": ""Specific users may be unable to withdraw their funds."",
      ""Location"": ""`withdrawFor` function""
    },
    {
      ""Issue"": ""Lack of Access Control for `withdrawFor`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `withdrawFor` function lacks access control, allowing anyone to withdraw funds on behalf of any user. This creates a trust relationship for other smart contracts interacting with this contract."",
      ""Impact"": ""Unauthorized withdrawal of funds from `pendingWithdrawals` for a given user, provided the `pendingWithdrawals[user]` is greater than 0."",
      ""Location"": ""withdrawFor function""
    },
    {
      ""Issue"": ""Missing Check for Contract Balance"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function attempts to send `amount` to `user` without first checking if the contract has sufficient funds to cover the transfer. While a failed `sendValue` call will add the amount to `pendingWithdrawals`, repeatedly attempting to send value when the contract's balance is low will cause many `WithdrawPending` events to be emitted and increase the `pendingWithdrawals` value unnecessarily, potentially consuming more gas later when users withdraw."",
      ""Impact"": ""Unnecessary gas consumption and potential denial of service due to repeatedly failing `sendValue` calls when the contract's balance is insufficient."",
      ""Location"": ""SendValueWithFallbackWithdraw.sol:_sendValueWithFallbackWithdraw function.""
    },
    {
      ""Issue"": ""Lack of zero address check in functions interacting with addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""Functions such as `withdrawFor` and `_sendValueWithFallbackWithdraw` don\'t check if the `user` address is the zero address. Sending ETH to the zero address is equivalent to burning it, and in the context of `withdrawFor`, it would be a loss of funds."",
      ""Impact"": ""Potential loss of funds if `user` is the zero address."",
      ""Location"": ""`withdrawFor` and `_sendValueWithFallbackWithdraw` functions""
    },
    {
      ""Issue"": ""Gas Limit Considerations for `_sendValueWithFallbackWithdraw`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function relies on `user.call{ value: amount, gas: gasLimit }(\\""\\"")`. If the provided `gasLimit` is insufficient for the receiving contract\'s fallback function (if any), the call will fail. Consistently providing too low a gas limit can render the direct transfer mechanism ineffective. This is important as it will significantly increase the gas used in the long run if every `sendValue` fails."",
      ""Impact"": ""Potentially higher gas costs and the direct transfer mechanism becomes non-functional if the gas limit is not chosen correctly."",
      ""Location"": ""`_sendValueWithFallbackWithdraw` function""
    },
    {
      ""Issue"": ""Potential for griefing with small transfers"",
      ""Severity"": ""Low"",
      ""Description"": ""An attacker could send a very small amount of ETH (e.g. 1 wei) to many different users, and if these transfers fail small `pendingWithdrawals` will be created. Although each withdrawal is small, if many users have to withdraw very small amounts, the gas cost of performing these withdrawals might become significant, thereby increasing the cost of using the contract."",
      ""Impact"": ""Potential increase in gas costs for users due to many small pending withdrawals."",
      ""Location"": ""_sendValueWithFallbackWithdraw function""
    },
    {
      ""Issue"": ""Missing Event for Failed Withdrawal in `withdrawFor` and `_sendValueWithFallbackWithdraw`"",
      ""Severity"": ""Info"",
      ""Description"": ""If `user.sendValue(amount)` in `withdrawFor` and `_sendValueWithFallbackWithdraw` fails, there is no event emitted to indicate this failure. Adding an event would help with debugging and monitoring."",
      ""Impact"": ""Reduced visibility into failed withdrawal attempts; Lack of debugging events."",
      ""Location"": ""`withdrawFor` function, after `user.sendValue(amount);` and `_sendValueWithFallbackWithdraw` function""
    },
    {
      ""Issue"": ""`WithdrawPending` event is emitted after `pendingWithdrawals` is updated"",
      ""Severity"": ""Info"",
      ""Description"": ""The `WithdrawPending` event is emitted after the `pendingWithdrawals[user]` is updated. This order of operations is not optimal. It's better to emit the event before the state change."",
      ""Impact"": ""Slightly degrades observability and debugging."",
      ""Location"": ""Function `_sendValueWithFallbackWithdraw`""
    },
    {
      ""Issue"": ""No Protection Against Sending to Non-Contract Accounts in `_sendValueWithFallbackWithdraw`"",
      ""Severity"": ""Information"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function does not check if the `user` address is a contract before calling `user.call{ value: amount, gas: gasLimit }(\\""\\"")`. Sending value to a non-contract account is a valid operation but the code handles the `success = false` case differently (queuing for withdrawal)."",
      ""Impact"": ""Unclear intent when sending value to EOA addresses. If the intention is to always send value, consider using `user.transfer(amount)` which reverts if the transfer fails (due to insufficient gas, etc.)."",
      ""Location"": ""Function `_sendValueWithFallbackWithdraw`""
    },
    {
      ""Issue"": ""Potential Front-Running of `withdrawFor` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""A malicious actor could potentially front-run a call to the `withdrawFor` function. While unlikely, it could cause issues if the contract\'s state changes significantly between when the user initiates the withdraw and when it\'s executed on-chain. The reentrancy guard helps against reentrancy *during* the function execution, but not before it."",
      ""Impact"": ""Potential for unexpected behavior if contract state changes before `withdrawFor` is executed."",
      ""Location"": ""Function `withdrawFor`""
    },
    {
      ""Issue"": ""Lack of Access Control for `_sendValueWithFallbackWithdraw`"",
      ""Severity"": ""Informational"",
      ""Description"": ""The `_sendValueWithFallbackWithdraw` function is internal, meaning it can only be called by the contract itself or derived contracts. However, there are no explicit access controls within the provided code to restrict who can call this function from derived contracts."",
      ""Impact"": ""If not carefully controlled in derived contracts, unauthorized entities could initiate value transfers and manipulate pending withdrawals."",
      ""Location"": ""_sendValueWithFallbackWithdraw function""
    },
        {
          ""Issue"": ""Missing Integer Overflow/Underflow Check"",
          ""Severity"": ""Informational"",
          ""Description"": ""The `unchecked { pendingWithdrawals[user] += amount; }` block in `_sendValueWithFallbackWithdraw` explicitly disables overflow/underflow checks. While the intention may be to save gas, it's crucial to consider the potential consequences."",
          ""Impact"": ""Potential for unexpected behavior due to integer overflow. While not necessarily exploitable for immediate fund theft, it can lead to incorrect accounting and potentially enable users to claim excessive funds if combined with other vulnerabilities."",
          ""Location"": ""_sendValueWithFallbackWithdraw function, within the unchecked block.""
        }
  ],
  ""IssueNumber"": 35,
  ""OutputList"": 16
}",212.27953791618347,3922.0,32.0,"### **[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals**

**Report Description**:
The `withdrawFor()` function in the `NFTMarketFees` and `NFTMarketReserveAuction` contracts uses the `_sendValueWithFallbackWithdraw` function to send ether to various recipients (e.g., FoundationTreasury, CreatorRecipients, Seller, Bidder). If the receiver fails to receive the ether due to reasons such as exceeding the gas limit or the receiver contract being unable to accept ether, the ether is recorded in the `pendingWithdrawals` variable. However, there is a risk that the `withdrawFor` function may fail to withdraw the ether recorded in `pendingWithdrawals`, potentially leading to stuck funds.

**Match in Response List**:
Matches with the issue titled **""Potential Denial of Service in `withdrawFor` if `sendValue` fails repeatedly""**.

**Validation**:
**Partially Correct**. The response correctly identifies the issue of repeated failures in the `sendValue` call leading to funds being stuck in `pendingWithdrawals`. However, it does not explicitly address the broader risk of the `withdrawFor` function failing to withdraw the recorded ether, which is the core concern in the issue report. The response focuses on the denial of service aspect but misses the specific impact on the withdrawal mechanism.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-02] SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals**

**Missed Issues from Issue Report**:
- *None*

---

### **Detailed Analysis**

The issue report highlights a specific vulnerability where the `withdrawFor` function may fail to withdraw ether recorded in `pendingWithdrawals`. The response in the `response_list` partially addresses this by discussing the potential for repeated `sendValue` failures leading to funds being stuck. However, the response does not fully capture the broader risk of the withdrawal mechanism itself failing, which is the primary concern in the issue report. This makes the response **partially correct** but incomplete in addressing the full scope of the issue.","```
None.
```",0.0
FETH.sol,"/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}",7670,779,"[M-03] Approve race condition in FETH

Submitted by 0x1f8b
FETH.sol#L212
Front running attack in `approve()` function.
Proof of Concept

The contract of the FETH does not have any protection against the well-known “Multiple Withdrawal Attack” attack on the Approve/TransferFrom methods of the ERC20 standard.
Although this attack poses a limited risk in specific situations, it is worth mentioning to consider it for possible future operations.
There are solutions to mitigate this front running such as, to first reduce the spender's allowance to 0 and set the desired value afterwards; another solution could the one that Open Zeppelin offers, where the non-standard decreaseAllowance and increaseAllowance functions have been added to mitigate the well-known issues involving setting allowances.
  [M-09] Missing receiver validation in withdrawFrom

Submitted by cmichel
FETH.sol#L433
The FETH.withdrawFrom function does not validate its to parameter. Funds can be lost if to is the zero address.
",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();

error FETH_Insufficient_Allowance(uint256 amount);

error FETH_Insufficient_Available_Funds(uint256 amount);

error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();


contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  
  struct AccountInfo {
    
    uint96 freedBalance;
    
    uint32 lockupStartIndex;
    
    LockedBalance.Lockups lockups;
    
    mapping(address => uint256) allowance;
  }

  
  mapping(address => AccountInfo) private accountToInfo;

  
  
  uint256 private immutable lockupDuration;
  
  uint256 private immutable lockupInterval;

  
  address payable private immutable foundationMarket;

  
  
  uint8 public constant decimals = 18;
  
  string public constant name = ""Foundation Wrapped Ether"";
  
  string public constant symbol = ""FETH"";

  
  
  event Approval(address indexed from, address indexed spender, uint256 amount);
  
  event Transfer(address indexed from, address indexed to, uint256 amount);

  
  
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  
  receive() external payable {
    depositFor(msg.sender);
  }

  
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  
  function deposit() external payable {
    depositFor(msg.sender);
  }

  
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      
      if (escrow.expiration == 0) {
        break;
      }

      
      unchecked {
        
        ++escrowIndex;
      }

      
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  
  
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    
    unchecked {
      
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    
    
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      
      revert FETH_Too_Much_ETH_Provided();
    }

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  
  
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      
      while (true) {
        
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    
    uint256 lockedCount;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          
          ++lockedCount;
        }
      }
    }

    
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    
    uint256 i;
    
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    
    unchecked {
      
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  
  function totalSupply() external view returns (uint256 supply) {
    
    return address(this).balance;
  }
}",3357,0,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Foundation Market Privileges"",
      ""Tasks"": [
        ""Verify that the `foundationMarket` address is correctly initialized and cannot be changed after deployment."",
        ""Thoroughly analyze the security of the `foundationMarket` contract. If it's upgradeable, understand the upgrade process and potential risks associated with upgrades. Its vulnerabilities directly impact FETH's security."",
        ""For all functions restricted by `onlyFoundationMarket`, analyze the potential impact of malicious behavior or compromise of the `foundationMarket` contract. Consider scenarios where the market acts against user interests (e.g., unfairly locking/unlocking balances, draining user funds)."",
        ""Examine the `marketChangeLockup` function for potential edge cases or vulnerabilities related to the atomic unlock and lock operations. Ensure that funds cannot be lost or double-spent during this process."",
        ""Assess the impact of potential denial-of-service (DoS) attacks on the `foundationMarket` contract, and how these attacks could affect FETH users.""
      ]
    },
    {
      ""Area"": ""Lockup Mechanism and Time Handling"",
      ""Tasks"": [
        ""Carefully review the `LockedBalance` library's implementation, particularly the `get`, `set`, `del`, and `setTotalAmount` functions. Understand how these functions interact with the `lockupStartIndex` and ensure correct index management during lockup creation and deletion."",
        ""Investigate potential vulnerabilities in the `_freeFromEscrow` function, focusing on the loop that iterates through expired lockups. Ensure that the loop terminates correctly and handles edge cases such as empty lockup lists or corrupted data."",
        ""Analyze the rounding behavior in the expiration calculation: `expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval`. Confirm that this behavior is intentional and doesn't introduce unexpected expiration times or vulnerabilities."",
        ""Determine the practical limitations of the `uint32` type used for `lockupStartIndex`. Assess whether there's a maximum number of lockups that can be created for a single account, and the potential consequences of exceeding this limit."",
        ""Explore potential issues related to timestamp manipulation (if any) and their impact on the lockup expiration logic."",
        ""Verify that the combination of `lockupDuration` and `lockupInterval` always results in evenly divisible intervals as enforced in the constructor.""
      ]
    },
    {
      ""Area"": ""Balance Management and Arithmetic Operations"",
      ""Tasks"": [
        ""Carefully review all arithmetic operations involving the `freedBalance` (uint96) to ensure they are safe from overflows and underflows, especially within `unchecked` blocks. Consider edge cases and maximum values to prevent potential vulnerabilities."",
        ""Analyze the potential impact of integer division rounding errors in the `lockupInterval` calculation, even though it's checked in the constructor. Ensure it cannot be manipulated to create unexpected lockup behaviors."",
        ""In the `_marketLockupFor` function, analyze the logic that determines whether the deposited ETH (`msg.value`) is sufficient to cover the lockup amount. Verify that the correct amount is deducted from the user's `freedBalance` and that the `FETH_Too_Much_ETH_Provided` error is correctly handled."",
        ""Examine the potential for DoS attacks related to the gas cost of the `_freeFromEscrow` function. If a user has a large number of expired lockups, calling this function could exceed the block gas limit and prevent other users from interacting with the contract. Consider pagination or other mitigation strategies.""
      ]
    },
    {
      ""Area"": ""ERC20 Compliance and Token Behavior"",
      ""Tasks"": [
        ""While the contract implements `approve`, `transfer`, and `transferFrom`, it is not a standard ERC20 token. Explicitly document this deviation and its implications for interacting with other DeFi protocols."",
        ""Verify that the `totalSupply` function accurately reflects the total amount of ETH held by the contract (`address(this).balance`)."",
        ""Analyze the implications of the `transfer` and `transferFrom` functions reverting when transferring to `address(0)` or `address(this)`. Ensure that this behavior is intentional and doesn't introduce any unexpected side effects."",
        ""Confirm that the `Approval` and `Transfer` events are emitted correctly with the appropriate parameters whenever allowances or balances are changed.""
      ]
    },
    {
      ""Area"": ""External Interactions and ETH Handling"",
      ""Tasks"": [
        ""Review the use of `payable(msg.sender).sendValue(amount)` for ETH transfers in the `marketWithdrawFrom` and `marketWithdrawLocked` functions. Ensure that the contract handles potential failures of the `sendValue` function gracefully (e.g., by reverting the transaction)."",
        ""Assess the risks associated with relying on `msg.value` for determining the amount of ETH deposited in the `depositFor` and `marketLockupFor` functions. Consider potential vulnerabilities related to incorrect ETH amounts being sent or unexpected interactions with other contracts."",
        ""Ensure proper handling of ETH received via the `receive()` function, particularly regarding potential reentrancy issues if the recipient contract attempts to call back into the FETH contract during the transfer.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
         ""Analyze the gas costs of key functions, such as `deposit`, `withdrawAvailableBalance`, `transfer`, and `marketLockupFor`. Identify potential areas for gas optimization, such as reducing storage writes or using more efficient data structures."",
         ""Evaluate the trade-offs between gas savings and code readability/maintainability when using `unchecked` blocks. Ensure that the potential gas savings justify the increased risk of overflow/underflow errors."",
         ""Consider batching operations where possible to reduce the overall gas cost of interacting with the contract.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The FETH contract implements a wrapped Ether token with a time-locking mechanism. Users can deposit ETH to receive FETH, transfer FETH, and withdraw ETH corresponding to their available (unlocked) FETH balance. A designated 'foundationMarket' contract has special privileges to lock user balances (potentially using user's freed balance or requiring additional ETH deposit via msg.value), unlock balances before their natural expiration, and withdraw both freed and locked ETH on behalf of users. The locking mechanism uses discrete expiration timestamps aligned with a 'lockupInterval'. The contract uses custom errors and unchecked blocks for potential gas optimizations."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""FETH"",
    ""Purpose"": ""To create a wrapped Ether (FETH) token where balances can be time-locked, primarily for interaction with a designated 'foundationMarket' contract."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"",
        ""@openzeppelin/contracts/utils/math/Math.sol"",
        ""./libraries/LockedBalance.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""accountToInfo"",
        ""Type"": ""mapping(address => AccountInfo)"",
        ""Purpose"": ""Stores user account details including freed balance, lockup information, and allowances.""
      },
      {
        ""Name"": ""lockupDuration"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Immutable variable defining the standard duration for new balance locks.""
      },
      {
        ""Name"": ""lockupInterval"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Immutable variable defining the time granularity for lock expirations (calculated from lockupDuration).""
      },
      {
        ""Name"": ""foundationMarket"",
        ""Type"": ""address payable"",
        ""Purpose"": ""Immutable address of the privileged market contract allowed to perform special lock/unlock/withdraw operations.""
      },
      {
        ""Name"": ""decimals"",
        ""Type"": ""uint8"",
        ""Purpose"": ""Constant defining the token's decimal places (18).""
      },
      {
        ""Name"": ""name"",
        ""Type"": ""string"",
        ""Purpose"": ""Constant defining the token's name ('Foundation Wrapped Ether').""
      },
      {
        ""Name"": ""symbol"",
        ""Type"": ""string"",
        ""Purpose"": ""Constant defining the token's symbol ('FETH').""
      },
      {
        ""Name"": ""AccountInfo.freedBalance"",
        ""Type"": ""uint96"",
        ""Purpose"": ""Stores the portion of a user's balance that is not currently locked.""
      },
      {
        ""Name"": ""AccountInfo.lockupStartIndex"",
        ""Type"": ""uint32"",
        ""Purpose"": ""Index pointing to the first potentially active lockup in the user's lockups structure.""
      },
      {
        ""Name"": ""AccountInfo.lockups"",
        ""Type"": ""LockedBalance.Lockups"",
        ""Purpose"": ""Data structure (from LockedBalance library) storing the time-locked balances for a user.""
      },
      {
        ""Name"": ""AccountInfo.allowance"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Stores ERC20-style allowances granted by the account owner to spenders.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, setting the foundationMarket address and lockup parameters."",
        ""Parameters"": [""address payable _foundationMarket"", ""uint256 _lockupDuration""],
        ""Returns"": []
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the contract to receive plain ETH transfers, depositing it for the sender."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""approve"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the allowance for a spender."",
        ""Parameters"": [""address spender"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Deposits ETH for the message sender."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""depositFor"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Deposits ETH for a specified account."",
        ""Parameters"": [""address account""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketChangeLockup"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the foundationMarket to atomically unlock funds from one expiration and lock funds for another account/expiration."",
        ""Parameters"": [""address unlockFrom"", ""uint256 unlockExpiration"", ""uint256 unlockAmount"", ""address lockupFor"", ""uint256 lockupAmount""],
        ""Returns"": [""uint256 expiration""]
      },
      {
        ""Name"": ""marketLockupFor"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the foundationMarket to lock funds for a specified account."",
        ""Parameters"": [""address account"", ""uint256 amount""],
        ""Returns"": [""uint256 expiration""]
      },
      {
        ""Name"": ""marketUnlockFor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the foundationMarket to unlock a specific amount from a specific lockup before its expiration."",
        ""Parameters"": [""address account"", ""uint256 expiration"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketWithdrawFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the foundationMarket to withdraw available (freed) funds from a user's account."",
        ""Parameters"": [""address from"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""marketWithdrawLocked"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the foundationMarket to withdraw funds directly from a specific lockup."",
        ""Parameters"": [""address account"", ""uint256 expiration"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers FETH from the message sender to a recipient."",
        ""Parameters"": [""address to"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers FETH from one address to another, using allowance if applicable."",
        ""Parameters"": [""address from"", ""address to"", ""uint256 amount""],
        ""Returns"": [""bool success""]
      },
      {
        ""Name"": ""withdrawAvailableBalance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw their entire available (freed) ETH balance."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFrom"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows an approved spender (or the owner) to withdraw a specific amount of ETH from an account."",
        ""Parameters"": [""address from"", ""address payable to"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""allowance"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the allowance granted by an owner to a spender."",
        ""Parameters"": [""address account"", ""address operator""],
        ""Returns"": [""uint256 amount""]
      },
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the available balance (freed + expired lockups) of an account."",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256 balance""]
      },
      {
        ""Name"": ""getFoundationMarket"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the address of the foundationMarket contract."",
        ""Parameters"": [],
        ""Returns"": [""address market""]
      },
      {
        ""Name"": ""getLockups"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the active (non-expired) lockups for an account."",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256[] memory expiries"", ""uint256[] memory amounts""]
      },
      {
        ""Name"": ""totalBalanceOf"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the total balance (freed + all lockups, expired or not) of an account."",
        ""Parameters"": [""address account""],
        ""Returns"": [""uint256 balance""]
      },
      {
        ""Name"": ""totalSupply"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the total amount of ETH held by the contract."",
        ""Parameters"": [],
        ""Returns"": [""uint256 supply""]
      },
      {
        ""Name"": ""_deductAllowanceFrom"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Helper function to deduct allowance from an account."",
        ""Parameters"": [""AccountInfo storage accountInfo"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_deductBalanceFrom"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Helper function to deduct from the freed balance of an account."",
        ""Parameters"": [""AccountInfo storage accountInfo"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_freeFromEscrow"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Helper function to process expired lockups for an account, moving their amounts to the freed balance."",
        ""Parameters"": [""address account""],
        ""Returns"": [""AccountInfo storage""]
      },
      {
        ""Name"": ""_marketLockupFor"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic for locking funds by the foundationMarket."",
        ""Parameters"": [""address account"", ""uint256 amount""],
        ""Returns"": [""uint256 expiration""]
      },
      {
        ""Name"": ""_marketUnlockFor"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic for unlocking funds by the foundationMarket."",
        ""Parameters"": [""address account"", ""uint256 expiration"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_removeFromLockedBalance"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Helper function to remove a specified amount from a specific lockup."",
        ""Parameters"": [""address account"", ""uint256 expiration"", ""uint256 amount""],
        ""Returns"": [""AccountInfo storage""]
      },
      {
        ""Name"": ""onlyFoundationMarket"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to only the foundationMarket address."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Receives ETH deposits."",
    ""Sends ETH withdrawals using `sendValue` to user-specified addresses or the `foundationMarket` address."",
    ""Relies on the `LockedBalance` library for lockup data structure management."",
    ""The `foundationMarket` address is treated as a privileged external actor.""
  ],
  ""SpecialMechanisms"": [
    ""Time-locking of balances managed via the `LockedBalance` library and associated internal functions."",
    ""Privileged `foundationMarket` role with extensive control over user funds (locking, unlocking, withdrawing)."",
    ""Use of custom errors for reverts."",
    ""Use of `unchecked` blocks for potential gas savings in arithmetic operations."",
    ""Implements an ERC20-like interface but is not a standard token (wraps ETH, `totalSupply` is `address(this).balance`)."",
    ""Lazy freeing of expired lockups (in `_freeFromEscrow`), triggered upon user interaction."",
    ""Use of `AddressUpgradeable.sendValue` for ETH transfers.""
  ],
  ""Questions"": [
    ""What is the specific implementation and behavior of the `LockedBalance.Lockups` library, particularly regarding `get`, `set`, `del`, `setTotalAmount` and how index management (like `lockupStartIndex`) interacts with deletions?"",
    ""What are the security guarantees of the `foundationMarket` contract? Is it upgradeable? Can its address be changed post-deployment (this contract makes it immutable)? Its potential vulnerabilities directly impact FETH users."",
    ""Are all `unchecked` blocks verifiably safe from overflow/underflow under all valid operational scenarios? Specifically review `freedBalance` (uint96) additions/subtractions and loop increments."",
    ""Is the rounding behavior in expiration calculation intended: `expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval`? This sets expiration relative to the *end* of the current interval."",
    ""Why is `AddressUpgradeable` imported if the contract itself doesn't seem to follow upgradeability patterns (e.g., no initializer)? Is it solely for `sendValue` and `isContract`?"",
    ""Could `balanceOf` report a balance significantly different from immediately transferable/withdrawable balance if `_freeFromEscrow` hasn't been called recently for an account with expired lockups?"",
    ""Is there a maximum lockup duration imposed by `uint32` used for `lockupStartIndex` or potential limitations in the `LockedBalance` library?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `marketWithdrawFrom` and `marketWithdrawLocked`"",
      ""Severity"": ""High"",
      ""Description"": ""The `marketWithdrawFrom` and `marketWithdrawLocked` functions use `payable(msg.sender).sendValue(amount)` to send ETH. This can trigger a reentrancy vulnerability if the recipient contract calls back into the FETH contract before state updates are complete, potentially allowing the recipient to withdraw more ETH than intended, leading to a potential drain of contract's ETH reserves."",
      ""Impact"": ""Potential for the foundation market or a malicious contract to drain ETH from the FETH contract via reentrancy."",
      ""Location"": ""`marketWithdrawFrom` function, `marketWithdrawLocked` function""
    },
    {
      ""Issue"": ""Potential Loss of Funds Due to Incorrect msg.value Handling in `_marketLockupFor`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_marketLockupFor` function requires the user to send the exact amount of ETH. If `msg.value` is more than the `amount`, the transaction reverts, and if the user sends less than `amount` some eth would be lost. There is no functionality to send extra eth to contract, also msg.value is non-zero but less than the amount to lock up, the ether would be lost as it is not accounted for in logic."",
      ""Impact"": ""The contract may become unusable for intended usage, as the user pays too much ETH for the lockup, causing a loss of funds."",
      ""Location"": ""`_marketLockupFor` function""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow Vulnerability Risk in Balance Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses unchecked arithmetic for balance calculations with `uint96 freedBalance`, potentially leading to integer overflows or underflows if inputs are not carefully validated. This affects `depositFor`, `_marketLockupFor`, `_deductBalanceFrom`, `_freeFromEscrow`, and other functions modifying `freedBalance`."",
      ""Impact"": ""Incorrect balance calculations can allow users to withdraw more ETH than they are entitled to or lock funds indefinitely."",
      ""Location"": ""Functions `depositFor`, `_marketLockupFor`, `_deductBalanceFrom`, `_freeFromEscrow`, and potentially others where `freedBalance` is modified.""
    },
    {
      ""Issue"": ""Potential Denial of Service (DoS) in `_freeFromEscrow` due to unbounded loop"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_freeFromEscrow` function iterates through lockups until it finds one that hasn't expired, or freeing all expired escrows. If a user has a very large number of expired lockups, this loop could consume a significant amount of gas, potentially leading to a denial of service (DoS) by exceeding the block gas limit."",
      ""Impact"": ""The function could become unusable for accounts with a large number of expired lockups, preventing users from accessing their funds. The contract can become unusable for intended usage."",
      ""Location"": ""`_freeFromEscrow` function""
    },
    {
      ""Issue"": ""Incorrect Calculation of Expiration Time in `_marketLockupFor` and Potential Overflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""The expiration time is calculated using `lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval`. This rounds the `block.timestamp` up to the nearest `lockupInterval`. If `block.timestamp`, `lockupInterval`, or `lockupDuration` are sufficiently large, the intermediate or final result could overflow, leading to an earlier than expected expiration."",
      ""Impact"": ""The actual lockup duration might be slightly shorter than the intended `lockupDuration`, potentially affecting users who rely on precise lockup periods."",
      ""Location"": ""`_marketLockupFor` function, `marketChangeLockup` function""
    },
    {
      ""Issue"": ""Inconsistent State Update in `_removeFromLockedBalance` when deleting the first escrow"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_removeFromLockedBalance` function, when the escrow being removed is the first one, `accountInfo.lockupStartIndex` is incremented only if there are subsequent lockups. If there are no more lockups after removing the first one, `accountInfo.lockupStartIndex` will remain pointing to a deleted escrow, potentially corrupting the state."",
      ""Impact"": ""The `lockupStartIndex` might be invalid, causing incorrect calculation of balance or making it impossible to unlock/withdraw funds in the future."",
      ""Location"": ""Function `_removeFromLockedBalance`""
    },
    {
      ""Issue"": ""Lack of Access Control on `withdrawFrom` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `withdrawFrom` function lacks explicit checks to ensure that the `to` address is authorized to receive the withdrawal. A malicious user could potentially exploit this to withdraw funds to an unintended address, even if they have allowance for a different address."",
      ""Impact"": ""Funds can be withdrawn to unintended addresses, potentially leading to loss of funds."",
      ""Location"": ""Function `withdrawFrom`""
    },
    {
      ""Issue"": ""Inconsistent allowance handling in `transferFrom` and `withdrawFrom`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferFrom` and `withdrawFrom` functions check allowance using `_deductAllowanceFrom`. The `_deductAllowanceFrom` checks that the allowance is not `type(uint256).max` before deduction. However, there is no explicit logic or check that the allowance is set to `type(uint256).max`, which means an approved spender can\'t use the entire balance."",
      ""Impact"": ""Unexpected behavior regarding allowances might confuse users."",
      ""Location"": ""`transferFrom`, `withdrawFrom`, and `_deductAllowanceFrom` functions""
    },
    {
      ""Issue"": ""Missing Access Control on Constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor of the `FETH` contract is not protected by any access control mechanisms. An attacker could front-run the deployment and set an invalid `_foundationMarket` address or `_lockupDuration`."",
      ""Impact"": ""Contract could be deployed with incorrect parameters rendering it useless."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Possible rounding errors in `block.timestamp.ceilDiv(lockupInterval)`"",
      ""Severity"": ""Low"",
      ""Description"": ""The expiration calculation depends on `block.timestamp.ceilDiv(lockupInterval)`. While `ceilDiv` is intended to provide a rounded up result, depending on how block timestamps and the `lockupInterval` align, there might be scenarios where the result is not precise, leading to slightly shorter or longer lockup periods than intended."",
      ""Impact"": ""Lockup periods might deviate slightly from the intended duration, potentially causing minor discrepancies in unlock times."",
      ""Location"": ""`_marketLockupFor` function""
    },
    {
      ""Issue"": ""Inconsistent use of storage and memory for Lockup struct"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_freeFromEscrow` function gets `escrow` from `accountInfo.lockups` into a memory variable. It then compares the expiration against `block.timestamp` but doesn't update any values to storage within the while loop unless the lockup is expired."",
      ""Impact"": ""The inconsistency can cause confusion and increase the risk of unintended behavior if the code is modified in the future."",
      ""Location"": ""`_freeFromEscrow`, `_removeFromLockedBalance`""
    }
  ],
  ""IssueNumber"": 32,
  ""OutputList"": 11
}",188.4834532737732,3852.0,26.0,"### **Comparison and Evaluation**

---

#### **[M-03] Approve race condition in FETH**

**Report Description**:  
The `approve()` function in `FETH.sol` is vulnerable to a front-running attack, commonly known as the ""Multiple Withdrawal Attack."" This occurs when an attacker exploits the race condition between the approval and transfer of tokens. The contract lacks protection mechanisms such as reducing the spender's allowance to 0 before setting the desired value or using OpenZeppelin's `decreaseAllowance` and `increaseAllowance` functions to mitigate this issue. While the risk is limited in specific scenarios, it is worth addressing for future operations.

**Match in Response List**:  
**No match found**.  

**Validation**:  
**Incorrect**. The response list does not address the race condition vulnerability in the `approve()` function. This issue is entirely missed, and no corresponding solution or mitigation is provided. The absence of this issue in the response list represents a significant gap in coverage.

---

#### **[M-09] Missing receiver validation in withdrawFrom**

**Report Description**:  
The `withdrawFrom` function in `FETH.sol` does not validate the `to` parameter, which represents the recipient address. If `to` is the zero address, funds can be permanently lost, as the zero address is not a valid recipient for token transfers. This oversight could lead to unintended loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control on `withdrawFrom` function""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of access control in the `withdrawFrom` function but focuses on the risk of funds being withdrawn to unintended addresses rather than explicitly addressing the zero address validation. While the response partially covers the issue, it misses the critical detail of validating the `to` parameter to prevent loss of funds to the zero address.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-09] Missing receiver validation in withdrawFrom**

**Missed Issues from Issue Report**:  
- **[M-03] Approve race condition in FETH**

---

### **Conclusion**  
The response list partially addresses one of the two issues in the `issue` report but entirely misses the race condition vulnerability in the `approve()` function. The coverage of the response list is insufficient, and critical vulnerabilities remain unaddressed. Improvements are needed to ensure comprehensive identification and mitigation of all reported issues.","```
None.
```",0.0
NFTMarketFees.sol,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/**
 * @title A mixin to distribute funds when an NFT is sold.
 */
abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private _primaryFoundationFeeBasisPoints;
   * uint256 private _secondaryFoundationFeeBasisPoints;
   * uint256 private _secondaryCreatorFeeBasisPoints;
   */
  uint256[3] private __gap_was_fees;

  /// @notice Track if there has been a sale for the NFT in this market previously.
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  /// @notice The royalties sent to creator recipients on secondary sales.
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; // 10%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a primary sale.
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; // 15%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a secondary sale.
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; // 5%

  /**
   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.
   */
  // solhint-disable-next-line code-complexity
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        // Determine the total shares defined so it can be leveraged to distribute below
        uint256 totalShares;
        unchecked {
          // The array length cannot overflow 256 bits.
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              // If the numbers are >100% we ignore the fee recipients and pay just the first instead
              maxCreatorIndex = 0;
              break;
            }
            // The check above ensures totalShares wont overflow.
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        // Send payouts to each additional recipient if more than 1 was defined
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        // Send the remainder to the 1st creator, rounding in their favor
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  /**
   * @notice Returns how funds will be distributed for a sale at the given price point.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param price The sale price to calculate the fees for.
   * @return foundationFee How much will be sent to the Foundation treasury.
   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.
   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.
   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.
   * If there is only one `creatorRecipient`, this may be an empty array.
   * Otherwise `creatorShares.length` == `creatorRecipients.length`.
   * @return ownerRev How much will be sent to the owner/seller of the NFT.
   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.
   * @return owner The address of the owner of the NFT.
   * If `ownerRev` is 0, this may be `address(0)`.
   */
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  /**
   * @dev Calculates how funds should be distributed for the given sale details.
   */
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    // Calculate the Foundation fee
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        // When sold by the creator, all revenue is split if applicable.
        creatorRev = price - foundationFee;
      } else {
        // Rounding favors the owner first, then creator, and foundation last.
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      // No royalty recipients found.
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1867,219,"[M-08] Primary seller can avoid paying the primary fee

Submitted by pedroais, also found by leastwood and WatchPug
A primary seller can circumvent the 15% fee and pay 5% as a secondary seller.
Context

The Foundation protocol charges a 15% fee if the sale is a primary sale and 5% if it's a secondary sale. https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L40
There are 2 conditions that must be met for a sale to be considered primary:
The seller is one of the creators in the NFT metadata.
It's the first time this NFT is sold on the foundation protocol.
https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L188
  [M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low

Submitted by cmichel
NFTMarketFees.sol#L78
The creator payouts are capped at MAX_ROYALTY_RECIPIENTS_INDEX. It's currently set to 4 and only 5 creators are paid out. Other creators are ignored.

",2,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";


abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  
  uint256[3] private __gap_was_fees;

  
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; 
  
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; 
  
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; 

  
  
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        
        uint256 totalShares;
        unchecked {
          
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              
              maxCreatorIndex = 0;
              break;
            }
            
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        
        creatorRev = price - foundationFee;
      } else {
        
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  
  uint256[1000] private __gap;
}",1195,0,2,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Analyze `_sendValueWithFallbackWithdraw` implementation for potential reentrancy vulnerabilities. Does it follow the checks-effects-interactions pattern correctly?"",
        ""Examine the use of `unchecked` in `totalShares += creatorShares[i]` within `_distributeFunds`. While overflow seems unlikely, create test cases with extremely large or manipulated `creatorShares` to confirm it behaves as expected and doesn't lead to unexpected behavior."",
        ""Review the gas limits used in `_sendValueWithFallbackWithdraw` (`SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`, `SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS`). Ensure these are sufficient for the intended operations and that they don't open the contract to denial-of-service attacks by griefing."",
        ""Investigate potential integer overflow/underflow vulnerabilities in calculations related to `foundationFee`, `creatorFee`, and `ownerRev`. While using SafeMath is not explicitly visible, ensure protection is implemented either directly or within inherited contracts.""
      ]
    },
    {
      ""Area"": ""Compliance and Business Logic"",
      ""Tasks"": [
        ""Verify the logic within `_getFees` correctly implements the intended fee structure for primary and secondary sales. Create detailed test cases covering various scenarios, including sales by creators, sales by non-creators, and sales before and after the first sale."",
        ""Analyze the behavior of `_distributeFunds` when `creatorRecipients.length` is greater than `MAX_ROYALTY_RECIPIENTS_INDEX`. Confirm the intended truncation logic is applied and that royalties are still distributed correctly to the intended recipients (up to the limit)."",
        ""Clarify and document the precise definition of a 'primary sale' and how it is determined by `_nftContractToTokenIdToFirstSaleCompleted`. Consider scenarios where NFTs are transferred or sold outside the marketplace before being listed."",
        ""Ensure the values for `CREATOR_ROYALTY_BASIS_POINTS`, `PRIMARY_FOUNDATION_FEE_BASIS_POINTS`, and `SECONDARY_FOUNDATION_FEE_BASIS_POINTS` align with the intended business model and are clearly documented."",
        ""Investigate the interaction between `_getFees` and `_getCreatorPaymentInfo`. Specifically, how are `creatorRecipients` and `creatorShares` handled when a creator has not set up their royalty information correctly, or if the information is invalid? Does it default to a safe state?""
      ]
    },
    {
      ""Area"": ""External Interactions and Data Integrity"",
      ""Tasks"": [
        ""Audit the implementation of the inherited functions `_getCreatorPaymentInfo` and `_getSellerFor`. Verify their correctness and security, paying particular attention to how they retrieve and validate data."",
        ""Examine the interaction with the `IERC721` interface within inherited contracts (like `NFTMarketCore`). Ensure that the contract correctly handles NFTs that do not fully conform to the ERC721 standard."",
        ""Analyze the storage and retrieval of the `_nftContractToTokenIdToFirstSaleCompleted` mapping. Is it possible to manipulate or bypass this flag through external actions or vulnerabilities in other parts of the system?"",
        ""Review the error handling within `_sendValueWithFallbackWithdraw`. What happens if a transfer fails? Is the error correctly propagated, or does it lead to unexpected behavior?""
      ]
    },
    {
      ""Area"": ""Upgradeability and Storage Gaps"",
      ""Tasks"": [
        ""Confirm that the storage gaps (`__gap_was_fees`, `__gap`) are of sufficient size to accommodate future upgrades and that they are correctly positioned within the contract's storage layout."",
        ""Verify that the `Initializable` contract is correctly used and that the initialization logic prevents unintended re-initialization.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Profile the gas costs of the `_distributeFunds` and `getFeesAndRecipients` functions. Identify potential areas for optimization, such as reducing storage reads/writes or simplifying calculations."",
        ""Evaluate the gas costs associated with the multiple transfers within `_distributeFunds`, especially when distributing royalties to multiple creators. Consider batching transfers or using more gas-efficient transfer methods where appropriate.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines an abstract contract `NFTMarketFees` designed to handle the calculation and distribution of funds (fees and revenues) from NFT sales within a marketplace. It leverages OpenZeppelin's Initializable for upgradeability and inherits functionality from several other custom contracts (`Constants`, `FoundationTreasuryNode`, `NFTMarketCore`, `NFTMarketCreators`, `SendValueWithFallbackWithdraw`). Key features include differentiating fees for primary vs. secondary sales, handling creator royalties (including multiple recipients), and interacting with a foundation treasury. It uses basis points for percentage calculations and includes gaps for upgradeability."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTMarketFees"",
    ""Purpose"": ""To calculate and distribute funds (foundation fees, creator royalties, seller revenue) generated from NFT sales, differentiating between primary and secondary market transactions."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Constants"",
        ""Initializable"",
        ""FoundationTreasuryNode"",
        ""NFTMarketCore"",
        ""NFTMarketCreators"",
        ""SendValueWithFallbackWithdraw""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""./Constants.sol"",
        ""./FoundationTreasuryNode.sol"",
        ""./NFTMarketCore.sol"",
        ""./NFTMarketCreators.sol"",
        ""./SendValueWithFallbackWithdraw.sol"",
        ""@openzeppelin/contracts/token/ERC721/IERC721.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""__gap_was_fees"",
        ""Type"": ""uint256[3]"",
        ""Purpose"": ""Storage gap for upgradeability, likely related to a previous version or structure.""
      },
      {
        ""Name"": ""_nftContractToTokenIdToFirstSaleCompleted"",
        ""Type"": ""mapping(address => mapping(uint256 => bool))"",
        ""Purpose"": ""Tracks whether the first sale for a specific NFT (by contract address and token ID) has occurred through this marketplace. Used to determine fee structure (primary vs. secondary).""
      },
      {
        ""Name"": ""CREATOR_ROYALTY_BASIS_POINTS"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Defines the royalty percentage (10%) paid to creators on secondary sales, expressed in basis points (1000 / 10000).""
      },
      {
        ""Name"": ""PRIMARY_FOUNDATION_FEE_BASIS_POINTS"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Defines the foundation fee percentage (15%) for primary sales conducted by the NFT's creator, expressed in basis points (1500 / 10000).""
      },
      {
        ""Name"": ""SECONDARY_FOUNDATION_FEE_BASIS_POINTS"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Defines the foundation fee percentage (5%) for secondary sales (or primary sales by non-creators), expressed in basis points (500 / 10000).""
      },
      {
        ""Name"": ""__gap"",
        ""Type"": ""uint256[1000]"",
        ""Purpose"": ""Large storage gap reserved for future upgrades, ensuring storage layout compatibility.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""_distributeFunds"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates fees using `_getFees` and distributes the sale price to the foundation, creator(s), and the seller (owner revenue). Marks the sale as completed for fee purposes."",
        ""Parameters"": [
          ""address nftContract"",
          ""uint256 tokenId"",
          ""address payable seller"",
          ""uint256 price""
        ],
        ""Returns"": [
          ""uint256 foundationFee"",
          ""uint256 creatorFee"",
          ""uint256 ownerRev""
        ]
      },
      {
        ""Name"": ""getFeesAndRecipients"",
        ""Visibility"": ""external"",
        ""Purpose"": ""A view function to publicly query the expected fee breakdown and recipient addresses for a potential sale without executing it."",
        ""Parameters"": [
          ""address nftContract"",
          ""uint256 tokenId"",
          ""uint256 price""
        ],
        ""Returns"": [
          ""uint256 foundationFee"",
          ""uint256 creatorRev"",
          ""address payable[] memory creatorRecipients"",
          ""uint256[] memory creatorShares"",
          ""uint256 ownerRev"",
          ""address payable owner""
        ]
      },
      {
        ""Name"": ""_getFees"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Core logic for calculating foundation fees, creator royalties, and owner revenue based on whether the sale is primary/secondary and if the seller is a creator. Retrieves creator payment info from an inherited function."",
        ""Parameters"": [
          ""address nftContract"",
          ""uint256 tokenId"",
          ""address payable seller"",
          ""uint256 price""
        ],
        ""Returns"": [
          ""uint256 foundationFee"",
          ""address payable[] memory creatorRecipients"",
          ""uint256[] memory creatorShares"",
          ""uint256 creatorRev"",
          ""address payable ownerRevTo"",
          ""uint256 ownerRev""
        ]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Inherited function `_getCreatorPaymentInfo` (from `NFTMarketCreators`) likely interacts with stored creator data."",
    ""Inherited function `_getSellerFor` (from `NFTMarketCore`) likely interacts with market listing data."",
    ""Inherited function `getFoundationTreasury` (from `FoundationTreasuryNode`) retrieves the treasury address."",
    ""Inherited function `_sendValueWithFallbackWithdraw` (from `SendValueWithFallbackWithdraw`) is used to send Ether to external addresses (foundation, creators, seller), potentially interacting with recipient contracts."",
    ""The contract logic assumes interaction with various NFT contracts (address `nftContract`), likely via `IERC721` interface used in inherited contracts like `NFTMarketCore`.""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract Design: Uses `Initializable` and storage gaps (`__gap*`) common in proxy patterns."",
    ""Basis Points Calculation: Uses fixed basis points (1/100th of a percent) for fee calculations."",
    ""Primary vs. Secondary Sale Logic: Differentiates fee structures based on the `_nftContractToTokenIdToFirstSaleCompleted` mapping and whether the seller is a creator."",
    ""Multiple Creator Royalty Distribution: Handles splitting creator royalties among multiple recipients based on predefined shares, with logic to cap recipients and handle share distribution."",
    ""Safe Ether Transfer Pattern: Utilizes `_sendValueWithFallbackWithdraw`, suggesting a mechanism to handle potential Ether transfer failures more gracefully than a simple `.transfer` or `.send`.""
  ],
  ""Questions"": [
    ""What is the specific implementation and behavior of the inherited `_sendValueWithFallbackWithdraw` function? How does it handle transfer failures and gas limits?"",
    ""How are `creatorRecipients` and `creatorShares` determined by the inherited `_getCreatorPaymentInfo` function? Is the share validation (`creatorShares[i] > BASIS_POINTS`) sufficient?"",
    ""Where is `MAX_ROYALTY_RECIPIENTS_INDEX` defined (presumably in `Constants`) and what is its value? Why is this cap necessary (likely gas limitations)?"",
    ""What is the exact logic within `_getSellerFor` (from `NFTMarketCore`)? Is the seller always the `ownerOf(tokenId)` or derived from specific market listing data?"",
    ""Is the use of `unchecked` for `totalShares += creatorShares[i]` safe? While overflow seems unlikely given basis points, are there edge cases?"",
    ""How is atomicity handled if one of the `_sendValueWithFallbackWithdraw` calls fails mid-distribution? Does the entire transaction revert, or does the fallback mechanism have implications?"",
    ""If a creator transfers their NFT to a collector *before* the first sale on this market, and the collector then lists it, will it be treated as a primary sale (15% fee) or secondary sale (5% fee) based on the `isCreator` check in `_getFees`?"",
    ""What prevents the `_nftContractToTokenIdToFirstSaleCompleted` flag from being manipulated or bypassed if sales occur outside this specific marketplace contract?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in _distributeFunds"",
      ""Severity"": ""High"",
      ""Description"": ""The `_distributeFunds` function sends Ether to multiple recipients using `_sendValueWithFallbackWithdraw`. Malicious recipient contracts could re-enter `_distributeFunds` before the transaction completes, potentially manipulating state variables, draining funds, or causing denial of service. Reentrancy guards are needed in both `_distributeFunds` and `_sendValueWithFallbackWithdraw`."",
      ""Impact"": ""Loss of funds, unexpected state changes, denial of service, and incorrect fee distribution."",
      ""Location"": ""_distributeFunds function, _sendValueWithFallbackWithdraw""
    },
    {
      ""Issue"": ""Gas Limit Issues in `_sendValueWithFallbackWithdraw` calls"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_distributeFunds` function uses different gas limits for single and multiple recipients within the `_sendValueWithFallbackWithdraw` calls (SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT and SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS). If gas limits are insufficient, especially when distributing to multiple creator recipients, transactions could revert, blocking withdrawals and causing sales to fail. Hardcoding gas limits might not be future-proof."",
      ""Impact"": ""Insufficient gas limits can cause transactions to fail, preventing legitimate recipients from receiving their funds, disrupting the market's operation and sales."",
      ""Location"": ""_distributeFunds function, calls to _sendValueWithFallbackWithdraw, _sendValueWithFallbackWithdraw""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Royalty Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Calculations involving royalty distribution, such as `(creatorFee * creatorShares[i]) / totalShares` and fee calculation such as `(price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS` and `(price * fee) / BASIS_POINTS`, could lead to unexpected behavior due to potential integer overflow or underflow if input values (`creatorFee`, `creatorShares[i]`, `price`) are sufficiently large, even with Solidity's built-in protection. If the totalShares becomes very large in `_distributeFunds`, while the multiplication by `creatorShares[i]` and subsequent division by totalShares is handled inside of `unchecked`, the result could still lead to unexpected behavior if the numbers are not properly constrained. Furthermore, although the code uses `unchecked` block, it can lead to unpredictable calculation results if `totalShares` becomes incorrect due to an overflow, specifically affecting the `share` calculation."",
      ""Impact"": ""Incorrect royalty distribution, potentially leading to recipients receiving incorrect amounts or financial loss. Incorrect fee distribution, potential loss of precision."",
      ""Location"": ""NFTMarketFees.sol:_distributeFunds, _getFees function, _distributeFunds, royalty calculation logic""
    },
    {
      ""Issue"": ""Potential Division by Zero in Royalty Distribution"",
      ""Severity"": ""Medium"",
      ""Description"": ""If `totalShares` is zero in the `_distributeFunds` function, the division `(creatorFee * creatorShares[i]) / totalShares` will cause a division by zero error.  While the code attempts to prevent this, it might not always be effective."",
      ""Impact"": ""Transaction failure during royalty distribution, preventing creators from receiving their payments. This is a denial-of-service vulnerability."",
      ""Location"": ""NFTMarketFees.sol:_distributeFunds""
    },
    {
      ""Issue"": ""Incorrect Royalty Distribution Logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""The code iterates from `i = 1` to `maxCreatorIndex` in `_distributeFunds`, distributing royalties, the first recipient (index 0) receives the remaining amount.  It seems like it\'s implicitly assuming creatorRecipients[0] is the main recipient and distributing the remainder to them, which could be an incorrect assumption if the first recipient is not intended to receive the remainder. In the `_distributeFunds` function, inside the royalties distribution loop, if `creatorShares[i]` is greater than `BASIS_POINTS`, the `maxCreatorIndex` is set to 0 which means no one except the creatorRecipients[0] will get the royalty payment. Also, there might be some tokens left undistributed due to integer division truncation."",
      ""Impact"": ""Incorrect royalty distribution and denial of service to intended recipients. The remainder might be sent to unintended accounts."",
      ""Location"": ""_distributeFunds function""
    },
    {
      ""Issue"": ""Missing Input Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks input validation for critical parameters like `price` and the NFT contract address. A zero price could lead to unexpected behavior. If the passed address is not a contract the calls to it will fail and cause the transaction to revert."",
      ""Impact"": ""Unexpected behavior, potentially exploitable vulnerabilities. Transaction reverts when interacting with invalid NFT contracts."",
      ""Location"": ""_distributeFunds, _getFees, getFeesAndRecipients, NFTMarketFees.sol:_distributeFunds""
    },
    {
      ""Issue"": ""Incorrect Logic for Determining Primary vs Secondary Sale"",
      ""Severity"": ""Medium"",
      ""Description"": ""The logic determining if a sale is the primary sale relies on `_nftContractToTokenIdToFirstSaleCompleted`. However, if for any reason this value is not properly set after the first sale, subsequent sales might incorrectly be treated as primary sales, leading to the wrong foundation fee being applied. A primary sale benefits the creator by sending the full sale price (minus foundation fee) to the creator. Subsequent sales provide the creator a royalty. If the primary sale calculation is used inappropriately, the creator could be getting far more funds than anticipated."",
      ""Impact"": ""Incorrect calculation of primary and secondary sales leading to either a higher or lower fee for the foundation, and either higher or lower royalty for the creator."",
      ""Location"": ""_getFees function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getFeesAndRecipients` function calculates fees based on the current state. A front-runner could observe these calculated fees and adjust their transaction to exploit the fee structure. If the fee percentages or recipient addresses are adjustable, an attacker could monitor the mempool for transactions that change these values and then front-run those transactions with their own transaction to exploit the window where the old fees/recipients are still in effect."",
      ""Impact"": ""A front-runner could potentially manipulate the price or timing of their transaction to take advantage of the calculated fee distribution, potentially gaining a small advantage at the expense of other users. Loss of Revenue, Unfair distribution of funds."",
      ""Location"": ""getFeesAndRecipients function, Functions related to fee management""
    },
    {
      ""Issue"": ""Unbounded Loop in Creator Shares can cause unexpected behavior"",
      ""Severity"": ""Low"",
      ""Description"": ""The for loop `for (uint256 i = 0; i <= maxCreatorIndex; ++i)` in the `_distributeFunds` function uses the `<=` operator and increments `i` in each loop. If the value of `maxCreatorIndex` is close to the maximum value of `uint256` the addition can cause an overflow and revert or perform unexpectedly"",
      ""Impact"": ""Transaction can revert or loop infinitely"",
      ""Location"": ""NFTMarketFees.sol:_distributeFunds""
    },
    {
      ""Issue"": ""Inconsistent use of `basis points` and hardcoded values"",
      ""Severity"": ""Low"",
      ""Description"": ""The code uses `CREATOR_ROYALTY_BASIS_POINTS`, `PRIMARY_FOUNDATION_FEE_BASIS_POINTS`, and `SECONDARY_FOUNDATION_FEE_BASIS_POINTS` which are defined as constants. These are percentages represented in basis points (out of `BASIS_POINTS`). The code should ensure consistency in how these values are used in calculations. Also, verify these hardcoded values are aligned with desired business logic and are configurable."",
      ""Impact"": ""Incorrect Fee Calculations, potentially affecting revenue."",
      ""Location"": ""Throughout the contract, where fee calculations are performed""
    },
    {
      ""Issue"": ""Unnecessary setting of `maxCreatorIndex` to `0`"",
      ""Severity"": ""Info"",
      ""Description"": ""The code sets `maxCreatorIndex = 0` if `creatorShares[i] > BASIS_POINTS`. However, `creatorShares[i]` is an unsigned integer and cannot be less than 0, and according to the Constants.sol contract BASIS_POINTS is equivalent to 10000 which is greater than 1000, so creatorShares can never be greater than BASIS_POINTS, and this check is unnecessary."",
      ""Impact"": ""The code can be simplified by removing unnecessary checks"",
      ""Location"": ""NFTMarketFees.sol:_distributeFunds""
    }
  ],
  ""IssueNumber"": 30,
  ""OutputList"": 11
}",150.54232001304626,9268.0,23.0,"### **[M-08] Primary seller can avoid paying the primary fee**

**Report Description**:
The Foundation protocol charges a 15% fee for primary sales and a 5% fee for secondary sales. A primary seller can circumvent the 15% fee and pay only 5% by manipulating the conditions that determine whether a sale is primary or secondary. Specifically, the conditions are:
1. The seller must be one of the creators in the NFT metadata.
2. It must be the first time the NFT is sold on the Foundation protocol.
If these conditions are not properly enforced, a primary seller could exploit this loophole to avoid paying the higher fee.

**Match in Response List**:
Matches with the issue titled **""Incorrect Logic for Determining Primary vs Secondary Sale""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the logic determining primary and secondary sales. It correctly explains the risks associated with incorrect fee calculations due to improper enforcement of the conditions for primary sales. This aligns with the reported issue where a primary seller can avoid paying the higher fee by manipulating these conditions.

### **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

**Report Description**:
The `MAX_ROYALTY_RECIPIENTS_INDEX` is set to 4, which means only 5 creators can be paid out. Any additional creators beyond this limit are ignored. This could lead to unfair distribution of royalties and potential disputes among creators.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address the issue of `MAX_ROYALTY_RECIPIENTS_INDEX` being set too low, which could lead to creators being unfairly excluded from royalty distributions.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-08] Primary seller can avoid paying the primary fee**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-11] `MAX_ROYALTY_RECIPIENTS_INDEX` set too low**

---","```
1. Incorrect Logic for Determining Primary vs Secondary Sale
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Incorrect Logic for Determining Primary vs Secondary Sale"".
   - This issue appears at rank 7 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 7 (\( P@7 \)) is calculated as the number of true positives up to rank 7 divided by 7.
   - Since there is only one true positive up to rank 7, \( P@7 = \frac{1}{7} \approx 0.1429 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the AP is simply the precision at rank 7.

**Average Precision (AP)**: 0.1429"
