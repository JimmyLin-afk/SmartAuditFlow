nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
FlashGovernanceArbiter.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""./Governable.sol"";
import ""hardhat/console.sol"";
import ""../facades/Burnable.sol"";

///@title Flash Governance Arbiter
///@author Justin Goro
/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.
 * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.
 * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.
 * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed
 * By default, the asset is EYE.
 */
contract FlashGovernanceArbiter is Governable {
  /**
   * @param actor user making flash governance decision
   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.
   * @param amount is the amount of the deposit_asset to be put up as decision collateral.
   * @param target is the contract that will be affected by the flash governance decision.
   */
  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);

  mapping(address => bool) enforceLimitsActive;

  constructor(address dao) Governable(dao) {}

  struct FlashGovernanceConfig {
    address asset;
    uint256 amount;
    uint256 unlockTime;
    bool assetBurnable;
  }

  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.
  struct SecurityParameters {
    uint8 maxGovernanceChangePerEpoch; //prevents flash governance from wrecking the incentives.
    uint256 epochSize; //only one flash governance action can happen per epoch to prevent governance DOS
    uint256 lastFlashGovernanceAct;
    uint8 changeTolerance; //1-100 maximum percentage any numeric variable can be changed through flash gov
  }

  //the current parameters determining the rules of flash governance
  FlashGovernanceConfig public flashGovernanceConfig;
  SecurityParameters public security;

  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules
   *without undermining the terms under which pending decisions were made.
   */
  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config

  /**
   *@notice An attempt is made to withdraw the current deposit requirement.
   * For a given user, flash governance decisions can only happen one at a time
   *@param sender is the user making the flash governance decision
   *@param target is the contract that will be affected by the flash governance decision.
   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.
   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.
   */
  function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
    if (
      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&
      pendingFlashDecision[target][sender].unlockTime < block.timestamp
    ) {
      require(
        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),
        ""Limbo: flash governance disabled for rest of epoch""
      );
      pendingFlashDecision[target][sender] = flashGovernanceConfig;
      pendingFlashDecision[target][sender].unlockTime += block.timestamp;

      security.lastFlashGovernanceAct = block.timestamp;
      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);
    } else {
      revert(""LIMBO: governance decision rejected."");
    }
  }

  /**
   *@param asset is the asset type put up as decision collateral. Must be burnable.
   *@param amount is the amount of the deposit_asset to be put up as decision collateral.
   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision
   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.
   */
  function configureFlashGovernance(
    address asset,
    uint256 amount,
    uint256 unlockTime,
    bool assetBurnable
  ) public virtual onlySuccessfulProposal {
    flashGovernanceConfig.asset = asset;
    flashGovernanceConfig.amount = amount;
    flashGovernanceConfig.unlockTime = unlockTime;
    flashGovernanceConfig.assetBurnable = assetBurnable;
  }

  /**
    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS
    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations
    @param changeTolerance is the amount by which a variable can be changed through flash governance.
    */
  function configureSecurityParameters(
    uint8 maxGovernanceChangePerEpoch,
    uint256 epochSize,
    uint8 changeTolerance
  ) public virtual onlySuccessfulProposal {
    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;
    security.epochSize = epochSize;
    require(security.changeTolerance < 100, ""Limbo: % between 0 and 100"");
    security.changeTolerance = changeTolerance;
  }

  /**
    @notice LimboDAO proposals for burning flash governance collateral act through this function
    @param targetContract is the contract that is affected by the flash governance decision.
    @param user is the user who made the flash governance decision
    @param asset is the collateral asset to be burnt
    @param amount is the amount of the collateral to be burnt
    */
  function burnFlashGovernanceAsset(
    address targetContract,
    address user,
    address asset,
    uint256 amount
  ) public virtual onlySuccessfulProposal {
    if (pendingFlashDecision[targetContract][user].assetBurnable) {
      Burnable(asset).burn(amount);
    }

    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
  }

  /**
   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset
   *@param targetContract is the contract that is affected by the flash governance decision.
   *@param asset is the collateral asset to be withdrawn
   */
  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
    require(
      pendingFlashDecision[targetContract][msg.sender].asset == asset &&
        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
      ""Limbo: Flashgovernance decision pending.""
    );
    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
      msg.sender,
      pendingFlashDecision[targetContract][msg.sender].amount
    );
    delete pendingFlashDecision[targetContract][msg.sender];
  }

  /**
   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance
   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.
   * @param enforce for the given context, set whether variable movement limits are enforced or not.
   */
  function setEnforcement(bool enforce) public {
    enforceLimitsActive[msg.sender] = enforce;
  }

  ///@dev for negative values, relative comparisons need to be calculated correctly.
  function enforceToleranceInt(int256 v1, int256 v2) public view {
    if (!configured) return;
    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);
    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);
    enforceTolerance(uv1, uv2);
  }

  ///@notice Allows functions to enforce maximum limits on a per variable basis
  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.
  function enforceTolerance(uint256 v1, uint256 v2) public view {
    if (!configured || !enforceLimitsActive[msg.sender]) return;
    //bonus points for readability
    if (v1 > v2) {
      if (v2 == 0) require(v1 <= 1, ""FE1"");
      else require(((v1 - v2) * 100) < security.changeTolerance * v1, ""FE1"");
    } else {
      if (v1 == 0) require(v2 <= 1, ""FE1"");
      else require(((v2 - v1) * 100) < security.changeTolerance * v1, ""FE1"");
    }
  }
}",1924,186,"[H-01] Lack of access control on assertGovernanceApproved can cause funds to be locked

Submitted by shw, also found by kirk-baird and pauliax
Lack of access control on the `assertGovernanceApproved` function of FlashGovernanceArbiter allows anyone to lock other users' funds in the contract as long as the users have approved the contract to transfer flashGovernanceConfig.amount of flashGovernanceConfig.asset from them.
Proof of Concept

Alice wants to execute a flash governance decision (e.g., disable to the protocol), so she first calls approve on the flashGovernanceConfig.asset to allow FlashGovernanceArbiter to transfer flashGovernanceConfig.amount of assets from her.
An attacker Bob, who listens to the mempool, notices Alice's approve transaction and decides to front-run it. He calls assertGovernanceApproved with sender being Alice, target being any address, and emergency being true.
As a result, Alice cannot execute her flash governance decision, and her funds are locked in the contract for the flashGovernanceConfig.unlockTime period.
Referenced code: DAO/FlashGovernanceArbiter.sol#L60-L81
  [H-04] Logic error in burnFlashGovernanceAsset can cause locked assets to be stolen

Submitted by shw
A logic error in the `burnFlashGovernanceAsset` function that resets a user's pendingFlashDecision allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.
Proof of Concept

An attacker Alice executes a malicious flash governance decision, and her assets are locked in the FlashGovernanceArbiter contract.
The community disagrees with Alice's flash governance decision and calls burnFlashGovernanceAsset to burn her locked assets. However, the burnFlashGovernanceAsset function resets Alice's pendingFlashDecision to the default config (see line 134).
A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.
Now, Alice calls withdrawGovernanceAsset to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's pendingFlashDecision is reset to the default, the unlockTime < block.timestamp condition is fulfilled, and the withdrawal succeeds.
  [H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request

Submitted by kirk-baird
Users who have not called `withdrawGovernanceAsset()` after they have locked their tokens from a previous proposal (i.e. assertGovernanceApproved), will lose their tokens if assertGovernanceApproved() is called again with the same target and sender.
The sender will lose pendingFlashDecision[target][sender].amount tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.
The impact of this is worsened by another vulnerability, that is assertGovernanceApproved() is a public function and may be called by any arbitrary user so long as the sender field has called approve() for FlashGovernanceArbiter on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary sender.

[M-01] Incorrect unlockTime can DOS withdrawGovernanceAsset

Submitted by csanuragjain
unlockTime is set incorrectly.
Proof of Concept

Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol
Observe the assertGovernanceApproved function ```
function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
...
pendingFlashDecision[target][sender].unlockTime += block.timestamp;
...
}
```  [M-02] Reentrancy on Flash Governance Proposal Withdrawal

Submitted by kirk-baird
The function withdrawGovernanceAsset() is vulnerable to reentrancy, which would allow the attacker to drain the balance of the flashGoverananceConfig.asset.
Note: this attack assumes the attacker may gain control of the execution flow in asset.tranfer() which is the case for many ERC20 tokens such as those that implement ERC777 but will depend on which asset is chosen in the configuration.
  [M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance

Submitted by kirk-baird
The proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.
Proof of Concept

The function burnFlashGovernanceAsset() will simply overwrite the user's state with pendingFlashDecision[targetContract][user] = flashGovernanceConfig; as seen below.
function burnFlashGovernanceAsset(
  address targetContract,
  address user,
  address asset,
  uint256 amount
) public virtual onlySuccessfulProposal {
  if (pendingFlashDecision[targetContract][user].assetBurnable) {
    Burnable(asset).burn(amount);
  }

  pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
}
",6,,"pragma solidity 0.8.4;
import ""./Governable.sol"";
import ""hardhat/console.sol"";
import ""../facades/Burnable.sol"";




contract FlashGovernanceArbiter is Governable {
  
  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);

  mapping(address => bool) enforceLimitsActive;

  constructor(address dao) Governable(dao) {}

  struct FlashGovernanceConfig {
    address asset;
    uint256 amount;
    uint256 unlockTime;
    bool assetBurnable;
  }

  
  struct SecurityParameters {
    uint8 maxGovernanceChangePerEpoch; 
    uint256 epochSize; 
    uint256 lastFlashGovernanceAct;
    uint8 changeTolerance; 
  }

  
  FlashGovernanceConfig public flashGovernanceConfig;
  SecurityParameters public security;

  
  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; 

  
  function assertGovernanceApproved(
    address sender,
    address target,
    bool emergency
  ) public {
    if (
      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&
      pendingFlashDecision[target][sender].unlockTime < block.timestamp
    ) {
      require(
        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),
        ""Limbo: flash governance disabled for rest of epoch""
      );
      pendingFlashDecision[target][sender] = flashGovernanceConfig;
      pendingFlashDecision[target][sender].unlockTime += block.timestamp;

      security.lastFlashGovernanceAct = block.timestamp;
      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);
    } else {
      revert(""LIMBO: governance decision rejected."");
    }
  }

  
  function configureFlashGovernance(
    address asset,
    uint256 amount,
    uint256 unlockTime,
    bool assetBurnable
  ) public virtual onlySuccessfulProposal {
    flashGovernanceConfig.asset = asset;
    flashGovernanceConfig.amount = amount;
    flashGovernanceConfig.unlockTime = unlockTime;
    flashGovernanceConfig.assetBurnable = assetBurnable;
  }

  
  function configureSecurityParameters(
    uint8 maxGovernanceChangePerEpoch,
    uint256 epochSize,
    uint8 changeTolerance
  ) public virtual onlySuccessfulProposal {
    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;
    security.epochSize = epochSize;
    require(security.changeTolerance < 100, ""Limbo: % between 0 and 100"");
    security.changeTolerance = changeTolerance;
  }

  
  function burnFlashGovernanceAsset(
    address targetContract,
    address user,
    address asset,
    uint256 amount
  ) public virtual onlySuccessfulProposal {
    if (pendingFlashDecision[targetContract][user].assetBurnable) {
      Burnable(asset).burn(amount);
    }

    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;
  }

  
  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
    require(
      pendingFlashDecision[targetContract][msg.sender].asset == asset &&
        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
      ""Limbo: Flashgovernance decision pending.""
    );
    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
      msg.sender,
      pendingFlashDecision[targetContract][msg.sender].amount
    );
    delete pendingFlashDecision[targetContract][msg.sender];
  }

  
  function setEnforcement(bool enforce) public {
    enforceLimitsActive[msg.sender] = enforce;
  }

  
  function enforceToleranceInt(int256 v1, int256 v2) public view {
    if (!configured) return;
    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);
    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);
    enforceTolerance(uv1, uv2);
  }

  
  
  function enforceTolerance(uint256 v1, uint256 v2) public view {
    if (!configured || !enforceLimitsActive[msg.sender]) return;
    
    if (v1 > v2) {
      if (v2 == 0) require(v1 <= 1, ""FE1"");
      else require(((v1 - v2) * 100) < security.changeTolerance * v1, ""FE1"");
    } else {
      if (v1 == 0) require(v2 <= 1, ""FE1"");
      else require(((v2 - v1) * 100) < security.changeTolerance * v1, ""FE1"");
    }
  }
}",1017,3,3,"{
  ""task_list"": [
    {
      ""Area"": ""Flash Governance Logic and Access Control"",
      ""Tasks"": [
        ""Verify the intended behavior of `assertGovernanceApproved`, particularly the requirement for a prior expired decision before a new one can be made. Confirm if this is a bug or intentional design."",
        ""Analyze the calculation of `pendingFlashDecision[target][sender].unlockTime` in `assertGovernanceApproved`. Ensure it correctly adds the unlock duration to the current timestamp and doesn't unintentionally accumulate over multiple approvals. Consider potential integer overflow."",
        ""Investigate the intended state of `pendingFlashDecision[targetContract][user]` after `burnFlashGovernanceAsset`. Determine why it's reset to the current `flashGovernanceConfig` instead of being deleted, and if this could lead to unexpected behavior or vulnerabilities."",
        ""Confirm that the `onlySuccessfulProposal` modifier inherited from `Governable.sol` is implemented correctly and provides adequate access control for critical functions like `configureFlashGovernance`, `configureSecurityParameters`, and `burnFlashGovernanceAsset`."",
        ""Analyze the potential impact of manipulating the `emergency` flag in `assertGovernanceApproved`. Can a malicious actor bypass the epoch-based rate limiting by setting this flag to `true`?"",
        ""Examine potential race conditions in `assertGovernanceApproved` where multiple actors attempt to deposit and assert governance simultaneously. Can this lead to unintended consequences or denial-of-service?"",
        ""Analyze the vulnerability in `withdrawGovernanceAsset` if the asset is a deflationary token. If the token reduces in balance during the time it is held by the contract, the withdrawer may not be able to withdraw what they initially deposited."",
        ""In `burnFlashGovernanceAsset`, verify that the `Burnable(asset).burn(amount)` call behaves as expected and doesn't introduce unintended side effects or vulnerabilities. Consider access control vulnerabilities within the `Burnable` contract.""
      ]
    },
    {
      ""Area"": ""Rate Limiting and Security Parameters"",
      ""Tasks"": [
        ""Evaluate the effectiveness of the rate limiting mechanism implemented using `epochSize` and `lastFlashGovernanceAct`. Determine if it provides sufficient protection against rapid governance changes."",
        ""Analyze the potential for denial-of-service attacks by repeatedly triggering flash governance actions near the end of an epoch, effectively blocking legitimate actions."",
        ""Review the validation logic for `security.changeTolerance` in `configureSecurityParameters`. Ensure it prevents invalid or nonsensical values (e.g., values greater than 100) and that the error message 'Limbo: % between 0 and 100' is clear and informative."",
        ""Assess the impact of different `epochSize` values on the responsiveness and security of the flash governance system. Determine if there are optimal ranges for this parameter.""
      ]
    },
    {
      ""Area"": ""Tolerance Enforcement and Arithmetic Errors"",
      ""Tasks"": [
        ""Locate the definition and initialization of the `configured` state variable. Confirm that it is set appropriately to enable tolerance enforcement. If not present in `FlashGovernanceArbiter`, check in the base contracts."",
        ""Verify the logic in `enforceTolerance` for potential arithmetic errors (e.g., division by zero) when either `v1` or `v2` is zero. Ensure the current implementation correctly handles these cases."",
        ""Analyze the use of `v1` as the denominator in both branches of the `enforceTolerance` comparison. Confirm that this is the intended behavior and doesn't introduce bias or inaccuracies in the tolerance check. Consider using the average of `v1` and `v2` or the maximum of `v1` and `v2` as the denominator."",
        ""Investigate the potential for integer overflows or underflows in the calculations within `enforceTolerance`, especially when `v1` and `v2` are large or small values."",
        ""Determine the intended callers of `enforceTolerance` and `enforceToleranceInt`. Verify that these functions are being used as designed and that the `enforceLimitsActive` mapping is being managed correctly."",
        ""Assess the potential for bypassing the tolerance check by setting `enforceLimitsActive[msg.sender]` to `false`. Determine if this is a desirable feature or a potential vulnerability.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of frequently used functions, particularly `assertGovernanceApproved` and `withdrawGovernanceAsset`. Identify potential areas for optimization, such as reducing storage writes or using more gas-efficient data structures."",
        ""Evaluate the cost of repeated access to state variables within functions. Consider caching frequently accessed variables in local variables to reduce gas costs."",
        ""Consider using calldata instead of memory for function arguments that are not modified within the function to save gas."",
        ""Review the order of conditional statements in `assertGovernanceApproved` to prioritize less expensive checks and potentially short-circuit execution.""
      ]
    },
    {
      ""Area"": ""External Interactions and Dependencies"",
      ""Tasks"": [
        ""Thoroughly review the `Governable.sol`, `Burnable.sol` contracts and `IERC20` interface to understand their functionality and potential vulnerabilities. Conduct separate audits of these contracts if necessary."",
        ""Analyze the risks associated with interacting with external token contracts via the `IERC20` interface. Ensure that the contract is resistant to malicious or faulty token implementations."",
         ""Verify that the addresses of the external contracts (token, Burnable) are properly validated before being used to prevent attacks using rogue contracts."",
        ""Remove or comment out the `hardhat/console.sol` import before deploying to production to avoid unnecessary gas costs and potential security risks.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `FlashGovernanceArbiter` appears to act as a mediator for a 'flash governance' mechanism. It allows users to deposit a specific token amount to gain temporary approval rights for actions related to a target contract. This process is governed by global configuration set by a DAO (via the `Governable` inheritance) and includes security parameters like rate limiting (epoch size) and optional tolerance checks for value changes. Users can later withdraw their deposit after an unlock period, or the DAO can potentially burn the deposited asset."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""FlashGovernanceArbiter"",
    ""Purpose"": ""To arbitrate and manage temporary governance approvals ('flash governance') based on token deposits, subject to configurable rules, rate limits, and security parameters."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Governable""
      ],
      ""Imports"": [
        ""./Governable.sol"",
        ""hardhat/console.sol"",
        ""../facades/Burnable.sol"",
        ""IERC20 (implicitly via usage)""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""enforceLimitsActive"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks whether tolerance limit enforcement is active for calls originating from a specific address.""
      },
      {
        ""Name"": ""flashGovernanceConfig"",
        ""Type"": ""FlashGovernanceConfig (struct)"",
        ""Purpose"": ""Holds the global configuration for flash governance deposits (asset address, required amount, unlock duration, burnable status).""
      },
      {
        ""Name"": ""security"",
        ""Type"": ""SecurityParameters (struct)"",
        ""Purpose"": ""Holds security-related parameters like rate limits (max changes per epoch, epoch size) and tolerance thresholds.""
      },
      {
        ""Name"": ""pendingFlashDecision"",
        ""Type"": ""mapping(address => mapping(address => FlashGovernanceConfig))"",
        ""Purpose"": ""Stores details of active/pending flash governance decisions, indexed by target contract address and the initiating user address. Holds a snapshot of the config + the calculated unlock time.""
      },
      {
        ""Name"": ""dao"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the DAO or governing body (inherited from Governable).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract by setting the DAO address via the Governable parent contract."",
        ""Parameters"": [""address dao""],
        ""Returns"": []
      },
      {
        ""Name"": ""assertGovernanceApproved"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows a sender to assert governance approval for a target contract by depositing the configured asset amount. Enforces rate limits and unlock time checks."",
        ""Parameters"": [""address sender"", ""address target"", ""bool emergency""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureFlashGovernance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the global configuration for flash governance deposits (asset, amount, unlock time, burnable flag). Restricted by `onlySuccessfulProposal`."",
        ""Parameters"": [""address asset"", ""uint256 amount"", ""uint256 unlockTime"", ""bool assetBurnable""],
        ""Returns"": []
      },
      {
        ""Name"": ""configureSecurityParameters"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the security parameters (rate limits, tolerance). Restricted by `onlySuccessfulProposal`."",
        ""Parameters"": [""uint8 maxGovernanceChangePerEpoch"", ""uint256 epochSize"", ""uint8 changeTolerance""],
        ""Returns"": []
      },
      {
        ""Name"": ""burnFlashGovernanceAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the DAO (via `onlySuccessfulProposal`) to burn the deposited asset for a specific pending decision, if configured as burnable."",
        ""Parameters"": [""address targetContract"", ""address user"", ""address asset"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawGovernanceAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the original depositor (`msg.sender`) to withdraw their deposited asset after the unlock time has passed."",
        ""Parameters"": [""address targetContract"", ""address asset""],
        ""Returns"": []
      },
      {
        ""Name"": ""setEnforcement"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows any address (`msg.sender`) to enable or disable tolerance limit enforcement for subsequent calls to `enforceTolerance` made by them."",
        ""Parameters"": [""bool enforce""],
        ""Returns"": []
      },
      {
        ""Name"": ""enforceToleranceInt"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Helper function to enforce tolerance checks for signed integer values by converting them to unsigned."",
        ""Parameters"": [""int256 v1"", ""int256 v2""],
        ""Returns"": []
      },
      {
        ""Name"": ""enforceTolerance"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Enforces a tolerance check between two unsigned integer values (v1, v2), based on the configured `security.changeTolerance`. Only active if `enforceLimitsActive[msg.sender]` is true and the contract is 'configured'."",
        ""Parameters"": [""uint256 v1"", ""uint256 v2""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlySuccessfulProposal"",
        ""Visibility"": ""internal/external (modifier, assumed from Governable)"",
        ""Purpose"": ""Restricts access to functions to only successful DAO proposals (implementation assumed within Governable.sol)."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 Interface: Calls `transferFrom` (in `assertGovernanceApproved`) and `transfer` (in `withdrawGovernanceAsset`) on external token contracts."",
    ""Burnable Interface/Facade: Calls `burn` (in `burnFlashGovernanceAsset`) on an external contract implementing the Burnable interface."",
    ""Governable Contract: Inherits state (e.g., `dao`) and modifiers (e.g., `onlySuccessfulProposal`).""
  ],
  ""SpecialMechanisms"": [
    ""Flash Governance: A pattern where depositing assets grants temporary rights or approval, which can be revoked or reclaimed later."",
    ""Rate Limiting: Uses `epochSize` and `lastFlashGovernanceAct` to limit the frequency of governance actions."",
    ""Configurable Tolerance Check: Provides functions (`enforceTolerance`, `enforceToleranceInt`) to check if the difference between two values is within a percentage tolerance, activated optionally per caller via `setEnforcement`."",
    ""DAO Configuration: Key parameters are configurable only by the DAO via functions protected by `onlySuccessfulProposal`.""
  ],
  ""Questions"": [
    ""In `assertGovernanceApproved`, what is the purpose of checking `pendingFlashDecision[target][sender].unlockTime < block.timestamp` *before* setting the new decision? This seems counter-intuitive, suggesting a previous decision must have expired."",
    ""In `assertGovernanceApproved`, why is the new unlock time calculated as `pendingFlashDecision[target][sender].unlockTime += block.timestamp`? Shouldn't it be `pendingFlashDecision[target][sender].unlockTime = block.timestamp + flashGovernanceConfig.unlockTime`?"",
    ""The functions `enforceToleranceInt` and `enforceTolerance` use a check `if (!configured) return;`. Where is the boolean state variable `configured` defined and set? It appears to be missing from the provided snippet."",
    ""In `burnFlashGovernanceAsset`, why is `pendingFlashDecision[targetContract][user]` reset to the *current* global `flashGovernanceConfig` after burning, instead of being deleted? What is the intended state after burning?"",
    ""Who is the intended caller for the `enforceTolerance` and `enforceToleranceInt` view functions? Are they meant to be called by the `target` contracts or external users/keepers?"",
    ""Is the use of `v1` as the baseline denominator in *both* branches of the comparison within `enforceTolerance` intentional (i.e., `((v1 - v2) * 100) < security.changeTolerance * v1` and `((v2 - v1) * 100) < security.changeTolerance * v1`)?"",
    ""The `hardhat/console.sol` import is typically used for debugging. Should this be removed for production deployment?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `withdrawGovernanceAsset` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdrawGovernanceAsset` function transfers tokens to `msg.sender` before deleting the `pendingFlashDecision` entry, creating a reentrancy vulnerability. A malicious recipient contract could call back into `withdrawGovernanceAsset` (or other vulnerable functions), potentially withdrawing more tokens than intended or manipulating contract state before the original `pendingFlashDecision` is deleted. State updates occur after external calls."",
      ""Impact"": ""Loss of governance asset funds; attacker could drain the contract of its assets by re-entering the function before the state is cleared; unexpected state manipulation."",
      ""Location"": ""FlashGovernanceArbiter.sol: `withdrawGovernanceAsset` function""
    },
    {
      ""Issue"": ""Insufficient validation for the asset in `burnFlashGovernanceAsset` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `burnFlashGovernanceAsset` function lacks validation to verify whether the `asset` parameter matches the `flashGovernanceConfig.asset` or if the `amount` is below a safety threshold. This allows a malicious actor to pass in any asset and amount, and burn any tokens from `Burnable(asset).burn(amount);`, potentially resulting in unintended token burning."",
      ""Impact"": ""A malicious actor can cause arbitrary token burning by manipulating the input parameters, potentially causing significant damage to the protocol\'s ecosystem and user funds."",
      ""Location"": ""FlashGovernanceArbiter.sol:burnFlashGovernanceAsset""
    },
    {
      ""Issue"": ""Missing Input Validation in Configuration Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Configuration functions like `configureFlashGovernance` and `configureSecurityParameters` lack proper input validation for parameters such as `asset` (zero address check), `maxGovernanceChangePerEpoch`, `epochSize`, and `amount`. Extreme or invalid values could lead to denial-of-service, unexpected behavior, or circumvent intended security measures."",
      ""Impact"": ""Contract may become unusable; governance less effective; potential denial-of-service; circumvention of intended security measures; unexpected behavior in dependent functions."",
      ""Location"": ""FlashGovernanceArbiter.sol: `configureFlashGovernance`, `configureSecurityParameters` functions""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `enforceTolerance` Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Calculations within the `enforceTolerance` and `enforceToleranceInt` functions, such as `(v1 - v2) * 100` or `(v2 - v1) * 100`, are vulnerable to integer overflows or underflows if the difference between `v1` and `v2` is large. This could lead to incorrect tolerance checks and bypassing intended security measures."",
      ""Impact"": ""Tolerance checks might not be as strict as intended, allowing larger changes than desired; Bypassing tolerance checks due to integer overflow; Incorrect tolerance calculation, potentially leading to bypassing intended limits."",
      ""Location"": ""FlashGovernanceArbiter.sol: `enforceTolerance`, `enforceToleranceInt` functions""
    },
    {
      ""Issue"": ""Incorrect `unlockTime` Update in `assertGovernanceApproved`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `assertGovernanceApproved` function updates `pendingFlashDecision[target][sender].unlockTime` by adding `block.timestamp` to it, effectively shifting the unlock time further into the future instead of setting an absolute unlock time. This progressively extends the cool down with each call, potentially disabling flash governance indefinitely or causing denial of service."",
      ""Impact"": ""Flash governance becomes disabled or delayed indefinitely; Potential denial of service due to unpredictable unlockTime behavior."",
      ""Location"": ""FlashGovernanceArbiter.sol: `assertGovernanceApproved` function""
    },
    {
      ""Issue"": ""Potential Replay Attack on `withdrawGovernanceAsset` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `withdrawGovernanceAsset` function allows users to withdraw governance assets after the `unlockTime` has passed. However, after the transfer, the `pendingFlashDecision` mapping is deleted. This means that if the same governance proposal is passed again, the user can potentially withdraw the asset a second time, circumventing the intended governance mechanism."",
      ""Impact"": ""Users could potentially withdraw governance assets multiple times for the same proposal, depleting the contract\'s funds and undermining the governance process."",
      ""Location"": ""withdrawGovernanceAsset function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `assertGovernanceApproved` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `assertGovernanceApproved` function checks if enough time has passed since the last flash governance act (`block.timestamp - security.lastFlashGovernanceAct > security.epochSize`). However, `block.timestamp` can be manipulated by miners. If a malicious actor observes a transaction calling `assertGovernanceApproved` and is close to the `epochSize` limit, they could potentially front-run the transaction by including their own transaction with a slightly higher gas price."",
      ""Impact"": ""A front-running attack could allow malicious actors to manipulate the governance process, potentially leading to unauthorized changes or theft of funds."",
      ""Location"": ""assertGovernanceApproved function""
    },
    {
      ""Issue"": ""Inconsistent Use of `pendingFlashDecision` Assignment and Data Management"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `burnFlashGovernanceAsset` function unconditionally overwrites the `pendingFlashDecision` mapping with `flashGovernanceConfig` after (or even if) the burning fails, potentially losing previous parameters and introducing inconsistencies. Also, `assertGovernanceApproved` and `burnFlashGovernanceAsset` use different assignment of `pendingFlashDecision`, potentially causing issues."",
      ""Impact"": ""Incorrect state management; Potential loss of original configuration; Unexpected behavior in subsequent calls; Code clarity and potential gas inefficiency; Different behaviors when recovering the `asset`."",
      ""Location"": ""FlashGovernanceArbiter.sol: `burnFlashGovernanceAsset`, `assertGovernanceApproved` functions""
    },
    {
      ""Issue"": ""Potential Division by Zero in `enforceTolerance` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `enforceTolerance` function, the check  can result in a division by zero if `v1` is zero."",
      ""Impact"": ""Possible integer overflow during calculation, unexpected reverts, potential bypass of tolerance checks."",
      ""Location"": ""FlashGovernanceArbiter.sol: `enforceTolerance` function""
    },
    {
      ""Issue"": ""Lack of Access Control on `setEnforcement` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setEnforcement` function allows any user to set or toggle the `enforceLimitsActive` flag for their address, allowing them to bypass tolerance checks in `enforceTolerance` and `enforceToleranceInt`. While not immediately exploitable, it reduces the intended effectiveness of the tolerance checks and could lead to unexpected behavior."",
      ""Impact"": ""Users can bypass tolerance checks, potentially leading to unexpected contract states or unintended consequences; Unexpected contract behavior; potential for bypassing intended tolerance limits."",
      ""Location"": ""FlashGovernanceArbiter.sol: `setEnforcement` function""
    },
    {
      ""Issue"": ""Unclear Role of `configured` Variable in `enforceTolerance` and `enforceToleranceInt`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `enforceTolerance` and `enforceToleranceInt` functions check a variable `configured` before applying the tolerance logic. However, the code does not show where this `configured` variable is defined or modified. If not set correctly during deployment/initialization, this could lead to the tolerance checks always being bypassed. Since this variable is not defined in this smart contract, it must be in the Governable.sol contract. This contract was not provided for analysis. The assumption is that this variable is defined."",
      ""Impact"": ""If `configured` is not properly managed, the tolerance checks may not be enforced as intended, leading to unexpected governance outcomes."",
      ""Location"": ""Function `enforceTolerance` and `enforceToleranceInt`""
    },
    {
        ""Issue"": ""Missing Check for Zero Address in `configureFlashGovernance`"",
        ""Severity"": ""Low"",
        ""Description"": ""The `configureFlashGovernance` function lacks a check to ensure that the `asset` address is not the zero address.  Setting the `flashGovernanceConfig.asset` to the zero address can lead to unexpected behavior and potential vulnerabilities when interacting with the `IERC20` interface in other functions, as calls to `IERC20(address(0))` will likely fail or behave unpredictably."",
        ""Impact"": ""If the asset address is set to zero, the `assertGovernanceApproved` function will revert because `IERC20(flashGovernanceConfig.asset).transferFrom` will call transferFrom on the zero address. This can break the intended functionality of the governance mechanism."",
        ""Location"": ""configureFlashGovernance function""
    },
    {
      ""Issue"": ""Unprotected Configuration State `configured`"",
      ""Severity"": ""Informational"",
      ""Description"": ""The `enforceTolerance` and `enforceToleranceInt` functions contain a line of code  `if (!configured) return;` but the `configured` state variable is inherited from `Governable.sol`, and is only set once, in the `Governable` constructor. This implies that the tolerance checks can only be active after `Governable` is initialized. This is an informational issue because it is likely intentional, but it is relevant."",
      ""Impact"": ""None if intended."",
      ""Location"": ""FlashGovernanceArbiter.sol: `enforceTolerance`, `enforceToleranceInt` function""
    }
  ],
  ""IssueNumber"": 48,
  ""OutputList"": 13
}",228.38690185546875,3782.0,35.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Lack of access control on `assertGovernanceApproved` can cause funds to be locked**

**Report Description**:  
The `assertGovernanceApproved` function in `FlashGovernanceArbiter` lacks access control, allowing anyone to lock other users' funds if the users have approved the contract to transfer `flashGovernanceConfig.amount` of `flashGovernanceConfig.asset`. An attacker can front-run a user's transaction to lock their funds, preventing them from executing flash governance decisions.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the lack of access control on `assertGovernanceApproved`, which is the core issue here. The response list focuses on other vulnerabilities but misses this critical access control flaw.

---

#### **[H-04] Logic error in `burnFlashGovernanceAsset` can cause locked assets to be stolen**

**Report Description**:  
The `burnFlashGovernanceAsset` function resets a user's `pendingFlashDecision` to the default config, allowing the user to steal other users' locked assets in future flash governance decisions. This enables attackers to withdraw funds even after their assets are burned.

**Match in Response List**:  
Matches with the issue titled **""Inconsistent Use of `pendingFlashDecision` Assignment and Data Management""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `pendingFlashDecision` being overwritten but does not explicitly mention the risk of stealing other users' assets. It focuses on state management inconsistencies rather than the theft of funds.

---

#### **[H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request**

**Report Description**:  
Users who do not withdraw their tokens after locking them in a previous proposal will lose their tokens if `assertGovernanceApproved` is called again with the same `target` and `sender`. The previous amount is overwritten, and the tokens become unaccounted for and locked in the contract.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this issue, which involves the loss of tokens due to overwriting `pendingFlashDecision` amounts.

---

#### **[M-01] Incorrect `unlockTime` can DOS `withdrawGovernanceAsset`**

**Report Description**:  
The `unlockTime` in `assertGovernanceApproved` is set incorrectly by adding `block.timestamp` to the existing `unlockTime`, progressively extending the unlock time and potentially causing a denial of service (DOS) for `withdrawGovernanceAsset`.

**Match in Response List**:  
Matches with the issue titled **""Incorrect `unlockTime` Update in `assertGovernanceApproved`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with `unlockTime` being incorrectly updated, leading to potential DOS. The description and impact align with the issue report.

---

#### **[M-02] Reentrancy on Flash Governance Proposal Withdrawal**

**Report Description**:  
The `withdrawGovernanceAsset` function is vulnerable to reentrancy, allowing an attacker to drain the contract's balance of `flashGovernanceConfig.asset` if the asset implements a callback mechanism (e.g., ERC777).

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability in `withdrawGovernanceAsset` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in `withdrawGovernanceAsset` and explains the potential impact, aligning with the issue report.

---

#### **[M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance**

**Report Description**:  
The `burnFlashGovernanceAsset` function overwrites the user's state with `flashGovernanceConfig`, effectively not deducting their balance and potentially unlocking their funds sooner than intended.

**Match in Response List**:  
Matches with the issue titled **""Inconsistent Use of `pendingFlashDecision` Assignment and Data Management""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `pendingFlashDecision` being overwritten but does not explicitly mention the failure to deduct the user's balance or the unintended unlocking of funds.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Incorrect `unlockTime` can DOS `withdrawGovernanceAsset`**
- **[M-02] Reentrancy on Flash Governance Proposal Withdrawal**

**Partially Correct Matches**:

- **[H-04] Logic error in `burnFlashGovernanceAsset` can cause locked assets to be stolen**
- **[M-03] Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance**

**Missed Issues from Issue Report**:

- **[H-01] Lack of access control on `assertGovernanceApproved` can cause funds to be locked**
- **[H-06] Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request**

--- 

The response list covers some issues accurately but misses critical vulnerabilities like access control flaws and token loss due to overwriting. Additionally, some responses partially address the issues but lack sufficient detail or focus on the wrong aspect of the vulnerability.","```
1. Incorrect `unlockTime` Update in `assertGovernanceApproved`
2. Potential Reentrancy Vulnerability in `withdrawGovernanceAsset` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Incorrect `unlockTime` Update in `assertGovernanceApproved`"" appears at rank 5.
   - ""Potential Reentrancy Vulnerability in `withdrawGovernanceAsset` Function"" appears at rank 1.

2. **Calculate the precision at each rank**:
   - For rank 1: \( P@1 = \frac{1}{1} = 1.0 \)
   - For rank 5: \( P@5 = \frac{2}{5} = 0.4 \)

3. **Average the precision values**:
   - \( AP = \frac{1.0 + 0.4}{2} = 0.7 \)

**Average Precision (AP)**: 0.7"
LimboDAO.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../ERC677/ERC677.sol"";
import ""../Flan.sol"";
import ""./ProposalFactory.sol"";
import ""../facades/SwapFactoryLike.sol"";
import ""../facades/UniPairLike.sol"";
import ""./Governable.sol"";

// import ""hardhat/console.sol"";

library TransferHelper {
  function ERC20NetTransfer(
    address token,
    address from,
    address to,
    int256 amount
  ) public {
    if (amount > 0) {
      require(IERC20(token).transferFrom(from, to, uint256(amount)), ""LimboDAO: ERC20 transfer from failed."");
    } else {
      require(IERC20(token).transfer(from, uint256(amount * (-1))), ""LimboDAO: ERC20 transfer failed."");
    }
  }
}

enum FateGrowthStrategy {
  straight,
  directRoot,
  indirectTwoRootEye
}

enum ProposalDecision {
  voting,
  approved,
  rejected
}

///@title Limbo DAO
///@author Justin Goro
/**@notice
 *This is the first MicroDAO associated with MorgothDAO. A MicroDAO manages parameterization of running dapps without having
 *control over existential functionality. This is not to say that some of the decisions taken are not critical but that the domain
 *of influence is confined to the local Dapp - Limbo in this case.
 * LimboDAO has two forms of decision making: proposals and flash governance. For proposals, voting power is required. Voting power in LimboDAO is measured
 * by a points system called Fate. Staking EYE or an EYE based LP earns Fate at a quadratic rate. Fate can be used to list a proposal for voting or to vote.
 * Using Fate to make a governance decisions spens it out of existince. So Fate reflects the opportunity cost of staking.
 * Flash governance is for instant decision making that cannot wait for voting to occur. Best used for small tweaks to parameters or emergencies.
 * Flash governance requires a governance asset (EYE) be staked at the time of the execution. The asset cannot be withdrawn for a certain period of time,
 * allowing for Fate holders to vote on the legitimacy of the decision. If the decision is considered malicious, the staked EYE is burnt.
 */
///@dev Contracts subject to LimboDAO must inherit the Governable abstract contract.
contract LimboDAO is Ownable {
  event daoKilled(address newOwner);
  event proposalLodged(address proposal, address proposer);
  event voteCast(address voter, address proposal, int256 fateCast);
  event assetApproval(address asset, bool appoved);
  event proposalExecuted(address proposal, bool approved);
  event assetBurnt(address burner, address asset, uint256 fateCreated);

  using TransferHelper for address;
  uint256 constant ONE = 1 ether;
  uint256 precision = 1e9;

  struct DomainConfig {
    address limbo;
    address flan;
    address eye;
    address fate;
    bool live;
    address flashGoverner;
    address sushiFactory;
    address uniFactory;
  }

  struct ProposalConfig {
    uint256 votingDuration;
    uint256 requiredFateStake;
    address proposalFactory; //check this for creating proposals
  }

  struct ProposalState {
    int256 fate;
    ProposalDecision decision;
    address proposer;
    uint256 start;
    Proposal proposal;
  }

  //rateCrate
  struct FateState {
    uint256 fatePerDay;
    uint256 fateBalance;
    uint256 lastDamnAdjustment;
  }

  struct AssetClout {
    uint256 fateWeight;
    uint256 balance;
  }

  DomainConfig public domainConfig;
  ProposalConfig public proposalConfig;

  /**@notice for staking EYE, we simply take the square root of staked amount.
   * For LP tokens, only half the value of the token is EYE so it's tempting to take the square root for the EYE balance. However this punishes the holder by ignoring the cost incurred by supplying the other asset. Since the other asset at rest is equal in value to the EYE balance, we just multiply the calculation by 2.
   */
  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;
  mapping(address => bool) public assetApproved;
  mapping(address => FateState) public fateState; //lateDate

  //Fate is earned per day. Keeping track of relative staked values, we can increment user balance
  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; //user->asset->weight

  ProposalState public currentProposalState;
  ProposalState public previousProposalState;

  // Since staking EYE precludes it from earning Flan on Limbo, fateToFlan can optionally be set to a non zero number to allow fat holders to spend their fate for Flan.
  uint256 public fateToFlan;

  modifier isLive() {
    require(domainConfig.live, ""LimboDAO: DAO is not live."");
    _;
  }

  function nextProposal() internal {
    previousProposalState = currentProposalState;
    currentProposalState.proposal = Proposal(address(0));
    currentProposalState.fate = 0;
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.proposer = address(0);
    currentProposalState.start = 0;
  }

  modifier onlySuccessfulProposal() {
    // console.log('onlySuccessfulProposal');
    require(successfulProposal(msg.sender), ""LimboDAO: approve proposal"");
    _;
    //nextProposal();
  }

  ///@notice has a proposal successfully been approved?
  function successfulProposal(address proposal) public view returns (bool) {
    return
      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);
  }

  modifier updateCurrentProposal() {
    incrementFateFor(_msgSender());
    if (address(currentProposalState.proposal) != address(0)) {
      uint256 durationSinceStart = block.timestamp - currentProposalState.start;
      if (
        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting
      ) {
        if (currentProposalState.fate > 0) {
          currentProposalState.decision = ProposalDecision.approved;
          currentProposalState.proposal.orchestrateExecute();
          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;
        } else {
          currentProposalState.decision = ProposalDecision.rejected;
        }
        emit proposalExecuted(
          address(currentProposalState.proposal),
          currentProposalState.decision == ProposalDecision.approved
        );
        nextProposal();
      }
    }
    _;
  }

  modifier incrementFate() {
    incrementFateFor(_msgSender());
    _;
  }

  function incrementFateFor(address user) public {
    FateState storage state = fateState[user];
    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);
    state.lastDamnAdjustment = block.timestamp;
  }

  ///@param limbo address of Limbo
  ///@param flan address of Flan
  ///@param eye address of EYE token
  ///@param proposalFactory authenticates and instantiates valid proposals for voting
  ///@param sushiFactory is the SushiSwap Factory contract
  ///@param uniFactory is the UniSwapV2 Factory contract
  ///@param flashGoverner oversees flash governance cryptoeconomics
  ///@param precisionOrderOfMagnitude when comparing fractional values, it's not necessary to get every last digit right
  ///@param sushiLPs valid EYE containing LP tokens elligible for earning Fate through staking
  ///@param uniLPs valid EYE containing LP tokens elligible for earning Fate through staking
  function seed(
    address limbo,
    address flan,
    address eye,
    address proposalFactory,
    address sushiFactory,
    address uniFactory,
    address flashGoverner,
    uint256 precisionOrderOfMagnitude,
    address[] memory sushiLPs,
    address[] memory uniLPs
  ) public onlyOwner {
    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);
    proposalConfig.votingDuration = 2 days;
    proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours
    proposalConfig.proposalFactory = proposalFactory;
    precision = 10**precisionOrderOfMagnitude;
    for (uint256 i = 0; i < sushiLPs.length; i++) {
      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;
      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
    for (uint256 i = 0; i < uniLPs.length; i++) {
      require(UniPairLike(uniLPs[i]).factory() == uniFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;
      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
  }

  ///@notice allows Limbo to be governed by a new DAO
  ///@dev functions marked by onlyOwner are governed by MorgothDAO
  function killDAO(address newOwner) public onlyOwner isLive {
    domainConfig.live = false;
    Governable(domainConfig.flan).setDAO(newOwner);
    Governable(domainConfig.limbo).setDAO(newOwner);
    emit daoKilled(newOwner);
  }

  ///@notice optional conversion rate of Fate to Flan
  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {
    fateToFlan = rate;
  }

  ///@notice caller spends their Fate to earn Flan
  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {
    require(fateToFlan > 0, ""LimboDAO: Fate conversion to Flan disabled."");
    fateState[msg.sender].fateBalance -= fate;
    flan = (fateToFlan * fate) / ONE;
    Flan(domainConfig.flan).mint(msg.sender, flan);
  }

  /**@notice handles proposal lodging logic. A deposit of Fate is removed from the user. If the decision is a success, half the fate is returned.
   *  This is to encourage only lodging of proposals that are likely to succeed.
   *  @dev not for external calling. Use the proposalFactory to lodge a proposal instead.
   */
  function makeProposal(address proposal, address proposer) public updateCurrentProposal {
    address sender = _msgSender();
    require(sender == proposalConfig.proposalFactory, ""LimboDAO: only Proposal Factory"");
    require(address(currentProposalState.proposal) == address(0), ""LimboDAO: active proposal."");

    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;
    currentProposalState.proposal = Proposal(proposal);
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.fate = 0;
    currentProposalState.proposer = proposer;
    currentProposalState.start = block.timestamp;
    emit proposalLodged(proposal, proposer);
  }

  ///@notice handles proposal voting logic.
  ///@param proposal contract to be voted on
  ///@param fate positive is YES, negative is NO. Absolute value is deducted from caller.
  function vote(address proposal, int256 fate) public incrementFate isLive {
    require(
      proposal == address(currentProposalState.proposal), //this is just to protect users with out of sync UIs
      ""LimboDAO: stated proposal does not match current proposal""
    );
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: voting on proposal closed"");
    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {
      int256 currentFate = currentProposalState.fate;
      //check if voting has ended
      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {
        revert(""LimboDAO: voting for current proposal has ended."");
      } else if (
        //The following if statement checks if the vote is flipped by fate
        fate * currentFate < 0 && //sign different
        (fate + currentFate) * fate > 0 //fate flipped current fate onto the same side of zero as fate
      ) {
        //extend voting duration when vote flips decision. Suggestion made by community member
        currentProposalState.start = currentProposalState.start + 2 hours;
      }
    }
    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);
    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;

    currentProposalState.fate += fate;
    emit voteCast(_msgSender(), proposal, fate);
  }

  ///@notice pushes the decision to execute a successful proposal. For convenience only
  function executeCurrentProposal() public updateCurrentProposal {}

  ///@notice parameterizes the voting
  ///@param requiredFateStake the amount of Fate required to lodge a proposal
  ///@param votingDuration the duration of voting in seconds
  ///@param proposalFactory the address of the proposal factory
  function setProposalConfig(
    uint256 votingDuration,
    uint256 requiredFateStake,
    address proposalFactory
  ) public onlySuccessfulProposal {
    proposalConfig.votingDuration = votingDuration;
    proposalConfig.requiredFateStake = requiredFateStake;
    proposalConfig.proposalFactory = proposalFactory;
  }

  ///@notice Assets approved for earning Fate
  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {
    assetApproved[asset] = approved;
    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;
    emit assetApproval(asset, approved);
  }

  ///@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.
  ///@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question
  ///@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half
  ///@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm
  ///@param asset the asset being staked
  function setEYEBasedAssetStake(
    uint256 finalAssetBalance,
    uint256 finalEYEBalance,
    uint256 rootEYE,
    address asset
  ) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    FateGrowthStrategy strategy = fateGrowthStrategy[asset];

    //verifying that rootEYE value is accurate within precision.
    uint256 rootEYESquared = rootEYE * rootEYE;
    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);
    require(
      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,
      ""LimboDAO: Stake EYE invariant.""
    );
    AssetClout storage clout = stakedUserAssetWeight[sender][asset];
    fateState[sender].fatePerDay -= clout.fateWeight;
    uint256 initialBalance = clout.balance;
    //EYE
    if (strategy == FateGrowthStrategy.directRoot) {
      require(finalAssetBalance == finalEYEBalance, ""LimboDAO: staking eye invariant."");
      require(asset == domainConfig.eye);

      clout.fateWeight = rootEYE;
      clout.balance = finalAssetBalance;
      fateState[sender].fatePerDay += rootEYE;
    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {
      //LP
      clout.fateWeight = 2 * rootEYE;
      fateState[sender].fatePerDay += clout.fateWeight;

      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);
      finalEYEBalance /= precision;
      require(
        finalEYEBalance == impliedEye, //precision cap
        ""LimboDAO: stake invariant check 2.""
      );
      clout.balance = finalAssetBalance;
    } else {
      revert(""LimboDAO: asset growth strategy not accounted for"");
    }
    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);
    asset.ERC20NetTransfer(sender, address(this), netBalance);
  }

  /**
   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.
   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset
   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.
   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent
   * loss of EYE.
   *@param asset the asset to burn and can be EYE or EYE based assets
   *@param amount the amount of asset to burn
   */
  function burnAsset(address asset, uint256 amount) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    require(ERC677(asset).transferFrom(sender, address(this), amount), ""LimboDAO: transferFailed"");
    uint256 fateCreated = fateState[_msgSender()].fateBalance;
    if (asset == domainConfig.eye) {
      fateCreated = amount * 10;
      ERC677(domainConfig.eye).burn(amount);
    } else {
      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * amount) / ONE;
      fateCreated = impliedEye * 20;
    }
    fateState[_msgSender()].fateBalance += fateCreated;
    emit assetBurnt(_msgSender(), asset, fateCreated);
  }

  ///@notice grants unlimited Flan minting power to an address.
  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {
    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);
  }

  ///@notice call this after initial config is complete.
  function makeLive() public onlyOwner {
    require(
      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),
      ""LimboDAO: transfer ownership of limbo and flan.""
    );
    domainConfig.live = true;
  }

  ///@notice if the DAO is being dismantled, it's necessary to transfer any owned items
  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {
    Ownable(thing).transferOwnership(destination);
  }

  function timeRemainingOnProposal() public view returns (uint256) {
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: proposal finished."");
    uint256 elapsed = block.timestamp - currentProposalState.start;
    if (elapsed > proposalConfig.votingDuration) return 0;
    return proposalConfig.votingDuration - elapsed;
  }

  /**@notice seed is a goro idiom for initialize that you tend to find in all the dapps I've written.
   * I prefer initialization funcitons to parameterized solidity constructors for reasons beyond the scope of this comment.
   */
  function _seed(
    address limbo,
    address flan,
    address eye,
    address sushiFactory,
    address uniFactory,
    address flashGoverner
  ) internal {
    domainConfig.limbo = limbo;
    domainConfig.flan = flan;
    domainConfig.eye = eye;
    domainConfig.uniFactory = uniFactory;
    domainConfig.sushiFactory = sushiFactory;
    domainConfig.flashGoverner = flashGoverner;
    assetApproved[eye] = true;
    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;
  }

  function getFlashGoverner() external view returns (address) {
    return domainConfig.flashGoverner;
  }
}",4664,453,"[H-07] LP pricing formula is vulnerable to flashloan manipulation
 `burnAsset` function of `LimboDAO` 
Submitted by shw
The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more fate than he is supposed to with a relatively low cost.
With the large portion of fate he gets, he has more voting power to influence the system's decisions, or even he can convert his fate to Flan tokens for a direct profit.
  [M-04] The system can get to a ""stuck"" state if a bad proposal (proposal that can't be executed) is accepted

LimboDAO.sol (`updateCurrentProposal() `modifier and makeProposal() function)

The LimboDAO contract has a variable that indicates the current proposal - every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an UpdateMultipleSoulConfigProposal proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass - the users won't be able to vote anymore (because the vote function will revert), and the proposal can't be executed - the execute function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.
When trying to call the executeCurrentProposal() function that activates the updateCurrentProposal() modifier, the modifier will check the balance of fate, it will see that it's positive and will call currentProposalState.proposal.orchestrateExecute() to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with voting state).
When trying to call makeProposal() function to make a new proposal it will revert because the current proposal is not equal to address(0).
",2,,"pragma solidity 0.8.4;
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""../ERC677/ERC677.sol"";
import ""../Flan.sol"";
import ""./ProposalFactory.sol"";
import ""../facades/SwapFactoryLike.sol"";
import ""../facades/UniPairLike.sol"";
import ""./Governable.sol"";



library TransferHelper {
  function ERC20NetTransfer(
    address token,
    address from,
    address to,
    int256 amount
  ) public {
    if (amount > 0) {
      require(IERC20(token).transferFrom(from, to, uint256(amount)), ""LimboDAO: ERC20 transfer from failed."");
    } else {
      require(IERC20(token).transfer(from, uint256(amount * (-1))), ""LimboDAO: ERC20 transfer failed."");
    }
  }
}

enum FateGrowthStrategy {
  straight,
  directRoot,
  indirectTwoRootEye
}

enum ProposalDecision {
  voting,
  approved,
  rejected
}





contract LimboDAO is Ownable {
  event daoKilled(address newOwner);
  event proposalLodged(address proposal, address proposer);
  event voteCast(address voter, address proposal, int256 fateCast);
  event assetApproval(address asset, bool appoved);
  event proposalExecuted(address proposal, bool approved);
  event assetBurnt(address burner, address asset, uint256 fateCreated);

  using TransferHelper for address;
  uint256 constant ONE = 1 ether;
  uint256 precision = 1e9;

  struct DomainConfig {
    address limbo;
    address flan;
    address eye;
    address fate;
    bool live;
    address flashGoverner;
    address sushiFactory;
    address uniFactory;
  }

  struct ProposalConfig {
    uint256 votingDuration;
    uint256 requiredFateStake;
    address proposalFactory; 
  }

  struct ProposalState {
    int256 fate;
    ProposalDecision decision;
    address proposer;
    uint256 start;
    Proposal proposal;
  }

  
  struct FateState {
    uint256 fatePerDay;
    uint256 fateBalance;
    uint256 lastDamnAdjustment;
  }

  struct AssetClout {
    uint256 fateWeight;
    uint256 balance;
  }

  DomainConfig public domainConfig;
  ProposalConfig public proposalConfig;

  
  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;
  mapping(address => bool) public assetApproved;
  mapping(address => FateState) public fateState; 

  
  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; 

  ProposalState public currentProposalState;
  ProposalState public previousProposalState;

  
  uint256 public fateToFlan;

  modifier isLive() {
    require(domainConfig.live, ""LimboDAO: DAO is not live."");
    _;
  }

  function nextProposal() internal {
    previousProposalState = currentProposalState;
    currentProposalState.proposal = Proposal(address(0));
    currentProposalState.fate = 0;
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.proposer = address(0);
    currentProposalState.start = 0;
  }

  modifier onlySuccessfulProposal() {
    
    require(successfulProposal(msg.sender), ""LimboDAO: approve proposal"");
    _;
    
  }

  
  function successfulProposal(address proposal) public view returns (bool) {
    return
      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);
  }

  modifier updateCurrentProposal() {
    incrementFateFor(_msgSender());
    if (address(currentProposalState.proposal) != address(0)) {
      uint256 durationSinceStart = block.timestamp - currentProposalState.start;
      if (
        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting
      ) {
        if (currentProposalState.fate > 0) {
          currentProposalState.decision = ProposalDecision.approved;
          currentProposalState.proposal.orchestrateExecute();
          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;
        } else {
          currentProposalState.decision = ProposalDecision.rejected;
        }
        emit proposalExecuted(
          address(currentProposalState.proposal),
          currentProposalState.decision == ProposalDecision.approved
        );
        nextProposal();
      }
    }
    _;
  }

  modifier incrementFate() {
    incrementFateFor(_msgSender());
    _;
  }

  function incrementFateFor(address user) public {
    FateState storage state = fateState[user];
    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);
    state.lastDamnAdjustment = block.timestamp;
  }

  
  
  
  
  
  
  
  
  
  
  function seed(
    address limbo,
    address flan,
    address eye,
    address proposalFactory,
    address sushiFactory,
    address uniFactory,
    address flashGoverner,
    uint256 precisionOrderOfMagnitude,
    address[] memory sushiLPs,
    address[] memory uniLPs
  ) public onlyOwner {
    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);
    proposalConfig.votingDuration = 2 days;
    proposalConfig.requiredFateStake = 223 * ONE; 
    proposalConfig.proposalFactory = proposalFactory;
    precision = 10**precisionOrderOfMagnitude;
    for (uint256 i = 0; i < sushiLPs.length; i++) {
      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;
      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
    for (uint256 i = 0; i < uniLPs.length; i++) {
      require(UniPairLike(uniLPs[i]).factory() == uniFactory, ""LimboDAO: invalid Sushi LP"");
      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;
      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;
    }
  }

  
  
  function killDAO(address newOwner) public onlyOwner isLive {
    domainConfig.live = false;
    Governable(domainConfig.flan).setDAO(newOwner);
    Governable(domainConfig.limbo).setDAO(newOwner);
    emit daoKilled(newOwner);
  }

  
  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {
    fateToFlan = rate;
  }

  
  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {
    require(fateToFlan > 0, ""LimboDAO: Fate conversion to Flan disabled."");
    fateState[msg.sender].fateBalance -= fate;
    flan = (fateToFlan * fate) / ONE;
    Flan(domainConfig.flan).mint(msg.sender, flan);
  }

  
  function makeProposal(address proposal, address proposer) public updateCurrentProposal {
    address sender = _msgSender();
    require(sender == proposalConfig.proposalFactory, ""LimboDAO: only Proposal Factory"");
    require(address(currentProposalState.proposal) == address(0), ""LimboDAO: active proposal."");

    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;
    currentProposalState.proposal = Proposal(proposal);
    currentProposalState.decision = ProposalDecision.voting;
    currentProposalState.fate = 0;
    currentProposalState.proposer = proposer;
    currentProposalState.start = block.timestamp;
    emit proposalLodged(proposal, proposer);
  }

  
  
  
  function vote(address proposal, int256 fate) public incrementFate isLive {
    require(
      proposal == address(currentProposalState.proposal), 
      ""LimboDAO: stated proposal does not match current proposal""
    );
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: voting on proposal closed"");
    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {
      int256 currentFate = currentProposalState.fate;
      
      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {
        revert(""LimboDAO: voting for current proposal has ended."");
      } else if (
        
        fate * currentFate < 0 && 
        (fate + currentFate) * fate > 0 
      ) {
        
        currentProposalState.start = currentProposalState.start + 2 hours;
      }
    }
    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);
    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;

    currentProposalState.fate += fate;
    emit voteCast(_msgSender(), proposal, fate);
  }

  
  function executeCurrentProposal() public updateCurrentProposal {}

  
  
  
  
  function setProposalConfig(
    uint256 votingDuration,
    uint256 requiredFateStake,
    address proposalFactory
  ) public onlySuccessfulProposal {
    proposalConfig.votingDuration = votingDuration;
    proposalConfig.requiredFateStake = requiredFateStake;
    proposalConfig.proposalFactory = proposalFactory;
  }

  
  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {
    assetApproved[asset] = approved;
    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;
    emit assetApproval(asset, approved);
  }

  
  
  
  
  
  function setEYEBasedAssetStake(
    uint256 finalAssetBalance,
    uint256 finalEYEBalance,
    uint256 rootEYE,
    address asset
  ) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    FateGrowthStrategy strategy = fateGrowthStrategy[asset];

    
    uint256 rootEYESquared = rootEYE * rootEYE;
    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);
    require(
      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,
      ""LimboDAO: Stake EYE invariant.""
    );
    AssetClout storage clout = stakedUserAssetWeight[sender][asset];
    fateState[sender].fatePerDay -= clout.fateWeight;
    uint256 initialBalance = clout.balance;
    
    if (strategy == FateGrowthStrategy.directRoot) {
      require(finalAssetBalance == finalEYEBalance, ""LimboDAO: staking eye invariant."");
      require(asset == domainConfig.eye);

      clout.fateWeight = rootEYE;
      clout.balance = finalAssetBalance;
      fateState[sender].fatePerDay += rootEYE;
    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {
      
      clout.fateWeight = 2 * rootEYE;
      fateState[sender].fatePerDay += clout.fateWeight;

      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);
      finalEYEBalance /= precision;
      require(
        finalEYEBalance == impliedEye, 
        ""LimboDAO: stake invariant check 2.""
      );
      clout.balance = finalAssetBalance;
    } else {
      revert(""LimboDAO: asset growth strategy not accounted for"");
    }
    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);
    asset.ERC20NetTransfer(sender, address(this), netBalance);
  }

  
  function burnAsset(address asset, uint256 amount) public isLive incrementFate {
    require(assetApproved[asset], ""LimboDAO: illegal asset"");
    address sender = _msgSender();
    require(ERC677(asset).transferFrom(sender, address(this), amount), ""LimboDAO: transferFailed"");
    uint256 fateCreated = fateState[_msgSender()].fateBalance;
    if (asset == domainConfig.eye) {
      fateCreated = amount * 10;
      ERC677(domainConfig.eye).burn(amount);
    } else {
      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);
      require(actualEyeBalance > 0, ""LimboDAO: No EYE"");
      uint256 totalSupply = IERC20(asset).totalSupply();
      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;
      uint256 impliedEye = (eyePerUnit * amount) / ONE;
      fateCreated = impliedEye * 20;
    }
    fateState[_msgSender()].fateBalance += fateCreated;
    emit assetBurnt(_msgSender(), asset, fateCreated);
  }

  
  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {
    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);
  }

  
  function makeLive() public onlyOwner {
    require(
      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),
      ""LimboDAO: transfer ownership of limbo and flan.""
    );
    domainConfig.live = true;
  }

  
  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {
    Ownable(thing).transferOwnership(destination);
  }

  function timeRemainingOnProposal() public view returns (uint256) {
    require(currentProposalState.decision == ProposalDecision.voting, ""LimboDAO: proposal finished."");
    uint256 elapsed = block.timestamp - currentProposalState.start;
    if (elapsed > proposalConfig.votingDuration) return 0;
    return proposalConfig.votingDuration - elapsed;
  }

  
  function _seed(
    address limbo,
    address flan,
    address eye,
    address sushiFactory,
    address uniFactory,
    address flashGoverner
  ) internal {
    domainConfig.limbo = limbo;
    domainConfig.flan = flan;
    domainConfig.eye = eye;
    domainConfig.uniFactory = uniFactory;
    domainConfig.sushiFactory = sushiFactory;
    domainConfig.flashGoverner = flashGoverner;
    assetApproved[eye] = true;
    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;
  }

  function getFlashGoverner() external view returns (address) {
    return domainConfig.flashGoverner;
  }
}",3290,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Governance"",
      ""Tasks"": [
        ""Verify that only the owner can call `seed` and `killDAO` functions."",
        ""Analyze the impact of transferring ownership via `killDAO` and `transferOwnershipOfThing` on dependent contracts and the overall system."",
        ""Ensure that the `onlySuccessfulProposal` modifier correctly validates that the `msg.sender` is indeed the current approved proposal."",
        ""Investigate potential vulnerabilities in the proposal process, especially how the `ProposalFactory` is validated and what constraints it enforces on new proposals."",
        ""Review the logic in `makeLive` to confirm that the DAO can only be activated when the Limbo and Flan contracts have their DAO set to the LimboDAO contract. Check for edge cases during initial deployment."",
        ""Analyze the impact of `approveFlanMintingPower` on the Flan token's supply and potential for inflation. Also, verify that allowance is indeed reset to 0 when `enabled` is false.""
      ]
    },
    {
      ""Area"": ""FATE Tokenomics and Staking"",
      ""Tasks"": [
        ""Thoroughly analyze the FATE calculation logic in `setEYEBasedAssetStake` for potential rounding errors or overflows, especially when dealing with large token balances or the `precision` factor. Focus on division and multiplication orders."",
        ""Investigate whether the FATE calculation logic in `setEYEBasedAssetStake` is vulnerable to manipulation by front-running or sandwich attacks."",
        ""Examine the `burnAsset` function to ensure the fateCreated calculation is accurate and resistant to manipulation.  Consider edge cases where `totalSupply` is very small or `actualEyeBalance` changes rapidly."",
        ""Assess the potential for users to manipulate the `fateGrowthStrategy` to their advantage, especially if they can influence the EYE balance of an asset."",
        ""Verify the fate deduction logic in the `makeProposal` and `vote` functions to prevent users from voting with insufficient FATE or exploiting vulnerabilities related to integer overflows or underflows."",
        ""Audit the `incrementFateFor` function for potential vulnerabilities, especially related to timestamp manipulation or out-of-sync block timestamps which could allow users to unfairly inflate their fate balances.""
      ]
    },
    {
      ""Area"": ""Proposal and Voting Mechanics"",
      ""Tasks"": [
        ""Analyze the potential impact of extending the voting duration in the `vote` function. Can this mechanism be abused to indefinitely delay or manipulate proposal outcomes?"",
        ""Investigate the potential for denial-of-service (DoS) attacks on the voting process, such as by repeatedly extending the voting duration with small negative votes."",
        ""Examine the `updateCurrentProposal` modifier to ensure that the proposal execution logic is secure and prevents unintended consequences. Scrutinize what `proposal.orchestrateExecute()` does."",
        ""Verify the refund of staked FATE upon successful proposal execution in `updateCurrentProposal`. Determine whether the proposer receives `proposalConfig.requiredFateStake` or `proposalConfig.requiredFateStake * 2` back."",
        ""Investigate whether it is possible for a proposal to be approved with a negative `currentProposalState.fate` due to negative votes exceeding positive votes.""
      ]
    },
    {
      ""Area"": ""External Interactions and Security"",
      ""Tasks"": [
        ""Conduct a thorough reentrancy analysis of all functions that interact with external contracts, especially `setEYEBasedAssetStake`, `burnAsset`, `convertFateToFlan`, and `proposal.orchestrateExecute()` called in `updateCurrentProposal`. Use static analysis tools and manual code review."",
        ""Review the error handling and validation of external calls to ensure that failures in external contracts do not lead to unexpected behavior or security vulnerabilities."",
        ""Analyze the potential risks associated with using the `TransferHelper` library, especially concerning token compatibility and handling of edge cases."",
        ""Verify that the contract addresses for Limbo, Flan, Eye, SushiFactory, UniFactory, ProposalFactory, and FlashGoverner are properly validated during the `seed` function. What happens if these are zero addresses?""
      ]
    },
    {
      ""Area"": ""Arithmetic Errors"",
      ""Tasks"": [
        ""Review all arithmetic operations for potential overflows, underflows, and division by zero errors. Use SafeMath or similar libraries where appropriate, or upgrade solidity version to 0.8.0+ where underflows are checked by default."",
        ""Specifically, analyze the FATE calculation in `setEYEBasedAssetStake` and `burnAsset` for potential precision loss due to integer division."",
        ""Check for potential integer truncation issues where converting between `uint256` and `int256`""
      ]
    },
     {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Profile gas usage of key functions like `setEYEBasedAssetStake`, `burnAsset`, `vote` and identify areas for optimization."",
        ""Minimize storage writes where possible to reduce gas costs."",
        ""Consider batching operations to reduce transaction overhead.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines the `LimboDAO` contract, which acts as a central governance hub for an ecosystem likely involving FLAN, EYE, and LIMBO tokens. It manages proposals, voting using an internal FATE balance system, staking of approved assets (like EYE or LP tokens) to generate FATE, burning assets for FATE, and converting FATE to FLAN tokens. It utilizes OpenZeppelin's Ownable for access control and interacts with several other contracts, including token contracts (IERC20, ERC677, Flan), DEX interfaces (UniPairLike, SwapFactoryLike), a ProposalFactory, and Governable contracts (Limbo, Flan). Key functionalities include proposal lifecycle management, FATE accrual based on staking strategies, voting mechanics with potential time extensions, and DAO-controlled configuration changes."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LimboDAO"",
    ""Purpose"": ""To manage governance proposals, voting, FATE tokenomics (generation via staking, burning, conversion to FLAN), and control associated contracts (Flan, Limbo) within its ecosystem."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""@openzeppelin/contracts/access/Ownable.sol""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""../ERC677/ERC677.sol"",
        ""../Flan.sol"",
        ""./ProposalFactory.sol"",
        ""../facades/SwapFactoryLike.sol"",
        ""../facades/UniPairLike.sol"",
        ""./Governable.sol"",
        ""TransferHelper (Library defined within the code)""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""ONE"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Represents 1 ether (1e18), likely used for fixed-point arithmetic.""
      },
      {
        ""Name"": ""precision"",
        ""Type"": ""uint256"",
        ""Purpose"": ""A precision factor (initialized to 1e9 in `seed`), used in staking calculations.""
      },
      {
        ""Name"": ""DomainConfig"",
        ""Type"": ""struct"",
        ""Purpose"": ""Holds addresses of core contracts (limbo, flan, eye, fate, factories, flash governer) and the DAO's live status.""
      },
      {
        ""Name"": ""ProposalConfig"",
        ""Type"": ""struct"",
        ""Purpose"": ""Holds configuration parameters for proposals (voting duration, required FATE stake, proposal factory address).""
      },
      {
        ""Name"": ""ProposalState"",
        ""Type"": ""struct"",
        ""Purpose"": ""Holds the state of a proposal (net FATE vote, decision, proposer, start time, proposal contract address).""
      },
      {
        ""Name"": ""FateState"",
        ""Type"": ""struct"",
        ""Purpose"": ""Holds user-specific FATE generation state (rate per day, current balance, last update time).""
      },
      {
        ""Name"": ""AssetClout"",
        ""Type"": ""struct"",
        ""Purpose"": ""Holds details about a user's stake in a specific asset (calculated FATE weight, token balance).""
      },
      {
        ""Name"": ""domainConfig"",
        ""Type"": ""DomainConfig"",
        ""Purpose"": ""Instance storing the domain configuration.""
      },
      {
        ""Name"": ""proposalConfig"",
        ""Type"": ""ProposalConfig"",
        ""Purpose"": ""Instance storing the proposal configuration.""
      },
      {
        ""Name"": ""fateGrowthStrategy"",
        ""Type"": ""mapping(address => FateGrowthStrategy)"",
        ""Purpose"": ""Maps asset addresses to their FATE generation strategy.""
      },
      {
        ""Name"": ""assetApproved"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Maps asset addresses to their approval status for staking/burning.""
      },
      {
        ""Name"": ""fateState"",
        ""Type"": ""mapping(address => FateState)"",
        ""Purpose"": ""Maps user addresses to their FATE state.""
      },
      {
        ""Name"": ""stakedUserAssetWeight"",
        ""Type"": ""mapping(address => mapping(address => AssetClout))"",
        ""Purpose"": ""Maps user addresses to their staked asset details (weight and balance per asset).""
      },
      {
        ""Name"": ""currentProposalState"",
        ""Type"": ""ProposalState"",
        ""Purpose"": ""Stores the state of the currently active proposal.""
      },
      {
        ""Name"": ""previousProposalState"",
        ""Type"": ""ProposalState"",
        ""Purpose"": ""Stores the state of the most recently concluded proposal.""
      },
      {
        ""Name"": ""fateToFlan"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The conversion rate from FATE to FLAN tokens.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""ERC20NetTransfer (within TransferHelper library)"",
        ""Visibility"": ""public (library function)"",
        ""Purpose"": ""Helper to transfer ERC20 tokens, handling both positive (transferFrom) and negative (transfer) amounts."",
        ""Parameters"": [
          ""address token"",
          ""address from"",
          ""address to"",
          ""int256 amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""isLive"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Requires the DAO to be live (`domainConfig.live == true`)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlySuccessfulProposal"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Requires `msg.sender` to be the address of the currently approved proposal contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updateCurrentProposal"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates the caller's FATE balance. Checks if the current proposal's voting period ended, determines outcome, executes if approved, rewards/penalizes proposer, and advances proposal state."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""incrementFate"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Updates the caller's (`_msgSender()`) FATE balance based on time elapsed and staked assets."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""incrementFateFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates and updates the FATE balance for a specific user."",
        ""Parameters"": [
          ""address user""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""seed"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Owner-only function to initialize DAO configurations, addresses, precision, and approve initial LP tokens."",
        ""Parameters"": [
          ""address limbo"",
          ""address flan"",
          ""address eye"",
          ""address proposalFactory"",
          ""address sushiFactory"",
          ""address uniFactory"",
          ""address flashGoverner"",
          ""uint256 precisionOrderOfMagnitude"",
          ""address[] memory sushiLPs"",
          ""address[] memory uniLPs""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""killDAO"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Owner-only function to disable the DAO and transfer ownership of associated contracts."",
        ""Parameters"": [
          ""address newOwner""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setFateToFlan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the FATE to FLAN conversion rate (requires successful proposal)."",
        ""Parameters"": [
          ""uint256 rate""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""convertFateToFlan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to burn their FATE balance to mint FLAN tokens."",
        ""Parameters"": [
          ""uint256 fate""
        ],
        ""Returns"": [
          ""uint256 flan""
        ]
      },
      {
        ""Name"": ""makeProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Called by the Proposal Factory to lodge a new proposal, deducting stake from the proposer."",
        ""Parameters"": [
          ""address proposal"",
          ""address proposer""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""vote"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to cast votes (positive or negative FATE) on the current proposal, potentially extending voting time near the end."",
        ""Parameters"": [
          ""address proposal"",
          ""int256 fate""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""executeCurrentProposal"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Triggers the logic in `updateCurrentProposal` to check and potentially finalize the current proposal."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setProposalConfig"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates proposal configuration parameters (requires successful proposal)."",
        ""Parameters"": [
          ""uint256 votingDuration"",
          ""uint256 requiredFateStake"",
          ""address proposalFactory""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setApprovedAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Approves or disapproves an asset for staking/burning (requires successful proposal)."",
        ""Parameters"": [
          ""address asset"",
          ""bool approved""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setEYEBasedAssetStake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to stake approved assets, calculating and updating their FATE generation rate based on asset type and EYE balance."",
        ""Parameters"": [
          ""uint256 finalAssetBalance"",
          ""uint256 finalEYEBalance"",
          ""uint256 rootEYE"",
          ""address asset""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""burnAsset"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to burn approved assets to gain FATE, based on the asset's direct or indirect EYE value."",
        ""Parameters"": [
          ""address asset"",
          ""uint256 amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""approveFlanMintingPower"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Grants or revokes FLAN minting allowance to an address (requires successful proposal)."",
        ""Parameters"": [
          ""address minter"",
          ""bool enabled""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""makeLive"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Owner-only function to activate the DAO after ensuring necessary ownerships are set."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""transferOwnershipOfThing"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers ownership of an arbitrary Ownable contract (requires successful proposal)."",
        ""Parameters"": [
          ""address thing"",
          ""address destination""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""timeRemainingOnProposal"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the remaining time for the current proposal's voting period."",
        ""Parameters"": [],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""getFlashGoverner"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the configured Flash Governer address."",
        ""Parameters"": [],
        ""Returns"": [
          ""address""
        ]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 interface: `transferFrom`, `transfer`, `balanceOf`, `totalSupply` on various token contracts (EYE, FLAN, LPs, other approved assets)."",
    ""ERC677 interface: `transferFrom`, `burn` (specifically on EYE token in `burnAsset`)."",
    ""Flan contract: `mint`, `increaseMintAllowance`, `setDAO`, `DAO`."",
    ""ProposalFactory contract: Relies on this external contract to call `makeProposal`."",
    ""Proposal contract instance: Calls `orchestrateExecute` on approved proposals."",
    ""SwapFactoryLike interface (Sushi/Uni): `factory()` called via `UniPairLike` in `seed`."",
    ""UniPairLike interface: `factory()` called in `seed`."",
    ""Governable interface: `setDAO`, `DAO` called on Flan and Limbo contracts."",
    ""Ownable interface: `transferOwnership` called in `transferOwnershipOfThing`.""
  ],
  ""SpecialMechanisms"": [
    ""DAO Governance: Manages proposal lifecycle (lodging, voting, execution)."",
    ""Internal Tokenomics (FATE): FATE is an internal accounting unit generated via staking, used for voting, required for proposing, and convertible to FLAN. It's not an external ERC20 token."",
    ""Complex Staking/FATE Generation: FATE generation rate depends on the staked asset and its relation to EYE token balance (direct, indirect via LP). Uses different `FateGrowthStrategy` enums."",
    ""Asset Burning for FATE: Allows conversion of approved assets into FATE."",
    ""Proposal Factory Pattern: Delegates proposal creation to a dedicated factory contract."",
    ""Access Control: Mix of `Ownable` (setup, kill switch), successful proposal (`onlySuccessfulProposal` modifier), and specific contract address checks (Proposal Factory)."",
    ""Vote Timing Extension: Logic in `vote` function to potentially extend voting duration if a vote flips the outcome near the deadline."",
    ""Control over External Contracts: Manages DAO role for Limbo/Flan, FLAN minting permissions, and ownership of other Ownable contracts."",
    ""Custom Transfer Logic: `TransferHelper` library used for net token movements.""
  ],
  ""Questions"": [
    ""What are the specific functionalities and limitations of the `Proposal` contract's `orchestrateExecute` function? What actions can a proposal enforce?"",
    ""What is the role of the `Limbo` contract (address stored in `domainConfig`) within the ecosystem?"",
    ""Why is the proposer's FATE balance reduced by `proposalConfig.requiredFateStake * 2` in `makeProposal`, but only `proposalConfig.requiredFateStake` is potentially returned upon successful execution?"",
    ""In `setEYEBasedAssetStake`, could the initial `rootEYE` check (`rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance`) be manipulated, or is it sufficiently constrained by subsequent checks?"",
    ""What is the rationale for using `precision = 1e9` specifically in staking calculations?"",
    ""Are there potential risks associated with the `incrementFateFor` function being public?"",
    ""Is the contract vulnerable to reentrancy attacks, particularly in functions like `setEYEBasedAssetStake`, `burnAsset`, `convertFateToFlan`, and during `proposal.orchestrateExecute()`?"",
    ""How is the `ProposalFactory` expected to vet or constrain the `proposal` contracts it creates to prevent malicious proposals?"",
    ""Is the `fate` address in `DomainConfig` used anywhere? It appears FATE is purely an internal balance mechanism."",
    ""What determines the initial FATE balance or `fatePerDay` for users before they stake?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""Multiple functions, including `vote`, `burnAsset`, and potentially others via `Flan.mint`, `ERC677.transferFrom`, or `ERC677.burn`, are vulnerable to reentrancy attacks. External calls are made before state updates, allowing malicious contracts to call back into the LimboDAO and manipulate the state before the original function completes.  This can be triggered via malicious ERC677 tokens or during Flan minting."",
      ""Impact"": ""Loss of funds, manipulation of fate balance, unexpected contract behavior, potential draining of assets from the contract, manipulation of proposal outcomes."",
      ""Location"": ""LimboDAO.sol: line 314 (vote), LimboDAO.sol: line 404, LimboDAO.sol:burnAsset, LimboDAO.sol:219 (convertFateToFlan)""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fate Calculation"",
      ""Severity"": ""High"",
      ""Description"": ""Calculations involving fate balances and conversions to Flan are susceptible to integer overflow or underflow, especially in `incrementFateFor` and `convertFateToFlan`, leading to incorrect balances or transaction reverts. The `(fateToFlan * fate)` calculation in `convertFateToFlan`, and `state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)` in `incrementFateFor` are particularly concerning. The `ERC20NetTransfer` also has an integer overflow issue."",
      ""Impact"": ""Incorrect fate balance, incorrect voting power, incorrect flan conversion, users receiving less flan than expected, denial of service, potential manipulation of DAO decisions."",
      ""Location"": ""LimboDAO.sol: line 153 (incrementFateFor), LimboDAO.sol, convertFateToFlan function, LimboDAO.sol:309, LimboDAO.sol:312, TransferHelper.sol:13-21""
    },
    {
      ""Issue"": ""Division by Zero Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The `setEYEBasedAssetStake` function contains a potential division by zero vulnerability if `totalSupply` is zero when calculating `eyePerUnit`. The `convertFateToFlan` also contains a potential division by zero if ONE is set to zero."",
      ""Impact"": ""Denial of service for staking and conversion."",
      ""Location"": ""function setEYEBasedAssetStake(...) public isLive incrementFate, LimboDAO.sol: `convertFateToFlan` function.""
    },
    {
      ""Issue"": ""Unchecked Return Value of ERC677 TransferFrom in burnAsset Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `burnAsset` function calls `ERC677(asset).transferFrom(sender, address(this), amount)` but doesn't check the return value of ERC20 tokens. If the transfer fails, the execution continues as if the transfer was successful, leading to inconsistent state and potential loss of funds.  The require statement is present but checking the IERC677 interface rather than ERC20. Some ERC20 tokens do not revert on failure but return false instead."",
      ""Impact"": ""Users may believe their assets have been burnt and fate created, while in reality the tokens are still in their account.  The DAO\'s internal state regarding fate balance will be incorrect."",
      ""Location"": ""LimboDAO.sol: line 404, TransferHelper.sol, ERC20NetTransfer function""
    },
    {
      ""Issue"": ""Inconsistent Fate Stake Requirement in `makeProposal`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `makeProposal` function deducts `proposalConfig.requiredFateStake * 2` from the proposer's `fateBalance`, which is twice the stated required stake. This discrepancy can lead to confusion and unexpected behavior regarding the required stake for submitting proposals and might not be enough to cover edge cases.  It could also prevent users from lodging proposals when they have the sufficient stake."",
      ""Impact"": ""Proposers may be unfairly penalized by having twice the intended amount of fate staked/deducted. This could discourage legitimate proposals or create unintended barriers to participation in governance. Proposals may be made without users staking the intended amount of fate."",
      ""Location"": ""LimboDAO.sol: line 293, LimboDAO.sol, makeProposal function""
    },
    {
      ""Issue"": ""Potential Front Running `setEYEBasedAssetStake` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setEYEBasedAssetStake` function calculates the amount of fate a user should receive based on their asset and EYE balances. An attacker could potentially front-run a call to `setEYEBasedAssetStake` by manipulating these balances, temporarily increasing the apparent EYE per unit of the asset, then quickly reversing the manipulation. This would allow them to receive more fate than they are actually entitled to."",
      ""Impact"": ""A malicious user could gain an unfair advantage in the governance system by receiving an inflated amount of fate. This could allow them to disproportionately influence voting outcomes or other DAO decisions."",
      ""Location"": ""LimboDAO.sol: line 376""
    },
    {
      ""Issue"": ""Lack of Slippage Control in Asset Transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setEYEBasedAssetStake` function transfers ERC20 tokens using the `ERC20NetTransfer` function. The `burnAsset` function also lacks slippage control. Large transfers could significantly alter the price of the asset, particularly for low-liquidity tokens, leading to unexpected losses for the user."",
      ""Impact"": ""Users could receive less fate than intended due to adverse price movements during asset transfers, especially during stake adjustments. The user adjusting their stake balance may suffer from loss of funds due to slippage when transfering low liquidity tokens to the contract. Loss of funds or denial of service in the `burnAsset` function."",
      ""Location"": ""LimboDAO.sol:setEYEBasedAssetStake, function burnAsset(address asset, uint256 amount) public isLive incrementFate, LimboDAO.sol:422""
    },
    {
      ""Issue"": ""Missing Input Validation in `setEYEBasedAssetStake`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `seed` function takes `precisionOrderOfMagnitude` as input without any input validation, which can cause integer overflows. The `setEYEBasedAssetStake` function lacks validation on the input variables leading to potential overflows or incorrect calculations of `impliedEye`, and therefore incorrect fate weights. A zero address check is also missing."",
      ""Impact"": ""Integer overflows can lead to incorrect calculations within the contract, potentially resulting in loss of funds, denial of service, or other unexpected behavior. Inaccurate fate weight calculations, potential unintended behavior in staking and voting mechanisms due to inaccurate data. Incorrect initialization of the DAO if zero addresses are passed, potentially leading to contract failure or unexpected behavior. Manipulation of users Fate weight."",
      ""Location"": ""LimboDAO.sol: line 176, LimboDAO.sol:407, LimboDAO.sol, setEYEBasedAssetStake function""
    },
    {
      ""Issue"": ""Incorrect Calculation of Implied EYE in `setEYEBasedAssetStake`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setEYEBasedAssetStake` function has issues related to calculating the implied EYE balance, especially under the `indirectTwoRootEye` strategy. Integer division precision loss and incorrect scaling can lead to inaccurate calculations. This might result in users being unable to stake assets or vote."",
      ""Impact"": ""Inaccurate fate weight calculations, potential unintended behavior in staking and voting mechanisms due to inaccurate data. Users may be unable to stake their assets due to overly strict invariant checks, leading to a poor user experience."",
      ""Location"": ""LimboDAO.sol: `setEYEBasedAssetStake` function, calculation of `impliedEye`, LimboDAO.sol:407""
    },
    {
      ""Issue"": ""Missing Input Validation in `seed` Function for LP Addresses and Zero Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `seed` function does not validate that the LP addresses are valid contract addresses or ERC20 contracts *before* calling their functions, potentially causing a denial-of-service during the seeding process.  The seed function also does not check for duplicate LP addresses. There's also no check to ensure the critical addresses are not set to the zero address which can brick the contract"",
      ""Impact"": ""Denial-of-service during contract initialization, potential unexpected behavior if invalid addresses are treated as valid contracts, the contract becomes unusable"",
      ""Location"": ""LimboDAO.sol: `seed` function, lines iterating through `sushiLPs` and `uniLPs`, LimboDAO.sol:209, LimboDAO.sol:213, LimboDAO.sol: Line 214, LimboDAO.sol:192-220, LimboDAO.sol, seed function""
    },
    {
      ""Issue"": ""Missing Access Control on `transferOwnershipOfThing` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferOwnershipOfThing` function allows transferring ownership of any Ownable contract and is only protected by the `onlySuccessfulProposal` modifier. The DAO should have tighter access control, such as being restricted to the DAO owner. Setting an extremely high or low rate can have significant economic impacts on the system."",
      ""Impact"": ""Potential takeover of crucial smart contracts, complete disruption of DAO functionality.  Potential for the governance to maliciously transfer ownership of critical contracts.  An extremely high rate would drain all fate quickly into Flan, devaluing Fate and inflating Flan. A very low rate would make fate conversion impractical."",
      ""Location"": ""LimboDAO.sol: `transferOwnershipOfThing` function, function setFateToFlan(uint256 rate) public onlySuccessfulProposal""
    },
    {
      ""Issue"": ""Stale Price Vulnerability in `burnAsset`."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `burnAsset` function calculates `impliedEye` based on the current ratio of EYE to the asset being burned. If this ratio is stale (e.g., due to manipulation in the external market), the `fateCreated` amount might be inaccurate, allowing users to mint more fate than they should have received with an accurate conversion rate."",
      ""Impact"": ""Users could potentially mint an excessive amount of fate by burning assets with a temporarily inflated value, undermining the fate creation mechanism."",
      ""Location"": ""LimboDAO.sol:440""
    },
    {
      ""Issue"": ""Potential Reentrancy in `setEYEBasedAssetStake` due to `ERC20NetTransfer`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setEYEBasedAssetStake` function uses `TransferHelper.ERC20NetTransfer` to transfer ERC20 tokens. If a malicious ERC20 token is used as the `asset`, its `transferFrom` or `transfer` function could call back into the `LimboDAO` contract before the `stakedUserAssetWeight` and `fateState` mappings are fully updated. This can lead to unexpected behavior, such as double-counting stake or manipulating balances."",
      ""Impact"": ""Malicious actors could potentially exploit the reentrancy vulnerability to manipulate their fate weight or drain assets from the contract."",
      ""Location"": ""LimboDAO.sol: Line 438, TransferHelper.sol: Lines 8-15""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow Risk in Fate Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several calculations involve `int256` for `fate` values, particularly in the `vote` function. If the accumulated `fate` exceeds the maximum or falls below the minimum value that `int256` can represent, it can lead to integer overflow or underflow, changing the proposal outcome unexpectedly."",
      ""Impact"": ""Incorrect proposal outcome, potential manipulation of the DAO\'s decisions, or denial of service."",
      ""Location"": ""LimboDAO.sol:309, LimboDAO.sol:312""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `vote` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `vote` function checks the time remaining on a proposal and attempts to extend the voting time by 2 hours if there's a vote swing (positive to negative or vice versa). However, this logic can be front-run."",
      ""Impact"": ""Manipulation of voting outcomes by front-running transactions and extending voting durations."",
      ""Location"": ""LimboDAO.sol:302, LimboDAO.sol:305""
    },
    {
      ""Issue"": ""Voting Logic Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""In the `vote` function, the code attempts to manipulate `currentProposalState.start` if the vote is cast near the end of the voting period and the vote changes the outcome from positive to negative or vice versa. This logic is flawed. It checks if the fate changes sign AND the magnitude decreases AND the time is close to the voting duration. This logic does not accomplish its intent and can cause unpredictable voting durations."",
      ""Impact"": ""Unpredictable voting durations, potential manipulation of the voting outcome, denial of service by extending voting periods indefinitely."",
      ""Location"": ""function vote(address proposal, int256 fate) public incrementFate isLive""
    },
    {
      ""Issue"": ""potential front running of vote function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `vote` checks if a proposal is close to its final voting period, and if so, the proposal voting period gets extended by two hours if the user votes in the opposition of the currently winning decision. This means that a malicious user could keep adding two hours of voting time indefinately as long as they vote in the opposing decision just before the end of the voting period."",
      ""Impact"": ""Malicious users can add indefinite voting time on proposals, therefore denying functionality of the smart contract."",
      ""Location"": ""LimboDAO.sol:256""
    },
     {
      ""Issue"": ""Inconsistent Precision Handling in `setEYEBasedAssetStake`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `setEYEBasedAssetStake`, different approaches are used to handle the `precision` factor. For directRoot FateGrowthStrategy, the finalAssetBalance should be equal to finalEYEBalance without scaling. However, for indirectTwoRootEye strategy, a division by precision (`finalEYEBalance /= precision`) is performed. This inconsistency could lead to unexpected stake calculations depending on the `FateGrowthStrategy` configuration. Furthermore, the calculation of the impliedEye balance: `uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);` contains a multiplication by ONE and then later a division by ONE * precision which simplifies to a division by precision. There isn't a need to scale by ONE and it just adds to potential overflow risk."",
      ""Impact"": ""Incorrect stake weights, leading to unfair fate distribution and voting power."",
      ""Location"": ""function setEYEBasedAssetStake(...) public isLive incrementFate""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `convertFateToFlan`"",
      ""Severity"": ""Medium"",
      ""Description"": ""While Solidity 0.8.x includes default overflow/underflow checks, the multiplication `(fateToFlan * fate)` in `convertFateToFlan` could still potentially lead to an overflow if `fateToFlan` and `fate` are sufficiently large, even though the result is then divided by `ONE`. This is especially true if `ONE` is significantly smaller than the maximum value of a uint256."",
      ""Impact"": ""Incorrect calculation of `flan` tokens due to integer overflow, potentially leading to users receiving less flan than expected."",
      ""Location"": ""LimboDAO.sol, convertFateToFlan function""
    },
    {
      ""Issue"": ""Unprotected `executeCurrentProposal` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `executeCurrentProposal` function is a public function with the `updateCurrentProposal` modifier. This is confusing and may be unintentional. A user could call this function at any time, incurring gas costs, to trigger a proposal resolution even if they have no stake in the outcome."",
      ""Impact"": ""Potential gas waste for users who unknowingly call this function expecting action beyond proposal resolution. Code readability and maintainability issues due to the function's unclear purpose."",
      ""Location"": ""LimboDAO.sol: Line 348, function executeCurrentProposal() public updateCurrentProposal {}""
    },
    {
      ""Issue"": ""Inconsistent Fate Stake Requirement in `makeProposal`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `makeProposal` function requires the proposer to have at least `proposalConfig.requiredFateStake * 2` fate to make a proposal. This stake will be refunded if the proposal succeeds. This may not be a large enough deterrent to prevent spam proposals"",
      ""Impact"": ""Proposals may be made without users staking the intended amount of fate leading to proposals being approved or denied with incorrect fate balances."",
      ""Location"": ""LimboDAO.sol: Line 306, function makeProposal(address proposal, address proposer) public updateCurrentProposal""
    },
    {
      ""Issue"": ""Incorrect Logic for Adjusting Voting Duration in `vote` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `vote` function contains logic to extend the voting period by 2 hours if a vote switches the proposal's fate from positive to negative or vice-versa within the last hour of the voting duration. However, the condition `fate * currentFate < 0 && (fate + currentFate) * fate > 0` only detects if the sign of the current fate changes after the vote. It doesn't ensure that the vote is occurring in the last hour."",
      ""Impact"": ""The voting duration might be unintentionally extended when a vote changes the fate sign outside the intended one-hour window, leading to unexpected behavior and potential manipulation of the voting process."",
      ""Location"": ""LimboDAO.sol: Lines 328-338""
    },
    {
      ""Issue"": ""Missing Check for Zero Address in `seed` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `seed` function sets critical addresses for the DAO, including the limbo, flan, eye, proposalFactory, sushiFactory, uniFactory, and flashGoverner addresses. There's no check to ensure these addresses are not set to the zero address. Setting these addresses to zero can brick the contract, rendering it unusable."",
      ""Impact"": ""If any of the critical addresses are accidentally or maliciously set to the zero address during seeding, the DAO contract will become dysfunctional."",
      ""Location"": ""LimboDAO.sol: Line 214, LimboDAO.sol:192-220, LimboDAO.sol, seed function""
    },
    {
      ""Issue"": ""Missing Input Validation in `setEYEBasedAssetStake`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `setEYEBasedAssetStake` function, specifically when `strategy == FateGrowthStrategy.indirectTwoRootEye`, the code performs a division `(eyePerUnit * finalAssetBalance) / (ONE * precision)`. It\'s important to ensure that `ONE * precision` doesn\'t equal zero to avoid division-by-zero errors."",
      ""Impact"": ""Potential division-by-zero error if `ONE * precision` is zero, halting the transaction."",
      ""Location"": ""LimboDAO.sol, setEYEBasedAssetStake function""
    },
    {
      ""Issue"": ""Imprecise EYE balance calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In the burnAsset function, the code uses a flawed calculation: `uint256 impliedEye = (eyePerUnit * amount) / ONE;`. If `amount` is sufficiently large the multiplication could overflow, or the ultimate fate created will be incorrect since the eyePerUnit value is multiplied with a scaled amount."",
      ""Impact"": ""Incorrect calculation of `fateCreated` tokens due to integer overflow, potentially leading to users receiving incorrect fate."",
      ""Location"": ""LimboDAO.sol, burnAsset function""
    },
    {
      ""Issue"": ""Unnecessary Logic in `vote` function for extending proposal duration"",
      ""Severity"": ""Low"",
      ""Description"": ""The `vote` function contains logic to extend the voting period by 2 hours if the vote changes the leading side of the proposal near the end of the voting period. The current implementation can be seen as more confusing than helpful."",
      ""Impact"": ""Potential disruption of voting mechanism, unexpected behavior, unnecessary complexity."",
      ""Location"": ""LimboDAO.sol: `vote` function.""
    },
    {
      ""Issue"": ""Time Manipulation on Proposals"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `vote` function, If users vote opposite the leading vote, the proposal time gets extended by 2 hours. This may not be a big issue, but it could still have unintended consequences as this could potentially be abused."",
      ""Impact"": ""Proposal time extended leading to potentially undesirable states in smart contract."",
      ""Location"": ""LimboDAO.sol:vote""
    },
    {
      ""Issue"": ""Missing access control on `incrementFateFor` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `incrementFateFor` function is `public` without any access control modifiers. This allows anyone to call this function and update the fate balance and last adjustment time for any user. While it only updates the balance based on existing configurations (fatePerDay), it could still be gamed by repeatedly calling it to manipulate balances right before a proposal ends."",
      ""Impact"": ""Potential manipulation of user's Fate balance, leading to voting influence, or asset conversions. Not directly a vulnerability but could be used to amplify other potential exploitable areas."",
      ""Location"": ""LimboDAO.sol:incrementFateFor, LimboDAO.sol:153""
    },
    {
      ""Issue"": ""Lack of slippage control in `setEYEBasedAssetStake` during asset transfer."",
      ""Severity"": ""Low"",
      ""Description"": ""When the user adjusts their EYE based asset stake through the `setEYEBasedAssetStake` function the user needs to transfer some assets to the contract through `asset.ERC20NetTransfer(sender, address(this), netBalance)`. If the assets are low liquidity tokens, then there may be severe slippage on this transfer causing an economic loss to the user."",
      ""Impact"": ""The user adjusting their stake balance may suffer from loss of funds due to slippage when transfering low liquidity tokens to the contract."",
      ""Location"": ""LimboDAO.sol:422""
    },
    {
      ""Issue"": ""Inconsistent Fate Stake Requirement"",
      ""Severity"": ""Low"",
      ""Description"": ""The `makeProposal` function requires `fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;`. The intended purpose of this requirement isn't explicitly clear. This could be a bug, since it costs twice the required fate stake amount. This could affect how often users propose new proposals, and unintentionally restricts it to top fate holders."",
      ""Impact"": ""Higher barrier of entry to create a proposal."",
      ""Location"": ""LimboDAO.sol:makeProposal, LimboDAO.sol:234""
    },
    {
      ""Issue"": ""Unbounded Array Iteration in `seed` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `seed` function iterates through `sushiLPs` and `uniLPs` arrays. If very large arrays are passed, the gas cost of the `seed` function might exceed the block gas limit, causing the transaction to fail. This is technically a denial of service."",
      ""Impact"": ""Denial of service during initial seeding."",
      ""Location"": ""function seed(...) public onlyOwner""
    },
    {
      ""Issue"": ""Potential Rounding Errors in `convertFateToFlan`"",
      ""Severity"": ""Low"",
      ""Description"": ""The conversion of fate to flan in the `convertFateToFlan` function involves division, which can lead to rounding errors. This could result in users receiving slightly less Flan than expected, especially when converting small amounts of fate. The difference, while small, can accumulate over time and impact users\' balances."",
      ""Impact"": ""Minor loss of value for users converting fate to flan."",
      ""Location"": ""LimboDAO.sol:261""
    },
    {
      ""Issue"": ""Insufficient Fate Stake Required for Proposals"",
      ""Severity"": ""Low"",
      ""Description"": ""The `makeProposal` function requires the proposer to lock up `proposalConfig.requiredFateStake * 2`. The stake will be refunded if the proposal succeeds. The current value of `requiredFateStake` is 223 ether in the `seed` function. This may not be a large enough deterrent to prevent spam proposals, especially if the potential benefits of a malicious proposal outweigh the cost of the stake. Also the proposer stake is refunded on success and no mention of stake for failure."",
      ""Impact"": ""Potential for spam proposals, flooding the governance system and hindering legitimate proposals."",
      ""Location"": ""function makeProposal(address proposal, address proposer) public updateCurrentProposal""
    }
  ],
  ""IssueNumber"": 77,
  ""OutputList"": 30
}",257.7485728263855,3386.0,32.0,"### **Output**

---

**[H-07] LP pricing formula is vulnerable to flashloan manipulation**

**Report Description**:  
The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more `fate` than they are supposed to with a relatively low cost. With the large portion of `fate` they receive, they can gain more voting power to influence the system's decisions or convert their `fate` to Flan tokens for direct profit.

**Match in Response List**:  
Matches with the issue titled **""Stale Price Vulnerability in `burnAsset`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of stale prices in the `burnAsset` function, which is related to the vulnerability described in the issue. However, it does not explicitly mention flashloan manipulation as the root cause or the potential for attackers to inflate LP token values. The response focuses on stale prices due to external market manipulation but misses the specific mechanism (flashloan) and its broader impact on the system's governance and token economics.

---

**[M-04] The system can get to a ""stuck"" state if a bad proposal (proposal that can't be executed) is accepted**

**Report Description**:  
The `LimboDAO` contract has a variable that indicates the current proposal, and only one proposal can exist at a time. A proposal can only be replaced if the previous proposal is either accepted and executed or rejected. If a proposal that cannot succeed (e.g., an `UpdateMultipleSoulConfigProposal` with insufficient gas or tokens) is accepted, the system will become stuck. This is because the proposal's time will pass, preventing users from voting (the `vote` function will revert), and the proposal cannot be executed (the `execute` function will revert). As a result, the proposal cannot be completed, and new proposals cannot be registered.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of the system becoming stuck due to a bad proposal. This is a critical oversight, as the issue describes a significant denial-of-service vulnerability that could render the entire DAO inoperable. The response list focuses on other vulnerabilities (e.g., reentrancy, integer overflows, and access control) but does not cover this specific scenario.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-07] LP pricing formula is vulnerable to flashloan manipulation**

**Missed Issues from Issue Report**:  
- **[M-04] The system can get to a ""stuck"" state if a bad proposal (proposal that can't be executed) is accepted**

--- 

### **Analysis of Gaps**  
The response list covers a wide range of vulnerabilities but misses critical issues like the system becoming stuck due to bad proposals. Additionally, while it partially addresses the flashloan manipulation issue, it does not fully capture the mechanism or its broader implications. These gaps highlight the need for a more comprehensive review of the contract's governance and proposal execution logic.","```
None.
```",The **Average Precision (AP)** for the query is **0.0**.
Limbo.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
// import ""hardhat/console.sol"";
import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}",7824,631,"[M-10] user won't be able to get his rewards in case of staking with amount = 0

Submitted by CertoraInc, also found by Randyyy
Limbo.sol (stake() function)

If a user has a pending reward and he calls the stake function with amount = 0, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)
That's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward
",1,,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./facades/LimboDAOLike.sol"";
import ""./facades/Burnable.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./facades/FlanLike.sol"";
import ""./facades/UniPairLike.sol"";
import ""./facades/MigratorLike.sol"";
import ""./facades/AMMHelper.sol"";
import ""./facades/AngbandLike.sol"";
import ""./facades/LimboAddTokenToBehodlerPowerLike.sol"";
import ""./DAO/Governable.sol"";
import ""./facades/FlashGovernanceArbiterLike.sol"";


enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, 
  perpetual 
}



struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; 
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; 
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; 
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; 
  uint256 initialCrossingBonus; 
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; 
  uint256 crossingMigrationDelay; 
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; 
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), ""E8"");

    
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), ""E9"");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}





contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; 
  bool protocolEnabled = true;

  
  CrossingConfig public crossingConfig;

  
  
  mapping(address => mapping(uint256 => Soul)) public souls;

  
  mapping(address => uint256) public latestIndex;

  
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, ""EF"");
    _;
  }

  
  
  
  
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EI"");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, ""E1"");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor 
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, ""E6"");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  
  
  
  
  
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  
  
  
  
  
  
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  
  
  
  
  
  
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  
  
  
  
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; 
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  
  
  
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  
  
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, ""E2"");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, ""E4"");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  
  
  
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  
  
  
  
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, ""E2"");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, ""E5"");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, ""E6"");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, ""ED"");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, ""E7"");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  
  
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, ""EB"");
    require(soul.state == SoulState.waitingToCross, ""E2"");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      ""EC""
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; 
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}",3769,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Governance"",
      ""Tasks"": [
        ""Verify the proper functioning of the `governanceApproved`, `onlySuccessfulProposal`, and `onlySoulUpdateProposal` modifiers across all functions they are applied to."",
        ""Analyze the implementation of the `Governable` contract to understand the proposal and voting mechanism. Verify that the DAO address is correctly initialized and used for access control."",
        ""Investigate the specific checks performed within the governance modifiers to ensure that only authorized actions are permitted."",
        ""Assess the potential impact of a compromised DAO on the `Limbo` contract's functionality and funds."",
        ""Evaluate the role of `FlashGovernanceArbiterLike` in enforcing tolerance limits. Determine the default tolerance levels and assess their appropriateness."",
        ""Check for any instances where governance-controlled functions could be front-run or manipulated to the detriment of users."",
        ""Verify that the `LimboDAO` address is a multisig or a well-established DAO with a robust governance process.""
      ]
    },
    {
      ""Area"": ""Reward Distribution and Accounting"",
      ""Tasks"": [
        ""Carefully review the reward calculation logic in the `updateSoul` function to ensure accuracy and prevent rounding errors that could lead to unfair distribution."",
        ""Analyze the `getPending` function and verify its accuracy in calculating pending rewards for users."",
        ""Check for potential integer overflows or underflows in the reward calculation and distribution process."",
        ""Verify that the `rewardDebt` mechanism correctly tracks and updates user reward debt."",
        ""Assess the potential for manipulation of the `accumulatedFlanPerShare` variable and its impact on reward distribution."",
        ""Examine the `claimReward` function to ensure that users can only claim rewards they are entitled to and that rewards are distributed fairly."",
        ""Investigate the interaction between staking, unstaking, and reward claiming to identify any potential vulnerabilities or inconsistencies."",
        ""Analyze the impact of changing `flanPerSecond` on reward distribution and fairness to stakers."",
        ""Review gas costs for staking and unstaking. Optimize for user experience.""
      ]
    },
    {
      ""Area"": ""Migration Process and External Interactions"",
      ""Tasks"": [
        ""Thoroughly examine the `migrate` function and its interactions with external contracts (Behodler, Angband, AMMHelper, MorgothPower)."",
        ""Verify the correctness of the `RectangleOfFairness` calculation and its role in the migration process. Understand the rationale behind the inflation factor and its potential impact."",
        ""Assess the security risks associated with transferring tokens to external contracts during migration and ensure proper error handling."",
        ""Investigate the specific functions performed by `AngbandLike.executePower` and `LimboAddTokenToBehodlerPowerLike.parameterize` during migration to identify potential vulnerabilities."",
        ""Analyze the logic for burning excess SCX and minting new liquidity pool tokens during migration. Verify that these actions are performed securely and fairly."",
        ""Check for potential reentrancy vulnerabilities in the `migrate` function, particularly when interacting with external contracts."",
        ""Assess the potential impact of a failed migration on the `Limbo` contract and user funds."",
        ""Verify that all external contract calls are properly checked for success and that appropriate error handling is implemented."",
        ""Confirm that the balances used in migration are calculated before transferring to external contracts to prevent manipulation of the balances during the process.""
      ]
    },
    {
      ""Area"": ""Soul State Management and Configuration"",
      ""Tasks"": [
        ""Carefully examine the state transition logic within the `configureSoul` function and ensure that souls transition between states correctly."",
        ""Verify that the `latestIndex` variable is correctly updated and used to track the current soul configuration for each token."",
        ""Assess the potential for manipulation of the `latestIndex` variable and its impact on soul configuration and user interactions."",
        ""Investigate the conditions under which a soul can transition back to the `calibration` state and the potential consequences."",
        ""Analyze the interaction between the `configureSoul` and `configureCrossingParameters` functions and ensure that they are properly synchronized."",
        ""Check that the timestamp values used for `stakingBeginsTimestamp` and `stakingEndsTimestamp` are accurate and consistent."",
        ""Verify the proper use of `SoulType` and `SoulState` enums and their impact on contract logic."",
        ""Review the logic that checks for the `crossingThreshold` and moves the `Soul` to the `waitingToCross` state."",
        ""Analyze potential consequences of setting `stakingEndsTimestamp` retroactively when falling back to `calibration`.""
      ]
    },
    {
      ""Area"": ""Unstake Approval Mechanism"",
      ""Tasks"": [
        ""Verify the correct implementation of the `approveUnstake`, `unstakeFor`, and `_unstake` functions."",
        ""Ensure that the `unstakeApproval` mapping is updated correctly when approvals are granted and revoked."",
        ""Assess the potential for unauthorized unstaking and ensure that only approved unstakers can withdraw funds on behalf of holders."",
        ""Check for potential vulnerabilities in the approval mechanism, such as replay attacks or double spending."",
        ""Confirm that the `unstakeApproval` amounts are correctly decremented upon unstaking.""
      ]
    },
    {
      ""Area"": ""Denial of Service (DoS) Considerations"",
      ""Tasks"": [
        ""Analyze potential DoS attack vectors, such as excessive gas consumption in critical functions."",
        ""Review the potential for griefing attacks, where malicious actors could prevent legitimate users from interacting with the contract."",
        ""Assess the impact of large token balances on gas costs and potential DoS vulnerabilities."",
        ""Check for potential DoS vulnerabilities related to large number of users or tokens."",
        ""Verify the gas limits for staking and unstaking and if there are any potential out-of-gas errors for regular users.""
      ]
    },
    {
      ""Area"": ""Bonus Claiming Logic"",
      ""Tasks"": [
        ""Analyze the `claimBonus` function and verify the logic for calculating the FLAN bonus."",
        ""Ensure that the bonus is calculated correctly based on the staking duration, initial crossing bonus, and crossing bonus delta."",
        ""Check for potential vulnerabilities in the bonus claiming process, such as double claiming or manipulation of bonus parameters."",
        ""Verify that the `bonusPaid` flag is correctly set to prevent users from claiming the bonus multiple times."",
        ""Assess potential for integer overflow/underflow in bonus calculations particularly concerning `int256 accumulatedFlanPerTeraToken` and `int256 finalFlanPerTeraToken`.""
      ]
    },
    {
      ""Area"": ""Protocol Enable/Disable Functionality"",
      ""Tasks"": [
        ""Verify the proper functioning of the `disableProtocol` and `enableProtocol` functions."",
        ""Assess the potential impact of disabling the protocol on user funds and staking positions."",
        ""Ensure that only authorized actors can disable or enable the protocol."",
        ""Check for any unintended consequences of disabling the protocol, such as preventing users from unstaking their tokens.""
      ]
    },
    {
      ""Area"": ""Error Handling"",
      ""Tasks"": [
        ""Review all require statements and custom errors to verify they provide adequate safety and are easily understandable by users."",
        ""Confirm all state-changing functions revert in exceptional conditions and that such conditions are well-documented."",
        ""Assess the use of `SafeERC20` and confirm it's correctly applied across all ERC20 interactions.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas costs for critical functions, particularly staking, unstaking, claiming rewards, and migration."",
        ""Identify potential areas for gas optimization, such as reducing storage reads/writes, using more efficient data structures, or optimizing loop iterations."",
        ""Consider using calldata instead of memory for function parameters where appropriate."",
        ""Explore opportunities to reduce the contract's overall code size to minimize deployment costs.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `Limbo` manages staking pools ('souls') for various tokens. Users stake tokens to earn FLAN rewards. Souls have different states (calibration, staking, waitingToCross, crossedOver) and types (threshold, perpetual). Threshold souls, upon reaching a certain staked amount, can transition to a state allowing migration. The migration process involves interacting with several external contracts (Behodler, Angband, AMMHelper, MorgothPower) to potentially list the token on Behodler and create liquidity pool tokens. The contract uses a reward-per-share mechanism for FLAN distribution and includes a bonus system claimable after a soul crosses over or is waiting. Governance controls sensitive configuration functions, and a flash governance arbiter imposes tolerance limits on parameter changes. An unstake approval mechanism allows third-party unstaking."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Limbo"",
    ""Purpose"": ""To provide a flexible staking platform (for 'souls' representing tokens) with FLAN rewards, potentially leading to token migration and integration into the Behodler ecosystem."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Governable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""./facades/LimboDAOLike.sol"",
        ""./facades/Burnable.sol"",
        ""./facades/BehodlerLike.sol"",
        ""./facades/FlanLike.sol"",
        ""./facades/UniPairLike.sol"",
        ""./facades/MigratorLike.sol"",
        ""./facades/AMMHelper.sol"",
        ""./facades/AngbandLike.sol"",
        ""./facades/LimboAddTokenToBehodlerPowerLike.sol"",
        ""./DAO/Governable.sol"",
        ""./facades/FlashGovernanceArbiterLike.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""TERA"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""A constant (1E12) likely used for fixed-point arithmetic in reward calculations.""
      },
      {
        ""Name"": ""RectangleOfFairness"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""A constant (30 ether) used as a base value in the migration process, potentially related to initial liquidity or SCX minting.""
      },
      {
        ""Name"": ""protocolEnabled"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to enable/disable core staking/unstaking functions.""
      },
      {
        ""Name"": ""crossingConfig"",
        ""Type"": ""CrossingConfig"",
        ""Purpose"": ""Struct holding configuration parameters related to the token migration process (Behodler address, fees, delays, related contracts).""
      },
      {
        ""Name"": ""souls"",
        ""Type"": ""mapping(address => mapping(uint256 => Soul))"",
        ""Purpose"": ""Stores the state (Soul struct) for each token address at a specific index.""
      },
      {
        ""Name"": ""latestIndex"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Tracks the current active index for each token's soul configuration.""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(address => mapping(address => mapping(uint256 => User)))"",
        ""Purpose"": ""Stores user-specific staking data (amount staked, reward debt, bonus status) per token, per user, per index.""
      },
      {
        ""Name"": ""tokenCrossingParameters"",
        ""Type"": ""mapping(address => mapping(uint256 => CrossingParameters))"",
        ""Purpose"": ""Stores parameters related to the crossing/migration process for each token at a specific index.""
      },
      {
        ""Name"": ""unstakeApproval"",
        ""Type"": ""mapping(address => mapping(address => mapping(address => uint256)))"",
        ""Purpose"": ""Stores allowances for third-party unstaking (token => holder => unstaker => amount).""
      },
      {
        ""Name"": ""Flan"",
        ""Type"": ""FlanLike"",
        ""Purpose"": ""Reference to the FLAN ERC20 token contract used for rewards.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""enabled"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Requires `protocolEnabled` to be true."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with FLAN address and DAO address (for Governable)."",
        ""Parameters"": [
          ""address flan"",
          ""address limboDAO""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""attemptToTargetAPY"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adjusts the `flanPerSecond` for a threshold soul to target a desired APY (governance controlled, uses AMMHelper)."",
        ""Parameters"": [
          ""address token"",
          ""uint256 desiredAPY"",
          ""uint256 daiThreshold""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateSoul (public)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates reward variables for the current soul of a token."",
        ""Parameters"": [
          ""address token""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateSoul (internal)"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Core logic to calculate and update accumulated rewards per share based on time elapsed and `flanPerSecond`."",
        ""Parameters"": [
          ""address token"",
          ""Soul storage soul""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""configureCrossingConfig"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets parameters within the `crossingConfig` struct (governance controlled)."",
        ""Parameters"": [
          ""address behodler"",
          ""address angband"",
          ""address ammHelper"",
          ""address morgothPower"",
          ""uint256 migrationInvocationReward"",
          ""uint256 crossingMigrationDelay"",
          ""uint16 rectInflationFactor""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""disableProtocol"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets `protocolEnabled` to false (governance controlled)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""enableProtocol"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets `protocolEnabled` to true (governance controlled)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""adjustSoul"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adjusts `flanPerSecond` and crossing bonus parameters for the current soul (governance controlled, uses flashGoverner)."",
        ""Parameters"": [
          ""address token"",
          ""uint256 initialCrossingBonus"",
          ""int256 crossingBonusDelta"",
          ""uint256 fps""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""configureSoul"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures or updates a soul for a given token and index, potentially incrementing `latestIndex` (governance controlled via `onlySoulUpdateProposal`)."",
        ""Parameters"": [
          ""address token"",
          ""uint256 crossingThreshold"",
          ""uint256 soulType"",
          ""uint256 state"",
          ""uint256 index"",
          ""uint256 fps""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""configureCrossingParameters"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures crossing parameters (bonus, burnable, threshold) for the current soul (governance controlled, uses flashGoverner)."",
        ""Parameters"": [
          ""address token"",
          ""uint256 initialCrossingBonus"",
          ""int256 crossingBonusDelta"",
          ""bool burnable"",
          ""uint256 crossingThreshold""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""stake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to stake tokens into a soul currently in the 'staking' state."",
        ""Parameters"": [
          ""address token"",
          ""uint256 amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""unstake"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to unstake their own tokens."",
        ""Parameters"": [
          ""address token"",
          ""uint256 amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""unstakeFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows an approved address to unstake tokens on behalf of a holder."",
        ""Parameters"": [
          ""address token"",
          ""uint256 amount"",
          ""address holder""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_unstake"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic for handling unstaking, transferring tokens, and updating rewards."",
        ""Parameters"": [
          ""address token"",
          ""uint256 amount"",
          ""address unstaker"",
          ""address holder""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""claimReward"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to claim their pending FLAN rewards for a specific soul index."",
        ""Parameters"": [
          ""address token"",
          ""uint256 index""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""claimBonus"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to claim a one-time FLAN bonus after a soul has crossed over or is waiting to cross."",
        ""Parameters"": [
          ""address token"",
          ""uint256 index""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""claimSecondaryRewards"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows anyone to transfer residual tokens (after migration or if in calibration) to AMMHelper to buy and burn FLAN."",
        ""Parameters"": [
          ""address token""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""migrate"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initiates the migration process for a threshold soul that is 'waitingToCross', interacting with external contracts."",
        ""Parameters"": [
          ""address token""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""approveUnstake"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a token holder to approve another address to unstake on their behalf."",
        ""Parameters"": [
          ""address soul"",
          ""address unstaker"",
          ""uint256 amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""rewardAdjustDebt"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Mints FLAN reward to the recipient and updates their reward debt."",
        ""Parameters"": [
          ""address recipient"",
          ""uint256 pending"",
          ""uint256 accumulatedFlanPerShare"",
          ""User storage user""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""currentSoul"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Returns a storage pointer to the soul struct for the latest index of a token."",
        ""Parameters"": [
          ""address token""
        ],
        ""Returns"": [
          ""Soul storage""
        ]
      },
      {
        ""Name"": ""getPending"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the pending FLAN reward for a user based on their stake and reward debt."",
        ""Parameters"": [
          ""User memory user"",
          ""Soul memory soul""
        ],
        ""Returns"": [
          ""uint256""
        ]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""FlanLike (FLAN): Minting rewards."",
    ""IERC20 (Staked Token): Transferring tokens (stake, unstake, migrate), checking balances."",
    ""Governable / LimboDAOLike: Access control via modifiers (`governanceApproved`, `onlySuccessfulProposal`, `onlySoulUpdateProposal`)."",
    ""FlashGovernanceArbiterLike: Enforcing tolerance limits on parameter changes (`enforceTolerance`, `enforceToleranceInt`)."",
    ""AMMHelper: Calculating APY/FPS, stabilizing FLAN post-migration, buying/burning FLAN with secondary rewards."",
    ""BehodlerLike: Burning excess SCX, receiving SCX for stabilization during migration."",
    ""AngbandLike: Executing Morgoth power during migration."",
    ""LimboAddTokenToBehodlerPowerLike: Parameterizing and receiving tokens during migration."",
    ""SafeERC20: Used for safe ERC20 transfers.""
  ],
  ""SpecialMechanisms"": [
    ""Soul Lifecycle Management: Uses `SoulState` enum and associated logic to manage different phases of staking pools."",
    ""Reward Distribution: Employs a reward-per-share mechanism (`accumulatedFlanPerShare`) for efficient FLAN distribution."",
    ""Token Migration Pathway: Includes a complex `migrate` function orchestrating interactions with multiple external contracts (Behodler ecosystem) for potential token listing and LP creation."",
    ""Governance Integration: Uses `Governable` for role-based access control and `FlashGovernanceArbiterLike` for change control on parameters."",
    ""Staking Bonus: Offers an additional bonus (`claimBonus`) calculated based on staking duration and configurable parameters."",
    ""Third-Party Unstaking: Allows delegation of unstaking via `approveUnstake` and `unstakeFor`."",
    ""Rectangle of Fairness: A concept applied during migration to adjust the amount of SCX used for liquidity stabilization, potentially preventing excessive dilution or ensuring a minimum liquidity level."",
    ""Soul Indexing: Uses an index (`latestIndex`) for each token, allowing configurations to potentially evolve over time.""
  ],
  ""Questions"": [
    ""What is the exact mechanism and purpose of the 'Rectangle of Fairness' and its inflation factor during migration?"",
    ""What are the specific functions performed by `AngbandLike.executePower` and `LimboAddTokenToBehodlerPowerLike.parameterize` during migration?"",
    ""What are the default tolerance levels enforced by `FlashGovernanceArbiterLike`?"",
    ""How is the `latestIndex` intended to be used? Can users still interact (claim rewards/bonus) with past indices? What prevents index manipulation?"",
    ""Under what exact conditions does `claimSecondaryRewards` become relevant? Does it handle failed migrations or non-migrating souls?"",
    ""Are there potential reentrancy vulnerabilities, particularly in functions involving reward calculation/minting followed by state updates (`claimReward`, `claimBonus`, `stake`, `_unstake`)?"",
    ""Why is `crossingBonusDelta` an `int256`? What scenarios lead to a negative delta?"",
    ""What is the relationship between `Limbo`, `Behodler`, `Angband`, `MorgothPower`, and the `AMMHelper`? How do they form a cohesive system?"",
    ""What is SCX and how is it generated/used in the context of Behodler and the migration process?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in multiple functions"",
      ""Severity"": ""High"",
      ""Description"": ""The contract makes external calls to `Flan.mint` in `stake`, `unstake`, `claimReward`, and `claimBonus`, and to `IERC20(token).safeTransfer` within `stake`, `unstake`, and `claimSecondaryRewards` before updating the internal state. If the `Flan` contract or the ERC20 token implements a malicious fallback function or a reentrant function, it could call back into the `Limbo` contract before the original function completes, potentially leading to unexpected state changes and fund manipulation."",
      ""Impact"": ""An attacker could exploit a reentrancy vulnerability to drain funds from the contract or manipulate user balances."",
      ""Location"": ""`stake`, `unstake`, `claimReward`, `claimBonus`, `claimSecondaryRewards`, `migrate`, `Limbo.sol:_unstake function`, `Limbo.sol:436`""
    },
    {
      ""Issue"": ""Missing Access Control on `approveUnstake` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `approveUnstake` function allows any address to set the `unstakeApproval` for another user. This is dangerous because any malicious user can set the allowance for any user, potentially leading to unintended or malicious unstaking actions."",
      ""Impact"": ""Unauthorized unstaking, potential loss of funds for stakers. Funds could be stolen by arbitrary addresses."",
      ""Location"": ""`approveUnstake` function, `Limbo.sol`""
    },
    {
      ""Issue"": ""Incorrect Usage of `enforceTolerance` for Signed Integers in `CrossingLib.set()` and `Limbo.adjustSoul()`"",
      ""Severity"": ""High"",
      ""Description"": ""The `enforceTolerance()` function in `CrossingLib.set()` is being used on both unsigned `initialCrossingBonus` and signed `crossingBonusDelta` integers after being cast to an unsigned integer. For negative values of `crossingBonusDelta`, the cast to `uint256` will result in a very large positive number. The check will therefore always fail, preventing any updates to `crossingBonusDelta` if the new value is negative. This defeats the entire purpose of the `enforceTolerance` check and might prevent the contract from functioning as expected."",
      ""Impact"": ""Inability to update the `crossingBonusDelta` parameter to negative values, leading to incorrect bonus calculations and potential disruption of the contract\'s functionality. This can lead to governance deadlocks when trying to modify the delta."",
      ""Location"": ""Limbo.sol:82-83, Limbo.sol:277-281""
    },
    {
      ""Issue"": ""Lack of Reentrancy Protection in `stake` and `unstake`"",
      ""Severity"": ""High"",
      ""Description"": ""The `stake` and `unstake` functions interact with external ERC20 contracts via `safeTransferFrom` and `safeTransfer`.  If a malicious ERC20 token is staked, the `safeTransferFrom` call in `stake` could trigger a reentrancy attack back into the `stake` function. Similarly, a reentrancy attack on `safeTransfer` is possible in `unstake`. This could allow an attacker to manipulate balances or other state variables within the contract."",
      ""Impact"": ""Complete compromise of contract state, theft of funds, or denial of service."",
      ""Location"": ""Limbo.sol:stake, Limbo.sol:unstake""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in bonus calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Calculations involving `accumulatedFlanPerShare`, `stakedAmount`, `crossingBonusDelta`, and time differences are susceptible to integer overflow or underflow.  Specifically, in the `updateSoul` function, the multiplication of `(finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond` could overflow. Similarly, the calculation of `accumulatedFlanPerTeraToken` as `crossing.crossingBonusDelta * (crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp)` in `claimBonus` can lead to overflow or underflow. Although Solidity 0.8.4 includes overflow/underflow checks, large values in conjunction with `int256` in `CrossingParameters` can still introduce underflow if `crossingBonusDelta` is sufficiently negative."",
      ""Impact"": ""Incorrect reward distribution, potential loss of funds for stakers, manipulation of the system, or denial of service."",
      ""Location"": ""`updateSoul`, `getPending`, `claimBonus`, usage of int256 in `CrossingParameters`, `Limbo.sol:claimBonus`""
    },
    {
      ""Issue"": ""Centralization Risk: Over-Reliance on Governance"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract heavily relies on governance for critical functions, including configuring crossing parameters, adjusting soul parameters, enabling/disabling the protocol, and setting up the initial crossing configuration. A compromised governance process or a malicious governance actor could severely impact the contract\'s functionality and the funds of its users."",
      ""Impact"": ""The DAO could maliciously or accidentally configure the contract in a way that harms users, such as setting unfair crossing parameters or disabling the protocol indefinitely. While the `enforceTolerance` checks aim to mitigate extreme parameter changes, a coordinated attack could still bypass these measures over time."",
      ""Location"": ""Functions using `governanceApproved` and `onlySuccessfulProposal` modifiers: `configureCrossingConfig`, `disableProtocol`, `enableProtocol`, `adjustSoul`, `configureCrossingParameters`, `attemptToTargetAPY`""
    },
    {
      ""Issue"": ""Unbounded `latestIndex` increment in `configureSoul` can lead to DoS"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `configureSoul` function increments `latestIndex[token]` based on `index > latestIndex[token]`. If the `index` parameter provided by governance is significantly large on multiple calls, it can cause `latestIndex[token]` to grow excessively. This could lead to increased gas costs for accessing `souls[token][latestIndex[token]]` and `tokenCrossingParameters[token][latestIndex[token]]` in subsequent calls, potentially causing a denial-of-service (DoS) due to exceeding block gas limits, especially when iterating over multiple tokens."",
      ""Impact"": ""Potential denial-of-service by exhausting gas limits, making the contract unusable or very expensive to interact with. Also, unbounded `latestIndex` increment in `configureSoul` can lead to storage exhaustion."",
      ""Location"": ""Limbo.sol: `configureSoul` function""
    },
    {
      ""Issue"": ""Inconsistent State Management during Soul Configuration"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `configureSoul` function, `latestIndex` is incremented *before* modifying the soul\'s state. If the configuration transaction fails after the index is incremented but before the soul\'s state is properly set, the `latestIndex` will be out of sync with the actual soul state. This can create inconsistent or unexpected behavior. In the fallingBack scenario, this creates a race condition as the timestamp is immediately set on the new soul, and not on the soul that was active during the stake."",
      ""Impact"": ""Potentially corrupts the soul\'s configuration, leading to incorrect reward calculations, inability to stake/unstake, and other unexpected behavior."",
      ""Location"": ""`configureSoul` function, `Limbo.sol`""
    },
    {
      ""Issue"": ""Unbounded Loop or High Gas Usage in `migrate` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `migrate` function transfers tokens to `crossingConfig.morgothPower`, executes a power on `crossingConfig.angband`, burns excess SCX, and then transfers SCX to `crossingConfig.ammHelper`. The potential for high gas usage exists, particularly if `AngbandLike(crossingConfig.angband).executePower` or `AMMHelper(crossingConfig.ammHelper).stabilizeFlan` perform complex or unbounded operations. Additionally, potential for DoS in `migrate` function due to `require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), \""E8\"")` if Behodler contract reverts."",
      ""Impact"": ""The `migrate` function could run out of gas, preventing users from migrating their tokens. The cost of running the migration can be prohibitive for users. Or Migration process can be halted indefinitely if the `BehodlerLike.burn()` function fails, contract may become unusable."",
      ""Location"": ""`migrate`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in Governance Actions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions (`attemptToTargetAPY`, `adjustSoul`, `configureCrossingParameters`) are protected by `governanceApproved(false)` and `governanceApproved`. This implies that external governance proposals are used to modify critical parameters. A front-runner could observe a governance proposal and execute a transaction before the proposal is enacted, potentially manipulating the state of the contract to their advantage before the intended changes take effect."",
      ""Impact"": ""Adverse manipulation of contract state or financial advantage gained by an attacker front-running governance proposals. Unexpected changes to `flanPerSecond`, potentially benefiting a malicious actor at the expense of other users. Or manipulate crucial configuration parameters before a legitimate governance proposal is executed, potentially leading to financial losses for users."",
      ""Location"": ""`attemptToTargetAPY` function, `Limbo.sol`, `adjustSoul` function, `Limbo.sol`; `configureCrossingParameters` function, `Limbo.sol`""
    },
    {
      ""Issue"": ""Lack of slippage control in claimSecondaryRewards()"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `claimSecondaryRewards` function transfers the token balance held by the contract to the `AMMHelper` contract and calls the `buyFlanAndBurn` function. This function performs a swap and burn operation, but there is no slippage control implemented. An attacker could manipulate the market to cause a large slippage during the swap, resulting in a significantly lower amount of FLAN being received by the user. The function also has a re-entrancy vulnerability."",
      ""Impact"": ""Users may receive less FLAN than expected when claiming secondary rewards, leading to financial loss and potential front-running attacks. Potential for malicious contracts to exploit the reentrancy vulnerability to drain funds or disrupt contract functionality."",
      ""Location"": ""Limbo.sol:433-436""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `MigrationLib.migrate` adjustedRectangle calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `MigrationLib.migrate` function, the adjustedRectangle is calculated as `((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;`. If `crossingConfig.rectangleOfFairnessInflationFactor` is significantly large and `RectangleOfFairness` is also large, the multiplication could result in an integer overflow leading to incorrect burning of SCX."",
      ""Impact"": ""Incorrect calculation of `adjustedRectangle` could lead to incorrect `excessSCX` value and consequently burning of the wrong amount of `scxMinted`, potentially disrupting the intended tokenomics or causing loss of funds. Also, there's Lack of input validation for `rectInflationFactor` which can lead to similar consequences."",
      ""Location"": ""MigrationLib.sol#L90, Limbo.sol:configureCrossingConfig function, Limbo.sol:MigrationLib.migrate function""
    },
    {
      ""Issue"": ""Missing Access Control in `unstakeFor` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `unstakeFor` function allows any address to unstake tokens on behalf of another address, provided that the unstaker has approval via `approveUnstake`. This creates a potential vulnerability where a malicious actor, having gained approval from a victim, could trigger the unstaking process without the holder\'s immediate knowledge or consent."",
      ""Impact"": ""A malicious unstaker, with prior approval, could unstake tokens from a legitimate holder, potentially leading to loss of funds or disruption of staking strategies."" ,
      ""Location"": ""`unstakeFor`, `approveUnstake`""
    },
    {
      ""Issue"": ""Potential Stale Data in `claimBonus` Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `claimBonus` function, the `accumulatedFlanPerTeraToken` is calculated based on `crossing.crossingBonusDelta` and the difference between `crossing.stakingEndsTimestamp` and `crossing.stakingBeginsTimestamp`. If these timestamps are manipulated or become stale (e.g., through unexpected state transitions or governance changes), the calculated bonus might be inaccurate or unfair. "",
      ""Impact"": ""Inaccurate bonus calculations could lead to unfair reward distribution and dissatisfaction among stakers. Malicious actors might attempt to manipulate timestamps to maximize their bonus at the expense of other stakers."",
      ""Location"": ""Limbo.sol#L409""
    },
    {
      ""Issue"": ""Missing Input Validation in `configureCrossingConfig`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `configureCrossingConfig` function lacks input validation for several key parameters, potentially causing issues with the protocol\'s logic. While `rectInflationFactor` has a check ensuring it's <= 10000, other crucial addresses like `behodler`, `angband`, `ammHelper`, and `morgothPower` are not validated to ensure they are non-zero addresses. Using the zero address for any of these would lead to contract execution failing or undefined behaviour when interacting with these addresses."",
      ""Impact"": ""Potential for contract failures and unexpected behavior if invalid addresses are configured, leading to governance proposals creating an unserviceable contract."",
      ""Location"": ""Limbo.sol: `configureCrossingConfig` function""
    },
        {
      ""Issue"": ""Potential Division by Zero in `updateSoul` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `updateSoul` function, the balance could become zero between the check and the calculation of flanReward, leading to a division by zero error."",
      ""Impact"": ""Transaction failure, denial of service."",
      ""Location"": ""`updateSoul` function""
    },
        {
      ""Issue"": ""Potential Front-Running Vulnerability in `attemptToTargetAPY`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `attemptToTargetAPY` function adjusts the `flanPerSecond` of a `threshold` soul based on a desired APY and DAI threshold. A malicious actor could monitor the mempool for transactions calling this function and front-run them."",
      ""Impact"": ""Unexpected changes to `flanPerSecond`, potentially benefiting a malicious actor at the expense of other users."",
      ""Location"": ""`attemptToTargetAPY` function, `Limbo.sol`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `configureSoul` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `configureSoul` function updates the `Soul` struct\'s state and other parameters based on governance proposals. If an attacker can predict the parameters of an upcoming proposal, they could front-run the transaction and stake tokens just before the state changes, potentially maximizing their rewards based on the new configuration."",
      ""Impact"": ""Possible unfair advantage for front-runners in reward accumulation."",
      ""Location"": ""Limbo.sol:configureSoul function""
    },
    {
      ""Issue"": ""Redundant check in `MigrationLib.migrate` could lead to miscalculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `MigrationLib.migrate` function, the conditional statement `if (scxMinted <= adjustedRectangle) {adjustedRectangle = scxMinted / 2;}` reduces `adjustedRectangle` to half of `scxMinted` if `scxMinted` is less than or equal to the initially calculated `adjustedRectangle`. However, since the purpose of `adjustedRectangle` is to limit the amount of SCX transferred to the `ammHelper`, this condition could lead to a potentially lower LP minting amount if `scxMinted` is naturally low, and the check is unnecessary."",
      ""Impact"": ""Potentially less optimal LP minting, reducing the benefit from the migration process."",
      ""Location"": ""Limbo.sol: `MigrationLib.migrate` function""
    },
    {
      ""Issue"": ""`unstakeApproval` mechanism lacks proper usage check"",
      ""Severity"": ""Low"",
      ""Description"": ""The `unstakeApproval` mapping allows a user (`unstaker`) to unstake on behalf of another user (`holder`). However, the `_unstake` function only decrements the allowance via `unstakeApproval[token][holder][unstaker] -= amount;` and does not check if the allowance is sufficient before decrementing. This leads to a potential underflow if `amount` is greater than the current allowance, which will revert due to Solidity 0.8+ protecting against underflows."",
      ""Impact"": ""Unexpected transaction reverts when unstaking for others with insufficient allowance."",
      ""Location"": ""Limbo.sol: `_unstake` function""
    },
    {
      ""Issue"": ""Lack of Handling for Zero Balances in `updateSoul`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updateSoul` function calculates `flanReward` based on `balance`. If the balance of the `token` is zero, the `flanReward` will be zero, and the subsequent calculation of `soul.accumulatedFlanPerShare` will be skipped. While this doesn\'t directly cause a security vulnerability, it might lead to unexpected behavior or inaccurate accounting if the token balance temporarily drops to zero during the staking period."",
      ""Impact"": ""Potentially inaccurate accounting of accumulated Flan per share if the token balance temporarily drops to zero."",
      ""Location"": ""Limbo.sol#L161""
    },
    {
      ""Issue"": ""Unprotected `updateSoul` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updateSoul(address token)` is public. There is no access control for the public `updateSoul(address token)`. Although it is unlikely to be exploited, it allows any user to update the `accumulatedFlanPerShare`, potentially leading to denial of service for claiming rewards. Consider restricting this function."",
      ""Impact"": ""Any user can update accumulatedFlanPerShare, potentially leading to denial of service for claiming rewards."",
      ""Location"": ""Limbo.sol#L151""
    },
    {
      ""Issue"": ""Potential Unbounded Loop Risk in `MigrationLib.migrate`"",
      ""Severity"": ""Low"",
      ""Description"": ""If `BehodlerLike(crossingConfig.behodler).burn(excessSCX)` fails (returns false) because burning is not available, the migration will halt."",
      ""Impact"": ""Contract may become unusable."",
      ""Location"": ""`MigrationLib.migrate` function""
    },
    {
      ""Issue"": ""Inconsistent use of `latestIndex` in `configureSoul`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `configureSoul` function, the logic to increment `latestIndex` is flawed and confusing, as the provided `index` is not used."",
      ""Impact"": ""Wasted gas, confusing logic"",
      ""Location"": ""`configureSoul` function""
    },
    {
      ""Issue"": ""Rounding Errors in Reward Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The reward calculation in `getPending` involves integer division, which can lead to rounding errors."",
      ""Impact"": ""Minor inaccuracies in reward distribution, potentially favoring the contract over users."",
      ""Location"": ""Limbo.sol:488, Limbo.sol:326, Limbo.sol:398""
    },
    {
      ""Issue"": ""Inconsistent use of `enforceTolerance`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `enforceTolerance` function is used throughout the contract to control parameter changes. However, the logic for determining what constitutes a valid tolerance is not present in the provided code."",
      ""Impact"": ""The governance mechanism may be ineffective or overly restrictive, depending on the `enforceTolerance` implementation."",
      ""Location"": ""Multiple locations, including `adjustSoul`, `configureCrossingParameters`.""
    },
    {
      ""Issue"": ""Missing Access Control for claimSecondaryRewards"",
      ""Severity"": ""Low"",
      ""Description"": ""The `claimSecondaryRewards` function allows any user to claim the remaining balance of a token held by the contract. While the intention might be to distribute the remaining tokens after a soul has crossed over, there\'s no access control mechanism to restrict who can call this function."",
      ""Impact"": ""Potential for unfair distribution of secondary rewards and front-running opportunities."",
      ""Location"": ""Limbo.sol:433""
    },
    {
      ""Issue"": ""Missing zero-address checks for critical contract addresses."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `configureCrossingConfig` function allows setting critical contract addresses like `behodler`, `angband`, `ammHelper`, and `morgothPower`. Setting these addresses to the zero address would likely break the contract\'s functionality. There should be explicit checks to prevent these addresses from being set to address(0)."",
      ""Impact"": ""Contract functionality can be permanently disrupted if critical addresses are set to the zero address, potentially leading to loss of funds."",
      ""Location"": ""Limbo.sol:configureCrossingConfig function""
    },
       {
      ""Issue"": ""Possible Loss of Funds due to unchecked subtraction"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_unstake` function, the code reduces `unstakeApproval[token][holder][unstaker]` by `amount` without checking for underflow. If `amount` is greater than `unstakeApproval[token][holder][unstaker]`, the value will wrap around, potentially allowing unintended unstaking."",
      ""Impact"": ""Unauthorized unstaking of tokens."",
      ""Location"": ""Limbo.sol:_unstake function""
    }
  ],
  ""IssueNumber"": 60,
  ""OutputList"": 30
}",242.5465512275696,4715.0,32.0,"### **Comparison of Issue Report and Response List**

---

**[M-10] User won't be able to get his rewards in case of staking with amount = 0**

**Report Description**:  
If a user has a pending reward and calls the `stake` function with `amount = 0`, they won't be able to claim their reward. This occurs because the reward calculation is only performed if the staked amount (provided as a parameter) is greater than 0. However, the reward debt is updated even if the amount is 0, effectively overwriting the pending reward without allowing the user to claim it.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The issue is not addressed in the `response_list`. The problem described in the issue report is specific to the reward calculation logic in the `stake` function when `amount = 0`. None of the responses in the `response_list` cover this scenario, which involves incorrect reward distribution due to flawed logic in the `stake` function. This is a significant oversight, as it directly impacts user rewards and contract functionality.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-10] User won't be able to get his rewards in case of staking with amount = 0**

---

### **Analysis of Gaps**

The `response_list` does not address the specific issue of reward calculation logic in the `stake` function when `amount = 0`. This is a critical vulnerability that could lead to users losing their pending rewards, which directly impacts the fairness and functionality of the contract. The `response_list` focuses on other vulnerabilities, such as reentrancy, access control, and integer overflows, but misses this specific issue. Future audits should ensure that reward distribution logic is thoroughly reviewed to prevent such oversights.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and the average of these values is also 0."
UniswapHelper.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import ""./facades/UniPairLike.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./DAO/Governable.sol"";
// import ""hardhat/console.sol"";
import ""./ERC677/ERC20Burnable.sol"";
import ""./facades/FlanLike.sol"";
import ""./testing/realUniswap/interfaces/IUniswapV2Factory.sol"";
import ""./facades/AMMHelper.sol"";

contract BlackHole {}

///@Title Uniswap V2 helper for managing Flan liquidity on Uniswap V2, Sushiswap and any other compatible AMM
///@author Justin Goro
/**@notice Flan liquidity is boosted on Uniswap (or Sushiswap) via open market operations at the point of a token migration.
  * UniswapHelper handles all the mechanics as well managing a just-in-time (Justin Time?) oracle
 */
contract UniswapHelper is Governable, AMMHelper {
  address limbo;

  struct UniVARS {
    UniPairLike Flan_SCX_tokenPair;
    address behodler;
    address blackHole;
    address flan;
    uint256 divergenceTolerance;
    uint256 minQuoteWaitDuration;
    address DAI;
    uint8 precision; // behodler uses a binary search. The higher this number, the more precise
    IUniswapV2Factory factory;
    uint8 priceBoostOvershoot; //percentage (0-100) for which the price must be overcorrected when strengthened to account for other AMMs
  }

  struct FlanQuote {
    uint256 DaiScxSpotPrice;
    uint256 DaiBalanceOnBehodler;
    uint256 blockProduced;
  }

  /**@dev the Dai SCX price and the Dai balance on Behodler are both sampled twice before a migration can occur. 
  * The two samples have to be spaced a minimum duration and have to be the same values (within an error threshold). The objective here is to make price manipulation untenably expensive for an attacker
  * so that the mining power expended (or the opportunity cost of eth staked) far exceeds the benefit to manipulating Limbo.
  * The assumption of price stability isn't a bug because migrations aren't required to happen frequently. Instead if natural price drift occurs for non malicious reasons,
  * the migration can be reattempted until a period of sufficient calm allows for migration. If a malicious actor injects volatility in order to prevent migration, by the principle
  * of antifragility, they're doing the entire Ethereum ecosystem a service at their own expense.
  */
  FlanQuote[2] public latestFlanQuotes; //0 is latest

  UniVARS VARS;

  //not sure why codebases don't use keyword ether but I'm reluctant to entirely part with that tradition for now.
  uint256 constant EXA = 1e18;

  //needs to be updated for future Martian, Lunar and Venusian blockchains although I suspect Lunar colonies will be very Terracentric because of low time lag.
  uint256 constant year = (1 days * 365);

  /*
    instead of relying on oracles, we simply require snapshots of important 
    prices to be taken at intervals far enough apart.
    If an attacker wishes to overstate or understate a price through market manipulation,
    they'd have to keep it out of equilibrium over the span of the two snapshots or they'd
    have to time the manipulation to happen as the snapshots occur. As a miner,
    they could do this through transaction ordering but they'd have to win two blocks at precise moments
    which is statistically highly unlikely. 
    The snapshot enforcement can be hindered by false negatives. Natural price variation, for instance, but the cost
    of this is just having to snapshot again when the market is calmer. Since migration is not not time sensitive,
    this is a cost worth bearing.
    */
  modifier ensurePriceStability() {
    _ensurePriceStability();
    _;
  }

  modifier onlyLimbo() {
    require(msg.sender == limbo);
    _;
  }

  constructor(address _limbo, address limboDAO) Governable(limboDAO) {
    limbo = _limbo;
    VARS.blackHole = address(new BlackHole());
    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
  }

  ///@notice LP tokens minted during migration are discarded.
  function blackHole() public view returns (address) {
    return VARS.blackHole;
  }

  ///@notice Uniswap factory contract
  function setFactory(address factory) public {
    require(block.chainid != 1, ""Uniswap factory hardcoded on mainnet"");
    VARS.factory = IUniswapV2Factory(factory);
  }

  ///@dev Only for testing: On mainnet Dai has a fixed address.
  function setDAI(address dai) public {
    require(block.chainid != 1, ""DAI hardcoded on mainnet"");
    VARS.DAI = dai;
  }

  ///@notice main configuration function.
  ///@dev We prefer to use configuration functions rather than a constructor for a number of reasons.
  ///@param _limbo Limbo contract
  ///@param FlanSCXPair The Uniswap flan/SCX pair
  ///@param behodler Behodler AMM
  ///@param flan The flan token
  ///@param divergenceTolerance The amount of price difference between the two quotes that is tolerated before a migration is attempted 
  ///@param minQuoteWaitDuration The minimum duration between the sampling of oracle data used for migration
  ///@param precision In order to query the tokens redeemed by a quantity of SCX, Behodler performs a binary search. Precision refers to the max iterations of the search.
  ///@param priceBoostOvershoot Flan targets parity with Dai. If we set Flan to equal Dai then between migrations, it will always be below Dai. Overshoot gives us some runway by intentionally ""overshooting"" the price
  function configure(
    address _limbo,
    address FlanSCXPair,
    address behodler,
    address flan,
    uint256 divergenceTolerance,
    uint256 minQuoteWaitDuration,
    uint8 precision,
    uint8 priceBoostOvershoot
  ) public onlySuccessfulProposal {
    limbo = _limbo;
    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);
    VARS.behodler = behodler;
    VARS.flan = flan;
    require(divergenceTolerance >= 100, ""Divergence of 100 is parity"");
    VARS.divergenceTolerance = divergenceTolerance;
    VARS.minQuoteWaitDuration = minQuoteWaitDuration;
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    VARS.precision = precision == 0 ? precision : precision;
    require(priceBoostOvershoot < 100, ""Set overshoot to number between 1 and 100."");
    VARS.priceBoostOvershoot = priceBoostOvershoot;
  }

  ///@notice Samples the two values required for migration. Must be called twice before migration can occur.
  function generateFLNQuote() public override {
    latestFlanQuotes[1] = latestFlanQuotes[0];
    (
      latestFlanQuotes[0].DaiScxSpotPrice,
      latestFlanQuotes[0].DaiBalanceOnBehodler
    ) = getLatestFLNQuote();
    latestFlanQuotes[0].blockProduced = block.number;
  }

  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {
    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(
      VARS.DAI,
      10000,
      1 ether,
      VARS.precision
    );
    dai_scx = (daiToRelease * EXA) / (1 ether);

    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);
  }

  ///@notice When tokens are migrated to Behodler, SCX is generated. This SCX is used to boost Flan liquidity and nudge the price of Flan back to parity with Dai
  ///@param rectangleOfFairness refers to the quantity of SCX held back to be used for open market Flan stabilizing operations
  ///@dev makes use of price tilting. Be sure to understand the concept of price tilting before trying to understand the final if statement.
  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {
    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));

    //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.
    //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes
    require((localSCXBalance * 100) / rectangleOfFairness == 98, ""EM"");
    rectangleOfFairness = localSCXBalance;

    //get DAI per scx
    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));
    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;

    //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.
    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);
    address pair = address(VARS.Flan_SCX_tokenPair);
    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);

    if (existingFlanOnLP < DesiredFinalFlanOnLP) {
      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;

      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;
      FlanLike(VARS.flan).mint(pair, flanToMint);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      {
        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
      }
    } else {
      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();

      FlanLike(VARS.flan).mint(pair, minFlan + 2);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
    }
    //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.
    _zeroOutQuotes();
  }

  ///@notice helper function for converting a desired APY into a flan per second (FPS) statistic
  ///@param minAPY Here APY refers to the dollar value of flan relative to the dollar value of the threshold
  ///@param daiThreshold The DAI value of the target threshold to list on Behodler. Threshold is an approximation of the AVB on Behodler
  function minAPY_to_FPS(
    uint256 minAPY, //divide by 10000 to get percentage
    uint256 daiThreshold
  ) public override view ensurePriceStability returns (uint256 fps) {
    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;
    // console.log(""DAI threshold %s"", daiThreshold);
    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;
    fps = returnOnThreshold / (year);
  }

  ///@notice Buys Flan with a specified token, apportions 1% of the purchased Flan to the caller and burns the rest.
  ///@param inputToken The token used to buy Flan
  ///@param amount amount of input token used to buy Flan
  ///@param recipient receives 1% of Flan purchased as an incentive to call this function regularly
  ///@dev Assumes a pair for Flan/InputToken exists on Uniswap
  function buyFlanAndBurn(
    address inputToken,
    uint256 amount,
    address recipient
  ) public override {
    address pair = VARS.factory.getPair(inputToken, VARS.flan);

    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);
    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);

    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);
    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;
    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;
    IERC20(inputToken).transfer(pair, amount);
    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), """");
    uint256 reward = (amountOut / 100);
    ERC20Burnable(VARS.flan).transfer(recipient, reward);
    ERC20Burnable(VARS.flan).burn(amountOut - reward);
  }

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountOut) {
    uint256 amountInWithFee = amountIn * 997;
    uint256 numerator = amountInWithFee * reserveOut;
    uint256 denominator = reserveIn * 1000 + amountInWithFee;
    amountOut = numerator / denominator;
  }

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountIn) {
    uint256 numerator = reserveIn * amountOut * 1000;
    uint256 denominator = (reserveOut - amountOut) * 997;
    amountIn = (numerator / denominator) + 1;
  }

  function _zeroOutQuotes() internal {
    delete latestFlanQuotes[0];
    delete latestFlanQuotes[1];
  }

  //the purpose of the divergence code is to bring the robustness of a good oracle without requiring an oracle
  function _ensurePriceStability() internal view {
    FlanQuote[2] memory localFlanQuotes; //save gas
    localFlanQuotes[0] = latestFlanQuotes[0];
    localFlanQuotes[1] = latestFlanQuotes[1];

    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice
      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice
      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;

    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler
      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler
      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;

    // console.log(""dai balance divergence %s"", daiBalanceDivergence);
    require(
      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,
      ""EG""
    );

    require(
      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&
        localFlanQuotes[1].blockProduced > 0,
      ""EH""
    );
  }
}",3665,289,"[M-07] Calling generateFLNQuote twice in every block prevents any migration

Submitted by camden, also found by GeekyLumberjack, kirk-baird, and shw
https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138 In the Uniswap helper, generateFLNQuote is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a blockProduced value of the current block's number.
These quotes are used in the _ensurePriceStability function. The last require statement here is key: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285
   [M-11] You can grief migrations by sending SCX to the UniswapHelper

Submitted by camden, also found by robee
The attack here allows the attacker to prevent migrations.
The attack here is recoverable because we can just call buyFlanAndBurn (f it worked as expected) with SCX as the input token to buy Flan with the extra SCX, then run the migration again.
   [M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks

Submitted by hyh
Trades can happen at a manipulated price and end up receiving fewer Flan to be bought than current market price dictates.
For example, at the time a user decides to call buyFlanAndBurn Flan trades at 0.8 in the input token terms at the corresponding DEX pool. If the input token holdings are big enough to compensate for pool manipulation costs, the following can happen: Flan buy order will be seen by a malicious bot, that buys Flan, pushing it to 0.9 before UniswapHelper's order comes through, and selling it back right afterwards. This way, given a cumulative impact of the trades on Flan's market price, the input token will be overspent.
This yields direct loss for the system as input token market operations have lesser effect than expected at the expense of contract holdings.

",3,,"pragma solidity 0.8.4;
import ""./facades/UniPairLike.sol"";
import ""./facades/BehodlerLike.sol"";
import ""./DAO/Governable.sol"";

import ""./ERC677/ERC20Burnable.sol"";
import ""./facades/FlanLike.sol"";
import ""./testing/realUniswap/interfaces/IUniswapV2Factory.sol"";
import ""./facades/AMMHelper.sol"";

contract BlackHole {}




contract UniswapHelper is Governable, AMMHelper {
  address limbo;

  struct UniVARS {
    UniPairLike Flan_SCX_tokenPair;
    address behodler;
    address blackHole;
    address flan;
    uint256 divergenceTolerance;
    uint256 minQuoteWaitDuration;
    address DAI;
    uint8 precision; 
    IUniswapV2Factory factory;
    uint8 priceBoostOvershoot; 
  }

  struct FlanQuote {
    uint256 DaiScxSpotPrice;
    uint256 DaiBalanceOnBehodler;
    uint256 blockProduced;
  }

  
  FlanQuote[2] public latestFlanQuotes; 

  UniVARS VARS;

  
  uint256 constant EXA = 1e18;

  
  uint256 constant year = (1 days * 365);

  
  modifier ensurePriceStability() {
    _ensurePriceStability();
    _;
  }

  modifier onlyLimbo() {
    require(msg.sender == limbo);
    _;
  }

  constructor(address _limbo, address limboDAO) Governable(limboDAO) {
    limbo = _limbo;
    VARS.blackHole = address(new BlackHole());
    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
  }

  
  function blackHole() public view returns (address) {
    return VARS.blackHole;
  }

  
  function setFactory(address factory) public {
    require(block.chainid != 1, ""Uniswap factory hardcoded on mainnet"");
    VARS.factory = IUniswapV2Factory(factory);
  }

  
  function setDAI(address dai) public {
    require(block.chainid != 1, ""DAI hardcoded on mainnet"");
    VARS.DAI = dai;
  }

  
  
  
  
  
  
  
  
  
  
  function configure(
    address _limbo,
    address FlanSCXPair,
    address behodler,
    address flan,
    uint256 divergenceTolerance,
    uint256 minQuoteWaitDuration,
    uint8 precision,
    uint8 priceBoostOvershoot
  ) public onlySuccessfulProposal {
    limbo = _limbo;
    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);
    VARS.behodler = behodler;
    VARS.flan = flan;
    require(divergenceTolerance >= 100, ""Divergence of 100 is parity"");
    VARS.divergenceTolerance = divergenceTolerance;
    VARS.minQuoteWaitDuration = minQuoteWaitDuration;
    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    VARS.precision = precision == 0 ? precision : precision;
    require(priceBoostOvershoot < 100, ""Set overshoot to number between 1 and 100."");
    VARS.priceBoostOvershoot = priceBoostOvershoot;
  }

  
  function generateFLNQuote() public override {
    latestFlanQuotes[1] = latestFlanQuotes[0];
    (
      latestFlanQuotes[0].DaiScxSpotPrice,
      latestFlanQuotes[0].DaiBalanceOnBehodler
    ) = getLatestFLNQuote();
    latestFlanQuotes[0].blockProduced = block.number;
  }

  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {
    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(
      VARS.DAI,
      10000,
      1 ether,
      VARS.precision
    );
    dai_scx = (daiToRelease * EXA) / (1 ether);

    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);
  }

  
  
  
  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {
    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));

    
    
    require((localSCXBalance * 100) / rectangleOfFairness == 98, ""EM"");
    rectangleOfFairness = localSCXBalance;

    
    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));
    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;

    
    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);
    address pair = address(VARS.Flan_SCX_tokenPair);
    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);

    if (existingFlanOnLP < DesiredFinalFlanOnLP) {
      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;

      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;
      FlanLike(VARS.flan).mint(pair, flanToMint);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      {
        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
      }
    } else {
      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();

      FlanLike(VARS.flan).mint(pair, minFlan + 2);
      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);
      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);
    }
    
    _zeroOutQuotes();
  }

  
  
  
  function minAPY_to_FPS(
    uint256 minAPY, 
    uint256 daiThreshold
  ) public override view ensurePriceStability returns (uint256 fps) {
    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;
    
    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;
    fps = returnOnThreshold / (year);
  }

  
  
  
  
  
  function buyFlanAndBurn(
    address inputToken,
    uint256 amount,
    address recipient
  ) public override {
    address pair = VARS.factory.getPair(inputToken, VARS.flan);

    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);
    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);

    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);
    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;
    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;
    IERC20(inputToken).transfer(pair, amount);
    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), """");
    uint256 reward = (amountOut / 100);
    ERC20Burnable(VARS.flan).transfer(recipient, reward);
    ERC20Burnable(VARS.flan).burn(amountOut - reward);
  }

  function getAmountOut(
    uint256 amountIn,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountOut) {
    uint256 amountInWithFee = amountIn * 997;
    uint256 numerator = amountInWithFee * reserveOut;
    uint256 denominator = reserveIn * 1000 + amountInWithFee;
    amountOut = numerator / denominator;
  }

  function getAmountIn(
    uint256 amountOut,
    uint256 reserveIn,
    uint256 reserveOut
  ) internal pure returns (uint256 amountIn) {
    uint256 numerator = reserveIn * amountOut * 1000;
    uint256 denominator = (reserveOut - amountOut) * 997;
    amountIn = (numerator / denominator) + 1;
  }

  function _zeroOutQuotes() internal {
    delete latestFlanQuotes[0];
    delete latestFlanQuotes[1];
  }

  
  function _ensurePriceStability() internal view {
    FlanQuote[2] memory localFlanQuotes; 
    localFlanQuotes[0] = latestFlanQuotes[0];
    localFlanQuotes[1] = latestFlanQuotes[1];

    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice
      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice
      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;

    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler
      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler
      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;

    
    require(
      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,
      ""EG""
    );

    require(
      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&
        localFlanQuotes[1].blockProduced > 0,
      ""EH""
    );
  }
}",2373,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Configuration and Governance"",
      ""Tasks"": [
        ""Verify that the `onlySuccessfulProposal` modifier in the `configure` function correctly enforces governance control over critical parameters."",
        ""Confirm that the `limboDAO` address is properly initialized in the constructor and used consistently throughout the contract."",
        ""Analyze the potential impact of changing configuration parameters (e.g., `divergenceTolerance`, `minQuoteWaitDuration`, `priceBoostOvershoot`) through governance and ensure there are no unintended consequences."",
        ""Investigate whether the hardcoded DAI and Uniswap Factory addresses on mainnet can be changed after deployment through governance, and assess the potential risks if they can.""
      ]
    },
    {
      ""Area"": ""Price Stability Mechanism"",
      ""Tasks"": [
        ""Thoroughly examine the `_ensurePriceStability` function to ensure it accurately detects and prevents price manipulation or instability."",
        ""Analyze the logic for calculating `daiSCXSpotPriceDivergence` and `daiBalanceDivergence` to confirm their correctness and sensitivity to market fluctuations."",
        ""Assess the potential for an attacker to manipulate the Behodler contract or the Flan/SCX pair on Uniswap to bypass the price stability checks."",
        ""Evaluate the `minQuoteWaitDuration` parameter to determine if it provides sufficient protection against rapid price changes and front-running attacks."",
        ""Simulate scenarios with different price fluctuations to test the effectiveness of the `ensurePriceStability` modifier."",
        ""Verify that the `latestFlanQuotes` array is updated atomically and that there are no race conditions or data inconsistencies during quote updates.""
      ]
    },
    {
      ""Area"": ""`stabilizeFlan` Function Logic"",
      ""Tasks"": [
        ""Clarify the purpose of the `rectangleOfFairness` parameter and the initial check `(localSCXBalance * 100) / rectangleOfFairness == 98`. Determine the rationale behind the 98% ratio and whether it's a potential source of errors or vulnerabilities."",
        ""Analyze the logic in the `else` block where `existingFlanOnLP >= DesiredFinalFlanOnLP`, specifically the Flan minting of `minFlan + 2`. Investigate the purpose of adding '2' and its potential impact on the system."",
        ""Assess the potential for arithmetic overflows or underflows when calculating `DesiredFinalFlanOnLP`, `flanToMint`, and other intermediate values in the `stabilizeFlan` function."",
        ""Verify that the Flan minting and liquidity addition process in `stabilizeFlan` is atomic and cannot be disrupted by external calls or reentrancy attacks."",
        ""Examine the interaction with the `FlanLike` and `UniPairLike` contracts during Flan minting and LP token creation, ensuring that the contract has sufficient permissions and that the calls are secure."",
        ""Trace the flow of SCX from the contract to the Uniswap pair, ensuring that the correct amount is transferred and that there are no potential vulnerabilities in the transfer process."",
        ""Confirm that the LP tokens are always correctly minted and transferred to the `BlackHole` contract, and that there are no edge cases where the tokens could be lost or stolen."",
        ""Analyze the impact of the `priceBoostOvershoot` parameter on the Flan amount minted and ensure it behaves as intended, preventing undesirable price fluctuations.""
      ]
    },
    {
      ""Area"": ""`buyFlanAndBurn` Function Security"",
      ""Tasks"": [
        ""Assess the potential for front-running attacks in the `buyFlanAndBurn` function, where an attacker could manipulate the price of Flan before the swap occurs."",
        ""Examine the `getAmountOut` function and ensure that it accurately calculates the output amount based on the current reserves in the Uniswap pair."",
        ""Verify that the Uniswap pair address retrieved by `VARS.factory.getPair(inputToken, VARS.flan)` is indeed the correct Flan/inputToken pair."",
        ""Check if slippage control is implemented in `buyFlanAndBurn` to prevent significant price fluctuations during the swap."",
        ""Ensure that the reward calculation `(amountOut / 100)` is correct and does not lead to any rounding errors or vulnerabilities."",
        ""Analyze the `transfer` and `burn` calls to the `ERC20Burnable` contract and confirm that they are executed securely and without any vulnerabilities."",
        ""Investigate the potential for an attacker to send malicious tokens as `inputToken` and exploit vulnerabilities in the `getAmountOut` function or the Uniswap pair.""
      ]
    },
    {
      ""Area"": ""External Interactions & Interface Compatibility"",
      ""Tasks"": [
        ""Verify the compatibility of the contract with the interfaces of the external contracts it interacts with (`UniPairLike`, `BehodlerLike`, `FlanLike`, `IUniswapV2Factory`, `ERC20Burnable`, `IERC20`)."",
        ""Audit the `BehodlerLike.withdrawLiquidityFindSCX` function call to confirm that it returns the expected Dai/SCX value and that the interaction is secure."",
        ""Ensure that the `UniPairLike` contract's `mint` and `swap` functions are implemented correctly and do not contain any vulnerabilities."",
        ""Check that the `FlanLike` contract's `mint` function is secure and does not allow unauthorized minting of Flan tokens."",
        ""Review the error handling and fallback mechanisms in case of failures in external contract calls."",
        ""Analyze the potential impact of changes or upgrades to the external contracts on the functionality and security of the `UniswapHelper` contract.""
      ]
    },
    {
      ""Area"": ""Tokenomics and BlackHole Functionality"",
      ""Tasks"": [
        ""Assess the overall tokenomics of the Flan token and the impact of the `stabilizeFlan` and `buyFlanAndBurn` functions on the token supply and price."",
        ""Investigate the purpose of sending LP tokens to the `BlackHole` contract and ensure that this mechanism is secure and does not lead to any unintended consequences."",
        ""Determine if the `BlackHole` contract has any other functionality or potential vulnerabilities."",
        ""Evaluate whether the burning of Flan tokens in `buyFlanAndBurn` is effective in maintaining the token's value and preventing inflation.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify and optimize gas-intensive operations, such as calculations and external contract calls, to reduce the cost of executing the contract's functions."",
        ""Minimize the storage usage of state variables to reduce gas costs for deployment and execution."",
        ""Optimize the loops and conditional statements in the contract to improve gas efficiency."",
        ""Consider using assembly code for specific operations to further optimize gas costs."",
        ""Benchmark the gas consumption of the contract's functions under different scenarios to identify areas for improvement.""
      ]
    },
    {
      ""Area"": ""Error Handling & Input Validation"",
      ""Tasks"": [
        ""Replace terse error messages like \""EM\"", \""EG\"", \""EH\"" with more descriptive and informative messages for better debugging and user experience."",
        ""Ensure that all input parameters are properly validated to prevent invalid values or malicious inputs from causing errors or vulnerabilities."",
        ""Implement comprehensive error handling mechanisms to catch and handle unexpected errors gracefully."",
        ""Consider adding logging and event emission to provide better insights into the contract's execution and state changes.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `UniswapHelper` serves as an intermediary and utility contract interacting with Uniswap V2, a protocol called Behodler, and a token named Flan. Its primary functions seem to be stabilizing the Flan token's price on a specific Uniswap pair (Flan/SCX) based on data derived from Behodler, and providing a mechanism to buy and burn Flan. It incorporates governance control for configuration and safety checks based on price stability between consecutive price quotes. LP tokens generated during stabilization are sent to a 'BlackHole' contract."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""UniswapHelper"",
    ""Purpose"": ""To manage interactions between Behodler, the Flan token, and a Uniswap V2 pair (Flan/SCX). It aims to stabilize the Flan price by adding liquidity based on Behodler-derived quotes and offers a buy-and-burn mechanism for Flan. Configuration is governance-controlled, and operations require price stability checks."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Governable"",
        ""AMMHelper""
      ],
      ""Imports"": [
        ""./facades/UniPairLike.sol"",
        ""./facades/BehodlerLike.sol"",
        ""./DAO/Governable.sol"",
        ""./ERC677/ERC20Burnable.sol"",
        ""./facades/FlanLike.sol"",
        ""./testing/realUniswap/interfaces/IUniswapV2Factory.sol"",
        ""./facades/AMMHelper.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""limbo"",
        ""Type"": ""address"",
        ""Purpose"": ""An address authorized to call specific functions like `stabilizeFlan`.""
      },
      {
        ""Name"": ""VARS"",
        ""Type"": ""UniVARS (struct)"",
        ""Purpose"": ""Holds configuration parameters like contract addresses (Flan/SCX pair, Behodler, Flan, BlackHole, DAI, Uniswap Factory) and operational settings (divergence tolerance, quote duration, precision, price boost overshoot).""
      },
      {
        ""Name"": ""latestFlanQuotes"",
        ""Type"": ""FlanQuote[2]"",
        ""Purpose"": ""Stores the two most recent price/state quotes obtained from Behodler, used for price stability checks.""
      },
      {
        ""Name"": ""EXA"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Represents 1e18, used for fixed-point arithmetic.""
      },
      {
        ""Name"": ""year"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""Represents the number of seconds in a year, used for APY/FPS calculations.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""ensurePriceStability"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Modifier that checks if the price divergence and DAI balance divergence between the last two quotes are within tolerance and if enough time has passed between quotes."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyLimbo"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Modifier that restricts function execution to the `limbo` address."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, sets the `limbo` and `limboDAO` addresses, creates a `BlackHole` contract instance, and sets default Uniswap Factory and DAI addresses (hardcoded for mainnet)."",
        ""Parameters"": [
          ""address _limbo"",
          ""address limboDAO""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""blackHole"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the internally created `BlackHole` contract."",
        ""Parameters"": [],
        ""Returns"": [
          ""address""
        ]
      },
      {
        ""Name"": ""setFactory"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows setting the Uniswap V2 Factory address (restricted on mainnet)."",
        ""Parameters"": [
          ""address factory""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setDAI"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows setting the DAI token address (restricted on mainnet)."",
        ""Parameters"": [
          ""address dai""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""configure"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Configures the main operational parameters and addresses for the contract. Requires authorization via `onlySuccessfulProposal` (from Governable)."",
        ""Parameters"": [
          ""address _limbo"",
          ""address FlanSCXPair"",
          ""address behodler"",
          ""address flan"",
          ""uint256 divergenceTolerance"",
          ""uint256 minQuoteWaitDuration"",
          ""uint8 precision"",
          ""uint8 priceBoostOvershoot""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""generateFLNQuote"",
        ""Visibility"": ""public override"",
        ""Purpose"": ""Fetches the latest Dai/SCX spot price and Dai balance from Behodler and stores it, shifting the previous quote."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""getLatestFLNQuote"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Helper function to query Behodler for the Dai/SCX spot price and Dai balance."",
        ""Parameters"": [],
        ""Returns"": [
          ""uint256 dai_scx"",
          ""uint256 daiBalanceOnBehodler""
        ]
      },
      {
        ""Name"": ""stabilizeFlan"",
        ""Visibility"": ""public override"",
        ""Purpose"": ""The core function to stabilize the Flan price. Called by `limbo`, requires price stability. Calculates the required Flan amount for the Uniswap pair based on the Behodler quote and the SCX provided (`rectangleOfFairness`), mints Flan, adds liquidity (SCX + Flan) to the pair, and sends the resulting LP tokens to the `blackHole` address. Resets quotes afterwards."",
        ""Parameters"": [
          ""uint256 rectangleOfFairness""
        ],
        ""Returns"": [
          ""uint256 lpMinted""
        ]
      },
      {
        ""Name"": ""minAPY_to_FPS"",
        ""Visibility"": ""public override view"",
        ""Purpose"": ""Calculates a 'Flan Per Second' (FPS) rate based on a desired minimum APY and a DAI threshold (defaults to current DAI balance on Behodler). Requires price stability."",
        ""Parameters"": [
          ""uint256 minAPY"",
          ""uint256 daiThreshold""
        ],
        ""Returns"": [
          ""uint256 fps""
        ]
      },
      {
        ""Name"": ""buyFlanAndBurn"",
        ""Visibility"": ""public override"",
        ""Purpose"": ""Allows a user to send an `inputToken` to this contract, which then swaps it for Flan on the corresponding Uniswap pair. A small percentage (1%) of the received Flan is sent to a `recipient`, and the rest is burned."",
        ""Parameters"": [
          ""address inputToken"",
          ""uint256 amount"",
          ""address recipient""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""getAmountOut"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the output amount for a Uniswap V2 swap given input amount and reserves."",
        ""Parameters"": [
          ""uint256 amountIn"",
          ""uint256 reserveIn"",
          ""uint256 reserveOut""
        ],
        ""Returns"": [
          ""uint256 amountOut""
        ]
      },
      {
        ""Name"": ""getAmountIn"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the required input amount for a Uniswap V2 swap given output amount and reserves."",
        ""Parameters"": [
          ""uint256 amountOut"",
          ""uint256 reserveIn"",
          ""uint256 reserveOut""
        ],
        ""Returns"": [
          ""uint256 amountIn""
        ]
      },
      {
        ""Name"": ""_zeroOutQuotes"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Deletes the stored Flan price quotes, likely called after a stabilization action."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_ensurePriceStability"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Contains the logic for the `ensurePriceStability` modifier, performing checks on price/balance divergence and block time difference between the last two quotes."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""BehodlerLike contract (at `VARS.behodler`): Calls `withdrawLiquidityFindSCX`."",
    ""UniPairLike contract (at `VARS.Flan_SCX_tokenPair` and dynamic pairs in `buyFlanAndBurn`): Calls `balanceOf`, `mint`, `swap`, `totalSupply`."",
    ""IUniswapV2Factory (at `VARS.factory`): Calls `getPair`."",
    ""FlanLike contract (at `VARS.flan`): Calls `mint`."",
    ""ERC20Burnable contract (at `VARS.flan`): Calls `transfer`, `burn`, `balanceOf`."",
    ""IERC20 tokens (DAI at `VARS.DAI`, SCX assumed to be at `VARS.behodler`, various `inputToken`s): Calls `balanceOf`, `transfer`."",
    ""`limbo` address: External actor expected to call `stabilizeFlan`."",
    ""Governable contract's DAO (`limboDAO`): Implicit interaction via `onlySuccessfulProposal` modifier."",
    ""`BlackHole` contract (at `VARS.blackHole`): Receives LP tokens via transfer during `stabilizeFlan`.""
  ],
  ""SpecialMechanisms"": [
    ""Price Stabilization Loop: Uses Behodler data (`generateFLNQuote`) to determine a target Flan/SCX ratio, then mints Flan and adds liquidity via `stabilizeFlan` to push the Uniswap price towards the target."",
    ""Dual Quote Stability Check: Relies on comparing two consecutive quotes (`latestFlanQuotes`) to prevent actions based on potentially manipulated or volatile single data points (`_ensurePriceStability`)."",
    ""LP Token Sink: Sends minted Uniswap LP tokens to a `BlackHole` contract, removing them from general circulation."",
    ""Buy and Burn Utility: Provides a public function (`buyFlanAndBurn`) to facilitate acquiring Flan and immediately burning 99% of it."",
    ""Governance-Controlled Configuration: Uses `Governable` inheritance and the `onlySuccessfulProposal` modifier to restrict configuration changes."",
    ""Operational Control via `limbo`: Key operational function `stabilizeFlan` is restricted to the `limbo` address.""
  ],
  ""Questions"": [
    ""What is the 'SCX' token? The code uses `VARS.behodler` address frequently when dealing with SCX balances (e.g., `IERC20(VARS.behodler).balanceOf(...)`). Is the Behodler contract address itself the SCX token address? This seems unconventional."",
    ""What is the exact nature and role of the `limbo` address? Is it an EOA, a multisig, or another automated contract?"",
    ""In `stabilizeFlan`, why is the `rectangleOfFairness` parameter checked against the contract's balance (`require((localSCXBalance * 100) / rectangleOfFairness == 98, \""EM\"");`) and then immediately overwritten (`rectangleOfFairness = localSCXBalance;`)? What's the purpose of the initial check and the specific 98% ratio?"",
    ""In `stabilizeFlan`, the `else` block (when `existingFlanOnLP >= DesiredFinalFlanOnLP`) mints `minFlan + 2` Flan. What is the rationale for adding exactly 2 wei?"",
    ""What is the purpose of the dedicated `BlackHole` contract? Could LP tokens be sent to `address(0)` or burned if the pair interface allowed it? Does `BlackHole` have any other functionality?"",
    ""In `configure`, the line `VARS.precision = precision == 0 ? precision : precision;` seems redundant or incorrect. If `precision` is 0, it assigns 0. If non-zero, it assigns the non-zero value. Was a default value intended if `precision` is 0?"",
    ""The `priceBoostOvershoot` parameter appears to cause *undershooting* the target Flan amount when minting in `stabilizeFlan`. What is the intended effect of this 'overshoot' parameter?"",
    ""Error messages like \""EM\"", \""EG\"", \""EH\"" are terse. Could they be made more descriptive?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `buyFlanAndBurn`"",
      ""Severity"": ""High"",
      ""Description"": ""The `buyFlanAndBurn` function interacts with external contracts (`UniPairLike(pair).swap`, `ERC20Burnable(VARS.flan).transfer`, `ERC20Burnable(VARS.flan).burn`).  A malicious contract could re-enter the function during the `swap`, `transfer`, or `burn` call, potentially leading to unexpected state changes or loss of funds. Also, the `mint` function of either the FlanLike or UniPairLike contracts re-enters the `stabilizeFlan` function before the `_zeroOutQuotes()` function is called, it could lead to unexpected behavior and potentially drain the contract\'s funds."",
      ""Impact"": ""Potential for a reentrancy attack that could drain funds from the contract or cause other unexpected behavior."",
      ""Location"": ""`buyFlanAndBurn` function, `stabilizeFlan()` function""
    },
    {
      ""Issue"": ""Incorrect Rectangle of Fairness Check"",
      ""Severity"": ""High"",
      ""Description"": ""The `stabilizeFlan` function includes a check: `require((localSCXBalance * 100) / rectangleOfFairness == 98, \\\""EM\\\"")`. The calculation is flawed and prevents the `stabilizeFlan` function from executing due to integer truncation or small values, and doesn't ensure anything meaningful about equality."",
      ""Impact"": ""Potentially halts the execution of core logic due to a faulty check."",
      ""Location"": ""stabilizeFlan function""
    },
    {
      ""Issue"": ""Division by Zero in `getAmountIn`"",
      ""Severity"": ""High"",
      ""Description"": ""In `getAmountIn`, if `amountOut` is equal to `reserveOut`, the denominator `(reserveOut - amountOut) * 997` becomes zero, leading to a division by zero error and causing the transaction to revert."",
      ""Impact"": ""Transaction reverts, preventing users from swapping tokens when `amountOut` is equal to `reserveOut` or disrupting the functionality of `buyFlanAndBurn`."",
      ""Location"": ""getAmountIn""
    },
    {
      ""Issue"": ""Hardcoded Uniswap Factory and DAI Address on Mainnet"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor hardcodes the Uniswap V2 Factory address (`0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f`) and DAI address (`0x6B175474E89094C44Da98b954EedeAC495271d0F`). While there are `setFactory` and `setDAI` functions, the `require(block.chainid != 1, ...)` check prevents changing these on mainnet. This limits flexibility and adaptability, and creates a single point of failure."",
      ""Impact"": ""Limits flexibility and upgradability on mainnet. If the hardcoded Uniswap V2 factory or DAI is compromised or deprecated, the contract will become unusable. Prevents interaction with alternative Uniswap V2 forks or DAI-like tokens."",
      ""Location"": ""Constructor, `setFactory`, `setDAI`, `configure` functions""
    },
    {
      ""Issue"": ""Price Manipulation Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `stabilizeFlan` function relies on the `latestFlanQuotes` to determine the desired `Flan` balance. An attacker can front-run the transaction that calls `stabilizeFlan` and manipulate the price of `Flan` before that transaction executes, causing `stabilizeFlan` to mint an incorrect amount of `Flan` or `SCX`. Also in the `stabilizeFlan` function, minting small fixed amount `minFlan + 2` if a condition fails can cause price to be lowered."",
      ""Impact"": ""Potential for the attacker to profit at the expense of the protocol by manipulating `Flan` price."",
      ""Location"": ""`stabilizeFlan` function""
    },
    {
      ""Issue"": ""Lack of Input Validation in `configure` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `configure` function lacks comprehensive validation for critical parameters like `FlanSCXPair`, `behodler`, and `flan` addresses. There's no check to ensure that these addresses are indeed contracts or that they implement the expected interfaces. Furthermore, there is no check to ensure the addresses passed are not the zero address."",
      ""Impact"": ""Incorrect or malicious addresses could be passed into the `configure` function, leading to unexpected behavior, contract failures, or even security vulnerabilities. Contract may not function or become unusable if critical addresses are set to the zero address or invalid contract addresses."",
      ""Location"": ""`configure` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `getAmountOut` and `getAmountIn` perform arithmetic operations that, under extreme conditions, could potentially lead to integer overflow or underflow. Also, in `getLatestFLNQuote`, the `dai_scx` price is calculated as `(daiToRelease * EXA) / (1 ether)`. If `daiToRelease` is small, the result of the division can be truncated, leading to a loss of precision in the price calculation. "",
      ""Impact"": ""Incorrect calculation of amountOut or amountIn, leading to financial losses or unexpected behavior in the `buyFlanAndBurn` function. Slight inaccuracies in price calculations"",
      ""Location"": ""getAmountOut, getAmountIn, getLatestFLNQuote functions""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `generateFLNQuote` and `stabilizeFlan`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `generateFLNQuote` function updates `latestFlanQuotes` with the latest price information. A malicious actor could observe the transaction calling `generateFLNQuote` in the mempool and front-run it to manipulate the price before `stabilizeFlan` is called, potentially exploiting the price difference."",
      ""Impact"": ""Potential for front-running attack, allowing an attacker to profit from price manipulation before `stabilizeFlan` is executed."",
      ""Location"": ""generateFLNQuote(), stabilizeFlan()""
    },
    {
      ""Issue"": ""Lack of Slippage Control in `buyFlanAndBurn`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `buyFlanAndBurn` function doesn\'t allow users to specify a minimum amount of FLAN they are willing to receive. This means that if the price of FLAN changes significantly between the transaction being submitted and executed, the user may receive much less FLAN than expected."",
      ""Impact"": ""Users may receive significantly less FLAN than expected due to price slippage."",
      ""Location"": ""buyFlanAndBurn()""
    },
    {
      ""Issue"": ""Magic Number in `stabilizeFlan`"",
      ""Severity"": ""Low"",
      ""Description"": ""The line `require((localSCXBalance * 100) / rectangleOfFairness == 98, \\\""EM\\\"")` uses the magic number 98. The purpose of this comparison is unclear from the context and obscures the logic."",
      ""Impact"": ""Reduced code readability and maintainability. The specific check and the acceptable tolerance are unclear."",
      ""Location"": ""`stabilizeFlan` function""
    },
    {
      ""Issue"": ""Unnecessary precision requirement in configure function"",
      ""Severity"": ""Low"",
      ""Description"": ""The configure function validates that `VARS.precision = precision == 0 ? precision : precision;`. This assignment doesn\'t change anything."",
      ""Impact"": ""Code is misleading and doesn't perform a useful function."",
      ""Location"": ""configure""
    },
    {
      ""Issue"": ""Inconsistent Use of `precision` Parameter"",
      ""Severity"": ""Low"",
      ""Description"": ""The `precision` parameter is used in the `getLatestFLNQuote` function for calls to `BehodlerLike`, indicating it is intended for use by the Behodler contract. However, the current validation doesn’t make it clear what values would be valid or invalid, and setting it to zero doesn’t appear to have any effect."",
      ""Impact"": ""Potential for incorrect calculations or unexpected behavior if the `precision` parameter is not properly understood and utilized by the BehodlerLike contract."",
      ""Location"": ""`configure` function, `getLatestFLNQuote` function""
    }
  ],
  ""IssueNumber"": 38,
  ""OutputList"": 12
}",230.09188413619995,4461.0,32.0,"### **[M-07] Calling generateFLNQuote twice in every block prevents any migration**

**Report Description**:
The `generateFLNQuote` function in the `UniswapHelper` contract is public, allowing any user to generate the latest quote. If this function is called twice in the same block, both quotes will have the same `blockProduced` value. These quotes are used in the `_ensurePriceStability` function, which contains a critical `require` statement that checks the `blockProduced` value. This could prevent migrations from occurring, as the function will fail if two quotes with the same `blockProduced` value are used.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of calling `generateFLNQuote` twice in the same block, which could prevent migrations. This is a specific vulnerability related to the `blockProduced` value and its impact on the `_ensurePriceStability` function, and it is not covered in the response list.

---

### **[M-11] You can grief migrations by sending SCX to the UniswapHelper**

**Report Description**:
An attacker can prevent migrations by sending SCX tokens to the `UniswapHelper` contract. This attack is recoverable by calling the `buyFlanAndBurn` function with SCX as the input token to buy Flan with the extra SCX, and then running the migration again. However, the attack can still disrupt the migration process temporarily.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of griefing migrations by sending SCX to the `UniswapHelper` contract. This is a specific attack vector that is not covered in the response list.

---

### **[M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks**

**Report Description**:
The `buyFlanAndBurn` function is vulnerable to sandwich attacks, where a malicious bot can manipulate the price of Flan before and after the transaction. For example, if Flan is trading at 0.8 in the input token terms, a bot could buy Flan, pushing the price to 0.9 before the `buyFlanAndBurn` transaction is executed, and then sell it back afterward. This results in the input token being overspent, leading to direct losses for the system.

**Match in Response List**:
Matches with the issue titled **""Lack of Slippage Control in `buyFlanAndBurn`""**.

**Validation**:
**Partially Correct**. The response identifies the lack of slippage control in `buyFlanAndBurn`, which is related to the vulnerability described in the issue. However, the response does not explicitly mention the sandwich attack vector or the specific manipulation of Flan prices, which are critical aspects of the issue. Therefore, the response is partially correct but misses key details.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-14] UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks**

**Missed Issues from Issue Report**:
- **[M-07] Calling generateFLNQuote twice in every block prevents any migration**
- **[M-11] You can grief migrations by sending SCX to the UniswapHelper**

---

The response list does not adequately address the specific vulnerabilities and attack vectors described in the issue report. While it covers some related issues, such as the lack of slippage control, it misses critical details and does not address the core problems in the issues related to `generateFLNQuote` and griefing migrations with SCX.","```
None.
```",0.0
