nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
LendingPool.sol,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';

/**
 * @title Contract that deals with pooling of capital from lenders
 * @notice Implements the functions related to lender pooling
 * @author Sublime
 **/

contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    //-------------------------------- Constants start --------------------------------//

    /**
     * @notice address of savings account
     */
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    /**
     * @notice address of pooled credit line
     */
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    /**
     * @notice address of verification module
     */
    IVerification public immutable VERIFICATION;
    /*
     * @notice Factor with which certain variables/constants are multiplied to maintain precision
     */
    uint256 constant SCALING_FACTOR = 1e18;

    //-------------------------------- Constants end --------------------------------//

    //-------------------------------- State variables start --------------------------------//

    /**
     * @notice Struct that stores the interest withdrawn by the lender of a specific credit line
     * @param borrowerInterestSharesWithdrawn interest paid by borrower in shares, withdrawn by lender
     * @param yieldInterestWithdrawnShares interest from yield strategy withdrawn by lender
     */
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    /**
     * @notice Struct that stores the constants of a pooled credit line
     * @param startTime Timestamp at which pooled credit line starts
     * @param borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param collateralAsset address of token that is used as collateral deposited by the borrower
     * @param borrowLimit max tokens that was requested by borrower
     * @param minBorrowAmount min tokens that was requested by borrower
     * @param lenderVerifier address of verifier with which lenders should be verified to lend
     * @param borrowAssetStrategy address of strategy to deposit lent tokens to in savings account
     * @param areTokensTransferable boolean that represents if pool tokens for pooled credit line are transferable
     */
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    /**
     * @notice Struct that stores the variables of a pooled credit line
     * @param lenders mapping that stores lender specific info for the pooled credit line
     * @param sharesHeld total shares of borrow token held by the pooled credit line
              sharesHeld is set when the pcl is started and is equal to the shares equivalent to borrowLimit
              when any amount is borrowed sharedHeld is reduced and when interest is withdrawn sharesHeld is reduced
              when any amount is repaid sharedHeld is increased.
              if any liquidity is withdrawn by the lender after liquidation or closing of the pcl, sharesHeld is
              not changed.
     * @param borrowerInterestShares total interest in shares repaid by borrower
     * @param borrowerInterestSharesWithdrawn shares withdrawn from borrowerInterestShares
     * @param yieldInterestWithdrawnShares total yield interest in shares withdrawn by all lenders together
     * @param collateralHeld total collateral tokens held by pooled credit line in case of liquidation
     */
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    /**
     * @notice Mapping that stores constants for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    /**
     * @notice Mapping that stores variables for pooledCreditLine against it's id
     */
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    /**
     * @notice Mapping that stores total pooledCreditLine token supply against the creditLineId
     * @dev Since ERC1155 tokens don't support the totalSupply function it is maintained here
     */
    mapping(uint256 => uint256) public totalSupply;

    //-------------------------------- State variables end --------------------------------//

    //-------------------------------- Modifiers start --------------------------------//

    /**
     * @notice Modifier that allows only pooled credit line to call a function
     */
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    //-------------------------------- Modifiers end --------------------------------//

    //-------------------------------- Events start --------------------------------//

    //--------------------------- LenderPool events start ---------------------------//

    /**
     * @notice Emitted when lender deposits tokens for pooled credit line
     * @param id identifier for the pooled credit line
     * @param user address of the user
     * @param amount amount of tokens lent by user
     */
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn when pool is not cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares amount of shares of liquidity provided initially by lender withdrawn
     */
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when liquidity provided by lender is withdrawn as pool is cancelled
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param amount amount of tokens lent by the user which is withdrawn on pooled credit line cancellation
     */
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    /**
     * @notice Emitted when interest by yield or/and borrower is withdrawn
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param shares shares withdrawn by lender from interest accrued by yield as well as supplied by borrower
     */
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    /**
     * @notice Emitted when a lender withdraws their share of liquidation
     * @param id identifier for the pooled credit line
     * @param user address of the lender
     * @param collateralShare share of collateral withdrawn by lender from liquidation
     */
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    /**
     * @notice Emitted when a pooled credit line is liquidated by a lender
     * @param id identifier for the pooled credit line
     * @param collateralLiquidated amount of collateral that is received after liquidation
     */
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    //--------------------------- LenderPool events end ---------------------------//

    //-------------------------------- Events end --------------------------------//

    //-------------------------------- Init start --------------------------------//

    /**
     * @notice constructor to initialize immutable global variables
     * @param _pooledCreditLine address of pooled credit line contract
     * @param _savingsAccount address of savings account contract
     * @param _verification address of verification contract
     */
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    /**
     * @notice initializes the contract in context of proxy
     */
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    //-------------------------------- Init end --------------------------------//

    //-------------------------------- PCL creation start --------------------------------//

    /**
     * @notice function invoked when creating pooled credit line
     * @dev only pooled credit line can call the create function
     * @param _id identifier for the pooled credit line
     * @param _lenderVerifier address of verifier with which lenders should be verified to lend
     * @param _borrowAsset address of token that is being lent by lenders & borrowed by borrower
     * @param _borrowAssetStrategy address of strategy to deposit lent tokens to savings account
     * @param _borrowLimit max tokens that was requested by borrower
     * @param _minBorrowAmount min tokens that was requested by borrower
     * @param _collectionPeriod time for which tokens can be lent to pooled credit lines
     * @param _areTokensTransferable boolean that represents if pool tokens for credit line are transferable
     */
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    //-------------------------------- PCL creation end --------------------------------//

    //-------------------------------- Lend & accept start --------------------------------//

    /**
     * @notice Function used by lenders to lend to pooled credit line
     * @dev lent amount is deposited to savings account only once borrow limit is reached or if start is called
     * @param _id identifier for the pooled credit line
     * @param _amount amount of borrow tokens to lend
     */
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    /**
     * @notice function used to start the pooled credit line once the start time is reached
     * @dev this function needs to be called by the borrower
     * @param _id identifier for the pooled credit line
     */
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        // PCL can be started once the collection period is over
        require(block.timestamp >= _startTime, 'LP:S2');
        // PCL cannot be started once it has ended
        // PCL remains in the REQUESTED stage if it is not started
        // check _withdrawLiquidity method to see how these cases are handled
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        // If msg.sender is not borrower, then tx is rejected
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    //-------------------------------- Lend & accept end --------------------------------//

    //-------------------------------- callbacks start --------------------------------//

    /**
     * @notice Function invoked on borrow from the pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesBorrowed amount of shares borrowed
     */
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    /**
     * @notice Function invoked when repayment is done to pooled credit line
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _sharesRepaid shares repaid
     * @param _interestShares interest in shares repaid
     */
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    /**
     * @notice Function invoked when pooled credit line is cancelled
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     */
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        // We want *function lend* to fail, so that lenders do not keep on lending even after the CL is cancelled.
        delete pooledCLConstants[_id].startTime;

        // After this, we cannot delete *pooledCLConstants[_id]*, else we risk getting stuck with some of the lenders'
        // liquidity inside of this contract. Therefore, after this, the user must themselves call *withdrawLiquidity*
    }

    /**
     * @notice Function invoked when pooled credit line is terminated by admin
     * @dev only pooledCreditLineContract can invoke
     * @param _id identifier for the pooled credit line
     * @param _to address to which all the borrow tokens are transferred
     */
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this is the maximum amount which can be borrowed from the PCL
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        // the borrower has not borrowed this much amount yet
        // for eg: _borrowedLimit is 1000 DAI and the amount borrowed is 90 DAI
        // also _notBorrowed == _borrowedLimit when the PCL has not started
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            // the amount of _borrowAsset deposited by lenders against the PCL is equal to totalSupply[_id]
            // when the PCL is active totalSupply[_id] == _borrowedLimit
            // but _borrowLimit is some cases can be different than totalSupply[_id]
            // for eg: before the PCL has started the borrowLimit asked by borrower is 1000 DAI
            // but the lenders have only deposited 900 DAI till now so totalSupply[_id] is 900 DAI
            // another eg is when the PCL has already been liquidated and some lenders have withdrawn the funds
            // in this case too _borrowedLimit is greater than the totalSupply[_id]
            // we multiply _notBorrowedInShares with the ratio of totalSupply[_id]/_borrowLimit
            // this is done to get the _actualNotBorrowedInShares which might be less than the
            // _notBorrowedInShares because of totalSupply[_id] being less than _borrowedLimit
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            // shareWithdrawable = _actualNotBorrowedInShares + _totalInterestInShares
            // _totalInterestInShares is not adjusted for change in totalSupply[_id] because
            // no withdrawal of the principal fund deposited in the PCL can happen when it is active
            // interest withdrawn from the PCL has already been deducted from sharesHeld
            // interest (borrow + yield) come into the picture only after the PCL was activated in its lifetime
            // borrowInterest is accrued only when PCL is active
            // yield interest is accrued funds are deposited in the _strategy contract and is intrinsic to the shares
            // any change in the totalSupply[_id] on does affect the interest shares in the PCL
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            // transferring the collateral that is transferred to Lender pool to distribute among lenders as part of liquidation
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    //-------------------------------- callbacks end --------------------------------//

    //-------------------------------- Interest start --------------------------------//

    /**
     * @notice Function used to withdraw interest repaid by the borrower and
               the yield interest generated by the borrow assets deposited in the strategy
     * @dev Tokens lent are locked till end of Pooled Credit line. 
            Any interest paid by borrower can be withdrawn by lenders proportional to
            their token balances for that pooled credit line. Partial withdrawal of
            interest is not allowed. Whenever they call the `withdrawInterest` function
            they will get the entire amount of interest that is owed to them by that time
     * @param _id identifier for the pooled credit line
     */
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // this checks if the constants are not deleted
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    /*
     * @dev this function updates the interest shares withdrawn by the lender.
            interest shares are of 2 types
            - borrowerInterestSharesWithdrawn: this is the interest paid by the borrower and withdrawn by the lender
            - yieldInterestWithdrawnShares: this is the interest accrued from the yield strategy and withdrawn by the lender
     */
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    /**
     * @notice Function used to get interest withdrawable by a lender in pooled credit line.
               the interest this function returns is a sum of borrowerInterest + yieldInterest
               borrower interest is the interest paid by the borrower
               yield interest is the interest generated by the yield strategy
     * @dev it is a view function as far as the Pooled credit lines are concerned and doesn't 
            make any state changes except for getSharesForTokens and getTokensForShares in yield
     * @param _lender address of lender for whom interest is withdrawn
     */
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        // get borrower repayments and yield interest shares
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        // convert total interest shares into tokens and return
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            // _sharesHeld is set in the _accept method
            // _sharesHeld == 0 is in these PCL stages: not created, requested, cancelled and terminated
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            // _notBorrowed is converted to _notBorrowedInShares using the current exchange rate
            // The difference in _sharesHeld and (_notBorrowedInShares + shares withdrawn)
            // is the _totalYieldInterest
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    //-------------------------------- Interest end --------------------------------//

    //-------------------------------- Liquidity withdraw start --------------------------------//

    /**
     * @notice Function to withdraw liquidity by lender
     * @dev Liquidity can be withdrawn when the pooled credit line in the following scenarios
            - pcl is cancelled by the borrower
            - pcl gets cancelled because because desired amount wasn't reached
            - pcl gets cancelled because it was never started by the borrower and endTime has reached
            - pcl is liquidated before the endTime has reached
            - pcl is liquidated after the endTime has reached
            - pcl is closed after all repayments
           in the other cases this function reverts
     * @param _id identifier for the pooled credit line
     */

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            // Case 0:
            // Credit Line request was cancelled by the borrower, which deletes the creditLineVariables, hence status = uint256(0)
            // Cancellation can only be done in the REQUESTED state, therefore, the borrowLimit target was also not met
            // &&
            // Case 1: Pooled credit line never started because desired amount wasn't reached
            // _maxToLend is 0 if credit line is accepted so this case is never run

            //transfer liquidity provided
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                // _isLiquidationWithdrawn is true when _withdrawLiquidity is called from within
                // withdrawTokensAfterLiquidation which means the lender is withdrawing all assets after the PCL
                // has been liquidated. Once PCL has been liquidated lender cannot call withdrawLiquidity directly
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            // all other cases distribute the sharesHeld proportional to their poolToken balances
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    /**
     * @notice Function that can be used to calculate principal withdrawable
     * @param _id identifier for the pooled credit line
     * @param _lender lender whose share of principal is to be withdrawn
     * @return Principal withdrawable
     */
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            // this else if block covers the conditions when PCL was cancelled OR
            // the PCL was in requested stage but never started
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    /*
    * @dev returns the amount of principal the lender can withdraw after the pcl has been liquidated or closed
           this value is equal to (total lent amount - principal borrowed) * lenders lp balance / total lent amount
    */
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    //-------------------------------- Liquidity withdraw end --------------------------------//

    //-------------------------------- Liquidation start --------------------------------//

    /**
     * @notice Function used to liquidate a pooled credit line
     * @dev only one of the lenders can liquidate their pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _withdraw flag used to identify if lender's share of
              liquidated collateral and liquidity (amount lent + interest) is also withdrawn
     */
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        // This line would call the liquidate function in the pooledCreditLine contract.
        // Which would transfer the totalCollateralTokens to the pooledCreditLine contract.
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            // This function would give the share of the lender who called this function from the total liquidated amount
            // this will withdraw both the _collateralAsset and the borrowAsset
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    /**
     * @notice Function used to withdraw lender's share of liquidated collateral and the borrowAsset
     * @param _id identifier for the pooled credit line
     */
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        // this will withdraw the lender's share of liquidity (amount lent + interest)
        _withdrawLiquidity(_id, true);
    }

    //-------------------------------- Liquidation end --------------------------------//

    //-------------------------------- Pre token transfer start --------------------------------//

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                // cannot transfer to the borrower
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                // cannot transfer to a non verified user
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                // this is the case for minting tokens
                // increase the total supply of lp tokens
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                // this is the case for burn
                // reduce the total supply of lp tokens
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                // case for user to user transfer
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                // we need to transfer the lender info from to the receiving address
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            // if the transfer is from user to user, we will withdraw all the interest for the user
            // this is done because we need to transfer the lender info
            // if the interest is not withdrawn the [from] user will not be able to withdraw the interest owned to them
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    //-------------------------------- Pre token transfer end --------------------------------//

    //-------------------------------- getters start --------------------------------//

    /**
     * @notice Function used to get withdrawal info of a lender for a specific pooled credit line
     * @param _id identifier for the pooled credit line
     * @param _lender address of the lender for which query is made
     * @return returns lender info
     */
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    //-------------------------------- getters end --------------------------------//
}

",9069,858,"[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee
LenderPool.sol#L594-L599 LenderPool.sol#L399-L404
The _principalWithdrawable calculated will be more than expected if _start() is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in totalSupply[id] not being 1:1 with the borrow limit.
``` function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {
  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
  return _principalWithdrawable;
} ```  [H-02] PooledCreditLine: termination likely fails because _principleWithdrawable is treated as shares
LenderPool.sol#L404-L406
_principalWithdrawable is denominated in the borrowAsset, but subsequently treats it as the share amount to be withdrawn.
``` // _notBorrowed = borrowAsset amount that isn't borrowed
// totalSupply[_id] = ERC1155 total supply of _id
// _borrowedTokens = borrower's specified borrowLimit
uint256 _principalWithdrawable = _notBorrowed.mul(totalSupply[_id]).div(_borrowedTokens);

SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _principalWithdrawable.add(_totalInterestInShares), false);
``` 
 [M-01] Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens
`IERC20(_borrowAsset).transfer(_to, _fee);`
If the USDT token is supported as _borrowAsset, the unsafe version of .transfer(_to, _fee) may revert as there is no return value in the USDT token contract’s transfer() implementation (but the IERC20 interface expects a return value).
Function start() will break when _borrowAsset is USDT or Non ERC20 Compliant Tokens. USDT is one of the most borrowed Asset in DEFI. This may cause losing a lot of potential users.
   [M-02] Lack of access control allow anyone to withdrawInterest() for any lender
LenderPool.sol#L442 ```
function withdrawInterest(uint256 _id, address _lender) external nonReentrant {
    _withdrawInterest(_id, _lender);
}

function _withdrawInterest(uint256 _id, address _lender) internal {
    address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
    address _borrowAsset = pooledCLConstants[_id].borrowAsset;

    (uint256 _interestToWithdraw, uint256 _interestSharesToWithdraw) = _calculateInterestToWithdraw(
        _id,
        _lender,
        _strategy,
        _borrowAsset
    );
    pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);

    if (_interestToWithdraw != 0) {
        SAVINGS_ACCOUNT.withdraw(_borrowAsset, _strategy, _lender, _interestToWithdraw, false);
    }
    emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
}
```
`withdrawInterest()` at a certain time may not be in the best interest of the specific `lender`.
It's unconventional and can potentially cause leak of value for the lender. For example, the lender may still want to accrued more interest from the strategy.
   [M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time
LenderPool.sol#L312 LenderPool.sol#L336
An attacker could keep track of the `totalSupply` of each LenderPool to see if it is more than the `minBorrowAmount`. If so, at startTime, which is pre-announced, the attacker could call `start`, which will trigger `SAVINGS_ACCOUNT.deposit()` of the entire pool assets to mint LP tokens from external strategy, for example, in CompoundYield.
There is potentially a big sum depositing into a known Compound `cToken` contract at a known fixed time. Thus, the attacker could prepare the pool by depositing a fair sum first to lower the exchange rate before calling start in lenderPool. Hence, the deposit of the entire pool could be at a less favourable rate. This also applies to other potential strategies that are yet to be integrated. For example, in Curve pool, the attacker could prime the pool to be very imbalanced first and trigger the deposit and then harvest the arbitrage bonus by bringing the pool back to balance.
This attack can happen once only when the pooledCreditLine becomes active for each new lenderPool.
",5,,"pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '../interfaces/ISavingsAccount.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ILenderPool.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IPooledCreditLine.sol';
import '../interfaces/IPooledCreditLineEnums.sol';



contract LenderPool is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IPooledCreditLineEnums, ILenderPool {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    

    
    ISavingsAccount public immutable SAVINGS_ACCOUNT;
    
    IPooledCreditLine public immutable POOLED_CREDIT_LINE;
    
    IVerification public immutable VERIFICATION;
    
    uint256 constant SCALING_FACTOR = 1e18;

    

    

    
    struct LenderInfo {
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
    }

    
    struct LenderPoolConstants {
        uint256 startTime;
        address borrowAsset;
        address collateralAsset;
        uint256 borrowLimit;
        uint256 minBorrowAmount;
        address lenderVerifier;
        address borrowAssetStrategy;
        bool areTokensTransferable;
    }

    
    struct LenderPoolVariables {
        mapping(address => LenderInfo) lenders;
        uint256 sharesHeld;
        uint256 borrowerInterestShares;
        uint256 borrowerInterestSharesWithdrawn;
        uint256 yieldInterestWithdrawnShares;
        uint256 collateralHeld;
    }

    
    mapping(uint256 => LenderPoolConstants) public pooledCLConstants;
    
    mapping(uint256 => LenderPoolVariables) public pooledCLVariables;
    
    mapping(uint256 => uint256) public totalSupply;

    

    

    
    modifier onlyPooledCreditLine() {
        require(msg.sender == address(POOLED_CREDIT_LINE), 'LP:OPCL1');
        _;
    }

    

    

    

    
    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);
    
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);
    
    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);
    
    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    
    event Liquidated(uint256 indexed id, uint256 collateralLiquidated);

    

    

    

    
    constructor(
        address _pooledCreditLine,
        address _savingsAccount,
        address _verification
    ) {
        require(_pooledCreditLine != address(0), 'LP:C1');
        require(_savingsAccount != address(0), 'LP:C2');
        require(_verification != address(0), 'LP:C3');
        POOLED_CREDIT_LINE = IPooledCreditLine(_pooledCreditLine);
        SAVINGS_ACCOUNT = ISavingsAccount(_savingsAccount);
        VERIFICATION = IVerification(_verification);
    }

    
    function initialize() external initializer {
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        __ERC1155_init('URI');
    }

    

    

    
    function create(
        uint256 _id,
        address _lenderVerifier,
        address _borrowAsset,
        address _borrowAssetStrategy,
        uint256 _borrowLimit,
        uint256 _minBorrowAmount,
        uint256 _collectionPeriod,
        bool _areTokensTransferable
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLConstants[_id].startTime = block.timestamp.add(_collectionPeriod);
        pooledCLConstants[_id].borrowAsset = _borrowAsset;
        pooledCLConstants[_id].borrowLimit = _borrowLimit;
        pooledCLConstants[_id].minBorrowAmount = _minBorrowAmount;
        pooledCLConstants[_id].lenderVerifier = _lenderVerifier;
        pooledCLConstants[_id].borrowAssetStrategy = _borrowAssetStrategy;
        pooledCLConstants[_id].areTokensTransferable = _areTokensTransferable;

        uint256 allowance = SAVINGS_ACCOUNT.allowance(address(this), _borrowAsset, address(POOLED_CREDIT_LINE));
        if (allowance != type(uint256).max) {
            SAVINGS_ACCOUNT.approve(_borrowAsset, address(POOLED_CREDIT_LINE), type(uint256).max);
        }
    }

    

    

    
    function lend(uint256 _id, uint256 _amount) external nonReentrant {
        require(_amount != 0, 'LP:L1');
        require(VERIFICATION.isUser(msg.sender, pooledCLConstants[_id].lenderVerifier), 'LP:L2');
        require(block.timestamp < pooledCLConstants[_id].startTime, 'LP:L3');

        uint256 _totalLent = totalSupply[_id];
        uint256 _maxLent = pooledCLConstants[_id].borrowLimit;
        require(_maxLent > _totalLent, 'LP:L4');

        uint256 _amountToLend = _amount;
        if (_totalLent.add(_amount) > _maxLent) {
            _amountToLend = _maxLent.sub(_totalLent);
        }
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amountToLend);
        _mint(msg.sender, _id, _amountToLend, '');

        emit Lend(_id, msg.sender, _amountToLend);
    }

    
    function start(uint256 _id) external override nonReentrant {
        uint256 _startTime = pooledCLConstants[_id].startTime;
        require(_startTime != 0, 'LP:S1');
        
        require(block.timestamp >= _startTime, 'LP:S2');
        
        
        
        require(block.timestamp < POOLED_CREDIT_LINE.getEndsAt(_id), 'LP:S3');

        uint256 _totalLent = totalSupply[_id];
        require(_totalLent >= pooledCLConstants[_id].minBorrowAmount, 'LP:S4');

        _accept(_id, _totalLent);
    }

    function _accept(uint256 _id, uint256 _amount) private {
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        IERC20(_borrowAsset).safeApprove(_strategy, _amount);
        pooledCLVariables[_id].sharesHeld = SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount);

        
        POOLED_CREDIT_LINE.accept(_id, _amount, msg.sender);

        pooledCLConstants[_id].borrowLimit = _amount;
        delete pooledCLConstants[_id].startTime;
        delete pooledCLConstants[_id].minBorrowAmount;
    }

    

    

    
    function borrowed(uint256 _id, uint256 _sharesBorrowed) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_sharesBorrowed);
    }

    
    function repaid(
        uint256 _id,
        uint256 _sharesRepaid,
        uint256 _interestShares
    ) external override nonReentrant onlyPooledCreditLine {
        pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.add(_sharesRepaid);
        pooledCLVariables[_id].borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares.add(_interestShares);
    }

    
    function requestCancelled(uint256 _id) external override onlyPooledCreditLine {
        
        delete pooledCLConstants[_id].startTime;

        
        
    }

    
    function terminate(uint256 _id, address _to) external override nonReentrant onlyPooledCreditLine {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        
        
        
        uint256 _notBorrowed = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
        uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
        if (_sharesHeld != 0) {
            uint256 _totalInterestInShares = _sharesHeld.sub(_notBorrowedInShares);
            
            
            
            
            
            
            
            
            
            
            uint256 _actualNotBorrowedInShares = _notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens);
            
            
            
            
            
            
            
            
            uint256 _totalBorrowAsset = _actualNotBorrowedInShares.add(_totalInterestInShares);
            if (_totalBorrowAsset != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _totalBorrowAsset, false);
            }
        }

        uint256 _collateralHeld = pooledCLVariables[_id].collateralHeld;
        if (_collateralHeld != 0) {
            
            IERC20(pooledCLConstants[_id].collateralAsset).safeTransfer(_to, _collateralHeld);
        }
        delete pooledCLConstants[_id];
        delete pooledCLVariables[_id];
    }

    

    

    
    function withdrawInterest(uint256 _id) external nonReentrant {
        uint256 _interestSharesWithdrawn = _withdrawInterest(_id, msg.sender);
        require(_interestSharesWithdrawn != 0, 'LP:WI1');
    }

    function _withdrawInterest(uint256 _id, address _lender) private returns (uint256 _interestSharesWithdrawn) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        require(_strategy != address(0), 'LP:IWI1');

        uint256 _interestSharesToWithdraw = _updateInterestSharesToWithdraw(_id, _lender, _strategy, _borrowAsset);

        if (_interestSharesToWithdraw != 0) {
            pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesToWithdraw);
            SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _lender, _interestSharesToWithdraw, false);
            emit InterestWithdrawn(_id, _lender, _interestSharesToWithdraw);
        }

        return _interestSharesToWithdraw;
    }

    
    function _updateInterestSharesToWithdraw(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset
    ) private returns (uint256) {
        uint256 _lenderBalance = balanceOf(_lender, _id);
        if (_lenderBalance == 0) {
            return 0;
        }

        uint256 _borrowLimit = pooledCLConstants[_id].borrowLimit;
        (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            _lenderBalance,
            _borrowLimit
        );

        if (_borrowerInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn = pooledCLVariables[_id]
                .lenders[_lender]
                .borrowerInterestSharesWithdrawn
                .add(_borrowerInterestSharesForLender);
            pooledCLVariables[_id].borrowerInterestSharesWithdrawn = pooledCLVariables[_id].borrowerInterestSharesWithdrawn.add(
                _borrowerInterestSharesForLender
            );
        }

        if (_yieldInterestSharesForLender != 0) {
            pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares = pooledCLVariables[_id]
                .lenders[_lender]
                .yieldInterestWithdrawnShares
                .add(_yieldInterestSharesForLender);
            pooledCLVariables[_id].yieldInterestWithdrawnShares = pooledCLVariables[_id].yieldInterestWithdrawnShares.add(
                _yieldInterestSharesForLender
            );
        }

        return _yieldInterestSharesForLender.add(_borrowerInterestSharesForLender);
    }

    
    function getLenderInterestWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
        address _borrowAsset = pooledCLConstants[_id].borrowAsset;
        
        (uint256 _borrowerInterestShares, uint256 _yieldInterestShares) = _calculateLenderInterest(
            _id,
            _lender,
            _strategy,
            _borrowAsset,
            balanceOf(_lender, _id),
            pooledCLConstants[_id].borrowLimit
        );
        
        return IYield(_strategy).getTokensForShares(_borrowerInterestShares.add(_yieldInterestShares), _borrowAsset);
    }

    function _calculateLenderInterest(
        uint256 _id,
        address _lender,
        address _strategy,
        address _borrowAsset,
        uint256 _lenderBalance,
        uint256 _borrowLimit
    ) private returns (uint256 _borrowerInterestSharesForLender, uint256 _yieldInterestSharesForLender) {
        uint256 _totalInterestWithdrawableInShares;
        {
            uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;
            
            
            if (_sharesHeld == 0) {
                return (0, 0);
            }
            uint256 _notBorrowed = _borrowLimit.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
            uint256 _notBorrowedInShares = IYield(_strategy).getSharesForTokens(_notBorrowed, _borrowAsset);
            _totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);
        }
        uint256 _borrowerInterestShares = pooledCLVariables[_id].borrowerInterestShares;
        _borrowerInterestSharesForLender = (_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
            pooledCLVariables[_id].lenders[_lender].borrowerInterestSharesWithdrawn
        );

        {
            uint256 _borrowerInterestWithdrawableInShares = _borrowerInterestShares.sub(
                pooledCLVariables[_id].borrowerInterestSharesWithdrawn
            );
            
            
            
            _yieldInterestSharesForLender = 0;
            if (_totalInterestWithdrawableInShares > _borrowerInterestWithdrawableInShares) {
                uint256 _totalYieldInterestShares = _totalInterestWithdrawableInShares.sub(_borrowerInterestWithdrawableInShares).add(
                    pooledCLVariables[_id].yieldInterestWithdrawnShares
                );
                _yieldInterestSharesForLender = (_totalYieldInterestShares.mul(_lenderBalance).div(_borrowLimit)).sub(
                    pooledCLVariables[_id].lenders[_lender].yieldInterestWithdrawnShares
                );
            }
        }
    }

    

    

    

    function withdrawLiquidity(uint256 _id) external nonReentrant {
        _withdrawLiquidity(_id, false);
    }

    function _withdrawLiquidity(uint256 _id, bool _isLiquidationWithdrawn) private {
        uint256 _liquidityProvided = balanceOf(msg.sender, _id);
        require(_liquidityProvided != 0, 'LP:IWL1');

        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);

        address _borrowAsset = pooledCLConstants[_id].borrowAsset;

        if (_status == PooledCreditLineStatus.REQUESTED) {
            if (block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) {
                POOLED_CREDIT_LINE.cancelRequestOnLowCollection(_id);
            } else if (block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)) {
                POOLED_CREDIT_LINE.cancelRequestOnRequestedStateAtEnd(_id);
            } else {
                revert('LP:IWL3');
            }
            _status = PooledCreditLineStatus.CANCELLED;
            delete pooledCLConstants[_id].startTime;
        }

        if (_status == PooledCreditLineStatus.CANCELLED) {
            
            
            
            
            
            

            
            IERC20(_borrowAsset).safeTransfer(msg.sender, _liquidityProvided);
            emit WithdrawLiquidityOnCancel(_id, msg.sender, _liquidityProvided);
        } else if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            if (_status == PooledCreditLineStatus.LIQUIDATED) {
                
                
                
                require(_isLiquidationWithdrawn, 'LP:IWL2');
            }
            
            address _strategy = pooledCLConstants[_id].borrowAssetStrategy;
            uint256 _principalWithdrawable = _calculatePrincipalWithdrawable(_id, msg.sender);
            uint256 _interestSharesWithdrawable = _updateInterestSharesToWithdraw(_id, msg.sender, _strategy, _borrowAsset);
            uint256 _interestWithdrawable;
            if (_interestSharesWithdrawable != 0) {
                _interestWithdrawable = IYield(_strategy).getTokensForShares(_interestSharesWithdrawable, _borrowAsset);
                pooledCLVariables[_id].sharesHeld = pooledCLVariables[_id].sharesHeld.sub(_interestSharesWithdrawable);
            }
            uint256 _amountToWithdraw = _principalWithdrawable.add(_interestWithdrawable);
            uint256 _sharesToWithdraw = IYield(_strategy).getSharesForTokens(_amountToWithdraw, _borrowAsset);
            if (_sharesToWithdraw != 0) {
                SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, msg.sender, _sharesToWithdraw, false);
            }
            emit WithdrawLiquidity(_id, msg.sender, _sharesToWithdraw);
        } else {
            revert('LP:IWL3');
        }

        _burn(msg.sender, _id, _liquidityProvided);
    }

    
    function calculatePrincipalWithdrawable(uint256 _id, address _lender) external returns (uint256) {
        PooledCreditLineStatus _status = POOLED_CREDIT_LINE.getStatusAndUpdate(_id);
        if (_status == PooledCreditLineStatus.CLOSED || _status == PooledCreditLineStatus.LIQUIDATED) {
            return _calculatePrincipalWithdrawable(_id, _lender);
        } else if (
            _status == PooledCreditLineStatus.CANCELLED ||
            (_status == PooledCreditLineStatus.REQUESTED &&
                ((block.timestamp >= pooledCLConstants[_id].startTime && totalSupply[_id] < pooledCLConstants[_id].minBorrowAmount) ||
                    block.timestamp >= POOLED_CREDIT_LINE.getEndsAt(_id)))
        ) {
            
            
            return balanceOf(_lender, _id);
        } else {
            return 0;
        }
    }

    
    function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }

    

    

    
    function liquidate(uint256 _id, bool _withdraw) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:LIQ1');
        
        
        (address _collateralAsset, uint256 _collateralLiquidated) = POOLED_CREDIT_LINE.liquidate(_id);
        pooledCLConstants[_id].collateralAsset = _collateralAsset;
        pooledCLVariables[_id].collateralHeld = _collateralLiquidated;

        emit Liquidated(_id, _collateralLiquidated);

        if (_withdraw) {
            
            
            _withdrawTokensAfterLiquidation(_id, _lendingShare);
        }
    }

    
    function withdrawTokensAfterLiquidation(uint256 _id) external nonReentrant {
        uint256 _lendingShare = balanceOf(msg.sender, _id);
        require(_lendingShare != 0, 'LP:WLC1');
        _withdrawTokensAfterLiquidation(_id, _lendingShare);
    }

    function _withdrawTokensAfterLiquidation(uint256 _id, uint256 _balance) private {
        address _collateralAsset = pooledCLConstants[_id].collateralAsset;
        require(_collateralAsset != address(0), 'LP:IWLC1');
        uint256 _collateralLiquidated = pooledCLVariables[_id].collateralHeld;
        uint256 _currentSupply = totalSupply[_id];

        uint256 _lenderCollateralShare = _balance.mul(_collateralLiquidated).div(_currentSupply);

        if (_lenderCollateralShare != 0) {
            pooledCLVariables[_id].collateralHeld = pooledCLVariables[_id].collateralHeld.sub(_lenderCollateralShare);

            IERC20(_collateralAsset).safeTransfer(msg.sender, _lenderCollateralShare);
            emit LiquidationWithdrawn(_id, msg.sender, _lenderCollateralShare);
        }
        
        _withdrawLiquidity(_id, true);
    }

    

    

    function _beforeTokenTransfer(
        address,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory
    ) internal override {
        require(from != to, 'LP:IT1');
        for (uint256 i; i < ids.length; ++i) {
            uint256 id = ids[i];
            if (to != address(0)) {
                
                require(to != POOLED_CREDIT_LINE.getBorrowerAddress(id), 'LP:IT2');
                
                require(VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier), 'LP:IT3');
            }

            uint256 amount = amounts[i];

            if (from == address(0)) {
                
                
                totalSupply[id] = totalSupply[id].add(amount);
            } else if (to == address(0)) {
                
                
                uint256 supply = totalSupply[id];
                require(supply >= amount, 'LP:IT4');
                totalSupply[id] = supply - amount;
            } else {
                
                require(pooledCLConstants[id].areTokensTransferable, 'LP:IT5');
            }

            if (from != address(0)) {
                
                _rebalanceInterestWithdrawn(id, amount, from, to);
            }
        }
    }

    function _rebalanceInterestWithdrawn(
        uint256 id,
        uint256 amount,
        address from,
        address to
    ) private {
        if (from != address(0) && to != address(0)) {
            
            
            
            _withdrawInterest(id, from);
            _withdrawInterest(id, to);
        }

        uint256 fromBalance = balanceOf(from, id);
        require(fromBalance != 0, 'LP:IRIW1');

        uint256 yieldInterestOnTransferAmount = pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares.mul(amount).div(
            fromBalance
        );
        uint256 borrowerInterestOnTransferAmount = pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn.mul(amount).div(
            fromBalance
        );

        if (borrowerInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                .lenders[from]
                .borrowerInterestSharesWithdrawn
                .sub(borrowerInterestOnTransferAmount);
        }

        if (yieldInterestOnTransferAmount != 0) {
            pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares = pooledCLVariables[id]
                .lenders[from]
                .yieldInterestWithdrawnShares
                .sub(yieldInterestOnTransferAmount);
        }

        if (to != address(0)) {
            if (borrowerInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].borrowerInterestSharesWithdrawn = pooledCLVariables[id]
                    .lenders[to]
                    .borrowerInterestSharesWithdrawn
                    .add(borrowerInterestOnTransferAmount);
            }
            if (yieldInterestOnTransferAmount != 0) {
                pooledCLVariables[id].lenders[to].yieldInterestWithdrawnShares = pooledCLVariables[id]
                    .lenders[to]
                    .yieldInterestWithdrawnShares
                    .add(yieldInterestOnTransferAmount);
            }
        }
    }

    

    

    
    function getLenderInfo(uint256 _id, address _lender) external view returns (LenderInfo memory) {
        return pooledCLVariables[_id].lenders[_lender];
    }

    
}",5453,2,3,"{
  ""task_list"": [
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify that all external calls, especially those to SAVINGS_ACCOUNT, IYield, and IERC20 contracts, are protected against reentrancy attacks beyond the `nonReentrant` modifier. Pay close attention to multi-call scenarios where a reentrant call could bypass the modifier's protection."",
        ""Examine the `withdrawInterest`, `withdrawLiquidity`, `liquidate`, and `_rebalanceInterestWithdrawn` functions for potential reentrancy issues, especially considering the calls to `SAVINGS_ACCOUNT.withdrawShares` and `IERC20.safeTransfer` within loops or after state modifications."",
        ""Simulate potential reentrancy scenarios by crafting malicious contracts that could be called by the LenderPool contract during normal operation. Attempt to manipulate state variables or drain funds.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflows/Underflows"",
      ""Tasks"": [
        ""Although SafeMath is used, review all arithmetic operations involving user-supplied inputs or values derived from external contracts to ensure that no overflows or underflows can occur in practice. Special attention should be given to subtractions and divisions."",
        ""Analyze the `_calculateLenderInterest` and `_calculatePrincipalWithdrawable` functions for potential underflows due to incorrect ordering of operations or unexpected input values. Consider edge cases where balances or shares are very low or very high."",
        ""Specifically review subtractions within the `_updateInterestSharesToWithdraw` and `_rebalanceInterestWithdrawn` functions, as well as the `_notBorrowed.sub(POOLED_CREDIT_LINE.getPrincipal(_id))` within the `terminate` function.""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Confirm that the `onlyPooledCreditLine` modifier is correctly applied to all functions that should only be callable by the POOLED_CREDIT_LINE contract. Verify that no sensitive functions are missing this modifier."",
        ""Verify the logic within `create` function to ensure that only `POOLED_CREDIT_LINE` can create new pools."",
        ""Analyze the `VERIFICATION.isUser` calls in the `lend` and `_beforeTokenTransfer` functions to ensure that the correct lender verifier is being used and that the verification process is secure and reliable. Investigate the potential for bypass or manipulation of the verification process."",
        ""Check that the constructor properly sets the immutable addresses for POOLED_CREDIT_LINE, SAVINGS_ACCOUNT, and VERIFICATION and that these addresses cannot be changed after deployment. Confirm that zero-address checks are present and enforced."",
        ""Review the access control mechanisms for critical state variables, ensuring that only authorized entities can modify them. Pay attention to the potential for unauthorized modification of `pooledCLConstants`, `pooledCLVariables`, and `totalSupply`.""
      ]
    },
    {
      ""Area"": ""ERC1155 Token Implementation and Transfer Restrictions"",
      ""Tasks"": [
        ""Ensure compliance with the ERC1155 standard, paying close attention to the handling of token IDs, balances, and metadata URI. Verify that the `_mint` and `_burn` functions are used correctly and that token transfers are handled securely."",
        ""Thoroughly examine the `_beforeTokenTransfer` hook to ensure that the transfer restrictions are enforced correctly. Verify that transfers to the borrower address are prohibited and that the lender verifier check is consistently applied."",
        ""Analyze the logic within the `_rebalanceInterestWithdrawn` function to confirm that interest shares are correctly rebalanced between sender and receiver during token transfers. Ensure that no interest shares are lost or double-counted."",
        ""Investigate potential vulnerabilities related to batch token transfers, especially in the context of interest rebalancing and transfer restrictions. Test for unexpected behavior or errors when transferring multiple tokens simultaneously."",
        ""Specifically examine the logic within `_beforeTokenTransfer` to guarantee that totalSupply is correctly updated during minting and burning. Confirm there are no scenarios where the totalSupply can be manipulated to cause incorrect interest calculations or withdrawal amounts.""
      ]
    },
    {
      ""Area"": ""Interest Calculation and Withdrawal"",
      ""Tasks"": [
        ""Carefully analyze the interest calculation logic in the `_calculateLenderInterest` function, paying close attention to the handling of borrower interest and yield interest. Verify that the calculations are accurate and fair to all lenders."",
        ""Investigate potential rounding errors or precision losses in the interest calculations, especially when dealing with large numbers or small balances. Ensure that these errors do not significantly impact the amount of interest received by lenders."",
        ""Review the logic in the `withdrawInterest` and `_updateInterestSharesToWithdraw` functions to ensure that interest shares are correctly tracked and withdrawn. Verify that lenders cannot withdraw more interest than they are entitled to."",
        ""Analyze the interaction with the `IYield` contract to ensure that the share-to-token conversion is accurate and reliable. Investigate potential vulnerabilities related to manipulation of the share price or exchange rate."",
        ""Verify that interest is only calculated and distributed after the pool has started and that the POOLED_CREDIT_LINE contract has repaid principal and interest."",
        ""Examine the logic that handles the case where `_sharesHeld` is zero in `_calculateLenderInterest`. This is a key edge case to ensure correct behavior.""
      ]
    },
    {
      ""Area"": ""Liquidity Withdrawal and Pool Termination"",
      ""Tasks"": [
        ""Thoroughly review the `withdrawLiquidity` and `terminate` functions to ensure that lenders can withdraw their principal and interest correctly after the pool is closed, liquidated, or cancelled. Verify that the correct amounts are calculated and transferred to the lenders."",
        ""Analyze the logic that handles the withdrawal of funds from the SAVINGS_ACCOUNT contract, ensuring that the correct shares are withdrawn and transferred to the lenders. Investigate potential vulnerabilities related to manipulation of the share price or exchange rate."",
        ""Examine the handling of collateral during liquidation and ensure that lenders receive their fair share of the liquidated collateral. Verify that the collateral is correctly transferred to the lenders."",
        ""Review the pool termination logic to ensure that all remaining assets are correctly distributed and that the pool's state is properly cleaned up. Verify that no funds are left behind or lost during termination."",
        ""Ensure the contract correctly handles the case where there's a difference between `totalSupply[_id]` and `_borrowedTokens`. Review division operations involving those values.""
      ]
    },
    {
      ""Area"": ""Interaction with External Contracts (SavingsAccount, Yield, Verification, PooledCreditLine, ERC20)"",
      ""Tasks"": [
        ""Verify that all calls to external contracts (SAVINGS_ACCOUNT, IYield, VERIFICATION, POOLED_CREDIT_LINE, IERC20) are handled securely and that the expected return values are validated. Check for potential vulnerabilities related to unexpected return values or reverts from these contracts."",
        ""Analyze the potential impact of changes or upgrades to the external contracts on the LenderPool contract. Ensure that the LenderPool contract is robust and can handle potential changes to the external contract interfaces or behavior."",
        ""Specifically focus on error handling around the calls to SAVINGS_ACCOUNT.deposit and SAVINGS_ACCOUNT.withdrawShares. What happens if these calls fail? Are there appropriate fallback mechanisms?"",
        ""Review the logic that uses the IYield interface, ensuring that the `getSharesForTokens` and `getTokensForShares` functions are used correctly and that the results are validated. Investigate potential vulnerabilities related to manipulation of the share price or exchange rate."",
        ""Assess the risks associated with the contract's reliance on the POOLED_CREDIT_LINE contract for determining the pool's status and managing borrowing activities. Verify that the LenderPool contract can handle potential inconsistencies or errors in the POOLED_CREDIT_LINE contract's state."",
         ""Review approval flow for SavingsAccount.approve within create function.""
      ]
    },
    {
      ""Area"": ""Denial of Service (DoS) Attacks"",
      ""Tasks"": [
        ""Analyze the potential for DoS attacks on the LenderPool contract, particularly in functions that involve loops or complex calculations. Identify potential gas limit issues or scenarios where an attacker could make the contract unusable for other lenders."",
        ""Review the logic that iterates through lenders or performs calculations based on the number of lenders in the pool. Assess the potential for an attacker to create a large number of lenders to exhaust gas limits or slow down the contract's performance."",
        ""Specifically, examine the `_beforeTokenTransfer` function in the context of a large number of token holders and ensure it is gas efficient.""
      ]
    },
    {
      ""Area"": ""Precision Loss"",
      ""Tasks"": [
        ""Audit all calculations for potential precision loss due to integer division, especially in functions like `_calculateLenderInterest` and `_calculatePrincipalWithdrawable`. Consider using more precise intermediate calculations or alternative algorithms to minimize precision loss."",
         ""Document the maximum potential precision loss in each calculation to understand the impact on lender returns.""
      ]
    },
    {
      ""Area"": ""Unused Scaling Factor"",
      ""Tasks"": [
         ""Investigate why the `SCALING_FACTOR` is defined but not used directly within this contract. Determine if it's used implicitly by external contracts or if it's a remnant from previous development iterations. If unused, consider removing it to reduce gas costs.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The LenderPool contract manages lending activities for specific pooled credit lines (identified by an ID). It acts as an ERC1155 token contract where each token ID represents participation in a specific lending pool. Lenders deposit the borrow asset during a collection period, receiving ERC1155 tokens. Once started, the funds are deposited into a Savings Account (potentially earning yield) and made available to the associated Pooled Credit Line contract. The contract handles interest calculation (distinguishing borrower interest and yield interest), distribution, liquidity withdrawal by lenders, and liquidation processes by interacting with external contracts like PooledCreditLine, SavingsAccount, and Verification."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LenderPool"",
    ""Purpose"": ""To manage individual lending pools, track lender contributions (via ERC1155 tokens), handle fund deposits/withdrawals to a Savings Account, calculate and distribute interest, and interact with a PooledCreditLine contract for borrowing, repayment, and liquidation."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ERC1155Upgradeable"",
        ""ReentrancyGuardUpgradeable"",
        ""IPooledCreditLineEnums"",
        ""ILenderPool""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"",
        ""@openzeppelin/contracts/math/SafeMath.sol"",
        ""@openzeppelin/contracts/token/ERC20/SafeERC20.sol"",
        ""../interfaces/ISavingsAccount.sol"",
        ""../interfaces/IYield.sol"",
        ""../interfaces/ILenderPool.sol"",
        ""../interfaces/IVerification.sol"",
        ""../interfaces/IPooledCreditLine.sol"",
        ""../interfaces/IPooledCreditLineEnums.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""SAVINGS_ACCOUNT"",
        ""Type"": ""ISavingsAccount"",
        ""Purpose"": ""Immutable address of the external Savings Account contract where funds are deposited.""
      },
      {
        ""Name"": ""POOLED_CREDIT_LINE"",
        ""Type"": ""IPooledCreditLine"",
        ""Purpose"": ""Immutable address of the main Pooled Credit Line contract this Lender Pool serves.""
      },
      {
        ""Name"": ""VERIFICATION"",
        ""Type"": ""IVerification"",
        ""Purpose"": ""Immutable address of the Verification contract to check user eligibility.""
      },
      {
        ""Name"": ""SCALING_FACTOR"",
        ""Type"": ""uint256 constant"",
        ""Purpose"": ""A constant value (1e18), likely intended for fixed-point math operations, although not explicitly used in visible calculations within this snippet.""
      },
      {
        ""Name"": ""LenderInfo"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores information about individual lenders within a pool, specifically tracking the amount of borrower interest and yield interest shares already withdrawn.""
      },
      {
        ""Name"": ""LenderPoolConstants"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores immutable configuration parameters for a specific lending pool (ID), set at creation time.""
      },
      {
        ""Name"": ""LenderPoolVariables"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores dynamic state variables for a specific lending pool (ID), including lender data, shares held in the savings account, accumulated interest shares, and collateral held.""
      },
      {
        ""Name"": ""pooledCLConstants"",
        ""Type"": ""mapping(uint256 => LenderPoolConstants)"",
        ""Purpose"": ""Maps a pool ID to its constant configuration data.""
      },
      {
        ""Name"": ""pooledCLVariables"",
        ""Type"": ""mapping(uint256 => LenderPoolVariables)"",
        ""Purpose"": ""Maps a pool ID to its dynamic state variables.""
      },
      {
        ""Name"": ""totalSupply"",
        ""Type"": ""mapping(uint256 => uint256)"",
        ""Purpose"": ""Tracks the total amount of ERC1155 tokens minted for a specific pool ID. Represents the total principal initially lent.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""onlyPooledCreditLine"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to only be callable by the associated POOLED_CREDIT_LINE contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes immutable contract addresses for dependencies."",
        ""Parameters"": [""_pooledCreditLine"", ""_savingsAccount"", ""_verification""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes the upgradeable contract components (ReentrancyGuard, ERC1155)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""create"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by POOLED_CREDIT_LINE to set up parameters for a new lending pool (ID)."",
        ""Parameters"": [""_id"", ""_lenderVerifier"", ""_borrowAsset"", ""_borrowAssetStrategy"", ""_borrowLimit"", ""_minBorrowAmount"", ""_collectionPeriod"", ""_areTokensTransferable""],
        ""Returns"": []
      },
      {
        ""Name"": ""lend"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows verified users to deposit the borrow asset into the pool during the collection period and mints ERC1155 tokens representing their share."",
        ""Parameters"": [""_id"", ""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""start"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transitions the pool from the collection phase to active lending, deposits collected funds into the Savings Account, and notifies the POOLED_CREDIT_LINE."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""borrowed"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Callback from POOLED_CREDIT_LINE to update internal state when funds are borrowed from the pool."",
        ""Parameters"": [""_id"", ""_sharesBorrowed""],
        ""Returns"": []
      },
      {
        ""Name"": ""repaid"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Callback from POOLED_CREDIT_LINE to update internal state when principal and interest are repaid to the pool."",
        ""Parameters"": [""_id"", ""_sharesRepaid"", ""_interestShares""],
        ""Returns"": []
      },
      {
        ""Name"": ""requestCancelled"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Callback from POOLED_CREDIT_LINE when the associated credit line request is cancelled before starting."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""terminate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Callback from POOLED_CREDIT_LINE to handle pool termination, withdrawing remaining assets and collateral."",
        ""Parameters"": [""_id"", ""_to""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawInterest"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a lender to withdraw their accrued interest (both borrower and yield interest)."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""getLenderInterestWithdrawable"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the amount of interest (in borrow asset tokens) currently withdrawable by a specific lender."",
        ""Parameters"": [""_id"", ""_lender""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""withdrawLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a lender to withdraw their principal (and any remaining interest) after the pool is CLOSED, LIQUIDATED, or CANCELLED."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""calculatePrincipalWithdrawable"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the amount of principal (in borrow asset tokens) currently withdrawable by a specific lender based on the pool's status."",
        ""Parameters"": [""_id"", ""_lender""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""liquidate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initiates the liquidation process via the POOLED_CREDIT_LINE and optionally withdraws the lender's share immediately."",
        ""Parameters"": [""_id"", ""_withdraw""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawTokensAfterLiquidation"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a lender to withdraw their share of liquidated collateral and remaining principal/interest after liquidation has occurred."",
        ""Parameters"": [""_id""],
        ""Returns"": []
      },
      {
        ""Name"": ""_beforeTokenTransfer"",
        ""Visibility"": ""internal override"",
        ""Purpose"": ""ERC1155 hook called before any token transfer. Updates total supply, enforces transfer restrictions (verification, transferability flag), and rebalances withdrawn interest accounting between sender and receiver."",
        ""Parameters"": [""operator"", ""from"", ""to"", ""ids"", ""amounts"", ""data""],
        ""Returns"": []
      },
      {
        ""Name"": ""getLenderInfo"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the LenderInfo struct for a given lender and pool ID."",
        ""Parameters"": [""_id"", ""_lender""],
        ""Returns"": [""LenderInfo memory""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""POOLED_CREDIT_LINE (IPooledCreditLine): Central coordinating contract. LenderPool calls its functions (`accept`, `cancelRequest...`, `liquidate`, getters) and is called back by it (`create`, `borrowed`, `repaid`, `requestCancelled`, `terminate`)."",
    ""SAVINGS_ACCOUNT (ISavingsAccount): Contract for depositing/withdrawing the borrow asset to potentially earn yield. LenderPool calls `deposit`, `withdrawShares`, `approve`, `allowance`."",
    ""VERIFICATION (IVerification): Contract used to verify lender eligibility via `isUser`."",
    ""Borrow Asset Strategy (IYield): Referenced via an address stored in `pooledCLConstants`. Used to convert between borrow asset tokens and strategy shares (`getSharesForTokens`, `getTokensForShares`)."",
    ""Borrow Asset (IERC20): The token being lent. Uses `safeTransferFrom`, `safeTransfer`, `safeApprove`."",
    ""Collateral Asset (IERC20): The token received during liquidation. Uses `safeTransfer`.""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract Pattern: Uses OpenZeppelin Upgradeable proxies."",
    ""ERC1155 Token Standard: Represents lender shares in different pools using unique token IDs."",
    ""Reentrancy Guard: Protects critical functions against reentrancy attacks."",
    ""Interest Accounting: Differentiates between borrower-paid interest and yield generated via Savings Account, tracking withdrawn amounts per lender using shares."",
    ""State-Dependent Logic: Pool actions (like withdrawal) depend heavily on the status reported by the external POOLED_CREDIT_LINE contract."",
    ""Callback Mechanism: Relies on callbacks from the POOLED_CREDIT_LINE contract for state updates (`borrowed`, `repaid`, `requestCancelled`, `terminate`)."",
    ""Interest Rebalancing on Transfer: The `_beforeTokenTransfer` hook ensures withdrawn interest accounting is adjusted proportionally when ERC1155 tokens are transferred.""
  ],
  ""Questions"": [
    ""The `SCALING_FACTOR` constant (1e18) is defined but not explicitly used in calculations within this contract. Is its use implicit in the external `IYield` or `ISavingsAccount` contracts, or was it intended for future use?"",
    ""Interest calculations (`_calculateLenderInterest`) involve multiple divisions (`div`). How are potential precision losses handled, especially when dealing with shares vs. tokens?"",
    ""How is division by zero prevented in calculations involving `_borrowLimit` or `_currentSupply`, especially in edge cases like pool creation or termination?"",
    ""The `terminate` function calculates `_actualNotBorrowedInShares`. Is this calculation robust if `totalSupply[_id]` significantly differs from `_borrowedTokens` (initial limit)?"",
    ""When rebalancing interest in `_rebalanceInterestWithdrawn`, calling `_withdrawInterest` for the `to` address seems potentially unnecessary if `to` had no prior balance. Is this intended for simplicity, or is there a case where `to` might have pre-existing withdrawn shares data?"",
    ""What are the specific mechanics and guarantees of the `IYield` strategy regarding share-to-token conversions? Are they always 1:1 initially, and how does yield accrual affect the ratio?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `_withdrawLiquidity`, `terminate` and `_withdrawInterest` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_withdrawLiquidity`, `terminate` and `_withdrawInterest` functions calls `SAVINGS_ACCOUNT.withdrawShares`, which is an external call and could be vulnerable to reentrancy. If the SavingsAccount contract calls back into the LenderPool, it could potentially lead to unexpected state changes or loss of funds. While some functions have the `nonReentrant` modifier, these specific sections of `_withdrawLiquidity` and `terminate` and `_withdrawInterest` do not appear to be protected against reentrancy. Additionally, `_updateInterestSharesToWithdraw` updates internal state BEFORE the external call, a malicious SavingsAccount could re-enter and potentially manipulate the state before the external call completes, leading to incorrect accounting of interest shares."",
      ""Impact"": ""Malicious lenders could exploit a reentrancy vulnerability to repeatedly withdraw more funds than they are entitled to. A malicious contract acting as a Savings Account or any malicious user can drain funds from the LenderPool if `SAVINGS_ACCOUNT.withdrawShares` allows external calls before updating its internal state. A reentrancy can manipulate the balances and logic within the `LenderPool` during the withdrawal process. Incorrect accounting of interest shares can lead to unfair distribution of interest."",
      ""Location"": ""LenderPool.sol:_withdrawLiquidity (lines 438-444), terminate function, _withdrawInterest function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `_beforeTokenTransfer`"",
      ""Severity"": ""High"",
      ""Description"": ""In the `_beforeTokenTransfer` function, when burning tokens (to == address(0)), the code checks `require(supply >= amount, 'LP:IT4');` and then performs `totalSupply[id] = supply - amount;`. While the require statement prevents underflow during burning, an integer overflow can occur in `totalSupply[id] = totalSupply[id].add(amount);` when minting tokens (from == address(0)). If `totalSupply[id] + amount` exceeds the maximum value of `uint256`, it will wrap around to a small value, leading to incorrect accounting of the total supply. This could allow users to withdraw more funds than they are entitled to, potentially draining the contract."",
      ""Impact"": ""Incorrect total supply calculation, potential for draining funds from the contract."",
      ""Location"": ""function _beforeTokenTransfer(...), totalSupply[id] = totalSupply[id].add(amount);""
    },
    {
      ""Issue"": ""Incorrect Calculation of `_actualNotBorrowedInShares` in `terminate` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `terminate` function, the calculation of `_actualNotBorrowedInShares` as `_notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens)` appears flawed. It aims to determine the share equivalent of the unborrowed tokens, but uses `totalSupply[_id]` which represents the total lent amount rather than the actual shares in the SAVINGS_ACCOUNT. Given the principal may not be able to be 100% withdrawn from the savings account, this would indicate there are less actualNotBorrowed shares in the savings account than there actually are. This can result in incorrect amounts being withdrawn. Also if `_borrowedTokens` is sufficiently larger than `_notBorrowedInShares.mul(totalSupply[_id])`, this division will result in `_actualNotBorrowedInShares` being zero"",
      ""Impact"": ""Potential loss of funds for lenders due to miscalculation of withdrawable amounts, leading to less yield being withdrawn. Potential solvency issues if more yield is being withdrawn than should be. Incorrect calculation of withdrawal amounts, potentially leading to a loss of funds for lenders."",
      ""Location"": ""terminate function""
    },
    {
      ""Issue"": ""Incorrect calculation of principal withdrawable"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_calculatePrincipalWithdrawable` function, The `_totalLiquidityWithdrawable` calculation will be incorrect as `_borrowedTokens` in the formula `_borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id))` contains the total amount lent, not necessarily the total amount borrowed. This means that the lender can withdraw more or less than the correct amount. This is because the total amount lent to the pool can be higher than the total amount borrowed if the borrower only partially uses the borrowed amount. The issue stems from a misunderstanding or misuse of the term `_borrowedTokens` and its relationship with `POOLED_CREDIT_LINE.getPrincipal(_id)`."",
      ""Impact"": ""Inaccurate distribution of available funds can lead to financial losses for both lenders and the contract itself. Lenders might receive an incorrect amount when withdrawing principal after a loan has been repaid."",
      ""Location"": ""_calculatePrincipalWithdrawable""
    },
    {
      ""Issue"": ""Missing Input Validation in `create` Function for Address Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `create` function, which is used to initialize a new lending pool, takes several address parameters: `_lenderVerifier`, `_borrowAsset`, `_borrowAssetStrategy`. The function does not validate that these addresses are not the zero address. If any of these addresses are set to the zero address, it can lead to unexpected behavior or make certain functions unusable. Inconsistent Handling of `msg.sender` in `_accept` function"",
      ""Impact"": ""If `_lenderVerifier` is the zero address, the verification process in the `lend` function will be compromised, potentially allowing unauthorized users to lend. If `_borrowAsset` is the zero address, the `IERC20(_borrowAsset).safeTransferFrom` call in the `lend` function will fail. If `_borrowAssetStrategy` is the zero address, the `SAVINGS_ACCOUNT.deposit` call in the `_accept` function and other functions that depend on `_borrowAssetStrategy` may not work correctly, resulting in potential loss of funds. Potential for incorrect access control within the `POOLED_CREDIT_LINE` contract."",
      ""Location"": ""create function, _accept function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow Vulnerabilities"",
      ""Severity"": ""Medium"",
      ""Description"": ""While SafeMath is used, there are still areas where incorrect logic might lead to unexpected behavior due to integer overflow/underflow. In `_calculateLenderInterest`, the calculation `_totalInterestWithdrawableInShares = _sharesHeld.sub(_notBorrowedInShares);` could underflow if `_notBorrowedInShares` is greater than `_sharesHeld`, leading to incorrect interest calculations. Additionally there are multiple subtractions in other functions where the result could be negative and therefore revert if the subtraction is `checked` but the logic is not considering the edge cases. The contract uses SafeMath library but it is not utilized everywhere."",
      ""Impact"": ""Incorrect interest calculations, leading to unfair distribution of funds or potential loss of funds. Unexpected reverts can lead to DoS of the contract and make it unavailable. Potential integer overflow."",
      ""Location"": ""_calculateLenderInterest function, _rebalanceInterestWithdrawn and other subtraction operations.""
    },
    {
      ""Issue"": ""Unsafe Division in Interest Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_calculateLenderInterest` function, the code calculates `_borrowerInterestSharesForLender` and `_yieldInterestSharesForLender` using division, and in the `_rebalanceInterestWithdrawn` function, the `yieldInterestWithdrawnShares` and `borrowerInterestSharesWithdrawn` are calculated using division by `fromBalance`. If `_borrowLimit` is zero, this will lead to a division by zero error, causing the transaction to revert. Even though there's a check `if (_sharesHeld == 0) { return (0, 0); }`, `_borrowLimit` could be zero in other scenarios if not properly initialized or set to zero later. Even if `fromBalance` is not zero, a very low `fromBalance` can lead to disproportionately large allocation of interests which might not be intended and may cause a division by zero even if the `require` check is present *after* the division happens."",
      ""Impact"": ""The contract can become unusable if `_borrowLimit` is zero, and any calls to `_calculateLenderInterest` will revert. This can effectively block interest withdrawal functionality for lenders. Denial of service for token transfers if a user's balance is unexpectedly or maliciously set to zero. Unexpected behavior or potential loss of funds if an integer overflow or underflow occurs during the calculation"",
      ""Location"": ""_calculateLenderInterest function, _rebalanceInterestWithdrawn function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `start` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `start` function checks if `block.timestamp >= _startTime`. A malicious actor could monitor the mempool for transactions calling the `start` function and front-run them, potentially triggering unexpected behavior if the state changes between the time the transaction is submitted and when it is executed."",
      ""Impact"": ""Malicious actors may be able to game the system to their advantage, leading to loss of funds for some or all users."",
      ""Location"": ""LenderPool.sol:start""
    },
    {
      ""Issue"": ""Lack of Slippage Protection in `_accept` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_accept` function calls `IERC20(_borrowAsset).safeApprove(_strategy, _amount)` and then `SAVINGS_ACCOUNT.deposit(_borrowAsset, _strategy, address(this), _amount)`. There is no slippage protection or consideration for potential fluctuations in the value of the `_borrowAsset` between the `safeApprove` and `deposit` calls. If the value of `_borrowAsset` decreases significantly, the amount deposited in terms of the underlying asset might be lower than expected, or the approval might be exploited by a malicious strategy contract."",
      ""Impact"": ""Potential loss of funds or unexpected behavior due to slippage. An attacker can potentially exploit the approval to drain funds."",
      ""Location"": ""_accept function, calls to `IERC20(_borrowAsset).safeApprove` and `SAVINGS_ACCOUNT.deposit`.""
    },
    {
      ""Issue"": ""Improper Handling of Edge Cases in `terminate` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `terminate` function, after calculating `_notBorrowed`, the code calculates `_notBorrowedInShares` and then `_totalInterestInShares`. There are checks for zero values further in the code with conditional statements that trigger `SAVINGS_ACCOUNT.withdrawShares`. However, the accuracy and handling of all edge cases involving these calculations should be carefully reviewed, particularly when the amounts are very small or close to the minimum representable value. The multiplication and division with totalSupply and borrowedTokens is prone to inaccuracies and should be checked."",
      ""Impact"": ""Potential for incorrect calculation of withdrawable amounts, leading to unfair distribution of funds or unexpected contract behavior when handling small amounts."",
      ""Location"": ""terminate function""
    },
    {
      ""Issue"": ""Missing Input Validation in _withdrawTokensAfterLiquidation for collateral share."",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_withdrawTokensAfterLiquidation` function, there isn't any check to verify that the `_lenderCollateralShare` calculated doesn't exceed the `_collateralLiquidated` that's held in the `pooledCLVariables[_id].collateralHeld` storage. While it's intended to reduce the value of `pooledCLVariables[_id].collateralHeld` with the withdrawn amount, a mismatch in calculations could potentially lead to attempting to withdraw more than what's available. This can be exacerbated if there's manipulation on the `_balance` or `_currentSupply` values."",
      ""Impact"": ""A mismatch in `_lenderCollateralShare` calculation can cause unexpected behavior and potential reverts, especially if the calculated share exceeds the current held collateral. This could result in some lenders not being able to withdraw their liquidation proceeds."",
      ""Location"": ""_withdrawTokensAfterLiquidation function""
    },
    {
      ""Issue"": ""Unprotected `initialize` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initialize` function is only protected by the `initializer` modifier from OpenZeppelin's upgradeable contracts. If the contract is deployed without using a proxy or the proxy is not initialized correctly, anyone can call `initialize` and potentially set up the contract in an unintended state. Additionally,  if `POOLED_CREDIT_LINE` contract is compromised, attacker can create malicious credit line configs."",
      ""Impact"": ""Potential for unintended contract setup leading to DoS or fund theft.  Potential for `POOLED_CREDIT_LINE` contract to create malicious credit line configs."",
      ""Location"": ""function initialize() external initializer, function create(...)""
    },
    {
      ""Issue"": ""Incorrect Interest Calculation due to Integer Truncation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The interest calculation logic in `_calculateLenderInterest` performs division without sufficient precision, potentially leading to significant inaccuracies due to integer truncation. For instance, `(_borrowerInterestShares.mul(_lenderBalance).div(_borrowLimit))` can truncate a large amount if `_lenderBalance` is significantly smaller than `_borrowLimit`. This means lenders with smaller balances might receive less interest than they are actually entitled to."",
      ""Impact"": ""Lenders with smaller balances might receive less interest"",
      ""Location"": ""function _calculateLenderInterest(...)""
    },
    {
      ""Issue"": ""Stale `PooledCreditLineStatus` in `withdrawLiquidity`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `withdrawLiquidity` function fetches the `PooledCreditLineStatus` by calling `POOLED_CREDIT_LINE.getStatusAndUpdate(_id)`. This is concerning since `getStatusAndUpdate` could potentially update the state of the `POOLED_CREDIT_LINE` contract, and the result might not be accurate if other operations have occurred in the meantime. A more reliable approach would involve fetching the status once at the beginning of the function and using that value consistently."",
      ""Impact"": ""Potentially incorrect `PooledCreditLineStatus` affecting withdrawal logic."",
      ""Location"": ""function withdrawLiquidity(...)""
    },
    {
      ""Issue"": ""Transfer to Zero Address in `_beforeTokenTransfer` can bypass restrictions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_beforeTokenTransfer` function has checks such as `to != POOLED_CREDIT_LINE.getBorrowerAddress(id)` and `VERIFICATION.isUser(to, pooledCLConstants[id].lenderVerifier)` when transferring tokens. However, if `to == address(0)` (burning tokens), these checks are bypassed. A malicious user could potentially burn tokens to bypass these access controls and achieve unintended results."",
      ""Impact"": ""Bypassing access controls by burning tokens."",
      ""Location"": ""function _beforeTokenTransfer(...)""
    },
    {
      ""Issue"": ""Unbounded loop in `_beforeTokenTransfer` function can lead to denial-of-service."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_beforeTokenTransfer` function iterates through `ids` and `amounts` arrays without checking their lengths against each other. If `ids` and `amounts` have different lengths, the shorter array will be accessed out-of-bounds, resulting in unexpected behavior. More concerning is that if the lengths are maliciously large, it might cause a gas exhaustion DoS."",
      ""Impact"": ""Potential denial-of-service, unexpected behavior during token transfers."",
      ""Location"": ""_beforeTokenTransfer function""
    },
    {
      ""Issue"": ""Incorrect calculation of `_actualNotBorrowedInShares` in the `terminate` function can cause incorrect withdrawals."",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `terminate` function, the calculation of `_actualNotBorrowedInShares` is performed using the division operation `_notBorrowedInShares.mul(totalSupply[_id]).div(_borrowedTokens)`. If `_borrowedTokens` is sufficiently larger than `_notBorrowedInShares.mul(totalSupply[_id])`, this division will result in `_actualNotBorrowedInShares` being zero. Consequently, only the \'totalInterestInShares\' is used to calculate the totalBorrowAsset, leading to an underestimation. This will cause lenders to withdraw an incorrect amount."",
      ""Impact"": ""Incorrect calculation of withdrawal amounts, potentially leading to a loss of funds for lenders."",
      ""Location"": ""terminate function""
    },
        {
      ""Issue"": ""Potential Denial of Service in `terminate` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `terminate` function iterates through potential collateral and borrow asset holders within the savings account via multiple external calls. If any of those external calls fail, the whole function reverts, meaning no collateral or borrow asset can be withdrawn. This becomes a vulnerability because it relies on external contracts functioning correctly, a malicious user can brick the contract by attacking the savings account contract or yield contract which would prevent the lender pool contract from being terminated."",
      ""Impact"": ""The lender pool can become unusable preventing users from claiming their funds."",
      ""Location"": ""LenderPool.sol:terminate""
    },
    {
      ""Issue"": ""Potential Reentrancy issue in `_withdrawInterest` when calling `SAVINGS_ACCOUNT.withdrawShares`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_withdrawInterest` function calls `SAVINGS_ACCOUNT.withdrawShares`. If the `SAVINGS_ACCOUNT` contract is malicious or contains a vulnerability, it could potentially re-enter the `LenderPool` contract, leading to unexpected state changes or potential fund losses. While the `LenderPool` contract uses `ReentrancyGuardUpgradeable`, this only protects against reentrancy within the `LenderPool` contract itself. The external call to `SAVINGS_ACCOUNT.withdrawShares` opens up a potential reentrancy attack vector if `SAVINGS_ACCOUNT` is compromised."",
      ""Impact"": ""Potential loss of funds if the SavingsAccount contract is malicious and initiates a reentrancy attack."",
      ""Location"": ""_withdrawInterest function""
    },
    {
      ""Issue"": ""Unbounded Loops Possible in edge cases"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_rebalanceInterestWithdrawn` function calls `_withdrawInterest` which calls `_updateInterestSharesToWithdraw`. The `_updateInterestSharesToWithdraw` function calculates the interest to withdraw for a given lender and withdraws it. This call of `_withdrawInterest` is a potential issue. Suppose that withdrawing the interest results in additional interest being generated by the yield strategy for the shares held. After withdrawing the initial interest and generating new interest by the yield strategy, the loop could call `_withdrawInterest` and the yield strategy would again generate more interest. This cycle could continue indefinitely or until the user runs out of gas. While this is unlikely to cause harm as users will only make minimal interest on each loop, it may cause issues with high gas consumption"",
      ""Impact"": ""Gas exhaustion, DoS"",
      ""Location"": ""_rebalanceInterestWithdrawn -> _withdrawInterest -> _updateInterestSharesToWithdraw""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in _rebalanceInterestWithdrawn function."",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_rebalanceInterestWithdrawn` function, the subtraction operations on `pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn` and `pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares` can potentially underflow if `borrowerInterestOnTransferAmount` or `yieldInterestOnTransferAmount` are greater than the current values of `pooledCLVariables[id].lenders[from].borrowerInterestSharesWithdrawn` and `pooledCLVariables[id].lenders[from].yieldInterestWithdrawnShares` respectively. This could cause unexpected behavior."",
      ""Impact"": ""Unexpected behavior during interest share rebalancing, potential accounting errors."",
      ""Location"": ""_rebalanceInterestWithdrawn function""
    },
    {
      ""Issue"": ""Missing checks for zero address"",
      ""Severity"": ""Low"",
      ""Description"": ""The `terminate` function does not check for zero address before transferring `_collateralHeld` to the _to. This is a common practice to prevent accidental burning of tokens."",
      ""Impact"": ""Accidental burning of collateral"",
      ""Location"": ""terminate""
    },
    {
      ""Issue"": ""Potential division by zero in _rebalanceInterestWithdrawn function."",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_rebalanceInterestWithdrawn` function, the calculations of `yieldInterestOnTransferAmount` and `borrowerInterestOnTransferAmount` involve a division by `fromBalance`. If `fromBalance` is zero, this will result in a division by zero error. Although there is a check `require(fromBalance != 0, 'LP:IRIW1')`, this check is performed after the interest is withdrawn. If the interest withdrawal results in a zero balance, then the check will catch it. However, in cases where the fromBalance is already zero before the interest withdrawal is called, then the check will not work."",
      ""Impact"": ""Division by zero error, transaction failure."",
      ""Location"": ""_rebalanceInterestWithdrawn function""
    },
        {
      ""Issue"": ""Missing Access Control on `requestCancelled` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `requestCancelled` function is only restricted to `onlyPooledCreditLine`. This means only the `POOLED_CREDIT_LINE` contract can call this function. This seems appropriate as only the pooled credit line should be able to cancel a request."",
      ""Impact"": ""N/A"",
      ""Location"": ""requestCancelled function""
    },
        {
      ""Issue"": ""Lack of Input Validation on `_id` Parameter"",
      ""Severity"": ""Low"",
      ""Description"": ""Throughout the contract, the `_id` parameter is used to access mappings like `pooledCLConstants` and `pooledCLVariables`. There is no explicit check to ensure that a given `_id` is a valid or initialized pool ID. While many functions have implicit checks (e.g., requiring `pooledCLConstants[_id].startTime != 0`), a general check could prevent unexpected behavior or errors arising from accessing uninitialized data."",
      ""Impact"": ""Accessing uninitialized data could lead to unexpected behavior, reverts, or potential denial-of-service."",
      ""Location"": ""Multiple locations throughout LenderPool.sol""
    },
    {
      ""Issue"": ""Potential Denial of Service in `_beforeTokenTransfer` Due to Gas Limit"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_beforeTokenTransfer` function iterates through `ids` and `amounts`. If a large number of tokens are being transferred in a single transaction, the gas cost of this loop, coupled with the calls to `_rebalanceInterestWithdrawn` and external calls within that function, could exceed the block gas limit, causing the transaction to revert and potentially preventing legitimate transfers."",
      ""Impact"": ""Users might be unable to transfer their tokens if the number of tokens being transferred is too large."",
      ""Location"": ""LenderPool.sol:_beforeTokenTransfer""
    },
       {
      ""Issue"": ""Missing Access Control on `requestCancelled`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `requestCancelled` function is marked `onlyPooledCreditLine`, meaning only the PooledCreditLine contract can call it. However, the intended logic is that the PooledCreditLine contract should only call this when a request is actually cancelled due to certain conditions (e.g., not meeting the minimum borrow amount). If the PooledCreditLine contract malfunctions or is compromised, it could call this function inappropriately, potentially disrupting the state of the LenderPool contract."",
      ""Impact"": ""Incorrectly cancelling requests, potentially leading to loss of funds or unexpected behavior."",
      ""Location"": ""LenderPool.sol:requestCancelled""
    },
    {
      ""Issue"": ""Missing Access Control for initialize() Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `initialize()` function lacks proper access control. Although it's meant to be called only once during contract deployment, there is no mechanism to prevent unauthorized users from calling it again, which could lead to unexpected behavior, especially in upgradeable contracts."",
      ""Impact"": ""Potential for contract state corruption or unexpected behavior if the `initialize()` function is called more than once."",
      ""Location"": ""initialize() function.""
    },
     {
      ""Issue"": ""Missing Event for Collateral Asset Updates"",
      ""Severity"": ""Low"",
      ""Description"": ""The `liquidate` function updates the `pooledCLConstants[_id].collateralAsset` and `pooledCLVariables[_id].collateralHeld` variables, but there is no event emitted to notify listeners about this change. This makes it difficult to track changes in collateral assets and amounts."",
      ""Impact"": ""Lack of transparency and difficulty tracking collateral asset updates."",
      ""Location"": ""liquidate function.""
    },
    {
      ""Issue"": ""Potential rounding errors in `_calculatePrincipalWithdrawable`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the function `_calculatePrincipalWithdrawable`, the calculation of `_principalWithdrawable` involves multiplication and division: `_principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);`. If `_totalLiquidityWithdrawable.mul(balanceOf(_lender, _id))` is not perfectly divisible by `_borrowedTokens`, there will be a rounding error, potentially leading to lenders receiving slightly less than they are entitled to. This is exacerbated if the numbers are small."",
      ""Impact"": ""Lenders may receive slightly less liquidity than they are owed due to rounding errors."",
      ""Location"": ""_calculatePrincipalWithdrawable""
    },
     {
      ""Issue"": ""Missing zero address checks for `_lenderVerifier`, `_borrowAsset`, `_borrowAssetStrategy` in `create` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `create` function does not check if `_lenderVerifier`, `_borrowAsset` and `_borrowAssetStrategy` are not zero addresses. This could lead to unexpected behavior or vulnerabilities if these addresses are accidentally set to the zero address."",
      ""Impact"": ""The lender pool will break and become unusable."",
      ""Location"": ""LenderPool.sol:create""
    },
    {
      ""Issue"": ""Inconsistent use of SafeMath"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `SafeMath` library but it is not utilized everywhere. For example, in function `_beforeTokenTransfer` the subtraction is protected with a `require` statement but addition is not. This inconsistency may lead to unexpected behavior."",
      ""Impact"": ""Potential integer overflow."",
      ""Location"": ""function _beforeTokenTransfer(...)""
    },
    {
      ""Issue"": ""Missing input validation for zero address in create function can cause unexpected behavior."",
      ""Severity"": ""Low"",
      ""Description"": ""The `create` function does not check for zero addresses for `_lenderVerifier`, `_borrowAsset`, `_borrowAssetStrategy`. Passing in the zero address for these parameters can cause unexpected behavior, especially if those addresses are later used in external calls. Although there are checks for zero address for SavingsAccount, PooledCreditLine and Verification in the constructor, similar checks should exist for addresses passed in through external functions."",
      ""Impact"": ""Unexpected behavior, potential contract malfunction."",
      ""Location"": ""create function.""
    }
  ],
  ""IssueNumber"": 55,
  ""OutputList"": 29
}",268.2222752571106,5773.0,32.0,"### **[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee**

**Report Description**:
The `_calculatePrincipalWithdrawable` function in `LenderPool.sol` incorrectly calculates the principal withdrawable if `start()` is invoked with a non-zero start fee. The issue arises because the borrow limit is reduced by the fee, resulting in `totalSupply[id]` not being 1:1 with the borrow limit. This can lead to lenders withdrawing more than they are entitled to, causing financial discrepancies.

**Match in Response List**:
Matches with the issue titled **""Incorrect calculation of principal withdrawable""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the calculation of `_principalWithdrawable` in the `_calculatePrincipalWithdrawable` function. It correctly explains the risks associated with the incorrect calculation, which aligns with the reported issue.

---

### **[H-02] PooledCreditLine: termination likely fails because _principalWithdrawable is treated as shares**

**Report Description**:
In the `terminate` function, `_principalWithdrawable` is denominated in the borrow asset but is subsequently treated as the share amount to be withdrawn. This mismatch can lead to incorrect withdrawals, potentially causing financial losses for lenders.

**Match in Response List**:
Matches with the issue titled **""Incorrect Calculation of `_actualNotBorrowedInShares` in `terminate` Function""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the calculation of `_actualNotBorrowedInShares` in the `terminate` function. It correctly explains the risks associated with the incorrect calculation, which aligns with the reported issue.

---

### **[M-01] Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens**

**Report Description**:
If the `_borrowAsset` is a non-ERC20 compliant token like USDT, the `transfer()` function may revert due to the lack of a return value. This can cause the `start()` function to fail, potentially losing a significant number of users who rely on such tokens.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address the issue of non-ERC20 compliant tokens causing the `start()` function to fail.

---

### **[M-02] Lack of access control allow anyone to withdrawInterest() for any lender**

**Report Description**:
The `withdrawInterest()` function lacks access control, allowing anyone to withdraw interest on behalf of any lender. This can lead to potential value leakage for lenders, as they may not want to withdraw interest at a specific time.

**Match in Response List**:
**No match found**.

**Validation**:
**Missed Issue**. The response list does not address the lack of access control in the `withdrawInterest()` function.

---

### **[M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time**

**Report Description**:
An attacker can monitor the `totalSupply` of each `LenderPool` and call `start()` at a pre-announced time to deposit the entire pool assets into a known strategy. This can lead to depositing at an unfavorable rate, potentially causing financial losses.

**Match in Response List**:
Matches with the issue titled **""Potential Front-Running Vulnerability in `start` function""**.

**Validation**:
**Partially Correct**. The response identifies the front-running vulnerability in the `start` function but does not fully address the issue of depositing at an unfavorable rate due to the attacker's manipulation of the strategy.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] LenderPool: Principal withdrawable is incorrectly calculated if start() is invoked with non-zero start fee**
- **[H-02] PooledCreditLine: termination likely fails because _principalWithdrawable is treated as shares**

**Partially Correct Matches**:

- **[M-03] Potentially depositing at unfavorable rate since anyone can deposit the entire lenderPool to a known strategy at a pre-fixed time**

**Missed Issues from Issue Report**:

- **[M-01] Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens**
- **[M-02] Lack of access control allow anyone to withdrawInterest() for any lender**

---","```
1. Incorrect calculation of principal withdrawable
2. Incorrect Calculation of `_actualNotBorrowedInShares` in `terminate` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Incorrect calculation of principal withdrawable"" appears at rank 4.
   - ""Incorrect Calculation of `_actualNotBorrowedInShares` in `terminate` Function"" appears at rank 3.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)
   - For rank 4: \( P@4 = \frac{2}{4} = 0.5 \)

3. **Average the precision values**:
   - \( AP = \frac{0.333 + 0.5}{2} = \frac{0.833}{2} \approx 0.4165 \)

**Average Precision (AP)**: 0.4165"
