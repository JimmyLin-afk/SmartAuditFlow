nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,Match,Partially,Not Match,LLM-generated,matchList,MAP,Score
NestedFactory.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Multicall.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""./libraries/ExchangeHelpers.sol"";
import ""./libraries/OperatorHelpers.sol"";
import ""./interfaces/external/IWETH.sol"";
import ""./interfaces/INestedFactory.sol"";
import ""./FeeSplitter.sol"";
import ""./MixinOperatorResolver.sol"";
import ""./NestedReserve.sol"";
import ""./NestedAsset.sol"";
import ""./NestedRecords.sol"";

/// @title Creates, updates and destroys NestedAssets.
/// @notice Responsible for the business logic of the protocol and interaction with operators
contract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {
    using SafeERC20 for IERC20;
    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Supported operators by the factory contract
    bytes32[] private operators;

    /// @dev Current feeSplitter contract/address
    FeeSplitter public feeSplitter;

    /// @dev Current reserve contract/address
    NestedReserve public reserve;

    NestedAsset public immutable nestedAsset;
    IWETH public immutable weth;
    NestedRecords public immutable nestedRecords;

    constructor(
        NestedAsset _nestedAsset,
        NestedRecords _nestedRecords,
        FeeSplitter _feeSplitter,
        IWETH _weth,
        address _operatorResolver
    ) MixinOperatorResolver(_operatorResolver) {
        nestedAsset = _nestedAsset;
        nestedRecords = _nestedRecords;
        feeSplitter = _feeSplitter;
        weth = _weth;
    }

    /// @dev Reverts the transaction if the caller is not the token owner
    /// @param _nftId The NFT Id
    modifier onlyTokenOwner(uint256 _nftId) {
        require(nestedAsset.ownerOf(_nftId) == _msgSender(), ""NestedFactory: Not the token owner"");
        _;
    }

    /// @dev Reverts the transaction if the nft is locked (hold by design).
    /// The block.timestamp must be greater than NFT record lock timestamp
    /// @param _nftId The NFT Id
    modifier isUnlocked(uint256 _nftId) {
        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), ""NestedFactory: The NFT is currently locked"");
        _;
    }

    /// @dev Receive function
    receive() external payable {}

    /// @notice Get the required operator addresses
    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {
        return operators;
    }

    /// @inheritdoc INestedFactory
    function addOperator(bytes32 operator) external override onlyOwner {
        operators.push(operator);
    }

    /// @inheritdoc INestedFactory
    function removeOperator(bytes32 operator) external override onlyOwner {
        uint256 i = 0;
        while (operators[i] != operator) {
            i++;
        }
        require(i > 0, ""NestedFactory::removeOperator: Cant remove non-existent operator"");
        delete operators[i];
    }

    /// @inheritdoc INestedFactory
    function setReserve(NestedReserve _reserve) external override onlyOwner {
        require(address(reserve) == address(0), ""NestedFactory::setReserve: Reserve is immutable"");
        reserve = _reserve;
        emit ReserveUpdated(address(_reserve));
    }

    /// @inheritdoc INestedFactory
    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {
        require(address(_feeSplitter) != address(0), ""NestedFactory::setFeeSplitter: Invalid feeSplitter address"");
        feeSplitter = _feeSplitter;
        emit FeeSplitterUpdated(address(_feeSplitter));
    }

    /// @inheritdoc INestedFactory
    function create(
        uint256 _originalTokenId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant {
        require(_orders.length > 0, ""NestedFactory::create: Missing orders"");

        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);
        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);

        _transferFeeWithRoyalty(fees, tokenSold, nftId);
        emit NftCreated(nftId, _originalTokenId);
    }

    /// @inheritdoc INestedFactory
    function addTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant onlyTokenOwner(_nftId) {
        require(_orders.length > 0, ""NestedFactory::addTokens: Missing orders"");

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);
        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function swapTokenForTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::swapTokenForTokens: Missing orders"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::swapTokenForTokens: Assets in different reserve""
        );

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function sellTokensToNft(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToNft: Missing orders"");
        require(_sellTokensAmount.length == _orders.length, ""NestedFactory::sellTokensToNft: Input lengths must match"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToNft: Assets in different reserve""
        );

        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function sellTokensToWallet(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToWallet: Missing orders"");
        require(
            _sellTokensAmount.length == _orders.length,
            ""NestedFactory::sellTokensToWallet: Input lengths must match""
        );
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToWallet: Assets in different reserve""
        );

        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(
            _nftId,
            _buyToken,
            _sellTokensAmount,
            _orders,
            false,
            true
        );
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function destroy(
        uint256 _nftId,
        IERC20 _buyToken,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);
        require(_orders.length > 0, ""NestedFactory::destroy: Missing orders"");
        require(tokens.length == _orders.length, ""NestedFactory::destroy: Missing sell args"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::destroy: Assets in different reserve""
        );

        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));

        for (uint256 i = 0; i < tokens.length; i++) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);
            reserve.withdraw(IERC20(holding.token), holding.amount);

            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);
            nestedRecords.freeHolding(_nftId, tokens[i]);
        }

        // Amount calculation to send fees and tokens
        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;
        uint256 amountFees = _calculateFees(_msgSender(), amountBought);
        amountBought = amountBought - amountFees;

        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());

        // Burn NFT
        nestedRecords.removeNFT(_nftId);
        nestedAsset.burn(_msgSender(), _nftId);
        emit NftBurned(_nftId);
    }

    /// @inheritdoc INestedFactory
    function withdraw(uint256 _nftId, uint256 _tokenIndex)
        external
        override
        nonReentrant
        onlyTokenOwner(_nftId)
        isUnlocked(_nftId)
    {
        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);
        require(assetTokensLength > _tokenIndex, ""NestedFactory::withdraw: Invalid token index"");
        // Use destroy instead if NFT has a single holding
        require(assetTokensLength > 1, ""NestedFactory::withdraw: Can't withdraw the last asset"");

        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(
            _nftId,
            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]
        );
        reserve.withdraw(IERC20(holding.token), holding.amount);
        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);

        nestedRecords.deleteAsset(_nftId, _tokenIndex);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {
        nestedRecords.updateLockTimestamp(_nftId, _timestamp);
    }

    /// @inheritdoc INestedFactory
    function unlockTokens(IERC20 _token) external override onlyOwner {
        _token.transfer(owner(), _token.balanceOf(address(this)));
    }

    /// @dev For every orders, call the operator with the calldata
    /// to submit buy orders (where the input is one asset).
    /// @param _nftId The id of the NFT impacted by the orders
    /// @param _inputToken Token used to make the orders
    /// @param _inputTokenAmount Amount of input tokens to use
    /// @param _orders Orders calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    /// @param _fromReserve True if the input tokens are from the reserve
    /// @return feesAmount The total amount of fees
    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)
    function _submitInOrders(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, IERC20 tokenSold) {
        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);
        uint256 amountSpent;
        for (uint256 i = 0; i < _orders.length; i++) {
            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);
        }
        feesAmount = _calculateFees(_msgSender(), amountSpent);
        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent

        // If input is from the reserve, update the records
        if (_fromReserve) {
            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);
        }

        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);

        tokenSold = _inputToken;
    }

    /// @dev For every orders, call the operator with the calldata
    /// to submit sell orders (where the output is one asset).
    /// @param _nftId The id of the NFT impacted by the orders
    /// @param _outputToken Token received for every orders
    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)
    /// @param _orders Orders calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    /// @param _fromReserve True if the input tokens are from the reserve
    /// @return feesAmount The total amount of fees
    /// @return amountBought The total amount bought
    function _submitOutOrders(
        uint256 _nftId,
        IERC20 _outputToken,
        uint256[] memory _inputTokenAmounts,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, uint256 amountBought) {
        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));

        for (uint256 i = 0; i < _orders.length; i++) {
            IERC20 _inputToken = _transferInputTokens(
                _nftId,
                IERC20(_orders[i].token),
                _inputTokenAmounts[i],
                _fromReserve
            );

            // Submit order and update holding of spent token
            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);
            assert(amountSpent <= _inputTokenAmounts[i]);

            if (_fromReserve) {
                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);
            }

            // Under spent input amount send to fee splitter
            if (_inputTokenAmounts[i] - amountSpent > 0) {
                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);
            }
        }

        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;
        feesAmount = _calculateFees(_msgSender(), amountBought);

        if (_reserved) {
            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);
        }
    }

    /// @dev Call the operator to submit the order (commit/revert) and add the output
    /// assets to the reserve (if needed).
    /// @param _inputToken Token used to make the orders
    /// @param _outputToken Expected output token
    /// @param _nftId The nftId
    /// @param _order The order calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    function _submitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _nftId,
        Order calldata _order,
        bool _reserved
    ) private returns (uint256 amountSpent) {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        require(success, ""NestedFactory::_submitOrder: Operator call failed"");

        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
            data,
            _inputToken,
            _outputToken
        );

        if (_reserved) {
            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);
        }
        amountSpent = amounts[1];
    }

    /// @dev Call the operator to submit the order (commit/revert) but dont stop if
    /// the call to the operator fail. It will send the input token back to the msg.sender.
    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was
    ///        useless for the only use case (destroy).
    /// @param _inputToken Token used to make the orders
    /// @param _outputToken Expected output token
    /// @param _amountToSpend The input amount available (to spend)
    /// @param _nftId The nftId
    /// @param _order The order calldata
    function _safeSubmitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _amountToSpend,
        uint256 _nftId,
        Order calldata _order
    ) private {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        if (success) {
            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
                data,
                _inputToken,
                _outputToken
            );
            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));
        } else {
            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);
        }
    }

    /// @dev Transfer tokens to the reserve, and compute the amount received to store
    /// in the records. We need to know the amount received in case of deflationary tokens.
    /// @param _token The token address
    /// @param _amount The amount to send to the reserve
    /// @param _nftId The Token ID to store the assets
    function _transferToReserveAndStore(
        address _token,
        uint256 _amount,
        uint256 _nftId
    ) private {
        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));

        // Send output to reserve
        IERC20(_token).safeTransfer(address(reserve), _amount);

        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));

        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));
    }

    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve
    ///      or the user wallet, to the factory.
    /// @param _nftId The NFT id
    /// @param _inputToken The token to receive
    /// @param _inputTokenAmount Amount to transfer
    /// @param _fromReserve True to transfer from the reserve
    /// @return tokenUsed Token transfered (in case of ETH)
    function _transferInputTokens(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        bool _fromReserve
    ) private returns (IERC20 tokenUsed) {
        if (_fromReserve) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));
            require(holding.amount >= _inputTokenAmount, ""NestedFactory:_transferInputTokens: Insufficient amount"");

            // Get input from reserve
            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);
        } else if (address(_inputToken) == ETH) {
            require(msg.value == _inputTokenAmount, ""NestedFactory::_transferInputTokens: Insufficient amount in"");
            weth.deposit{ value: msg.value }();
            _inputToken = IERC20(address(weth));
        } else {
            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);
        }
        tokenUsed = _inputToken;
    }

    /// @dev Send the under spent amount to the FeeSplitter without the royalties.
    ///      The ""under spent"" amount is the positive difference between the amount supposed
    ///      to be spent and the amount really spent.
    /// @param _amountToSpent The amount supposed to be spent
    /// @param _amountSpent The amount really spent
    /// @param _token The amount-related token
    function _handleUnderSpending(
        uint256 _amountToSpent,
        uint256 _amountSpent,
        IERC20 _token
    ) private {
        if (_amountToSpent - _amountSpent > 0) {
            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);
        }
    }

    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset
    /// @param _amount Amount to send
    /// @param _token Token to send
    /// @param _nftId User portfolio ID used to find a potential royalties recipient
    function _transferFeeWithRoyalty(
        uint256 _amount,
        IERC20 _token,
        uint256 _nftId
    ) private {
        address originalOwner = nestedAsset.originalOwner(_nftId);
        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
        if (originalOwner != address(0)) {
            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);
        } else {
            feeSplitter.sendFees(_token, _amount);
        }
    }

    /// @dev Decrease the amount of a NFT holding
    /// @param _nftId The NFT id
    /// @param _inputToken The token holding
    /// @param _amount The amount to subtract from the actual holding amount
    function _decreaseHoldingAmount(
        uint256 _nftId,
        address _inputToken,
        uint256 _amount
    ) private {
        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);
        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);
    }

    /// @dev Transfer a token amount from the factory to the recipient.
    ///      The token is unwrapped if WETH.
    /// @param _token The token to transfer
    /// @param _amount The amount to transfer
    /// @param _dest The address receiving the funds
    function _safeTransferAndUnwrap(
        IERC20 _token,
        uint256 _amount,
        address _dest
    ) private {
        // if buy token is WETH, unwrap it instead of transferring it to the sender
        if (address(_token) == address(weth)) {
            IWETH(weth).withdraw(_amount);
            (bool success, ) = _dest.call{ value: _amount }("""");
            require(success, ""ETH_TRANSFER_ERROR"");
        } else {
            _token.safeTransfer(_dest, _amount);
        }
    }

    /// @dev Transfer from factory and collect fees
    /// @param _token The token to transfer
    /// @param _amount The amount (with fees) to transfer
    /// @param _dest The address receiving the funds
    function _safeTransferWithFees(
        IERC20 _token,
        uint256 _amount,
        address _dest,
        uint256 _nftId
    ) private {
        uint256 feeAmount = _calculateFees(_dest, _amount);
        _transferFeeWithRoyalty(feeAmount, _token, _nftId);
        _token.safeTransfer(_dest, _amount - feeAmount);
    }

    /// @dev Calculate the fees for a specific user and amount (1%)
    /// @param _user The user address
    /// @param _amount The amount
    /// @return The fees amount
    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {
        return _amount / 100;
    }
}",5567,562,"[H-01] Copy your own portfolio to keep earning royalties

Submitted by jayjonah8
Impact

In NestedFactory.sol going through the create() function which leads to the sendFeesWithRoyalties() => addShares() function, Im not seeing any checks preventing someone from copying their own portfolio and receiving royalty shares for it and simply repeating the process over and over again.

[M-01] setReserve() can be front-run

Submitted by palina
Impact

The reserve address variable in NestedFactory.sol remains equal to 0 before the setReserve() function is called by an owner. This may lead to incorrect transfers of tokens or invalid comparison with e.g., the asset reserve (nestedRecords.getAssetReserve(_nftId) == address(reserve)), should they occur before the value for reserve was set. In addition, the immutabiliy of the reserve variable requires extra caution when setting the value.
Proof of Concept

setReserve(): NestedFactory.sol L89
 [M-06] NestedFactory.sol#_submitInOrders() Wrong implementation cause users to be overcharged

Function `_submitInOrders`
When executing orders, the actual amountSpent + feesAmount can be lower than _inputTokenAmount, the unspent amount should be returned to the user.
However, in the current implementation, the unspent amount will be taken as part of the fee. NestedFactory.sol L285-L309
 [M-07] Ensure on-chain that cache is synced

Submitted by GreyArt, also found by WatchPug
Impact

Currently, many core operations (like `NestedFactory.create()`, `NestedFactory.swapTokenForTokens()`) are dependent on the assumption that the cache is synced before these functions are executed however this may not necessarily be the case.
 [M-08] Passing multiple ETH deposits in orders array will use the same msg.value many times

malicious user `msg.value` function `_transferInputTokens`

Contract holdings can be emptied as malicious user will do deposit/withdraw to extract value. This is possible because after transferInputTokens system uses contract balance for user's operations, assuming that equivalent value was transferred.",5,"pragma solidity 0.8.9;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Multicall.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""./libraries/ExchangeHelpers.sol"";
import ""./libraries/OperatorHelpers.sol"";
import ""./interfaces/external/IWETH.sol"";
import ""./interfaces/INestedFactory.sol"";
import ""./FeeSplitter.sol"";
import ""./MixinOperatorResolver.sol"";
import ""./NestedReserve.sol"";
import ""./NestedAsset.sol"";
import ""./NestedRecords.sol"";



contract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {
    using SafeERC20 for IERC20;
    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    
    bytes32[] private operators;

    
    FeeSplitter public feeSplitter;

    
    NestedReserve public reserve;

    NestedAsset public immutable nestedAsset;
    IWETH public immutable weth;
    NestedRecords public immutable nestedRecords;

    constructor(
        NestedAsset _nestedAsset,
        NestedRecords _nestedRecords,
        FeeSplitter _feeSplitter,
        IWETH _weth,
        address _operatorResolver
    ) MixinOperatorResolver(_operatorResolver) {
        nestedAsset = _nestedAsset;
        nestedRecords = _nestedRecords;
        feeSplitter = _feeSplitter;
        weth = _weth;
    }

    
    
    modifier onlyTokenOwner(uint256 _nftId) {
        require(nestedAsset.ownerOf(_nftId) == _msgSender(), ""NestedFactory: Not the token owner"");
        _;
    }

    
    
    
    modifier isUnlocked(uint256 _nftId) {
        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), ""NestedFactory: The NFT is currently locked"");
        _;
    }

    
    receive() external payable {}

    
    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {
        return operators;
    }

    
    function addOperator(bytes32 operator) external override onlyOwner {
        operators.push(operator);
    }

    
    function removeOperator(bytes32 operator) external override onlyOwner {
        uint256 i = 0;
        while (operators[i] != operator) {
            i++;
        }
        require(i > 0, ""NestedFactory::removeOperator: Cant remove non-existent operator"");
        delete operators[i];
    }

    
    function setReserve(NestedReserve _reserve) external override onlyOwner {
        require(address(reserve) == address(0), ""NestedFactory::setReserve: Reserve is immutable"");
        reserve = _reserve;
        emit ReserveUpdated(address(_reserve));
    }

    
    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {
        require(address(_feeSplitter) != address(0), ""NestedFactory::setFeeSplitter: Invalid feeSplitter address"");
        feeSplitter = _feeSplitter;
        emit FeeSplitterUpdated(address(_feeSplitter));
    }

    
    function create(
        uint256 _originalTokenId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant {
        require(_orders.length > 0, ""NestedFactory::create: Missing orders"");

        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);
        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);

        _transferFeeWithRoyalty(fees, tokenSold, nftId);
        emit NftCreated(nftId, _originalTokenId);
    }

    
    function addTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant onlyTokenOwner(_nftId) {
        require(_orders.length > 0, ""NestedFactory::addTokens: Missing orders"");

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);
        emit NftUpdated(_nftId);
    }

    
    function swapTokenForTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::swapTokenForTokens: Missing orders"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::swapTokenForTokens: Assets in different reserve""
        );

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);

        emit NftUpdated(_nftId);
    }

    
    function sellTokensToNft(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToNft: Missing orders"");
        require(_sellTokensAmount.length == _orders.length, ""NestedFactory::sellTokensToNft: Input lengths must match"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToNft: Assets in different reserve""
        );

        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);

        emit NftUpdated(_nftId);
    }

    
    function sellTokensToWallet(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToWallet: Missing orders"");
        require(
            _sellTokensAmount.length == _orders.length,
            ""NestedFactory::sellTokensToWallet: Input lengths must match""
        );
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToWallet: Assets in different reserve""
        );

        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(
            _nftId,
            _buyToken,
            _sellTokensAmount,
            _orders,
            false,
            true
        );
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());

        emit NftUpdated(_nftId);
    }

    
    function destroy(
        uint256 _nftId,
        IERC20 _buyToken,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);
        require(_orders.length > 0, ""NestedFactory::destroy: Missing orders"");
        require(tokens.length == _orders.length, ""NestedFactory::destroy: Missing sell args"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::destroy: Assets in different reserve""
        );

        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));

        for (uint256 i = 0; i < tokens.length; i++) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);
            reserve.withdraw(IERC20(holding.token), holding.amount);

            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);
            nestedRecords.freeHolding(_nftId, tokens[i]);
        }

        
        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;
        uint256 amountFees = _calculateFees(_msgSender(), amountBought);
        amountBought = amountBought - amountFees;

        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());

        
        nestedRecords.removeNFT(_nftId);
        nestedAsset.burn(_msgSender(), _nftId);
        emit NftBurned(_nftId);
    }

    
    function withdraw(uint256 _nftId, uint256 _tokenIndex)
        external
        override
        nonReentrant
        onlyTokenOwner(_nftId)
        isUnlocked(_nftId)
    {
        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);
        require(assetTokensLength > _tokenIndex, ""NestedFactory::withdraw: Invalid token index"");
        
        require(assetTokensLength > 1, ""NestedFactory::withdraw: Can't withdraw the last asset"");

        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(
            _nftId,
            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]
        );
        reserve.withdraw(IERC20(holding.token), holding.amount);
        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);

        nestedRecords.deleteAsset(_nftId, _tokenIndex);

        emit NftUpdated(_nftId);
    }

    
    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {
        nestedRecords.updateLockTimestamp(_nftId, _timestamp);
    }

    
    function unlockTokens(IERC20 _token) external override onlyOwner {
        _token.transfer(owner(), _token.balanceOf(address(this)));
    }

    
    
    
    
    
    
    
    
    
    
    function _submitInOrders(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, IERC20 tokenSold) {
        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);
        uint256 amountSpent;
        for (uint256 i = 0; i < _orders.length; i++) {
            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);
        }
        feesAmount = _calculateFees(_msgSender(), amountSpent);
        assert(amountSpent <= _inputTokenAmount - feesAmount); 

        
        if (_fromReserve) {
            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);
        }

        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);

        tokenSold = _inputToken;
    }

    
    
    
    
    
    
    
    
    
    
    function _submitOutOrders(
        uint256 _nftId,
        IERC20 _outputToken,
        uint256[] memory _inputTokenAmounts,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, uint256 amountBought) {
        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));

        for (uint256 i = 0; i < _orders.length; i++) {
            IERC20 _inputToken = _transferInputTokens(
                _nftId,
                IERC20(_orders[i].token),
                _inputTokenAmounts[i],
                _fromReserve
            );

            
            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);
            assert(amountSpent <= _inputTokenAmounts[i]);

            if (_fromReserve) {
                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);
            }

            
            if (_inputTokenAmounts[i] - amountSpent > 0) {
                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);
            }
        }

        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;
        feesAmount = _calculateFees(_msgSender(), amountBought);

        if (_reserved) {
            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);
        }
    }

    
    
    
    
    
    
    
    function _submitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _nftId,
        Order calldata _order,
        bool _reserved
    ) private returns (uint256 amountSpent) {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        require(success, ""NestedFactory::_submitOrder: Operator call failed"");

        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
            data,
            _inputToken,
            _outputToken
        );

        if (_reserved) {
            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);
        }
        amountSpent = amounts[1];
    }

    
    
    
    
    
    
    
    
    
    function _safeSubmitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _amountToSpend,
        uint256 _nftId,
        Order calldata _order
    ) private {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        if (success) {
            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
                data,
                _inputToken,
                _outputToken
            );
            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));
        } else {
            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);
        }
    }

    
    
    
    
    
    function _transferToReserveAndStore(
        address _token,
        uint256 _amount,
        uint256 _nftId
    ) private {
        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));

        
        IERC20(_token).safeTransfer(address(reserve), _amount);

        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));

        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));
    }

    
    
    
    
    
    
    
    function _transferInputTokens(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        bool _fromReserve
    ) private returns (IERC20 tokenUsed) {
        if (_fromReserve) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));
            require(holding.amount >= _inputTokenAmount, ""NestedFactory:_transferInputTokens: Insufficient amount"");

            
            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);
        } else if (address(_inputToken) == ETH) {
            require(msg.value == _inputTokenAmount, ""NestedFactory::_transferInputTokens: Insufficient amount in"");
            weth.deposit{ value: msg.value }();
            _inputToken = IERC20(address(weth));
        } else {
            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);
        }
        tokenUsed = _inputToken;
    }

    
    
    
    
    
    
    function _handleUnderSpending(
        uint256 _amountToSpent,
        uint256 _amountSpent,
        IERC20 _token
    ) private {
        if (_amountToSpent - _amountSpent > 0) {
            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);
        }
    }

    
    
    
    
    function _transferFeeWithRoyalty(
        uint256 _amount,
        IERC20 _token,
        uint256 _nftId
    ) private {
        address originalOwner = nestedAsset.originalOwner(_nftId);
        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
        if (originalOwner != address(0)) {
            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);
        } else {
            feeSplitter.sendFees(_token, _amount);
        }
    }

    
    
    
    
    function _decreaseHoldingAmount(
        uint256 _nftId,
        address _inputToken,
        uint256 _amount
    ) private {
        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);
        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);
    }

    
    
    
    
    
    function _safeTransferAndUnwrap(
        IERC20 _token,
        uint256 _amount,
        address _dest
    ) private {
        
        if (address(_token) == address(weth)) {
            IWETH(weth).withdraw(_amount);
            (bool success, ) = _dest.call{ value: _amount }("""");
            require(success, ""ETH_TRANSFER_ERROR"");
        } else {
            _token.safeTransfer(_dest, _amount);
        }
    }

    
    
    
    
    function _safeTransferWithFees(
        IERC20 _token,
        uint256 _amount,
        address _dest,
        uint256 _nftId
    ) private {
        uint256 feeAmount = _calculateFees(_dest, _amount);
        _transferFeeWithRoyalty(feeAmount, _token, _nftId);
        _token.safeTransfer(_dest, _amount - feeAmount);
    }

    
    
    
    
    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {
        return _amount / 100;
    }
}",4148,1,4,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is used appropriately to protect sensitive functions such as `addOperator`, `removeOperator`, `setReserve`, `setFeeSplitter`, and `unlockTokens`."",
        ""Confirm that only the token owner can call functions protected by the `onlyTokenOwner` modifier."",
        ""Check that `increaseLockTimestamp` can only be called by the token owner."",
        ""Ensure the `setReserve` function can only be called once and that the reserve address cannot be changed after being set."",
        ""Verify that the `_calculateFees` function is correctly implemented and cannot be manipulated by malicious users to reduce fees."",
        ""Investigate potential vulnerabilities if the `owner()` is a contract address and the contract is compromised.""
      ]
    },
    {
      ""Area"": ""External Interactions and Operator Security"",
      ""Tasks"": [
        ""Analyze the `OperatorHelpers` library, particularly the `callOperator` and `decodeDataAndRequire` functions, to understand the execution flow and potential vulnerabilities of external operators."",
        ""Assess the risk of malicious operators executing harmful trades or stealing funds. Implement mitigations such as whitelisting operators, setting limits on trade amounts, or requiring operator deposits."",
        ""Examine the `MixinOperatorResolver` contract to understand how operator addresses are resolved and ensure the resolution process is secure and tamper-proof."",
        ""Verify that the `requireAndGetAddress` function in `MixinOperatorResolver` correctly retrieves and validates operator addresses."",
        ""Investigate potential vulnerabilities in the external calls to `nestedAsset`, `nestedRecords`, `feeSplitter`, and `nestedReserve`. Consider scenarios where these contracts could be compromised."",
        ""Analyze the potential impact of incorrect data being returned from external contracts."",
        ""Evaluate whether the contract sufficiently validates the input data provided to external contracts.""
      ]
    },
    {
      ""Area"": ""Token Handling and Arithmetic"",
      ""Tasks"": [
        ""Check for potential integer overflow or underflow vulnerabilities in arithmetic operations, especially in fee calculations, amount calculations, and transfer functions."",
        ""Verify that tokens are safely transferred using `SafeERC20`'s `safeTransfer` and `safeTransferFrom` functions."",
        ""Review the logic for handling ETH deposits and withdrawals via WETH. Ensure that ETH is correctly deposited and unwrapped."",
        ""Analyze the potential impact of tokens with different decimals. How the contract handles tokens with different decimals?"",
        ""Verify that the contract handles rebasing/deflationary tokens properly"",
        ""In `_handleUnderSpending` function, ensure that `ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter))` will work properly. FeeSplitter needs to send fee to different addresses. It will be safe if the allowance is set to max?"",
        ""Check the calculation of fees in `_calculateFees`. Ensure this fee is reasonable and doesn't lead to stuck funds. Ensure this can be updated by owner.""
      ]
    },
    {
      ""Area"": ""NFT Logic and State Management"",
      ""Tasks"": [
        ""Review the state management of NFTs, particularly the `nestedRecords` contract, to ensure that token balances and ownership are correctly tracked."",
        ""Analyze the locking mechanism controlled by `nestedRecords.getLockTimestamp` and `increaseLockTimestamp` to prevent unauthorized actions on locked NFTs."",
        ""Verify that the `destroy` function correctly removes the NFT and transfers all tokens to the owner."",
        ""Investigate potential vulnerabilities if the nested asset is also using royalty"",
        ""In the `withdraw` function, analyze the edge case of withdrawing the last asset and verify the contract's behavior"",
        ""Review storage and access of NFT metadata to prevent leakage.""
      ]
    },
    {
      ""Area"": ""Reentrancy and Control Flow"",
      ""Tasks"": [
        ""Confirm that the `nonReentrant` modifier is correctly applied to all external functions that modify state to prevent reentrancy attacks."",
         ""Review all functions performing external calls for potential reentrancy vulnerabilities despite the `nonReentrant` modifier. Pay special attention to the order in which state variables are updated versus when external calls occur."",
        ""Carefully analyze the control flow in functions involving external calls, especially those that transfer tokens or interact with other contracts. Make sure the function logic executes as expected under different conditions.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify areas where gas costs can be reduced, such as using more efficient data structures or reducing the number of storage accesses."",
        ""Review loops and iterations for potential gas inefficiencies."",
        ""Consider using calldata instead of memory for function parameters where appropriate."",
        ""Evaluate the contract's deployment cost and transaction costs for common operations."",
        ""Are there opportunities to combine function calls to reduce gas costs?"",
        ""Can events be emitted more efficiently to lower gas costs for users who listen to them?""
      ]
    },
    {
      ""Area"": ""Order Processing and Validation"",
      ""Tasks"": [
        ""Examine the order processing logic in `_submitInOrders` and `_submitOutOrders` to ensure that orders are executed correctly and securely."",
        ""Verify that the order data is properly validated before being passed to external operators."",
        ""Assess the potential for manipulation or abuse of the order processing system."",
        ""Analyze the use of `assert` in `_submitInOrders` to ensure it's used appropriately for internal invariant checking."",
        ""What happens if an operator fails? Is there sufficient error handling?"",
        ""In the `_safeSubmitOrder` function, the `_handleUnderSpending` function should be analyzed properly.""
      ]
    },
    {
      ""Area"": ""General Security"",
      ""Tasks"": [
        ""Perform static analysis of the contract to identify potential security vulnerabilities."",
        ""Write unit tests and integration tests to cover all critical functions and edge cases."",
        ""Consider using fuzzing tools to automatically generate test cases and uncover unexpected behavior."",
        ""Review the contract's error handling and logging mechanisms."",
        ""Ensure that the contract adheres to best practices for smart contract security."",
        ""Is there a fallback mechanism to handle unforeseen issues or bugs in the contract?""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines a `NestedFactory` contract that facilitates the creation, modification, and destruction of nested NFTs, allowing users to trade tokens within these NFTs using a series of orders executed by external operators. It manages fees, royalties, and integrates with other contracts like `NestedAsset`, `NestedRecords`, `FeeSplitter`, and `NestedReserve`. The contract also handles WETH deposits and withdrawals. Access control is managed through `Ownable` and custom modifiers."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NestedFactory"",
    ""Purpose"": ""A factory contract for creating, managing, and destroying nested NFTs. It allows users to add, swap, and sell tokens within the NFT and transfer them to the wallet, leveraging external operators to execute trades."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ReentrancyGuard"",
        ""Ownable"",
        ""MixinOperatorResolver"",
        ""Multicall"",
        ""INestedFactory""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/security/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/utils/Multicall.sol"",
        ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""./libraries/ExchangeHelpers.sol"",
        ""./libraries/OperatorHelpers.sol"",
        ""./interfaces/external/IWETH.sol"",
        ""./interfaces/INestedFactory.sol"",
        ""./FeeSplitter.sol"",
        ""./MixinOperatorResolver.sol"",
        ""./NestedReserve.sol"",
        ""./NestedAsset.sol"",
        ""./NestedRecords.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""ETH"",
        ""Type"": ""address"",
        ""Purpose"": ""Constant address representing ETH""
      },
      {
        ""Name"": ""operators"",
        ""Type"": ""bytes32[]"",
        ""Purpose"": ""Array of operator identifiers""
      },
      {
        ""Name"": ""feeSplitter"",
        ""Type"": ""FeeSplitter"",
        ""Purpose"": ""Address of the fee splitter contract""
      },
      {
        ""Name"": ""reserve"",
        ""Type"": ""NestedReserve"",
        ""Purpose"": ""Address of the nested reserve contract""
      },
      {
        ""Name"": ""nestedAsset"",
        ""Type"": ""NestedAsset"",
        ""Purpose"": ""Address of the nested asset contract""
      },
      {
        ""Name"": ""weth"",
        ""Type"": ""IWETH"",
        ""Purpose"": ""Address of the WETH contract""
      },
      {
        ""Name"": ""nestedRecords"",
        ""Type"": ""NestedRecords"",
        ""Purpose"": ""Address of the nested records contract""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the addresses of the `NestedAsset`, `NestedRecords`, `FeeSplitter`, `IWETH`, and `MixinOperatorResolver` contracts."",
        ""Parameters"": [
          ""_nestedAsset"",
          ""_nestedRecords"",
          ""_feeSplitter"",
          ""_weth"",
          ""_operatorResolver""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyTokenOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Requires the caller to be the owner of the specified NFT."",
        ""Parameters"": [""_nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""isUnlocked"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Requires the NFT to be unlocked based on the lock timestamp stored in `nestedRecords`."",
        ""Parameters"": [""_nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the contract to receive ETH."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""resolverAddressesRequired"",
        ""Visibility"": ""public override view"",
        ""Purpose"": ""Returns the array of operator identifiers."",
        ""Parameters"": [],
        ""Returns"": [""bytes32[]""]
      },
      {
        ""Name"": ""addOperator"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Adds a new operator identifier to the `operators` array. Only callable by the owner."",
        ""Parameters"": [""operator""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeOperator"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Removes an operator identifier from the `operators` array. Only callable by the owner."",
        ""Parameters"": [""operator""],
        ""Returns"": []
      },
      {
        ""Name"": ""setReserve"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Sets the address of the `NestedReserve` contract.  It can only be set once."",
        ""Parameters"": [""_reserve""],
        ""Returns"": []
      },
      {
        ""Name"": ""setFeeSplitter"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Sets the address of the `FeeSplitter` contract. Only callable by the owner."",
        ""Parameters"": [""_feeSplitter""],
        ""Returns"": []
      },
      {
        ""Name"": ""create"",
        ""Visibility"": ""external payable override"",
        ""Purpose"": ""Creates a new nested NFT with a given original token ID and executes a series of orders to populate the NFT with tokens."",
        ""Parameters"": [
          ""_originalTokenId"",
          ""_sellToken"",
          ""_sellTokenAmount"",
          ""_orders""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""addTokens"",
        ""Visibility"": ""external payable override"",
        ""Purpose"": ""Adds tokens to an existing nested NFT by executing a series of orders."",
        ""Parameters"": [
          ""_nftId"",
          ""_sellToken"",
          ""_sellTokenAmount"",
          ""_orders""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""swapTokenForTokens"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Swaps a token within the NFT for other tokens using a series of orders."",
        ""Parameters"": [
          ""_nftId"",
          ""_sellToken"",
          ""_sellTokenAmount"",
          ""_orders""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""sellTokensToNft"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Sells a series of tokens from the user's wallet to the NFT."",
        ""Parameters"": [
          ""_nftId"",
          ""_buyToken"",
          ""_sellTokensAmount"",
          ""_orders""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""sellTokensToWallet"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Sells a series of tokens from the NFT to the user's wallet."",
        ""Parameters"": [
          ""_nftId"",
          ""_buyToken"",
          ""_sellTokensAmount"",
          ""_orders""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""destroy"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Destroys a nested NFT, selling all the tokens within it for a specified buy token and transferring the proceeds to the owner."",
        ""Parameters"": [""_nftId"", ""_buyToken"", ""_orders""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Withdraws a specific token from a nested NFT to the owner's wallet."",
        ""Parameters"": [""_nftId"", ""_tokenIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseLockTimestamp"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Increases the lock timestamp for an NFT."",
        ""Parameters"": [""_nftId"", ""_timestamp""],
        ""Returns"": []
      },
      {
        ""Name"": ""unlockTokens"",
        ""Visibility"": ""external override"",
        ""Purpose"": ""Allows the owner to withdraw any tokens accidentally sent to the contract."",
        ""Parameters"": [""_token""],
        ""Returns"": []
      },
      {
        ""Name"": ""_submitInOrders"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Handles orders where input token is sold."",
        ""Parameters"": [
          ""_nftId"",
          ""_inputToken"",
          ""_inputTokenAmount"",
          ""_orders"",
          ""_reserved"",
          ""_fromReserve""
        ],
        ""Returns"": [""uint256"", ""IERC20""]
      },
      {
        ""Name"": ""_submitOutOrders"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Handles orders where output token is bought."",
        ""Parameters"": [
          ""_nftId"",
          ""_outputToken"",
          ""_inputTokenAmounts"",
          ""_orders"",
          ""_reserved"",
          ""_fromReserve""
        ],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""_submitOrder"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Submits a single order to an operator."",
        ""Parameters"": [
          ""_inputToken"",
          ""_outputToken"",
          ""_nftId"",
          ""_order"",
          ""_reserved""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_safeSubmitOrder"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Safely submits a single order and handles errors by transferring funds back to the sender."",
        ""Parameters"": [
          ""_inputToken"",
          ""_outputToken"",
          ""_amountToSpend"",
          ""_nftId"",
          ""_order""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferToReserveAndStore"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Transfers tokens to the reserve and updates the nested records."",
        ""Parameters"": [""_token"", ""_amount"", ""_nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferInputTokens"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Transfers input tokens from the user or reserve to the contract."",
        ""Parameters"": [
          ""_nftId"",
          ""_inputToken"",
          ""_inputTokenAmount"",
          ""_fromReserve""
        ],
        ""Returns"": [""IERC20""]
      },
      {
        ""Name"": ""_handleUnderSpending"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Handles cases where the amount spent is less than the amount provided."",
        ""Parameters"": [""_amountToSpent"", ""_amountSpent"", ""_token""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transferFeeWithRoyalty"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Calculates and transfers fees and royalties."",
        ""Parameters"": [""_amount"", ""_token"", ""_nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_decreaseHoldingAmount"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Decreases a holding amount in NestedRecords."",
        ""Parameters"": [""_nftId"", ""_inputToken"", ""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_safeTransferAndUnwrap"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Safely transfers tokens or ETH to a destination address, unwrapping WETH if necessary."",
        ""Parameters"": [""_token"", ""_amount"", ""_dest""],
        ""Returns"": []
      },
      {
        ""Name"": ""_safeTransferWithFees"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Safely transfers tokens to a destination address, calculating and deducting fees."",
        ""Parameters"": [""_token"", ""_amount"", ""_dest"", ""_nftId""],
        ""Returns"": []
      },
      {
        ""Name"": ""_calculateFees"",
        ""Visibility"": ""private view"",
        ""Purpose"": ""Calculates the fees based on the amount."",
        ""Parameters"": [""_user"", ""_amount""],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20"",
    ""IWETH"",
    ""NestedAsset"",
    ""NestedRecords"",
    ""FeeSplitter"",
    ""NestedReserve"",
    ""Operators (through MixinOperatorResolver)""
  ],
  ""SpecialMechanisms"": [
    ""Nested NFTs: The contract manages NFTs that contain other tokens."",
    ""Operator Pattern: External operators execute trades, allowing for flexible exchange logic."",
    ""Fee and Royalty Split:  Fees and royalties are calculated and distributed to the appropriate parties."",
    ""Locking Mechanism: NFTs can be locked to prevent certain actions until a specified timestamp."",
    ""WETH Handling: Special logic is implemented to handle ETH deposits and withdrawals using WETH.""
  ],
  ""Questions"": [
    ""What is the specific logic within the `OperatorHelpers` library, especially regarding `callOperator` and `decodeDataAndRequire`?"",
    ""How is the `originalOwner` of the NFT determined and used in the `_transferFeeWithRoyalty` function?  Is this retrieved from `nestedAsset`?"",
    ""What are the security implications of relying on external operators for trade execution?  How are malicious operators prevented?"",
    ""What are the gas optimization strategies employed in this contract?"",
     ""Can the owner withdraw the very last asset using the `withdraw` function? The require statement `require(assetTokensLength > 1, \""NestedFactory::withdraw: Can't withdraw the last asset\"");` seems to contradict this.  The `destroy` function exists for this purpose but it is more complex."",
    ""Why is `assert(amountSpent <= _inputTokenAmount - feesAmount);` used instead of `require` in the `_submitInOrders` function? Is there a specific reason for using assert here? A failed assert will revert the transaction.""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in `_safeTransferAndUnwrap` when unwrapping WETH"",
      ""Severity"": ""High"",
      ""Description"": ""The `_safeTransferAndUnwrap` function withdraws WETH and attempts to transfer ETH using a raw `call`, which can trigger a reentrancy attack if the recipient is a contract. This bypasses the `ReentrancyGuard` and can lead to unexpected state changes or loss of funds. The fallback function of the reentering contract can call back into NestedFactory through functions like `swapTokenForTokens`, `sellTokensToNft`, `sellTokensToWallet` or `destroy`."",
      ""Impact"": ""The contract could be drained of ETH if a malicious contract re-enters during the ETH transfer in `_safeTransferAndUnwrap`."",
      ""Location"": ""NestedFactory.sol:_safeTransferAndUnwrap""
    },
    {
      ""Issue"": ""Potential Loss of Funds Due to Incorrect UnderSpending Handling in `_safeSubmitOrder`"",
      ""Severity"": ""High"",
      ""Description"": ""If `OperatorHelpers.callOperator` fails in `_safeSubmitOrder`, the function executes `_safeTransferWithFees`. However, the function does not revert if the operator call fails. This means that `_amountToSpend` is debited, but potentially no actual swap occurs. Because the user is charged fees, they lose value and receive nothing in return for the failed operator call and corresponding fees."",
      ""Impact"": ""Users may lose funds if an operator call fails, and a portion of their funds are used to pay fees, while no swap or trade occurs.""
    },
    {
      ""Issue"": ""Unbounded Loop in `removeOperator`"",
      ""Severity"": ""High"",
      ""Description"": ""The `removeOperator` function iterates through the `operators` array to find the index of the operator to remove without checking for the end of the array. If the operator is not found, the loop will continue indefinitely, potentially leading to an out-of-bounds access and potentially crashing the contract or causing unexpected behavior. Also the require statement `require(i > 0, \""NestedFactory::removeOperator: Cant remove non-existent operator\"");` is incorrect and should be `require(i < operators.length, \""NestedFactory::removeOperator: Cant remove non-existent operator\"");`"",
      ""Impact"": ""The contract could become unusable or exhibit unpredictable behavior due to an out-of-bounds access in the `removeOperator` function."",
      ""Location"": ""NestedFactory.sol:removeOperator""
    },
    {
      ""Issue"": ""Asset Reserve Check Circumvention Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The functions `swapTokenForTokens`, `sellTokensToNft`, and `sellTokensToWallet` all have a check requiring that the NFT's associated reserve matches the contract's `reserve`. However, there is no mechanism in this contract to *set* the asset reserve. Therefore, if the `NestedRecords` contract is compromised, the asset reserve could be set to an arbitrary address by a malicious actor, bypassing these critical security checks."",
      ""Impact"": ""Catastrophic loss of funds if the NestedRecords contract is compromised, allowing the reserve checks to be bypassed.""
    },
    {
      ""Issue"": ""Potential Reentrancy Issues with Operator Contracts"",
      ""Severity"": ""High"",
      ""Description"": ""The `_submitOrder` and `_safeSubmitOrder` functions call external operator contracts using `OperatorHelpers.callOperator`. While the `NestedFactory` itself uses `ReentrancyGuard`, the external operator contracts might be vulnerable to reentrancy attacks. If an operator contract calls back into the `NestedFactory` before the initial execution is complete, it could lead to unexpected behavior or security exploits."",
      ""Impact"": ""Potential for reentrancy attacks through vulnerable operator contracts, potentially leading to theft of funds or other security breaches."",
      ""Location"": ""NestedFactory.sol:322, NestedFactory.sol:351""
    },
    {
      ""Issue"": ""Potential Reentrancy Risk in `_safeSubmitOrder` Fallback"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_safeSubmitOrder` function attempts a potentially unsafe transfer if the operator call fails, specifically, `_safeTransferWithFees` is called. This can be vulnerable to reentrancy if the token being transferred implements a hook that calls back into the contract, potentially manipulating contract state unexpectedly. This is particularly concerning because the fallback mechanism is triggered on operator failure, which could be attacker-controlled."",
      ""Impact"": ""The contract's state could be manipulated maliciously if a reentrancy attack occurs during the fallback transfer, leading to unexpected token transfers, incorrect state updates, or denial of service."",
      ""Location"": ""NestedFactory.sol:_safeSubmitOrder, NestedFactory.sol:_safeTransferWithFees""
    },
    {
      ""Issue"": ""Missing Input Validation for `_orders` array and `_sellTokensAmount` across multiple functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions require a `_orders` array as input, but don't validate individual `Order` structs within the array. The `sellTokensToNft` and `sellTokensToWallet` functions do not validate `_sellTokensAmount` which can cause DoS. Missing validation for the `Order` struct (specifically `commit` and `callData`) could lead to unexpected behavior if invalid or malicious data is provided."",
      ""Impact"": ""The contract could be vulnerable to denial-of-service attacks if invalid data causes the contract to revert unexpectedly within the loop of processing the orders. Also, malicious actors could pass crafted `callData` to cause the called operators to execute unintended behavior."",
      ""Location"": ""Functions: `create`, `addTokens`, `swapTokenForTokens`, `sellTokensToNft`, `sellTokensToWallet`, `destroy`.""
    },
    {
      ""Issue"": ""Missing Zero Address Check for Important Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor lacks zero address checks for critical address parameters like `_nestedAsset`, `_nestedRecords`, `_weth`, and `_operatorResolver`. Passing the zero address to these parameters can cause unpredictable behavior or contract failure later on. While `setFeeSplitter` has a zero address check."",
      ""Impact"": ""Contract may become unusable if a crucial address is unintentionally set to zero. For example, if the `_operatorResolver` is the zero address, then `requireAndGetAddress` calls will always fail, halting most contract functionality."",
      ""Location"": ""NestedFactory.sol:Constructor""
    },
    {
      ""Issue"": ""Lack of Slippage Protection in Order Execution"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_submitOrder` and `_safeSubmitOrder` functions execute orders by calling an external operator. There is no slippage protection in place, meaning the operator could execute the swap at a significantly worse price than expected, potentially losing funds for the user.  The amounts returned from the `OperatorHelpers.decodeDataAndRequire` are trusted without validation. An untrusted operator could manipulate these values."",
      ""Impact"": ""Users could receive less tokens than expected due to slippage during order execution."",
      ""Location"": ""NestedFactory.sol:_submitOrder, NestedFactory.sol:_safeSubmitOrder""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `create`, `addTokens`, `swapTokenForTokens`, `sellTokensToNft`, and `sellTokensToWallet`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `create`, `addTokens`, `swapTokenForTokens`, `sellTokensToNft`, and `sellTokensToWallet` functions rely on an array of `Order` structs provided by the caller. A malicious actor could monitor the mempool for transactions calling these functions and front-run them with their own `Order` data. This could allow the attacker to profit at the expense of the original transaction's creator, by inserting favorable orders for themselves before the original transaction executes."",
      ""Impact"": ""Users may experience unfavorable execution prices due to front-running."",
      ""Location"": ""NestedFactory.sol:create, NestedFactory.sol:addTokens, NestedFactory.sol:swapTokenForTokens, NestedFactory.sol:sellTokensToNft, NestedFactory.sol:sellTokensToWallet""
    },
    {
      ""Issue"": ""Incorrect handling of ETH in `_transferFeeWithRoyalty` when ETH is used as fee token"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_transferFeeWithRoyalty` function calls `ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter))`. This call is unnecessary and potentially problematic when `_token` is WETH (representing ETH), as `setMaxAllowance` is designed for ERC20 tokens and setting allowance for WETH towards feeSplitter is ineffective and may not function as intended for native ETH transfers."",
      ""Impact"": ""Potential errors during fee distribution with WETH. Inability to collect fees correctly if WETH is treated as ERC20 instead of native ETH in the `feeSplitter` contract."",
      ""Location"": ""NestedFactory.sol:_transferFeeWithRoyalty""
    },
    {
      ""Issue"": ""Potential vulnerability in _submitOutOrders when dealing with ERC20 tokens with no return values on transfer"",
      ""Severity"": ""Medium"",
      ""Description"": ""In function `_submitOutOrders`, for loop, when the underspending handling is triggered: `if (_inputTokenAmounts[i] - amountSpent > 0) { _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId); }`. This will cause a transfer to the feeSplitter. `_transferFeeWithRoyalty` calls  `ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter))`. If `_token` is a token that does not return a boolean value on transfer and approve (like USDT), the `safeTransfer` and `safeApprove` functions will revert, causing the whole transaction to revert, blocking the user from withdrawing or burning their NFT. It might be impossible for users to interact with certain tokens that aren't compliant with the ERC20 standard."",
      ""Impact"": ""Contract can be rendered unusable with non-compliant ERC20 tokens, blocking token transfers and NFT actions."",
      ""Location"": ""NestedFactory.sol:_submitOutOrders""
    },
    {
      ""Issue"": ""Missing Input Validation for `_timestamp` in `increaseLockTimestamp`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `increaseLockTimestamp` function allows the token owner to increase the lock timestamp of an NFT without validating that the new timestamp `_timestamp` is actually greater than the current lock timestamp or adding a max cap. This allows the owner to set the timestamp to a past value, effectively unlocking the NFT prematurely."",
      ""Impact"": ""Token owners can bypass the lock mechanism, potentially leading to unexpected behavior and security vulnerabilities. A malicious owner could lock the NFT for an unreasonably long period of time."",
      ""Location"": ""NestedFactory.sol:increaseLockTimestamp""
    },
    {
      ""Issue"": ""Potential Loss of Tokens if `_handleUnderSpending` Fails"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_handleUnderSpending` function attempts to send fees to the `feeSplitter`. If this transfer fails, the funds will be stuck in the contract. "",
      ""Impact"": ""Funds intended to be distributed as fees can be stuck within the contract if the `feeSplitter.sendFees` transaction fails."",
      ""Location"": ""NestedFactory.sol:_handleUnderSpending""
    },
    {
      ""Issue"": ""Lack of proper handling of Ether transfers in `destroy` function."",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `destroy` function, if `_buyToken` is WETH, the contract withdraws the WETH but then sends Ether to the msg.sender using a low-level call. This requires a gas stipend, and could fail. It\'s best to use `payable(msg.sender).transfer(_amount)` for this in 0.8.9. Moreover, the `_safeTransferAndUnwrap` function should be used instead."",
      ""Impact"": ""Possible failure of Ether transfer, leading to stuck funds or denial of service."",
      ""Location"": ""NestedFactory.sol:183, NestedFactory.sol:469""
    },
    {
      ""Issue"": ""Missing Zero Address Check in `setReserve`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setReserve` function sets the address of the `reserve`. Although the function checks that `address(reserve) == address(0)` before setting the reserve, there\'s no explicit check in the `setReserve` function that the new `_reserve` address isn\'t the zero address itself. Setting it to the zero address would effectively disable reserve functionality and likely break the contract."",
      ""Impact"": ""Denial of service if reserve is set to the zero address."",
      ""Location"": ""NestedFactory.sol:68""
    },
    {
      ""Issue"": ""Potential for incorrect asset handling due to lack of slippage protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_submitOrder` and `_safeSubmitOrder` functions directly interact with external operators without implementing any slippage protection mechanism. The amounts returned from `OperatorHelpers.decodeDataAndRequire` are assumed to be the exact amounts transferred. If the actual swap deviates from the expected amounts due to price fluctuations or other market conditions, it can lead to unexpected behavior in the downstream logic, such as incorrect reserve accounting and transfer of too few or too many tokens."",
      ""Impact"": ""Unexpected token amounts being transferred or stored, leading to financial losses for users or contract owner."",
      ""Location"": ""NestedFactory.sol:_submitOrder"",
      ""Location"": ""NestedFactory.sol:_safeSubmitOrder""
    },
    {
      ""Issue"": ""Missing input validation in `_submitInOrders` and `_submitOutOrders` for `_orders` array elements"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `_submitInOrders` and `_submitOutOrders` rely on the `Order` struct's `operator`, `commit`, and `callData` fields without explicitly validating them. Malicious or incorrectly formatted data in these fields can cause the operator call to fail unexpectedly, or cause incorrect amounts or tokens to be used."",
      ""Impact"": ""Execution reverts, incorrect order processing, or potential exploitation via a malicious operator implementation."",
      ""Location"": ""NestedFactory.sol:_submitInOrders, NestedFactory.sol:_submitOutOrders""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `_safeSubmitOrder`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_safeSubmitOrder` function calls an external operator using `OperatorHelpers.callOperator`. While the `NestedFactory` contract itself uses `ReentrancyGuard`, the external operator\'s code is not under its control. A malicious operator could potentially re-enter the `NestedFactory` contract through other functions that interact with the same state variables, bypassing the reentrancy protection."",
      ""Impact"": ""A malicious operator could potentially manipulate the state of the `NestedFactory` contract, leading to unauthorized access, fund theft, or other unexpected behavior."",
      ""Location"": ""NestedFactory.sol:_safeSubmitOrder""
    },
    {
      ""Issue"": ""Lack of slippage protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract executes trades without any slippage protection. A user could submit an order that gets executed at a much worse price than expected, especially if the liquidity is low. This is a common vulnerability in DeFi protocols."",
      ""Impact"": ""Users can lose significant funds due to slippage."",
      ""Location"": ""All functions that execute trades: `create`, `addTokens`, `swapTokenForTokens`, `sellTokensToNft`, `sellTokensToWallet`, `destroy`""
    },
    {
      ""Issue"": ""Lack of Input Validation in `removeOperator` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `removeOperator` function iterates through the `operators` array to find the operator to remove. However, it stops iteration as soon as it finds a match (`operators[i] != operator`). If the operator is not found, the loop will continue to end of array, potentially causing issues with gas consumption. Furthermore, the require statement `require(i > 0, ...)` is not correct. If the operator is at index 0, the require statement will prevent its removal, which is likely unintended."",
      ""Impact"": ""Unnecessary gas consumption. Inability to remove the first operator in the array"",
      ""Location"": ""NestedFactory.sol:removeOperator""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `_calculateFees` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_calculateFees` function calculates fees as `_amount / 100`. While this is a simple calculation, in a scenario where `_amount` is very close to zero (but still non-zero), integer division could result in a fee of zero, regardless of the actual fee percentage. Also if `_amount` is a result of a substraction, it could underflow. The fee is hardcoded as 1% in the `_calculateFees` function. This could be problematic if the owner wants to change the fee in the future. It should be a configurable parameter."",
      ""Impact"": ""Slightly reduced fee collection, potentially affecting revenue distribution. User may receive wrong output of the sale."",
      ""Location"": ""NestedFactory.sol:_calculateFees""
    },
    {
      ""Issue"": ""Potential for Griefing via `_handleUnderSpending`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_handleUnderSpending` function sends any unused tokens (amountToSpent - amountSpent) to the `feeSplitter`. While seemingly harmless, this could be used for griefing if an attacker can manipulate the `_orders` such that a very small amount is spent.  The attacker would still have to pay gas, so the severity is relatively low, and it is not exploitable for gain."",
      ""Impact"": ""Possible griefing by forcing small token transfers to the feeSplitter."",
      ""Location"": ""NestedFactory.sol:445""
    },
    {
      ""Issue"": ""Potential Loss of tokens due to rounding errors in `_handleUnderSpending`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_handleUnderSpending` function attempts to send unused input tokens to the `feeSplitter`. If the difference between the amount to spend and the amount spent is very small, rounding errors during fee calculation within the `feeSplitter` might lead to a situation where a tiny amount of tokens remains stuck in the contract."",
      ""Impact"": ""The amount lost will be small but is still a loss. Overtime with lots of calls to the function, it will accumulate."",
      ""Location"": ""Function: `_handleUnderSpending`""
    },
    {
      ""Issue"": ""Unprotected transfer of stuck tokens in `unlockTokens` function."",
      ""Severity"": ""Low"",
      ""Description"": ""The `unlockTokens` function transfers all tokens of a specific ERC20 to the owner. It is intended as a way to release tokens stuck in the contract. However, this function does not prevent accidentally transferring important or critical tokens of the protocol to the owner, potentially disrupting its functionality or governance."",
      ""Impact"": ""Accidental transfer of tokens. It is a safety risk."",
      ""Location"": ""Function: `unlockTokens`""
    },
     {
      ""Issue"": ""Unprotected `unlockTokens` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `unlockTokens` function allows the owner to transfer any ERC20 token held by the contract to the owner. While this is intended functionality, it lacks any form of protection against accidentally unlocking large amounts of tokens. A typo or mistake in the UI could cause significant financial loss."",
      ""Impact"": ""Accidental loss of ERC20 tokens held by the contract due to a user error in calling the `unlockTokens` function."",
      ""Location"": ""NestedFactory.sol:unlockTokens""
    },
        {
      ""Issue"": ""Assert usage"",
      ""Severity"": ""Low"",
      ""Description"": ""The use of assert statements `assert(amountSpent <= _inputTokenAmount - feesAmount);` in `_submitInOrders` function and `assert(amountSpent <= _inputTokenAmounts[i]);` in `_submitOutOrders` is appropriate for internal checks that should never fail under normal circumstances. However, asserts consume all remaining gas when they fail. Consider using `require` instead to allow a user to potentially recover their funds if such a condition occurs due to unexpected external factors (e.g., price fluctuations leading to order execution failure)."",
      ""Impact"": ""Transaction failure and loss of gas if an assert condition is violated due to external factors."",
      ""Location"": ""NestedFactory.sol:272, 310""
    },
    {
      ""Issue"": ""Potential precision loss during fee calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The current fee calculation `_calculateFees` uses integer division, `_amount / 100`, which can lead to significant precision loss, especially for smaller `_amount` values. Consider using a higher precision factor (e.g., dividing by 10000 for basis points) and then scaling back down, or using a more sophisticated fee calculation mechanism that minimizes precision loss. This might affect the fees earned by the feeSplitter and originalOwner."",
      ""Impact"": ""Lower fees earned due to precision loss."",
      ""Location"": ""NestedFactory.sol:528""
    },
    {
      ""Issue"": ""Use of `delete` keyword on array could lead to gaps in storage"",
      ""Severity"": ""Low"",
      ""Description"": ""The use of the `delete` keyword in `removeOperator` will leave a gap in the `operators` array. This can lead to unexpected behavior when iterating or accessing the array, and may not be the intended behavior. It would be more appropriate to shift the rest of the array to the left, or use a linked list/mapping to store the operators."",
      ""Impact"": ""Gaps in storage array might cause issues during iteration or usage of the operator list."",
      ""Location"": ""NestedFactory.sol:removeOperator""
    },
        {
      ""Issue"": ""Lack of access control on `increaseLockTimestamp` function."",
      ""Severity"": ""Low"",
      ""Description"": ""The `increaseLockTimestamp` function allows the token owner to increase the lock timestamp. There isn't a max limit on the lock timestamp."",
      ""Impact"": ""Malicious owner can lock the NFT for a long time"",
      ""Location"": ""Function: `increaseLockTimestamp`""
    },
    {
      ""Issue"": ""Unused `tokens` variable in `_submitOrder` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `tokens` variable, which is a part of the return of `OperatorHelpers.decodeDataAndRequire`, is not used within the `_submitOrder` function. Consider removing the unused variable or utilize for more robust validation."",
      ""Impact"": ""Code quality and gas optimization."",
      ""Location"": ""NestedFactory.sol:_submitOrder""
    }
  ],
  ""IssueNumber"": 62,
  ""OutputList"": 29
}",209.803488016129,4081.0,32.0,"### **Summary of Matches and Gaps**

---

#### **[H-01] Copy your own portfolio to keep earning royalties**

**Report Description**:  
In `NestedFactory.sol`, the `create()` function leads to `sendFeesWithRoyalties()` and `addShares()`. There are no checks preventing someone from copying their own portfolio and receiving royalty shares repeatedly, leading to potential abuse.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The issue describes a potential abuse of the royalty mechanism, but none of the responses in `response_list` address this specific vulnerability. The responses focus on reentrancy, unchecked external calls, and other issues but do not cover the royalty exploitation described here.

---

#### **[M-01] setReserve() can be front-run**

**Report Description**:  
The `reserve` address in `NestedFactory.sol` remains `0` until `setReserve()` is called by the owner. This can lead to incorrect token transfers or invalid comparisons (e.g., `nestedRecords.getAssetReserve(_nftId) == address(reserve)`) before `reserve` is set. The immutability of `reserve` requires caution when setting its value.

**Match in Response List**:  
Matches with the issue titled **""Missing Zero Address Check in `setReserve`""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of a zero address check in `setReserve`, which is related to the issue. However, it does not address the front-running risk or the immutability concerns highlighted in the report. The response partially covers the issue but misses critical details.

---

#### **[M-06] NestedFactory.sol#_submitInOrders() Wrong implementation cause users to be overcharged**

**Report Description**:  
In `_submitInOrders`, the actual `amountSpent + feesAmount` can be lower than `_inputTokenAmount`. The unspent amount should be returned to the user, but the current implementation takes it as part of the fee, overcharging users.

**Match in Response List**:  
Matches with the issue titled **""Potential Loss of Funds Due to Incorrect UnderSpending Handling in `_safeSubmitOrder`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with incorrect handling of underspent amounts, which aligns with the report. It explains the risk of users losing funds due to improper fee calculations, addressing the core concern.

---

#### **[M-07] Ensure on-chain that cache is synced**

**Report Description**:  
Core operations like `NestedFactory.create()` and `NestedFactory.swapTokenForTokens()` assume the cache is synced before execution. However, this assumption may not hold, leading to potential vulnerabilities.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The issue highlights a critical assumption about cache synchronization, but none of the responses in `response_list` address this concern. The responses focus on other vulnerabilities but do not cover the cache synchronization issue.

---

#### **[M-08] Passing multiple ETH deposits in orders array will use the same msg.value many times**

**Report Description**:  
In `_transferInputTokens`, a malicious user can exploit `msg.value` by performing deposit/withdraw operations to extract value. This is possible because the system uses the contract balance for user operations, assuming equivalent value was transferred.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The issue describes a potential exploit involving `msg.value` and contract balance assumptions, but none of the responses in `response_list` address this specific vulnerability. The responses focus on other issues but do not cover this exploit.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-06] NestedFactory.sol#_submitInOrders() Wrong implementation cause users to be overcharged**

**Partially Correct Matches**:

- **[M-01] setReserve() can be front-run**

**Missed Issues from Issue Report**:

- **[H-01] Copy your own portfolio to keep earning royalties**
- **[M-07] Ensure on-chain that cache is synced**
- **[M-08] Passing multiple ETH deposits in orders array will use the same msg.value many times**

---

### **Conclusion**

The `response_list` partially addresses some issues but misses critical vulnerabilities described in the `issue` report. Specifically, the royalty exploitation, cache synchronization, and `msg.value` exploitation are not covered. The responses that do match are either correct or partially correct, but significant gaps remain in addressing all reported issues.",1,1,3,29.0,"```
1. Potential Loss of Funds Due to Incorrect UnderSpending Handling in `_safeSubmitOrder`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is: `Potential Loss of Funds Due to Incorrect UnderSpending Handling in _safeSubmitOrder`.
   - This issue appears at **rank 2** in the ranked list of predictions.

2. **Calculate the precision at rank 2**:
   - Precision at rank 2 (\( P@2 \)) is calculated as the number of true positives up to rank 2 divided by the rank.
   - Since there is only one true positive up to rank 2, \( P@2 = \frac{1}{2} = 0.5 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.5 \).

**Output**:
```
0.5
```",0.5
FeeSplitter.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/external/IWETH.sol"";

/// @title Manage the fees between shareholders
/// @notice Receives fees collected by the NestedFactory, and splits the income among
/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).
contract FeeSplitter is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Emitted when a payment is released
    /// @param to The address receiving the payment
    /// @param token The token transfered
    /// @param amount The amount paid
    event PaymentReleased(address to, address token, uint256 amount);

    /// @dev Emitted when a payment is released
    /// @param from The address sending the tokens
    /// @param token The token received
    /// @param amount The amount received
    event PaymentReceived(address from, address token, uint256 amount);

    /// @dev Represent a shareholder
    /// @param account Shareholders address that can receive income
    /// @param weight Determines share allocation
    struct Shareholder {
        address account;
        uint256 weight;
    }

    /// @dev Registers shares and amount release for a specific token or ETH
    struct TokenRecords {
        uint256 totalShares;
        uint256 totalReleased;
        mapping(address => uint256) shares;
        mapping(address => uint256) released;
    }

    /// @dev Map of tokens with the tokenRecords
    mapping(address => TokenRecords) private tokenRecords;

    /// @dev All the shareholders (array)
    Shareholder[] private shareholders;

    /// @dev Royalties part weights when applicable
    uint256 public royaltiesWeight;

    uint256 public totalWeights;

    address public immutable weth;

    constructor(
        address[] memory _accounts,
        uint256[] memory _weights,
        uint256 _royaltiesWeight,
        address _weth
    ) {
        // Initial shareholders addresses and weights
        setShareholders(_accounts, _weights);
        setRoyaltiesWeight(_royaltiesWeight);
        weth = _weth;
    }

    /// @dev Receive ether after a WETH withdraw call
    receive() external payable {
        require(_msgSender() == weth, ""FeeSplitter: ETH_SENDER_NOT_WETH"");
    }

    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.
    /// @param _account Account address to check the amount due for
    /// @param _token ERC20 payment token address (or ETH_ADDR)
    /// @return The total amount due for the requested currency
    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 totalReceived = _tokenRecords.totalReleased;
        if (_tokenRecords.totalShares == 0) return 0;
        else totalReceived += _token.balanceOf(address(this));
        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /
            _tokenRecords.totalShares -
            _tokenRecords.released[_account];
        return amountDue;
    }

    /// @notice Sets the weight assigned to the royalties part for the fee
    /// @param _weight The new royalties weight
    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {
        totalWeights -= royaltiesWeight;
        royaltiesWeight = _weight;
        totalWeights += _weight;
    }

    /// @notice Sets a new list of shareholders
    /// @param _accounts Shareholders accounts list
    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them
    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {
        delete shareholders;
        require(_accounts.length > 0 && _accounts.length == _weights.length, ""FeeSplitter: ARRAY_LENGTHS_ERR"");
        totalWeights = royaltiesWeight;

        for (uint256 i = 0; i < _accounts.length; i++) {
            _addShareholder(_accounts[i], _weights[i]);
        }
    }

    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to
    /// the amount of shares they own and their previous withdrawals.
    /// @param _token Payment token address
    function releaseToken(IERC20 _token) public nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), _token);
        _token.safeTransfer(_msgSender(), amount);
        emit PaymentReleased(_msgSender(), address(_token), amount);
    }

    /// @notice Call releaseToken() for multiple tokens
    /// @param _tokens ERC20 tokens to release
    function releaseTokens(IERC20[] memory _tokens) external {
        for (uint256 i = 0; i < _tokens.length; i++) {
            releaseToken(_tokens[i]);
        }
    }

    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to
    /// the amount of shares they own and their previous withdrawals.
    function releaseETH() external nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));
        IWETH(weth).withdraw(amount);
        (bool success, ) = _msgSender().call{ value: amount }("""");
        require(success, ""FeeSplitter: ETH_TRANFER_ERROR"");
        emit PaymentReleased(_msgSender(), ETH, amount);
    }

    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.
    /// @param _token Currency for the fee as an ERC20 token
    /// @param _amount Amount of token as fee to be claimed by this contract
    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {
        uint256 weights = totalWeights - royaltiesWeight;
        _sendFees(_token, _amount, weights);
    }

    /// @notice Sends a fee to this contract for splitting, as an ERC20 token
    /// @param _royaltiesTarget The account that can claim royalties
    /// @param _token Currency for the fee as an ERC20 token
    /// @param _amount Amount of token as fee to be claimed by this contract
    function sendFeesWithRoyalties(
        address _royaltiesTarget,
        IERC20 _token,
        uint256 _amount
    ) external nonReentrant {
        require(_royaltiesTarget != address(0), ""FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS"");

        _sendFees(_token, _amount, totalWeights);
        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));
    }

    /// @notice Updates weight for a shareholder
    /// @param _accountIndex Account to change the weight of
    /// @param _weight The new weight
    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {
        require(_accountIndex + 1 <= shareholders.length, ""FeeSplitter: INVALID_ACCOUNT_INDEX"");
        uint256 _totalWeights = totalWeights;
        _totalWeights -= shareholders[_accountIndex].weight;
        shareholders[_accountIndex].weight = _weight;
        _totalWeights += _weight;
        require(_totalWeights > 0, ""FeeSplitter: TOTAL_WEIGHTS_ZERO"");
        totalWeights = _totalWeights;
    }

    /// @notice Getter for the total shares held by shareholders.
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The total shares count
    function totalShares(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalShares;
    }

    /// @notice Getter for the total amount of token already released.
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The total amount release to shareholders
    function totalReleased(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalReleased;
    }

    /// @notice Getter for the amount of shares held by an account.
    /// @param _account Account the shares belong to
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The shares owned by the account
    function shares(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].shares[_account];
    }

    /// @notice Getter for the amount of Ether already released to a shareholders.
    /// @param _account The target account for this request
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The amount already released to this account
    function released(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].released[_account];
    }

    /// @notice Finds a shareholder and return its index
    /// @param _account Account to find
    /// @return The shareholder index in the storage array
    function findShareholder(address _account) external view returns (uint256) {
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (shareholders[i].account == _account) return i;
        }
        revert(""FeeSplitter: NOT_FOUND"");
    }

    /// @dev Transfers a fee to this contract
    /// @param _token Currency for the fee
    /// @param _amount Amount of token as fee
    /// @param _totalWeights Total weights to determine the share count to allocate
    function _sendFees(
        IERC20 _token,
        uint256 _amount,
        uint256 _totalWeights
    ) private {
        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);

        for (uint256 i = 0; i < shareholders.length; i++) {
            _addShares(
                shareholders[i].account,
                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),
                address(_token)
            );
        }
        emit PaymentReceived(_msgSender(), address(_token), _amount);
    }

    /// @dev Increase the shares of a shareholder
    /// @param _account The shareholder address
    /// @param _shares The shares of the holder
    /// @param _token The updated token
    function _addShares(
        address _account,
        uint256 _shares,
        address _token
    ) private {
        TokenRecords storage _tokenRecords = tokenRecords[_token];
        _tokenRecords.shares[_account] += _shares;
        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;
    }

    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 amountToRelease = getAmountDue(_account, _token);
        require(amountToRelease != 0, ""FeeSplitter: NO_PAYMENT_DUE"");

        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;
        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;

        return amountToRelease;
    }

    function _addShareholder(address _account, uint256 _weight) private {
        require(_weight > 0, ""FeeSplitter: ZERO_WEIGHT"");
        shareholders.push(Shareholder(_account, _weight));
        totalWeights += _weight;
    }

    function _computeShareCount(
        uint256 _amount,
        uint256 _weight,
        uint256 _totalWeights
    ) private pure returns (uint256) {
        return (_amount * _weight) / _totalWeights;
    }
}",2615,277,"[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice.

Function `_sendFee()`

It is possible for duplicate shareholders to be added. These shareholders will get more than intended when _sendFee() is called.
Recommended Mitigation Steps

Ensure that the _accounts array is sorted in setShareholders().
for (uint256 i = 0; i < _accounts.length; i++) {
	if (i > 0) {
		require(_accounts[i - 1] < _accounts[i], ""FeeSplitter: ACCOUNTS_NOT_SORTED"");
	}
	_addShareholder(_accounts[i], _weights[i]);
}
  [M-04] FeeSplitter: Unbounded number of shareholders can cause DOS

Impact

There is no limit to the number of shareholders. It is therefore possible to set a large number of shareholders such that `_sendFees()` will run out of gas when adding shares to each shareholder. This will cause denial of service to all NestedFactory functions, especially the ones that will remove funds like withdraw() and destroy().",2,"pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/external/IWETH.sol"";




contract FeeSplitter is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    
    
    
    
    event PaymentReleased(address to, address token, uint256 amount);

    
    
    
    
    event PaymentReceived(address from, address token, uint256 amount);

    
    
    
    struct Shareholder {
        address account;
        uint256 weight;
    }

    
    struct TokenRecords {
        uint256 totalShares;
        uint256 totalReleased;
        mapping(address => uint256) shares;
        mapping(address => uint256) released;
    }

    
    mapping(address => TokenRecords) private tokenRecords;

    
    Shareholder[] private shareholders;

    
    uint256 public royaltiesWeight;

    uint256 public totalWeights;

    address public immutable weth;

    constructor(
        address[] memory _accounts,
        uint256[] memory _weights,
        uint256 _royaltiesWeight,
        address _weth
    ) {
        
        setShareholders(_accounts, _weights);
        setRoyaltiesWeight(_royaltiesWeight);
        weth = _weth;
    }

    
    receive() external payable {
        require(_msgSender() == weth, ""FeeSplitter: ETH_SENDER_NOT_WETH"");
    }

    
    
    
    
    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 totalReceived = _tokenRecords.totalReleased;
        if (_tokenRecords.totalShares == 0) return 0;
        else totalReceived += _token.balanceOf(address(this));
        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /
            _tokenRecords.totalShares -
            _tokenRecords.released[_account];
        return amountDue;
    }

    
    
    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {
        totalWeights -= royaltiesWeight;
        royaltiesWeight = _weight;
        totalWeights += _weight;
    }

    
    
    
    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {
        delete shareholders;
        require(_accounts.length > 0 && _accounts.length == _weights.length, ""FeeSplitter: ARRAY_LENGTHS_ERR"");
        totalWeights = royaltiesWeight;

        for (uint256 i = 0; i < _accounts.length; i++) {
            _addShareholder(_accounts[i], _weights[i]);
        }
    }

    
    
    
    function releaseToken(IERC20 _token) public nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), _token);
        _token.safeTransfer(_msgSender(), amount);
        emit PaymentReleased(_msgSender(), address(_token), amount);
    }

    
    
    function releaseTokens(IERC20[] memory _tokens) external {
        for (uint256 i = 0; i < _tokens.length; i++) {
            releaseToken(_tokens[i]);
        }
    }

    
    
    function releaseETH() external nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));
        IWETH(weth).withdraw(amount);
        (bool success, ) = _msgSender().call{ value: amount }("""");
        require(success, ""FeeSplitter: ETH_TRANFER_ERROR"");
        emit PaymentReleased(_msgSender(), ETH, amount);
    }

    
    
    
    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {
        uint256 weights = totalWeights - royaltiesWeight;
        _sendFees(_token, _amount, weights);
    }

    
    
    
    
    function sendFeesWithRoyalties(
        address _royaltiesTarget,
        IERC20 _token,
        uint256 _amount
    ) external nonReentrant {
        require(_royaltiesTarget != address(0), ""FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS"");

        _sendFees(_token, _amount, totalWeights);
        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));
    }

    
    
    
    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {
        require(_accountIndex + 1 <= shareholders.length, ""FeeSplitter: INVALID_ACCOUNT_INDEX"");
        uint256 _totalWeights = totalWeights;
        _totalWeights -= shareholders[_accountIndex].weight;
        shareholders[_accountIndex].weight = _weight;
        _totalWeights += _weight;
        require(_totalWeights > 0, ""FeeSplitter: TOTAL_WEIGHTS_ZERO"");
        totalWeights = _totalWeights;
    }

    
    
    
    function totalShares(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalShares;
    }

    
    
    
    function totalReleased(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalReleased;
    }

    
    
    
    
    function shares(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].shares[_account];
    }

    
    
    
    
    function released(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].released[_account];
    }

    
    
    
    function findShareholder(address _account) external view returns (uint256) {
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (shareholders[i].account == _account) return i;
        }
        revert(""FeeSplitter: NOT_FOUND"");
    }

    
    
    
    
    function _sendFees(
        IERC20 _token,
        uint256 _amount,
        uint256 _totalWeights
    ) private {
        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);

        for (uint256 i = 0; i < shareholders.length; i++) {
            _addShares(
                shareholders[i].account,
                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),
                address(_token)
            );
        }
        emit PaymentReceived(_msgSender(), address(_token), _amount);
    }

    
    
    
    
    function _addShares(
        address _account,
        uint256 _shares,
        address _token
    ) private {
        TokenRecords storage _tokenRecords = tokenRecords[_token];
        _tokenRecords.shares[_account] += _shares;
        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;
    }

    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 amountToRelease = getAmountDue(_account, _token);
        require(amountToRelease != 0, ""FeeSplitter: NO_PAYMENT_DUE"");

        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;
        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;

        return amountToRelease;
    }

    function _addShareholder(address _account, uint256 _weight) private {
        require(_weight > 0, ""FeeSplitter: ZERO_WEIGHT"");
        shareholders.push(Shareholder(_account, _weight));
        totalWeights += _weight;
    }

    function _computeShareCount(
        uint256 _amount,
        uint256 _weight,
        uint256 _totalWeights
    ) private pure returns (uint256) {
        return (_amount * _weight) / _totalWeights;
    }
}",1677,0,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call `setShareholders`, `setRoyaltiesWeight` and `updateShareholder` functions."",
        ""Confirm the `Ownable` contract is correctly implemented and that the initial owner is set appropriately."",
        ""Check for any unintended owner-only functionality that could be exploited.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Analyze the `releaseToken` and `releaseETH` functions, which interact with external contracts, to ensure the `nonReentrant` modifier effectively prevents reentrancy attacks."",
        ""Review the `sendFees` and `sendFeesWithRoyalties` functions to verify that the `nonReentrant` modifier protects against reentrancy during the `safeTransferFrom` calls."",
        ""Consider potential reentrancy scenarios within the WETH `withdraw` call in `releaseETH` and ensure the subsequent ETH transfer is protected.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflow/Underflow"",
      ""Tasks"": [
        ""Examine all arithmetic operations, especially in `_computeShareCount`, `_addShares`, `_releaseToken`, `setRoyaltiesWeight`, and `updateShareholder`, for potential overflow/underflow vulnerabilities. While Solidity 0.8.9 has built-in overflow protection, review for any explicit `unchecked` blocks where this protection is disabled."",
        ""Verify that `totalWeights` is correctly updated in all functions that modify shareholder weights (`setShareholders`, `setRoyaltiesWeight`, `updateShareholder`, `_addShareholder`).""
      ]
    },
    {
      ""Area"": ""Token Handling and ERC20 Compliance"",
      ""Tasks"": [
        ""Verify that the `safeTransfer` and `safeTransferFrom` functions from `SafeERC20` are used correctly throughout the contract."",
        ""Confirm that the contract handles tokens that do not conform to the ERC20 standard gracefully (e.g., tokens that don't return a boolean on `transfer` and `transferFrom`)."",
        ""Check the handling of ETH via WETH in `releaseETH` to ensure that the correct amount of WETH is withdrawn and that the ETH transfer succeeds."",
        ""Inspect `sendFees` and `sendFeesWithRoyalties` to confirm that the contract only operates on tokens for which it has been approved via `approve`.""
      ]
    },
    {
      ""Area"": ""Precision Loss and Rounding Errors"",
      ""Tasks"": [
        ""Analyze the `_computeShareCount` function for potential precision loss due to integer division. Determine if small amounts of tokens could lead to unclaimable dust accumulating in the contract."",
        ""Evaluate the impact of rounding errors on the distribution of fees, especially when dealing with a large number of shareholders or small amounts of tokens."",
        ""Consider implementing a mechanism to handle dust amounts, either by periodically distributing them or allowing the owner to claim them.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of the `setShareholders`, `_sendFees`, and `findShareholder` functions, especially considering the iteration over the `shareholders` array. Consider limiting the maximum number of shareholders to prevent excessive gas costs."",
        ""Evaluate the storage patterns to minimize gas usage, particularly in the `tokenRecords` mapping. Consider using more efficient data structures if appropriate."",
        ""Profile the contract's gas usage during typical operations (e.g., sending fees, releasing tokens) and identify areas for optimization.""
      ]
    },
    {
      ""Area"": ""Unhandled edge cases"",
      ""Tasks"": [
        ""What happens if a token's balance changes unexpectedly?"",
        ""What if `IWETH(weth).withdraw(amount)` fails, but the require check passes anyway?""
      ]
    },
    {
      ""Area"": ""Logic Errors"",
      ""Tasks"": [
        ""Verify that `getAmountDue` correctly calculates the amount due to an account, considering received fees and previous releases. Test with various scenarios, including multiple fee payments and partial withdrawals."",
        ""Ensure that `setShareholders` correctly initializes the `totalWeights` variable and that the weights of all shareholders are accounted for."",
        ""Confirm that `_sendFees` correctly distributes the fees among the shareholders based on their weights."",
        ""Analyze the logic in `sendFeesWithRoyalties` to ensure that the royalties are correctly allocated and that the `_royaltiesTarget` receives the correct share."",
        ""Verify that `updateShareholder` correctly updates the weight of a shareholder and adjusts the `totalWeights` accordingly. Check for potential issues when updating the weight of the last shareholder."",
        ""In `releaseETH`, if the low-level `.call` fails, but `IWETH(weth).withdraw(amount)` succeeded, the contract will have withdrawn the WETH but not paid the user. This should be checked, and the withdrawn WETH refunded in case of failure. Alternatively, the `IWETH(weth).withdraw(amount)` should be performed _after_ the `.call` to avoid loss of funds.""
      ]
    },
    {
      ""Area"": ""Unexpected token transfers"",
      ""Tasks"": [
          ""What happens if someone sends tokens or ETH directly to the contract address, without calling `sendFees` or `sendFeesWithRoyalties`? Will this affect the accounting of existing shareholders?""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `FeeSplitter` is designed to receive fees (primarily ERC20 tokens, but also handles ETH via WETH) and distribute them among a list of shareholders based on pre-defined weights. It includes functionality for owner-controlled configuration of shareholders and weights, handling of royalties as a separate share, and secure withdrawal mechanisms for shareholders."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""FeeSplitter"",
    ""Purpose"": ""To receive fees collected elsewhere (e.g., NestedFactory) and split the income among shareholders (NFT owners, Nested treasury, NST buybacker) based on assigned weights. It handles both ERC20 tokens and ETH (via WETH)."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Ownable"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/security/ReentrancyGuard.sol"",
        ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""./interfaces/external/IWETH.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""ETH"",
        ""Type"": ""address constant"",
        ""Purpose"": ""Placeholder address to represent native ETH.""
      },
      {
        ""Name"": ""tokenRecords"",
        ""Type"": ""mapping(address => TokenRecords)"",
        ""Purpose"": ""Maps each token address (or WETH address for ETH) to its distribution records (total shares, total released, individual shares, individual released amounts).""
      },
      {
        ""Name"": ""shareholders"",
        ""Type"": ""Shareholder[] private"",
        ""Purpose"": ""An array storing the registered shareholders, each with an address and a weight.""
      },
      {
        ""Name"": ""royaltiesWeight"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""The weight assigned specifically for royalties distribution, if applicable.""
      },
      {
        ""Name"": ""totalWeights"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""The sum of all shareholder weights plus the royalties weight.""
      },
      {
        ""Name"": ""weth"",
        ""Type"": ""address public immutable"",
        ""Purpose"": ""The address of the Wrapped Ether (WETH) contract, used for handling ETH fees.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with shareholders, weights, royalties weight, and the WETH address."",
        ""Parameters"": [
          ""address[] memory _accounts"",
          ""uint256[] memory _weights"",
          ""uint256 _royaltiesWeight"",
          ""address _weth""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Fallback function to receive Ether, specifically expected to be called only by the WETH contract during a `withdraw` operation."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""getAmountDue"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the amount of a specific token owed to a specific account, considering received fees and previous releases."",
        ""Parameters"": [
          ""address _account"",
          ""IERC20 _token""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""setRoyaltiesWeight"",
        ""Visibility"": ""public onlyOwner"",
        ""Purpose"": ""Allows the owner to update the weight allocated for royalties."",
        ""Parameters"": [
          ""uint256 _weight""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setShareholders"",
        ""Visibility"": ""public onlyOwner"",
        ""Purpose"": ""Allows the owner to replace the entire list of shareholders and their weights."",
        ""Parameters"": [
          ""address[] memory _accounts"",
          ""uint256[] memory _weights""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""releaseToken"",
        ""Visibility"": ""public nonReentrant"",
        ""Purpose"": ""Allows a shareholder (`msg.sender`) to withdraw their due amount of a specific ERC20 token."",
        ""Parameters"": [
          ""IERC20 _token""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""releaseTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Convenience function to release multiple ERC20 tokens for the caller in sequence."",
        ""Parameters"": [
          ""IERC20[] memory _tokens""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""releaseETH"",
        ""Visibility"": ""external nonReentrant"",
        ""Purpose"": ""Allows a shareholder (`msg.sender`) to withdraw their due amount of ETH (by withdrawing WETH and sending ETH)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""sendFees"",
        ""Visibility"": ""external nonReentrant"",
        ""Purpose"": ""Receives ERC20 token fees from an external source and updates shares for shareholders (excluding royalties share). Requires token approval beforehand."",
        ""Parameters"": [
          ""IERC20 _token"",
          ""uint256 _amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""sendFeesWithRoyalties"",
        ""Visibility"": ""external nonReentrant"",
        ""Purpose"": ""Receives ERC20 token fees and updates shares for shareholders, including allocating a share for a specified royalties target. Requires token approval beforehand."",
        ""Parameters"": [
          ""address _royaltiesTarget"",
          ""IERC20 _token"",
          ""uint256 _amount""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""updateShareholder"",
        ""Visibility"": ""external onlyOwner"",
        ""Purpose"": ""Allows the owner to update the weight of an existing shareholder identified by index."",
        ""Parameters"": [
          ""uint256 _accountIndex"",
          ""uint256 _weight""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""totalShares"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the total shares accumulated for a specific token."",
        ""Parameters"": [
          ""address _token""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""totalReleased"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the total amount of a specific token already released to all shareholders."",
        ""Parameters"": [
          ""address _token""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""shares"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the accumulated shares for a specific account and token."",
        ""Parameters"": [
          ""address _account"",
          ""address _token""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""released"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the amount of a specific token already released to a specific account."",
        ""Parameters"": [
          ""address _account"",
          ""address _token""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""findShareholder"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Finds the index of a shareholder address within the `shareholders` array."",
        ""Parameters"": [
          ""address _account""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""_sendFees"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic for receiving fees: transfers tokens in and iterates through shareholders to add shares."",
        ""Parameters"": [
          ""IERC20 _token"",
          ""uint256 _amount"",
          ""uint256 _totalWeights""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_addShares"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic to update the share count for a specific account and token."",
        ""Parameters"": [
          ""address _account"",
          ""uint256 _shares"",
          ""address _token""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_releaseToken"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic for releasing tokens: calculates amount due, updates released records, and returns the amount. Called by `releaseToken` and `releaseETH`."",
        ""Parameters"": [
          ""address _account"",
          ""IERC20 _token""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""_addShareholder"",
        ""Visibility"": ""private"",
        ""Purpose"": ""Internal logic to add a shareholder to the array and update total weights. Called by `setShareholders`."",
        ""Parameters"": [
          ""address _account"",
          ""uint256 _weight""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_computeShareCount"",
        ""Visibility"": ""private pure"",
        ""Purpose"": ""Calculates the number of shares to allocate based on amount, weight, and total weights."",
        ""Parameters"": [
          ""uint256 _amount"",
          ""uint256 _weight"",
          ""uint256 _totalWeights""
        ],
        ""Returns"": [
          ""uint256""
        ]
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Prevents reentrancy attacks on decorated functions."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Calls `safeTransferFrom` and `safeTransfer` on arbitrary `IERC20` token contracts."",
    ""Calls `balanceOf` on arbitrary `IERC20` token contracts."",
    ""Calls `withdraw` on the configured `IWETH` contract address."",
    ""Sends native ETH using low-level `.call{value: ...}` to shareholder addresses."",
    ""Relies on `msg.sender` for access control (`Ownable`) and identifying the payee in release functions.""
  ],
  ""SpecialMechanisms"": [
    ""**Weighted Distribution:** Fees are split based on proportional weights assigned to shareholders and potentially a separate royalty weight."",
    ""**ETH Handling via WETH:** Native ETH fees are handled by treating WETH as the underlying token for accounting purposes. `releaseETH` unwraps WETH and sends native ETH."",
    ""**Pull Payment:** Shareholders must actively call `releaseToken` or `releaseETH` to claim their due amounts."",
    ""**Owner Control:** Uses OpenZeppelin `Ownable` for managing shareholders and weights."",
    ""**Reentrancy Guard:** Uses OpenZeppelin `ReentrancyGuard` on functions involving external calls/transfers (`sendFees`, `releaseToken`, `releaseETH`) to prevent reentrancy vulnerabilities."",
    ""**SafeERC20:** Uses OpenZeppelin `SafeERC20` for safer interactions with ERC20 tokens.""
  ],
  ""Questions"": [
    ""What is the expected maximum number of shareholders? Iterations in `setShareholders`, `_sendFees`, and `findShareholder` could lead to high gas costs."",
    ""How is potential precision loss from integer division in `_computeShareCount` handled? Could small amounts lead to unclaimable dust accumulating?"",
    ""Is it intended that tokens sent directly to the contract (not via `sendFees*` functions) are included in the `getAmountDue` calculation? This seems flexible but potentially bypasses the intended share allocation logic if used incorrectly."",
    ""Is there a mechanism to handle potential failures in the `IWETH(weth).withdraw(amount)` call within `releaseETH`?"",
    ""The `setShareholders` function replaces the entire list. Is there a reason not to have functions for adding/removing individual shareholders?"",
    ""In `sendFeesWithRoyalties`, the `_royaltiesTarget` receives shares. Can this target be changed later, or do they accrue shares indefinitely for that token once set?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Risk with ETH Transfers"",
      ""Severity"": ""High"",
      ""Description"": ""The `releaseETH` function withdraws WETH and sends ETH directly to the recipient using a low-level `call`. If the recipient is a malicious contract, the `call` can trigger a reentrancy attack if the recipient's fallback/receive function calls back into the FeeSplitter contract before the state is updated. Although a `ReentrancyGuard` is implemented, it may not prevent all reentrancy scenarios."",
      ""Impact"": ""Loss of funds, ability for an attacker to drain the contract of ETH."",
      ""Location"": ""releaseETH()""
    },
    {
      ""Issue"": ""Incorrect use of IERC20 interface when dealing with ETH"",
      ""Severity"": ""High"",
      ""Description"": ""The `releaseToken` function uses `_token.safeTransfer(_msgSender(), amount);`, but the `releaseETH` function uses `IWETH(weth).withdraw(amount);(bool success, ) = _msgSender().call{ value: amount }("""");`. `_releaseToken` is aware of the WETH special case (in `releaseETH`) and uses the WETH interface to `withdraw` the WETH before sending ETH to `_msgSender()`. However, `_releaseToken` uses `IERC20 _token` which does not have the same method available for ETH, thus, potentially breaking the logic. Furthermore, the `_token` parameter can be of type ETH (address 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) which does not have a `safeTransfer` function and will cause a crash."",
      ""Impact"": ""Prevents ETH tokens from being released, and/or a potential crash that can block the whole contract."",
      ""Location"": ""`releaseToken` and `_releaseToken` functions""
    },
    {
      ""Issue"": ""Potential Reentrancy Issue with `releaseETH`"",
      ""Severity"": ""High"",
      ""Description"": ""The `releaseETH` function withdraws ETH from the WETH contract and then attempts to transfer the ETH to the recipient using a low-level `call`. The recipient address could be a contract that executes arbitrary code upon receiving ETH, potentially re-entering another part of the system. Even though `ReentrancyGuard` is used, it protects against reentrancy within the contract only, not external reentrancy."",
      ""Impact"": ""Potential for malicious contracts to drain funds or cause unexpected state changes."",
      ""Location"": ""FeeSplitter.sol:109-114""
    },
    {
      ""Issue"": ""Potential Division by Zero in `_computeShareCount` and `getAmountDue`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_computeShareCount` function calculates shares using division, and the `getAmountDue` calculates the amount due based on shares. If `_totalWeights` or `_tokenRecords.totalShares` is ever zero, this will result in a division by zero error, halting the transaction. While checks exist to prevent `_weight` from being zero in `_addShareholder`, there is no direct check to prevent `_totalWeights` from becoming zero after multiple updates and subtractions in `setRoyaltiesWeight` and `updateShareholder`.  The `getAmountDue` function checks if `_tokenRecords.totalShares == 0`. If true, it returns 0. However, if `_tokenRecords.totalShares` becomes zero *after* tokens are present in the contract balance, the calculation `(totalReceived * _tokenRecords.shares[_account]) / _tokenRecords.totalShares` will still lead to a division by zero error. "",
      ""Impact"": ""Denial of Service (DoS). Prevents fee distribution and potentially halts contract operation. Transaction reverts due to division by zero, disrupting fee distribution functionality."",
      ""Location"": ""_computeShareCount(), setRoyaltiesWeight(), updateShareholder(), FeeSplitter.sol:68""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Weight Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract performs arithmetic operations on weights (e.g., `totalWeights -= royaltiesWeight;`, `_totalWeights -= shareholders[_accountIndex].weight;`). While Solidity 0.8.0+ has built-in overflow/underflow protection, incorrect logic or extremely large/small weights could lead to unexpected behavior if `totalWeights` or `_totalWeights` approach the boundaries of the `uint256` type. This can occur in `setRoyaltiesWeight`, `setShareholders`, and `updateShareholder`."",
      ""Impact"": ""Incorrect weight calculations could lead to disproportionate distribution of fees, potentially depriving shareholders of their rightful share or allowing others to receive an excessive amount. Unexpected behavior, DoS, incorrect share distribution."",
      ""Location"": ""setRoyaltiesWeight(), updateShareholder(), setShareholders()""
    },
    {
      ""Issue"": ""Potential Denial of Service (DoS) in `setShareholders` Function due to large array"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setShareholders` function iterates through `_accounts` and `_weights` arrays. If these arrays are excessively large, the function could consume a significant amount of gas, potentially exceeding the block gas limit. This would prevent the owner from updating the shareholders, leading to a denial-of-service condition."",
      ""Impact"": ""Inability to update shareholders, potentially disrupting fee distribution. Denial of Service (DoS) prevents owner from updating shareholders."",
      ""Location"": ""`setShareholders` function""
    },
    {
      ""Issue"": ""Vulnerability to Griefing Attack in `releaseETH`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `releaseETH` function, the contract withdraws WETH and then attempts to send ETH to the shareholder using a raw call. If the shareholder is a contract that reverts on receiving ETH (or has a payable function that consumes too much gas), the `releaseETH` function will fail, reverting the WETH withdrawal. This can lead to a griefing attack, where an attacker can repeatedly call `releaseETH` for such accounts, preventing other shareholders from withdrawing their ETH."",
      ""Impact"": ""Denial of service by preventing shareholders from withdrawing their ETH."",
      ""Location"": ""`releaseETH` function""
    },
    {
      ""Issue"": ""Potential Reentrancy Issues if Shareholder is a Malicious Contract"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `releaseToken` and `releaseETH` functions use `safeTransfer` or `call` to send tokens or ETH to shareholders. If a shareholder is a malicious contract, it could potentially trigger a reentrancy attack in the `PaymentReleased` event emission, allowing it to manipulate the contract\'s state before the function completes. Although the contract uses `ReentrancyGuard`, this guard only protects against reentrancy during the `releaseToken` and `releaseETH` functions themselves and won't prevent reentrancy via callbacks."",
      ""Impact"": ""Potential for attackers to manipulate the contract\'s state and steal funds."",
      ""Location"": ""`releaseToken` and `releaseETH` functions""
    },
    {
      ""Issue"": ""Lack of Access Control for `sendFees` and `sendFeesWithRoyalties`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `sendFees` and `sendFeesWithRoyalties` are marked as `external` and `nonReentrant`, but they lack access control. Any address can call these functions, transferring tokens to the `FeeSplitter` contract. While the contract logic correctly distributes fees based on shareholder weights, an attacker could potentially front-run legitimate fee payments, influencing the distribution outcome. Furthermore, nothing prevents a malicious actor from sending tokens to this contract that were not intended to be split, which could cause unexpected share distribution."",
      ""Impact"": ""Potential manipulation of fee distribution and unintended share allocations. Possible griefing attack."",
      ""Location"": ""FeeSplitter.sol:127, FeeSplitter.sol:139""
    },
    {
      ""Issue"": ""Lack of Input Validation on Constructor Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor takes arrays of `_accounts` and `_weights`. While the `setShareholders` function checks for equal array lengths, the constructor does not validate that `_accounts` contains unique addresses. Duplicate entries in `_accounts` could lead to unintended share distributions. The constructor also does not prevent zero addresses from being passed in `_accounts`."",
      ""Impact"": ""Incorrect distribution of fees, potential for unexpected behavior and possibly draining of funds if an attacker can control the input to the constructor."",
      ""Location"": ""FeeSplitter.sol:50""
    },
    {
      ""Issue"": ""Lack of Input Validation for Token Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract receives token addresses as parameters in functions like `releaseToken`, `releaseTokens`, `sendFees`, and `sendFeesWithRoyalties`. There\'s no explicit check to ensure that these addresses are actually valid ERC20 contract addresses. Passing an arbitrary address or the zero address could lead to unexpected behavior or failures when `safeTransferFrom` or `safeTransfer` are called."",
      ""Impact"": ""Contract malfunctions, potential loss of funds due to incorrect token transfers, denial-of-service if an invalid address causes a revert."",
      ""Location"": ""releaseToken(), releaseTokens(), sendFees(), sendFeesWithRoyalties()""
    },
    {
      ""Issue"": ""Inconsistent ETH Handling and Potential WETH Confusion"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses both ETH (constant address) and WETH for handling ETH payments. The `releaseETH` function withdraws from WETH and then sends ETH directly to the recipient using `call{value: amount}("""")`. The `receive()` function only accepts ETH from the WETH contract. This can lead to confusion, as users might expect to send ETH directly to the contract, which will be rejected."",
      ""Impact"": ""User confusion and potential loss of funds if users try to send ETH directly to the contract. Inconsistent ETH and WETH handling."",
      ""Location"": ""FeeSplitter.sol:54, FeeSplitter.sol:119, FeeSplitter.sol:49""
    },
    {
      ""Issue"": ""Potential Reentrancy with WETH withdraw"",
      ""Severity"": ""Medium"",
      ""Description"": ""Although the contract uses `ReentrancyGuard`, the `releaseETH` function interacts with the `IWETH` contract. If the `IWETH.withdraw` call triggers a callback to the `FeeSplitter`, the reentrancy guard will prevent further modifications of the state within FeeSplitter. However, it doesn't prevent malicious code within the callback from manipulating the ETH balance of the FeeSplitter before or after `IWETH.withdraw`, which could cause issues with the subsequent `_msgSender().call{value: amount}`."",
      ""Impact"": ""Possible manipulation of ETH balance or incorrect accounting."",
      ""Location"": ""`releaseETH` function""
    },
    {
      ""Issue"": ""Potential for Griefing with Royalties"",
      ""Severity"": ""Low"",
      ""Description"": ""The `sendFeesWithRoyalties` function allows anyone to specify a `_royaltiesTarget`. A malicious actor could grief the intended recipient by repeatedly calling this function with small `_amount` values to artificially inflate their `shares`, making it more expensive to release the royalties (gas costs)."",
      ""Impact"": ""Increased gas costs for the royalties target to claim their fees."",
      ""Location"": ""FeeSplitter.sol:130""
    },
    {
      ""Issue"": ""Rounding Errors in Share Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_computeShareCount` function performs integer division, which truncates the decimal part. Over time, these small rounding errors can accumulate and lead to a slight discrepancy between the intended share allocation and the actual distribution."",
      ""Impact"": ""Minor inaccuracies in share distribution, potentially causing unfairness among shareholders. The impact increases as the number of transactions increases."",
      ""Location"": ""`_computeShareCount` function""
    },
    {
      ""Issue"": ""Lack of Input Validation for Zero Addresses in `setShareholders`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setShareholders` function does not explicitly check for zero addresses in the `_accounts` array. While transferring tokens to the zero address will result in a burnt token, it's generally good practice to prevent zero addresses from being added as shareholders to avoid unintended behavior or errors later on. No checks are performed to see if any two addresses are same (duplicate shareholders)."",
      ""Impact"": ""Potential for tokens to be unintentionally burned, leading to confusion or financial loss, and logic errors from duplicate shareholders."",
      ""Location"": ""`setShareholders` function""
    },
    {
      ""Issue"": ""Missing Zero Address Check in setShareholders"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setShareholders` function sets the shareholder accounts and weights. However, there isn't a check to ensure that the `_accounts` array doesn't contain the zero address. Setting a shareholder address to the zero address could lead to issues in `getAmountDue`, `releaseToken`, and other functions that rely on shareholder addresses. Also, there is no check to ensure that accounts are not the zero address in `_addShareholder` function."",
      ""Impact"": ""Unexpected behavior when calculating and distributing payments, potential for funds to be locked or misallocated."",
      ""Location"": ""setShareholders()""
    },
    {
      ""Issue"": ""Inconsistent Token Balance Check in `getAmountDue`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getAmountDue` function checks the token balance only when `_tokenRecords.totalShares` is not zero. There is no clear reason for this conditional. A more consistent design would always check the current token balance of the contract and include it in the calculation."",
      ""Impact"": ""Potential for inaccurate `amountDue` calculations if there are edge cases where tokens are sent to the contract before shares are allocated."",
      ""Location"": ""`getAmountDue` function""
    },
    {
      ""Issue"": ""Missing Input Validation for `_accountIndex` in `updateShareholder`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updateShareholder` function checks `_accountIndex + 1 <= shareholders.length`. However, `_accountIndex` can still be equal to `shareholders.length` - 1, which results in accessing the last valid element. An integer overflow will occur if `_accountIndex` is set to `type(uint256).max` because the `_accountIndex + 1` results in an overflow."",
      ""Impact"": ""Incorrect `amountDue` calculation for a token."",
      ""Location"": ""`updateShareholder` function""
    },
    {
      ""Issue"": ""Lack of Access Control on `receive()`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `receive()` function only verifies that the sender is the `weth` address. It doesn't check the amount of ETH received or any other contextual information. If the WETH contract has a bug or is compromised, it could potentially send ETH to the FeeSplitter without a corresponding `sendFees` transaction, leading to an imbalance between recorded shares and actual ETH balance."",
      ""Impact"": ""Imbalance between recorded shares and actual ETH balance if WETH contract is compromised or has a bug."",
      ""Location"": ""`receive()` function""
    },
    {
      ""Issue"": ""Incorrect Calculation of `totalReceived` in `getAmountDue` leading to inconsistent results"",
      ""Severity"": ""Low"",
      ""Description"": ""In `getAmountDue`, `totalReceived` is calculated as `_tokenRecords.totalReleased`. It adds the current contract balance with this value `else totalReceived += _token.balanceOf(address(this));`. The current contract balance should have been added to `_tokenRecords.totalReleased` when tokens are received in `sendFees` and `sendFeesWithRoyalties` functions. It looks like `_tokenRecords.totalReleased` stores just released amount not received."",
      ""Impact"": ""Shareholders may receive incorrect payments."",
      ""Location"": ""FeeSplitter.sol:58-60""
    },
    {
      ""Issue"": ""Missing Check for Zero Address in `setShareholders`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setShareholders` function sets a new list of shareholders. It iterates through `_accounts` and adds them as shareholders. However, there\'s no check to ensure that the provided addresses are not the zero address. Adding the zero address as a shareholder could lead to unexpected behavior when distributing fees, as tokens sent to the zero address are effectively burned."",
      ""Impact"": ""Potential loss of funds if zero address is added as a shareholder."",
      ""Location"": ""FeeSplitter.sol:80-86""
    },
    {
      ""Issue"": ""Lack of Input Validation in `updateShareholder`"",
      ""Severity"": ""Low"",
      ""Description"": ""In `updateShareholder`, the new weight `_weight` is assigned to a shareholder after retrieving it using `_accountIndex`. There\'s no check to validate that `_weight` is within a reasonable range. A very large weight could disproportionately allocate fees to a single shareholder, potentially starving other shareholders. Also there is no check to ensure that the provided `_accountIndex` is within the bounds of `shareholders.length`, even though `_accountIndex + 1 <= shareholders.length` check exists."",
      ""Impact"": ""Unfair fee distribution, potential denial of service for other shareholders."",
      ""Location"": ""FeeSplitter.sol:135-141""
    },
    {
      ""Issue"": ""Incorrect Error Message in `receive` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `receive` function enforces that the sender must be the WETH contract. However, the error message `FeeSplitter: ETH_SENDER_NOT_WETH` is misleading because it\'s not related to the fact that it\'s ETH that is being sent, but the sender\'s address."",
      ""Impact"": ""Minor inconvenience for debugging."",
      ""Location"": ""FeeSplitter.sol:52""
    },
    {
      ""Issue"": ""Missing Zero-Address Check for Royalty Target in `sendFeesWithRoyalties`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `sendFeesWithRoyalties` checks that the royalties target is not the zero address. However, it does not check whether any shareholder is the royalties target. The royalty target could be another shareholder. This can lead to unexpected behavior."",
      ""Impact"": ""Minor inconvenience for debugging."",
      ""Location"": ""FeeSplitter.sol:121-122""
    },
    {
      ""Issue"": ""Potential Front Running Vulnerability in `updateShareholder`"",
      ""Severity"": ""Low"",
      ""Description"": ""An attacker could monitor the mempool for `updateShareholder` transactions and front-run them to manipulate shareholder weights before a legitimate transaction."",
      ""Impact"": ""The attacker can unfairly claim a larger portion of the fees before the update is processed."",
      ""Location"": ""FeeSplitter.sol:167""
    },
    {
      ""Issue"": ""WETH dependency might affect token compatibility."",
      ""Severity"": ""Low"",
      ""Description"": ""The contract makes assumptions about the WETH token, specifically within the `releaseETH` and the `receive` functions. If the deployed WETH contract\'s interface differs even slightly from `IWETH`, the `releaseETH` function could fail and the `receive` function may be incorrectly triggered. The `receive` function assumes that only the WETH contract will send eth to it, and any other calls will be rejected."",
      ""Impact"": ""Possible incompatibility with different WETH implementations. Inability to receive ETH from sources other than the intended WETH contract, potentially leading to lost funds if ETH is mistakenly sent directly to the contract."",
      ""Location"": ""FeeSplitter.sol:47, 119""
    },
    {
      ""Issue"": ""Unbounded Loop in `releaseTokens` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `releaseTokens` function iterates through an array of `IERC20` tokens and calls `releaseToken` for each token. If the array is very large, this could potentially lead to a gas limit issue."",
      ""Impact"": ""The `releaseTokens` function might revert if the `_tokens` array is too large, preventing shareholders from claiming their tokens."",
      ""Location"": ""FeeSplitter.sol:112""
    },
    {
      ""Issue"": ""Possible rounding error in `_computeShareCount` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_computeShareCount` function uses integer division, which truncates the decimal portion of the result. This could lead to a slight underestimation of the share count, especially when dealing with small amounts or large total weights."",
      ""Impact"": ""Slightly inaccurate share allocation due to truncation. Minimal unclaimed tokens."",
      ""Location"": ""FeeSplitter.sol:209""
    },
    {
      ""Issue"": ""Unbounded Loop Risk in `findShareholder` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `findShareholder` function iterates through the `shareholders` array to find a specific account. If the account is not found, the loop completes, and the function reverts. However, If the `shareholders` array is very large, this loop could consume a significant amount of gas."",
      ""Impact"": ""Potential denial of service due to high gas consumption."",
      ""Location"": ""FeeSplitter.sol:177""
    },
    {
      ""Issue"": ""Potential for Division by Zero in `_computeShareCount`"",
      ""Severity"": ""Low"",
      ""Description"": ""While the code includes `require(_totalWeights > 0, \""FeeSplitter: TOTAL_WEIGHTS_ZERO\"");` in `updateShareholder`, there is no such check directly before `_computeShareCount` is called in `_sendFees`. In the unlikely edge case that `_totalWeights` somehow becomes zero *after* the check in `updateShareholder` but *before* `_sendFees` is called, the division in `_computeShareCount` will revert the transaction."",
      ""Impact"": ""Transaction reverts, denial of service."",
      ""Location"": ""_computeShareCount(), _sendFees()""
    },
    {
      ""Issue"": ""Possible Integer Overflow/Underflow in Weight Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""While using Solidity 0.8.9 protects against underflow and overflow by default, large `royaltiesWeight` or `_weights` values in `setRoyaltiesWeight`, `setShareholders`, or `updateShareholder` could still potentially lead to unexpected behavior if `totalWeights` approaches the maximum uint256 value."",
      ""Impact"": ""Incorrect distribution of fees due to inaccurate weight calculations."",
      ""Location"": ""FeeSplitter.sol:82, 93, 170""
    },
    {
      ""Issue"": ""Unnecessary IERC20 Casting"",
      ""Severity"": ""Information"",
      ""Description"": ""In `_sendFees`, the code casts `_token` (which is already declared as `IERC20`) to `IERC20` again: `IERC20(_token).safeTransferFrom(...)`. This casting is redundant and can be removed for code clarity."",
      ""Impact"": ""None, code could be cleaner."",
      ""Location"": ""_sendFees()""
    }
  ],
  ""IssueNumber"": 50,
  ""OutputList"": 30
}",215.516788005829,3666.0,35.0,"### **[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice**

**Report Description**:  
The `_sendFee()` function in the `FeeSplitter` contract does not include a sanity check to prevent duplicate shareholders from being added. This oversight allows the same shareholder to be added multiple times, leading to unintended overpayments when `_sendFee()` is called. The recommended mitigation is to ensure the `_accounts` array is sorted and to add a check to prevent duplicates.

**Match in Response List**:  
Matches with the issue titled **""Lack of Input Validation for Zero Addresses in `setShareholders`""** and **""Missing Zero Address Check in setShareholders""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of input validation in the `setShareholders` function, including the absence of checks for zero addresses and duplicate shareholders. However, it does not explicitly mention the risk of overpayments due to duplicate shareholders, which is the core issue in the report. The response partially addresses the issue but misses critical details about the impact on fee distribution.

---

### **[M-04] FeeSplitter: Unbounded number of shareholders can cause DOS**

**Report Description**:  
The `FeeSplitter` contract does not limit the number of shareholders, allowing an attacker to set a large number of shareholders. This could cause the `_sendFees()` function to run out of gas, leading to a denial of service (DOS) for all `NestedFactory` functions, particularly those that remove funds like `withdraw()` and `destroy()`.

**Match in Response List**:  
Matches with the issue titled **""Potential Denial of Service (DoS) in `setShareholders` Function due to large array""**.

**Validation**:  
**Correct**. The response accurately identifies the risk of a DOS attack due to an unbounded number of shareholders in the `setShareholders` function. It correctly explains the impact of high gas consumption and the potential for disrupting fee distribution, which aligns with the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-04] FeeSplitter: Unbounded number of shareholders can cause DOS**

**Partially Correct Matches**:

- **[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice**

**Missed Issues from Issue Report**:

- *None*

---

### **Overall Analysis**

The `response_list` covers most of the issues in the `issue` report, but there are some gaps in the details provided. Specifically, the response for **[M-02]** partially addresses the issue but misses the critical impact of duplicate shareholders on fee distribution. The response for **[M-04]** is accurate and complete. Overall, the `response_list` demonstrates a good understanding of the vulnerabilities but could benefit from more detailed explanations of the impacts in some cases.",0,0,2,,"```
None.
```",0.0,
