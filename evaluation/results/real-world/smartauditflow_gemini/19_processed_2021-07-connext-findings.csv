nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,Comparison,matchList,MAP
TransactionManager.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.4;

import ""./interfaces/IFulfillHelper.sol"";
import ""./interfaces/ITransactionManager.sol"";
import ""./lib/LibAsset.sol"";
import ""./lib/LibERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";

// Outstanding qs:
// - what happens if you have unique user data, but duplicate tx ids?
//   no requires here would catch this, the tx would be properly prepared
//
// - we validate all the inputs but the amount, bidSignature, and encodedBid.
//   bidSignature and encodedBid could be used as slashing later, and their
//   validation is out of scope of this function. But, do we want to be able
//   to use this to send 0-value amounts? basically as some incentivized
//   relayer? would that break bidding?


/// @title TransactionManager
/// @author Connext <support@connext.network>
/// @notice This contract holds the logic to facilitate crosschain transactions.
///         Transactions go through three phases:
///
///         1. Route Auction: User broadcasts to our network signalling their 
///         desired route. Routers respond with sealed bids containing 
///         commitments to fulfilling the transaction within a certain time and 
///         price range.
///
///         2. Prepare: Once the auction is completed, the transaction can be 
///         prepared. The user submits a transaction to `TransactionManager` 
///         contract on sender-side chain containing router's signed bid. This 
///         transaction locks up the users funds on the sending chiain. Upon 
///         detecting an event containing their signed bid from the chain, 
///         router submits the same transaction to `TransactionManager` on the 
///         receiver-side chain, and locks up a corresponding amount of 
///         liquidity. The amount locked on the receiving chain is `sending 
///         amount - auction fee` so the router is incentivized to complete the 
///         transaction.
///
///         3. Fulfill: Upon detecting the `TransactionPrepared` event on the 
///         receiver-side chain, the user signs a message and sends it to a 
///         relayer, who will earn a fee for submission. The relayer (which may 
///         be the router) then submits the message to the `TransactionManager` 
///         to complete their transaction on receiver-side chain and claim the 
///         funds locked by the router. A relayer is used here to allow users 
///         to submit transactions with arbitrary calldata on the receiving 
///         chain without needing gas to do so. The router then submits the 
///         same signed message and completes transaction on sender-side, 
///         unlocking the original `amount`.
///
///         If a transaction is not fulfilled within a fixed timeout, it 
///         reverts and can be reclaimed by the party that called `prepare` on 
///         each chain (initiator). Additionally, transactions can be cancelled 
///         unilaterally by the person owed funds on that chain (router for 
///         sending chain, user for receiving chain) prior to expiry.

contract TransactionManager is ReentrancyGuard, ITransactionManager {
  /// @dev Mapping of router to balance specific to asset
  mapping(address => mapping(address => uint256)) public routerBalances;

  /// @dev Mapping of user address to blocks where active transfers
  ///      were created.
  mapping(address => uint256[]) public activeTransactionBlocks;

  /// @dev Mapping of hash of `InvariantTransactionData` to the hash
  //       of the `VariantTransactionData`
  mapping(bytes32 => bytes32) public variantTransactionData;

  /// @dev The chain id of the contract, is passed in to avoid any evm issues
  uint256 public immutable chainId;

  /// @dev Minimum timeout (will be the lowest on the receiving chain)
  uint256 public constant MIN_TIMEOUT = 24 hours;

  constructor(uint256 _chainId) {
    chainId = _chainId;
  }

  /// @notice This is used by any router to increase their available
  ///         liquidity for a given asset.
  /// @param amount The amount of liquidity to add for the router
  /// @param assetId The address (or `address(0)` if native asset) of the
  ///                asset you're adding liquidity for
  /// @param router The router you are adding liquidity on behalf of
  function addLiquidity(uint256 amount, address assetId, address router) external payable override nonReentrant {
    // Sanity check: nonzero amounts
    require(amount > 0, ""addLiquidity: AMOUNT_IS_ZERO"");

    // Validate correct amounts are transferred
    if (LibAsset.isEther(assetId)) {
      require(msg.value == amount, ""addLiquidity: VALUE_MISMATCH"");
    } else {
      require(msg.value == 0, ""addLiquidity: ETH_WITH_ERC_TRANSFER"");
      require(LibERC20.transferFrom(assetId, router, address(this), amount), ""addLiquidity: ERC20_TRANSFER_FAILED"");
    }

    // Update the router balances
    routerBalances[router][assetId] += amount;

    // Emit event
    emit LiquidityAdded(router, assetId, amount, msg.sender);
  }

  /// @notice This is used by any router to decrease their available
  ///         liquidity for a given asset.
  /// @param amount The amount of liquidity to remove for the router
  /// @param assetId The address (or `address(0)` if native asset) of the
  ///                asset you're removing liquidity for
  /// @param recipient The address that will receive the liquidity being removed
  function removeLiquidity(
    uint256 amount,
    address assetId,
    address payable recipient
  ) external override nonReentrant {
    // Sanity check: nonzero amounts
    require(amount > 0, ""removeLiquidity: AMOUNT_IS_ZERO"");

    // Sanity check: amount can be deducted for the router
    require(routerBalances[msg.sender][assetId] >= amount, ""removeLiquidity: INSUFFICIENT_FUNDS"");

    // Update router balances
    routerBalances[msg.sender][assetId] -= amount;

    // Transfer from contract to specified recipient
    require(LibAsset.transferAsset(assetId, recipient, amount), ""removeLiquidity: TRANSFER_FAILED"");

    // Emit event
    emit LiquidityRemoved(msg.sender, assetId, amount, recipient);
  }

  /// @notice This function creates a crosschain transaction. When called on
  ///         the sending chain, the user is expected to lock up funds. When
  ///         called on the receiving chain, the router deducts the transfer
  ///         amount from the available liquidity. The majority of the
  ///         information about a given transfer does not change between chains,
  ///         with three notable exceptions: `amount`, `expiry`, and 
  ///         `preparedBlock`. The `amount` and `expiry` are decremented
  ///         between sending and receiving chains to provide an incentive for 
  ///         the router to complete the transaction and time for the router to
  ///         fulfill the transaction on the sending chain after the unlocking
  ///         signature is revealed, respectively.
  /// @param invariantData The data for a crosschain transaction that will
  ///                      not change between sending and receiving chains.
  ///                      The hash of this data is used as the key to store 
  ///                      the inforamtion that does change between chains 
  ///                      (amount, expiry,preparedBlock) for verification
  /// @param amount The amount of the transaction on this chain
  /// @param expiry The block.timestamp when the transaction will no longer be
  ///               fulfillable and is freely cancellable on this chain
  /// @param encryptedCallData The calldata to be executed when the tx is
  ///                          fulfilled. Used in the function to allow the user
  ///                          to reconstruct the tx from events. Hash is stored
  ///                          onchain to prevent shenanigans.
  /// @param encodedBid The encoded bid that was accepted by the user for this
  ///                   crosschain transfer. It is supplied as a param to the
  ///                   function but is only used in event emission
  /// @param bidSignature The signature of the bidder on the encoded bid for
  ///                     this transaction. Only used within the function for
  ///                     event emission. The validity of the bid and
  ///                     bidSignature are enforced offchain
  function prepare(
    InvariantTransactionData calldata invariantData,
    uint256 amount,
    uint256 expiry,
    bytes calldata encryptedCallData,
    bytes calldata encodedBid,
    bytes calldata bidSignature
  ) external payable override nonReentrant returns (TransactionData memory) {
    // Sanity check: user is sensible
    require(invariantData.user != address(0), ""prepare: USER_EMPTY"");

    // Sanity check: router is sensible
    require(invariantData.router != address(0), ""prepare: ROUTER_EMPTY"");

    // Sanity check: valid fallback
    require(invariantData.receivingAddress != address(0), ""prepare: RECEIVING_ADDRESS_EMPTY"");

    // Make sure the chains are different
    require(invariantData.sendingChainId != invariantData.receivingChainId, ""prepare: SAME_CHAINIDS"");

    // Make sure the chains are relevant
    require(invariantData.sendingChainId == chainId || invariantData.receivingChainId == chainId, ""prepare: INVALID_CHAINIDS"");

    // Make sure the expiry is greater than min
    require((expiry - block.timestamp) >= MIN_TIMEOUT, ""prepare: TIMEOUT_TOO_LOW"");

    // Make sure the hash is not a duplicate
    bytes32 digest = keccak256(abi.encode(invariantData));
    require(variantTransactionData[digest] == bytes32(0), ""prepare: DIGEST_EXISTS"");

    // NOTE: the `encodedBid` and `bidSignature` are simply passed through
    //       to the contract emitted event to ensure the availability of
    //       this information. Their validity is asserted offchain, and
    //       is out of scope of this contract. They are used as inputs so
    //       in the event of a router or user crash, they may recover the
    //       correct bid information without requiring an offchain store.

    // Store the transaction variants
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: amount,
      expiry: expiry,
      preparedBlockNumber: block.number
    })));

    // Store active blocks
    activeTransactionBlocks[invariantData.user].push(block.number);

    // First determine if this is sender side or receiver side
    if (invariantData.sendingChainId == chainId) {
      // Sanity check: amount is sensible
      // Only check on sending chain to enforce router fees. Transactions could
      // be 0-valued on receiving chain if it is just a value-less call to some
      // `IFulfillHelper`
      require(amount > 0, ""prepare: AMOUNT_IS_ZERO"");

      // This is sender side prepare. The user is beginning the process of 
      // submitting an onchain tx after accepting some bid. They should
      // lock their funds in the contract for the router to claim after
      // they have revealed their signature on the receiving chain via
      // submitting a corresponding `fulfill` tx

      // Validate correct amounts on msg and transfer from user to
      // contract
      if (LibAsset.isEther(invariantData.sendingAssetId)) {
        require(msg.value == amount, ""prepare: VALUE_MISMATCH"");
      } else {
        require(msg.value == 0, ""prepare: ETH_WITH_ERC_TRANSFER"");
        require(
          LibERC20.transferFrom(invariantData.sendingAssetId, msg.sender, address(this), amount),
          ""prepare: ERC20_TRANSFER_FAILED""
        );
      }
    } else {
      // This is receiver side prepare. The router has proposed a bid on the
      // transfer which the user has accepted. They can now lock up their
      // own liquidity on th receiving chain, which the user can unlock by
      // calling `fulfill`. When creating the `amount` and `expiry` on the
      // receiving chain, the router should have decremented both. The
      // expiry should be decremented to ensure the router has time to
      // complete the sender-side transaction after the user completes the
      // receiver-side transactoin. The amount should be decremented to act as
      // a fee to incentivize the router to complete the transaction properly.

      // Check that the caller is the router
      require(msg.sender == invariantData.router, ""prepare: ROUTER_MISMATCH"");

      // Check that the router isnt accidentally locking funds in the contract
      require(msg.value == 0, ""prepare: ETH_WITH_ROUTER_PREPARE"");

      // Check that router has liquidity
      require(
        routerBalances[invariantData.router][invariantData.receivingAssetId] >= amount,
        ""prepare: INSUFFICIENT_LIQUIDITY""
      );

      // Decrement the router liquidity
      routerBalances[invariantData.router][invariantData.receivingAssetId] -= amount;
    }

    // Emit event
    TransactionData memory txData = TransactionData({
      user: invariantData.user,
      router: invariantData.router,
      sendingAssetId: invariantData.sendingAssetId,
      receivingAssetId: invariantData.receivingAssetId,
      sendingChainFallback: invariantData.sendingChainFallback,
      callTo: invariantData.callTo,
      receivingAddress: invariantData.receivingAddress,
      callDataHash: invariantData.callDataHash,
      transactionId: invariantData.transactionId,
      sendingChainId: invariantData.sendingChainId,
      receivingChainId: invariantData.receivingChainId,
      amount: amount,
      expiry: expiry,
      preparedBlockNumber: block.number
    });
    emit TransactionPrepared(txData.user, txData.router, txData.transactionId, txData, msg.sender, encryptedCallData, encodedBid, bidSignature);
    return txData;
  }



  /// @notice This function completes a crosschain transaction. When called on
  ///         the receiving chain, the user reveals their signature on the
  ///         invariant parts of the transaction data and is sent the 
  ///         appropriate amount. The router then uses this signature to
  ///         unlock the corresponding funds on the receiving chain, which are
  ///         then added back to their available liquidity. The user includes a
  ///         relayer fee since it is not assumed they will have gas on the
  ///         receiving chain. This function *must* be called before the
  ///         transaction expiry has elapsed.
  /// @param txData All of the data (invariant and variant) for a crosschain
  ///               transaction. The variant data provided is checked against
  ///               what was stored when the `prepare` function was called.
  /// @param relayerFee The fee that should go to the relayer when they are
  ///                   calling the function on the receiving chain for the user
  /// @param signature The users signature on the invariant data + fee that
  ///                  can be used by the router to unlock the transaction on 
  ///                  the sending chain
  function fulfill(
    TransactionData calldata txData,
    uint256 relayerFee,
    bytes calldata signature, // signature on fee + digest
    bytes calldata callData
  ) external override nonReentrant returns (TransactionData memory) {
    // Get the hash of the invariant tx data. This hash is the same
    // between sending and receiving chains. The variant data is stored
    // in the contract when `prepare` is called within the mapping.
    bytes32 digest = hashInvariantTransactionData(txData);

    // Make sure that the variant data matches what was stored
    require(variantTransactionData[digest] == hashVariantTransactionData(txData), ""fulfill: INVALID_VARIANT_DATA"");

    // Make sure the expiry has not elapsed
    require(txData.expiry > block.timestamp, ""fulfill: EXPIRED"");

    // Make sure the transaction wasn't already completed
    require(txData.preparedBlockNumber > 0, ""fulfill: ALREADY_COMPLETED"");

    // Validate the user has signed
    require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, ""fulfill: INVALID_SIGNATURE"");

    // Sanity check: fee <= amount. Allow `=` in case of only wanting to execute
    // 0-value crosschain tx, so only providing the fee amount
    require(relayerFee <= txData.amount, ""fulfill: INVALID_RELAYER_FEE"");

    // Check provided callData matches stored hash
    require(keccak256(callData) == txData.callDataHash, ""fulfill: INVALID_CALL_DATA"");

    // To prevent `fulfill` / `cancel` from being called multiple times, the
    // preparedBlockNumber is set to 0 before being hashed. The value of the
    // mapping is explicitly *not* zeroed out so users who come online without
    // a store can tell the difference between a transaction that has not been
    // prepared, and a transaction that was already completed on the receiver
    // chain.
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: 0
    })));

    // Remove the transaction prepared block from the active blocks
    removeUserActiveBlocks(txData.user, txData.preparedBlockNumber);

    if (txData.sendingChainId == chainId) {
      // The router is completing the transaction, they should get the
      // amount that the user deposited credited to their liquidity
      // reserves.

      // Make sure that the user is not accidentally fulfilling the transaction
      // on the sending chain
      require(msg.sender == txData.router, ""fulfill: ROUTER_MISMATCH"");

      // Complete tx to router for original sending amount
      routerBalances[txData.router][txData.sendingAssetId] += txData.amount;
    } else {
      // The user is completing the transaction, they should get the
      // amount that the router deposited less fees for relayer.

      // Get the amount to send
      uint256 toSend = txData.amount - relayerFee;

      // Send the relayer the fee
      if (relayerFee > 0) {
        require(
          LibAsset.transferAsset(txData.receivingAssetId, payable(msg.sender), relayerFee),
          ""fulfill: FEE_TRANSFER_FAILED""
        );
      }

      // Handle receiver chain external calls if needed
      if (txData.callTo == address(0)) {
        // No external calls, send directly to receiving address
        require(
          LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
          ""fulfill: TRANSFER_FAILED""
        );
      } else {
        // Handle external calls with a fallback to the receiving
        // address in case the call fails so the funds dont remain
        // locked.

        // First, approve the funds to the helper if needed
        if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {
          require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), ""fulfill: APPROVAL_FAILED"");
        }

        // Next, call `addFunds` on the helper. Helpers should internally
        // track funds to make sure no one user is able to take all funds
        // for tx
        if (toSend > 0) {
          try
            IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(
              txData.user,
              txData.transactionId,
              txData.receivingAssetId,
              toSend
            )
          {} catch {
            // Regardless of error within the callData execution, send funds
            // to the predetermined fallback address
            require(
              LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
              ""fulfill: TRANSFER_FAILED""
            );
          }
        }

        // Call `execute` on the helper
        try
          IFulfillHelper(txData.callTo).execute(
            txData.user,
            txData.transactionId,
            txData.receivingAssetId,
            toSend,
            callData
          )
        {} catch {
          // Regardless of error within the callData execution, send funds
          // to the predetermined fallback address
          require(
            LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
            ""fulfill: TRANSFER_FAILED""
          );
        }
      }
    }

    // Emit event
    emit TransactionFulfilled(txData.user, txData.router, txData.transactionId, txData, relayerFee, signature, callData, msg.sender);

    return txData;
  }

  /// @notice Any crosschain transaction can be cancelled after it has been
  ///         created to prevent indefinite lock up of funds. After the
  ///         transaction has expired, anyone can cancel it. Before the
  ///         expiry, only the recipient of the funds on the given chain is
  ///         able to cancel. On the sending chain, this means only the router
  ///         is able to cancel before the expiry, while only the user can
  ///         prematurely cancel on the receiving chain.
  /// @param txData All of the data (invariant and variant) for a crosschain
  ///               transaction. The variant data provided is checked against
  ///               what was stored when the `prepare` function was called.
  /// @param relayerFee The fee that should go to the relayer when they are
  ///                   calling the function for the user
  /// @param signature The user's signature that allows a transaction to be
  ///                  cancelled on the receiving chain.
  function cancel(TransactionData calldata txData, uint256 relayerFee, bytes calldata signature)
    external
    override
    nonReentrant
    returns (TransactionData memory)
  {
    // Make sure params match against stored data
    // Also checks that there is an active transfer here
    // Also checks that sender or receiver chainID is this chainId (bc we checked it previously)

    // Get the hash of the invariant tx data. This hash is the same
    // between sending and receiving chains. The variant data is stored
    // in the contract when `prepare` is called within the mapping.
    bytes32 digest = hashInvariantTransactionData(txData);

    // Verify the variant data is correct
    require(variantTransactionData[digest] == hashVariantTransactionData(txData), ""cancel: INVALID_VARIANT_DATA"");

    // Make sure the transaction wasn't already completed
    require(txData.preparedBlockNumber > 0, ""cancel: ALREADY_COMPLETED"");

    // Sanity check: fee <= amount. Allow `=` in case of only wanting to execute
    // 0-value crosschain tx, so only providing the fee amount
    require(relayerFee <= txData.amount, ""cancel: INVALID_RELAYER_FEE"");

    // To prevent `fulfill` / `cancel` from being called multiple times, the
    // preparedBlockNumber is set to 0 before being hashed. The value of the
    // mapping is explicitly *not* zeroed out so users who come online without
    // a store can tell the difference between a transaction that has not been
    // prepared, and a transaction that was already completed on the receiver
    // chain.
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: 0
    })));

    // Remove active blocks
    removeUserActiveBlocks(txData.user, txData.preparedBlockNumber);

    // Return the appropriate locked funds
    if (txData.sendingChainId == chainId) {
      // Sender side, funds must be returned to the user
      if (txData.expiry >= block.timestamp) {
        // Timeout has not expired and tx may only be cancelled by router
        // NOTE: no need to validate the signature here, since you are requiring
        // the router must be the sender when the cancellation is during the
        // fulfill-able window
        require(msg.sender == txData.router, ""cancel: ROUTER_MUST_CANCEL"");

        // Return totality of locked funds to provided fallbacl
        require(
          LibAsset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), txData.amount),
          ""cancel: TRANSFER_FAILED""
        );
      } else {
        // When the user could be unlocking funds through a relayer, validate
        // their signature and payout the relayer.
        if (relayerFee > 0) {
          require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, ""cancel: INVALID_SIGNATURE"");

          require(
            LibAsset.transferAsset(txData.receivingAssetId, payable(msg.sender), relayerFee),
            ""cancel: FEE_TRANSFER_FAILED""
          );
        }

        // Get the amount to refund the user
        uint256 toRefund = txData.amount - relayerFee;

        // Return locked funds to sending chain fallback
        if (toRefund > 0) {
          require(
            LibAsset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), toRefund),
            ""cancel: TRANSFER_FAILED""
          );
        }
      }

    } else {
      // Receiver side, router liquidity is returned
      if (txData.expiry >= block.timestamp) {
        // Timeout has not expired and tx may only be cancelled by user
        // Validate signature
        require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, ""cancel: INVALID_SIGNATURE"");

        // NOTE: there is no incentive here for relayers to submit this on
        // behalf of the user (i.e. fee not respected) because the user has not
        // locked funds on this contract.
      }

      // Return liquidity to router
      routerBalances[txData.router][txData.receivingAssetId] += txData.amount;
    }

    // Emit event
    emit TransactionCancelled(txData.user, txData.router, txData.transactionId, txData, relayerFee, msg.sender);

    // Return
    return txData;
  }

  // helper method to get full array of active blocks
  function getActiveTransactionBlocks(address user) external override view returns (uint256[] memory) {
    return activeTransactionBlocks[user];
  }

  //////////////////////////
  /// Private functions ///
  //////////////////////////

  /// @notice Removes a given block from the tracked activeTransactionBlocks
  ///         array for the user. Called when transactions are completed.
  /// @param user User who has completed a transaction
  /// @param preparedBlock The TransactionData.preparedBlockNumber to remove
  function removeUserActiveBlocks(address user, uint256 preparedBlock) internal {
    // Remove active blocks
    uint256 newLength = activeTransactionBlocks[user].length - 1;
    uint256[] memory updated = new uint256[](newLength);
    bool removed = false;
    uint256 updatedIdx = 0;
    for (uint256 i; i < newLength + 1; i++) {
      // Handle case where there could be more than one tx added in a block
      // And only one should be removed
      if (!removed && activeTransactionBlocks[user][i] == preparedBlock) {
        removed = true;
        continue;
      }
      updated[updatedIdx] = activeTransactionBlocks[user][i];
      updatedIdx++;
    }
    activeTransactionBlocks[user] = updated;
  }

  /// @notice Recovers the signer from the signature provided to the `fulfill`
  ///         function. Returns the address recovered
  /// @param txData TransactionData of the transaction being fulfilled
  /// @param relayerFee The fee paid to the relayer for submitting the fulfill
  ///                   tx on behalf of the user.
  /// @param signature The signature you are recovering the signer from
  function recoverFulfillSignature(
    TransactionData calldata txData,
    uint256 relayerFee,
    bytes calldata signature
  ) internal pure returns (address) {
    // Create the signed payload
    SignedFulfillData memory payload = SignedFulfillData({transactionId: txData.transactionId, relayerFee: relayerFee});

    // Recover
    return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);
  }

  /// @notice Recovers the signer from the signature provided to the `cancel`
  ///         function. Returns the address recovered
  /// @param txData TransactionData of the transaction being fulfilled
  /// @param relayerFee The fee paid to the relayer for submitting the cancel
  ///                   tx on behalf of the user.
  /// @param signature The signature you are recovering the signer from
  function recoverCancelSignature(TransactionData calldata txData, uint256 relayerFee, bytes calldata signature)
    internal
    pure
    returns (address)
  {
    // Create the signed payload
    SignedCancelData memory payload = SignedCancelData({transactionId: txData.transactionId, cancel: ""cancel"", relayerFee: relayerFee});

    // Recover
    return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);
  }

  /// @notice Returns the hash of only the invariant portions of a given
  ///         crosschain transaction
  /// @param txData TransactionData to hash
  function hashInvariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {
    InvariantTransactionData memory invariant = InvariantTransactionData({
      user: txData.user,
      router: txData.router,
      sendingAssetId: txData.sendingAssetId,
      receivingAssetId: txData.receivingAssetId,
      sendingChainFallback: txData.sendingChainFallback,
      callTo: txData.callTo,
      receivingAddress: txData.receivingAddress,
      sendingChainId: txData.sendingChainId,
      receivingChainId: txData.receivingChainId,
      callDataHash: txData.callDataHash,
      transactionId: txData.transactionId
    });
    return keccak256(abi.encode(invariant));
  }

  /// @notice Returns the hash of only the variant portions of a given
  ///         crosschain transaction
  /// @param txData TransactionData to hash
  function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {
    return keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: txData.preparedBlockNumber
    })));
  }
}

",6657,654,"[H-01] Anyone can arbitrarily add router liquidity
The `addLiquidity()` function takes a router address parameter, whose liquidity is increased (instead of assuming that router == msg.sender like is done on removeLiquidity()) on this contract/chain, by transferring the fund amount from router address to this contract if assetID != 0 (i.e. ERC20 tokens). However, anyone can call this function on the router’s behalf. For assetID == 0, the Ether transfer via msg.value comes from msg.sender and hence is assumed to be the router itself.
The impact is that this will allow anyone to call this function and arbitrarily move ERC20 tokens from router address to this contract, assuming router has given max approval to this contract and has assetID amount available for transfer. While the router can always remove the liquidity if it doesn’t want to maintain that level of liquidity, this lack of access control or flexibility for a relayer to add liquidity on router’s behalf, may unnecessarily (and without authorization) increase the router’s exposure to protocol risk to more than it desires. See TransactionManager.sol #L88-L98. See also, use of msg.sender in removeLiquidity (#L88-L98).
 [H-02] activeTransactionBlocks are vulnerable to DDoS attacks
There is a potential issue in function `removeUserActiveBlocks` and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for activeTransactionBlocks, it may grow so large that the for loop may never finish. You should consider introducing an upper limit for activeTransactionBlocks. Also, a malicious actor may block any account (DDOS) by just calling prepare again and again with 0 amount acting as a router. This will push `activeTransactionBlocks` to the specified user until it is no longer possible to remove them from the array.
This is also a gas issue, as function removeUserActiveBlocks iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an EnumerableMap, so you can find and remove elements in O(1).
The best solution depends on what the usual number of activeTransactionBlocks is. If it is expected to be low (e.g. less than 5), then the current approach will work. But with larger arrays, I expect EnumerableMap would be more efficient.
Because an upper limit will not fully mitigate this issue, as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. And, because you need to improve both the security and performance of removeUserActiveBlocks; EnumerableMap may be a go-to solution.
 [H-03] Router liquidity on receiving chain can be double-dipped by the user

Submitted by 0xRajeev, also found by cmichel, gpersoon, pauliax, s1m0 and shw
During `fulfill()` on the receiving chain, if the user has set up an external contract at `txData.callTo`, the catch blocks for both IFulfillHelper.addFunds() and IFulfillHelper.excute() perform transferAsset to the predetermined fallback address txData.receivingAddress.
If addFunds() has reverted earlier, toSend amount would already have been transferred to the receivingAddress. If execute() also fails, it is again transferred.
Scenario: User sets up receiver chain txData.callTo contract such that both addFunds() and execute() calls revert. That will let him get twice the toSend amount credited to the receivingAddress. So effectively, Alice locks 100 tokenAs on chain A, and can get 200 tokenAs (or twice the amount of any token she is supposed to get on chain B from the router), minus relayer fee, on chain B. Router liquidity is double-dipped by Alice and router loses funds. See TransactionManager.sol L395-L409 and L413-L428.
 [H-04] Expired transfers will lock user funds on the sending chain function `cancel()`
The cancelling relayer is being paid in `receivingAssetId` on the sendingChain instead of in sendingAssetID. If the user relies on a relayer to cancel transactions, and that receivingAssetId asset does not exist on the sending chain (assuming only sendingAssetID on the sending chain and receivingAssetId on the receiving chain are assured to be valid and present), then the cancel transaction from the relayer will always revert and user’s funds will remain locked on the sending chain.
The impact is that expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.
Recommend changing receivingAssetId to sendingAssetId in transferAsset() on TransactionManager.sol L514.
 [H-05] Approval is not reset if the call to IFulfillHelper fails
The function `fulfill` first approves the `callTo` to transfer an amount of toSend tokens and tries to call IFulfillHelper, but if the call fails, it transfers these assets directly. However, in such case the approval is not reset, so a malicous callTo can pull these tokens later:  [M-01] Signatures use only tx ID instead of entire digest 
The signature check in `recoverFulfillSignature()` only uses transaction ID (along with the relayer fee) which can be accidentally reused by the user, in which case the older signatures with the older relayer fees can be replayed. The signature should be on the entire digest hashInvariantTransactionData(txData) as indicated in the comment on L306.
The impact is that, If the user signatures are indeed on the digest as indicated by the comment, the signature/address check in fulfill() will fail. If not, they may be accidentally/intentionally replayed with same transaction ID, which also appears to be an outstanding question as indicated by the comment on L12.
 [M-02] Malicious router can block cross-chain-transfers
The agreement between the user and the router seems to already happen off-chain because all the fields are required for the initial In variantTransactionData call already. A router could pretend to take on a user's cross-chain transfer, the user sends their prepare transaction, locking up funds on the sending chain. But then the router simply doesn't respond or responds with a prepare transaction of amount=0.
The user's funds are then locked for the entire expiry time, whereas the router does not have to lock up anything as the amount is 0, even no gas if they simply don't respond. In this way, a router can bid on everything off-chain without a penalty, and take down everyone that accepts the bid.
",7,,"pragma solidity 0.8.4;

import ""./interfaces/IFulfillHelper.sol"";
import ""./interfaces/ITransactionManager.sol"";
import ""./lib/LibAsset.sol"";
import ""./lib/LibERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";


















































contract TransactionManager is ReentrancyGuard, ITransactionManager {
  
  mapping(address => mapping(address => uint256)) public routerBalances;

  
  
  mapping(address => uint256[]) public activeTransactionBlocks;

  
  
  mapping(bytes32 => bytes32) public variantTransactionData;

  
  uint256 public immutable chainId;

  
  uint256 public constant MIN_TIMEOUT = 24 hours;

  constructor(uint256 _chainId) {
    chainId = _chainId;
  }

  
  
  
  
  
  
  function addLiquidity(uint256 amount, address assetId, address router) external payable override nonReentrant {
    
    require(amount > 0, ""addLiquidity: AMOUNT_IS_ZERO"");

    
    if (LibAsset.isEther(assetId)) {
      require(msg.value == amount, ""addLiquidity: VALUE_MISMATCH"");
    } else {
      require(msg.value == 0, ""addLiquidity: ETH_WITH_ERC_TRANSFER"");
      require(LibERC20.transferFrom(assetId, router, address(this), amount), ""addLiquidity: ERC20_TRANSFER_FAILED"");
    }

    
    routerBalances[router][assetId] += amount;

    
    emit LiquidityAdded(router, assetId, amount, msg.sender);
  }

  
  
  
  
  
  
  function removeLiquidity(
    uint256 amount,
    address assetId,
    address payable recipient
  ) external override nonReentrant {
    
    require(amount > 0, ""removeLiquidity: AMOUNT_IS_ZERO"");

    
    require(routerBalances[msg.sender][assetId] >= amount, ""removeLiquidity: INSUFFICIENT_FUNDS"");

    
    routerBalances[msg.sender][assetId] -= amount;

    
    require(LibAsset.transferAsset(assetId, recipient, amount), ""removeLiquidity: TRANSFER_FAILED"");

    
    emit LiquidityRemoved(msg.sender, assetId, amount, recipient);
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  function prepare(
    InvariantTransactionData calldata invariantData,
    uint256 amount,
    uint256 expiry,
    bytes calldata encryptedCallData,
    bytes calldata encodedBid,
    bytes calldata bidSignature
  ) external payable override nonReentrant returns (TransactionData memory) {
    
    require(invariantData.user != address(0), ""prepare: USER_EMPTY"");

    
    require(invariantData.router != address(0), ""prepare: ROUTER_EMPTY"");

    
    require(invariantData.receivingAddress != address(0), ""prepare: RECEIVING_ADDRESS_EMPTY"");

    
    require(invariantData.sendingChainId != invariantData.receivingChainId, ""prepare: SAME_CHAINIDS"");

    
    require(invariantData.sendingChainId == chainId || invariantData.receivingChainId == chainId, ""prepare: INVALID_CHAINIDS"");

    
    require((expiry - block.timestamp) >= MIN_TIMEOUT, ""prepare: TIMEOUT_TOO_LOW"");

    
    bytes32 digest = keccak256(abi.encode(invariantData));
    require(variantTransactionData[digest] == bytes32(0), ""prepare: DIGEST_EXISTS"");

    
    
    
    
    
    

    
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: amount,
      expiry: expiry,
      preparedBlockNumber: block.number
    })));

    
    activeTransactionBlocks[invariantData.user].push(block.number);

    
    if (invariantData.sendingChainId == chainId) {
      
      
      
      
      require(amount > 0, ""prepare: AMOUNT_IS_ZERO"");

      
      
      
      
      

      
      
      if (LibAsset.isEther(invariantData.sendingAssetId)) {
        require(msg.value == amount, ""prepare: VALUE_MISMATCH"");
      } else {
        require(msg.value == 0, ""prepare: ETH_WITH_ERC_TRANSFER"");
        require(
          LibERC20.transferFrom(invariantData.sendingAssetId, msg.sender, address(this), amount),
          ""prepare: ERC20_TRANSFER_FAILED""
        );
      }
    } else {
      
      
      
      
      
      
      
      
      

      
      require(msg.sender == invariantData.router, ""prepare: ROUTER_MISMATCH"");

      
      require(msg.value == 0, ""prepare: ETH_WITH_ROUTER_PREPARE"");

      
      require(
        routerBalances[invariantData.router][invariantData.receivingAssetId] >= amount,
        ""prepare: INSUFFICIENT_LIQUIDITY""
      );

      
      routerBalances[invariantData.router][invariantData.receivingAssetId] -= amount;
    }

    
    TransactionData memory txData = TransactionData({
      user: invariantData.user,
      router: invariantData.router,
      sendingAssetId: invariantData.sendingAssetId,
      receivingAssetId: invariantData.receivingAssetId,
      sendingChainFallback: invariantData.sendingChainFallback,
      callTo: invariantData.callTo,
      receivingAddress: invariantData.receivingAddress,
      callDataHash: invariantData.callDataHash,
      transactionId: invariantData.transactionId,
      sendingChainId: invariantData.sendingChainId,
      receivingChainId: invariantData.receivingChainId,
      amount: amount,
      expiry: expiry,
      preparedBlockNumber: block.number
    });
    emit TransactionPrepared(txData.user, txData.router, txData.transactionId, txData, msg.sender, encryptedCallData, encodedBid, bidSignature);
    return txData;
  }



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  function fulfill(
    TransactionData calldata txData,
    uint256 relayerFee,
    bytes calldata signature, 
    bytes calldata callData
  ) external override nonReentrant returns (TransactionData memory) {
    
    
    
    bytes32 digest = hashInvariantTransactionData(txData);

    
    require(variantTransactionData[digest] == hashVariantTransactionData(txData), ""fulfill: INVALID_VARIANT_DATA"");

    
    require(txData.expiry > block.timestamp, ""fulfill: EXPIRED"");

    
    require(txData.preparedBlockNumber > 0, ""fulfill: ALREADY_COMPLETED"");

    
    require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, ""fulfill: INVALID_SIGNATURE"");

    
    
    require(relayerFee <= txData.amount, ""fulfill: INVALID_RELAYER_FEE"");

    
    require(keccak256(callData) == txData.callDataHash, ""fulfill: INVALID_CALL_DATA"");

    
    
    
    
    
    
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: 0
    })));

    
    removeUserActiveBlocks(txData.user, txData.preparedBlockNumber);

    if (txData.sendingChainId == chainId) {
      
      
      

      
      
      require(msg.sender == txData.router, ""fulfill: ROUTER_MISMATCH"");

      
      routerBalances[txData.router][txData.sendingAssetId] += txData.amount;
    } else {
      
      

      
      uint256 toSend = txData.amount - relayerFee;

      
      if (relayerFee > 0) {
        require(
          LibAsset.transferAsset(txData.receivingAssetId, payable(msg.sender), relayerFee),
          ""fulfill: FEE_TRANSFER_FAILED""
        );
      }

      
      if (txData.callTo == address(0)) {
        
        require(
          LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
          ""fulfill: TRANSFER_FAILED""
        );
      } else {
        
        
        

        
        if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {
          require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), ""fulfill: APPROVAL_FAILED"");
        }

        
        
        
        if (toSend > 0) {
          try
            IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(
              txData.user,
              txData.transactionId,
              txData.receivingAssetId,
              toSend
            )
          {} catch {
            
            
            require(
              LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
              ""fulfill: TRANSFER_FAILED""
            );
          }
        }

        
        try
          IFulfillHelper(txData.callTo).execute(
            txData.user,
            txData.transactionId,
            txData.receivingAssetId,
            toSend,
            callData
          )
        {} catch {
          
          
          require(
            LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),
            ""fulfill: TRANSFER_FAILED""
          );
        }
      }
    }

    
    emit TransactionFulfilled(txData.user, txData.router, txData.transactionId, txData, relayerFee, signature, callData, msg.sender);

    return txData;
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  function cancel(TransactionData calldata txData, uint256 relayerFee, bytes calldata signature)
    external
    override
    nonReentrant
    returns (TransactionData memory)
  {
    
    
    

    
    
    
    bytes32 digest = hashInvariantTransactionData(txData);

    
    require(variantTransactionData[digest] == hashVariantTransactionData(txData), ""cancel: INVALID_VARIANT_DATA"");

    
    require(txData.preparedBlockNumber > 0, ""cancel: ALREADY_COMPLETED"");

    
    
    require(relayerFee <= txData.amount, ""cancel: INVALID_RELAYER_FEE"");

    
    
    
    
    
    
    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: 0
    })));

    
    removeUserActiveBlocks(txData.user, txData.preparedBlockNumber);

    
    if (txData.sendingChainId == chainId) {
      
      if (txData.expiry >= block.timestamp) {
        
        
        
        
        require(msg.sender == txData.router, ""cancel: ROUTER_MUST_CANCEL"");

        
        require(
          LibAsset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), txData.amount),
          ""cancel: TRANSFER_FAILED""
        );
      } else {
        
        
        if (relayerFee > 0) {
          require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, ""cancel: INVALID_SIGNATURE"");

          require(
            LibAsset.transferAsset(txData.receivingAssetId, payable(msg.sender), relayerFee),
            ""cancel: FEE_TRANSFER_FAILED""
          );
        }

        
        uint256 toRefund = txData.amount - relayerFee;

        
        if (toRefund > 0) {
          require(
            LibAsset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), toRefund),
            ""cancel: TRANSFER_FAILED""
          );
        }
      }

    } else {
      
      if (txData.expiry >= block.timestamp) {
        
        
        require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, ""cancel: INVALID_SIGNATURE"");

        
        
        
      }

      
      routerBalances[txData.router][txData.receivingAssetId] += txData.amount;
    }

    
    emit TransactionCancelled(txData.user, txData.router, txData.transactionId, txData, relayerFee, msg.sender);

    
    return txData;
  }

  
  function getActiveTransactionBlocks(address user) external override view returns (uint256[] memory) {
    return activeTransactionBlocks[user];
  }

  
  
  

  
  
  
  
  function removeUserActiveBlocks(address user, uint256 preparedBlock) internal {
    
    uint256 newLength = activeTransactionBlocks[user].length - 1;
    uint256[] memory updated = new uint256[](newLength);
    bool removed = false;
    uint256 updatedIdx = 0;
    for (uint256 i; i < newLength + 1; i++) {
      
      
      if (!removed && activeTransactionBlocks[user][i] == preparedBlock) {
        removed = true;
        continue;
      }
      updated[updatedIdx] = activeTransactionBlocks[user][i];
      updatedIdx++;
    }
    activeTransactionBlocks[user] = updated;
  }

  
  
  
  
  
  
  function recoverFulfillSignature(
    TransactionData calldata txData,
    uint256 relayerFee,
    bytes calldata signature
  ) internal pure returns (address) {
    
    SignedFulfillData memory payload = SignedFulfillData({transactionId: txData.transactionId, relayerFee: relayerFee});

    
    return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);
  }

  
  
  
  
  
  
  function recoverCancelSignature(TransactionData calldata txData, uint256 relayerFee, bytes calldata signature)
    internal
    pure
    returns (address)
  {
    
    SignedCancelData memory payload = SignedCancelData({transactionId: txData.transactionId, cancel: ""cancel"", relayerFee: relayerFee});

    
    return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);
  }

  
  
  
  function hashInvariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {
    InvariantTransactionData memory invariant = InvariantTransactionData({
      user: txData.user,
      router: txData.router,
      sendingAssetId: txData.sendingAssetId,
      receivingAssetId: txData.receivingAssetId,
      sendingChainFallback: txData.sendingChainFallback,
      callTo: txData.callTo,
      receivingAddress: txData.receivingAddress,
      sendingChainId: txData.sendingChainId,
      receivingChainId: txData.receivingChainId,
      callDataHash: txData.callDataHash,
      transactionId: txData.transactionId
    });
    return keccak256(abi.encode(invariant));
  }

  
  
  
  function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {
    return keccak256(abi.encode(VariantTransactionData({
      amount: txData.amount,
      expiry: txData.expiry,
      preparedBlockNumber: txData.preparedBlockNumber
    })));
  }
}",3101,5,2,"{'task_list': [{'Area': 'Access Control', 'Tasks': ['Verify that only the intended actor (router) can call `removeLiquidity`.', 'Confirm that `prepare` can only be called with the intended `msg.sender` based on chainId and asset type.', 'Ensure that the `fulfill` function correctly validates that `msg.sender` is the intended `router` when `txData.sendingChainId == chainId`.', 'Verify that only the router can call `cancel` before expiry on the sending chain when `txData.sendingChainId == chainId`. Investigate potential griefing attack scenarios.']}, {'Area': 'Reentrancy Vulnerabilities', 'Tasks': ['Analyze external calls in `fulfill` (to `IFulfillHelper`) for potential reentrancy issues, even with the `nonReentrant` modifier. Consider the possibility of the called contract re-entering the `TransactionManager` through a different function.', 'Examine the interaction with `LibAsset.transferAsset` within `fulfill` and `cancel` for potential reentrancy, especially if the asset is a custom ERC20 token with a malicious callback.', 'Review the impacts of a potential reentrancy if `IFulfillHelper(txData.callTo).execute` fails after `addFunds` has succeeded.', 'Consider reentrancy attacks when removing liquidity in `removeLiquidity`.']}, {'Area': 'Signature Validation', 'Tasks': [""Thoroughly test the `recoverFulfillSignature` and `recoverCancelSignature` functions with various inputs (valid and invalid signatures) to ensure they correctly recover the signer's address."", 'Verify that the signature recovery is not vulnerable to signature malleability.', 'Confirm that the correct message is being signed by the user. Specifically, analyze the `SignedFulfillData` and `SignedCancelData` structs to ensure they contain all relevant transaction details.', 'Investigate the potential for replay attacks if signatures are not properly invalidated or scoped.']}, {'Area': 'Transaction State Management and Data Integrity', 'Tasks': ['Verify that the `variantTransactionData` mapping is updated correctly in `prepare`, `fulfill`, and `cancel` to prevent double-spending or incorrect transaction state.', 'Ensure that the hashes used in `variantTransactionData` (`hashInvariantTransactionData` and `hashVariantTransactionData`) are collision-resistant and correctly incorporate all relevant transaction details.', 'Analyze how the `activeTransactionBlocks` mapping and the `removeUserActiveBlocks` function interact and confirm that they accurately track active transactions. Check edge cases with many concurrent transactions and the gas costs involved.', 'Confirm that modifying `txData` in the `fulfill` and `cancel` functions does not introduce any vulnerabilities.', 'Check the case where the same transactionId is used multiple times. Can it lead to problems with the current implementation?']}, {'Area': 'Asset Handling and Value Transfer', 'Tasks': ['Verify that the correct amount of ETH or ERC20 tokens is transferred in `addLiquidity`, `removeLiquidity`, `prepare`, `fulfill`, and `cancel` functions. Pay close attention to edge cases (e.g., zero amounts, very large amounts).', 'Ensure that `LibAsset.transferAsset` and `LibERC20.transferFrom` are used correctly and handle potential errors (e.g., insufficient allowance, transfer failures).', 'Analyze the logic for handling relayer fees in `fulfill` and `cancel` to ensure the correct amount is paid to the relayer and the remaining amount is transferred to the intended recipient.', 'Investigate potential rounding errors or precision issues when calculating and transferring asset amounts.', 'Verify that ETH can be sent using the `callTo` functionality in `fulfill` and the value is properly forwarded.']}, {'Area': 'Timeout and Expiry', 'Tasks': ['Ensure that the `MIN_TIMEOUT` constant is enforced correctly in the `prepare` function.', 'Verify that the `expiry` timestamp is handled correctly in the `fulfill` and `cancel` functions and that transactions are not fulfilled or cancelled after they have expired.', 'Check for potential time-dependent vulnerabilities or race conditions related to the `expiry` timestamp.', 'Assess the impact of block timestamp manipulation on transaction expiry.']}, {'Area': 'External Call Security', 'Tasks': ['Carefully examine the external call to `IFulfillHelper` in the `fulfill` function. Analyze potential risks associated with calling untrusted contracts (e.g., malicious code execution, denial-of-service attacks).', 'Assess the effectiveness of the `try/catch` block around the external call and ensure that it correctly handles errors and reverts the transaction if necessary.', 'Verify that the `callData` parameter is validated appropriately to prevent malicious code injection.', ""If the external contract performs complex operations, verify that it doesn't violate gas limits and potentially cause the `fulfill` transaction to fail."", 'The `IFulfillHelper(txData.callTo).addFunds` is called before `execute`. If the former succeeds but the latter fails, funds may be stuck in the `callTo` contract. Analyze this scenario.']}, {'Area': 'Gas Optimization', 'Tasks': ['Analyze gas costs of frequently used functions, such as `prepare`, `fulfill`, and `cancel`.', ""Consider using more gas-efficient data structures or algorithms where appropriate. Specifically, the `removeUserActiveBlocks` function's array copying could be optimized."", 'Evaluate the use of `calldata` vs. `memory` for function parameters.', 'Assess the impact of storage reads and writes on gas costs and optimize where possible.', 'Check if using unchecked arithmetic can reduce gas costs in certain calculations.']}, {'Area': 'Denial of Service (DoS)', 'Tasks': ['Examine the `activeTransactionBlocks` mapping for potential DoS vulnerabilities. If a user creates a large number of transactions, it could lead to high gas costs when iterating over the array in `removeUserActiveBlocks`, potentially causing transactions to revert. Consider alternative data structures or pagination techniques.', 'Analyze the `fulfill` and `cancel` functions for potential DoS attacks if they involve complex calculations or external calls that consume a significant amount of gas.', 'Consider if there are any potential attacks involving blocking the `router` from adding or removing liquidity, effectively freezing the system.']}, {'Area': 'Unused Parameters', 'Tasks': ['The `encryptedCallData`, `encodedBid`, and `bidSignature` parameters in `prepare` are emitted but not used in the core logic. Determine the purpose of these parameters and ensure they are handled appropriately. If they are not needed, consider removing them to save gas.']}]}","{'ReviewingTheCode': ""The contract `TransactionManager` facilitates cross-chain or potentially same-chain asset transfers and interactions. It acts as an escrow and state machine, managing liquidity provided by 'routers' and handling the lifecycle (prepare, fulfill, cancel) of transactions initiated by users. It uses signature verification for authorization and incorporates reentrancy protection."", 'IdentifyingKeyComponents': {'ContractName': 'TransactionManager', 'Purpose': 'To manage liquidity and execute atomic cross-chain/same-chain transactions, allowing users to transfer assets and potentially interact with other contracts across chains via routers and relayers.', 'InheritanceAndImports': {'InheritsFrom': ['ReentrancyGuard', 'ITransactionManager'], 'Imports': ['./interfaces/IFulfillHelper.sol', './interfaces/ITransactionManager.sol', './lib/LibAsset.sol', './lib/LibERC20.sol', '@openzeppelin/contracts/security/ReentrancyGuard.sol', '@openzeppelin/contracts/utils/cryptography/ECDSA.sol']}, 'StateVariables': [{'Name': 'routerBalances', 'Type': 'mapping(address => mapping(address => uint256))', 'Purpose': 'Stores the amount of liquidity provided by each router for each specific asset.'}, {'Name': 'activeTransactionBlocks', 'Type': 'mapping(address => uint256[])', 'Purpose': 'Tracks the block numbers at which transactions were prepared for each user. Used to identify active transactions.'}, {'Name': 'variantTransactionData', 'Type': 'mapping(bytes32 => bytes32)', 'Purpose': 'Stores the hashed state (amount, expiry, preparedBlockNumber) of a transaction, keyed by the hash of its invariant data. Used to verify transaction status and prevent replays.'}, {'Name': 'chainId', 'Type': 'uint256', 'Purpose': 'Stores the chain ID where this contract is deployed. Immutable.'}, {'Name': 'MIN_TIMEOUT', 'Type': 'uint256', 'Purpose': 'Constant defining the minimum duration a transaction must be prepared for before expiring.'}], 'FunctionsAndModifiers': [{'Name': 'constructor', 'Visibility': 'public', 'Purpose': 'Initializes the contract by setting the chainId.', 'Parameters': ['_chainId'], 'Returns': []}, {'Name': 'addLiquidity', 'Visibility': 'external', 'Purpose': 'Allows a router (or any address acting as one) to add liquidity (ETH or ERC20) to the contract.', 'Parameters': ['amount', 'assetId', 'router'], 'Returns': []}, {'Name': 'removeLiquidity', 'Visibility': 'external', 'Purpose': 'Allows a router (msg.sender) to remove previously added liquidity.', 'Parameters': ['amount', 'assetId', 'recipient'], 'Returns': []}, {'Name': 'prepare', 'Visibility': 'external', 'Purpose': 'Initiates a transaction by locking funds (if sending chain) or reserving router liquidity (if receiving chain). Records transaction details and state.', 'Parameters': ['invariantData', 'amount', 'expiry', 'encryptedCallData', 'encodedBid', 'bidSignature'], 'Returns': ['TransactionData memory']}, {'Name': 'fulfill', 'Visibility': 'external', 'Purpose': 'Executes a prepared transaction on the receiving chain after verifying user signature and transaction validity. Handles asset transfer and potential external contract calls.', 'Parameters': ['txData', 'relayerFee', 'signature', 'callData'], 'Returns': ['TransactionData memory']}, {'Name': 'cancel', 'Visibility': 'external', 'Purpose': 'Cancels a prepared transaction, either by the router (before expiry on sending chain) or based on expiry/user signature. Returns funds/liquidity.', 'Parameters': ['txData', 'relayerFee', 'signature'], 'Returns': ['TransactionData memory']}, {'Name': 'getActiveTransactionBlocks', 'Visibility': 'external', 'Purpose': 'View function to retrieve the list of active transaction block numbers for a given user.', 'Parameters': ['user'], 'Returns': ['uint256[] memory']}, {'Name': 'removeUserActiveBlocks', 'Visibility': 'internal', 'Purpose': ""Helper function to remove a specific block number from a user's active transaction list."", 'Parameters': ['user', 'preparedBlock'], 'Returns': []}, {'Name': 'recoverFulfillSignature', 'Visibility': 'internal', 'Purpose': ""Recovers the signer's address from a fulfill signature."", 'Parameters': ['txData', 'relayerFee', 'signature'], 'Returns': ['address']}, {'Name': 'recoverCancelSignature', 'Visibility': 'internal', 'Purpose': ""Recovers the signer's address from a cancel signature."", 'Parameters': ['txData', 'relayerFee', 'signature'], 'Returns': ['address']}, {'Name': 'hashInvariantTransactionData', 'Visibility': 'internal', 'Purpose': 'Computes the hash of the invariant part of transaction data, used as a key in `variantTransactionData`.', 'Parameters': ['txData'], 'Returns': ['bytes32']}, {'Name': 'hashVariantTransactionData', 'Visibility': 'internal', 'Purpose': 'Computes the hash of the variant part of transaction data (state), used as a value in `variantTransactionData`.', 'Parameters': ['txData'], 'Returns': ['bytes32']}, {'Name': 'nonReentrant', 'Visibility': 'modifier (from ReentrancyGuard)', 'Purpose': 'Prevents reentrant calls into protected functions.', 'Parameters': [], 'Returns': []}]}, 'ExternalInteractions': ['LibAsset: Used for handling ETH and generic asset transfers.', 'LibERC20: Used for ERC20 token transfers (`transferFrom`, `approve`).', 'IFulfillHelper: Interface used to call external contracts (`callTo`) during fulfillment (`addFunds`, `execute`).', 'ECDSA library (@openzeppelin/contracts/utils/cryptography/ECDSA.sol): Used for signature recovery.', 'ReentrancyGuard (@openzeppelin/contracts/security/ReentrancyGuard.sol): Inherited for reentrancy protection.'], 'SpecialMechanisms': ['Cross-Chain Transaction Protocol: Implements a prepare-fulfill-cancel mechanism for atomic swaps/transfers.', 'State Management via Hashing: Uses `hashInvariantTransactionData` and `hashVariantTransactionData` with the `variantTransactionData` mapping to track and verify transaction states.', 'Liquidity Pool for Routers: Routers provide funds (`routerBalances`) that are used to facilitate transactions on the receiving chain.', ""Signature Verification: Employs ECDSA signatures (`fulfill`, `cancel`) for user authorization, enabling gasless approvals from the user's perspective."", 'Relayer Fee Mechanism: Allows relayers (who call `fulfill` or `cancel`) to be compensated.', 'External Call Integration: `fulfill` can interact with external contracts (`callTo`) via the `IFulfillHelper` interface, with basic error handling (try/catch).', 'Reentrancy Protection: Utilizes the `nonReentrant` modifier.'], 'Questions': ['How are the `encryptedCallData`, `encodedBid`, and `bidSignature` parameters in `prepare` intended to be used? They are emitted but not utilized within the core on-chain logic shown.', 'The `removeUserActiveBlocks` function creates a new array and copies elements. Could this lead to high gas costs if a user has many active transactions? Is an alternative (e.g., swap-and-pop) feasible?', 'In `fulfill` on the receiving chain, if `IFulfillHelper(txData.callTo).execute` fails after `addFunds` (if applicable) has succeeded, the funds might remain in the `callTo` contract before the fallback transfer occurs. Is this the intended behavior?', 'The cancellation logic allows the router to cancel before expiry on the sending chain. Could this be used to grief users?', 'How is the `relayerFee` amount determined and agreed upon off-chain? The contract only checks `relayerFee <= txData.amount`.']}","{'Findings': [{'Issue': 'Potential Reentrancy Vulnerability via External Calls in `fulfill` Function', 'Severity': 'High', 'Description': 'The `fulfill` function, despite using a `nonReentrant` modifier, makes external calls to `IFulfillHelper(txData.callTo).addFunds` and `IFulfillHelper(txData.callTo).execute`. If the contract at `txData.callTo` is malicious, it could re-enter the `TransactionManager` contract (potentially calling other functions or even `fulfill` itself in a separate transaction context before state updates like `variantTransactionData` are finalized or `removeUserActiveBlocks` is called). The `nonReentrant` guard only prevents direct re-entry into the same function execution context, not indirect re-entry via external calls to untrusted contracts or re-entry in a subsequent transaction.', 'Impact': 'Loss of funds, state corruption, denial of service, or bypassing security checks. A malicious contract could potentially drain router balances, manipulate transaction data, or execute unintended actions.', 'Location': '`TransactionManager.fulfill` function, specifically external calls to `IFulfillHelper` (e.g., Lines 304-348, depending on report version)'}, {'Issue': 'Inconsistent Asset ID Usage During `cancel` Function Refund Process', 'Severity': 'High', 'Description': ""The `cancel` function exhibits inconsistent logic when handling refunds based on transaction expiry. If the transaction hasn't expired and `txData.sendingChainId == chainId`, it refunds `txData.amount` in `txData.sendingAssetId`. However, if the transaction *has* expired, it refunds the relayer fee in `txData.receivingAssetId` and the remainder in `txData.sendingAssetId`. This inconsistency allows manipulating refunds by choosing specific asset IDs and values, potentially directing excessive funds (in `receivingAssetId`) to the relayer."", 'Impact': 'Potential theft of funds from the intended recipient (sendingChainFallback) by manipulating the refund distribution between `sendingAssetId` and `receivingAssetId` when a transaction expires.', 'Location': '`TransactionManager.cancel` function'}, {'Issue': 'Potential Replay Attack Vulnerability in `fulfill` and `cancel` Functions', 'Severity': 'High', 'Description': 'The `fulfill` and `cancel` functions rely on signatures (`SignedFulfillData`, `SignedCancelData`) recovered via `recoverFulfillSignature` and `recoverCancelSignature`. These signatures lack replay protection mechanisms like a nonce or inclusion of the chain ID in the signed payload. An attacker could potentially reuse a valid signature on the same chain (if state allows) or, more critically, on a different chain where the contract might be deployed, leading to unauthorized execution.', 'Impact': 'Unauthorized execution of `fulfill` or `cancel` transactions, potentially leading to double spending, incorrect state changes, or loss of funds by replaying transactions across chains or multiple times on the same chain.', 'Location': '`TransactionManager.fulfill`, `TransactionManager.cancel`, `TransactionManager.recoverFulfillSignature`, `TransactionManager.recoverCancelSignature`'}, {'Issue': 'Potential Denial of Service (DoS) in `removeUserActiveBlocks` Function', 'Severity': 'Medium', 'Description': 'The `removeUserActiveBlocks` function iterates through the entire `activeTransactionBlocks[user]` array to find and remove a specific `preparedBlock`. It does this by creating a new, smaller array and copying elements. If a user accumulates a large number of active transactions (the array size is unbounded), the gas cost of this linear search and copy operation (O(n)) can become excessively high, potentially exceeding the block gas limit. This can prevent the user from successfully calling `fulfill` or `cancel`.', 'Impact': 'Denial of service for users with many active transactions, preventing them from completing or canceling their transactions due to excessive gas costs.', 'Location': '`TransactionManager.removeUserActiveBlocks` function (e.g., Lines 406-451, depending on report version)'}, {'Issue': 'Insufficient Input Validation for `addLiquidity` Function', 'Severity': 'Medium', 'Description': ""The `addLiquidity` function only checks if `amount > 0`. It lacks a check to prevent `assetId` from being the zero address or other potentially invalid addresses. While `LibAsset.isEther` is used, it doesn't fully validate the `assetId` itself."", 'Impact': 'Accounting errors, unexpected behavior, or potential griefing if liquidity is added using the zero address or an unintended address.', 'Location': '`TransactionManager.addLiquidity`'}, {'Issue': 'Lack of Authorization/Access Control for `removeLiquidity`', 'Severity': 'Medium', 'Description': ""The `removeLiquidity` function uses `msg.sender` to identify the router removing liquidity. There's no additional access control mechanism beyond this check. If a router's key is compromised or `msg.sender` can be manipulated (e.g., through a proxy contract vulnerability), unauthorized parties could potentially remove the router's liquidity."", 'Impact': 'Unauthorized removal of liquidity, leading to potential loss of funds for the router.', 'Location': '`TransactionManager.removeLiquidity` function'}, {'Issue': 'Missing Check for Zero Address Recipient in `removeLiquidity`', 'Severity': 'Medium', 'Description': 'The `removeLiquidity` function transfers assets to a specified `recipient` address but does not validate if this address is the zero address. Sending funds (Ether or tokens) to the zero address results in their permanent loss.', 'Impact': 'Accidental or malicious burning of router funds if the `recipient` is mistakenly set to the zero address.', 'Location': '`TransactionManager.removeLiquidity` function (e.g., Line 70/71 or 93-103, depending on report version)'}, {'Issue': 'Potential Front-Running Vulnerability in `prepare` Function', 'Severity': 'Medium', 'Description': ""The `prepare` function checks `variantTransactionData[digest] == bytes32(0)` to prevent duplicate transactions based on the `invariantData` hash. However, an attacker monitoring the mempool can observe a pending `prepare` transaction and submit their own transaction with the same `invariantData` hash (but potentially different variant data like amount, expiry, etc.) with a higher gas price. This allows the attacker's transaction to be mined first, causing the original user's transaction to fail."", 'Impact': 'Transaction failure for the original user, loss of gas, and potential manipulation of transaction parameters by the front-runner.', 'Location': '`TransactionManager.prepare` function (e.g., Line 125 or 145, depending on report version)'}, {'Issue': 'Insufficient Validation of `invariantData.callDataHash` in `prepare` Function', 'Severity': 'Medium', 'Description': ""The `prepare` function accepts `encryptedCallData` but does not validate it against the `callDataHash` provided in `invariantData`. This discrepancy allows a scenario where the emitted `TransactionPrepared` event contains `encryptedCallData` that does not correspond to the `callDataHash`, potentially misleading off-chain listeners or allowing manipulation if the receiver relies solely on the event's data without verifying against the hash."", 'Impact': 'Misleading event data, potential for receiver to sign off on incorrect call data, potentially enabling execution of unintended functions or theft of funds if validation relies on emitted data.', 'Location': '`TransactionManager.prepare` function'}, {'Issue': 'Missing Input Validation for Chain IDs in `prepare` Function', 'Severity': 'Medium', 'Description': ""The `prepare` function checks that sending and receiving chain IDs differ and that one matches the contract's chain ID, but it does not validate if the provided chain IDs themselves are sensible or within an expected range. Arbitrary values could be used."", 'Impact': 'Potential integration issues, unexpected behavior in cross-chain interactions, or exploitation of systems relying on valid chain ID assumptions.', 'Location': '`TransactionManager.prepare` function'}, {'Issue': 'Lack of Input Validation for `relayerFee`', 'Severity': 'Medium', 'Description': ""While `fulfill` and `cancel` check `relayerFee <= txData.amount`, there's no upper bound check relative to the transaction value or a check against unreasonably high fees. A malicious relayer (or compromised communication resulting in a bad signature) could potentially set the `relayerFee` to be equal or very close to `txData.amount`, draining most funds intended for the recipient or refund."", 'Impact': ""Potential loss of funds for the transaction's user or recipient, with most of the value going to the relayer."", 'Location': '`TransactionManager.fulfill`, `TransactionManager.cancel` (e.g., Lines 270, 355)'}, {'Issue': 'Potential Integer Overflow/Underflow in `removeUserActiveBlocks` Function', 'Severity': 'Low', 'Description': 'The calculation `uint256 newLength = activeTransactionBlocks[user].length - 1;` can underflow if `activeTransactionBlocks[user].length` is 0. This results in `newLength` becoming `type(uint256).max`. While the subsequent loop might handle this correctly in some versions (or incorrectly in others, e.g., looping up to `newLength + 1`), allocating memory for the `updated` array (`new uint256[](newLength)`) with this massive value will cause the transaction to run out of gas.', 'Impact': 'Transaction reverts due to out-of-gas errors when trying to remove from an empty list, denial of service for the specific function call.', 'Location': '`TransactionManager.removeUserActiveBlocks` function (e.g., Line 407 or 421, depending on report version)'}, {'Issue': 'Missing Zero-Address Check for `sendingChainFallback` in `prepare` Function', 'Severity': 'Low', 'Description': 'The `prepare` function does not validate if `invariantData.sendingChainFallback` is the zero address. If a transaction using such data is later cancelled, the refund transfer to the zero address will effectively burn the funds.', 'Impact': 'Unintentional burning of funds upon cancellation if `sendingChainFallback` was set to the zero address during preparation.', 'Location': '`TransactionManager.prepare`'}, {'Issue': 'Lack of Input Validation for `chainId` in Constructor', 'Severity': 'Low', 'Description': ""The constructor accepts `_chainId` without validation. Providing an incorrect or unexpected `chainId` during deployment could lead to fundamental operational issues, as the contract's logic relies on comparing transaction chain IDs against this immutable value."", 'Impact': 'Contract misconfiguration, rejection of valid transactions intended for the chain, disruption of normal operations.', 'Location': '`TransactionManager` constructor (e.g., Line 20 or 27)'}, {'Issue': 'Lack of Events for `routerBalances` Updates in `prepare` and `cancel`', 'Severity': 'Low', 'Description': 'The `prepare` and `cancel` functions modify the `routerBalances` mapping (locking funds in `prepare`, unlocking in `cancel`) but do not emit events specifically indicating these balance changes. This makes it harder for off-chain services to accurately track router liquidity state changes.', 'Impact': 'Reduced transparency and difficulty for off-chain monitoring and analysis of router liquidity.', 'Location': '`TransactionManager.prepare` (Line 179), `TransactionManager.cancel` (Line 384)'}, {'Issue': 'Public Visibility of `routerBalances` Mapping', 'Severity': 'Low', 'Description': ""The `routerBalances` mapping is declared `public`, creating an automatic getter function accessible by anyone. While read access isn't inherently a vulnerability, it exposes potentially sensitive information about router liquidity levels."", 'Impact': 'Information disclosure about router liquidity, potentially aiding attackers in identifying high-value targets.', 'Location': '`TransactionManager.sol`: Line 12'}, {'Issue': 'Incorrect Array Logic/Iteration in `removeUserActiveBlocks`', 'Severity': 'Low', 'Description': 'Some versions of the `removeUserActiveBlocks` function contain potential logic errors in array handling. Examples include: calculating `newLength` incorrectly assuming the element always exists, using `newLength + 1` as a loop bound which might be off-by-one or incorrect after underflow, or potential out-of-bounds access if loop indices are not handled carefully relative to the size of the `updated` array (`newLength`).', 'Impact': 'Potential for transaction reverts, incorrect state updates (wrong block removed or array corrupted), or unexpected behavior depending on the specific logic flaw.', 'Location': '`TransactionManager.removeUserActiveBlocks` (e.g., Lines 416, 425)'}, {'Issue': 'Missing Check if `callTo` Address is a Contract in `fulfill`', 'Severity': 'Low', 'Description': ""The `fulfill` function calls `addFunds` and `execute` on the `txData.callTo` address without first verifying if it's a contract address (using `address.code.length > 0`). Calling these functions on an Externally Owned Account (EOA) will fail."", 'Impact': 'Transaction failure if `callTo` is an EOA instead of a contract implementing `IFulfillHelper`.', 'Location': '`TransactionManager.fulfill` function, calls to `IFulfillHelper`'}, {'Issue': 'Potential Precision Loss Issues with `relayerFee`', 'Severity': 'Low', 'Description': ""The check `relayerFee <= txData.amount` doesn't account for token decimals. If `txData.amount` is very small (e.g., 1 wei of a token) due to high precision, even a minimal `relayerFee` (e.g., 1 wei) might consume the entire amount, which might not be the intended behavior, although technically allowed by the check."", 'Impact': 'Potential for relayer fee to consume the entire transaction amount for low-value transactions involving high-precision tokens, potentially leading to unexpected outcomes.', 'Location': '`TransactionManager.fulfill`, `TransactionManager.cancel` (e.g., Lines 250, 370)'}], 'IssueNumber': 44, 'OutputList': 19}",254.59305381774905,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Anyone can arbitrarily add router liquidity**

**Report Description**:  
The `addLiquidity()` function allows anyone to add liquidity on behalf of a router by transferring ERC20 tokens from the router's address to the contract. This lack of access control can lead to unauthorized increases in the router's exposure to protocol risk, even though the router can remove the liquidity later. The issue is particularly concerning when dealing with untrusted tokens or malicious actors.

**Match in Response List**:  
Matches with the issue titled **""Insufficient Input Validation for `addLiquidity` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of input validation in the `addLiquidity` function but does not explicitly address the core issue of unauthorized liquidity addition on behalf of a router. The response focuses on potential accounting errors or griefing due to invalid `assetId`, which is a related but distinct concern.

---

#### **[H-02] `activeTransactionBlocks` are vulnerable to DDoS attacks**

**Report Description**:  
The `removeUserActiveBlocks` function iterates through the `activeTransactionBlocks` array, which can grow unbounded. This can lead to gas exhaustion or denial of service (DoS) if a malicious actor repeatedly calls `prepare` with zero amounts. Additionally, the function's gas inefficiency can be exploited to block users from completing or canceling transactions.

**Match in Response List**:  
Matches with the issue titled **""Potential Denial of Service (DoS) in `removeUserActiveBlocks` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the DoS vulnerability due to unbounded array growth and gas inefficiency in the `removeUserActiveBlocks` function. It also suggests potential optimizations, aligning with the issue's description and impact.

---

#### **[H-03] Router liquidity on receiving chain can be double-dipped by the user**

**Report Description**:  
During `fulfill()`, if both `addFunds()` and `execute()` calls revert, the `toSend` amount is transferred twice to the `receivingAddress`. This allows a user to double-dip router liquidity, effectively receiving twice the intended amount on the receiving chain.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability via External Calls in `fulfill` Function""**.

**Validation**:  
**Partially Correct**. The response identifies the risks associated with external calls in the `fulfill` function but does not explicitly address the double-dipping issue. The focus is on reentrancy and state corruption, which are related but not identical to the reported issue.

---

#### **[H-04] Expired transfers will lock user funds on the sending chain**

**Report Description**:  
The `cancel()` function refunds the relayer fee in `receivingAssetId` instead of `sendingAssetId`. If `receivingAssetId` does not exist on the sending chain, the transaction will revert, locking user funds indefinitely.

**Match in Response List**:  
Matches with the issue titled **""Inconsistent Asset ID Usage During `cancel` Function Refund Process""**.

**Validation**:  
**Correct**. The response accurately identifies the inconsistency in asset ID usage during the refund process in the `cancel` function. It highlights the potential for fund locking, which aligns with the issue's description and impact.

---

#### **[H-05] Approval is not reset if the call to `IFulfillHelper` fails**

**Report Description**:  
The `fulfill` function approves the `callTo` address to transfer `toSend` tokens but does not reset the approval if the call to `IFulfillHelper` fails. This allows a malicious `callTo` to pull the tokens later.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a critical oversight in the `fulfill` function's security design.

---

#### **[M-01] Signatures use only tx ID instead of entire digest**

**Report Description**:  
The signature check in `recoverFulfillSignature()` uses only the transaction ID, which can lead to replay attacks if the same transaction ID is reused with different parameters.

**Match in Response List**:  
Matches with the issue titled **""Potential Replay Attack Vulnerability in `fulfill` and `cancel` Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the replay attack vulnerability due to insufficient signature validation in the `fulfill` and `cancel` functions. It aligns with the issue's description and impact.

---

#### **[M-02] Malicious router can block cross-chain transfers**

**Report Description**:  
A malicious router can bid on a user's cross-chain transfer off-chain, lock the user's funds by submitting a `prepare` transaction with `amount=0`, and then fail to respond. This blocks the user's funds for the entire expiry period without the router locking any funds.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue, which is a significant vulnerability in the cross-chain transfer mechanism.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] `activeTransactionBlocks` are vulnerable to DDoS attacks**
- **[H-04] Expired transfers will lock user funds on the sending chain**
- **[M-01] Signatures use only tx ID instead of entire digest**

**Partially Correct Matches**:

- **[H-01] Anyone can arbitrarily add router liquidity**
- **[H-03] Router liquidity on receiving chain can be double-dipped by the user**

**Missed Issues from Issue Report**:

- **[H-05] Approval is not reset if the call to `IFulfillHelper` fails**
- **[M-02] Malicious router can block cross-chain transfers**

--- 

**Conclusion**:  
The response list covers several critical issues but misses or partially addresses others. Improvements are needed to ensure comprehensive coverage of all vulnerabilities, particularly those related to access control, approval management, and cross-chain transfer mechanisms.","```
1. Potential Denial of Service (DoS) in `removeUserActiveBlocks` Function
2. Inconsistent Asset ID Usage During `cancel` Function Refund Process
3. Potential Replay Attack Vulnerability in `fulfill` and `cancel` Functions
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - `Potential Denial of Service (DoS) in `removeUserActiveBlocks` Function` appears at rank 4.
   - `Inconsistent Asset ID Usage During `cancel` Function Refund Process` appears at rank 2.
   - `Potential Replay Attack Vulnerability in `fulfill` and `cancel` Functions` appears at rank 3.

2. **Calculate the precision at each rank where a true positive appears**:
   - At rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - At rank 3: \( P@3 = \frac{2}{3} \approx 0.6667 \)
   - At rank 4: \( P@4 = \frac{3}{4} = 0.75 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.5 + 0.6667 + 0.75}{3} \approx \frac{1.9167}{3} \approx 0.6389
   \]

**Output**:
```
0.6389
```"
