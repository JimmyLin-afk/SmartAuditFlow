nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
StabilityPool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a ""compounded deposit"": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a ""feedback"" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate ""per-unit-staked"" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a ""feedback"" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate ""per-unit-staked"" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want ""slightly too much"" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P ""favors the Pool"", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",12382,1177,"[H-01] receiveCollateral() can be called by anyone

Submitted by jayjonah8, also found by dalgarim and kenzo
Impact

In StabilityPool.sol, the receiveCollateral() function should be called by ActivePool per comments, but anyone can call it passing in _tokens and _amounts args to update stability pool balances.
",1,,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";



contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    
    ISortedTroves internal sortedTroves;

    
    uint256 internal totalYUSDDeposits;

    
    
    
    newColls internal totalColl;

    

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; 

    
    mapping(address => Snapshots) public depositSnapshots; 

    mapping(address => FrontEnd) public frontEnds; 
    mapping(address => uint256) public frontEndStakes; 
    mapping(address => Snapshots) public frontEndSnapshots; 

    
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    
    uint128 public currentScale;

    
    uint128 public currentEpoch;

    
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    
    uint256 public lastYETIError;
    
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    

    
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    

    
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        
        
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; 
        
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    

    
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; 
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); 
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    


    
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; 
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    

    
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    
    
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    
    
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    

    
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    
    
    
    
    
    
    
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            
            compoundedStake = 0;
        }

        
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    

    
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    

    
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    
    
    
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",7250,1,0,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the `_leftSubColls` and `_leftSumColls` functions used for collateral subtraction and addition are implemented correctly and are free from overflow/underflow vulnerabilities."",
        ""Check for potential reentrancy vulnerabilities in the `provideToSP`, `withdrawFromSP`, and `offset` functions, especially when interacting with external contracts (e.g., `yusdToken.sendToPool`, `yusdToken.returnFromPool`, `IERC20.safeTransfer`, `IWAsset.unwrapFor`). Consider using the checks-effects-interactions pattern or reentrancy guards."",
        ""Analyze the use of `SafeERC20` library to ensure that all ERC20 token transfers are handled safely, especially when dealing with tokens that do not conform to the ERC20 standard."",
        ""Examine the logic within the `offset` function to ensure that the `_debtToOffset` value is never greater than the actual debt available in the ActivePool. Prevent unexpected behavior."",
        ""Investigate potential denial-of-service (DoS) vulnerabilities, such as the possibility of a large number of collateral types being added via `addCollateralType`, potentially exceeding gas limits in subsequent operations. Consider restricting the number of collateral types or implementing pagination."",
        ""Review all require statements and error messages to ensure they provide sufficient information for debugging and prevent unexpected state changes.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms & Reward Calculation"",
      ""Tasks"": [
        ""Thoroughly review the reward calculation logic in `_computeRewardsPerUnitStaked`, `_updateRewardSumAndProduct`, `_getGainFromSnapshots`, and `_getYETIGainFromSnapshots`. Verify the correctness of the formulas and the handling of edge cases (e.g., zero deposits, zero debt, extreme values of `P`, `currentScale`, `currentEpoch`)."",
        ""Analyze the purpose and behavior of the `lastYETIError`, `lastAssetError_Offset`, and `lastYUSDLossError_Offset` variables. Ensure they correctly accumulate and distribute errors to maintain accuracy in reward calculations. Verify these error terms don't grow unbounded leading to eventual incorrectness."",
        ""Simulate different scenarios of deposits, withdrawals, and liquidations to verify that the reward distribution is fair and accurate for all depositors and front-ends."",
        ""Investigate the impact of the `SCALE_FACTOR` and `currentScale` on the precision of reward calculations. Determine the potential for rounding errors and their effect on the overall system."",
        ""Analyze the epoch and scale mechanism and confirm that the state transitions between epochs and scales are handled correctly and prevent any inconsistencies in reward calculation. In particular, investigate zero value of newProductFactor"",
        ""Verify that the front-end kickback mechanism functions as intended, ensuring that rewards are correctly distributed between depositors and front-ends according to the configured kickback rates."",
        ""Review the logic to handle assets using `IWAsset` vs. `IERC20` and ensure correct reward processing between wrapped and unwrapped assets.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that all external contract calls (e.g., to `yusdToken`, `borrowerOperations`, `troveManager`, `sortedTroves`, `communityIssuance`, `activePool`, `whitelist`, `IERC20`, `IWAsset`) are properly handled, including error handling and gas limits."",
        ""Assess the trust assumptions and potential risks associated with each external contract. Consider the impact of contract upgrades or malicious behavior by external contracts on the StabilityPool's functionality and security."",
        ""Analyze the `setAddresses` function and the potential impact of changing the addresses of external contracts. Ensure that the `_renounceOwnership` call does not create unintended consequences."",
        ""Examine the Whitelist contract to check if the length of valid collaterals and lastAssetError_Offset are in sync.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is used appropriately to protect sensitive functions, such as `setAddresses` and `addCollateralType`."",
        ""Ensure that the `_requireCallerIsWhitelist`, `_requireCallerIsActivePool`, and `_requireCallerIsTML` modifiers correctly restrict access to specific functions based on the caller's address."",
        ""Review the ownership transfer mechanism and ensure that the owner can be changed securely.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify potential gas inefficiencies in the contract, such as redundant calculations, unnecessary storage writes, and inefficient data structures."",
        ""Optimize the loops used for collateral processing in functions like `_sendGainsToDepositor` and `offset` to reduce gas costs."",
        ""Consider using assembly code or other low-level optimizations to further reduce gas consumption in critical functions."",
        ""Review and improve data caching practices to reduce `sload` operations, a costly aspect of gas usage.""
      ]
    },
    {
      ""Area"": ""Compliance"",
      ""Tasks"": [
        ""If the YUSD token is expected to conform to the ERC-20 standard, verify that the contract correctly implements all required functions and events, along with no deviations.""
      ]
    },
    {
      ""Area"": ""Fallback/Emergency Stops"",
      ""Tasks"": [
        ""There is no clear emergency stop mechanism in this contract. Explore adding a pausable functionality to halt critical functions in case of exploits or critical bugs."",
        ""If a pause function is added, ensure there is a multi-sig or timelock mechanism required to trigger the stop.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines the `StabilityPool` contract, which is a core component of the Liquity protocol. It manages YUSD deposits from users, uses these deposits to offset debt from liquidated Troves, and distributes collateral and YETI rewards to depositors and front-ends. The contract interacts with several other Liquity contracts, including `BorrowerOperations`, `TroveManager`, `YUSDToken`, `SortedTroves`, `CommunityIssuance`, `Whitelist`, and `ActivePool`. The logic for calculating and distributing rewards seems complex, involving epochs, scales, and error tracking to ensure accuracy."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""StabilityPool"",
    ""Purpose"": ""Manages YUSD deposits, offsets debt from liquidations, and distributes collateral and YETI rewards to depositors and front-ends."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""LiquityBase"",
        ""Ownable"",
        ""CheckContract"",
        ""IStabilityPool""
      ],
      ""Imports"": [
        ""./Interfaces/IBorrowerOperations.sol"",
        ""./Interfaces/IStabilityPool.sol"",
        ""./Interfaces/ITroveManager.sol"",
        ""./Interfaces/IYUSDToken.sol"",
        ""./Interfaces/ISortedTroves.sol"",
        ""./Interfaces/ICommunityIssuance.sol"",
        ""./Interfaces/IWhitelist.sol"",
        ""./Interfaces/IERC20.sol"",
        ""./Interfaces/IWAsset.sol"",
        ""./Dependencies/LiquityBase.sol"",
        ""./Dependencies/SafeMath.sol"",
        ""./Dependencies/LiquitySafeMath128.sol"",
        ""./Dependencies/Ownable.sol"",
        ""./Dependencies/CheckContract.sol"",
        ""./Dependencies/SafeERC20.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""troveManagerLiquidationsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the TroveManagerLiquidations contract.""
      },
      {
        ""Name"": ""whitelistAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the Whitelist contract.""
      },
      {
        ""Name"": ""borrowerOperations"",
        ""Type"": ""IBorrowerOperations"",
        ""Purpose"": ""Interface to the BorrowerOperations contract.""
      },
      {
        ""Name"": ""troveManager"",
        ""Type"": ""ITroveManager"",
        ""Purpose"": ""Interface to the TroveManager contract.""
      },
      {
        ""Name"": ""yusdToken"",
        ""Type"": ""IYUSDToken"",
        ""Purpose"": ""Interface to the YUSDToken contract.""
      },
      {
        ""Name"": ""communityIssuance"",
        ""Type"": ""ICommunityIssuance"",
        ""Purpose"": ""Interface to the CommunityIssuance contract for YETI issuance.""
      },
      {
        ""Name"": ""sortedTroves"",
        ""Type"": ""ISortedTroves"",
        ""Purpose"": ""Interface to the SortedTroves contract.""
      },
      {
        ""Name"": ""totalYUSDDeposits"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total amount of YUSD deposited in the Stability Pool.""
      },
      {
        ""Name"": ""totalColl"",
        ""Type"": ""newColls"",
        ""Purpose"": ""Struct containing the tokens and amounts of all collateral""
      },
      {
        ""Name"": ""deposits"",
        ""Type"": ""mapping(address => Deposit)"",
        ""Purpose"": ""Mapping of depositor addresses to their deposit information.""
      },
      {
        ""Name"": ""depositSnapshots"",
        ""Type"": ""mapping(address => Snapshots)"",
        ""Purpose"": ""Mapping of depositor addresses to their reward snapshots.""
      },
      {
        ""Name"": ""frontEnds"",
        ""Type"": ""mapping(address => FrontEnd)"",
        ""Purpose"": ""Mapping of front-end addresses to their registration information.""
      },
      {
        ""Name"": ""frontEndStakes"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Mapping of front-end addresses to their YUSD stake.""
      },
      {
        ""Name"": ""frontEndSnapshots"",
        ""Type"": ""mapping(address => Snapshots)"",
        ""Purpose"": ""Mapping of front-end addresses to their reward snapshots.""
      },
      {
        ""Name"": ""P"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Accumulated product of (1 - YUSDLossPerUnitStaked), used for reward calculation.""
      },
      {
        ""Name"": ""currentScale"",
        ""Type"": ""uint128"",
        ""Purpose"": ""Scale factor to maintain precision of P.""
      },
      {
        ""Name"": ""currentEpoch"",
        ""Type"": ""uint128"",
        ""Purpose"": ""Counter to store the number of times the product of (1 - YUSDLossPerUnitStaked) is less than SCALE_FACTOR. It represents the era of reward calculation.""
      },
      {
        ""Name"": ""epochToScaleToSum"",
        ""Type"": ""mapping(address => mapping(uint128 => mapping(uint128 => uint256)))"",
        ""Purpose"": ""Maps asset address, epoch and scale to the sum of AssetGainPerUnitStaked until that point.""
      },
      {
        ""Name"": ""epochToScaleToG"",
        ""Type"": ""mapping(uint128 => mapping(uint128 => uint256))"",
        ""Purpose"": ""Maps epoch and scale to accumulated YETI issuance.""
      },
      {
        ""Name"": ""lastYETIError"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Stores the accumulated error from calculating YETI per unit staked to propagate the error for next calculations.""
      },
      {
        ""Name"": ""lastAssetError_Offset"",
        ""Type"": ""uint256[]"",
        ""Purpose"": ""Stores the accumulated error from calculating Asset gains after offsetting for each collateral.""
      },
      {
        ""Name"": ""lastYUSDLossError_Offset"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Stores the accumulated error from calculating YUSD Loss during an offset.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the addresses of the external contracts and renounce ownership."",
        ""Parameters"": [
          ""_borrowerOperationsAddress"",
          ""_troveManagerAddress"",
          ""_activePoolAddress"",
          ""_yusdTokenAddress"",
          ""_sortedTrovesAddress"",
          ""_communityIssuanceAddress"",
          ""_whitelistAddress"",
          ""_troveManagerLiquidationsAddress""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""provideToSP"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to deposit YUSD into the Stability Pool."",
        ""Parameters"": [""_amount"", ""_frontEndTag""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawFromSP"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw YUSD from the Stability Pool."",
        ""Parameters"": [""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""offset"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Offsets debt from liquidations by burning YUSD and transferring collateral."",
        ""Parameters"": [""_debtToOffset"", ""_tokens"", ""_amountsAdded""],
        ""Returns"": []
      },
      {
        ""Name"": ""registerFrontEnd"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Registers a front-end with a specific kickback rate."",
        ""Parameters"": [""_kickbackRate""],
        ""Returns"": []
      },
      {
        ""Name"": ""receiveCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Receives collateral from the ActivePool after liquidations."",
        ""Parameters"": [""_tokens"", ""_amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addCollateralType"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a valid collateral token to the pool."",
        ""Parameters"": [""_collateral""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IBorrowerOperations"",
    ""ITroveManager"",
    ""IYUSDToken"",
    ""ISortedTroves"",
    ""ICommunityIssuance"",
    ""IWhitelist"",
    ""IActivePool"",
    ""IERC20"",
    ""IWAsset""
  ],
  ""SpecialMechanisms"": [
    ""Epoch and Scale-based reward calculation: Divides time into epochs and scales to handle reward calculation with precision."",
    ""Front-end tagging: Allows depositors to associate their deposits with a front-end, enabling kickback rewards."",
    ""Error tracking: Accumulates errors in reward calculations to distribute in next iterations.""
  ],
  ""Questions"": [
    ""What is the purpose of `troveManagerLiquidationsAddress`?"",
    ""Can a front-end deregister?"",
    ""What happens if the kickback rate is changed after deposits are made?"",
    ""How does the SCALE_FACTOR and currentScale affect the `P` value and reward calculations?"",
    ""The contracts relies on external contracts for critical functions.  How are these contracts secured and upgraded?"",
    ""The _leftSubColls and _leftSumColls functions are used for subtraction and addition of arrays, but the implementation is not provided. Need to verify those implementations to avoid potential overflow/underflow vulnerabilities or other incorrect array manipulation.""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unprotected `_renounceOwnership` call in `setAddresses`"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `setAddresses` function calls `_renounceOwnership()` at the end, permanently removing the owner of the contract and making it impossible to update critical parameters or recover from errors in the future. Once invoked, the contract is effectively immutable."",
      ""Impact"": ""Loss of control over the Stability Pool, inability to perform necessary upgrades or maintenance."",
      ""Location"": ""setAddresses function""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `_sendGainsToDepositor` and `provideToSP`/`withdrawFromSP`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_sendGainsToDepositor` function iterates through a list of collateral tokens and transfers them to the depositor. If one of these tokens is a malicious contract, the `safeTransfer` call can trigger a reentrancy attack, potentially allowing the attacker to drain funds from the StabilityPool. Additionally, `provideToSP` and `withdrawFromSP` interact with external contracts during their execution which could lead to a reentrancy attack, allowing the attacker to withdraw more than their fair share."",
      ""Impact"": ""Potential for malicious contracts to drain or manipulate funds in the StabilityPool through a reentrancy attack. Fund loss for depositors, potential draining of the Stability Pool."",
      ""Location"": ""_sendGainsToDepositor function, Functions `provideToSP` and `withdrawFromSP`, particularly the external calls in `_payOutYETIGains`, `_sendYUSDtoStabilityPool`, `_sendGainsToDepositor`, and `_sendYUSDToDepositor`.""
    },
    {
      ""Issue"": ""Incorrect Calculation or Missing Function for Collateral Amounts"",
      ""Severity"": ""High"",
      ""Description"": ""The contract is missing `_leftSubColls` and `_leftSumColls` functions required to subtract and add collateral amounts respectively from `totalColl.amounts`, or does not update the state correctly when certain conditions apply. Also, the incorrect calculation in `_getCompoundedStakeFromSnapshots` when `epochSnapshot < currentEpoch` can result in loss of user stake."",
      ""Impact"": ""It would mess with the calculation with totalColl available. Users lose their deposits if they don't interact with the contract frequently, leading to severe financial loss and trust issues."",
      ""Location"": ""_sendGainsToDepositor and receiveCollateral functions, StabilityPool.sol:627""
    },
    {
      ""Issue"": ""Potential Division by Zero in `_computeYETIPerUnitStaked`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_computeYETIPerUnitStaked` function calculates `YETIPerUnitStaked` by dividing `YETINumerator` by `_totalYUSDDeposits`. If `_totalYUSDDeposits` is zero, this will result in a division by zero error, causing the transaction to revert. This can occur even with checks in place if external actions lead to a zero value right before the division."",
      ""Impact"": ""Transaction reverts, denial of service. The `_triggerYETIIssuance` may fail when pool has no YUSD."",
      ""Location"": ""_computeYETIPerUnitStaked function""
    },
    {
      ""Issue"": ""Unbounded Loop in `_sendGainsToDepositor` when whitelist is compromised or has many wrapped assets"",
      ""Severity"": ""High"",
      ""Description"": ""In the `_sendGainsToDepositor` function, there's a loop that iterates through `assets` obtained from the whitelist or unwraps wrapped assets. If the whitelist is compromised and contains a very large number of collateral types, or if there are many wrapped assets with amounts to be unwrapped, the loop could consume significant gas, potentially leading to a denial-of-service (DoS) due to out-of-gas errors."",
      ""Impact"": ""Denial-of-service (DoS), rendering the Stability Pool unusable. Potential for griefing attacks."",
      ""Location"": ""_sendGainsToDepositor function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Reward Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple calculations within `_computeRewardsPerUnitStaked` and `_computeYETIPerUnitStaked` are vulnerable to integer overflow or underflow, especially with `YUSDLossNumerator`, `CollateralNumerators`, `AssetGainPerUnitStaked`, and `_YETIIssuance`. If input values are large enough, intermediate multiplication results could overflow, or subtraction results could underflow, leading to incorrect reward distribution. Also, make sure that `lastYETIError`, `lastAssetError_Offset` and `lastYUSDLossError_Offset` does not overflow or underflow. The `require` statement only checks `_debtToOffset <= _totalYUSDDeposits, but does not take care of overflow cases."",
      ""Impact"": ""Incorrect reward distribution, potential manipulation of the Stability Pool's internal state, financial loss for users, and system instability."",
      ""Location"": ""_computeRewardsPerUnitStaked and _computeYETIPerUnitStaked functions""
    },
    {
      ""Issue"": ""Incorrect accounting of `lastAssetError_Offset` can lead to unfair rewards distribution"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `lastAssetError_Offset` to compensate for rounding errors in the `_computeRewardsPerUnitStaked` function. However, the logic for calculating and updating `lastAssetError_Offset` and `lastYUSDLossError_Offset` is complex and prone to errors. A small error in these calculations can accumulate over time, leading to significant deviations in the intended rewards distribution, favoring or disadvantaging certain depositors."",
      ""Impact"": ""Unfair distribution of rewards among depositors, potentially leading to loss of trust and adoption. Inaccurate reward distribution, potential token loss for depositors, and unfair system."",
      ""Location"": ""_computeRewardsPerUnitStaked function""
    },
    {
      ""Issue"": ""Missing input validation can cause out-of-bounds write in `_computeRewardsPerUnitStaked` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `_computeRewardsPerUnitStaked` iterates through `amountsLen`. In the loop, `tokenIDX` is derived by calling `whitelist.getIndex(_tokens[i])`. If a token does not exist in the whitelist, `whitelist.getIndex()` can return a value equal to the whitelist array length, which causes `lastAssetError_Offset[tokenIDX]` to write outside the bounds of the `lastAssetError_Offset` array."",
      ""Impact"": ""This can cause the contract to behave in an unpredictable way."",
      ""Location"": ""StabilityPool.sol:_computeRewardsPerUnitStaked""
    },
    {
      ""Issue"": ""Lack of Access Control on `addCollateralType` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addCollateralType` function is protected by `_requireCallerIsWhitelist()`, which only checks if `msg.sender` is `whitelistAddress`. If the whitelist contract is compromised, an attacker could use it to add malicious collateral types, potentially leading to unexpected behavior or vulnerabilities."",
      ""Impact"": ""Potential for malicious or invalid collateral types to be added, leading to unforeseen consequences."",
      ""Location"": ""addCollateralType function""
    },
    {
      ""Issue"": ""Missing check for `_tokens.length == _amountsAdded.length` in `offset` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `offset` function, the code assumes that `_tokens` and `_amountsAdded` have the same length but does not explicitly check this condition. If these arrays have different lengths, it can lead to unexpected behavior and potentially out-of-bounds access when iterating through them in the subsequent calculations."",
      ""Impact"": ""Unexpected behavior, potential out-of-bounds access, and incorrect calculations."",
      ""Location"": ""offset function""
    },
    {
      ""Issue"": ""Logic Error or Precision Loss in Stake Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_getCompoundedStakeFromSnapshots` function returns 0 under certain conditions, such as when `scaleDiff` is greater than 1.  Also, if `compoundedStake` calculated is `less than initialStake.div(1e9)`, function will return 0 as well. This can lead to a significant loss of precision and can unfairly impact depositors, especially those who have been in the pool for a long time and have accumulated significant gains. Additionally, if `newProductFactor == 0` in `_updateRewardSumAndProduct`, some YETI gains may be lost."",
      ""Impact"": ""Depositors may receive zero rewards even if they are entitled to them, leading to dissatisfaction and potential loss of funds. Potential loss of YETI gains for users, leading to inaccurate reward distribution."",
      ""Location"": ""_getCompoundedStakeFromSnapshots function, _updateRewardSumAndProduct""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `_updateRewardSumAndProduct`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `currentP.mul(newProductFactor)` in `_updateRewardSumAndProduct` could overflow. "",
      ""Impact"": ""Incorrect `P` value, leading to inaccurate calculations of future rewards and potentially system instability."",
      ""Location"": ""StabilityPool.sol:330""
    },
    {
      ""Issue"": ""Incorrect use of sub function leads to unexpected result"",
      ""Severity"": ""Medium"",
      ""Description"": ""The result of the `sub` function is used as an index for the `amounts` array. If the result is greater than `amounts.length - 1`, the operation will result in out of gas error. And in func `_leftSubColls`, the result of `_existsInSlice(tokens, _tokens[i])` is used to determine the index to subtract. It returns `type(uint).max` when the target token is not found in the slice, which will certainly lead to out of gas error."",
      ""Impact"": ""It will lead to unexpected `out of gas error` when the target token is not found in the slice"",
      ""Location"": ""_leftSubColls func in LiquityBase.sol""
    },
    {
      ""Issue"": ""Lack of Protection Against Front Running in `registerFrontEnd`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `registerFrontEnd` function allows anyone to register as a front end with a specified `_kickbackRate`. There\'s no mechanism to prevent an attacker from front-running a legitimate front-end registration with a lower `_kickbackRate` to siphon off potential rewards."",
      ""Impact"": ""Minor financial impact to legitimate front ends.  An attacker could register slightly ahead of a legitimate front end and claim a portion of their rewards."",
      ""Location"": ""registerFrontEnd function""
    },
    {
      ""Issue"": ""Potential Division by Zero"",
      ""Severity"": ""Low"",
      ""Description"": ""Although there are checks in place, there's a possibility of division by zero if `_totalYUSDDeposits` is zero in `_computeYETIPerUnitStaked` after calling `_triggerYETIIssuance` or in `_computeRewardsPerUnitStaked` if `_totalYUSDDeposits` is zero. Even with checks for `totalYUSD == 0`, subsequent external actions may lead to a zero value for `_totalYUSDDeposits` right before the division."",
      ""Impact"": ""Transaction reverts, potential denial of service."",
      ""Location"": ""_computeYETIPerUnitStaked and _computeRewardsPerUnitStaked functions""
    },
    {
      ""Issue"": ""Potential denial-of-service (DoS) in `_updateRewardSumAndProduct` due to unbounded loop."",
      ""Severity"": ""Low"",
      ""Description"": ""The function `_updateRewardSumAndProduct` iterates through a list of `_assets`. If the whitelist contract returns an extremely long list of valid collateral, the gas cost of this loop could exceed the block gas limit, causing transactions to revert and effectively denying service to users who need to interact with the Stability Pool."",
      ""Impact"": ""Potential denial of service, preventing users from withdrawing or providing to the Stability Pool."",
      ""Location"": ""StabilityPool.sol:_updateRewardSumAndProduct""
    },
    {
      ""Issue"": ""Potential Rounding Errors in Reward Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""The reward calculations involve multiple multiplications and divisions, which can introduce rounding errors. The `lastYETIError`, `lastAssetError_Offset`, and `lastYUSDLossError_Offset` variables attempt to compensate for these errors. However, repeated rounding errors can still accumulate over time, especially if the total YUSD deposits are small relative to the reward amounts, potentially resulting in unfair distribution of rewards to users."",
      ""Impact"": ""Slightly unfair reward distribution, potential loss of precision, and minor token imbalances."",
      ""Location"": ""_computeYETIPerUnitStaked, _computeRewardsPerUnitStaked, _calculateGains""
    },
    {
      ""Issue"": ""Use of delete operator for snapshot clearing can be expensive"",
      ""Severity"": ""Low"",
      ""Description"": ""The delete operator is used to clear deposit snapshots when `_newValue == 0` in `_updateDepositAndSnapshots`.  While functionally correct, using `delete` on storage mappings can be gas-intensive."",
      ""Impact"": ""Higher gas costs for users when clearing deposits."",
      ""Location"": ""_updateDepositAndSnapshots function""
    },
    {
      ""Issue"": ""Stale Snapshot Data"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getDepositorGains` function relies on snapshots of `S`, `P`, and `G`. If a depositor hasn't interacted with the Stability Pool for a long time, their snapshot data could be significantly outdated, leading to incorrect gain calculations."",
      ""Impact"": ""Inaccurate gain calculations for inactive depositors."",
      ""Location"": ""StabilityPool.sol:463""
    },
    {
      ""Issue"": ""Unbounded `lastAssetError_Offset` Array"",
      ""Severity"": ""Low"",
      ""Description"": ""The `lastAssetError_Offset` array grows without bound in the `addCollateralType` function. A very large number of collateral types could lead to excessive gas costs for certain operations. A check should be added to avoid duplication of tokens."",
      ""Impact"": ""Potential increase in gas costs over time."",
      ""Location"": ""StabilityPool.sol:719""
    }
  ],
  ""IssueNumber"": 50,
  ""OutputList"": 20
}",173.5454981327057,3691.0,29.0,"### **Output**

---

**[H-01] receiveCollateral() can be called by anyone**

**Report Description**:
In `StabilityPool.sol`, the `receiveCollateral()` function is intended to be called exclusively by the `ActivePool` contract, as indicated by the comments. However, the function lacks access control, allowing anyone to call it by passing `_tokens` and `_amounts` arguments. This can lead to unauthorized updates to the stability pool balances, potentially disrupting the system's integrity and causing financial discrepancies.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of missing access control in the `receiveCollateral()` function. None of the findings in the response list mention this specific vulnerability or its impact on the stability pool balances. This is a critical oversight, as unauthorized access to such a function can lead to significant security risks and financial losses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-01] receiveCollateral() can be called by anyone**

---

### **Conclusion**
The response list fails to address the issue of missing access control in the `receiveCollateral()` function, which is a significant security vulnerability. This oversight highlights a gap in the coverage of the response list, as it does not account for improper access control mechanisms in the contract. Addressing this issue is crucial to ensure the integrity and security of the stability pool.","```
None.
```",0.0
sYetiToken.sol,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}

// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)
// modified by BoringCrypto for DictatorDAO


// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 
// Each rebase increases the effective yetibalance by a certain amount of the total value
// of the contract, which is equal to the yusd balance + the last price which the buyback 
// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200
// of the total value of the contract is added to the effective yetibalance. Also updated on 
// mint and withdraw, because that is actual value that is added to the contract. 

contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain
    // and do that one. 
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    /// @notice owner > balance mapping.
    mapping(address => User) public users;
    /// @notice owner > spender > allowance mapping.
    mapping(address => mapping(address => uint256)) public override allowance;
    /// @notice owner > nonce mapping. Used in `permit`.
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); // Moved down so other failed calls safe some gas
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; // Underflow is checked
                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; // Underflow is checked
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.
    /// @param to The address to move the tokens.
    /// @param shares of the tokens to move.
    /// @return (bool) Returns True if succeeded.
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.
    /// @param from Address to draw tokens from.
    /// @param to The address to move the tokens.
    /// @param shares The token shares to move.
    /// @return (bool) Returns True if succeeded.
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18
    /// theoretically you can grow the amount/share ratio, but it's not practical and useless
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    /** 
     * Buyback function called by owner of function. Keeps track of the 
     */
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    /** 
     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.
     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock 
     * in order to activate. 
     * No YUSDToSell param since this just does 5% of the YUSD in the contract.
     */
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        // Get 5% of the YUSD in the contract
        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. 
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        // Checks internal mapping to see if router is valid
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    // Rebase function for adding new value to the sYETI - YETI ratio. 
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns 
        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance

        // raw balance of the contract
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        // amount of YETI free / available to give out
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        // in YETI, amount that should be eligible to give out.
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        // in YETI, amount to rebase
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. 
        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        // rebase amount joins the effective supply. 
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        // update rebase time
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    // Sums YUSD balance + old price. 
    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI 
    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    // Sets new transfer ratio for rebasing
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    // TODO - add time delay for setting new valid router. 
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    // TODO - add time delay for invalidating router. 
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    // Safe divide
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",3595,338,"[H-02] Yeti token rebase checks the additional token amount incorrectly

function `rebuse`, `effectiveYetiTokenBalance`
`yetiToken.balance - effectiveYetiTokenBalance`â€¨
The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added toÂ effectiveYetiTokenBalanceÂ during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.
The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total usersâ€™ claims. In other words, the contract will be in default if enough users claim after that.

[M-01] WrongÂ lastBuyBackPrice

Submitted by cmichel
TheÂ sYETIToken.lastBuyBackPriceÂ is set inÂ buyBackÂ and hardcoded as:
function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {
    require(YUSDToSell > 0, ""Zero amount"");
    require(lastBuybackTime + 69 hours < block.timestamp, ""Must have 69 hours pass before another buyBack"");
    yusdToken.approve(routerAddress, YUSDToSell);
    uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);
    lastBuybackTime = block.timestamp;
    // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]
    // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)
    lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
    emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]);
}

It divides the first and second returnÂ amountsÂ of the swap, however, these amounts depend on the swapÂ pathÂ parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).
",2,,"pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}












contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    
    
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    
    mapping(address => User) public users;
    
    mapping(address => mapping(address => uint256)) public override allowance;
    
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); 
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; 
                users[to].balance = toUser.balance + shares128; 
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; 
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    
    
    
    
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    
    
    
    
    
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    
    
    
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    
    
    
    
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    
    
    
    
    
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    
    
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); 
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        
        
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        
        

        
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        
        
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    
    
    
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",2343,1,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Ownership"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is correctly implemented in `BoringOwnable.sol` and used appropriately throughout the contract, especially for critical functions like `setAddresses`, `buyBack`, `publicBuyBack`, `setTransferRatio`, `addValidRouter`, and `removeValidRouter`."",
        ""Confirm that the contract owner is initialized correctly upon deployment."",
        ""Analyze the impact of potential owner key compromise and define mitigation strategies."",
        ""Check for any unintended side effects or vulnerabilities introduced by the `BoringOwnable` implementation."",
        ""Review the onlyOwner modifier's usage for consistency in all sensitive functions.""
      ]
    },
    {
      ""Area"": ""Rebasing Mechanism"",
      ""Tasks"": [
        ""Analyze the `rebase` function to ensure the `effectiveYetiTokenBalance` is updated correctly and that the rebasing logic doesn't lead to unexpected inflation or deflation."",
        ""Investigate potential vulnerabilities related to the `_getValueOfContract` function, specifically the reliance on `lastBuybackPrice`. Assess if this price can be manipulated to influence the rebase amount."",
        ""Evaluate the impact of large YUSD balance fluctuations on the `_getValueOfContract` function and the rebasing mechanism."",
        ""Examine the timing constraint on the `rebase` function (8 hours) and assess its impact on tokenomics and user experience."",
        ""Simulate different scenarios for rebase calculations to confirm expected behavior.""
      ]
    },
    {
      ""Area"": ""Buyback Mechanism"",
      ""Tasks"": [
        ""Scrutinize the `buyBack` and `publicBuyBack` functions to ensure that the YUSD is being used effectively to buy back YETI tokens, and that the `_YETIOutMin` parameter is handled correctly to prevent slippage issues."",
        ""Assess the potential risks associated with relying on external routers (`IsYETIRouter`) for buybacks. Verify that only trusted routers are added to `validRouters` and that the `swap` function is implemented securely in the router contract."",
        ""Evaluate the potential for front-running attacks on the `publicBuyBack` function, given the 169-hour time constraint."",
        ""Review the YUSD approval process in the `_buyBack` function to ensure that it's secure and doesn't introduce any vulnerabilities related to token approvals."",
        ""Simulate buyback scenarios with different router implementations to check the resilience.""
      ]
    },
    {
      ""Area"": ""Token Locking and Transfer Restrictions"",
      ""Tasks"": [
        ""Verify that the `LOCK_TIME` mechanism (69 hours) is correctly implemented and enforced in the `_transfer`, `mint`, `_burn`, `burn`, and `burnFrom` functions."",
        ""Assess the impact of the token locking mechanism on user experience and liquidity."",
        ""Check for any potential loopholes or bypass methods for the locking mechanism."",
        ""Review whether the locking time is configurable or fixed, and analyze the potential impact of that choice.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflow/Underflow"",
      ""Tasks"": [
        ""Although BoringMath is used, confirm that all arithmetic operations are safe from overflow and underflow, especially in functions like `_transfer`, `mint`, `_burn`, rebase calculations, and allowance management."",
        ""Specifically check the conversions to and from uint128 in the User struct.""
      ]
    },
    {
      ""Area"": ""Permit Function"",
      ""Tasks"": [
        ""Carefully review the `permit` function for potential vulnerabilities related to signature verification and replay attacks. Ensure that the nonce mechanism (`nonces`) is implemented correctly and prevents unauthorized allowance approvals."",
        ""Verify the correctness of the `_getDigest` function (inherited from Domain.sol) and its usage in the `permit` function."",
        ""Analyze the security implications of using `ecrecover` for signature verification."",
        ""Ensure that the PERMIT_SIGNATURE_HASH is correctly computed and used."",
        ""Write a test to verify that the permit function works as expected with different owners, spenders and values.""
      ]
    },
    {
      ""Area"": ""Minting and Burning Mechanics"",
      ""Tasks"": [
        ""Analyze the `mint` function to ensure that the share calculation `(amount * totalSupply) / effectiveYetiTokenBalance` is correct and doesn't lead to unexpected token inflation."",
        ""Scrutinize the `_burn` function to confirm that the `amount` calculation `(shares * effectiveYetiTokenBalance) / totalSupply` is accurate and prevents users from burning more tokens than they own."",
        ""Examine potential attack vectors if a user can manipulate the `totalSupply` or `effectiveYetiTokenBalance` to gain an unfair advantage during minting or burning."",
        ""Consider cases where totalSupply or effectiveYetiTokenBalance are very small values during minting.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Audit all external calls to other contracts (e.g., `yetiToken.sendToSYETI`, `yetiToken.transfer`, `yusdToken.balanceOf`, `yusdToken.approve`, `yusdToken.increaseAllowance`, `IsYETIRouter.swap`) to ensure they are secure and don't introduce any reentrancy vulnerabilities or unexpected behavior."",
        ""Verify that the contract addresses for `yetiToken`, `yusdToken`, and the routers are properly validated and can't be maliciously set to incorrect addresses."",
        ""Specifically analyze the `IsYETIRouter.swap` interaction to ensure that the router contract is trustworthy and doesn't introduce any security risks."",
        ""Implement checks for return values on external calls (where applicable) to prevent unexpected failures."",
        ""Review the `sendToSYETI` function in the IYETIToken interface and understand its function and security implications""
      ]
    },
    {
      ""Area"": ""Division by Zero"",
      ""Tasks"": [
        ""Verify that the internal `div` function is used correctly in calculations where division by zero could occur, preventing unexpected errors."",
        ""Check all other division operations for missing division by zero checks, despite the inclusion of the `div` helper function.""
      ]
    },
    {
      ""Area"": ""Unhandled Exceptions"",
      ""Tasks"":[
        ""The IERC20 interface doesn't revert automatically, so if an operation fails, it returns false. Check that the functions in the router don't have side-effects after a `false` return value, and that these `false` returns are handled correctly""
      ]
    },
     {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the contract's gas usage and identify areas for optimization. Focus on frequently called functions like `transfer`, `mint`, `burn`, and `rebase`. Consider using assembly or other optimization techniques to reduce gas costs."",
        ""Evaluate the storage patterns to minimize gas costs associated with state variable updates."",
        ""Review the use of libraries like BoringMath and BoringERC20 to ensure they are being used efficiently."",
        ""Check for redundant calculations or operations that can be eliminated to save gas.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines an sYETIToken contract which is a staked version of the YETIToken. It implements rebasing and buyback mechanisms. The contract inherits from Domain and BoringOwnable, and uses the BoringMath, BoringMath128, and BoringERC20 libraries for arithmetic and ERC20 functionalities."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""sYETIToken"",
    ""Purpose"": ""Implementation of a staked YETI token that implements rebasing and buyback mechanisms."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""IERC20"", ""Domain"", ""BoringOwnable""],
      ""Imports"": [
        ""./BoringCrypto/BoringMath.sol"",
        ""./BoringCrypto/BoringERC20.sol"",
        ""./BoringCrypto/Domain.sol"",
        ""./BoringCrypto/ERC20.sol"",
        ""./BoringCrypto/IERC20.sol"",
        ""./BoringCrypto/BoringOwnable.sol"",
        ""./IsYETIRouter.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""symbol"",
        ""Type"": ""string"",
        ""Purpose"": ""Token symbol""
      },
      {
        ""Name"": ""name"",
        ""Type"": ""string"",
        ""Purpose"": ""Token name""
      },
      {
        ""Name"": ""decimals"",
        ""Type"": ""uint8"",
        ""Purpose"": ""Token decimals""
      },
      {
        ""Name"": ""totalSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total supply of the token""
      },
      {
        ""Name"": ""LOCK_TIME"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Time duration for locking tokens (69 hours)""
      },
      {
        ""Name"": ""effectiveYetiTokenBalance"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Effective balance of YETI tokens""
      },
      {
        ""Name"": ""lastBuybackTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last buyback""
      },
      {
        ""Name"": ""lastBuybackPrice"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Price of YETI in YUSD during the last buyback""
      },
      {
        ""Name"": ""lastRebaseTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last rebase""
      },
      {
        ""Name"": ""transferRatio"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Ratio used in rebase calculation""
      },
      {
        ""Name"": ""yetiToken"",
        ""Type"": ""IYETIToken"",
        ""Purpose"": ""Address of the YETI token contract""
      },
      {
        ""Name"": ""yusdToken"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""Address of the YUSD token contract""
      },
      {
        ""Name"": ""addressesSet"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to check if addresses have been set""
      },
      {
        ""Name"": ""validRouters"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Mapping of valid router addresses for buybacks""
      },
      {
        ""Name"": ""users"",
        ""Type"": ""mapping(address => User)"",
        ""Purpose"": ""Mapping of user balances and lock times""
      },
      {
        ""Name"": ""allowance"",
        ""Type"": ""mapping(address => mapping(address => uint256))"",
        ""Purpose"": ""Mapping of token allowances for spenders""
      },
      {
        ""Name"": ""nonces"",
        ""Type"": ""mapping(address => uint256)"",
        ""Purpose"": ""Mapping of nonces for permit function""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""balanceOf"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the balance of a user"",
        ""Parameters"": [""address user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the addresses of YETI and YUSD tokens"",
        ""Parameters"": [""IYETIToken _yeti"", ""IERC20 _yusd""],
        ""Returns"": []
      },
      {
        ""Name"": ""_transfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function for transferring tokens"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 shares""],
        ""Returns"": []
      },
      {
        ""Name"": ""_useAllowance"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function for managing allowances"",
        ""Parameters"": [""address from"", ""uint256 shares""],
        ""Returns"": []
      },
      {
        ""Name"": ""transfer"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers tokens from the sender to a recipient"",
        ""Parameters"": [""address to"", ""uint256 shares""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""transferFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Transfers tokens from one address to another using allowance"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 shares""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""approve"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Approves a spender to spend tokens on behalf of the sender"",
        ""Parameters"": [""address spender"", ""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""increaseAllowance"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Increases the allowance of a spender"",
        ""Parameters"": [""address spender"", ""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""DOMAIN_SEPARATOR"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the domain separator"",
        ""Parameters"": [],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""permit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows approving an allowance via signature"",
        ""Parameters"": [
          ""address owner_"",
          ""address spender"",
          ""uint256 value"",
          ""uint256 deadline"",
          ""uint8 v"",
          ""bytes32 r"",
          ""bytes32 s""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""mint"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mints sYETI tokens"",
        ""Parameters"": [""uint256 amount""],
        ""Returns"": [""bool""]
      },
       {
        ""Name"": ""_burn"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Burns sYETI tokens"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 shares""],
        ""Returns"": []
      },
      {
        ""Name"": ""burn"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns sYETI tokens for the caller"",
        ""Parameters"": [""address to"", ""uint256 shares""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""burnFrom"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Burns sYETI tokens on behalf of another user, if allowance allows"",
        ""Parameters"": [""address from"", ""address to"", ""uint256 shares""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""buyBack"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Executes a buyback of YETI tokens using YUSD"",
        ""Parameters"": [""address _routerAddress"", ""uint256 _YUSDToSell"", ""uint256 _YETIOutMin""],
        ""Returns"": []
      },
      {
        ""Name"": ""publicBuyBack"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to execute a buyback after a certain time"",
        ""Parameters"": [""address _routerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""_buyBack"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function for executing the buyback"",
        ""Parameters"": [""address _routerAddress"", ""uint256 _YUSDToSell"", ""uint256 _YETIOutMin""],
        ""Returns"": []
      },
      {
        ""Name"": ""rebase"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Rebases the token supply"",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_getValueOfContract"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the value of the contract in YETI tokens"",
        ""Parameters"": [""uint _adjustedYetiTokenBalance""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""setTransferRatio"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the transfer ratio"",
        ""Parameters"": [""uint256 newTransferRatio""],
        ""Returns"": []
      },
      {
        ""Name"": ""addValidRouter"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a valid router address"",
        ""Parameters"": [""address _routerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""removeValidRouter"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes a valid router address"",
        ""Parameters"": [""address _routerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""div"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Performs division with a require statement to prevent division by zero"",
        ""Parameters"": [""uint256 a"", ""uint256 b""],
        ""Returns"": [""uint256 c""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IYETIToken.sendToSYETI()"",
    ""IYETIToken.transfer()"",
    ""IERC20.balanceOf()"",
    ""IERC20.approve()"",
    ""IERC20.increaseAllowance()"",
    ""IsYETIRouter.swap()"",
    ""yusdToken.balanceOf()"",
    ""yusdToken.approve()"",
    ""yusdToken.increaseAllowance()""
  ],
  ""SpecialMechanisms"": [
    ""Rebasing: Adjusts token balances based on the value of the contract."",
    ""Buyback: Uses YUSD to buy back YETI tokens."",
    ""Permit: Allows approving an allowance via signature (EIP-2612)."",
    ""Token Locking: Users are locked for a specific amount of time after minting.""
  ],
  ""Questions"": [
    ""What is the exact purpose of the sendToSYETI() function in the IYETIToken interface? How is it different from transfer()?"",
    ""How frequently is the rebase function intended to be called and what triggers it?"",
    ""What are the security implications of relying on the lastBuybackPrice for rebase calculations? Could this be manipulated?"",
    ""Is there a potential attack vector if the IsYETIRouter contract is malicious, given the buyBack functions?"",
    ""Why is there a public buyback that can be executed after 169 hours, does that make it easier to grief the protocol?"",
    ""In the burn and _burn functions, the address 'to' is passed as a parameter, and it must not be a zero address. However, the tokens are being burned to address(0). What is the 'to' parameter actually for in this context?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Re-entrancy Vulnerability in `_buyBack` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_buyBack` function calls an external contract (`IsYETIRouter(_routerAddress).swap`), which can lead to a re-entrancy vulnerability. A malicious router can call back into the `sYETIToken` contract before the `_buyBack` function completes, potentially manipulating the state of the contract. Several issues identify this re-entrancy risk, where the `swap` function could re-enter and call buyBack again before states are properly updated, potentially draining the contract. Additionally, this can lead to incorrect `lastBuybackPrice` calculations and potential manipulation of contract's state."",
      ""Impact"": ""Loss of funds, contract compromise. Possible theft of funds from the contract or disruption of contract functionality."",
      ""Location"": ""`_buyBack` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in User Balance Management and Calculations"",
      ""Severity"": ""High"",
      ""Description"": ""The `User` struct uses `uint128` for `balance` and `lockedUntil`.  Despite using `BoringMath` and `BoringMath128`, conversions from `uint256` to `uint128` in `mint` and `_transfer`, and arithmetic operations in `_burn` and `_transfer` functions can lead to overflow/underflow if values are too large or small relative to the data types. Integer overflow/underflow in `mint` could allow a user to mint more tokens than intended or cause balance wraps around. Also, the `totalSupply` variable is a `uint256`, When minting, a large amount could cause overflow before being converted to `uint128` for the user\'s balance."",
      ""Impact"": ""Incorrect balance calculations, potential loss of funds, unauthorized minting, bypassing lockup restrictions, and overall system instability.  Severe devaluation of existing sYETI tokens due to uncontrolled inflation."",
      ""Location"": ""`mint` function, `_transfer` function, `_burn` function""
    },
    {
      ""Issue"": ""Unprotected Mint Function Leading to Inflation"",
      ""Severity"": ""High"",
      ""Description"": ""The `mint` function, responsible for creating new sYETI tokens, is publicly accessible, but it should only be callable by a trusted actor/contract. If `mint` is accidentally or maliciously called with a large `amount`, it will dilute the existing token supply, effectively stealing value from existing sYETI holders. This is a critical security flaw."",
      ""Impact"": ""Severe devaluation of existing sYETI tokens due to uncontrolled inflation. Potential for malicious actors to exploit the mint function for personal gain."",
      ""Location"": ""sYETIToken.sol:mint""
    },
    {
      ""Issue"": ""Rebase Logic Vulnerability and Lack of Access Control"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `rebase` function aims to adjust the `effectiveYetiTokenBalance` based on the contract's value. The calculation of `valueOfContract` relies on `lastBuybackPrice`. If `lastBuybackPrice` is manipulated or becomes stale, the calculated `amountYetiToRebase` might be incorrect, potentially leading to incorrect increases in `effectiveYetiTokenBalance`. Also, the `rebase` function can be called by anyone subject only to the time constraint, making it possible for malicious actors to call this function at an inopportune time to influence the value of the contract and potentially dilute existing users."",
      ""Impact"": ""Potential for inaccurate adjustments to `effectiveYetiTokenBalance`, leading to inconsistencies in the system and dilution of existing sYETI holders. Reliance on a possibly stale or manipulated `lastBuybackPrice` introduces a vulnerability."",
      ""Location"": ""sYETIToken.sol:rebase, sYETIToken.sol:_getValueOfContract, rebase() function""
    },
    {
      ""Issue"": ""Lack of Slippage Control in `_buyBack` and `publicBuyBack` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_buyBack` function takes a `_YETIOutMin` parameter, but there is no guarantee that the Router will meet that minimum. The `publicBuyBack` function sets `_YETIOutMin` to 0. This means there is no minimum amount of YETI tokens guaranteed to be received for the YUSD sold. Malicious actors could front-run the transaction, causing the swap to execute at a significantly worse rate, potentially draining a substantial amount of YUSD with minimal YETI received in return."",
      ""Impact"": ""Potential loss of funds due to unfavorable market conditions or front-running attacks during buyback. The contract may receive less YETI than expected for the YUSD sold, resulting in a loss of value for token holders."",
      ""Location"": ""`_buyBack` function, `publicBuyBack` function""
    },
    {
      ""Issue"": ""Possible Denial of Service (DoS) in `buyBack` functions due to `approve` gas costs"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_buyBack` function calls `yusdToken.approve(_routerAddress, 0)` before approving the actual amount. Resetting the approval to zero requires more gas than setting it directly to the desired amount when the allowance is non-zero.  In scenarios with high gas prices, this could make the `buyBack` transaction fail and halt the buyback mechanism."",
      ""Impact"": ""The owner may not be able to perform buybacks when needed, especially during periods of high network congestion and gas prices. Also, this extra gas consumption costs more to the owner."",
      ""Location"": ""`sYETIToken.sol:223`""
    },
    {
      ""Issue"": ""Approval Manipulation in `_buyBack` Function and Unchecked Return Value"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_buyBack` function attempts to set allowance by first calling `approve(address(router), 0)` and then `increaseAllowance(address(router), amount)`. Some ERC20 tokens will revert when calling approve with a zero amount. An attacker can front-run this transaction and approve the router for a large amount before the `_buyBack` transaction is executed. Also the `approve` function returns a boolean indicating success or failure. Failing to check this return value means the transaction could proceed even if the approval fails."",
      ""Impact"": ""Buyback failure, unexpected behavior, or the router contract, if malicious or compromised, could transfer more YUSD than intended from the `sYETIToken` contract, leading to a loss of funds."",
      ""Location"": ""`_buyBack` function""
    },
    {
      ""Issue"": ""Reliance on External `IsYETIRouter` Interface Without Proper Validation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_buyBack` function depends on an external contract implementing the `IsYETIRouter` interface. The behavior of this external contract is not fully controlled by the `sYETIToken` contract. If the `swap` function in `IsYETIRouter` is vulnerable, the `sYETIToken` contract could be exploited. There is no further validation that the contract at `_routerAddress` actually implements the `IsYETIRouter` interface correctly."",
      ""Impact"": ""Potential vulnerability stemming from reliance on external contract's security and Risk of losing YUSD balance to a malicious router contract, potential manipulation of buyback data."",
      ""Location"": ""`_buyBack` function""
    },
    {
      ""Issue"": ""Unprotected Critical Parameters After Initial Setup and Missing Zero Address Check"",
      ""Severity"": ""Medium"",
      ""Description"": ""After the `setAddresses` function is called, the `yetiToken` and `yusdToken` addresses are set, which is good. However, there is no mechanism to update these token addresses if needed, or for any migration scenario. If the YETI or YUSD token were to be upgraded or replaced, the `sYETIToken` contract would be stuck using the old token contracts. A similar issue exists with `LOCK_TIME`, `transferRatio` and the `validRouters`. There is no check to ensure that `_yeti` and `_yusd` are not set to the zero address."",
      ""Impact"": ""The lack of a mechanism to update these addresses if necessary can lead to a permanent loss of functionality or token lockup if the associated tokens are upgraded or replaced. Contract will be unusable if set to zero address"",
      ""Location"": ""`sYETIToken.sol:75`, `sYETIToken.sol:121`, `setAddresses` function.""
    },
    {
      ""Issue"": ""Potential Front Running in `publicBuyBack` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `publicBuyBack` function can be front-run. An attacker can monitor the mempool for transactions calling `publicBuyBack` and submit their own transaction with a higher gas price to be executed first. This can allow the attacker to profit from the buyback at the expense of other users, manipulate the YUSDBalance, or cause the contract to receive less YETI in the swap."",
      ""Impact"": ""Loss of funds for users and Unfavorable execution of `publicBuyBack`, potential for loss of funds, and unfair distribution of value, or Reduced return for the contract when executing a public buyback."",
      ""Location"": ""`publicBuyBack` function""
    },
    {
      ""Issue"": ""Approve-then-TransferFrom Front-Running Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The standard ERC20 `approve` and `transferFrom` pattern is susceptible to a front-running attack. An attacker can front-run a `transferFrom` call after the allowance has been approved but before the `transferFrom` is executed. This can lead to unexpected behavior and potentially loss of funds for the user who approved the allowance."",
      ""Impact"": ""Potential for attackers to steal tokens by front-running `transferFrom` transactions."",
      ""Location"": ""sYETIToken.sol: `approve`, `transferFrom`""
    },
    {
      ""Issue"": ""Inconsistent Rounding of `shares` during mint and rounding errors during mint"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `mint` function, `uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;`  If `totalSupply` is 0, `shares` equals `amount`. However, if `totalSupply` is non-zero, then `shares` is calculated as `(amount * totalSupply) / effectiveYetiTokenBalance`. This can lead to inconsistencies in the number of `sYETI` tokens received when minting and  Due to integer division, this calculation can lead to rounding errors, especially when `amount` or `totalSupply` are relatively small compared to `effectiveYetiTokenBalance`."",
      ""Impact"": ""Inconsistent share calculation affects users differently based on when they mint. Early minters will receive more shares for the same amount of underlying tokens. Slight inaccuracies in sYETI token distribution, potentially disadvantaging smaller stakeholders."",
      ""Location"": ""sYETIToken.sol:mint""
    },
    {
      ""Issue"": ""Incorrectly calculated time for `publicBuyBack`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `publicBuyBack` requires `lastBuybackTime + 169 hours < block.timestamp`, meaning that the public buyback can be done 169 hours *after* the last buyback time. This is an unusual amount of time, and should be checked to ensure it is correct, especially because `LOCK_TIME` uses 69 hours."",
      ""Impact"": ""Incorrectly calculated time for `publicBuyBack`"",
      ""Location"": ""sYETIToken.sol:publicBuyBack""
    },
    {
      ""Issue"": ""Potential division by zero in `_getValueOfContract`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_getValueOfContract` function contains the line `return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);`. If `lastBuybackPrice` is ever set to zero, this division will cause the transaction to revert. Even though `lastBuybackPrice` is updated inside the `_buyBack` function which requires `_YUSDToSell != 0`, the initial value of `lastBuybackPrice` is not initialized in the contract\'s constructor or through any other dedicated mechanism. Therefore, until the first successful buyback, the value will be `0`, and a call to `_getValueOfContract` and, therefore, `rebase` will fail."",
      ""Impact"": ""Rebase functionality will be broken until a buyBack is executed. This can temporarily halt the intended tokenomics of the token."",
      ""Location"": ""`_getValueOfContract` function (line 161), `_buyBack` function (line 152)""
    },
    {
      ""Issue"": ""Missing input validation in `addValidRouter` and `removeValidRouter`"",
      ""Severity"": ""Low"",
      ""Description"": ""While `addValidRouter` checks for zero address, there is no check to prevent adding the same router address multiple times or removing a router address that is not already validated."",
      ""Impact"": ""Although this doesn\'t directly introduce security vulnerability, it could lead to confusion and increase gas costs."",
      ""Location"": ""`sYETIToken.sol:279`, `sYETIToken.sol:284`""
    },
    {
      ""Issue"": ""Timestamp Dependence in `LOCK_TIME`"",
      ""Severity"": ""Low"",
      ""Description"": ""The locking mechanism relies on `block.timestamp`. While this is generally acceptable, it\'s important to be aware that miners can have a small degree of control over the timestamp, which could potentially be exploited in edge cases, though it is extremely rare."",
      ""Impact"": ""Slight manipulation of lock times possible, but unlikely."",
      ""Location"": ""`mint` and `_burn` functions""
    },
    {
      ""Issue"": ""Potential denial of service on `permit`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `permit` function increments `nonces[owner_]` every time it is called, regardless of whether the permit succeeds or fails. If a malicious actor spams the `permit` function with invalid signatures, they can exhaust the nonce space for a given owner, effectively preventing them from using the `permit` function. "",
      ""Impact"": ""Owner can no longer use the `permit` function, denial of service"",
      ""Location"": ""`permit` function""
    },
    {
      ""Issue"": ""Precision Loss in `lastBuybackPrice` calculation and Divisions done without using BoringMath Lib"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract calculates `lastBuybackPrice` using `div(amounts[0].mul(1e18), amounts[1])`. If `amounts[1]` is very large compared to `amounts[0]`, the division could result in significant precision loss due to integer division.Also The div function, doesn\'t use BoringMath library which would have safer implementation."",
      ""Impact"": ""The `_getValueOfContract` function uses `lastBuybackPrice`. Inaccurate representation of the `lastBuybackPrice` will cause a miscalculation of value of the contract and will impact the `rebase` function.gas optimisation"",
      ""Location"": ""`sYETIToken.sol:226`, `div`""
    },
    {
      ""Issue"": ""Unnecessary Approvals in `_buyBack`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_buyBack` function performs `require(yusdToken.approve(_routerAddress, 0))` before increasing the allowance.  This is a redundant step, as increasing the allowance will overwrite the previous value.  This adds unnecessary gas costs to the transaction."",
      ""Impact"": ""Slightly increased gas costs for buyback transactions."",
      ""Location"": ""sYETIToken.sol: `_buyBack`""
    },
    {
      ""Issue"": ""Unprotected Modification of `transferRatio`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferRatio` which plays a pivotal role in `rebase` calculations, is only checked to be non-zero and less than equal to `1e18`. While only the owner can change the ratio, an accidental or malicious update of this ratio by the owner can have significant effects on the `rebase` and overall value of contract. There aren\'t sufficient guardrails to ensure its modification is done after careful evaluation of its impacts. Also, it is not clear in the contract why it's named `transferRatio`."",
      ""Impact"": ""Potentially significant miscalculation of `amountYetiToRebase` in `rebase` function which may affect how minting and burning are handled."",
      ""Location"": ""`setTransferRatio` function""
    }
  ],
  ""IssueNumber"": 73,
  ""OutputList"": 17
}",266.5099699497223,4451.0,41.0,"### **[H-02] Yeti token rebase checks the additional token amount incorrectly**

**Report Description**:
The `rebase` function in the contract incorrectly calculates the additional token amount by using the entire balance of Yeti tokens instead of the tokens bought back from the market. This oversight can lead to an overestimation of the `effectiveYetiTokenBalance`, as the amount added during rebase may exceed the actual amount of Yeti tokens owned by the contract. This discrepancy can materialize in net worth terms if the price of Yeti tokens increases, leading to a situation where users' claims exceed the contract's actual holdings. This could result in the contract being in default if enough users attempt to withdraw their tokens.

**Match in Response List**:
Matches with the issue titled **""Rebase Logic Vulnerability and Lack of Access Control""**.

**Validation**:
**Partially Correct**. The response identifies the issue with the `rebase` function and the reliance on `lastBuybackPrice`, which is relevant to the problem. However, it does not explicitly address the core issue of the incorrect calculation of the additional token amount using the entire balance instead of the tokens bought back from the market. The response focuses more on the potential manipulation of `lastBuybackPrice` and the lack of access control, which, while related, does not fully cover the specific vulnerability described in the issue report.

---

### **[M-01] Wrong `lastBuyBackPrice`**

**Report Description**:
The `lastBuyBackPrice` is calculated incorrectly in the `buyBack` function. The calculation assumes a swap path of length 2, dividing the first and second return amounts of the swap. However, if a swap path of length 3 is used, this calculation is incorrect. Additionally, the calculation assumes that all routers sort the pairs the same way, which may not always be true. This can lead to incorrect pricing data being used in the contract, potentially affecting the `rebase` function and other calculations that rely on `lastBuyBackPrice`.

**Match in Response List**:
Matches with the issue titled **""Precision Loss in `lastBuybackPrice` calculation and Divisions done without using BoringMath Lib""**.

**Validation**:
**Incorrect**. The response discusses precision loss in the calculation of `lastBuybackPrice` and the use of integer division, but it does not address the core issue of the incorrect calculation when using a swap path of length 3 or the assumption about router behavior. The response focuses on precision loss and gas optimization, which are not the primary concerns raised in the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[H-02] Yeti token rebase checks the additional token amount incorrectly**

**Missed Issues from Issue Report**:
- **[M-01] Wrong `lastBuyBackPrice`**

---

### **Conclusion**
The response list partially addresses one of the issues ([H-02]) but misses the core concern of the incorrect calculation of the additional token amount. The other issue ([M-01]) is not adequately covered, as the response focuses on precision loss rather than the incorrect calculation of `lastBuyBackPrice` for different swap paths. There is a need for more precise and detailed responses to fully address the vulnerabilities described in the issue report.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and the average of these values is also 0."
PriceFeed.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";


/*
* PriceFeed for mainnet deployment, to be connected to Chainlink's live Collateral:USD aggregator reference
* contract, and a wrapper contract TellorCaller, which connects to TellorMaster contract.
*
* The PriceFeed uses Chainlink as primary oracle, and Tellor as fallback. It contains logic for
* switching oracles based on oracle failures, timeouts, and conditions for returning to the primary
* Chainlink oracle.
*/
contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  // Mainnet Chainlink aggregator
    ITellorCaller public tellorCaller;  // Wrapper contract that calls the Tellor system

    // Core Liquity contracts
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    // Use to convert a price answer to an 18-digit precision uint
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.
    uint constant public TIMEOUT = 14400;  // 4 hours: 60 * 60 * 4

    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; // 50%

    /*
    * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed
    * to return to using the Chainlink oracle. 18-digit precision.
    */
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%

    // The last good price seen from an oracle by Liquity
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    // --- Dependency setters ---

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        // Explicitly set initial system status
        status = Status.chainlinkWorking;

        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    // --- Functions ---

    /*
    * fetchPrice():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail,
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice() external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen, switch to Tellor and return last good price
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                /*
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is working and Tellor is broken, remember Tellor is broken
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            // If Chainlink is working, return Chainlink current price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }


        // --- CASE 2: The system fetched last price from Tellor ---
        if (status == Status.usingTellorChainlinkUntrusted) {
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // Otherwise, use Tellor price
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                return _storeTellorPrice(tellorResponse);
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
        if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted,
            // return Chainlink price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    // --- Functions ---

    /*
    * fetchPrice_vce_v():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail, 
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice_v() view external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                // If Tellor is frozen, switch to Tellor and return last good price 
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                /* 
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink 
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            // If Chainlink is working, return Chainlink current price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        // --- CASE 2: The system fetched last price from Tellor --- 
        if (status == Status.usingTellorChainlinkUntrusted) { 
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            // Otherwise, use Tellor price
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
         if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch 
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted, 
            // return Chainlink price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    // --- Helper functions ---

    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round
    * for two reasons:
    *
    * 1) It is necessary data for the price deviation check in case 1,
    * and
    * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds
    * peace of mind when using or returning to Chainlink.
    */
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid roundId that is 0
        if (_response.roundId == 0) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for non-positive price
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        /*
        * Use the larger price as the denominator:
        * - If price decreased, the percentage deviation is in relation to the the previous price.
        * - If price increased, the percentage deviation is in relation to the current price.
        */
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        // Return true if price has more than doubled, or more than halved.
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for zero price
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        // Return false if either oracle is broken or frozen
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        /*
        * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting
        * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.
        */
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        /*
        * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by Liquity.
        * At date of Liquity launch, Chainlink uses an 8-digit price, but we also handle the possibility of
        * future changes.
        *
        */
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            // Scale the returned price value down to Liquity's target precision
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            // Scale the returned price value up to Liquity's target precision
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    // --- Oracle response wrapper functions ---

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            // If call to Tellor succeeds, return the response and success = true
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            // If call to Tellor reverts, return a zero response with success = false
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        // First, try to get current decimal precision:
        try priceAggregator.decimals() returns (uint8 decimals) {
            // If call to Chainlink succeeds, record the current decimal precision
            chainlinkResponse.decimals = decimals;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }

        // Secondly, try to get latest price data:
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        /*
        * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a
        * previous round.  We assume the decimals used in the previous round are the same as the current round.
        */

        // Try to get the price data from the previous round:
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return prevChainlinkResponse;
        }
    }
}",7613,799,"[M-02] Should check return data from Chainlink aggregators

Function `_getCurrentChainlinkResponse`, no checks on lastRoundData

The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.
Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.
",1,,"pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";



contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  
    ITellorCaller public tellorCaller;  

    
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    
    uint constant public TIMEOUT = 14400;  

    
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; 

    
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; 

    
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        
        status = Status.chainlinkWorking;

        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    

    
    function fetchPrice() external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                
                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            
            return _storeChainlinkPrice(chainlinkResponse);
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    

    
    function fetchPrice_v() view external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) { 
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
         if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    

    
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.roundId == 0) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        
        try priceAggregator.decimals() returns (uint8 decimals) {
            
            chainlinkResponse.decimals = decimals;
        } catch {
            
            return chainlinkResponse;
        }

        
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        

        
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            
            return prevChainlinkResponse;
        }
    }
}",4598,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Oracle Integrity (Chainlink & Tellor)"",
      ""Tasks"": [
        ""Verify that the `priceAggregator` address is a valid and trusted Chainlink aggregator contract."",
        ""Verify that the `tellorCaller` address is a valid and trusted Tellor caller contract."",
        ""Analyze the `_chainlinkIsBroken` function to ensure all potential failure conditions of Chainlink are correctly identified (e.g., incorrect `roundId`, `timestamp` or `answer`)."",
        ""Analyze the `_tellorIsBroken` function to ensure all potential failure conditions of Tellor are correctly identified (e.g., incorrect `timestamp` or `value`)."",
        ""Confirm that the `TIMEOUT` value is appropriate for the application's risk tolerance and that stale prices are handled correctly."",
        ""Analyze the impact of potential oracle manipulation on the contract's functionality, particularly when falling back to Tellor. Assess how an attacker could exploit differences between Chainlink and Tellor prices."",
        ""Review the scaling logic in `_scaleChainlinkPriceByDigits` and `_scaleTellorPriceByDigits` to ensure correct price scaling and prevent precision loss or overflows."",
        ""Investigate whether Chainlink's reported `decimals` value could change unexpectedly and the impact this would have on price scaling and comparisons."",
        ""Verify that Chainlink and Tellor oracles are reporting prices in the same currency pair (ETH/USD) and are using compatible units."",
        ""Assess the potential for denial-of-service (DoS) attacks by manipulating oracle data to force the contract into a less favorable state (e.g., `bothOraclesUntrusted`)."",
        ""Review the `_bothOraclesSimilarPrice` function to ensure the `MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES` is appropriate and prevents significant price discrepancies from being accepted."",
        ""Check if the contract handles Chainlink reporting negative prices or zero prices, despite that Chainlink should always return positive prices."",
        ""Inspect how the contract deals with potential drift in `decimals` reported by Chainlink. Are checks present to validate a change in `decimals` and react accordingly?"",
        ""Assess the reliability and security of the `ITellorCaller` contract, as any vulnerabilities within this dependency could directly impact the PriceFeed contract's security and accuracy."",
        ""Simulate scenarios where Chainlink reports a price of 0, and verify the system's reaction is robust and secure. Ensure that division by 0 is prevented."",
        ""Analyze the consequences of `lastGoodPrice` being used when both oracles are untrusted. Understand the risks associated with relying on potentially outdated prices.""
      ]
    },
    {
      ""Area"": ""Status Management and Fallback Logic"",
      ""Tasks"": [
        ""Trace the state transitions of the `status` variable under various oracle failure scenarios to ensure the correct fallback behavior."",
        ""Verify that the `_changeStatus` function correctly emits the `PriceFeedStatusChanged` event."",
        ""Evaluate the logic in `fetchPrice` and `fetchPrice_v` to confirm that the correct price is returned based on the current `status` and oracle health."",
        ""Confirm that the conditions for transitioning to the `bothOraclesUntrusted` status are appropriate and prevent the contract from relying on potentially compromised data."",
        ""Investigate the potential for 'stuck' states where the contract remains in a degraded status (e.g., `usingTellorChainlinkUntrusted`) even after Chainlink recovers."",
        ""Analyze the gas costs associated with different `status` states and fallback scenarios to identify potential optimization opportunities."",
        ""Assess the attack vectors possible by manipulating the status variable, potentially forcing the contract to use lastGoodPrice for extended periods."",
        ""Examine the recovery mechanisms for transitioning out of the `bothOraclesUntrusted` state. Is there a risk that the contract will remain in this state indefinitely?"",
        ""Analyze the differences in logic between `fetchPrice` and `fetchPrice_v`, especially around how price scaling is handled in different scenarios. Ensure consistency in price reporting."",
        ""Verify correct handling of edge cases, like Chainlink freezing or Tellor breaking down immediately after Chainlink, potentially locking the price feed in a degraded state.""
      ]
    },
    {
      ""Area"": ""Access Control and Initialization"",
      ""Tasks"": [
        ""Confirm that only the owner can call the `setAddresses` function."",
        ""Investigate why `_renounceOwnership()` is called at the end of the `setAddresses` function. This is highly unusual, as it permanently removes the owner's control.  Determine if this is intentional and whether it creates any security risks. If this is intentional, there should be a very strong justification for why this is the case."",
        ""If ownership is renounced after `setAddresses`, verify that the contract can function correctly without an owner and that no critical functionality is lost."",
        ""Check if there are any potential vulnerabilities related to the contract's initialization, such as uninitialized state variables or incorrect initial values."",
        ""If the contract relies on external contracts for functionality, verify that these contracts are initialized correctly and are not vulnerable to attacks."",
        ""Consider the implications of the contract being unowned after initialization. Are there any governance or upgradeability concerns?"",
        ""Ensure that the `checkContract` modifier correctly validates that the provided addresses are indeed contracts.""
      ]
    },
    {
      ""Area"": ""Arithmetic Operations and Data Handling"",
      ""Tasks"": [
        ""Verify that the `SafeMath` library is used correctly throughout the contract to prevent overflows and underflows."",
        ""Analyze the potential for integer truncation errors in calculations, particularly when scaling prices."",
        ""Examine how the contract handles negative prices from Chainlink. While unlikely, it's important to understand the behavior if this occurs."",
        ""Assess the precision of the price feed and the potential for rounding errors to impact calculations."",
        ""Ensure that the `LiquityMath._min` and `LiquityMath._max` functions are used correctly and handle edge cases appropriately."",
        ""Review all calculations involving timestamps and block numbers to prevent potential vulnerabilities related to time-based attacks."",
        ""If the `int256` answer from Chainlink is converted to `uint256`, ensure that the contract handles the conversion correctly and prevents negative values from wrapping around."",
        ""Verify that the data types used for storing prices and timestamps are large enough to accommodate future values and prevent potential overflows.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify opportunities to reduce gas costs by optimizing data storage, function calls, and control flow."",
        ""Assess the gas costs associated with different code paths in the `fetchPrice` and `fetchPrice_v` functions."",
        ""Consider using assembly code or other low-level optimizations to improve gas efficiency in critical sections of the code."",
        ""Evaluate the use of caching or other techniques to reduce the number of external contract calls."",
        ""Identify and remove any unnecessary code or redundant calculations."",
        ""Investigate the potential for using cheaper data types (e.g., `uint8` instead of `uint256`) where appropriate."",
        ""Analyze the gas costs associated with emitting events and consider whether they can be optimized or removed."",
        ""Use the 'SOLIDITY_OPTIMIZER' setting in Remix and Hardhat to improve the contract's efficiency.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code implements a price feed contract that fetches price data from Chainlink and Tellor oracles. It prioritizes Chainlink but falls back to Tellor under certain conditions, such as Chainlink failures or significant price deviations. It includes checks to ensure data validity and prevent manipulation."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""PriceFeed"",
    ""Purpose"": ""To provide a reliable ETH/USD price feed by using Chainlink as the primary source and Tellor as a backup."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""CheckContract"", ""BaseMath"", ""IPriceFeed""],
      ""Imports"": [""./Interfaces/IPriceFeed.sol"", ""./Interfaces/ITellorCaller.sol"", ""./Dependencies/AggregatorV3Interface.sol"", ""./Dependencies/SafeMath.sol"", ""./Dependencies/Ownable.sol"", ""./Dependencies/CheckContract.sol"", ""./Dependencies/BaseMath.sol"", ""./Dependencies/LiquityMath.sol""]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NAME"",
        ""Type"": ""string constant"",
        ""Purpose"": ""Contract's name.""
      },
      {
        ""Name"": ""priceAggregator"",
        ""Type"": ""AggregatorV3Interface"",
        ""Purpose"": ""Address of the Chainlink price aggregator contract.""
      },
      {
        ""Name"": ""tellorCaller"",
        ""Type"": ""ITellorCaller"",
        ""Purpose"": ""Address of the Tellor caller contract.""
      },
      {
        ""Name"": ""borrowerOperationsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the BorrowerOperations contract (not used in the current code snippet).""
      },
      {
        ""Name"": ""troveManagerAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the TroveManager contract (not used in the current code snippet).""
      },
      {
        ""Name"": ""ETHUSD_TELLOR_REQ_ID"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Tellor's request ID for ETH/USD price.""
      },
      {
        ""Name"": ""TARGET_DIGITS"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""The target number of digits for the price (18).""
      },
      {
        ""Name"": ""TELLOR_DIGITS"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""The number of digits returned by Tellor (6).""
      },
      {
        ""Name"": ""TIMEOUT"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Maximum age of a price feed value before it's considered stale (14400 seconds = 4 hours).""
      },
      {
        ""Name"": ""MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Maximum allowed price deviation from the previous Chainlink round (5e17 = 50%).""
      },
      {
        ""Name"": ""MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES"",
        ""Type"": ""uint constant"",
        ""Purpose"": ""Maximum acceptable price difference between Chainlink and Tellor (5e16 = 5%).""
      },
      {
        ""Name"": ""lastGoodPrice"",
        ""Type"": ""uint"",
        ""Purpose"": ""The last known good price.""
      },
      {
        ""Name"": ""status"",
        ""Type"": ""Status"",
        ""Purpose"": ""Current status of the price feed (chainlinkWorking, usingTellorChainlinkUntrusted, bothOraclesUntrusted, usingTellorChainlinkFrozen, usingChainlinkTellorUntrusted).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the addresses of the Chainlink aggregator and Tellor caller contracts. Can only be called by the owner."",
        ""Parameters"": [""address _priceAggregatorAddress"", ""address _tellorCallerAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""fetchPrice"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Fetches the current price, prioritizing Chainlink and falling back to Tellor if necessary. Updates the contract's status based on oracle health."",
        ""Parameters"": [],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""fetchPrice_v"",
        ""Visibility"": ""view external"",
        ""Purpose"": ""A view function that fetches the price without modifying state, prioritizing Chainlink and falling back to Tellor if necessary.  This is a view version of `fetchPrice`."",
        ""Parameters"": [],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_chainlinkIsBroken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if either the current or previous Chainlink response is invalid."",
        ""Parameters"": [""ChainlinkResponse memory _currentResponse"", ""ChainlinkResponse memory _prevResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_badChainlinkResponse"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a Chainlink response is invalid based on several criteria (success, roundId, timestamp, answer)."",
        ""Parameters"": [""ChainlinkResponse memory _response""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_chainlinkIsFrozen"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a Chainlink response is too old."",
        ""Parameters"": [""ChainlinkResponse memory _response""],
        ""Returns"": [""bool""]
      },
       {
        ""Name"": ""_chainlinkPriceChangeAboveMax"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Checks if the price deviation between current and previous Chainlink rounds exceeds the maximum allowed."",
        ""Parameters"": [""ChainlinkResponse memory _currentResponse"", ""ChainlinkResponse memory _prevResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_tellorIsBroken"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a Tellor response is invalid based on several criteria (success, timestamp, value)."",
        ""Parameters"": [""TellorResponse memory _response""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_tellorIsFrozen"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a Tellor response is too old."",
        ""Parameters"": [""TellorResponse  memory _tellorResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_bothOraclesLiveAndUnbrokenAndSimilarPrice"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if both Chainlink and Tellor are live, unbroken, and their prices are similar."",
        ""Parameters"": [""ChainlinkResponse memory _chainlinkResponse"", ""ChainlinkResponse memory _prevChainlinkResponse"", ""TellorResponse memory _tellorResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_bothOraclesSimilarPrice"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Checks if the prices from Chainlink and Tellor are similar within a defined percentage."",
        ""Parameters"": [""ChainlinkResponse memory _chainlinkResponse"", ""TellorResponse memory _tellorResponse""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_scaleChainlinkPriceByDigits"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Scales the Chainlink price to the target number of digits."",
        ""Parameters"": [""uint _price"", ""uint _answerDigits""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_scaleTellorPriceByDigits"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Scales the Tellor price to the target number of digits."",
        ""Parameters"": [""uint _price""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_changeStatus"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the contract's status and emits a PriceFeedStatusChanged event."",
        ""Parameters"": [""Status _status""],
        ""Returns"": []
      },
      {
        ""Name"": ""_storePrice"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the lastGoodPrice and emits a LastGoodPriceUpdated event."",
        ""Parameters"": [""uint _currentPrice""],
        ""Returns"": []
      },
      {
        ""Name"": ""_storeTellorPrice"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Scales and stores the Tellor price."",
        ""Parameters"": [""TellorResponse memory _tellorResponse""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_storeChainlinkPrice"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Scales and stores the Chainlink price."",
        ""Parameters"": [""ChainlinkResponse memory _chainlinkResponse""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_getCurrentTellorResponse"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Retrieves the current Tellor response."",
        ""Parameters"": [],
        ""Returns"": [""TellorResponse memory""]
      },
      {
        ""Name"": ""_getCurrentChainlinkResponse"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Retrieves the current Chainlink response."",
        ""Parameters"": [],
        ""Returns"": [""ChainlinkResponse memory""]
      },
      {
        ""Name"": ""_getPrevChainlinkResponse"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Retrieves the previous Chainlink response."",
        ""Parameters"": [""uint80 _currentRoundId"", ""uint8 _currentDecimals""],
        ""Returns"": [""ChainlinkResponse memory""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""AggregatorV3Interface (Chainlink price feed)"",
    ""ITellorCaller (Tellor price feed)""
  ],
  ""SpecialMechanisms"": [
    ""Fallback mechanism from Chainlink to Tellor."",
    ""Health checks for both Chainlink and Tellor oracles."",
    ""Price deviation checks to prevent manipulation."",
    ""Status tracking of the price feed's health."",
    ""SafeMath library for arithmetic operations to prevent overflows/underflows."",
    ""Oracle price scaling to ensure consistent precision.""
  ],
  ""Questions"": [
    ""What are the specific roles of borrowerOperationsAddress and troveManagerAddress? They are declared but not used in this code snippet."",
    ""Could the fallback mechanism to Tellor be vulnerable to Tellor-specific manipulation? How robust is the Tellor price validation?"",
    ""What are the gas costs associated with fetching prices from both Chainlink and Tellor, and how might these costs affect the contract's performance?"",
    ""Why is _renounceOwnership() called in setAddresses()? This seems unusual."",
    ""The Chainlink response includes an `int256` answer, but the scaling functions operate on `uint`. Is there a possibility of underflow when converting negative prices to `uint`? (although chainlink should always return positive price)""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Access Control on Sensitive Functions"",
      ""Severity"": ""High"",
      ""Description"": ""Functions involving fund transfers and role management, such as `crossDeposit`, `crossWithdraw`, `crossBorrow`, `crossOvercollateralizedBorrow`, and `setGateway` do not implement any access control mechanisms, allowing any user to call these functions and manipulate funds or change critical parameters without authorization."",
      ""Impact"": ""Unauthorized access could lead to fund mismanagement, unauthorized fund transfers, changes to gateway addresses, and potential financial loss to the protocol."",
      ""Location"": ""Functions `crossDeposit`, `crossWithdraw`, `crossBorrow`, `crossOvercollateralizedBorrow`, `setGateway`""
    },
    {
      ""Issue"": ""Missing Validation for User-Supplied Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `crossWithdraw` function lacks proper validation for the user-supplied `receiver` address. An attacker can set the `receiver` address to the zero address, causing tokens to be burned, or to a contract address that does not implement the expected ERC-20 functionality, leading to unexpected behavior and potential token loss."",
      ""Impact"": ""Tokens could be unintentionally burned or sent to contracts that cannot handle them, leading to loss of funds."",
      ""Location"": ""Function `crossWithdraw`""
    }
  ],
  ""IssueNumber"": 4,
  ""OutputList"": 2
}",43.06892919540405,4510.0,9.0,"---

**[M-02] Should check return data from Chainlink aggregators**

**Report Description**:  
The function `_getCurrentChainlinkResponse` in `PriceFeed.sol` fetches the asset price from a Chainlink aggregator using the `latestRoundData` function. However, it does not validate the `roundID` or other return data. According to Chainlink's documentation, this function may return stale or incorrect data (e.g., a price of 0) if no valid answer is available. This could lead to incorrect price feeds being used in the `PriceOracle`, potentially resulting in financial risks such as incorrect index price calculations, liquidity mismanagement, and exposure to outdated or manipulated data from third-party oracles.

**Match in Response List**:  
**No match found**.

**Validation**:  
The `response_list` does not address the issue of missing validation for Chainlink oracle data. The findings in the `response_list` focus on access control and address validation but do not cover the risks associated with unchecked external data sources like Chainlink oracles. This issue is entirely missed, making the response **incorrect** for this specific vulnerability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-02] Should check return data from Chainlink aggregators**

--- 

The `response_list` fails to address the critical issue of validating Chainlink oracle data, leaving a significant gap in its coverage of vulnerabilities. This omission could lead to severe financial risks if stale or incorrect price feeds are used in the protocol.","```
None.
```",0.0
ActivePool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";

/*
 * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.
 *
 * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the
 * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.
 *
 */
contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts 
    newColls internal poolColl;

    // YUSD Debt tracker. Tracker of all debt in the system. 
    uint256 internal YUSDDebt;

    // --- Events ---

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    // --- Internal Functions ---

    // --- Getters for public variables. Required by IPool interface ---

    /*
    * Returns the collateralBalance for a given collateral
    *
    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.
    */
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    /*
    * Returns all collateral balances in state. Not necessarily the contract's actual balances.
    */
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    // returns the VC value of a given collateralAddress in this contract
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    /*
    * Returns the VC of the contract
    *
    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.
    *
    * Computed when called by taking the collateral balances and
    * multiplying them by the corresponding price and ratio and then summing that
    */
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    // Debt that this pool holds. 
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    // --- Pool functionality ---

    // Internal function to send collateral to a different pool. 
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. 
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.
    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,
    // It also harvests rewards on the user's behalf. 
    // _from is where the reward balance is, _to is where to send the tokens. 
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                // Collects rewards automatically for that amount and unwraps for the original borrower. 
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails
            }
        }
        return true;
    }

    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); // reverts if send fails
        return true;
    }

    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            // Collects rewards automatically for that amount and unwraps for the original borrower. 
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); // reverts if send fails
        }
        return true;
    }

    // View function that returns if the contract transferring to needs to have its balances updated. 
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    // Increases the YUSD Debt of this pool. 
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // Decreases the YUSD Debt of this pool. 
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // --- 'require' functions ---

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    // should be called by BorrowerOperations or DefaultPool
    // __after__ collateral is transferred to this contract.
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    // Adds collateral type from whitelist. 
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2716,304,"[M-03] Unwhitelisted token can cause disaster

Submitted by csanuragjain
Impact

Contract instability and financial loss. This will happen if one of the allowed contract calls sendCollaterals with non whitelisted token (may happen with user input on allowed contract)
Proof of Concept

Navigate to contract atÂ https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/ActivePool.sol
Assume sendCollaterals function is called by one of allowed contract with a non whitelisted token and amount as 1
```â€¨function sendCollaterals(address _to, address[] memory _tokens, uint[] memory _amounts) external override returns (bool) {
    _requireCallerIsBOorTroveMorTMLorSP();
    require(_tokens.length == _amounts.length);
    for (uint i = 0; i < _tokens.length; i++) {
        _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails
    }

    if (_needsUpdateCollateral(_to)) {
        ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
    }
    
    return true;
}â€¨```â€¨â€¨[M-04] Out of gas.

Submitted by Jujic, also found by gzeon
There is no upper limit onÂ poolColl.tokens[], it increments each time when a new collateral is added. Eventually, as the count of collateral increases, gas cost of smart contract calls will raise and that there is no implemented function to reduce the array size.
Impact

For every callÂ getVC()Â function which computed contain the VC value of a given collateralAddress is listed inÂ poolColl.tokens[]Â array, the gas consumption can be more expensive each time that a new collateral address is appended to the array, until reaching an ""Out of Gas"" error or a ""Block Gas Limit"" in the worst scenario.
",2,,"pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";


contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    
    newColls internal poolColl;

    
    uint256 internal YUSDDebt;

    

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    

    

    
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    

    
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); 
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    
    
    
    
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); 
            }
        }
        return true;
    }

    
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); 
        return true;
    }

    
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); 
        }
        return true;
    }

    
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2101,0,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that `onlyOwner` modifier in `setAddresses` correctly restricts access to the owner."",
        ""Confirm that the `checkContract` function, used within `setAddresses`, effectively prevents setting addresses to non-contract accounts."",
        ""Analyze all functions with the `_requireCallerIsBOorTroveMorTMLorSP`, `_requireCallerIsBorrowerOperationsOrDefaultPool`, `_requireCallerIsBorrowerOperations`, `_requireCallerIsBOorTroveMorSP`, `_requireCallerIsBOorTroveM` and `_requireCallerIsWhitelist` modifiers to ensure they provide appropriate and intended access control. Specifically, verify that only the intended contracts can call these functions."",
        ""Ensure that there are no missing access control checks in any state-modifying function."",
        ""Investigate the impact of renouncing ownership in `setAddresses` using `_renounceOwnership`. Confirm that this is the intended behavior and analyze potential security implications."",
        ""Check if `Ownership` can be reclaimed and how. Consider impact of making the contract unowned.""
      ]
    },
    {
      ""Area"": ""Collateral Management and Whitelist Interaction"",
      ""Tasks"": [
        ""Examine the implementation of the `Whitelist` contract and its interaction with the `ActivePool` to ensure that only whitelisted collateral types are accepted."",
        ""Verify that the `getIndex` function in the `Whitelist` contract behaves as expected and handles edge cases (e.g., non-whitelisted tokens)."",
        ""Analyze the logic of `getCollateral`, `getAllCollateral`, `getCollateralVC` and `getVC` functions to ensure they accurately reflect the collateral state and value contribution (VC)."",
        ""Investigate potential vulnerabilities related to the `poolColl` struct, especially considering that the `newColls` struct and the `_leftSumColls` function are not defined in the provided code. Confirm the correct update/summation of collateral."",
        ""Verify that the `addCollateralType` function, which adds new collateral types, is properly protected by the `_requireCallerIsWhitelist` modifier."",
        ""Analyze how the `whitelist.getValueVC` function is used and ensure that the returned value contribution is calculated correctly and consistently with the overall system's economic model.""
      ]
    },
    {
      ""Area"": ""YUSD Debt Management"",
      ""Tasks"": [
        ""Confirm that `increaseYUSDDebt` and `decreaseYUSDDebt` functions correctly update the `YUSDDebt` variable and emit the corresponding events."",
        ""Verify that the access control modifiers on `increaseYUSDDebt` and `decreaseYUSDDebt` are appropriate and prevent unauthorized modification of the debt."",
        ""Analyze potential overflow/underflow issues when increasing/decreasing `YUSDDebt`, even though SafeMath is used."",
        ""Ensure that the YUSDDebt value is consistent and accurate throughout the contract's lifecycle, especially during collateral transfers and liquidations.""
      ]
    },
    {
      ""Area"": ""Collateral Transfer and Unwrap Logic"",
      ""Tasks"": [
        ""Carefully examine the `_sendCollateral` function to ensure that collateral is correctly transferred and internal balances are updated accordingly."",
        ""Verify that the `sendCollaterals` and `sendCollateralsUnwrap` functions correctly handle multiple collateral types and amounts."",
        ""Analyze the interaction with the `IWAsset` interface in the `sendCollateralsUnwrap` and `sendSingleCollateralUnwrap` functions to ensure that the unwrapping logic is secure and functions as expected."",
        ""Check for potential reentrancy vulnerabilities in the `_sendCollateral` function, considering the external call to `IERC20(_collateral).safeTransfer(_to, _amount)`. Consider adding a reentrancy guard."",
        ""Verify that the `_needsUpdateCollateral` function correctly identifies contracts that need to receive collateral updates via the `ICollateralReceiver` interface."",
        ""Ensure proper handling of zero-value collateral amounts in `sendCollaterals` and other functions to avoid unnecessary operations or potential errors."",
        ""Investigate the event emissions (`ActivePoolBalanceUpdated`, `CollateralSent`, `CollateralsSent`) to ensure they provide accurate and complete information about collateral transfers.""
      ]
    },
    {
      ""Area"": ""External Interactions and Dependencies"",
      ""Tasks"": [
        ""Audit the implementation of `CheckContract` to ensure it prevents addresses without code to be used."",
        ""Review the implementation of `SafeERC20` to verify that it correctly handles ERC-20 token transfers and potential errors."",
        ""Analyze the interaction with the `ICollateralReceiver` interface and ensure that the `receiveCollateral` function is implemented correctly in the target contracts (StabilityPool, DefaultPool, CollSurplusPool)."",
        ""Investigate the functionality of the `YetiCustomBase` contract and its impact on the `ActivePool`'s behavior."",
        ""Trace the flow of collateral and debt across all interacting contracts (BorrowerOperations, TroveManager, StabilityPool, DefaultPool, Whitelist, etc.) to ensure consistency and prevent unintended consequences."",
        ""Assess the risk of malicious or compromised external contracts and their potential impact on the `ActivePool`'s functionality and security.""
      ]
    },
    {
      ""Area"": ""Potential Arithmetic Overflows/Underflows"",
      ""Tasks"": [
        ""Although SafeMath is used, carefully audit all arithmetic operations, especially those involving user-supplied inputs or external data, to ensure that overflows or underflows are impossible. Review `_leftSumColls` once the code is available."",
        ""Check for potential vulnerabilities related to integer truncation or rounding errors in calculations involving collateral amounts or debt values.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of frequently used functions, such as `sendCollaterals` and `sendCollateralsUnwrap`, and identify potential optimizations."",
        ""Review the storage variable access patterns to minimize gas costs, particularly within loops and frequently called functions."",
        ""Evaluate the use of calldata vs. memory for function parameters to reduce gas consumption."",
        ""Check for opportunities to use more gas-efficient data types or algorithms without compromising security or functionality.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines the `ActivePool` contract, which manages collateral and debt within a DeFi system. It handles the storage and transfer of various whitelisted collateral types, tracks the total YUSD debt, and interacts with other core contracts such as `BorrowerOperations`, `TroveManager`, `StabilityPool`, `DefaultPool`, and `Whitelist`. Access control is enforced through modifiers that check the caller's address against a list of allowed contract addresses. The contract also includes logic for unwrapping wrapped assets during collateral transfers."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ActivePool"",
    ""Purpose"": ""Manages collateral and YUSD debt within the system. Acts as a central repository for collateral and facilitates its transfer to other contracts."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Ownable"",
        ""CheckContract"",
        ""IActivePool"",
        ""YetiCustomBase""
      ],
      ""Imports"": [
        ""./Interfaces/IActivePool.sol"",
        ""./Interfaces/IWhitelist.sol"",
        ""./Interfaces/IERC20.sol"",
        ""./Interfaces/IWAsset.sol"",
        ""./Dependencies/SafeMath.sol"",
        ""./Dependencies/Ownable.sol"",
        ""./Dependencies/CheckContract.sol"",
        ""./Dependencies/YetiCustomBase.sol"",
        ""./Dependencies/SafeERC20.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""borrowerOperationsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the BorrowerOperations contract.""
      },
      {
        ""Name"": ""troveManagerAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the TroveManager contract.""
      },
      {
        ""Name"": ""stabilityPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the StabilityPool contract.""
      },
      {
        ""Name"": ""defaultPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the DefaultPool contract.""
      },
      {
        ""Name"": ""troveManagerLiquidationsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the TroveManagerLiquidations contract.""
      },
      {
        ""Name"": ""troveManagerRedemptionsAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the TroveManagerRedemptions contract.""
      },
      {
        ""Name"": ""collSurplusPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the CollSurplusPool contract.""
      },
      {
        ""Name"": ""poolColl"",
        ""Type"": ""newColls"",
        ""Purpose"": ""Struct containing arrays of collateral addresses and amounts.""
      },
      {
        ""Name"": ""YUSDDebt"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total YUSD debt held by the active pool.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the addresses of various contracts. Can only be called by the owner."",
        ""Parameters"": [
          ""_borrowerOperationsAddress"",
          ""_troveManagerAddress"",
          ""_stabilityPoolAddress"",
          ""_defaultPoolAddress"",
          ""_whitelistAddress"",
          ""_troveManagerLiquidationsAddress"",
          ""_troveManagerRedemptionsAddress"",
          ""_collSurplusPoolAddress""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""getCollateral"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the amount of a given collateral type held in the pool."",
        ""Parameters"": [""_collateral""],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""getAllCollateral"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns all collaterals and amounts held in the pool."",
        ""Parameters"": [],
        ""Returns"": [""address[]"", ""uint256[]""]
      },
      {
        ""Name"": ""getYUSDDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total YUSD debt of the active pool."",
        ""Parameters"": [],
        ""Returns"": [""uint""]
      },
      {
        ""Name"": ""_sendCollateral"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sends collateral to a given address, updating internal balances."",
        ""Parameters"": [""_to"", ""_collateral"", ""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""sendCollaterals"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends multiple collateral types to a given address.  Requires caller to be BorrowerOperations, TroveManager, TroveManagerLiquidations, TroveManagerRedemptions, or StabilityPool."",
        ""Parameters"": [""_to"", ""_tokens"", ""_amounts""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""sendCollateralsUnwrap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends multiple collateral types to a given address, unwrapping them if necessary."",
        ""Parameters"": [""_from"", ""_to"", ""_tokens"", ""_amounts""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""sendSingleCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends a single collateral type to a given address.  Requires caller to be BorrowerOperations."",
        ""Parameters"": [""_to"", ""_token"", ""_amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""sendSingleCollateralUnwrap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sends a single collateral type to a given address, unwrapping it if necessary. Requires caller to be BorrowerOperations."",
        ""Parameters"": [""_from"", ""_to"", ""_token"", ""_amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""increaseYUSDDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases the total YUSD debt. Requires caller to be BorrowerOperations or TroveManager."",
        ""Parameters"": [""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""decreaseYUSDDebt"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Decreases the total YUSD debt. Requires caller to be BorrowerOperations, TroveManager, StabilityPool or TroveManagerRedemptions."",
        ""Parameters"": [""_amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""receiveCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Receives collateral from BorrowerOperations or DefaultPool, updating internal balances."",
        ""Parameters"": [""_tokens"", ""_amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addCollateralType"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new collateral type to the tracked collaterals. Can only be called by the Whitelist contract."",
        ""Parameters"": [""_collateral""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 for transferring collateral tokens."",
    ""IWhitelist for validating and retrieving collateral information and if a token is wrapped."",
    ""IWAsset for unwrapping wrapped collateral tokens."",
    ""BorrowerOperations contract."",
    ""TroveManager contract."",
    ""StabilityPool contract."",
    ""DefaultPool contract."",
    ""TroveManagerLiquidations contract."",
    ""TroveManagerRedemptions contract."",
    ""CollSurplusPool contract."",
    ""ICollateralReceiver for receiving updated collateral information.""
  ],
  ""SpecialMechanisms"": [
    ""Uses SafeMath for arithmetic operations to prevent overflows."",
    ""Uses SafeERC20 for safe ERC20 token transfers."",
    ""Implements a whitelist to manage accepted collateral types."",
    ""Employs modifiers for access control based on caller addresses."",
    ""Includes logic for unwrapping wrapped assets via the IWAsset interface before sending them.""
  ],
  ""Questions"": [
    ""The purpose of `YetiCustomBase` is unclear and needs further explanation."",
    ""The `newColls` struct and `_leftSumColls` function are not defined within the provided snippet; their implementations and usage should be examined."",
    ""What is the significance of value contribution (VC) and how is it calculated using the Whitelist contract?"",
    ""The usage and implications of renouncing ownership in `setAddresses` should be considered. Is this intentional and what are the security implications?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unprotected renouncement of ownership in setAddresses"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `setAddresses` function renounces ownership using `_renounceOwnership()` after setting addresses. This action is irreversible, leading to a permanent loss of administrative control. If addresses are incorrectly set, there is no recourse, potentially rendering the contract unusable or exploitable."",
      ""Impact"": ""Permanent loss of administrative control over the contract, potential for the contract to become unusable if it relies on owner privileges, increased risk of exploitation if addresses are set maliciously."",
      ""Location"": ""ActivePool.sol: setAddresses function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Collateral Transfer Logic"",
      ""Severity"": ""High"",
      ""Description"": ""The `_sendCollateral` function and potentially internal function `_leftSumColls` lack sufficient validation to prevent integer overflows or underflows during collateral transfer or summing amounts. Specifically, `poolColl.amounts[index] = poolColl.amounts[index].sub(_amount)` relies on the assumption that `poolColl.amounts[index]` will always be greater than or equal to `_amount`. A lack of validation that the tokens in `_tokens` are already present in the activePool in the function `_leftSumColls` could also lead to unexpected behavior."",
      ""Impact"": ""Loss of funds due to underflow, potential denial-of-service due to transaction reverting when trying to send more collateral than the ActivePool holds, malfunctioning contract due to accounting errors and potentially unauthorized withdrawal of collateral."",
      ""Location"": ""ActivePool.sol: _sendCollateral function, ActivePool.sol: line 251, ActivePool.sol: line 290. Also relevant is the struct definition of `newColls` (line 24)""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in Collateral Transfer Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `sendCollaterals` and `sendCollateralsUnwrap` functions make external calls that introduce reentrancy risks. `sendCollaterals` calls `IERC20(_tokens[i]).safeTransfer(_to, thisAmount)` and `ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts)`. `sendCollateralsUnwrap` calls `IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i])`. A malicious contract at the recipient address (`_to` or `IWAsset`) could re-enter the ActivePool contract and manipulate its state before the original transaction completes."",
      ""Impact"": ""Potential theft of funds, contract state corruption, or other unexpected behavior due to reentrancy."",
      ""Location"": ""ActivePool.sol: sendCollaterals function, ActivePool.sol: sendCollateralsUnwrap function""
    },
    {
      ""Issue"": ""Missing Zero-Address Checks in `setAddresses` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setAddresses` function updates critical contract addresses but does not prevent setting them to the zero address (0x0). While `checkContract` validates contract existence, it does not explicitly prevent the zero address. Setting a crucial address to zero would effectively disable important functionality of the protocol and can lead to unexpected errors or stuck funds."",
      ""Impact"": ""Potential for contract malfunction, denial of service, or locking of funds if critical addresses are inadvertently set to the zero address."",
      ""Location"": ""ActivePool.sol: setAddresses function""
    },
    {
      ""Issue"": ""Lack of Access Control on `addCollateralType` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addCollateralType` function, protected only by `_requireCallerIsWhitelist()`, allows the `whitelist` contract to add any arbitrary token as collateral. If the `whitelist` contract is compromised, an attacker could add a malicious or worthless token as collateral or duplicate types, potentially causing issues within the system."",
      ""Impact"": ""The addition of malicious or worthless collateral types can lead to system instability, financial loss, or break other contract functions."",
      ""Location"": ""ActivePool.sol: line 295, ActivePool.sol:256""
    },
    {
      ""Issue"": ""Collateral Manipulation in `sendCollateralsUnwrap` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract calls `IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i])` in the `sendCollateralsUnwrap` function without proper authorization checks on `_from`. Specifically, it doesn't verify that `_from` is actually the owner of the wAsset. This allows attackers to potentially steal wAssets from arbitrary users."",
      ""Impact"": ""User's wAssets can be stolen by an attacker."",
      ""Location"": ""ActivePool.sol: line 155""
    },
    {
      ""Issue"": ""Centralized Control and Risk"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract leverages the Ownable pattern for address setting, granting extensive control to the owner through the `setAddresses` function. This creates a single point of failure if the owner is compromised. Additionally, functions `receiveCollateral` are only protected by certain contracts which might be a single point of failure. "",
      ""Impact"": ""Complete system takeover or denial of service if the owner is compromised. Potential for unauthorized manipulation of collateral balances"",
      ""Location"": ""ActivePool.sol: lines 54-74, 76, ActivePool.sol: Contract inherits Ownable, receiveCollateral function""
    },
    {
      ""Issue"": ""Missing Input Validation in `sendCollaterals` and `sendCollateralsUnwrap`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `sendCollaterals` and `sendCollateralsUnwrap` functions lack comprehensive input validation. Although they check that the lengths of `_tokens` and `_amounts` arrays match, they do not validate that each `_token` is a valid and whitelisted collateral token, preventing sending zero amounts for all tokens, or preventing underflow. An attacker could potentially include an arbitrary address in the `_tokens` array."",
      ""Impact"": ""Potential for denial-of-service if an attacker can trigger an expensive loop with no collateral transfer, unexpected behavior if underflows are used in amounts, sending tokens to unintended addresses or triggering unexpected behavior in other contracts."",
      ""Location"": ""ActivePool.sol: sendCollaterals and sendCollateralsUnwrap functions, ActivePool.sol: line 135-137, ActivePool.sol:145, ActivePool.sol:163""
    },
    {
      ""Issue"": ""Missing Input Validation in `receiveCollateral` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `receiveCollateral` function does not check if the lengths of the `_tokens` and `_amounts` arrays match. This could lead to unexpected behavior if the arrays are of different sizes, as the function iterates through them based on their indices."",
      ""Impact"": ""Potential unexpected behavior, transaction reverts, denial of service."",
      ""Location"": ""ActivePool.sol: receiveCollateral function""
    },
    {
      ""Issue"": ""Unprotected Address Setting with Ownership Renouncement &  Unprotected Address Renouncement"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setAddresses` function renounces ownership, meaning addresses are immutable once set. If a mistake is made, the contract becomes unusable. Also, while addresses are validated as contracts, there is no check to see if the `whitelistAddress` is set to zero. This also create a fixed set of contracts that cannot be upgraded or patched."",
      ""Impact"": ""Potential for the contract to become un-upgradable or un-patchable if critical addresses need to be changed in the future. Potential for contract malfunction due to interaction with the zero address. Loss of administrative control if addresses are incorrectly set."",
      ""Location"": ""ActivePool.sol: setAddresses function, ActivePool.sol:76, ActivePool.sol:43-77""
    },
    {
      ""Issue"": ""Missing input validation on `addCollateralType` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `addCollateralType` allows the whitelist to add a new collateral type to the `poolColl.tokens` array. However, there is no check to ensure that the `_collateral` address being added is not already present in the `poolColl.tokens` array. Adding the same collateral type multiple times could lead to unexpected behavior and calculation errors in functions that iterate over `poolColl.tokens` and `poolColl.amounts`."",
      ""Impact"": ""Duplicated collateral types can lead to inaccurate calculations and potential vulnerabilities."",
      ""Location"": ""addCollateralType function""
    },
    {
      ""Issue"": ""Inconsistent Event Emission for Collateral Transfers"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `_sendCollateral` emits `ActivePoolBalanceUpdated` and `CollateralSent` events. In the `sendCollaterals` function, only `CollateralsSent` is emitted. `sendCollateralsUnwrap` and `sendSingleCollateral/Unwrap` emit no events. `ActivePoolBalanceUpdated` should emit the remaining amount, instead of `_amountSent` and It would be more informative to include the recipient address in the `ActivePoolBalanceUpdated` event to have a consistent set of information across both events."",
      ""Impact"": ""Increased difficulty in tracking collateral flows and debugging issues. Lack of comprehensive event logging can hinder auditing and monitoring efforts. Potentially incorrect data shown on block explorers or monitoring tools."",
      ""Location"": ""ActivePool.sol: `_sendCollateral`, `sendCollaterals`, `sendCollateralsUnwrap`, `sendSingleCollateral/Unwrap`, ActivePool.sol:123-124""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in external functions interacting with YUSDDebt"",
      ""Severity"": ""Low"",
      ""Description"": ""Although SafeMath is used within the `ActivePool` contract, the potential for integer overflow or underflow exists in external functions like `increaseYUSDDebt` and `decreaseYUSDDebt`, especially if the input `_amount` is maliciously crafted or exceptionally large/small relative to the current `YUSDDebt`. While the SafeMath library protects from overflows/underflows *within* the functions themselves, logic errors from outside the contract can lead to incorrect results."",
      ""Impact"": ""Incorrect YUSDDebt values can impact the stability and proper functioning of the entire system, leading to incorrect liquidations or redemptions."",
      ""Location"": ""increaseYUSDDebt and decreaseYUSDDebt functions""
    },
    {
      ""Issue"": ""Unchecked Division in `whitelist.getValueVC` calls within `getVC`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getVC` function iterates through all collateral types and calls `whitelist.getValueVC(collateral, amount)`. If the `whitelist.getValueVC` function contains a division operation, there is a risk of division by zero if certain conditions are met within the whitelist\'s logic. This isn't a direct vulnerability in ActivePool, but the contract depends on `whitelist` and makes potentially vulnerable calls to it."",
      ""Impact"": ""Transaction failure (denial of service) if `whitelist.getValueVC` attempts to divide by zero."",
      ""Location"": ""ActivePool.sol: getVC function, call to `whitelist.getValueVC(collateral, amount)`""
    },
    {
      ""Issue"": ""Missing validation for _collateral parameter in getCollateralVC"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `getCollateralVC` calls the `getValueVC` of the `whitelist` contract. However, it does not check if the provided `_collateral` address exists in the `poolColl.tokens` array. If the `_collateral` is not in the `poolColl.tokens` array, then `whitelist.getIndex(_collateral)` will return `0`, and the behavior may be incorrect if the whitelist has something at index `0`. Additionally, if `_collateral` isn't an accepted collateral in the whitelist, this could cause issues"",
      ""Impact"": ""Unexpected behavior or incorrect virtual collateral calculations if an invalid collateral address is passed."",
      ""Location"": ""ActivePool.sol: getCollateralVC function""
    },
    {
      ""Issue"": ""Potential integer overflow in getAllCollateral"",
      ""Severity"": ""Low"",
      ""Description"": ""The `getAllCollateral` function retrieves all the collaterals that this pool currently holds. In case the `poolColl` struct holds a very large number of collateral types, the function can potentially consume a lot of gas for its execution, leading to out-of-gas errors. Though unlikely given the context, this should be considered as a limitation of the contract\'s design."",
      ""Impact"": ""Potential gas exhaustion and failure when retrieving a very large list of all collateral types."",
      ""Location"": ""ActivePool.sol: getAllCollateral function""
    },
    {
      ""Issue"": ""Lack of event emission for `addCollateralType`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `addCollateralType` adds a new collateral and its amount to the `poolColl` struct. But the `addCollateralType` does not emit any event when a new collateral type is added, which makes it difficult to track changes to the active collaterals."",
      ""Impact"": ""Difficult to track changes to the active collaterals and react accordingly."",
      ""Location"": ""ActivePool.sol: addCollateralType function""
    }
  ],
  ""IssueNumber"": 53,
  ""OutputList"": 17
}",191.7887408733368,3932.0,31.0,"### **[M-03] Unwhitelisted token can cause disaster**

**Report Description**:  
The `sendCollaterals` function in `ActivePool.sol` does not validate whether the tokens in the `_tokens` array are whitelisted. If an allowed contract calls `sendCollaterals` with a non-whitelisted token (e.g., via user input), it could lead to contract instability and financial loss. This vulnerability arises because the function does not enforce whitelisting checks, allowing arbitrary tokens to be processed.

**Match in Response List**:  
Matches with the issue titled **""Missing Input Validation in `sendCollaterals` and `sendCollateralsUnwrap`""**.

**Validation**:  
**Partially Correct**. The response identifies the lack of input validation in `sendCollaterals` but does not explicitly mention the risk of non-whitelisted tokens. While it covers the broader issue of missing validation, it misses the specific impact of unwhitelisted tokens causing instability and financial loss. This makes the response partially correct.

---

### **[M-04] Out of gas**

**Report Description**:  
The `poolColl.tokens[]` array in `ActivePool.sol` has no upper limit, and its size increases each time a new collateral is added. As the array grows, the gas cost of functions like `getVC()` increases, potentially leading to ""Out of Gas"" errors or exceeding the block gas limit. This issue arises because there is no mechanism to reduce the array size or limit its growth.

**Match in Response List**:  
Matches with the issue titled **""Potential integer overflow in getAllCollateral""**.

**Validation**:  
**Incorrect**. The response discusses gas exhaustion in `getAllCollateral` due to a large number of collateral types but does not address the specific issue of `poolColl.tokens[]` growing indefinitely and causing gas-related failures in `getVC()`. The core issue of unbounded array growth and its impact on gas costs is not covered, making the response incorrect.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-03] Unwhitelisted token can cause disaster**

**Missed Issues from Issue Report**:  
- **[M-04] Out of gas**

---

### **Analysis of Gaps**  
The `response_list` partially addresses the issue of missing input validation in `sendCollaterals` but fails to explicitly highlight the risk of unwhitelisted tokens. Additionally, it completely misses the issue of unbounded array growth in `poolColl.tokens[]` and its impact on gas costs. These gaps indicate a need for more comprehensive coverage of vulnerabilities related to input validation and gas optimization in the `response_list`.","```
None.
```",0.0
BorrowerOperations.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, etc. 
 */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        // transfer collateral into ActivePool
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called _after_ collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist and no duplicates
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }


        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // Use the unmodified _YUSDChange here, as we don't send the fee to the user
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        // transfer withdrawn collateral to msg.sender from ActivePool
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     */
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    /* Checks that:
     * 1. _colls contains no duplicates
     * 2. All elements of _colls are active collateral on the whitelist
     */
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    // requires that avax indices are in order
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",9859,1116,"[M-05] Reentrancy in contracts/BorrowerOperations.sol

Submitted by heiho1, also found by jayjonah8
Impact

There are several potential re-entrant functions in contracts/BorrowerOperations.sol:
=> Function addColl() on line 346 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _adjustTrove() which potentially impacts user debt, collateral top-ups or withdrawals.
Same applies to
-- withdrawColl() on line 373 -- withdrawYUSD() on line 389 -- repayYUSD() on line 406 -- adjustTrove() on line 420
=> Function openTrove() on line 207 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _openTroveInternal() which potentially impacts trove creation, YUSD withdrawals and YUSD gas compensation.
=> Function closeTrove() on line 628 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes troveManagerCached.r
",1,,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";



contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    
    
    
    
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, 
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); 

        _requireAtLeastMinNetDebt(vars.netDebt);
        
        
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); 
            _requireNewTCRisAboveCCR(newTCR);
        }

        
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    
    
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    
    
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); 
        _requireNoDuplicateColls(_collsOut);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, 
                params._maxFeePercentage
            );
            
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); 
        }


        
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); 
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        
        
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    
    function claimCollateral() external override {
        
        collSurplusPool.claimColl(msg.sender);
    }

    

    
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); 
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    
    
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); 
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { 
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { 
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    
    
    
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    

    
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    

    
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",8265,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Initialization"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is used appropriately to protect sensitive functions like `setAddresses`."",
        ""Confirm that the contract is initialized correctly via the `setAddresses` function and that all necessary contract addresses are set."",
        ""Analyze the impact of renouncing ownership in `setAddresses`. Ensure this is the intended behavior, as it makes the contract immutable after initialization."",
        ""Check for any potential vulnerabilities related to incorrect or missing initialization of state variables.""
      ]
    },
    {
      ""Area"": ""Fee Calculation and Manipulation"",
      ""Tasks"": [
        ""Examine the logic within `_triggerBorrowingFee` to ensure the borrowing fee is calculated correctly and that there are no rounding errors or potential for manipulation."",
        ""Analyze the `whitelist.getFeeAndUpdate` function in `_getTotalVariableDepositFee` for potential vulnerabilities that could lead to fee manipulation or incorrect fee calculations."",
        ""Investigate the conditions under which fees are applied during the bootstrap period, particularly the `_min(whitelistFee, 1e16)` logic. Ensure this doesn't unintentionally create vulnerabilities."",
        ""Verify that the `_requireUserAcceptsFee` function prevents users from bypassing fee payments by setting an unreasonably low `_maxFeePercentage`."",
        ""Analyze the relationship between sYETI minting and fees. Confirm that the sYETI contract and the minting process are secure and cannot be exploited to create sYETI without proper fee payment."",
        ""Check the formula used to deduct `vars.YUSDFee` from `_maxFeePercentage` in `_openTroveInternal` to confirm it is behaving as intended.""
      ]
    },
    {
      ""Area"": ""Collateral Management and Whitelist"",
      ""Tasks"": [
        ""Thoroughly review the `_transferCollateralsIntoActivePool` function to ensure collateral tokens are transferred securely and that there are no vulnerabilities related to ERC-20 token implementations (e.g., tokens that don't return `true` on transfer)."",
        ""Analyze the `whitelist.getIsActive` function in `_requireValidDepositCollateral` and `whitelist.isValidRouter` to ensure the collateral whitelist mechanism is secure and that only approved collateral types can be used."",
        ""Investigate the logic within `activePool.sendCollateralsUnwrap` in both `_adjustTrove` and `closeTrove` to verify that collateral is correctly unwrapped and sent to the borrower, and that no collateral can be unintentionally lost or stolen."",
        ""Inspect the `_requireNoOverlapColls` and `_requireNoDuplicateColls` functions to verify their effectiveness in preventing issues arising from duplicate or overlapping collateral addresses.""
      ]
    },
    {
      ""Area"": ""Debt Calculation and Trove Management"",
      ""Tasks"": [
        ""Review the composite debt calculation in `_getCompositeDebt` and its usage throughout the contract to ensure it accurately reflects the Trove's debt and that there are no potential vulnerabilities related to its calculation or application."",
        ""Analyze the `_updateTroveFromAdjustment` function to ensure that Trove collateral and debt are updated correctly and consistently, and that there are no vulnerabilities related to integer overflows or underflows."",
        ""Examine the logic in `openTrove` and `adjustTrove` regarding Recovery Mode. Specifically, verify that the ICR and TCR checks (`_requireICRisAboveCCR`, `_requireICRisAboveMCR`, `_requireNewTCRisAboveCCR`) are enforced correctly and prevent the system from entering an unsound state."",
        ""Check for reentrancy vulnerabilities, especially in functions that interact with external contracts such as `_transferCollateralsIntoActivePool`, `_withdrawYUSD`, and `_repayYUSD`."",
        ""Analyze the logic in the `closeTrove` function to ensure that YUSD repayment and collateral withdrawal are handled correctly and securely, and that borrowers receive the correct amount of collateral after closing their Trove."",
        ""Examine `_moveYUSD` and confirm `_withdrawYUSD` and `_repayYUSD` are behaving as expected.""
      ]
    },
    {
      ""Area"": ""Recovery Mode and System State"",
      ""Tasks"": [
        ""Verify that the `_checkRecoveryMode` function is implemented correctly and accurately reflects the current state of the system."",
        ""Analyze the handling of Recovery Mode within the `adjustTrove` and `closeTrove` functions to ensure that the appropriate restrictions and checks are applied."",
        ""Check that the `_requireValidAdjustmentInCurrentMode` function correctly enforces the restrictions on collateral withdrawal and ICR/TCR changes during Recovery Mode."",
        ""Ensure no unexpected behavior occurs in the `closeTrove` function by verifying that it can not be executed during recovery mode via `_requireNotInRecoveryMode()`.""
      ]
    },
    {
      ""Area"": ""Arithmetic and Overflow/Underflow"",
      ""Tasks"": [
        ""Review all arithmetic operations, especially those involving collateral amounts, debt, and fees, to ensure that there are no potential integer overflow or underflow vulnerabilities. Consider using SafeMath or similar libraries to mitigate these risks (though the solidity version may handle this)."",
        ""Pay close attention to calculations involving `DECIMAL_PRECISION` to ensure that the results are accurate and that there are no unexpected rounding errors."",
        ""Specifically review the functions `_getNewICRFromTroveChange` and `_getNewTCRFromTroveChange` as there are many arithmetic operations that could cause issues.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `BorrowerOperations` handles user interactions with Troves, including opening, adjusting, and closing them. It manages collateral deposits, YUSD borrowing and repayment, and interacts with various other contracts within the Liquity protocol, such as the TroveManager, ActivePool, YUSDToken, and SortedTroves.  The contract also incorporates a whitelist for approved collateral types and calculates borrowing and deposit fees. It aims to provide a secure and efficient interface for users to manage their Troves."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BorrowerOperations"",
    ""Purpose"": ""Provides functions for users to open, adjust, and close Troves, including handling collateral deposits, YUSD borrowing and repayment, and fee calculations."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""LiquityBase"", ""Ownable"", ""CheckContract""],
      ""Imports"": [
        ""./Interfaces/IBorrowerOperations.sol"",
        ""./Interfaces/ITroveManager.sol"",
        ""./Interfaces/IYUSDToken.sol"",
        ""./Interfaces/ICollSurplusPool.sol"",
        ""./Interfaces/ISortedTroves.sol"",
        ""./Interfaces/ISYETI.sol"",
        ""./Interfaces/IWhitelist.sol"",
        ""./Interfaces/IYetiRouter.sol"",
        ""./Dependencies/LiquityBase.sol"",
        ""./Dependencies/Ownable.sol"",
        ""./Dependencies/CheckContract.sol"",
        ""./Interfaces/IERC20.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""NAME"",
        ""Type"": ""string public constant"",
        ""Purpose"": ""Stores the name of the contract.""
      },
      {
        ""Name"": ""troveManager"",
        ""Type"": ""ITroveManager public"",
        ""Purpose"": ""Address of the TroveManager contract.""
      },
      {
        ""Name"": ""stabilityPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the StabilityPool contract.""
      },
      {
        ""Name"": ""gasPoolAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the GasPool contract.""
      },
      {
        ""Name"": ""collSurplusPool"",
        ""Type"": ""ICollSurplusPool"",
        ""Purpose"": ""Address of the CollSurplusPool contract.""
      },
       {
        ""Name"": ""sYETI"",
        ""Type"": ""ISYETI public"",
        ""Purpose"": ""Address of the sYETI contract.""
      },
      {
        ""Name"": ""sYETIAddress"",
        ""Type"": ""address public"",
        ""Purpose"": ""Address of the sYETI contract.""
      },
      {
        ""Name"": ""yusdToken"",
        ""Type"": ""IYUSDToken public"",
        ""Purpose"": ""Address of the YUSDToken contract.""
      },
      {
        ""Name"": ""BOOTSTRAP_PERIOD"",
        ""Type"": ""uint public constant"",
        ""Purpose"": ""Defines the length of the bootstrap period (14 days).""
      },
      {
        ""Name"": ""deploymentTime"",
        ""Type"": ""uint"",
        ""Purpose"": ""Stores the deployment timestamp of the contract.""
      },
      {
        ""Name"": ""sortedTroves"",
        ""Type"": ""ISortedTroves public"",
        ""Purpose"": ""Address of the SortedTroves contract.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the addresses of other contracts in the system."",
        ""Parameters"": [
          ""_troveManagerAddress"",
          ""_activePoolAddress"",
          ""_defaultPoolAddress"",
          ""_stabilityPoolAddress"",
          ""_gasPoolAddress"",
          ""_collSurplusPoolAddress"",
          ""_sortedTrovesAddress"",
          ""_yusdTokenAddress"",
          ""_sYETIAddress"",
          ""_whitelistAddress""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""openTrove"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to open a new Trove."",
        ""Parameters"": [
          ""_maxFeePercentage"",
          ""_YUSDAmount"",
          ""_upperHint"",
          ""_lowerHint"",
          ""_colls"",
          ""_amounts""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_openTroveInternal"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle the logic of opening a trove after initial checks"",
        ""Parameters"": [
          ""_troveOwner"",
          ""_maxFeePercentage"",
          ""_YUSDAmount"",
          ""_upperHint"",
          ""_lowerHint"",
          ""_colls"",
          ""_amounts""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""addColl"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to add collateral to an existing Trove."",
        ""Parameters"": [""_collsIn"", ""_amountsIn"", ""_upperHint"", ""_lowerHint"", ""_maxFeePercentage""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawColl"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw collateral from an existing Trove."",
        ""Parameters"": [""_collsOut"", ""_amountsOut"", ""_upperHint"", ""_lowerHint""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawYUSD"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to withdraw YUSD from an existing Trove."",
        ""Parameters"": [""_maxFeePercentage"", ""_YUSDAmount"", ""_upperHint"", ""_lowerHint""],
        ""Returns"": []
      },
      {
        ""Name"": ""repayYUSD"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to repay YUSD to an existing Trove."",
        ""Parameters"": [""_YUSDAmount"", ""_upperHint"", ""_lowerHint""],
        ""Returns"": []
      },
      {
        ""Name"": ""adjustTrove"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to adjust an existing Trove by changing collateral and/or debt."",
        ""Parameters"": [
          ""_collsIn"",
          ""_amountsIn"",
          ""_collsOut"",
          ""_amountsOut"",
          ""_YUSDChange"",
          ""_isDebtIncrease"",
          ""_upperHint"",
          ""_lowerHint"",
          ""_maxFeePercentage""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""closeTrove"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to close their Trove."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""claimCollateral"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to claim collateral from the CollSurplusPool."",
        ""Parameters"": [],
        ""Returns"": []
      },
       {
        ""Name"": ""_getTotalVariableDepositFee"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculate the total variable deposit fee"",
        ""Parameters"": [
          ""address[] memory _tokensIn"",
          ""uint256[] memory _amountsIn"",
          ""uint256 _VCin"",
          ""uint256 _VCout"",
          ""uint256 _maxFeePercentageFactor"",
          ""uint256 _maxFeePercentage"",
          ""ContractsCache memory _contractsCache""
        ],
        ""Returns"": [""uint256 YUSDFee""]
      },
      {
        ""Name"": ""_transferCollateralsIntoActivePool"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers specified collateral tokens from an address to the ActivePool contract."",
        ""Parameters"": [""address _from"", ""address[] memory _colls"", ""uint256[] memory _amounts""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_triggerBorrowingFee"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates and triggers the borrowing fee by minting YUSD to sYETI address."",
        ""Parameters"": [
          ""ITroveManager _troveManager"",
          ""IYUSDToken _yusdToken"",
          ""uint256 _YUSDAmount"",
          ""uint256 _maxFeePercentageFactor"",
          ""uint256 _maxFeePercentage""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_triggerDepositFee"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculate and triggers the deposit fee by minting YUSD to sYETI address."",
        ""Parameters"": [""IYUSDToken _yusdToken"", ""uint256 _YUSDFee""],
        ""Returns"": []
      },
      {
        ""Name"": ""_updateTroveFromAdjustment"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Updates the trove's state with adjusted collateral and debt amounts."",
        ""Parameters"": [
          ""ITroveManager _troveManager"",
          ""address _borrower"",
          ""address[] memory _finalColls"",
          ""uint256[] memory _finalAmounts"",
          ""uint256 _newVC"",
          ""uint256 _debtChange"",
          ""bool _isDebtIncrease"",
          ""uint256 _variableYUSDFee""
        ],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""_getNewPortfolio"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates the new portfolio of collateral tokens and amounts after adjustments."",
        ""Parameters"": [
          ""address[] memory _initialTokens"",
          ""uint256[] memory _initialAmounts"",
          ""address[] memory _tokensIn"",
          ""uint256[] memory _amountsIn"",
          ""address[] memory _tokensOut"",
          ""uint256[] memory _amountsOut""
        ],
        ""Returns"": [""address[] memory"", ""uint256[] memory""]
      },
      {
        ""Name"": ""_moveYUSD"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Handles the transfer of YUSD based on whether the debt is increasing or decreasing."",
        ""Parameters"": [
          ""IActivePool _activePool"",
          ""IYUSDToken _yusdToken"",
          ""address _borrower"",
          ""uint256 _YUSDChange"",
          ""bool _isDebtIncrease"",
          ""uint256 _netDebtChange""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_withdrawYUSD"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Mints YUSD to the account and increases the YUSD debt in the ActivePool."",
        ""Parameters"": [
          ""IActivePool _activePool"",
          ""IYUSDToken _yusdToken"",
          ""address _account"",
          ""uint256 _YUSDAmount"",
          ""uint256 _netDebtIncrease""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_repayYUSD"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Burns YUSD from the account and decreases the YUSD debt in the ActivePool."",
        ""Parameters"": [""IActivePool _activePool"", ""IYUSDToken _yusdToken"", ""address _account"", ""uint256 _YUSD""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireValidDepositCollateral"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if the specified collateral tokens are whitelisted and have no duplicates."",
        ""Parameters"": [""address[] memory _colls""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireNonZeroAdjustment"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that there is either a collateral change or a debt change."",
        ""Parameters"": [
          ""uint256[] memory _amountsIn"",
          ""uint256[] memory _amountsOut"",
          ""uint256 _YUSDChange""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_arrayIsNonzero"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Checks if any element in an array is non-zero."",
        ""Parameters"": [""uint256[] memory arr""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_isBeforeFeeBootstrapPeriod"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if the current block timestamp is before the end of the bootstrap period."",
        ""Parameters"": [],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_requireTroveisActive"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a Trove is active."",
        ""Parameters"": [""ITroveManager _troveManager"", ""address _borrower""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireTroveisNotActive"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks if a Trove is not active."",
        ""Parameters"": [""ITroveManager _troveManager"", ""address _borrower""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireNonZeroDebtChange"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires a non-zero debt change."",
        ""Parameters"": [""uint256 _YUSDChange""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireNoOverlapColls"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that there are no overlapping collateral tokens between two arrays."",
        ""Parameters"": [""address[] memory _colls1"", ""address[] memory _colls2""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireNoDuplicateColls"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that there are no duplicate collateral tokens in an array."",
        ""Parameters"": [""address[] memory _colls""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireNotInRecoveryMode"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Checks that the system is not in recovery mode."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireNoCollWithdrawal"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that there is no collateral withdrawal during recovery mode."",
        ""Parameters"": [""uint256[] memory _amountOut""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireValidAdjustmentInCurrentMode"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Requires that the adjustment is valid based on the current mode (normal or recovery)."",
        ""Parameters"": [
          ""bool _isRecoveryMode"",
          ""uint256[] memory _collWithdrawal"",
          ""bool _isDebtIncrease"",
          ""LocalVariables_adjustTrove memory _vars""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireICRisAboveMCR"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that the new ICR is above the MCR."",
        ""Parameters"": [""uint256 _newICR""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireICRisAboveCCR"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that the new ICR is above the CCR."",
        ""Parameters"": [""uint256 _newICR""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireNewICRisAboveOldICR"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that the new ICR is above the old ICR."",
        ""Parameters"": [""uint256 _newICR"", ""uint256 _oldICR""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireNewTCRisAboveCCR"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that the new TCR is above the CCR."",
        ""Parameters"": [""uint256 _newTCR""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireAtLeastMinNetDebt"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that the Trove's net debt is above the minimum."",
        ""Parameters"": [""uint256 _netDebt""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireValidYUSDRepayment"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that the YUSD repayment is valid."",
        ""Parameters"": [""uint256 _currentDebt"", ""uint256 _debtRepayment""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireSufficientYUSDBalance"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Requires that the borrower has enough YUSD to make the repayment."",
        ""Parameters"": [""IYUSDToken _yusdToken"", ""address _borrower"", ""uint256 _debtRepayment""],
        ""Returns"": []
      },
      {
        ""Name"": ""_requireValidMaxFeePercentage"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Requires that the max fee percentage is within the valid range."",
        ""Parameters"": [""uint256 _maxFeePercentage"", ""bool _isRecoveryMode""],
        ""Returns"": []
      },
      {
        ""Name"": ""_getNewICRFromTroveChange"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the new ICR after a Trove change."",
        ""Parameters"": [
          ""uint256 _newVC"",
          ""uint256 _debt"",
          ""uint256 _debtChange"",
          ""bool _isDebtIncrease""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_getNewTCRFromTroveChange"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates the new TCR after a Trove change."",
        ""Parameters"": [
          ""uint256 _collChange"",
          ""bool _isCollIncrease"",
          ""uint256 _debtChange"",
          ""bool _isDebtIncrease""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getCompositeDebt"",
        ""Visibility"": ""external pure"",
        ""Purpose"": ""Returns the composite debt."",
        ""Parameters"": [""uint256 _debt""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_max"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Returns the maximum of two unsigned integers."",
        ""Parameters"": [""uint256 _a"", ""uint256 _b""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_min"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Returns the minimum of two unsigned integers."",
        ""Parameters"": [""uint256 _a"", ""uint256 _b""],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ITroveManager"",
    ""IActivePool"",
    ""IDefaultPool"",
    ""IWhitelist"",
    ""IYUSDToken"",
    ""ISortedTroves"",
    ""ICollSurplusPool"",
    ""ISYETI"",
    ""IERC20""
  ],
  ""SpecialMechanisms"": [
    ""Fee calculation and distribution (borrowing fee, variable deposit fee)"",
    ""Collateral whitelist management"",
    ""Recovery mode handling"",
    ""Hints for SortedTroves insertion"",
    ""Debt and collateral accounting with composite debt calculations""
  ],
  ""Questions"": [
    ""What is the purpose of the `sYETI` contract, and how is it integrated into the fee mechanism?"",
    ""What specific criteria determine the fees returned by the whitelist, and how is `whitelist.getFeeAndUpdate` secured against manipulation?"",
    ""What is the purpose of the composite debt calculation and how does it impact the overall system's risk management?"",
    ""Are there any considerations for gas optimization within the fee calculations and collateral transfers?"",
    ""Is the `_renounceOwnership()` in `setAddresses()` intended to be permanent, making the contract immutable after initial setup?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The contract lacks reentrancy protection in multiple functions that interact with external contracts (e.g., ActivePool, YUSDToken). A malicious contract could re-enter `BorrowerOperations` during these external calls, potentially manipulating the state of the contract, draining funds from the active pool, bypassing intended logic, or causing incorrect state updates. Functions `_adjustTrove` and `closeTrove` are vulnerable, as they interact with the `activePool` before setting the user trove status as not active. `_moveYUSD` function calls `_withdrawYUSD` or `_repayYUSD` based on `_isDebtIncrease`. Both `_withdrawYUSD` and `_repayYUSD` interact with external contracts (`_activePool` and `_yusdToken`) using `mint` and `burn` respectively."",
      ""Impact"": ""Critical vulnerability leading to potential theft of funds, collateral manipulation, denial of service, or loss of funds, incorrect debt calculation, and potential instability of the system."",
      ""Location"": ""Multiple functions involving external calls, particularly `_moveYUSD`, `_withdrawYUSD`, `_repayYUSD`, `_transferCollateralsIntoActivePool`, `_adjustTrove`, `closeTrove`""
    },
    {
      ""Issue"": ""Missing Input Validation for Collateral Addresses and Amounts"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `openTrove` and `adjustTrove` functions rely on external data (e.g., `_colls`, `_amounts`, `_collsIn`, `_amountsIn`, `_collsOut`, `_amountsOut`) provided by the user without sufficient validation. There are no checks performed within `_transferCollateralsIntoActivePool` to ensure that each collateral address `_colls[i]` is actually a contract or an EOA that supports ERC20 `transferFrom` functionality. Also, there is a lack of explicit checks to ensure that `_amounts` are non-zero or excessively large before performing calculations or that addresses are non-zero."",
      ""Impact"": ""Possible denial of service or loss of funds if invalid collateral addresses are used. Possible arithmetic overflow/underflow in subsequent calculations, potentially leading to incorrect ICR calculations, or denial-of-service."",
      ""Location"": ""functions `openTrove`, `adjustTrove`, `_transferCollateralsIntoActivePool`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in Trove Operations"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions, including `openTrove`, `addColl`, `withdrawColl`, `withdrawYUSD`, `repayYUSD`, and `adjustTrove`, are susceptible to front-running attacks. A malicious actor could monitor the mempool for pending transactions and manipulate the system's state (e.g., TCR, base rate, collateral prices) to their advantage before the user's transaction is executed, leading to unexpected liquidations, high fees, or suboptimal Trove placement."",
      ""Impact"": ""Users might experience unexpected liquidations or less favorable terms when interacting with their Troves. Griefing, Failed Trove Operations, unexpected high fees"",
      ""Location"": ""Functions `openTrove`, `addColl`, `withdrawColl`, `withdrawYUSD`, `repayYUSD`, `adjustTrove`, `BorrowerOperations.sol:_triggerBorrowingFee`, `BorrowerOperations.sol:_getTotalVariableDepositFee`""
    },
    {
      ""Issue"": ""Inconsistent Fee Calculation and Handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""Fee calculations in `_adjustTrove` distinguish between debt increases and other adjustments, leading to inconsistencies in fees for equivalent trove adjustments. In Recovery Mode, `_triggerBorrowingFee` may not use `_maxFeePercentage` correctly, resulting in unexpected fees. Also, it's not clear how the deposit fee calculated by `_getTotalVariableDepositFee` affects ICR and TCR."",
      ""Impact"": ""Potential inconsistencies in fee calculations that may disincentivize users, unexpected borrowing fees in Recovery Mode, inaccurate debt accounting potentially leading to liquidation issues."",
      ""Location"": ""function `_adjustTrove`, `_openTroveInternal`, `_triggerBorrowingFee`, `_getTotalVariableDepositFee`, `_openTroveInternal`""
    },
    {
      ""Issue"": ""Missing Input Validation for Array Lengths"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `openTrove` and `adjustTrove` functions, along with `_getNewPortfolio`, lack explicit upper bounds on the lengths of input arrays (`_colls`, `_amounts`, `_collsIn`, `_amountsIn`, `_collsOut`, `_amountsOut`, `_initialTokens`, `_initialAmounts`). Also, `_getNewPortfolio` does not explicitly check if the lengths of `_initialTokens` and `_initialAmounts` are equal, or if `_tokensIn` and `_amountsIn` have matching lengths, or if `_tokensOut` and `_amountsOut` have matching lengths."",
      ""Impact"": ""Potential denial-of-service (DoS) vulnerability if a malicious user provides extremely large or mismatched arrays, causing the transaction to run out of gas or exceeding memory limits."",
      ""Location"": ""`openTrove` function, `adjustTrove` function, `_getNewPortfolio`, `_sumColls` and `_subColls`""
    },
    {
      ""Issue"": ""Potential denial of service during `setAddresses` Function."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setAddresses` function is called once during initialization and lacks validation. Someone front-running can steal ownership and set the addresses to malicious contracts, effectively bricking the contract. Also, The `setAddresses` function doesnâ€™t validate if any of the input addresses are the zero address."",
      ""Impact"": ""Bricking the contract during the initialization phase, making the system unusable."",
      ""Location"": ""`setAddresses` function.""
    },
    {
      ""Issue"": ""Lack of slippage protection in token transfers and whitelist"",
      ""Severity"": ""Medium"",
      ""Description"": ""The code relies on the user correctly estimating the amounts of collateral to provide. If there is a significant price slippage or difference between expected amount and actual amount, the trove could be opened or adjusted to a state where it is undercollateralized. The `_getTotalVariableDepositFee` function uses whitelist to get fee and update the state without any slippage protection for manipulated values."",
      ""Impact"": ""Users losing collateral due to immediate liquidations. Users could end up paying unexpected large fees."",
      ""Location"": ""`openTrove`, `adjustTrove` functions, `Function _getTotalVariableDepositFee`""
    },
    {
      ""Issue"": ""Race Condition in `whitelist.getFeeAndUpdate`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `whitelist.getFeeAndUpdate` is called within a loop in `_getTotalVariableDepositFee`. Concurrent transactions, or complex transactions with many ERC20 tokens in the whitelist, could experience unexpected state changes in the whitelist between iterations due to other operations. This can cause inconsistent fee calculations."",
      ""Impact"": ""Inconsistent fee calculations, potential for denial of service or unexpected fee rates."",
      ""Location"": ""BorrowerOperations.sol:_getTotalVariableDepositFee""
    },
    {
      ""Issue"": ""Unchecked subtraction in `repayYUSD`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In function `closeTrove` there is an unchecked subtraction in `_requireSufficientYUSDBalance`. In case `debt` is less than `YUSD_GAS_COMPENSATION` the transaction will revert. This means that troves with debt lower than `YUSD_GAS_COMPENSATION` cannot be closed."",
      ""Impact"": ""Cannot close troves with debt lower than `YUSD_GAS_COMPENSATION`."",
      ""Location"": ""`closeTrove` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses Solidity 0.6.11, which lacks built-in overflow/underflow protection. Although SafeMath-like libraries (`LiquityBase`) are used, there could be potential vulnerabilities if intermediate calculations in fee calculations, especially in `_getTotalVariableDepositFee` and `_triggerBorrowingFee`, result in very large numbers that could cause inaccuracies or underflows."",
      ""Impact"": ""Incorrect fee calculations, potentially resulting in users being charged incorrect amounts."",
      ""Location"": ""functions `_getTotalVariableDepositFee`, `_triggerBorrowingFee` and all arithmetic operations.""
    },
    {
      ""Issue"": ""Unbounded Loop Risk"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `_sumColls` and `_subColls` used in `_getNewPortfolio`, and the functions `_requireNoOverlapColls` and `_requireNoDuplicateColls`, donâ€™t have limits on the size of the input arrays. If these arrays become excessively large, the loops within these functions could consume excessive gas, potentially leading to a denial-of-service (DoS). Especially important if this data could be controlled by users"",
      ""Impact"": ""Potential for Denial of Service (DoS) due to excessive gas consumption."",
      ""Location"": ""Functions `_getNewPortfolio`, `_sumColls`, and `_subColls`,`_requireNoOverlapColls`, `_requireNoDuplicateColls`""
    },
    {
      ""Issue"": ""Missing Check for Zero Addresses in `setAddresses` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setAddresses` function, which is used to set the addresses of critical contracts, lacks a check to ensure that the provided addresses are not the zero address. Setting a core contract address to the zero address could lead to the contract becoming unusable."",
      ""Impact"": ""Potential for contract malfunction and denial of service."",
      ""Location"": ""Function `setAddresses`""
    },
    {
      ""Issue"": ""Missing validation of `_upperHint` and `_lowerHint` addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_upperHint` and `_lowerHint` parameters in the `openTrove` and `adjustTrove` functions are used to maintain the sorted list of Troves. However, there is no explicit validation to ensure that these addresses are valid or non-zero. Invalid hint addresses might lead to issues with the ordering of Troves and incorrect liquidation sequences."",
      ""Impact"": ""Potential degradation of Trove sorting, potentially leading to suboptimal liquidation order."",
      ""Location"": ""`openTrove`, `adjustTrove` functions""
    },
    {
      ""Issue"": ""Lack of Input Validation for Collateral Addresses in `_requireValidDepositCollateral`"",
      ""Severity"": ""Low"",
      ""Description"": ""While `_requireValidDepositCollateral` checks if a collateral address is active via the `whitelist`, it lacks a check to ensure that the address is actually a contract. A user could potentially pass an EOA address as collateral, causing unexpected behavior."",
      ""Impact"": ""Unexpected behavior and potential for errors."",
      ""Location"": ""Function `_requireValidDepositCollateral`""
    },
    {
      ""Issue"": ""Potential rounding error in fee calculation due to integer division."",
      ""Severity"": ""Low"",
      ""Description"": ""In the function `_triggerBorrowingFee`, the base rate decay is triggered using `_troveManager.decayBaseRateFromBorrowing()`. After this, the fee amount is computed as `uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);`. Due to integer division, there could be rounding errors that slightly affect the accuracy of the calculated fee."",
      ""Impact"": ""Minor inaccuracies in fee calculation, potential for slight imbalances in the system over time."",
      ""Location"": ""BorrowerOperations.sol:_triggerBorrowingFee, BorrowerOperations.sol:_openTroveInternal""
    },
    {
      ""Issue"": ""Unprotected `sYETIAddress` allows for potential griefing"",
      ""Severity"": ""Low"",
      ""Description"": ""The `sYETIAddress` is used as the recipient of minted YUSD during the borrowing fee calculation. If the `sYETIAddress` is accidentally set to an incorrect or non-operational address, any YUSD minted as fees during borrowing would be effectively lost"",
      ""Impact"": ""Loss of fees, potential disruption of the sYETI system."",
      ""Location"": ""BorrowerOperations.sol:_triggerBorrowingFee, BorrowerOperations.sol:_triggerDepositFee""
    },
    {
      ""Issue"": ""Bootstrap Period Fee Manipulation"",
      ""Severity"": ""Low"",
      ""Description"": ""During the bootstrap period, the whitelist fee is capped at 1e16. A malicious actor could try to manipulate the fee by strategically depositing and withdrawing collaterals, to maximize the fee paid to SYETI."",
      ""Impact"": ""Slightly increased fees for borrowers, benefiting SYETI holders. Possible manipulation of the system."",
      ""Location"": ""`_getTotalVariableDepositFee` function, specifically the conditional `if (_isBeforeFeeBootstrapPeriod())`.""
    },
    {
      ""Issue"": ""Possible Integer Overflow in _getTotalVariableDepositFee Calculations"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `_getTotalVariableDepositFee` function, the multiplication of `vars.collateralInputVC` with `whitelistFee` could potentially lead to an integer overflow if these values are sufficiently large. While the result is then divided by `1e18`, if the overflow occurs *before* the division, the result will be incorrect and may affect the final `YUSDFee` calculation."",
      ""Impact"": ""Incorrect YUSDFee calculation, potential for user loss."",
      ""Location"": ""Function `_getTotalVariableDepositFee`""
    },
    {
      ""Issue"": ""Unused Local Variable"",
      ""Severity"": ""Info"",
      ""Description"": ""The local variable `vars.prices` is declared but never used within the function `_openTroveInternal`. This indicates a potential oversight and could suggest missing functionality."",
      ""Impact"": ""Unused variable that may indicate a missing functionality"",
      ""Location"": ""`_openTroveInternal` function""
    }
  ],
  ""IssueNumber"": 46,
  ""OutputList"": 19
}",166.53544282913208,3736.0,26.0,"### **[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Report Description**:  
The issue identifies several functions in `BorrowerOperations.sol` that are potentially re-entrant due to the lack of reentrancy guards. These functions include `addColl()`, `withdrawColl()`, `withdrawYUSD()`, `repayYUSD()`, `adjustTrove()`, `openTrove()`, and `closeTrove()`. Each of these functions interacts with external contracts or state variables without protection, which could allow a malicious actor to re-enter the contract and manipulate its state, leading to potential theft of funds, incorrect debt calculations, or other vulnerabilities.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in `BorrowerOperations.sol`. It highlights the lack of reentrancy protection in multiple functions that interact with external contracts, such as `ActivePool` and `YUSDToken`. The response also correctly explains the potential impact, including theft of funds, collateral manipulation, and incorrect state updates. This aligns with the issue report's description and Solidity best practices for preventing reentrancy attacks.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- *None*

---

### **Conclusion**  
The response list effectively addresses the reentrancy issue reported in `BorrowerOperations.sol`. The description, impact, and location of the vulnerability are accurately matched, and the response aligns with Solidity security best practices. No gaps or missed issues were identified in this comparison.","```
1. Potential Reentrancy Vulnerability
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Potential Reentrancy Vulnerability"".
   - In the ranked list of predictions, this issue appears at **rank 1**.

2. **Calculate the precision at rank 1 (P@1)**:
   - Precision at rank 1 is the ratio of true positives up to rank 1 to the total number of predictions up to rank 1.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
ThreePieceWiseLinearPriceCurve.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";

/** 
 * This contract is used to calculate the variable fee for an input of tokens. 
 * Uses three linear piecewise functions to calculate the fee, and the average 
 * of the system collateralization by that asset before and after the tx. 
 */
contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    /** 
     * f1 = m1 * x + b1
     * f1 meets f2 at cutoff1, which is defined by that intersection point and slope m2
     * f2 meets f3 at cutoff2, which is defined by that intersection point and slope m3
     * Everything in terms of actual * 1e18, scaled by 1e18 because can't do percentages
     * Decimal precision = 1e18
     */

    /** 
     * Function for setting slopes and intercepts of linear functions used for fee calculations. 
     */
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        // b2 = _m1.mul(_cutoff1).div(1e18).add(_b1).sub(_m2.mul(_cutoff1).div(1e18));
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        // b3 = _m2.mul(_cutoff2).div(1e18).add(b2).sub(_m3.mul(_cutoff2).div(1e18));
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; // Cap in VC terms of max of this asset. dollarCap = 0 means no cap. No cap.
        decayTime = 5 days;
    }

    // Set the whitelist address so that the fee can only be updated by whitelistAddress
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    // Set the decay time in seconds
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    // Gets the fee cap and time currently. Used for setting new values for next price curve. 
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. 
    // Called only by whitelist. 
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     * @param _collateralVCInput is how much collateral is being input by the user into the system
     * @param _totalCollateralVCBalance is how much collateral is in the system
     * @param _totalVCBalancePost is how much VC the system for all collaterals after all adjustments (additions, subtractions)
     */
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    // Called only by whitelist. Updates the last fee time and last fee percent
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     */
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        // percent of all VC backed by this collateral * 1e18
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { // use function 1
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { // use function 2
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            // return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
        } else { // use function 3
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            // return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        // Decay within bounds of decay time, then decay the fee. 
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            // If it has been longer than decay time, then reset fee to 0.
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}

",2218,197,"[M-07] Cannot use most piecewise linear functions with current implementation

TheÂ ThreePieceWiseLinearPriceCurve.adjustParamsÂ function uses three functionsÂ f1, f2, f3Â whereÂ y_i = f_i(x_i). It computes the y-axis intersect (b2 = f_2(0), b3 = f_3(0)) for each of these but usesÂ unsigned integersÂ for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.
â€¨
[M-08] Wrong comment inÂ getFee

TheÂ ThreePieceWiseLinearPriceCurve.getFeeÂ comment states that the total + the input must be less than the cap:
If dollarCap == 0, then it is not capped. Otherwise,Â then the total + the total inputÂ must be less than the cap.
The code only checks if the input is less than the cap:
// @param _collateralVCInput is how much collateral is being input by the user into the system
if (dollarCap != 0) {
    require(_collateralVCInput <= dollarCap, ""Collateral input exceeds cap"");
}
â€¨â€¨â€¨[M-09] Fee not decayed if pastÂ decayTime

TheÂ ThreePieceWiseLinearPriceCurve.calculateDecayedFeeÂ function is supposed to decay theÂ lastFeePercentÂ over time. This is correctly done in theÂ decay > 0 && decay < decayTimeÂ case, but for theÂ decay > decayTimeÂ case it does not decay at all but should set it to 0 instead..
if (decay > 0 && decay < decayTime) {
    // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay > decayTime should return 0.
    fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime));
} else {
    fee = lastFeePercent;
}
",3,,"pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";


contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    

    
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; 
        decayTime = 5 days;
    }

    
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    
    
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { 
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { 
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            
        } else { 
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",1536,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Parameter Validation and Curve Behavior"",
      ""Tasks"": [
        ""Analyze the `adjustParams` function to verify that the calculated values of `b2` and `b3`, and the boolean flags `b2Negative` and `b3Negative`, result in the intended three-piecewise linear curve behavior across all possible inputs for `_m1`, `_b1`, `_m2`, `_cutoff1`, `_m3`, and `_cutoff2`.  Consider edge cases where slopes are zero or extremely large, or when cutoffs are equal."",
        ""Specifically, create a test suite that rigorously checks the price curve at and around `cutoff1` and `cutoff2` to ensure continuity and expected fee values given various combinations of `m1`, `b1`, `m2`, `m3`, and cutoff values. Include tests to ensure `b2Negative` and `b3Negative` are correctly set based on the input parameters."",
        ""Verify that the calculated fee never exceeds 1e18 (100%) due to incorrect parameter configurations."",
        ""Investigate potential denial-of-service vulnerabilities in `adjustParams` if extremely large numbers are used for parameters. Consider adding checks to limit maximum values for slopes and intercepts.""
      ]
    },
    {
      ""Area"": ""Access Control and Whitelist"",
      ""Tasks"": [
        ""Confirm that the `Ownable` contract is implemented correctly and that only the owner can call `adjustParams`, `setAddresses`, and `setDecayTime`."",
        ""Verify that only the `whitelistAddress` can call `setFeeCapAndTime` and `getFeeAndUpdate`."",
        ""Audit the `setAddresses` function to ensure that the `addressesSet` flag prevents re-setting the whitelist address.  Consider the implications if the whitelist address is accidentally set to the zero address."",
        ""Evaluate the security implications of having a single whitelist address. Consider the possibility of multi-sig or more robust role-based access control for managing fee updates.""
      ]
    },
    {
      ""Area"": ""Fee Calculation and Decay Mechanism"",
      ""Tasks"": [
        ""Analyze the `_getFeePoint` function to confirm that the fee calculation is accurate for all three segments of the curve and that the `_min` function correctly caps the fee at 1e18."",
        ""Verify that the `calculateDecayedFee` function correctly calculates the decayed fee and that the decay mechanism functions as intended. Check edge cases when `lastFeeTime` is close to `block.timestamp` and when `decayTime` is zero."",
        ""Investigate potential rounding errors in the fee calculations, particularly in the `_getFeePoint` function's multiplication and division operations. Determine if these errors could lead to significant discrepancies in the calculated fees."",
        ""Examine the interaction between `getFee` and `getFeeAndUpdate`.  Since `getFee` does not update `lastFeeTime` or `lastFeePercent`, an attacker might call `getFee` repeatedly to obtain a lower fee without triggering an update.""
      ]
    },
    {
      ""Area"": ""Collateral Cap"",
      ""Tasks"": [
        ""Confirm that the `dollarCap` is enforced correctly in both `getFee` and `getFeeAndUpdate` functions."",
        ""Investigate potential vulnerabilities related to integer overflows or underflows when calculating `_totalCollateralVCBalance.add(_collateralVCInput)`. Although SafeMath is used, ensure the result does not exceed the maximum uint256 value, potentially circumventing the cap check."",
        ""Consider the case where `dollarCap` is set to zero. Verify that this disables the collateral cap check, as implied by the conditional statement.""
      ]
    },
    {
      ""Area"": ""Front-Running and Transaction Ordering"",
      ""Tasks"": [
        ""Analyze the `getFeeAndUpdate` function for potential front-running vulnerabilities. A malicious actor could observe a transaction calling `getFeeAndUpdate` and submit a transaction with a higher gas price to execute their transaction first, potentially affecting the fee calculation and the updated `lastFeeTime` and `lastFeePercent` values. Evaluate potential mitigation strategies, such as commit-reveal schemes or using a short time lock."",
        ""Consider scenarios where multiple transactions are submitted simultaneously. Analyze how the order of these transactions affects the fee calculations and the updated state variables.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review the code for potential gas optimization opportunities. For example, caching state variables outside loops (though currently the code is relatively free of loops), using cheaper arithmetic operations where possible, and minimizing storage writes."",
        ""Specifically, analyze if `cachedDollarCap` and `cachedDecayTime` are actually beneficial from a gas perspective, considering the cost of reading the state variable vs. storing it locally.  Test both scenarios thoroughly."",
        ""Consider if the `_max` and `_min` functions could be inlined to save gas, given their simplicity.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Verify that the imported contracts (`IPriceCurve`, `SafeMath`, and `Ownable`) are from trusted sources and that their implementations are secure."",
        ""Analyze the interaction with the `whitelistAddress`. Ensure that the contract at this address behaves as expected and does not introduce any vulnerabilities.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `ThreePieceWiseLinearPriceCurve` implements a price curve with three linear segments. It calculates a fee based on the collateralization ratio of a virtual currency (VC). The fee is determined by the segment of the price curve the collateralization ratio falls into. The contract incorporates a decay mechanism for the fee, reducing it over time. Access control is managed using the `Ownable` contract and a whitelist address. The contract uses SafeMath to prevent arithmetic overflows/underflows."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""ThreePieceWiseLinearPriceCurve"",
    ""Purpose"": ""Implements a three-piecewise linear price curve to calculate fees based on collateralization ratio."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable""],
      ""Imports"": [""../Interfaces/IPriceCurve.sol"", ""../Dependencies/SafeMath.sol"", ""../Dependencies/Ownable.sol""]
    },
    ""StateVariables"": [
      {
        ""Name"": ""name"",
        ""Type"": ""string"",
        ""Purpose"": ""Name of the price curve.""
      },
      {
        ""Name"": ""m1"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Slope of the first linear segment.""
      },
      {
        ""Name"": ""b1"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Y-intercept of the first linear segment.""
      },
      {
        ""Name"": ""cutoff1"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Upper bound for the first linear segment (percent backed).""
      },
      {
        ""Name"": ""m2"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Slope of the second linear segment.""
      },
      {
        ""Name"": ""b2"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Y-intercept of the second linear segment.""
      },
      {
        ""Name"": ""b2Negative"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether b2 should be subtracted or added.""
      },
      {
        ""Name"": ""cutoff2"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Upper bound for the second linear segment (percent backed).""
      },
      {
        ""Name"": ""m3"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Slope of the third linear segment.""
      },
      {
        ""Name"": ""b3"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Y-intercept of the third linear segment.""
      },
      {
        ""Name"": ""b3Negative"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether b3 should be subtracted or added.""
      },
      {
        ""Name"": ""decayTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Time period over which the last fee decays to zero.""
      },
      {
        ""Name"": ""lastFeeTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last fee update.""
      },
      {
        ""Name"": ""lastFeePercent"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The last calculated fee percentage.""
      },
      {
        ""Name"": ""dollarCap"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum total collateral value allowed.""
      },
      {
        ""Name"": ""whitelistAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address authorized to update the last fee information.""
      },
      {
        ""Name"": ""addressesSet"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to indicate whether the whitelist address has been set.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""adjustParams"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adjusts the parameters of the price curve."",
        ""Parameters"": [
          ""_name (string memory)"",
          ""_m1 (uint256)"",
          ""_b1 (uint256)"",
          ""_m2 (uint256)"",
          ""_cutoff1 (uint256)"",
          ""_m3 (uint256)"",
          ""_cutoff2 (uint256)"",
          ""_dollarCap (uint)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setAddresses"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the whitelist address."",
        ""Parameters"": [""_whitelistAddress (address)""],
        ""Returns"": []
      },
      {
        ""Name"": ""setDecayTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the decay time."",
        ""Parameters"": [""_decayTime (uint)""],
        ""Returns"": []
      },
      {
        ""Name"": ""getFeeCapAndTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the last fee percentage and time."",
        ""Parameters"": [],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""setFeeCapAndTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the last fee percentage and time, restricted to the whitelist address."",
        ""Parameters"": [""_lastFeePercent (uint256)"", ""_lastFeeTime (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""getFee"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the fee based on the collateralization ratio and decay."",
        ""Parameters"": [
          ""_collateralVCInput (uint256)"",
          ""_totalCollateralVCBalance (uint256)"",
          ""_totalVCBalancePre (uint256)"",
          ""_totalVCBalancePost (uint256)""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getFeeAndUpdate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the fee, updates the last fee time and percentage, and restricts access to the whitelist address."",
        ""Parameters"": [
          ""_collateralVCInput (uint256)"",
          ""_totalCollateralVCBalance (uint256)"",
          ""_totalVCBalancePre (uint256)"",
          ""_totalVCBalancePost (uint256)""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_getFeePoint"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the fee for a specific point on the price curve."",
        ""Parameters"": [""_collateralVCBalance (uint256)"", ""_totalVCBalance (uint256)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""calculateDecayedFee"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the decayed fee based on the time elapsed since the last fee update."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_min"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the minimum of two uint256 values."",
        ""Parameters"": [""a (uint256)"", ""b (uint256)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_max"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the maximum of two uint256 values."",
        ""Parameters"": [""a (uint256)"", ""b (uint256)""],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IPriceCurve (interface)"",
    ""Ownable (contract)"",
    ""SafeMath (library)""
  ],
  ""SpecialMechanisms"": [
    ""Three-piecewise linear price curve implementation."",
    ""Fee decay mechanism."",
    ""Whitelist-based access control for fee updates.""
  ],
  ""Questions"": [
    ""In `adjustParams`, the calculations for `b2` and `b3` depend on the order of `m1Val` and `m2Val`, and `m2Val` and `m3Val`, which determine whether `b2Negative` and `b3Negative` are set to true. Are there specific scenarios or intended behaviors depending on whether b2 and b3 are positive or negative?"",
    ""Why is `calculateDecayedFee` declared as `public` instead of `internal` or `private` if it's not part of the `IPriceCurve` interface?"",
    ""Are there any considerations for potential front-running vulnerabilities in `getFeeAndUpdate` since the `lastFeeTime` and `lastFeePercent` are updated based on the current block timestamp?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Division by Zero in `_getFeePoint`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_getFeePoint` function divides by `_totalVCBalance` which could be zero. The code includes a check: `if (_totalVCBalance == 0) { return 0; }`, which prevents the division by zero. However, a malicious user may intentionally cause this condition which leads to 0 fee and thus DoS the contract by making it less profitable or unusable. A race condition could occur if another transaction reduces `_totalVCBalance` to zero between the check and the division. While this is very unlikely due to transaction atomicity, a reentrancy attack could lead to such a state if the state change of `_totalVCBalance` is externalized. Additionally, if `decayTime` is set to 0, the division `lastFeePercent.mul(decay).div(cachedDecayTime)` in `calculateDecayedFee` will result in a division by zero error, causing the transaction to revert."",
      ""Impact"": ""Denial of Service (DoS) by forcing fee to zero, or contract revert due to division by zero. While the code avoids an actual error, it can be exploited to make the price curve ineffective."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:159, ThreePieceWiseLinearPriceCurve.sol:123-125, _getFeePoint function, calculateDecayedFee function""
    },
    {
      ""Issue"": ""Unbounded loop in `adjustParams`"",
      ""Severity"": ""High"",
      ""Description"": ""The contract computes `b2` and `b3` based on `m1`, `m2`, `m3` and the cutoff values. If m2Val > m1Val or m3Val > m2Val then b2Negative or b3Negative are set to true. Later on, in `_getFeePoint`, if `b2Negative` or `b3Negative` is true, then the contract uses subtraction, which could underflow to unexpected values. There should be checks to make sure that no subtraction underflows will happen."",
      ""Impact"": ""If m2Val > m1Val or m3Val > m2Val, the contract computes negative values which, due to the nature of solidity, underflows to very large numbers, thus leading to incorrect fee calculations."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:33, ThreePieceWiseLinearPriceCurve.sol:43, ThreePieceWiseLinearPriceCurve.sol:138, ThreePieceWiseLinearPriceCurve.sol:143""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""Multiple locations in the contract, specifically `calculateDecayedFee` and `_getFeePoint`, are vulnerable to integer overflow/underflow. In `calculateDecayedFee`, `uint256 decay = block.timestamp.sub(lastFeeTime);` could underflow, and `lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime))` may also underflow. In `_getFeePoint`, if `_totalVCBalance` is small, the result of `_collateralVCBalance.mul(1e18).div(_totalVCBalance)` could be very large, and calculations involving slopes (`m1`, `m2`, `m3`) and `percentBacked` could overflow before the division by 1e18. In adjustParams, the subtraction `m2Val.sub(m1Val)` or `m3Val.sub(m2Val)` could also underflow if m1Val or m2Val is 0."",
      ""Impact"": ""Incorrect fee calculations, potentially leading to losses for users or the protocol.  The underflow in `calculateDecayedFee` could result in a fee of 0, while overflows can result in incorrect fee values."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:208-214, ThreePieceWiseLinearPriceCurve.sol:152-159, ThreePieceWiseLinearPriceCurve.sol:157, ThreePieceWiseLinearPriceCurve.sol:160, _getFeePoint function,`_getFeePoint`, `calculateDecayedFee`, ThreePieceWiseLinearPriceCurve.sol:30-45""
    },
    {
      ""Issue"": ""Lack of Input Validation in `adjustParams` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `adjustParams` function lacks sufficient input validation for the slope parameters `_m1`, `_m2`, and `_m3`, as well as base values `_b1`, cutoffs (`_cutoff1`, `_cutoff2`), and `_dollarCap`. There are no checks to ensure that these parameters are within reasonable bounds or that they don't result in fee percentages exceeding 100% (1e18) for any valid input. Additionally, large values for the slope parameters, combined with large `percentBacked` values in `_getFeePoint`, could lead to integer overflows. While `cutoff1 <= cutoff2` is enforced, the magnitudes of `m1`, `m2`, and `m3` aren't constrained to ensure reasonable curve behavior."",
      ""Impact"": ""Incorrect fee calculation due to integer overflow, unexpected behavior, or undesirable fee calculation behavior. Potential for exploiting the contract with adversarial parameter adjustments by the owner. This can affect the fairness and predictability of the system. Malicious or erroneous input could result in incorrect fee calculations and potentially break the contract\'s intended functionality or introduce unexpected behavior."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:43-70, ThreePieceWiseLinearPriceCurve.sol:161-179, ThreePieceWiseLinearPriceCurve.sol:26, ThreePieceWiseLinearPriceCurve.sol:25-49, adjustParams function""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `setFeeCapAndTime`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setFeeCapAndTime` function allows the `whitelistAddress` to set `lastFeePercent` and `lastFeeTime`. If the `whitelistAddress` is a contract, and that contract's `receive` or `fallback` function calls `getFee` or `getFeeAndUpdate`, it could potentially lead to unexpected behavior since `lastFeePercent` and `lastFeeTime` would be updated mid-execution. While not a direct reentrancy in the traditional sense, the change in state could influence the subsequent fee calculation."",
      ""Impact"": ""Unexpected fee calculations, potentially allowing malicious contracts to manipulate the fee calculation logic. Potential for unexpected state changes and exploits."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:73-77, setFeeCapAndTime function""
    },
    {
      ""Issue"": ""Vulnerability to Front-Running in `setFeeCapAndTime`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setFeeCapAndTime` function allows a whitelisted address to set the `lastFeePercent` and `lastFeeTime`.  A malicious actor can monitor the mempool for transactions calling this function. By front-running this transaction with their own, they can potentially manipulate the `lastFeePercent` and `lastFeeTime` to their advantage or a malicious or compromised whitelist address could set these values to extremes."",
      ""Impact"": ""Potential for malicious actors to influence fee calculations by manipulating the `lastFeePercent` and `lastFeeTime` variables. Risk of economic exploitation by the whitelist address. A malicious actor could manipulate the fee calculation by front-running the `setFeeCapAndTime` transaction."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:73-77, ThreePieceWiseLinearPriceCurve.sol:75-79, `setFeeCapAndTime`""
    },
    {
      ""Issue"": ""Missing Overflow Checks in `_getFeePoint` slope calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_getFeePoint` function, the fee is calculated using `m1.mul(percentBacked).div(1e18).add(b1)`, `m2.mul(percentBacked).div(1e18).add(b2)`, and `m3.mul(percentBacked).div(1e18).add(b3)`. While the results are checked against `1e18` with `_min`, there's no check for overflow after the multiplication and before the division by 1e18. If `m1 * percentBacked` (or similar) is larger than the maximum uint256 value before the division by 1e18, it will wrap around, leading to an incorrect and possibly much smaller fee."",
      ""Impact"": ""Incorrect fee calculation, which could result in lower-than-expected fees for the protocol. Potential for economic exploitation."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:116, 119, 124""
    },
    {
      ""Issue"": ""Race Condition in `getFee` and `getFeeAndUpdate`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `getFee` calculates the fee, while `getFeeAndUpdate` calculates the fee and then updates `lastFeeTime` and `lastFeePercent`.  There's a potential race condition. If two transactions call `getFeeAndUpdate` concurrently, the second transaction to be mined could use stale values of `lastFeeTime` and `lastFeePercent` from before the first transaction was mined, potentially leading to incorrect fee updates. The `getFee` function could also read stale values before they have been updated by `getFeeAndUpdate`."",
      ""Impact"": ""Inconsistent fee calculations and updates due to concurrent transactions, leading to fairness issues and potential economic exploitation."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:86, ThreePieceWiseLinearPriceCurve.sol:103""
    },
    {
      ""Issue"": ""Missing Check for Zero Address in `setAddresses`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setAddresses` function sets the `whitelistAddress`. There isn't a check to ensure that the provided address is not the zero address (0x0). Setting the whitelist address to the zero address would effectively disable the restrictions imposed by `require(msg.sender == whitelistAddress, ...)` in `setFeeCapAndTime` and `getFeeAndUpdate`, allowing anyone to call those functions."",
      ""Impact"": ""Circumventing access control, potential for unauthorized modification of fee parameters. If the owner accidentally sets the whitelist address to address(0), it will effectively brick the contract."",
      ""Location"": ""setAddresses function, ThreePieceWiseLinearPriceCurve.sol:52""
    },
    {
      ""Issue"": ""Potential Replay Attack on `setFeeCapAndTime` and `getFeeAndUpdate`"",
      ""Severity"": ""Low"",
      ""Description"": ""Both `setFeeCapAndTime` and `getFeeAndUpdate` functions rely on a whitelisted address. There is a potential replay attack vector if an attacker can intercept and replay the transaction from a whitelisted address in a different environment or chain, assuming the whitelist address is the same."",
      ""Impact"": ""An attacker could manipulate fee calculations in a different environment or chain."",
      ""Location"": ""`setFeeCapAndTime`, `getFeeAndUpdate`""
    },
    {
      ""Issue"": ""Inconsistent use of SafeMath library"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses SafeMath for some arithmetic operations, but not all. Specifically, within the `calculateDecayedFee` function, `sub` and `mul` operations are performed directly without using SafeMath. While the contract attempts to mitigate this with checks, using SafeMath consistently would improve robustness. While `SafeMath` is generally used throughout the contract, the return values from internal `_min` and `_max` functions used in `_getFeePoint` is not using `SafeMath`."",
      ""Impact"": ""Potential integer overflow/underflow issues in `calculateDecayedFee`. Potential inconsistency and minor risk of unforeseen issues."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:208-214, _getFeePoint function calls""
    },
    {
      ""Issue"": ""Possible Division by Zero in `_getFeePoint` due to Integer Division Order of Operations"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `_getFeePoint` starts with `uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);`. While there's a check for `_totalVCBalance == 0` that returns 0, a malicious caller can front-run this.  The main issue is that the calculation `m1.mul(percentBacked).div(1e18)`, `m2.mul(percentBacked).div(1e18)` and `m3.mul(percentBacked).div(1e18)` are sensitive to integer division. Since the multiplication of `percentBacked` by `m1`, `m2`, or `m3` happens before the division by `1e18`, it's possible that the product is so small that the division results in 0, leading to an inaccurate fee."",
      ""Impact"": ""The calculated fee might be inaccurate due to integer division truncation, especially when `percentBacked`, `m1`, `m2`, or `m3` are relatively small compared to `1e18`."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:133, ThreePieceWiseLinearPriceCurve.sol:136, ThreePieceWiseLinearPriceCurve.sol:139, ThreePieceWiseLinearPriceCurve.sol:144""
    },
    {
      ""Issue"": ""Inconsistent Use of `override` keyword"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `setAddresses` and `setDecayTime` are marked with the `override` keyword which implies the functions are overriding functions from the interface. However, functions `getFee` and `getFeeAndUpdate` use the override keyword after external instead of before."",
      ""Impact"": ""Syntactically incorrect usage of override may lead to compiler warnings/errors in future solidity versions."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:58, 63, 81, 95""
    },
    {
      ""Issue"": ""Require Statements for Dollar Cap"",
      ""Severity"": ""Low"",
      ""Description"": ""The require statements `require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, \\""Collateral input exceeds cap\\"");` in functions `getFee` and `getFeeAndUpdate` checks if the addition of `_totalCollateralVCBalance` and `_collateralVCInput` exceeds the `cachedDollarCap`. However, the addition itself could overflow if the sum of `_totalCollateralVCBalance` and `_collateralVCInput` exceeds the maximum value of uint256, causing the transaction to revert unexpectedly. Also the dollarCap state variable is read and saved into a local variable `cachedDollarCap` which is unnecessary."",
      ""Impact"": ""Unexpected reverts when adding `_totalCollateralVCBalance` and `_collateralVCInput` overflows `uint256`. This is DoS and not the intended behavior. Slightly higher gas cost."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:85-87, 98-100, getFee and getFeeAndUpdate functions""
    },
    {
      ""Issue"": ""Unnecessary require statements in `getFee` and `getFeeAndUpdate`"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `getFee` and `getFeeAndUpdate` contain require statements `require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, \\""Collateral input exceeds cap\\"")`. These checks ensure that the total collateral doesn't exceed the `dollarCap`. However, there are no additional checks when the `dollarCap` is zero, so the check effectively becomes meaningless when `cachedDollarCap` is zero."",
      ""Impact"": ""Slightly higher gas costs due to unnecessary require statements."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:86 and 98""
    },
    {
      ""Issue"": ""Lack of slippage Control in `getFeeAndUpdate`"",
      ""Severity"": ""Info"",
      ""Description"": ""The function `getFeeAndUpdate` doesn't have a slippage control mechanism. While the function calculates and updates the `lastFeeTime` and `lastFeePercent`, it does not protect against scenarios where the expected fee drifts from the final, applied fee due to external factors such as price changes or manipulations."",
      ""Impact"": ""Without a slippage mechanism, the caller of `getFeeAndUpdate` risks the fee diverging significantly from expectations. This can lead to unforeseen financial outcomes for users or the protocol."",
      ""Location"": ""`getFeeAndUpdate`""
    },
    {
      ""Issue"": ""Missing Access Control on getFee Function"",
      ""Severity"": ""Info"",
      ""Description"": ""The `getFee` function lacks any access control. Anyone can call this function to determine the current fee without incurring a cost or changing contract state. This might not be a security issue, but it should be explicitly documented whether this is the intended behavior."",
      ""Impact"": ""Lack of clarity on intended usage; potentially unexpected access."",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:118""
    },
    {
      ""Issue"": ""Missing Access Control in `setFeeCapAndTime`"",
      ""Severity"": ""Info"",
      ""Description"": ""The `setFeeCapAndTime` function can only be called by `whitelistAddress`. This introduces a dependency on the correct configuration and security of the contract at `whitelistAddress`."",
      ""Impact"": ""The security and functionality of the price curve depend on the security and functionality of the contract at `whitelistAddress`."",
      ""Location"": ""setFeeCapAndTime function""
    },
    {
      ""Issue"": ""Possible precision loss in `adjustParams`"",
      ""Severity"": ""Info"",
      ""Description"": ""In the `adjustParams` function, calculations like `_m1.mul(_cutoff1).div(1e18)` and `_m2.mul(_cutoff1).div(1e18)` are susceptible to precision loss due to the order of operations. Multiplying before dividing can lead to truncation errors, which can affect the calculated fee and overall precision of the curve. Although `SafeMath` is used, this does not mitigate precision loss."",
      ""Impact"": ""The calculated fee and overall curve precision could be less accurate due to the truncation errors during calculations, possibly leading to unpredictable outcomes."",
      ""Location"": ""`adjustParams`""
    },
    {
      ""Issue"": ""Unnecessary External Visibility in `getFee` and `getFeeAndUpdate`"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `getFee` and `getFeeAndUpdate` are marked as `external`. Since they are also overriding functions from `IPriceCurve.sol`, it is better to mark these functions as `override public`, since external functions have higher gas cost."",
      ""Impact"": ""Slightly higher gas costs"",
      ""Location"": ""getFee and getFeeAndUpdate functions""
    },
    {
      ""Issue"": ""addressesSet can only be set to true, never false"",
      ""Severity"": ""Low"",
      ""Description"": ""The boolean `addressesSet` is set to `true` after calling `setAddresses`, but there is no function to set it back to `false`. This might be problematic if one would want to change the `whitelistAddress` after initial setting of addresses."",
      ""Impact"": ""Inability to change whitelist address after initial setup"",
      ""Location"": ""ThreePieceWiseLinearPriceCurve.sol:75-78""
    },
        {
      ""Issue"": ""Race Condition in Addresses Setting"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `setAddresses` is protected by `addressesSet` boolean to prevent multiple invocations. This can be attacked if two transactions are sent almost simultaneously to set the address. The first transaction will set the address and update the flag to `true`. While the first transaction is not mined yet, the second transaction can also pass the `require(!addressesSet, \""addresses already set\"")` check. This will lead to the `whitelistAddress` being set by the second transaction, and the address set by the first transaction will be lost forever."",
      ""Impact"": ""The `whitelistAddress` can be overwritten by a malicious actor if the owner tries to set the address."",
      ""Location"": ""setAddresses function""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 23
}",184.5074818134308,3537.0,29.0,"### **Comparison of Issue Report and Response List**

---

#### **[M-07] Cannot use most piecewise linear functions with current implementation**

**Report Description**:  
The `ThreePieceWiseLinearPriceCurve.adjustParams` function uses three functions `f1`, `f2`, `f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0)`, `b3 = f_3(0)`) for each of these but uses `unsigned integers`, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.

**Match in Response List**:  
Matches with the issue titled **""Unbounded loop in `adjustParams`""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `adjustParams` and mentions the potential for underflow due to subtraction when `b2Negative` or `b3Negative` is true. However, it does not explicitly address the limitation of using `unsigned integers` for `b2` and `b3`, which prevents the use of negative values and restricts the class of functions that can be implemented. This is a critical detail missing from the response.

---

#### **[M-08] Wrong comment in `getFee`**

**Report Description**:  
The `ThreePieceWiseLinearPriceCurve.getFee` comment states that the total + the input must be less than the cap:  
*If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.*  
The code only checks if the input is less than the cap:  
```solidity
if (dollarCap != 0) {
    require(_collateralVCInput <= dollarCap, ""Collateral input exceeds cap"");
}
```

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The discrepancy between the comment and the actual code is a clear oversight that could lead to confusion or misinterpretation of the contract's behavior.

---

#### **[M-09] Fee not decayed if past `decayTime`**

**Report Description**:  
The `ThreePieceWiseLinearPriceCurve.calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0 && decay < decayTime` case, but for the `decay > decayTime` case, it does not decay at all but should set it to 0 instead.  
```solidity
if (decay > 0 && decay < decayTime) {
    fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime));
} else {
    fee = lastFeePercent;
}
```

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow/Underflow in Fee Calculation""**.

**Validation**:  
**Incorrect**. The response focuses on potential integer overflow/underflow issues in `calculateDecayedFee` but does not address the core issue of the fee not being decayed to 0 when `decay > decayTime`. This is a significant oversight in the response.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-07] Cannot use most piecewise linear functions with current implementation**

**Missed Issues from Issue Report**:  
- **[M-08] Wrong comment in `getFee`**  
- **[M-09] Fee not decayed if past `decayTime`**

---

### **Conclusion**  
The response list partially addresses one issue ([M-07]) but misses critical details. It completely fails to address two other issues ([M-08] and [M-09]), which are significant vulnerabilities or inconsistencies in the contract. The response list could be improved by ensuring that all issues in the report are covered, especially those related to logical errors and discrepancies between comments and code.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. 

Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and thus the average precision is also 0."
