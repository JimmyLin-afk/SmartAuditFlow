nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
Vault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";

/**
 * A vault where other accounts can deposit an underlying token
 * currency and set distribution params for their principal and yield
 *
 * @dev Yield generation strategies not yet implemented
 */

contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    //
    // Constants
    //

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    //
    // State
    //

    /// Underlying ERC20 token accepted by the vault
    /// See {IVault}
    IERC20 public override(IVault) underlying;

    /// See {IVault}
    IStrategy public strategy;

    /// See {IVault}
    uint256 public investPerc;

    /// See {IVault}
    uint256 public immutable override(IVault) minLockPeriod;

    /// See {IVaultSponsoring}
    uint256 public override(IVaultSponsoring) totalSponsored;

    /// Depositors, represented as an NFT per deposit
    Depositors public depositors;

    /// Yield allocation
    Claimers public claimers;

    /// Unique IDs to correlate donations that belong to the same foundation
    Counters.Counter private _depositGroupIds;

    /**
     * @param _underlying Underlying ERC20 token to use.
     */
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    //
    // IVault
    //

    /// See {IVault}
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    /// See {IVault}
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    /// See {IVault}
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    /// See {IVault}
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    /// See {IVault}
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    /// See {IVault}
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    /// See {IVault}
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    /// See {IVault}
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    /// See {IVault}
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    /// See {IVault}
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    /// See {IVault}
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    //
    // IVaultSponsoring

    /// See {IVaultSponsoring}
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    /// See {IVaultSponsoring}
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    /// See {IVaultSponsoring}
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    //
    // Public API
    //

    /**
     * Computes the total amount of principal + yield currently controlled by the
     * vault and the strategy. The principal + yield is the total amount
     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.
     *
     * @return Total amount of principal and yield help by the vault (not including sponsored amount).
     */
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        // TODO no invested amount yet
        return totalUnderlying() - totalSponsored;
    }

    //
    // ERC165
    //

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    //
    // Internal API
    //

    /**
     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    /**
     * Withdraws the sponsored amount for the deposits with the ids provided
     * in @param _ids and sends it to @param _to.
     *
     * @notice the NFTs of the deposits will be burned.
     *
     * @param _to Address that will receive the funds.
     * @param _ids Array with the ids of the deposits.
     * @param _force Boolean to specify if the action should be perfomed when there's loss.
     */
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    /**
     * Creates a deposit with the given amount of underlying and claim
     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.
     * @notice This function assumes underlying will be transfered elsewhere in
     * the transaction.
     *
     * @notice Underlying must be transfered *after* this function, in order to
     * correctly calculate shares.
     *
     * @notice claims must add up to 100%.
     *
     * @param _amount Amount of underlying to consider @param claims claim
     * @param _lockedUntil When the depositor can unsponsor the amount.
     * @param claims Claim params
     * params.
     */
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    /**
     * Burns a deposit NFT and reduces the principal and shares of the claimer.
     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.
     *
     * @notice This function doesn't transfer any funds, it only updates the state.
     *
     * @notice Only the owner of the deposit may call this function.
     *
     * @param _tokenId The deposit ID to withdraw from.
     * @param _totalShares The total shares to consider for the withdraw.
     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.
     *
     * @return the amount to withdraw.
     */
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    /**
     * Computes amount of shares that will be received for a given deposit amount
     *
     * @param _amount Amount of deposit to consider.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount of shares the deposit will receive.
     */
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    /**
     * Computes the amount of underlying from a given number of shares
     *
     * @param _shares Number of shares.
     * @param _totalShares Amount of existing shares to consider.
     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.
     * @return Amount that corresponds to the number of shares.
     */
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            // TODO exclude sponsored assets
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    /**
     * Checks if the given address is a contract implementing IIntegration
     *
     * @param addr Address to check
     * @return true if contract is an IIntegraiont
     */
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",4418,652,"[H-01] forceUnsponsor() may open a window for attackers to manipulate the _totalShares and freeze users' funds at a certain deposit amount

function `_unsponsor()`, variables `totalSponsored`

https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/Vault.sol#L390-L401
if (_force && sponsorAmount > totalUnderlying()) {
    sponsorToTransfer = totalUnderlying();
} else if (!_force) {
    require(
        sponsorToTransfer <= totalUnderlying(),
        ""Vault: not enough funds to unsponsor""
    );
}

totalSponsored -= sponsorAmount;

underlying.safeTransfer(_to, sponsorToTransfer);

When sponsorAmount > totalUnderlying(), the contract will transfer totalUnderlying() to sponsorToTransfer, even if there are other depositors and totalShares > 0.
After that, and before others despoiting into the Vault, the Attacker can send 1 wei underlying token, then cal deposit() with 0.1 * 1e18 , since newShares = (_amount * _totalShares) / _totalUnderlyingMinusSponsored and _totalUnderlyingMinusSponsored is 1, with a tiny amount of underlying token, newShares will become extremly large.
As we stated in issue #166, when the value of totalShares is manipulated precisely, the attacker can plant a bomb, and the contract will not work when the deposit/withdraw amount reaches a certain value, freezing the user's funds.
 [H-02] Withdrawers can get more value returned than expected with reentrant call
Reentrancy call 
Submitted by camden, also found by cmichel and harleythedog
The impact of this is that users can get significantly more UST withdrawn than they would be alotted if they had done non-reentrant withdraw calls.
  [H-04] deposit() function is open to reentrancy attacks
Reentrancy attacks 
In Vault.sol the deposit() function is left wide open to reentrancy attacks. The function eventually calls \_createDeposit() => \_createClaim() which calls depositors.mint() which will then mint an NFT. When the NFT is minted the sender will receive a callback which can then be used to call the deposit() function again before execution is finished. An attacker can do this minting multiple NFT's for themselves. claimers.mint() is also called in the same function which can also be used to call back into the deposit function before execution is complete. Since there are several state updates before and after NFT's are minted this can be used to further manipulate the protocol like with newShares which is called before minting. This is not counting what an attacker can do with cross function reentrancy entering into several other protocol functions (like withdraw) before code execution is complete further manipulating the system.
  [H-05] sponsor() function in open to reentrancy attacks

Reentrancy guard, sponsor() function
In Vault.sol the sponsor() function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender. Since there are state updates after the call to depositors.mint() function this is especially dangerous. An attacker can make it so the totalSponsored amount is only updated once after calling mint() several times since the update takes place after the callback. The same will be true for the Sponsored event that is emitted.
  [M-04] unsponsor, claimYield and withdraw might fail unexpectedly
In function `  function _unsponsor` 
Submitted by danb, also found by ACai, cmichel, harleythedog, leastwood, palina, pedroais, and WatchPug
totalUnderlying() includes the invested assets, they are not in the contract balance.
when a user calls withdraw, claimYield or unsponsor, the system might not have enough assets in the balance and the transfer would fail.
especially, force unsponsor will always fail, because it tries to transfer the entire totalUnderlying(), which the system doesn't have:
https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L391
  [M-06] totalUnderlyingMinusSponsored() may revert on underflow and malfunction the contract
  [M-07] Vault can't receive deposits if underlying token charges fees on transfer

`function _transferAndCheckUnderlying` 
Some ERC20 tokens charge a fee for every transfer. If the underlying token of a vault is such a token any deposit to the protocol will fail.
Some tokens have the possibility of adding fees later on, e.g. USDT. So those have to be covered too.
Generally, the user would also receive fewer tokens on withdrawing in such a scenario but that's not the protocol's fault.
I rated the issue as medium since part of the protocol become unavailable in such a situation.
  [M-15] Check _to is not empty

functions claimYield, \_withdraw, and \_unsponsor should validate that \_to is not an empty 0x0 address to prevent accidental burns.

",8,,"pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Context} from ""@openzeppelin/contracts/utils/Context.sol"";
import {Counters} from ""@openzeppelin/contracts/utils/Counters.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";
import {ERC165} from ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import {IVault} from ""./vault/IVault.sol"";
import {IVaultSponsoring} from ""./vault/IVaultSponsoring.sol"";
import {PercentMath} from ""./lib/PercentMath.sol"";
import {Depositors} from ""./vault/Depositors.sol"";
import {Claimers} from ""./vault/Claimers.sol"";
import {IIntegration} from ""./integrations/IIntegration.sol"";
import {IStrategy} from ""./strategy/IStrategy.sol"";
import {ERC165Query} from ""./lib/ERC165Query.sol"";

import ""hardhat/console.sol"";



contract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;
    using PercentMath for uint256;
    using Address for address;
    using ERC165Query for address;

    
    
    

    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; 
    uint256 public constant SHARES_MULTIPLIER = 10**18;

    
    
    

    
    
    IERC20 public override(IVault) underlying;

    
    IStrategy public strategy;

    
    uint256 public investPerc;

    
    uint256 public immutable override(IVault) minLockPeriod;

    
    uint256 public override(IVaultSponsoring) totalSponsored;

    
    Depositors public depositors;

    
    Claimers public claimers;

    
    Counters.Counter private _depositGroupIds;

    
    constructor(
        IERC20 _underlying,
        uint256 _minLockPeriod,
        uint256 _investPerc,
        address _owner
    ) Trust(_owner) {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );
        require(
            address(_underlying) != address(0x0),
            ""VaultContext: underlying cannot be 0x0""
        );
        investPerc = _investPerc;
        underlying = _underlying;
        minLockPeriod = _minLockPeriod;

        depositors = new Depositors(address(this), ""depositors"", ""p"");
        claimers = new Claimers(address(this));
    }

    
    
    

    
    function setStrategy(address _strategy)
        external
        override(IVault)
        requiresTrust
    {
        require(_strategy != address(0), ""Vault: strategy 0x"");
        require(
            IStrategy(_strategy).vault() == address(this),
            ""Vault: invalid vault""
        );
        require(
            address(strategy) == address(0) || strategy.investedAssets() == 0,
            ""Vault: strategy has invested funds""
        );

        strategy = IStrategy(_strategy);
    }

    
    function totalUnderlying() public view override(IVault) returns (uint256) {
        if (address(strategy) != address(0)) {
            return
                underlying.balanceOf(address(this)) + strategy.investedAssets();
        } else {
            return underlying.balanceOf(address(this));
        }
    }

    
    function totalShares() public view override(IVault) returns (uint256) {
        return claimers.totalShares();
    }

    
    function yieldFor(address _to)
        public
        view
        override(IVault)
        returns (uint256)
    {
        uint256 tokenId = claimers.addressToTokenID(_to);
        uint256 claimerPrincipal = claimers.principalOf(tokenId);
        uint256 claimerShares = claimers.sharesOf(tokenId);
        uint256 currentClaimerPrincipal = _computeAmount(
            claimerShares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        if (currentClaimerPrincipal <= claimerPrincipal) {
            return 0;
        }

        return currentClaimerPrincipal - claimerPrincipal;
    }

    
    function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

    
    function claimYield(address _to) external override(IVault) {
        uint256 yield = yieldFor(_msgSender());

        if (yield == 0) return;

        uint256 shares = _computeShares(
            yield,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );
        uint256 sharesAmount = _computeAmount(
            shares,
            totalShares(),
            totalUnderlyingMinusSponsored()
        );

        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);

        underlying.safeTransfer(_to, sharesAmount);
    }

    
    function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

    
    function forceWithdraw(address _to, uint256[] memory _ids) external {
        _withdraw(_to, _ids, true);
    }

    
    function setInvestPerc(uint16 _investPerc) external requiresTrust {
        require(
            PercentMath.validPerc(_investPerc),
            ""Vault: invalid investPerc""
        );

        emit InvestPercentageUpdated(_investPerc);

        investPerc = _investPerc;
    }

    
    function investableAmount() public view returns (uint256) {
        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);

        uint256 alreadyInvested = strategy.investedAssets();

        if (alreadyInvested >= maxInvestableAssets) {
            return 0;
        } else {
            return maxInvestableAssets - alreadyInvested;
        }
    }

    
    function updateInvested() external requiresTrust {
        require(address(strategy) != address(0), ""Vault: strategy is not set"");

        uint256 _investable = investableAmount();

        if (_investable > 0) {
            underlying.safeTransfer(address(strategy), _investable);

            emit Invested(_investable);
        }

        strategy.doHardWork();
    }

    
    

    
    function sponsor(uint256 _amount, uint256 _lockedUntil)
        external
        override(IVaultSponsoring)
    {
        if (_lockedUntil == 0)
            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;
        else
            require(
                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,
                ""Vault: lock time is too small""
            );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            _amount,
            0,
            _lockedUntil
        );

        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);

        totalSponsored += _amount;
        _transferAndCheckUnderlying(_msgSender(), _amount);
    }

    
    function unsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, false);
    }

    
    function forceUnsponsor(address _to, uint256[] memory _ids) external {
        _unsponsor(_to, _ids, true);
    }

    
    
    

    
    function totalUnderlyingMinusSponsored() public view returns (uint256) {
        
        return totalUnderlying() - totalSponsored;
    }

    
    
    

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165)
        returns (bool)
    {
        return
            interfaceId == type(IVault).interfaceId ||
            interfaceId == type(IVaultSponsoring).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    
    
    

    
    function _withdraw(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 localTotalShares = totalShares();
        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();
        uint256 amount;

        for (uint8 i = 0; i < _ids.length; i++) {
            amount += _withdrawDeposit(
                _ids[i],
                localTotalShares,
                localTotalPrincipal,
                _to,
                _force
            );
        }

        underlying.safeTransfer(_to, amount);
    }

    
    function _unsponsor(
        address _to,
        uint256[] memory _ids,
        bool _force
    ) internal {
        uint256 sponsorAmount;

        for (uint8 i = 0; i < _ids.length; i++) {
            uint256 tokenId = _ids[i];

            require(
                depositors.ownerOf(tokenId) == _msgSender(),
                ""Vault: you are not the owner of a sponsor""
            );

            (
                uint256 depositAmount,
                uint256 claimerId,
                uint256 lockedUntil
            ) = depositors.deposits(tokenId);
            require(lockedUntil <= block.timestamp, ""Vault: amount is locked"");

            require(claimerId == 0, ""Vault: token id is not a sponsor"");

            depositors.burn(tokenId);

            emit Unsponsored(tokenId);

            sponsorAmount += depositAmount;
        }

        uint256 sponsorToTransfer = sponsorAmount;

        if (_force && sponsorAmount > totalUnderlying()) {
            sponsorToTransfer = totalUnderlying();
        } else if (!_force) {
            require(
                sponsorToTransfer <= totalUnderlying(),
                ""Vault: not enough funds to unsponsor""
            );
        }

        totalSponsored -= sponsorAmount;

        underlying.safeTransfer(_to, sponsorToTransfer);
    }

    
    function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

    function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }

    
    function _withdrawDeposit(
        uint256 _tokenId,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored,
        address _to,
        bool _force
    ) internal returns (uint256) {
        require(
            depositors.ownerOf(_tokenId) == _msgSender(),
            ""Vault: you are not the owner of a deposit""
        );

        (
            uint256 depositAmount,
            uint256 claimerId,
            uint256 lockedUntil
        ) = depositors.deposits(_tokenId);
        require(lockedUntil <= block.timestamp, ""Vault: deposit is locked"");

        require(claimerId != 0, ""Vault: token id is not a withdraw"");

        uint256 claimerShares = claimers.sharesOf(claimerId);

        uint256 depositShares = _computeShares(
            depositAmount,
            _totalShares,
            _totalUnderlyingMinusSponsored
        );

        if (_force && depositShares > claimerShares) {
            depositShares = claimerShares;
        } else if (!_force) {
            require(
                claimerShares >= depositShares,
                ""Vault: cannot withdraw more than the available amount""
            );
        }

        claimers.onWithdraw(claimerId, depositAmount, depositShares);
        depositors.burn(_tokenId);

        address claimer = claimers.ownerOf(claimerId);

        if (_isIntegration(claimer)) {
            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);

            require(ret == IIntegration(claimer).onDepositBurned.selector);
        }

        emit DepositBurned(_tokenId, depositShares, _to);

        return
            _computeAmount(
                depositShares,
                _totalShares,
                _totalUnderlyingMinusSponsored
            );
    }

    function _transferAndCheckUnderlying(address _from, uint256 _amount)
        internal
    {
        uint256 balanceBefore = totalUnderlying();
        underlying.safeTransferFrom(_from, address(this), _amount);
        uint256 balanceAfter = totalUnderlying();

        require(
            balanceAfter == balanceBefore + _amount,
            ""Vault: amount received does not match params""
        );
    }

    function _blockTimestamp() public view returns (uint64) {
        return uint64(block.timestamp);
    }

    
    function _computeShares(
        uint256 _amount,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_amount == 0) return 0;
        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;

        require(
            _totalUnderlyingMinusSponsored > 0,
            ""Vault: cannot compute shares when there's no principal""
        );

        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;
    }

    
    function _computeAmount(
        uint256 _shares,
        uint256 _totalShares,
        uint256 _totalUnderlyingMinusSponsored
    ) internal pure returns (uint256) {
        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {
            return 0;
        } else {
            
            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);
        }
    }

    
    function _isIntegration(address addr) internal view returns (bool) {
        return
            addr.doesContractImplementInterface(type(IIntegration).interfaceId);
    }
}",3364,4,4,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Trust Management"",
      ""Tasks"": [
        ""Verify that the `Trust` contract is implemented correctly and that only the owner can call functions with the `requiresTrust` modifier."",
        ""Analyze the impact of `forceWithdraw` and `forceUnsponsor` functions on user funds and identify potential abuse scenarios by the trust."",
        ""Check for any unintended consequences if the owner/trust is a contract that can be compromised."",
        ""Review events emitted during trust-controlled actions to ensure proper logging for accountability.""
      ]
    },
    {
      ""Area"": ""Integration with IIntegration Contracts"",
      ""Tasks"": [
        ""Analyze the security implications of calling external `IIntegration` contracts during deposit and withdrawal (`onDepositMinted`, `onDepositBurned`)."",
        ""Identify potential reentrancy vulnerabilities in the `_createClaim` and `_withdrawDeposit` functions due to the external calls to `IIntegration` contracts."",
        ""Verify that the return values of `onDepositMinted` and `onDepositBurned` are properly validated to prevent malicious integrations from manipulating the vault's state."",
        ""Check how the vault handles errors/exceptions thrown by `IIntegration` contracts."",
        ""Investigate potential DoS attack vectors related to malicious or unresponsive `IIntegration` contracts.""
      ]
    },
    {
      ""Area"": ""Sponsoring Mechanism Security"",
      ""Tasks"": [
        ""Examine the logic in `sponsor` and `unsponsor` functions to identify potential vulnerabilities related to locking and unlocking of funds."",
        ""Verify that the `MIN_SPONSOR_LOCK_DURATION` constant is enforced correctly and cannot be circumvented."",
        ""Check for potential integer overflow/underflow issues when calculating `totalSponsored` or when transferring funds during `unsponsor`."",
        ""Analyze the impact of `forceUnsponsor` on the vault's solvency and the potential for griefing attacks."",
        ""Assess whether sponsors are protected against front-running when setting `lockedUntil`.""
      ]
    },
    {
      ""Area"": ""Accounting and Calculation Accuracy"",
      ""Tasks"": [
        ""Verify the correctness of `_computeShares` and `_computeAmount` functions and ensure that they accurately calculate shares and amounts, especially with large numbers."",
        ""Analyze the potential for rounding errors in share/amount calculations and their impact on users' funds."",
        ""Investigate scenarios where `totalUnderlyingMinusSponsored` could be calculated incorrectly, leading to incorrect share/amount calculations."",
        ""Confirm that the `SHARES_MULTIPLIER` is appropriate and does not introduce precision issues."",
        ""Check for any potential discrepancies between the vault's internal accounting and the actual balance of the underlying token.""
      ]
    },
    {
      ""Area"": ""Strategy Integration and Investment Logic"",
      ""Tasks"": [
        ""Analyze the potential risks associated with the `setStrategy` function, including setting the strategy to a malicious contract."",
        ""Verify that the `investableAmount` function accurately calculates the amount of assets that can be invested in the strategy."",
        ""Check for race conditions between `investableAmount` and `updateInvested` functions that could lead to over-investment or under-investment."",
        ""Assess the impact of incorrect `strategy.investedAssets()` values on the vault's investment decisions."",
        ""Examine potential issues related to the strategy being bricked or unable to return invested funds.""
      ]
    },
    {
      ""Area"": ""Deposit and Withdrawal Logic"",
      ""Tasks"": [
        ""Verify that the `minLockPeriod` is enforced correctly in the `deposit` function."",
        ""Analyze the claims mechanism in the `deposit` function to ensure that claims add up to 100% and that funds are correctly distributed to claimers."",
        ""Check for potential vulnerabilities in the `_withdrawDeposit` function, such as withdrawing more than the available amount."",
        ""Investigate the impact of `forceWithdraw` on other users and the vault's solvency."",
        ""Ensure proper handling of tokens with non-standard ERC20 implementations in the `_transferAndCheckUnderlying` function.""
      ]
    },
    {
      ""Area"": ""Event Emission and Logging"",
      ""Tasks"": [
        ""Verify that all relevant state changes are properly logged using events."",
        ""Check that events include all necessary information for off-chain monitoring and analysis."",
        ""Ensure that events are properly indexed to facilitate efficient querying and filtering."",
        ""Review emitted events during crucial operations like deposits, withdrawals, sponsorships, and strategy updates to identify potential anomalies or malicious activities.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines a Vault contract that manages deposits, withdrawals, and yield claiming for a specific underlying asset. It integrates with a Strategy contract to invest deposited assets and uses depositors/claimers contracts to manage user funds. It includes sponsoring functionality, allowing users to lock funds for a specified period. The contract uses various OpenZeppelin libraries and a custom Trust contract for access control. The code appears well-structured and utilizes safe math practices through libraries like SafeERC20 and PercentMath."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""Vault"",
    ""Purpose"": ""Manages deposits, withdrawals, yield claiming, and sponsoring of an underlying asset, integrating with a strategy for investment."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IVault"",
        ""IVaultSponsoring"",
        ""Context"",
        ""ERC165"",
        ""Trust""
      ],
      ""Imports"": [
        ""IERC20 from @openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""SafeERC20 from @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""Context from @openzeppelin/contracts/utils/Context.sol"",
        ""Counters from @openzeppelin/contracts/utils/Counters.sol"",
        ""Address from @openzeppelin/contracts/utils/Address.sol"",
        ""ERC165 from @openzeppelin/contracts/utils/introspection/ERC165.sol"",
        ""Trust from @rari-capital/solmate/src/auth/Trust.sol"",
        ""IVault from ./vault/IVault.sol"",
        ""IVaultSponsoring from ./vault/IVaultSponsoring.sol"",
        ""PercentMath from ./lib/PercentMath.sol"",
        ""Depositors from ./vault/Depositors.sol"",
        ""Claimers from ./vault/Claimers.sol"",
        ""IIntegration from ./integrations/IIntegration.sol"",
        ""IStrategy from ./strategy/IStrategy.sol"",
        ""ERC165Query from ./lib/ERC165Query.sol"",
        ""hardhat/console.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""MIN_SPONSOR_LOCK_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum lock duration for sponsored funds (2 weeks).""
      },
      {
        ""Name"": ""SHARES_MULTIPLIER"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant used to scale shares to a large number.""
      },
      {
        ""Name"": ""underlying"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""The ERC20 token managed by the vault.""
      },
      {
        ""Name"": ""strategy"",
        ""Type"": ""IStrategy"",
        ""Purpose"": ""Address of the strategy contract used for investing.""
      },
      {
        ""Name"": ""investPerc"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Percentage of assets to invest in the strategy.""
      },
      {
        ""Name"": ""minLockPeriod"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum lock period for deposits.""
      },
      {
        ""Name"": ""totalSponsored"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total amount of funds currently sponsored.""
      },
      {
        ""Name"": ""depositors"",
        ""Type"": ""Depositors"",
        ""Purpose"": ""Contract managing deposit tokenIds.""
      },
       {
        ""Name"": ""claimers"",
        ""Type"": ""Claimers"",
        ""Purpose"": ""Contract managing claimer tokenIds.""
      },
      {
        ""Name"": ""_depositGroupIds"",
        ""Type"": ""Counters.Counter"",
        ""Purpose"": ""Counter to keep track of the current deposit group id.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the vault with the underlying token, minimum lock period, investment percentage, and owner."",
        ""Parameters"": [
          ""_underlying (IERC20)"",
          ""_minLockPeriod (uint256)"",
          ""_investPerc (uint256)"",
          ""_owner (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setStrategy"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the strategy contract address. Restricted to trust."",
        ""Parameters"": [""_strategy (address)""],
        ""Returns"": []
      },
      {
        ""Name"": ""totalUnderlying"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total amount of underlying assets in the vault (including those invested in the strategy)."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""totalShares"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the total number of shares."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""yieldFor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the yield for a given address."",
        ""Parameters"": [""_to (address)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to deposit underlying assets into the vault."",
        ""Parameters"": [""_params (DepositParams)""],
        ""Returns"": []
      },
      {
        ""Name"": ""claimYield"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to claim accumulated yield."",
        ""Parameters"": [""_to (address)""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw their deposited assets."",
        ""Parameters"": [""_to (address)"", ""_ids (uint256[])""],
        ""Returns"": []
      },
      {
        ""Name"": ""forceWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows trust to force withdraw of a users assets."",
        ""Parameters"": [""_to (address)"", ""_ids (uint256[])""],
        ""Returns"": []
      },
      {
        ""Name"": ""setInvestPerc"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the investment percentage. Restricted to trust."",
        ""Parameters"": [""_investPerc (uint16)""],
        ""Returns"": []
      },
      {
        ""Name"": ""investableAmount"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the amount of underlying assets that can be invested in the strategy."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""updateInvested"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Transfers investable assets to the strategy and triggers hard work."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""sponsor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to sponsor assets, locking them for a specified duration."",
        ""Parameters"": [""_amount (uint256)"", ""_lockedUntil (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""unsponsor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to unsponsor their locked assets."",
        ""Parameters"": [""_to (address)"", ""_ids (uint256[])""],
        ""Returns"": []
      },
      {
        ""Name"": ""forceUnsponsor"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows trust to force unsponsor of a users assets."",
        ""Parameters"": [""_to (address)"", ""_ids (uint256[])""],
        ""Returns"": []
      },
       {
        ""Name"": ""totalUnderlyingMinusSponsored"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Calculates the total underlying assets minus the sponsored assets."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""supportsInterface"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Checks if the contract supports a given interface."",
        ""Parameters"": [""interfaceId (bytes4)""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_withdraw"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle withdrawals."",
        ""Parameters"": [""_to (address)"", ""_ids (uint256[])"", ""_force (bool)""],
        ""Returns"": []
      },
      {
        ""Name"": ""_unsponsor"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle unsponsoring."",
        ""Parameters"": [""_to (address)"", ""_ids (uint256[])"", ""_force (bool)""],
        ""Returns"": []
      },
      {
        ""Name"": ""_createDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle deposit creation."",
        ""Parameters"": [""_amount (uint256)"", ""_lockedUntil (uint256)"", ""claims (ClaimParams[])""],
        ""Returns"": []
      },
      {
        ""Name"": ""_createClaim"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle claim creation."",
        ""Parameters"": [""_depositGroupId (uint256)"", ""_amount (uint256)"", ""_lockedUntil (uint256)"", ""_claim (ClaimParams)"", ""_localTotalShares (uint256)"", ""_localTotalPrincipal (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""_withdrawDeposit"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle deposit withdrawal."",
        ""Parameters"": [""_tokenId (uint256)"", ""_totalShares (uint256)"", ""_totalUnderlyingMinusSponsored (uint256)"", ""_to (address)"", ""_force (bool)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_transferAndCheckUnderlying"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers the underlying asset to the contract and verifies that the amount is correct."",
        ""Parameters"": [""_from (address)"", ""_amount (uint256)""],
        ""Returns"": []
      },
      {
        ""Name"": ""_computeShares"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Computes the number of shares for a given amount."",
        ""Parameters"": [""_amount (uint256)"", ""_totalShares (uint256)"", ""_totalUnderlyingMinusSponsored (uint256)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_computeAmount"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Computes the amount for a given number of shares."",
        ""Parameters"": [""_shares (uint256)"", ""_totalShares (uint256)"", ""_totalUnderlyingMinusSponsored (uint256)""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_isIntegration"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Checks if an address implements the IIntegration interface."",
        ""Parameters"": [""addr (address)""],
        ""Returns"": [""bool""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 (underlying asset)"",
    ""IStrategy (investment strategy contract)"",
    ""Depositors (manages deposits)"",
    ""Claimers (manages claims)"",
    ""IIntegration (integration contracts for deposits and withdrawals)"",
    ""SafeERC20 (for safe token transfers)""
  ],
  ""SpecialMechanisms"": [
    ""Uses a Trust contract for access control, allowing the owner to perform privileged actions."",
    ""Implements a sponsoring mechanism for locking funds."",
    ""Integrates with a strategy contract to invest underlying assets."",
    ""Uses depositors and claimers contracts to manage ownership of the underlying assets."",
    ""Uses custom libraries PercentMath and ERC165Query for calculations and interface detection, respectively.""
  ],
  ""Questions"": [
    ""What are the specific security considerations for the integration with `IIntegration` contracts, especially regarding the `onDepositMinted` and `onDepositBurned` callbacks?"",
    ""What is the purpose of deposit group ids and how do they affect the claims processing during deposits?"",
    ""Are there any known vulnerabilities or attack vectors associated with the sponsoring mechanism, particularly concerning the locking and unlocking of funds?"",
    ""Could the forceWithdraw and forceUnsponsor functions be abused by the trust to steal user funds, and what measures are in place to prevent this?"",
    ""What is the intended functionality and security considerations related to integrations with the IIntegration interface? Can malicious integrations manipulate the token balance or state of the Vault?"",
    ""Under what conditions would `strategy.investedAssets()` return an incorrect value, and how would this impact the vault's accounting and investment decisions?"",
    ""Are the events properly indexed for off-chain monitoring of the Vault activities and state changes?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `claimYield` and `_withdrawDeposit` Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `claimYield` function transfers underlying tokens to the claimer, and `_withdrawDeposit` burns the depositor token and transfers tokens to the recipient. Both involve external calls to potentially malicious contracts (`_to` in `claimYield` and `IIntegration(claimer).onDepositBurned` in `_withdrawDeposit`). These external calls can re-enter the Vault contract before state updates are complete, potentially draining funds or manipulating internal state. The transfer of underlying assets without a reentrancy guard allows malicious contracts to recursively call `claimYield` or other vulnerable functions before the original transaction completes."",
      ""Impact"": ""Loss of funds, manipulation of vault state, potential for malicious contracts to drain the vault's assets."",
      ""Location"": ""Vault.sol: `claimYield` function, Vault.sol: `_withdrawDeposit` function""
    },
    {
      ""Issue"": ""Missing Access Control in `forceWithdraw` and `forceUnsponsor` Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `forceWithdraw` and `forceUnsponsor` functions bypass normal lock time restrictions and intended user checks but lack access control modifiers. Anyone can call them, potentially leading to unauthorized withdrawals and unsponsors, circumventing intended lockup mechanisms, and abuse by malicious actors."",
      ""Impact"": ""Unauthorized withdrawals, potential abuse by malicious actors, circumventing intended lockup mechanisms, potentially anyone could call these functions if they meet the other requirements."",
      ""Location"": ""Vault.sol: `forceWithdraw` and `forceUnsponsor` functions, Vault.sol: Lines 164, 261, Vault.sol:212-214, Vault.sol:238-240, Vault.sol: 153, 166""
    },
    {
      ""Issue"": ""Unprotected Upgradeability"",
      ""Severity"": ""High"",
      ""Description"": ""The contract `Vault` lacks any upgradeability mechanism. Once deployed, the contract's code cannot be changed. If a critical bug is discovered after deployment, there is no way to fix it without redeploying a new contract and migrating all assets, which is a complex and risky process."",
      ""Impact"": ""Inability to fix bugs or upgrade the contract, potentially leading to loss of funds or functionality."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Lack of Slippage Control During Token Transfers"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `claimYield`, `_withdraw` and `updateInvested` functions transfer underlying assets to users or the strategy without any slippage control. If the underlying asset has a significant price fluctuation or pool imbalance between the time the transaction is initiated and the time it is executed, the user may receive less value than expected. This issue could also be exploited by a malicious actor to manipulate the price of the underlying asset."",
      ""Impact"": ""Users may receive less value than expected when claiming yield or withdrawing assets due to price fluctuations. Vault could lose a significant portion of investable assets due to slippage. Suboptimal yield generation or reverted transactions due to slippage."",
      ""Location"": ""Vault.sol: `claimYield` and `_withdraw` functions, Vault.sol: Lines 132-144, Vault.sol:updateInvested""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Share and Amount Calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""While SafeERC20 is used for token transfers, the `_computeShares` and `_computeAmount` functions perform arithmetic operations that could potentially lead to integer overflow or underflow if `_amount`, `_totalShares`, or `_totalUnderlyingMinusSponsored` are sufficiently large or small. Although the functions include checks to prevent division by zero, there are no checks to explicitly prevent overflows/underflows during intermediate calculations, such as `_amount * _totalShares` in `_computeShares` or in Sponsor/Unsponsor logic with large amounts."",
      ""Impact"": ""Incorrect share calculations could lead to users receiving incorrect amounts of underlying assets or shares. If `totalSponsored` overflows, users might be able to unsponsor more funds than they deposited. If it underflows, users might not be able to withdraw all their sponsorship funds."",
      ""Location"": ""Vault.sol: `_computeShares` and `_computeAmount` functions, Vault.sol: Lines 240, 277, 373""
    },
    {
      ""Issue"": ""Force Withdraw/Unsponsor Functions Bypass Lockup Restrictions but Don't Check Overall Vault Solvency and can lead to Incorrect Calculations."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `forceWithdraw` and `forceUnsponsor` functions allow bypassing lockup periods. While they have checks to ensure `depositShares <= claimerShares` (in `_withdraw`) and sponsors have sufficient funds, they don't account for the vault\'s overall solvency before transferring funds. If the strategy underperforms, or a large amount of assets are locked in illiquid positions, force withdrawing a large amount can lead to the remaining users being unable to withdraw their assets. Additionally, Incorrect Calculation of Sponsor Transfer Amount in `_unsponsor` function during force withdrawal if `sponsorAmount > totalUnderlying()` doesn't consider existing sponsored amount."",
      ""Impact"": ""Force withdraw/unsponsor can lead to vault insolvency, negatively impacting remaining users\' ability to withdraw. The vault could transfer more tokens than it actually has available, leading to a shortfall in funds for other users, denial of service, or unexpected behavior."",
      ""Location"": ""Vault.sol: `forceWithdraw`, `forceUnsponsor`, Vault.sol:_unsponsor""
    },
    {
      ""Issue"": ""Incorrect Calculation in `_transferAndCheckUnderlying`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `_transferAndCheckUnderlying` is designed to ensure that the amount of underlying token transferred into the Vault matches the expected amount. It calculates balances before and after the transfer, and checks if `balanceAfter == balanceBefore + _amount`. However, the `totalUnderlying()` function considers the `strategy.investedAssets()`. If the strategy has increased or decreased its assets due to market movement between `balanceBefore` and `balanceAfter` readings, the check can fail even with a valid transfer. This could cause deposits to fail even if funds are correctly transferred. The potential volatility of `strategy.investedAssets()` undermines the reliability of the balance check."",
      ""Impact"": ""Deposits could incorrectly fail if the `strategy` assets fluctuate in value between balance readings."",
      ""Location"": ""Vault.sol:580-588""
    },
        {
      ""Issue"": ""Potential manipulation of `investableAmount` before `updateInvested`"",
      ""Severity"": ""Medium"",
      ""Description"": ""A malicious or compromised strategy can potentially manipulate the investedAssets() before the `updateInvested` function is called. It is important to note that the `investableAmount` calculates the amount available for investment based on the difference between the maximum investable assets and the already invested assets. A faulty `investedAssets` return value on the strategy could be exploited, and more tokens could be transferred to the strategy than should be. This needs further investigation if the strategy\'s `investedAssets` function depends on an external source of truth, or complex calculations."",
      ""Impact"": ""Potentially transferring more assets than intended to the strategy, which could lead to further losses if the strategy is flawed or compromised."",
      ""Location"": ""Vault.sol: `investableAmount`, `updateInvested`""
    },
    {
      ""Issue"": ""Missing Input Validation on `investPerc` Update"",
      ""Severity"": ""Medium"",
      ""Description"": ""While the constructor checks for valid `investPerc` using `PercentMath.validPerc`, the `setInvestPerc` function only checks valid percentages, but does not check to ensure a reasonable difference from the current value, or account for large invested assets. A malicious trust could set this value to 0, and lock the strategy, or a high value, and cause massive slippage."",
      ""Impact"": ""Setting `investPerc` to an extreme value (0 or 100) could lead to DoS or unexpected behavior within the strategy."",
      ""Location"": ""Vault.sol: `setInvestPerc` function""
    },
    {
      ""Issue"": ""Unclear handling of failed integration calls in `_createClaim` and `_withdrawDeposit`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In both `_createClaim` and `_withdrawDeposit`, calls are made to external `IIntegration` contracts (`onDepositMinted` and `onDepositBurned` respectively). The code checks that the return value matches the function selector, but it doesn't handle the case where the external call reverts or runs out of gas. If the external call fails, the deposit/withdrawal is still processed, potentially leading to an inconsistent state where the integration contract and the vault have conflicting records. This could create issues with accounting and reconciliation."",
      ""Impact"": ""Potential for inconsistent state between the vault and integration contracts, leading to accounting and reconciliation issues. The transaction will revert, however the funds could be transferred and other side effects executed."",
      ""Location"": ""Vault.sol:_createClaim, Vault.sol:_withdrawDeposit""
    },
    {
      ""Issue"": ""Inconsistent use of `totalUnderlying` vs. `totalUnderlyingMinusSponsored` in calculations"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses both `totalUnderlying` and `totalUnderlyingMinusSponsored` in various calculations, like computing shares and amounts. It\'s crucial to ensure that the correct value is being used in each context. Using `totalUnderlying` when `totalUnderlyingMinusSponsored` is more appropriate, or vice-versa, could lead to inaccurate calculations and misallocation of funds."",
      ""Impact"": ""Incorrect calculation of shares and amounts, potentially leading to loss of funds or incorrect accounting."",
      ""Location"": ""Multiple locations. Requires careful audit.""
    },
    {
      ""Issue"": ""Denial of Service due to extreme gas usage in withdraw and unsponsor functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `withdraw` and `unsponsor` functions iterate through an array of `_ids` using a `for` loop and call `_withdrawDeposit` or internal logic per id. If a user provides a very large array of ids, it could potentially cause the transaction to run out of gas, preventing legitimate users from withdrawing or unsponsoring their funds. An attacker could exploit this by crafting a transaction with an extremely large array, effectively DoS\'ing the contract."",
      ""Impact"": ""Denial of service: Users unable to withdraw or unsponsor funds."",
      ""Location"": ""Vault.sol:207-218, Vault.sol:243-256""
    },
    {
      ""Issue"": ""Potential unintended behavior in forceUnsponsor and forceWithdraw"",
      ""Severity"": ""Low"",
      ""Description"": ""The `forceUnsponsor` and `forceWithdraw` functions allow withdrawal even when a user\'s deposit is locked or the total amount exceeds the contract\'s balance. While these functions can be useful for emergency situations, they can create unintended behavior if misused or if there are bugs in the logic related to determining the transferable amount. Care must be taken to ensure these functions are called only under well-defined conditions."",
      ""Impact"": ""Potential loss of funds or inconsistent state if used incorrectly."",
      ""Location"": ""Vault.sol:212-214, Vault.sol:238-240, Vault.sol:267-285, Vault.sol:345-408""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in _computeAmount and _computeShares due to extreme values"",
      ""Severity"": ""Low"",
      ""Description"": ""While SafeMath is not used directly, the library PercentMath is used. However, the multiplication and division operations in `_computeAmount` and `_computeShares` could still potentially lead to unexpected results if the intermediate values become very large, especially if `_totalUnderlyingMinusSponsored`, `_shares`, `_amount`, `_totalShares` are near the maximum value of uint256. Although the `PercentMath` library mitigates some risks with percentage calculations, there can still be problems with extreme values. A large amount of total shares multiplied by large totalUnderlying could overflow."",
      ""Impact"": ""Incorrect calculation of shares or amount, leading to discrepancies in deposits and withdrawals."",
      ""Location"": ""Vault.sol: `_computeAmount` and `_computeShares` functions, Vault.sol:602-625, Vault.sol:553-602""
    },
    {
      ""Issue"": ""Unbounded Loop in `_withdraw` and `_unsponsor` Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_withdraw` and `_unsponsor` functions iterate through the `_ids` array using a `for` loop with `uint8 i = 0; i < _ids.length; i++`. If `_ids.length` is larger than the maximum value of `uint8` (255), this loop will revert. While this limit is unlikely to be reached in typical scenarios, it\'s a potential denial-of-service vulnerability."",
      ""Impact"": ""Denial of service."",
      ""Location"": ""Vault.sol: `_withdraw` and `_unsponsor` functions, Vault.sol: Lines 341, 362""
    },
    {
      ""Issue"": ""Missing Zero Address Check for `_to` in `_withdraw` and `_unsponsor` functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_withdraw` and `_unsponsor` functions transfer underlying tokens to the `_to` address. There\'s no check to prevent `_to` from being the zero address, which would result in tokens being burned."",
      ""Impact"": ""If `_to` is set to the zero address, the tokens will be burned, causing a loss of funds for the user."",
      ""Location"": ""Vault.sol: Lines 349, 376""
    },
    {
      ""Issue"": ""Insufficient validation of `_lockedUntil` in `sponsor` function"",
      ""Severity"": ""Low"",
      ""Description"": ""While the `sponsor` function checks if `_lockedUntil` is greater than or equal to `block.timestamp + MIN_SPONSOR_LOCK_DURATION`, it does not prevent unreasonably large values for `_lockedUntil`. A large `_lockedUntil` value could effectively lock funds indefinitely, potentially impacting the vault\'s liquidity and usability. There is no maximum lock period implemented."",
      ""Impact"": ""Potential for funds to be locked for very long or indefinite periods."",
      ""Location"": ""Vault.sol: Lines 190-194""
    },
    {
      ""Issue"": ""Potential rounding errors in share calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_computeShares` function uses division, which can lead to rounding errors. These errors, although likely small, can accumulate over time, leading to minor discrepancies in share calculations and eventual misallocation of funds."",
      ""Impact"": ""Small, cumulative errors in share calculations."",
      ""Location"": ""Vault.sol: Line 553, Vault.sol: Lines 546, 565""
    },
    {
      ""Issue"": ""Potential for front-running of `setInvestPerc` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setInvestPerc` function allows the trusted address to update the investment percentage. If a user observes a pending transaction to `setInvestPerc` to a lower value, they could front-run this transaction with a deposit. Then, the next `updateInvested` call might invest a smaller amount than initially anticipated by the user, creating a slight arbitrage opportunity or unexpected behavior."",
      ""Impact"": ""Potential for front-running to exploit changes in investment percentage."",
      ""Location"": ""Vault.sol: Line 158""
    },
    {
      ""Issue"": ""Lack of check for zero amount in deposit and sponsor functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `deposit` and `sponsor` functions do not explicitly check if the `_amount` is zero. While `safeTransferFrom` might handle a zero amount transfer correctly, explicitly checking for this condition can improve code clarity and prevent potential unexpected behavior or wasted gas."",
      ""Impact"": ""Potential for wasted gas or unexpected behavior with zero amount deposits/sponsorships."",
      ""Location"": ""Vault.sol: Lines 124, 184""
    },
        {
      ""Issue"": ""Inconsistent parameter naming"",
      ""Severity"": ""Low"",
      ""Description"": ""The variable names between _computeShares and _computeAmount are not very consistent and it can be confusing to see what is going on"",
      ""Impact"": ""Readability and maintenance"",
      ""Location"": ""Vault.sol: `_computeShares` and `_computeAmount` functions""
    }
  ],
  ""IssueNumber"": 54,
  ""OutputList"": 20
}",196.2818250656128,3241.0,30.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] forceUnsponsor() may open a window for attackers to manipulate the _totalShares and freeze users' funds at a certain deposit amount**

**Report Description**:  
The `forceUnsponsor()` function in `Vault.sol` allows an attacker to manipulate `_totalShares` by exploiting the logic when `sponsorAmount > totalUnderlying()`. This can lead to freezing users' funds at a specific deposit amount due to incorrect calculations of `newShares`. The issue arises because the contract transfers `totalUnderlying()` to `sponsorToTransfer` without considering other depositors, enabling an attacker to deposit a tiny amount of underlying tokens and inflate `newShares` to an extremely large value.

**Match in Response List**:  
Matches with the issue titled **""Force Withdraw/Unsponsor Functions Bypass Lockup Restrictions but Don't Check Overall Vault Solvency and can lead to Incorrect Calculations.""**

**Validation**:  
**Partially Correct**. The response identifies the issue with `forceUnsponsor` bypassing lockup restrictions and mentions incorrect calculations. However, it does not explicitly address the manipulation of `_totalShares` or the freezing of users' funds, which are critical aspects of the reported issue.

---

#### **[H-02] Withdrawers can get more value returned than expected with reentrant call**

**Report Description**:  
The `withdraw` function is vulnerable to reentrancy attacks, allowing users to withdraw significantly more UST than expected. This occurs because the function does not implement a reentrancy guard, enabling attackers to recursively call the function before state updates are complete.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability in `claimYield` and `_withdrawDeposit` Functions.""**

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in functions involving external calls, including `_withdrawDeposit`. It correctly explains the risks of reentrancy and aligns with the reported issue.

---

#### **[H-04] deposit() function is open to reentrancy attacks**

**Report Description**:  
The `deposit()` function in `Vault.sol` is vulnerable to reentrancy attacks due to the use of `depositors.mint()` and `claimers.mint()`, which trigger callbacks. An attacker can exploit this to mint multiple NFTs and manipulate the protocol's state, including `newShares`.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability in `claimYield` and `_withdrawDeposit` Functions.""**

**Validation**:  
**Partially Correct**. The response identifies reentrancy vulnerabilities in other functions but does not explicitly mention the `deposit()` function or the specific risks associated with NFT minting callbacks.

---

#### **[H-05] sponsor() function is open to reentrancy attacks**

**Report Description**:  
The `sponsor()` function lacks a reentrancy guard, allowing attackers to reenter the function via the `depositors.mint()` callback. This can lead to incorrect updates of `totalSponsored` and the `Sponsored` event.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability in `claimYield` and `_withdrawDeposit` Functions.""**

**Validation**:  
**Partially Correct**. The response identifies reentrancy vulnerabilities but does not specifically address the `sponsor()` function or the risks associated with state updates after the callback.

---

#### **[M-04] unsponsor, claimYield, and withdraw might fail unexpectedly**

**Report Description**:  
The `_unsponsor`, `claimYield`, and `withdraw` functions may fail unexpectedly because `totalUnderlying()` includes invested assets not in the contract balance. This can lead to insufficient funds for transfers, especially in `forceUnsponsor`, which attempts to transfer `totalUnderlying()`.

**Match in Response List**:  
Matches with the issue titled **""Force Withdraw/Unsponsor Functions Bypass Lockup Restrictions but Don't Check Overall Vault Solvency and can lead to Incorrect Calculations.""**

**Validation**:  
**Correct**. The response accurately identifies the issue with `forceUnsponsor` and `forceWithdraw` bypassing solvency checks, leading to potential failures in transfers.

---

#### **[M-06] totalUnderlyingMinusSponsored() may revert on underflow and malfunction the contract**

**Report Description**:  
The `totalUnderlyingMinusSponsored()` function may revert due to underflow if `totalSponsored` exceeds `totalUnderlying()`, causing the contract to malfunction.

**Match in Response List**:  
Matches with the issue titled **""Potential Integer Overflow/Underflow in Share and Amount Calculations.""**

**Validation**:  
**Correct**. The response identifies the risk of integer underflow in calculations involving `totalSponsored` and `totalUnderlying()`, aligning with the reported issue.

---

#### **[M-07] Vault can't receive deposits if underlying token charges fees on transfer**

**Report Description**:  
If the underlying token charges fees on transfer, deposits to the vault will fail because `_transferAndCheckUnderlying()` does not account for such fees.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Calculation in `_transferAndCheckUnderlying`.""**

**Validation**:  
**Correct**. The response accurately identifies the issue with `_transferAndCheckUnderlying()` failing to account for token transfer fees, leading to deposit failures.

---

#### **[M-15] Check _to is not empty**

**Report Description**:  
The `claimYield`, `_withdraw`, and `_unsponsor` functions should validate that `_to` is not an empty address to prevent accidental burns.

**Match in Response List**:  
Matches with the issue titled **""Missing Zero Address Check for `_to` in `_withdraw` and `_unsponsor` functions.""**

**Validation**:  
**Correct**. The response accurately identifies the missing zero address check in `_withdraw` and `_unsponsor`, aligning with the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- **[H-02] Withdrawers can get more value returned than expected with reentrant call**
- **[M-04] unsponsor, claimYield, and withdraw might fail unexpectedly**
- **[M-06] totalUnderlyingMinusSponsored() may revert on underflow and malfunction the contract**
- **[M-07] Vault can't receive deposits if underlying token charges fees on transfer**
- **[M-15] Check _to is not empty**

**Partially Correct Matches**:
- **[H-01] forceUnsponsor() may open a window for attackers to manipulate the _totalShares and freeze users' funds at a certain deposit amount**
- **[H-04] deposit() function is open to reentrancy attacks**
- **[H-05] sponsor() function is open to reentrancy attacks**

**Missed Issues from Issue Report**:
- *None*

--- 

The response list covers most of the issues in the report, but some critical details in the partially correct matches are missing. Overall, the response list is comprehensive but could benefit from more specific details in certain areas.","```
1. Potential Reentrancy Vulnerability in `claimYield` and `_withdrawDeposit` Functions.
2. Force Withdraw/Unsponsor Functions Bypass Lockup Restrictions but Don't Check Overall Vault Solvency and can lead to Incorrect Calculations.
3. Potential Integer Overflow/Underflow in Share and Amount Calculations.
4. Incorrect Calculation in `_transferAndCheckUnderlying`.
5. Missing Zero Address Check for `_to` in `_withdraw` and `_unsponsor` functions.
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Potential Reentrancy Vulnerability in `claimYield` and `_withdrawDeposit` Functions**: Rank 1
   - **Force Withdraw/Unsponsor Functions Bypass Lockup Restrictions but Don't Check Overall Vault Solvency and can lead to Incorrect Calculations**: Rank 6
   - **Potential Integer Overflow/Underflow in Share and Amount Calculations**: Rank 5
   - **Incorrect Calculation in `_transferAndCheckUnderlying`**: Rank 7
   - **Missing Zero Address Check for `_to` in `_withdraw` and `_unsponsor` functions**: Rank 16

2. **Calculate the precision at each rank where a true positive appears**:
   - **Rank 1**: \( P@1 = \frac{1}{1} = 1.0 \)
   - **Rank 5**: \( P@5 = \frac{2}{5} = 0.4 \)
   - **Rank 6**: \( P@6 = \frac{3}{6} = 0.5 \)
   - **Rank 7**: \( P@7 = \frac{4}{7} \approx 0.571 \)
   - **Rank 16**: \( P@16 = \frac{5}{16} \approx 0.3125 \)

3. **Average the precision values**:
   \[
   AP = \frac{1.0 + 0.4 + 0.5 + 0.571 + 0.3125}{5} = \frac{2.7835}{5} \approx 0.5567
   \]

**Average Precision (AP)**: 0.5567"
NonUSTStrategy.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import ""./curve/ICurve.sol"";
import ""./BaseStrategy.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

/**
 * Strategy that handles non-UST tokens, by first converting them to UST via
 * Curve (https://curve.fi/), and only then depositing into EthAnchor
 */
contract NonUSTStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    // address of the Curve pool to use
    ICurve public curvePool;

    // index of the underlying token in the pool
    int128 public underlyingI;

    // index of the UST token in the pool
    int128 public ustI;

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner,
        address _curvePool,
        int128 _underlyingI,
        int128 _ustI
    )
        BaseStrategy(
            _vault,
            _treasury,
            _ethAnchorRouter,
            _exchangeRateFeeder,
            _ustToken,
            _aUstToken,
            _perfFeePct,
            _owner
        )
    {
        require(underlying != _ustToken, ""invalid underlying"");
        require(_curvePool != address(0), ""0x addr"");
        curvePool = ICurve(_curvePool);
        underlyingI = _underlyingI;
        ustI = _ustI;

        ustToken.safeApprove(_curvePool, type(uint256).max);
        underlying.safeApprove(_curvePool, type(uint256).max);
    }

    /**
     * Swaps the underlying currency for UST, and initiates a deposit of all
     * the converted UST into EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the deposit process, but does not finish it.
     */
    function doHardWork() external override(BaseStrategy) restricted {
        _swapUnderlyingToUst();
        _initDepositStable();
    }

    /**
     * Calls Curve to convert the existing underlying balance into UST
     */
    function _swapUnderlyingToUst() internal {
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            // slither-disable-next-line unused-return
            curvePool.exchange_underlying(
                underlyingI,
                ustI,
                underlyingBalance,
                0
            );
        }
    }

    /**
     * Calls Curve to convert the existing UST back into the underlying token
     */
    function _swapUstToUnderlying() internal {
        uint256 ustBalance = _getUstBalance();
        if (ustBalance > 0) {
            // slither-disable-next-line unused-return
            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);
        }
    }

    /**
     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.
     * Once UST is retrieved, convert it back to underlying via Curve
     *
     * @notice Must be called some time after `initRedeemStable()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending redeem operation
     */
    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {
        super.finishRedeemStable(idx);
        _swapUstToUnderlying();
    }

    /**
     * Amount, expressed in the underlying currency, currently in the strategy
     *
     * @notice both held and invested amounts are included here, using the
     * latest known exchange rates to the underlying currency
     *
     * @return The total amount of underlying
     */
    function investedAssets()
        external
        view
        override(BaseStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance();
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(
            address(aUstToken),
            true
        ) * aUstBalance) / 1e18) + pendingDeposits;
        return
            underlyingBalance +
            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);
    }
}",1005,137,"[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool

In short, the NonUSTStrategy is vulnerable to attacks by flash loans on curve pools.
Here's an outline of the attack:
Assume there is a vault with DAI underlying and a NonUSTStrategy with a DAI / UST curve pool
Take out a flash loan of DAI
Exchange a ton of DAI for UST
The exchange rate from DAI to UST has gone up (!!)
Withdraw or deposit from vault with more favorable terms than market
Transfer back UST to DAI
Repay flash loan
  [M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users

Function `_swapUnderlyingToUst`
https://github.com/code-423n4/2022-01-sandclock/blob/a90ad3824955327597be00bb0bd183a9c228a4fb/sandclock/contracts/strategy/NonUSTStrategy.sol#L66-L69
NonUSTStrategy will swap the deposited non-UST assets into UST before depositing to EthAnchor. However, the swap fee is not attributed to the depositor correctly like many other yield farming vaults involving swaps (ZapIn).
An attacker can exploit it for the swap fees paid by other users by taking a majority share of the liquidity pool.
 [M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals

Submitted by leastwood, also found by danb
The investedAssets() function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in finishRedeemStable().
",3,,"pragma solidity ^0.8.10;

import ""./curve/ICurve.sol"";
import ""./BaseStrategy.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";


contract NonUSTStrategy is BaseStrategy {
    using SafeERC20 for IERC20;

    
    ICurve public curvePool;

    
    int128 public underlyingI;

    
    int128 public ustI;

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner,
        address _curvePool,
        int128 _underlyingI,
        int128 _ustI
    )
        BaseStrategy(
            _vault,
            _treasury,
            _ethAnchorRouter,
            _exchangeRateFeeder,
            _ustToken,
            _aUstToken,
            _perfFeePct,
            _owner
        )
    {
        require(underlying != _ustToken, ""invalid underlying"");
        require(_curvePool != address(0), ""0x addr"");
        curvePool = ICurve(_curvePool);
        underlyingI = _underlyingI;
        ustI = _ustI;

        ustToken.safeApprove(_curvePool, type(uint256).max);
        underlying.safeApprove(_curvePool, type(uint256).max);
    }

    
    function doHardWork() external override(BaseStrategy) restricted {
        _swapUnderlyingToUst();
        _initDepositStable();
    }

    
    function _swapUnderlyingToUst() internal {
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            
            curvePool.exchange_underlying(
                underlyingI,
                ustI,
                underlyingBalance,
                0
            );
        }
    }

    
    function _swapUstToUnderlying() internal {
        uint256 ustBalance = _getUstBalance();
        if (ustBalance > 0) {
            
            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);
        }
    }

    
    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {
        super.finishRedeemStable(idx);
        _swapUstToUnderlying();
    }

    
    function investedAssets()
        external
        view
        override(BaseStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance();
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(
            address(aUstToken),
            true
        ) * aUstBalance) / 1e18) + pendingDeposits;
        return
            underlyingBalance +
            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);
    }
}",664,1,2,"{
  ""task_list"": [
    {
      ""Area"": ""Curve Pool Interaction Security"",
      ""Tasks"": [
        ""Verify the implementation of `ICurve` interface against the actual Curve pool contract being used to ensure correct function signatures and data types."",
        ""Analyze the potential slippage when calling `curvePool.exchange_underlying` with `min_dy` set to 0.  Simulate swaps with varying sizes to determine potential losses due to slippage and front-running. Implement slippage control if necessary."",
        ""Investigate potential for manipulation of the Curve pool price oracle and its impact on the `investedAssets` function."",
        ""Confirm that the `underlyingI` and `ustI` indices correctly correspond to the underlying asset and UST within the Curve pool's configuration."",
        ""Review the Curve pool contract for any known vulnerabilities or exploits specific to the pool implementation."",
        ""Verify that the approvals granted to the Curve pool are sufficient and not excessive, preventing potential draining of tokens by a malicious or compromised Curve pool contract.""
      ]
    },
    {
      ""Area"": ""BaseStrategy Integration and Anchor Protocol Interaction"",
      ""Tasks"": [
        ""Thoroughly review the `BaseStrategy` contract, especially the implementation of `_initDepositStable`, `finishRedeemStable` and its interaction with the Anchor protocol."",
        ""Analyze the potential risks associated with depositing UST into and redeeming UST from Anchor through the `BaseStrategy` methods."",
        ""Examine the `exchangeRateFeeder` contract and its role in calculating `investedAssets`. Verify that the exchange rate is resistant to manipulation and accurately reflects the value of aUST."",
        ""Investigate the handling of `pendingRedeems` and `pendingDeposits` in `investedAssets` function. Confirm their correct usage and prevent potential accounting errors or exploits."",
        ""Assess the impact of Anchor protocol instability (e.g., de-pegging of UST, changes in interest rates) on the strategy's profitability and solvency."",
        ""Verify proper handling of fees inside `BaseStrategy` and ensure that performance fees are calculated and distributed correctly.""
      ]
    },
    {
      ""Area"": ""Access Control and Security"",
      ""Tasks"": [
        ""Verify that the `restricted` modifier in `doHardWork` effectively restricts access to authorized accounts only."",
        ""Review the ownership and admin roles within the contract and `BaseStrategy` to ensure proper access control."",
        ""Analyze the potential impact of a compromised owner or admin account."",
        ""Confirm the validity and purpose of `_ethAnchorRouter` address."",
        ""Assess the consequences if `_ethAnchorRouter` is malicious or compromised."",
        ""Investigate potential reentrancy vulnerabilities, especially in functions that interact with external contracts (Curve pool, Anchor protocol)."",
        ""Confirm the usage of safe math operations to prevent overflows/underflows.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of `doHardWork`, `finishRedeemStable` and `investedAssets` functions."",
        ""Identify potential gas optimizations, such as reducing storage reads/writes, using more efficient data structures or algorithms."",
        ""Evaluate the trade-offs between gas optimization and code readability/maintainability.""
      ]
    },
    {
      ""Area"": ""Token Handling and Arithmetic"",
      ""Tasks"": [
        ""Verify that all token transfers use `SafeERC20` to prevent issues with non-standard ERC20 tokens."",
        ""Ensure that calculations involving token amounts are performed with sufficient precision to avoid rounding errors."",
        ""Check for potential vulnerabilities arising from incorrect token decimals handling, especially when interacting with Curve pools or the exchange rate feeder.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `NonUSTStrategy` manages the investment and rebalancing of assets between an underlying asset (other than UST) and UST via a Curve pool. It inherits from `BaseStrategy` and utilizes `ICurve` for swaps, `IERC20` for token interactions and `SafeERC20` for safe ERC20 operations. The strategy aims to deposit UST into Anchor (through the `BaseStrategy` methods) to earn yield."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NonUSTStrategy"",
    ""Purpose"": ""This contract implements a strategy for a vault, swapping between an underlying asset (other than UST) and UST via a Curve pool before depositing into Anchor protocol (handled in BaseStrategy)."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""BaseStrategy""],
      ""Imports"": [
        ""./curve/ICurve.sol"",
        ""./BaseStrategy.sol"",
        ""@openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""curvePool"",
        ""Type"": ""ICurve"",
        ""Purpose"": ""Address of the Curve pool used for swapping""
      },
      {
        ""Name"": ""underlyingI"",
        ""Type"": ""int128"",
        ""Purpose"": ""Index of the underlying asset in the Curve pool""
      },
      {
        ""Name"": ""ustI"",
        ""Type"": ""int128"",
        ""Purpose"": ""Index of the UST token in the Curve pool""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, sets addresses, and approves tokens to the curve pool."",
        ""Parameters"": [
          ""_vault"",
          ""_treasury"",
          ""_ethAnchorRouter"",
          ""_exchangeRateFeeder"",
          ""_ustToken"",
          ""_aUstToken"",
          ""_perfFeePct"",
          ""_owner"",
          ""_curvePool"",
          ""_underlyingI"",
          ""_ustI""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""doHardWork"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Performs the core strategy logic: swaps the underlying asset to UST and then deposits the UST.  Calls `_swapUnderlyingToUst()` and `_initDepositStable()`."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_swapUnderlyingToUst"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swaps the underlying asset to UST using the Curve pool."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_swapUstToUnderlying"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swaps UST to the underlying asset using the Curve pool."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""finishRedeemStable"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Called after redeeming from Anchor, swaps UST back to the underlying asset."",
        ""Parameters"": [""idx""],
        ""Returns"": []
      },
      {
        ""Name"": ""investedAssets"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Calculates the total value of assets invested in the strategy, including underlying assets and UST equivalent from aUST."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""ICurve (custom interface) - Interacts with the Curve pool for swapping tokens."",
    ""IERC20 (OpenZeppelin) - Interacts with ERC20 tokens."",
    ""exchangeRateFeeder (address) - Retrieves the exchange rate for aUST."",
    ""BaseStrategy - Inherits methods from this contract, presumably for depositing to Anchor.""
  ],
  ""SpecialMechanisms"": [
    ""The contract uses SafeERC20 library to avoid common ERC20 pitfalls. The use of int128 indices for the Curve pool indicates a specific design of the targeted Curve pool."",
    ""Swaps happen within the `doHardWork` and `finishRedeemStable` functions to manage the asset balance.""
  ],
  ""Questions"": [
    ""What is the structure of `BaseStrategy`? Understanding how `_initDepositStable` and `finishRedeemStable` affect the overall strategy is critical."",
    ""What specific Curve pool is being targeted? Understanding the parameters and implementation of the `ICurve` interface is essential."",
    ""What are the specific assets involved in the strategy? Knowing the underlying asset and UST token is needed for a comprehensive risk assessment."",
    ""How frequently is `doHardWork` expected to be called? The frequency impacts swap costs and profitability."",
     ""Is there any slippage protection used when calling `curvePool.exchange_underlying`? Setting `min_dy` to 0 is risky as it allows for significant slippage.""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Missing Slippage Protection in Swaps"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_swapUnderlyingToUst` and `_swapUstToUnderlying` functions call `curvePool.exchange_underlying` with `min_dy` or `min_amount` set to 0, which means the swap will execute regardless of slippage. This can lead to significant financial losses due to unfavorable swap prices, front-running, or price manipulation attacks if there is high volatility or low liquidity in the Curve pool."",
      ""Impact"": ""Significant financial losses due to unfavorable swap prices, potentially draining the strategy's funds. Vulnerability to front-running and high slippage during swaps."",
      ""Location"": ""_swapUnderlyingToUst, _swapUstToUnderlying functions""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `finishRedeemStable`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `finishRedeemStable` function calls `super.finishRedeemStable(idx)` before calling `_swapUstToUnderlying()`. If the `super.finishRedeemStable(idx)` function allows external calls, it could create a reentrancy vulnerability, potentially leading to unexpected behavior or loss of funds. The specific reentrancy risk depends on the implementation of `BaseStrategy.finishRedeemStable()` which needs to be analyzed in the context of this strategy."",
      ""Impact"": ""Potential for malicious actors to drain funds or manipulate the state of the strategy through reentrancy attacks. Requires analyzing `BaseStrategy.finishRedeemStable()` to confirm risk.""
    },
    {
      ""Issue"": ""Missing Input Validation for Curve Pool Indices"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor receives `_underlyingI` and `_ustI` as indices for the Curve pool. There is no validation to ensure that these indices are within the valid range for the specific Curve pool being used. An invalid index could lead to unexpected behavior or revert, especially if the Curve pool's number of coins or configuration changes."",
      ""Impact"": ""Potential for transaction failures, incorrect calculations, or unintended behavior if the indices are out of bounds for the Curve pool."",
      ""Location"": ""Constructor: NonUSTStrategy.sol""
    },
    {
      ""Issue"": ""Lack of Emergency Pause Mechanism"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks a mechanism to pause the strategy in case of emergencies, such as a vulnerability being discovered in the Curve pool or the `exchangeRateFeeder` contract. A pause function would allow the owner to temporarily halt operations and prevent further losses while the issue is investigated and resolved."",
      ""Impact"": ""Increased risk of financial losses in case of unexpected events or vulnerabilities."",
      ""Location"": ""Entire Contract: NonUSTStrategy.sol""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `investedAssets` calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `investedAssets` function, the calculation `(exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) * aUstBalance) / 1e18` could potentially lead to an integer overflow if `exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) * aUstBalance` is a very large number. Similarly, potential rounding errors may also affect the investedAssets calculation."",
      ""Impact"": ""Transaction reverts if integer overflow/underflow occurs. While built-in checks prevent silent errors, it still disrupts normal operation. Inaccurate investedAssets calculation, potentially misleading users and affecting fee calculations based on the invested amount."",
      ""Location"": ""investedAssets function""
    },
    {
      ""Issue"": ""Unbounded Approval Amounts for Curve Pool"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor approves the `curvePool` for `type(uint256).max` for both `ustToken` and `underlying`. While this is a common practice, it's worth noting that some users prefer to limit approval amounts to reduce potential risks if the Curve pool contract is compromised in the future."",
      ""Impact"": ""Slightly increased risk in case of compromise of the Curve pool, as the Curve pool has unlimited access to the strategy's UST and Underlying tokens."",
      ""Location"": ""Constructor: NonUSTStrategy.sol""
    },
    {
      ""Issue"": ""Missing Validation on Addresses in Constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""While the constructor checks for a zero address for `_curvePool`, it doesn't check for zero addresses for other critical components such as `_vault`, `_treasury`, `_ethAnchorRouter`, and `_exchangeRateFeeder`. A zero address for these parameters can lead to contract malfunction."",
      ""Impact"": ""Potential contract malfunction and loss of functionality if critical addresses are incorrectly set to zero."",
      ""Location"": ""Constructor: NonUSTStrategy.sol""
    },
    {
      ""Issue"": ""Lack of checks for return values from external calls"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract does not check return values from the calls to the `curvePool` in `_swapUnderlyingToUst` and `_swapUstToUnderlying` functions. Failures from the Curve pool could lead to unexpected states and potential vulnerabilities that are not caught."",
      ""Impact"": ""The strategy may not function as expected if the calls to `curvePool` fail without being detected and handled."",
      ""Location"": ""_swapUnderlyingToUst and _swapUstToUnderlying functions""
    },
    {
      ""Issue"": ""Lack of validation of `_curvePool` address in constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""While the constructor checks for a zero address for `_curvePool`, it does not validate that the provided address is indeed a contract implementing the `ICurve` interface. Providing an arbitrary non-zero address that isn't a `ICurve` contract will cause the contract to revert when `curvePool.exchange_underlying` or `curvePool.get_dy_underlying` is called, potentially bricking the strategy."",
      ""Impact"": ""Strategy can become unusable if an invalid Curve pool address is provided during deployment."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Missing access control for `finishRedeemStable` function"",
      ""Severity"": ""Info"",
      ""Description"": ""While `finishRedeemStable` calls `super.finishRedeemStable(idx)` which presumably has access control, it is good practice to explicitly define the required access restrictions directly on `NonUSTStrategy.finishRedeemStable`. This improves code readability and reduces reliance on implementation details of the base class."",
      ""Impact"": ""Reduced code clarity and increased dependency on the base class implementation."",
      ""Location"": ""finishRedeemStable function""
    },
    {
      ""Issue"": ""Unnecessary Approvals in Constructor"",
      ""Severity"": ""Info"",
      ""Description"": ""The constructor approves the curve pool for both `ustToken` and `underlying` for `type(uint256).max`. Depending on the design of `BaseStrategy`, it's possible that `BaseStrategy` might already be approving these tokens. If so, this is redundant. If `BaseStrategy` doesn't do this, it's okay but this can be improved with an approval check before approving."",
      ""Impact"": ""Gas inefficiency, slightly increased deployment cost."",
      ""Location"": ""Constructor""
    }
  ],
  ""IssueNumber"": 31,
  ""OutputList"": 11
}",166.323881149292,2745.0,32.0,"### **[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool**

**Report Description**:
The `NonUSTStrategy` is vulnerable to flash loan attacks on Curve pools. An attacker can exploit this by taking out a flash loan of the underlying asset (e.g., DAI), exchanging a large amount of DAI for UST to manipulate the exchange rate, and then withdrawing or depositing from the vault under more favorable terms. This manipulation can lead to financial losses for the vault and its users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific vulnerability of flash loan attacks on Curve pools in the context of `NonUSTStrategy`. While some issues related to Curve pools are mentioned (e.g., missing slippage protection), none of them specifically identify or address the risk of flash loan attacks and their impact on the strategy.

---

### **[M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users**

**Report Description**:
The `_swapUnderlyingToUst` function in `NonUSTStrategy.sol` swaps non-UST assets into UST but does not correctly attribute swap fees to the depositor. An attacker can exploit this by taking a majority share of the liquidity pool, allowing them to steal swap fees paid by other users.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of improper handling of swap fees in `_swapUnderlyingToUst`. While there are findings related to slippage and Curve pool interactions, none of them specifically identify the risk of fee misattribution or the potential for an attacker to exploit this vulnerability.

---

### **[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Report Description**:
The `investedAssets()` function in `NonUSTStrategy.sol` and `BaseStrategy.sol` does not account for the performance fee charged by the treasury during withdrawals. This oversight can lead to inaccurate calculations of the vault's investments, potentially misleading users and affecting fee calculations.

**Match in Response List**:
Matches with the issue titled **""Potential Integer Overflow/Underflow in `investedAssets` calculation""**.

**Validation**:
**Partially Correct**. The response identifies a potential issue with the `investedAssets` function, specifically the risk of integer overflow/underflow. However, it does not address the core issue of the function failing to account for performance fees charged during withdrawals. While the response highlights a technical risk, it misses the broader financial impact of the oversight.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Missed Issues from Issue Report**:
- **[H-03] Vaults with non-UST underlying asset vulnerable to flash loan attack on curve pool**
- **[M-02] NonUSTStrategy.sol Improper handling of swap fees allows attacker to steal funds from other users**

---

### **Conclusion**
The response list partially addresses one of the issues ([M-12]) but misses the other two critical vulnerabilities ([H-03] and [M-02]). The findings in the response list focus on technical risks (e.g., integer overflow, slippage) but fail to capture the broader financial and security implications of the issues reported in the `issue` list. This highlights a significant gap in the coverage and accuracy of the responses.","```
None.
```",0.0
BaseStrategy.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import ""../lib/PercentMath.sol"";
import ""../vault/IVault.sol"";
import ""./IStrategy.sol"";
import ""./anchor/IEthAnchorRouter.sol"";
import ""./anchor/IExchangeRateFeeder.sol"";

// import ""./Controllable.sol"";

/**
 * Base strategy that handles UST tokens and invests them via the EthAnchor
 * protocol (https://docs.anchorprotocol.com/ethanchor/ethanchor)
 */
abstract contract BaseStrategy is IStrategy, Trust {
    using SafeERC20 for IERC20;
    using PercentMath for uint256;

    event PerfFeeClaimed(uint256 amount);
    event PerfFeePctUpdated(uint256 pct);

    struct Operation {
        address operator;
        uint256 amount;
    }

    IERC20 public override(IStrategy) underlying;
    // Vault address
    address public override(IStrategy) vault;

    // address of the treasury
    address public treasury;

    // address for the UST token
    IERC20 public ustToken;

    // address for the aUST token (wrapped Anchor UST, received to accrue interest for an Anchor deposit)
    IERC20 public aUstToken;

    // performance fee taken by the treasury on profits
    uint16 public perfFeePct;

    // external contract to interact with EthAnchor
    IEthAnchorRouter public ethAnchorRouter;

    // external exchange rate provider
    IExchangeRateFeeder public exchangeRateFeeder;

    // amount currently pending in deposits to EthAnchor
    uint256 public pendingDeposits;

    // amount currently pending redeemption from EthAnchor
    uint256 public pendingRedeems;

    // deposit operations history
    Operation[] public depositOperations;

    // redeem operations history
    Operation[] public redeemOperations;

    // amount of UST converted (used to calculate yield)
    uint256 public convertedUst;

    // restructs a function to be called only by the vault or governance
    modifier restricted() {
        require(msg.sender == vault || isTrusted[msg.sender], ""restricted"");

        _;
    }

    modifier onlyVault() {
        require(msg.sender == vault, ""only vault"");

        _;
    }

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner
    ) Trust(_owner) {
        require(_ethAnchorRouter != address(0), ""0x addr"");
        require(_exchangeRateFeeder != address(0), ""0x addr"");
        require(address(_ustToken) != address(0), ""0x addr"");
        require(address(_aUstToken) != address(0), ""0x addr"");
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");

        treasury = _treasury;
        vault = _vault;
        underlying = IVault(_vault).underlying();
        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);
        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);
        ustToken = _ustToken;
        aUstToken = _aUstToken;
        perfFeePct = _perfFeePct;

        // pre-approve EthAnchor router to transact all UST and aUST
        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);
        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);
    }

    /**
     * Initiates a deposit of all the currently held UST into EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the deposit process, but does not finish it.
     */
    function doHardWork() external virtual override(IStrategy) restricted {
        _initDepositStable();
    }

    function _initDepositStable() internal {
        uint256 ustBalance = _getUstBalance();
        require(ustBalance > 0, ""balance 0"");
        pendingDeposits += ustBalance;
        address _operator = ethAnchorRouter.initDepositStable(ustBalance);
        depositOperations.push(
            Operation({operator: _operator, amount: ustBalance})
        );
    }

    /**
     * Calls EthAnchor with a pending deposit ID, and attempts to finish it.
     *
     * @notice Must be called some time after `doHardWork()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending deposit operation
     */
    function finishDepositStable(uint256 idx) external {
        require(depositOperations.length > idx, ""not running"");
        Operation storage operation = depositOperations[idx];
        ethAnchorRouter.finishDepositStable(operation.operator);

        pendingDeposits -= operation.amount;
        convertedUst += operation.amount;

        operation.operator = depositOperations[depositOperations.length - 1]
            .operator;
        operation.amount = depositOperations[depositOperations.length - 1]
            .amount;
        depositOperations.pop();
    }

    /**
     * Initiates a withdrawal of UST from EthAnchor
     *
     * @notice since EthAnchor uses an asynchronous model, this function
     * only starts the redeem process, but does not finish it.
     *
     * @param amount Amount of aUST to redeem
     */
    function initRedeemStable(uint256 amount) public restricted {
        uint256 aUstBalance = _getAUstBalance();
        require(amount > 0, ""amount 0"");
        require(aUstBalance >= amount, ""insufficient"");
        pendingRedeems += amount;
        address _operator = ethAnchorRouter.initRedeemStable(amount);
        redeemOperations.push(Operation({operator: _operator, amount: amount}));
    }

    /**
     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.
     *
     * @notice Must be called some time after `initRedeemStable()`. Will only work if
     * the EthAnchor bridge has finished processing the deposit.
     *
     * @param idx Id of the pending redeem operation
     */
    function finishRedeemStable(uint256 idx) public virtual {
        require(redeemOperations.length > idx, ""not running"");
        Operation storage operation = redeemOperations[idx];
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;
        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;
        uint256 ustBalanceBefore = _getUstBalance();

        ethAnchorRouter.finishRedeemStable(operation.operator);

        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;
        uint256 perfFee = redeemedAmount > originalUst
            ? (redeemedAmount - originalUst).percOf(perfFeePct)
            : 0;
        if (perfFee > 0) {
            ustToken.safeTransfer(treasury, perfFee);
            emit PerfFeeClaimed(perfFee);
        }
        convertedUst -= originalUst;
        pendingRedeems -= operation.amount;

        operation.operator = redeemOperations[redeemOperations.length - 1]
            .operator;
        operation.amount = redeemOperations[redeemOperations.length - 1].amount;
        redeemOperations.pop();
    }

    /**
     * Withdraws the entire amount back to the vault
     *
     * @notice since some of the amount may be deposited into EthAnchor, this
     * call may not withdraw all the funds right away. It will start a redeem
     * process on EthAnchor, but this function must be called again a second
     * time once that is finished.
     */
    function withdrawAllToVault() external override(IStrategy) restricted {
        uint256 aUstBalance = _getAUstBalance();
        if (aUstBalance > 0) {
            initRedeemStable(aUstBalance);
        }
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            underlying.safeTransfer(vault, underlyingBalance);
        }
    }

    /**
     * Withdraws a specified amount back to the vault
     *
     * @notice Unlike `withdrawToVault`, this function only considers the
     * amount currently not invested, but only what is currently held by the
     * strategy
     *
     * @param amount Amount to withdraw
     */
    function withdrawToVault(uint256 amount)
        external
        override(IStrategy)
        restricted
    {
        underlying.safeTransfer(vault, amount);
    }

    /**
     * Updates the performance fee
     *
     * @notice Can only be called by governance
     *
     * @param _perfFeePct The new performance fee %
     */
    function setPerfFeePct(uint16 _perfFeePct) external restricted {
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");
        perfFeePct = _perfFeePct;
        emit PerfFeePctUpdated(_perfFeePct);
    }

    /**
     * Amount, expressed in the underlying currency, currently in the strategy
     *
     * @notice both held and invested amounts are included here, using the
     * latest known exchange rates to the underlying currency
     *
     * @return The total amount of underlying
     */
    function investedAssets()
        external
        view
        virtual
        override(IStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        return
            underlyingBalance +
            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *
                aUstBalance) / 1e18);
    }

    // Amount of underlying tokens in the strategy
    function _getUnderlyingBalance() internal view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    // Amount of UST tokens in the strategy
    function _getUstBalance() internal view returns (uint256) {
        return ustToken.balanceOf(address(this));
    }

    // Amount of aUST tokens in the strategy
    function _getAUstBalance() internal view returns (uint256) {
        return aUstToken.balanceOf(address(this));
    }

    // Amount of pending deposit operations
    function depositOperationLength() external view returns (uint256) {
        return depositOperations.length;
    }

    // Amount of pending redeem operations
    function redeemOperationLength() external view returns (uint256) {
        return redeemOperations.length;
    }
}",2363,303,"[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys

Submitted by WatchPug
The current implementation requires trusted key holders (`isTrusted[msg.sender]`) to send transactions (`initRedeemStable()`) to initialize withdrawals from EthAnchor before the users can withdraw funds from the contract.
  [M-05] Add a timelock to BaseStrategy:setPerfFeePct

Submitted by Dravee
To give more trust to users: functions that set key/critical variables should be put behind a timelock.

[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals
 
Submitted by leastwood, also found by danb
The investedAssets() function is implemented by the vault's strategy contracts as a way to express a vault's investments in terms of the underlying currency. While the implementation of this function in BaseStrategy.sol and NonUSTStrategy.sol is mostly correct. It does not account for the performance fee charged by the treasury as shown in finishRedeemStable().
",3,,"pragma solidity ^0.8.10;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {Trust} from ""@rari-capital/solmate/src/auth/Trust.sol"";

import ""../lib/PercentMath.sol"";
import ""../vault/IVault.sol"";
import ""./IStrategy.sol"";
import ""./anchor/IEthAnchorRouter.sol"";
import ""./anchor/IExchangeRateFeeder.sol"";




abstract contract BaseStrategy is IStrategy, Trust {
    using SafeERC20 for IERC20;
    using PercentMath for uint256;

    event PerfFeeClaimed(uint256 amount);
    event PerfFeePctUpdated(uint256 pct);

    struct Operation {
        address operator;
        uint256 amount;
    }

    IERC20 public override(IStrategy) underlying;
    
    address public override(IStrategy) vault;

    
    address public treasury;

    
    IERC20 public ustToken;

    
    IERC20 public aUstToken;

    
    uint16 public perfFeePct;

    
    IEthAnchorRouter public ethAnchorRouter;

    
    IExchangeRateFeeder public exchangeRateFeeder;

    
    uint256 public pendingDeposits;

    
    uint256 public pendingRedeems;

    
    Operation[] public depositOperations;

    
    Operation[] public redeemOperations;

    
    uint256 public convertedUst;

    
    modifier restricted() {
        require(msg.sender == vault || isTrusted[msg.sender], ""restricted"");

        _;
    }

    modifier onlyVault() {
        require(msg.sender == vault, ""only vault"");

        _;
    }

    constructor(
        address _vault,
        address _treasury,
        address _ethAnchorRouter,
        address _exchangeRateFeeder,
        IERC20 _ustToken,
        IERC20 _aUstToken,
        uint16 _perfFeePct,
        address _owner
    ) Trust(_owner) {
        require(_ethAnchorRouter != address(0), ""0x addr"");
        require(_exchangeRateFeeder != address(0), ""0x addr"");
        require(address(_ustToken) != address(0), ""0x addr"");
        require(address(_aUstToken) != address(0), ""0x addr"");
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");

        treasury = _treasury;
        vault = _vault;
        underlying = IVault(_vault).underlying();
        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);
        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);
        ustToken = _ustToken;
        aUstToken = _aUstToken;
        perfFeePct = _perfFeePct;

        
        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);
        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);
    }

    
    function doHardWork() external virtual override(IStrategy) restricted {
        _initDepositStable();
    }

    function _initDepositStable() internal {
        uint256 ustBalance = _getUstBalance();
        require(ustBalance > 0, ""balance 0"");
        pendingDeposits += ustBalance;
        address _operator = ethAnchorRouter.initDepositStable(ustBalance);
        depositOperations.push(
            Operation({operator: _operator, amount: ustBalance})
        );
    }

    
    function finishDepositStable(uint256 idx) external {
        require(depositOperations.length > idx, ""not running"");
        Operation storage operation = depositOperations[idx];
        ethAnchorRouter.finishDepositStable(operation.operator);

        pendingDeposits -= operation.amount;
        convertedUst += operation.amount;

        operation.operator = depositOperations[depositOperations.length - 1]
            .operator;
        operation.amount = depositOperations[depositOperations.length - 1]
            .amount;
        depositOperations.pop();
    }

    
    function initRedeemStable(uint256 amount) public restricted {
        uint256 aUstBalance = _getAUstBalance();
        require(amount > 0, ""amount 0"");
        require(aUstBalance >= amount, ""insufficient"");
        pendingRedeems += amount;
        address _operator = ethAnchorRouter.initRedeemStable(amount);
        redeemOperations.push(Operation({operator: _operator, amount: amount}));
    }

    
    function finishRedeemStable(uint256 idx) public virtual {
        require(redeemOperations.length > idx, ""not running"");
        Operation storage operation = redeemOperations[idx];
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;
        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;
        uint256 ustBalanceBefore = _getUstBalance();

        ethAnchorRouter.finishRedeemStable(operation.operator);

        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;
        uint256 perfFee = redeemedAmount > originalUst
            ? (redeemedAmount - originalUst).percOf(perfFeePct)
            : 0;
        if (perfFee > 0) {
            ustToken.safeTransfer(treasury, perfFee);
            emit PerfFeeClaimed(perfFee);
        }
        convertedUst -= originalUst;
        pendingRedeems -= operation.amount;

        operation.operator = redeemOperations[redeemOperations.length - 1]
            .operator;
        operation.amount = redeemOperations[redeemOperations.length - 1].amount;
        redeemOperations.pop();
    }

    
    function withdrawAllToVault() external override(IStrategy) restricted {
        uint256 aUstBalance = _getAUstBalance();
        if (aUstBalance > 0) {
            initRedeemStable(aUstBalance);
        }
        uint256 underlyingBalance = _getUnderlyingBalance();
        if (underlyingBalance > 0) {
            underlying.safeTransfer(vault, underlyingBalance);
        }
    }

    
    function withdrawToVault(uint256 amount)
        external
        override(IStrategy)
        restricted
    {
        underlying.safeTransfer(vault, amount);
    }

    
    function setPerfFeePct(uint16 _perfFeePct) external restricted {
        require(PercentMath.validPerc(_perfFeePct), ""invalid pct"");
        perfFeePct = _perfFeePct;
        emit PerfFeePctUpdated(_perfFeePct);
    }

    
    function investedAssets()
        external
        view
        virtual
        override(IStrategy)
        returns (uint256)
    {
        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;
        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;

        return
            underlyingBalance +
            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *
                aUstBalance) / 1e18);
    }

    
    function _getUnderlyingBalance() internal view returns (uint256) {
        return underlying.balanceOf(address(this));
    }

    
    function _getUstBalance() internal view returns (uint256) {
        return ustToken.balanceOf(address(this));
    }

    
    function _getAUstBalance() internal view returns (uint256) {
        return aUstToken.balanceOf(address(this));
    }

    
    function depositOperationLength() external view returns (uint256) {
        return depositOperations.length;
    }

    
    function redeemOperationLength() external view returns (uint256) {
        return redeemOperations.length;
    }
}",1636,0,3,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that the `Trust` contract is correctly implemented and that only trusted addresses and the `vault` can call restricted functions."",
        ""Confirm that the `onlyVault` modifier is used appropriately and only allows the `vault` address to call functions that should be exclusively controlled by the vault."",
        ""Analyze the impact of adding/removing trusted addresses via the `Trust` contract and ensure that it doesn't create any unintended access control issues.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Carefully analyze the `finishRedeemStable` function for potential reentrancy vulnerabilities, especially around the external calls to `ethAnchorRouter.finishRedeemStable` and `ustToken.safeTransfer`. Consider using reentrancy guard patterns."",
        ""Check for potential reentrancy issues in `initRedeemStable` function, where the `ethAnchorRouter.initRedeemStable` is called, even though this function doesn't involve any payments here.""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflows/Underflows"",
      ""Tasks"": [
        ""Review all arithmetic operations, especially in the `finishRedeemStable` function when calculating `perfFee` and `originalUst`, to ensure that they are protected against overflows or underflows using SafeMath or Solidity 0.8+ built-in protection. Explicitly check division by zero."",
        ""Examine the calculation of `investedAssets` to confirm that the multiplication and division operations do not lead to overflows, potentially causing incorrect asset valuation.""
      ]
    },
    {
      ""Area"": ""External Interactions and Data Validation"",
      ""Tasks"": [
        ""Thoroughly investigate the implementation of `IEthAnchorRouter` and `IExchangeRateFeeder` to understand their potential failure modes and ensure that the `BaseStrategy` contract handles these failures gracefully. Consider implementing proper error handling and fallback mechanisms."",
        ""Assess the reliability and security of the `exchangeRateOf` function in `IExchangeRateFeeder`. Investigate how the exchange rate is updated and what measures are in place to prevent manipulation or stale data. Analyze the impact of inaccurate exchange rates on the `investedAssets` function."",
        ""Validate the inputs to `initRedeemStable` to prevent potential DoS attacks where a malicious user could provide a very large `amount` value, potentially causing the function to revert or consume excessive gas.""
      ]
    },
    {
      ""Area"": ""Logic Errors and Inconsistencies"",
      ""Tasks"": [
        ""Verify the calculation of `originalUst` in `finishRedeemStable` by cross-referencing the logic with the Anchor Protocol's redemption process to ensure accuracy and prevent incorrect fee calculation."",
        ""Analyze the state updates in `finishDepositStable` and `finishRedeemStable` to ensure that the `pendingDeposits`, `pendingRedeems`, and `convertedUst` variables are updated correctly in all scenarios."",
        ""Review the usage of `depositOperations` and `redeemOperations` arrays. Ensure that the popping and swapping of elements are done correctly to avoid potential inconsistencies in tracking deposit and redeem operations."",
        ""Investigate why `aUstBalance` in `finishRedeemStable` includes `pendingRedeems`, and confirm that this is the intended behavior and doesn't lead to any logical errors in the calculation of `originalUst` or the performance fee.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of the `finishDepositStable` and `finishRedeemStable` functions, particularly the array manipulation operations, and explore opportunities for optimization to reduce gas consumption."",
        ""Consider caching frequently accessed state variables to reduce the number of SLOAD operations and improve gas efficiency.""
      ]
    },
    {
      ""Area"": ""Unused Return Values"",
      ""Tasks"": [
        ""Inspect the return values of external calls to `ethAnchorRouter.initDepositStable` and `ethAnchorRouter.initRedeemStable`, and check if the returned `operator` address is actually used and if an event should be emitted containing the operator's address.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines an abstract contract `BaseStrategy` designed to interact with Anchor Protocol for yield generation. It handles depositing UST tokens into Anchor and redeeming aUST tokens back to UST. It manages fees, tracks pending operations, and integrates with a Vault contract for overall asset management."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""BaseStrategy"",
    ""Purpose"": ""Abstract base contract for strategies that interact with Anchor Protocol to deposit UST and redeem aUST."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""IStrategy"", ""Trust""],
      ""Imports"": [
        ""IERC20 from @openzeppelin/contracts/token/ERC20/IERC20.sol"",
        ""SafeERC20 from @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"",
        ""Trust from @rari-capital/solmate/src/auth/Trust.sol"",
        ""PercentMath from ../lib/PercentMath.sol"",
        ""IVault from ../vault/IVault.sol"",
        ""IStrategy from ./IStrategy.sol"",
        ""IEthAnchorRouter from ./anchor/IEthAnchorRouter.sol"",
        ""IExchangeRateFeeder from ./anchor/IExchangeRateFeeder.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""underlying"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""The underlying asset (e.g., UST) managed by the strategy.""
      },
      {
        ""Name"": ""vault"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the Vault contract that manages the strategy.""
      },
      {
        ""Name"": ""treasury"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the treasury to receive performance fees.""
      },
      {
        ""Name"": ""ustToken"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""IERC20 interface for the UST token.""
      },
      {
        ""Name"": ""aUstToken"",
        ""Type"": ""IERC20"",
        ""Purpose"": ""IERC20 interface for the aUST token.""
      },
      {
        ""Name"": ""perfFeePct"",
        ""Type"": ""uint16"",
        ""Purpose"": ""Percentage of profit to be taken as performance fee.""
      },
      {
        ""Name"": ""ethAnchorRouter"",
        ""Type"": ""IEthAnchorRouter"",
        ""Purpose"": ""Interface to interact with the EthAnchorRouter contract.""
      },
      {
        ""Name"": ""exchangeRateFeeder"",
        ""Type"": ""IExchangeRateFeeder"",
        ""Purpose"": ""Interface to retrieve the exchange rate between aUST and UST.""
      },
      {
        ""Name"": ""pendingDeposits"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of UST pending deposit into Anchor.""
      },
      {
        ""Name"": ""pendingRedeems"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of aUST pending redemption from Anchor.""
      },
      {
        ""Name"": ""depositOperations"",
        ""Type"": ""Operation[]"",
        ""Purpose"": ""Array to track deposit operations.""
      },
      {
        ""Name"": ""redeemOperations"",
        ""Type"": ""Operation[]"",
        ""Purpose"": ""Array to track redeem operations.""
      },
       {
        ""Name"": ""convertedUst"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The amount of UST that has been converted to aUST (used for fee calculations).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with addresses for the vault, treasury, Anchor router, exchange rate feeder, UST token, aUST token, performance fee percentage, and owner."",
        ""Parameters"": [
          ""_vault"",
          ""_treasury"",
          ""_ethAnchorRouter"",
          ""_exchangeRateFeeder"",
          ""_ustToken"",
          ""_aUstToken"",
          ""_perfFeePct"",
          ""_owner""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""doHardWork"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initiates the deposit of stablecoins into Anchor."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_initDepositStable"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers UST to the Anchor router for deposit."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""finishDepositStable"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Finalizes the deposit operation after the Anchor router confirms."",
        ""Parameters"": [""idx""],
        ""Returns"": []
      },
      {
        ""Name"": ""initRedeemStable"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initiates the redemption of aUST from Anchor."",
        ""Parameters"": [""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""finishRedeemStable"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Finalizes the redemption operation after the Anchor router confirms and claims performance fees."",
        ""Parameters"": [""idx""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawAllToVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Redeems all aUST and withdraws all underlying tokens to the vault."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawToVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Withdraws a specific amount of underlying tokens to the vault."",
        ""Parameters"": [""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""setPerfFeePct"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the performance fee percentage."",
        ""Parameters"": [""_perfFeePct""],
        ""Returns"": []
      },
      {
        ""Name"": ""investedAssets"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the total value of assets invested in the strategy, including underlying and aUST."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_getUnderlyingBalance"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the balance of underlying tokens held by the contract."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_getUstBalance"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the balance of UST tokens held by the contract."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_getAUstBalance"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Returns the balance of aUST tokens held by the contract."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""depositOperationLength"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the length of depositOperations array."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""redeemOperationLength"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Returns the length of redeemOperations array."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""restricted"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to the vault or trusted addresses."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyVault"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function access to only the vault address."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20 (UST and aUST tokens)"",
    ""IVault"",
    ""IEthAnchorRouter"",
    ""IExchangeRateFeeder""
  ],
  ""SpecialMechanisms"": [
    ""Uses `Trust` contract for access control."",
    ""Uses `SafeERC20` library for safe token operations."",
    ""Keeps track of pending deposits and redeems."",
    ""Calculates performance fees based on redeemed amounts."",
    ""Uses `PercentMath` library for percentage calculations."",
    ""Tracks operations via the `depositOperations` and `redeemOperations` arrays.""
  ],
  ""Questions"": [
    ""What is the purpose of the `operator` address returned by `ethAnchorRouter.initDepositStable` and `ethAnchorRouter.initRedeemStable`? Why is it important for `finishDepositStable` and `finishRedeemStable`?"",
    ""How is the `exchangeRateOf` function in `IExchangeRateFeeder` implemented? How is it updated, and what are the potential risks associated with relying on an external exchange rate?"",
    ""Are there any potential reentrancy vulnerabilities in the `finishRedeemStable` function, especially related to the external calls to `ethAnchorRouter.finishRedeemStable` and `ustToken.safeTransfer`?"",
    ""What are the possible failure modes for the `ethAnchorRouter.initDepositStable` and `ethAnchorRouter.initRedeemStable` functions, and how are these failures handled by the `BaseStrategy` contract?"",
    ""In `finishRedeemStable`, `aUstBalance` includes `pendingRedeems`. Why is `pendingRedeems` added here instead of only using the actual balance?"",
    ""The swap operation within Anchor Protocol is abstracted away by the `ethAnchorRouter`. What assumptions are being made about how that router performs the swaps and how they are accounted for? Are there any potential slippage or pricing risks that need to be considered?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `finishRedeemStable`"",
      ""Severity"": ""High"",
      ""Description"": ""The `finishRedeemStable` function interacts with an external contract `ethAnchorRouter.finishRedeemStable(operation.operator)` before updating critical state variables (`convertedUst`, `pendingRedeems`, and popping `redeemOperations`). A malicious contract at `ethAnchorRouter` or `treasury` could re-enter `finishRedeemStable`, potentially draining funds by manipulating state before it's updated or causing incorrect calculations, especially related to `_getUstBalance()`, `originalUst`, and performance fees. The re-entrant call could be a callback to the strategy."",
      ""Impact"": ""Potential loss of funds due to reentrancy attacks, incorrect performance fee calculations, and denial of service."",
      ""Location"": ""BaseStrategy.sol:117, BaseStrategy.sol#L133, BaseStrategy.sol#L137, function finishRedeemStable(uint256 idx), Function `finishRedeemStable`""
    },
    {
      ""Issue"": ""Unbounded Array Length for `depositOperations` and `redeemOperations`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `depositOperations` and `redeemOperations` arrays grow without bound as new operations are added via `_initDepositStable` and `initRedeemStable`. Without pruning, gas costs for iterating, accessing, and manipulating these arrays increase linearly. This can lead to denial-of-service (DoS) due to excessive gas consumption (out-of-gas errors), making calls to `finishDepositStable` and `finishRedeemStable` fail or render the contract unusable."",
      ""Impact"": ""Potential denial-of-service (DoS), increased gas costs, contract un-usability, and vulnerability to out-of-gas errors."",
      ""Location"": ""Declaration of `depositOperations` and `redeemOperations` arrays, `finishDepositStable`, `finishRedeemStable`, `_initDepositStable` function, `initRedeemStable` function""
    },
    {
      ""Issue"": ""Incorrect Calculation of `originalUst` in `finishRedeemStable`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The calculation of `originalUst` in `finishRedeemStable` uses an incorrect formula. It incorporates `pendingRedeems` into `aUstBalance` before decrementing it, leading to an inaccurate proportion calculation. This also doesn't account for the aUST to UST exchange rate or aUST earned via interest, leading to potential errors in performance fee calculations. Further, balance manipulation between `initRedeemStable` and `finishRedeemStable` can skew `originalUst` and the performance fee."",
      ""Impact"": ""Potentially incorrect performance fee calculation and inaccurate accounting of converted UST, leading to unfair distribution of rewards and potential loss of funds for the treasury."",
      ""Location"": ""Function `finishRedeemStable`, BaseStrategy.sol#L130-L136""
    },
    {
      ""Issue"": ""Missing Input Validation for `finishDepositStable` and `finishRedeemStable` index"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `finishDepositStable` and `finishRedeemStable` functions lack sufficient input validation for the `idx` parameter used to access elements in the `depositOperations` and `redeemOperations` arrays. There's no check to ensure `idx` is within bounds before array access or to prevent duplicate calls with the same `idx`. Calling the functions with an out-of-bounds `idx` could lead to out-of-bounds reads and DoS. Duplicate calls with the same `idx` can lead to processing the same operation multiple times."",
      ""Impact"": ""Potential denial of service or unexpected behavior due to out-of-bounds array access, double processing of deposits or redeems, and potential inconsistencies in accounting."",
      ""Location"": ""function finishDepositStable(uint256 idx), function finishRedeemStable(uint256 idx), BaseStrategy.sol: `finishDepositStable` and `finishRedeemStable` functions""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `finishDepositStable` and `finishRedeemStable`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `finishDepositStable` and `finishRedeemStable` functions are vulnerable to front-running attacks. A malicious actor could monitor the mempool and front-run a legitimate call to these functions with their own `idx` value, potentially causing the legitimate transaction to fail or operate on unintended data. Also, an attacker can front-run the `finishRedeemStable` call to manipulate the UST balance before it is executed, reducing the performance fee."",
      ""Impact"": ""Denial of service, potential manipulation of operations, and lower performance fees for the treasury."",
      ""Location"": ""BaseStrategy.sol:61, BaseStrategy.sol:105, `finishRedeemStable` function""
    },
    {
      ""Issue"": ""Lack of Slippage Control during redeem"",
      ""Severity"": ""Medium"",
      ""Description"": ""When redeeming `aUstToken` to `ustToken`, the contract lacks any slippage control. If the exchange rate changes significantly between `initRedeemStable` and `finishRedeemStable`, the strategy could receive less `ustToken` than expected, impacting profitability."",
      ""Impact"": ""Potential loss of funds due to unfavorable price fluctuations during the redeem process."",
      ""Location"": ""initRedeemStable and finishRedeemStable functions, BaseStrategy.sol: `finishRedeemStable` function""
    },
    {
      ""Issue"": ""Missing Input Validation for Critical Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor lacks explicit checks on the validity of the `_vault`, `_treasury`, `_ethAnchorRouter`, `_exchangeRateFeeder`, `_ustToken`, and `_aUstToken` addresses beyond being non-zero. It's important to ensure these addresses point to contracts that conform to their respective interfaces. Also Missing Zero Address Check for Vault Address."",
      ""Impact"": ""Unexpected behavior, potential strategy failure, possible loss of funds, potential contract failure or unpredictable behavior."",
      ""Location"": ""BaseStrategy.sol:48-54, Constructor of `BaseStrategy`""
    },
    {
      ""Issue"": ""Potential loss of funds if `ethAnchorRouter.initRedeemStable` reverts after state update."",
      ""Severity"": ""Medium"",
      ""Description"": ""In `initRedeemStable`, `pendingRedeems` is incremented before calling `ethAnchorRouter.initRedeemStable`. If `ethAnchorRouter.initRedeemStable` reverts for some reason after `pendingRedeems` has been updated, the `pendingRedeems` value will be inflated."",
      ""Impact"": ""Incorrect accounting, potential loss of funds due to inflated `pendingRedeems`."",
      ""Location"": ""BaseStrategy.sol#L117, BaseStrategy.sol#L118""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `finishRedeemStable` Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In `finishRedeemStable`, calculations of `originalUst` and `perfFee` could potentially lead to integer overflow or underflow issues if `convertedUst * operation.amount` exceeds the maximum `uint256` value or if `originalUst` is greater than `redeemedAmount`. SafeMath and PercentMath mitigate, but are not a complete protection."",
      ""Impact"": ""Incorrect calculation of original UST and performance fees, potentially leading to incorrect fee calculations or unexpected behavior."",
      ""Location"": ""BaseStrategy.sol:112, function finishRedeemStable(uint256 idx), BaseStrategy.sol#L130, Function `finishRedeemStable`.""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `investedAssets`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `investedAssets` function, the calculation `(exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) * aUstBalance) / 1e18` could potentially lead to an integer overflow if the multiplication exceeds the maximum value of a `uint256`."",
      ""Impact"": ""Incorrect value of `investedAssets` returned, potentially leading to incorrect accounting and reward distribution."",
      ""Location"": ""`investedAssets` function""
    },
    {
      ""Issue"": ""Potential for Griefing in `initRedeemStable`"",
      ""Severity"": ""Low"",
      ""Description"": ""A restricted user could call `initRedeemStable` with a large `amount`, effectively locking up a large portion of the `aUstToken` balance. If `finishRedeemStable` is never called for that `idx`, the funds are effectively inaccessible."",
      ""Impact"": ""Denial of service, potential lockup of funds."",
      ""Location"": ""BaseStrategy.sol:80""
    },
    {
      ""Issue"": ""Lack of access control for `finishDepositStable` and `finishRedeemStable` can lead to DoS and stale operations."",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `finishDepositStable` and `finishRedeemStable` lack proper access control. Anyone can call these functions with any `idx` value. While the functions check `depositOperations.length > idx` and `redeemOperations.length > idx`, a malicious user can call these functions with arbitrary indices which could lead to Denial of Service (DoS) because subsequent calls to `finishDepositStable` using the last index would then operate on incorrect data and potentially fail. For `finishRedeemStable` it might lead to processing a stale redemption with incorrect values."",
      ""Impact"": ""Denial of Service, potential for processing stale or incorrect operations, leading to fund loss or unexpected behavior."",
      ""Location"": ""BaseStrategy.sol#L97, BaseStrategy.sol#L123""
    },
    {
      ""Issue"": ""Use of `operation.operator` after `depositOperations.pop()`/`redeemOperations.pop()`"",
      ""Severity"": ""Low"",
      ""Description"": ""In `finishDepositStable` and `finishRedeemStable`, after `depositOperations.pop()` and `redeemOperations.pop()` respectively, the `operation.operator` and `operation.amount` are updated by the popped element. It\'s unnecessary to write data into storage after the item has been removed."",
      ""Impact"": ""Code clarity issues and potentially unexpected side effects if the popped `operation` storage variable is accidentally used elsewhere later."",
      ""Location"": ""`finishDepositStable` and `finishRedeemStable` functions.""
    },
    {
      ""Issue"": ""Missing Input Validation for `amount` in `initRedeemStable`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `initRedeemStable` function, while it checks if `amount > 0` and `aUstBalance >= amount`, there\'s no upper bound on `amount`. If the Anchor protocol or aUst token has unexpected behavior with such large values, it could lead to issues."",
      ""Impact"": ""Potential integration issues with the Anchor protocol or aUst token if extremely large amounts are used."",
      ""Location"": ""`initRedeemStable` function.""
    },
    {
      ""Issue"": ""Unnecessary `safeApprove` Calls with `type(uint256).max`"",
      ""Severity"": ""Informational"",
      ""Description"": ""The `constructor` calls `ustToken.safeApprove(_ethAnchorRouter, type(uint256).max)` and `aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max)`. While `safeApprove` is generally safe, approving the maximum amount can sometimes cause issues with certain tokens that don’t handle such large allowances correctly."",
      ""Impact"": ""Potential compatibility issues with certain ERC20 tokens."",
      ""Location"": ""BaseStrategy.sol:60-61""
    },
     {
      ""Issue"": ""Use of unchecked math could be used to reduce gas usage."",
      ""Severity"": ""Informational"",
      ""Description"": ""This contract uses solidity 0.8.x and thus is secured with checked math. However, in several places such as `operation.operator = depositOperations[depositOperations.length - 1].operator;`, unchecked math could be used to reduce the gas costs."",
      ""Impact"": ""Higher gas usage."",
      ""Location"": ""BaseStrategy.sol#L104, BaseStrategy.sol#L147""
    },
     {
      ""Issue"": ""Missing Zero Address Check for `_owner` in Trust Constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor of `BaseStrategy` calls the constructor of `Trust` with the `_owner` parameter. However, there is no check to ensure that `_owner` is not the zero address. If `_owner` is the zero address, no one will be able to update the trusted addresses."",
      ""Impact"": ""The contract will be unable to update trusted addresses if the owner is the zero address."",
      ""Location"": ""Constructor of `BaseStrategy`.""
    },
    {
        ""Issue"": ""Potential Front-Running Vulnerability in `setPerfFeePct`"",
        ""Severity"": ""Low"",
        ""Description"": ""The `setPerfFeePct` function allows the owner to update the performance fee percentage. If a malicious actor can front-run a legitimate transaction to update the fee, they could set an extremely high or low fee to their advantage, potentially stealing funds from the treasury or causing other unintended consequences."",
        ""Impact"": ""Potential loss of funds from the treasury due to manipulation of the performance fee."",
        ""Location"": ""BaseStrategy.sol: `setPerfFeePct` function""
    },
    {
        ""Issue"": ""Imprecise performance fee calculation in finishRedeemStable when redeemedAmount < originalUst"",
        ""Severity"": ""Low"",
        ""Description"": ""If `redeemedAmount` is less than `originalUst`, the `perfFee` is calculated as 0, which is correct. However, there is no handling for the case where `redeemedAmount` is slightly less than `originalUst` due to rounding errors. In this case, although the calculated perfFee is 0, it would be more precise to account for the rounding error when updating `convertedUst`."",
        ""Impact"": ""Minor accounting inaccuracies may accumulate over time."",
        ""Location"": ""finishRedeemStable function""
    },
     {
        ""Issue"": ""Lack of Sanity Checks on `finishDepositStable` and `finishRedeemStable` parameters"",
        ""Severity"": ""Low"",
        ""Description"": ""The `finishDepositStable` and `finishRedeemStable` functions uses the `idx` parameter to access an element in the arrays, but doesn't validate that `idx` is a reasonable value. While the require statement `require(depositOperations.length > idx, \""not running\"");` will prevent array out of bounds reads, a sufficiently large value could consume a large amount of gas."",
        ""Impact"": ""Possible denial of service due to high gas consumption. Revert if array boundaries are crossed"",
        ""Location"": ""Function `finishDepositStable`, Function `finishRedeemStable`""
      }
  ],
  ""IssueNumber"": 40,
  ""OutputList"": 21
}",176.3281111717224,3051.0,29.0,"### **[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys**

**Report Description**:  
The current implementation requires trusted key holders (`isTrusted[msg.sender]`) to send transactions (`initRedeemStable()`) to initialize withdrawals from EthAnchor before users can withdraw funds from the contract. If these key holders lose access to their keys, funds could be frozen, leading to a centralization risk.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the centralization risk associated with trusted key holders losing access to their keys. This issue is entirely missed in the response list, and no corresponding vulnerability or mitigation is provided.

---

### **[M-05] Add a timelock to BaseStrategy:setPerfFeePct**

**Report Description**:  
To increase user trust, functions that set key/critical variables (e.g., `setPerfFeePct`) should be put behind a timelock. This ensures that users have time to react to changes in critical parameters.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running Vulnerability in `setPerfFeePct`""**.

**Validation**:  
**Partially Correct**. The response identifies a related issue with `setPerfFeePct`, specifically the potential for front-running. However, it does not address the core concern of adding a timelock to increase user trust and transparency. The response focuses on the risk of front-running but misses the broader security recommendation of implementing a timelock.

---

### **[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Report Description**:  
The `investedAssets()` function, implemented by the vault's strategy contracts, expresses a vault's investments in terms of the underlying currency. However, it does not account for the performance fee charged by the treasury, as shown in `finishRedeemStable()`. This oversight could lead to inaccurate accounting of investments.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Calculation of `originalUst` in `finishRedeemStable`""**.

**Validation**:  
**Partially Correct**. The response identifies an issue with the calculation of `originalUst` in `finishRedeemStable`, which is related to performance fees. However, it does not directly address the specific concern of `investedAssets()` failing to account for performance fees. The response is relevant but does not fully cover the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-05] Add a timelock to BaseStrategy:setPerfFeePct**  
- **[M-12] investedAssets() Does Not Take Into Consideration The Performance Fee Charged On Strategy Withdrawals**

**Missed Issues from Issue Report**:  
- **[M-03] Centralization Risk: Funds can be frozen when critical key holders lose access to their keys**

---

### **Overall Assessment**  
The response list partially addresses some of the issues but misses critical vulnerabilities like the centralization risk associated with trusted key holders. Additionally, the responses that do match are only partially correct, as they fail to fully address the core concerns raised in the issue report. Improvements are needed to ensure comprehensive coverage of all reported vulnerabilities.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at every rank is 0, and the average of these values is also 0."
