nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
NFTXMarketplaceZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    // Return extras.
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}

",5808,615,"[H-01] buyAndSwap1155WETH() function may cause loss of user assets

Submitted by cccz
In the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail
  [H-03] A vault can be locked from MarketplaceZap and StakingZap

Submitted by p4st13r4, also found by cmichel, GreyArt, hyh, jayjonah8, leastwood, pauliax, shenwilly, and WatchPug
Any user that owns a vToken of a particular vault can lock the functionalities of NFTXMarketplaceZap.sol and NFTXStakingZap.sol for everyone.
Every operation performed by the marketplace, that deals with vToken minting, performs this check:
require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");

A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace
  [M-01] Missing non reentrancy modifier

Submitted by robee
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..
  [M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to

function `buyAndSwap721WETH` 
https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L226-L249
  [M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address

Submitted by hyh
transferFromERC721(address assetAddr, uint256 tokenId, address to) should transfer from msg.sender to to. It transfers to address(this) instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is to).
  [M-12] buyAndSwap1155WETH Does Not Work As Intended

Submitted by leastwood
The `buyAndSwap1155WETH` function in NFTXMarketplaceZap aims to facilitate buying and swapping ERC1155 tokens within a single transaction. The function expects to transfer WETH tokens from the msg.sender account and use these tokens in purchasing vault tokens. However, the _buyVaultToken call in buyAndSwap1155WETH actually uses msg.value and not maxWethIn. As a result, the function will not work unless the user supplies both WETH and native ETH amounts, equivalent to the maxWethIn amount.
",6,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
  function balanceOf(address to) external view returns (uint256);
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXMarketplaceZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 constant BASE = 10**18;

  event Buy(uint256 count, uint256 ethSpent, address to);
  event Sell(uint256 count, uint256 ethReceived, address to);
  event Swap(uint256 count, uint256 ethSpent, address to);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function mintAndSell721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function mintAndSell721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);
    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);
    emit Sell(ids.length, amounts[1], to);
  }

  function buyAndSwap721(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap721WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (idsIn.length - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);
    _swap721(vaultId, idsIn, specificIds, to);

    emit Swap(idsIn.length, amounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndSwap1155(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    WETH.deposit{value: msg.value}();
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndSwap1155WETH(
    uint256 vaultId, 
    uint256[] memory idsIn, 
    uint256[] memory amounts, 
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(idsIn.length != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    uint256 count;
    for (uint256 i = 0; i < idsIn.length; i++) {
        uint256 amount = amounts[i];
        require(amount > 0, ""Transferring < 1"");
        count += amount;
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (
        vault.randomSwapFee() * (count - specificIds.length)
    );
    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);
    _swap1155(vaultId, idsIn, amounts, specificIds, to);

    emit Swap(count, swapAmounts[0], to);

    
    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function buyAndRedeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    address[] calldata path,
    address to
  ) public payable nonReentrant {
    require(to != address(0));
    require(amount != 0);
    WETH.deposit{value: msg.value}();
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.withdraw(remaining);
    (bool success, ) = payable(to).call{value: remaining}("""");
    require(success, ""Address: unable to send value, recipient may have reverted"");
  }

  function buyAndRedeemWETH(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds, 
    uint256 maxWethIn, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(amount != 0);
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (
        vault.randomRedeemFee() * (amount - specificIds.length)
    );
    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);
    _redeem(vaultId, amount, specificIds, to);

    emit Buy(amount, amounts[0], to);

    uint256 remaining = WETH.balanceOf(address(this));
    WETH.transfer(to, remaining);
  }

  function mintAndSell1155(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function mintAndSell1155WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minWethOut, 
    address[] calldata path,
    address to
  ) public nonReentrant {
    require(to != address(0));
    require(ids.length != 0);
    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);
    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);

    uint256 count;
    for (uint256 i = 0; i < ids.length; i++) {
        count += amounts[i];
    }
    emit Sell(count, amounts[1], to);
  }

  function _mint721(
    uint256 vaultId, 
    uint256[] memory ids
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE) - (count * INFTXVault(vault).mintFee()); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _swap721(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < idsIn.length; i++) {
      transferFromERC721(assetAddress, idsIn[i], vault);
      approveERC721(assetAddress, vault, idsIn[i]);
    }
    uint256[] memory emptyIds;
    INFTXVault(vault).swapTo(idsIn, emptyIds, idsOut, to);
    
    return (vault);
  }

  function _swap1155(
    uint256 vaultId, 
    uint256[] memory idsIn,
    uint256[] memory amounts,
    uint256[] memory idsOut,
    address to
  ) internal returns (address) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), idsIn, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    INFTXVault(vault).swapTo(idsIn, amounts, idsOut, to);
    
    return (vault);
  }

  function _redeem(
    uint256 vaultId, 
    uint256 amount,
    uint256[] memory specificIds,
    address to
  ) internal {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");
    INFTXVault(vault).redeemTo(amount, specificIds, to);
  }

  function _mint1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts
  ) internal returns (address, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE) - INFTXVault(vault).mintFee()*count;
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return (vault, balance);
  }

  function _buyVaultToken(
    address vault, 
    uint256 minTokenOut, 
    uint256 maxWethIn, 
    address[] calldata path
  ) internal returns (uint256[] memory) {
    uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(
      minTokenOut,
      maxWethIn,
      path, 
      address(this),
      block.timestamp
    );

    return amounts;
  }
  function _sellVaultTokenWETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForTokens(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function _sellVaultTokenETH(
    address vault, 
    uint256 minWethOut, 
    uint256 maxTokenIn, 
    address[] calldata path,
    address to
  ) internal returns (uint256[] memory) {
    IERC20Upgradeable(vault).approve(address(sushiRouter), maxTokenIn);
    uint256[] memory amounts = sushiRouter.swapExactTokensForETH(
      maxTokenIn,
      minWethOut,
      path, 
      to,
      block.timestamp
    );

    return amounts;
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }
}",4873,2,4,"{
  ""task_list"": [
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Verify that the `nonReentrant` modifier is correctly applied to all external-facing functions that modify state, including `mintAndSell721`, `mintAndSell721WETH`, `buyAndSwap721`, `buyAndSwap721WETH`, `buyAndSwap1155`, `buyAndSwap1155WETH`, `buyAndRedeem`, `buyAndRedeemWETH`, `mintAndSell1155`, and `mintAndSell1155WETH`."",
        ""Analyze the control flow within the `nonReentrant` functions to ensure there are no potential reentrancy vectors due to unexpected external calls or callbacks."",
        ""Specifically, analyze potential reentrancy issues when transferring WETH to the `to` address in the `buyAndSwap` and `buyAndSwap1155` functions, in case the recipient is a malicious contract.""
      ]
    },
    {
      ""Area"": ""Uniswap/SushiSwap Interaction and Slippage"",
      ""Tasks"": [
        ""Examine the `_buyVaultToken`, `_sellVaultTokenWETH`, and `_sellVaultTokenETH` functions to assess if sufficient slippage protection is implemented. Consider potential front-running attacks or sandwich attacks."",
        ""Evaluate the usage of `minWethOut` parameter in `_sellVaultTokenWETH` and `_sellVaultTokenETH` functions. Ensure proper handling of scenarios where the actual output is less than `minWethOut`. Check if the `amounts` array returned by the SushiRouter is properly validated."",
        ""Verify the `path` parameter validation in all functions that interact with the SushiSwap router to prevent malicious token swaps or unexpected behavior. Research common attack vectors related to the path parameter in AMMs."",
        ""Confirm that the `deadline` parameter (set to `block.timestamp`) passed to the SushiSwap router is acceptable. Consider potential issues with block timestamp manipulation or transaction delays."",
        ""Analyze the potential for front-running attacks when using `swapTokensForExactTokens` in the `_buyVaultToken` function. Specifically, an attacker could manipulate the price of the tokens in the path to their advantage.""
      ]
    },
    {
      ""Area"": ""ERC721/ERC1155 Transfers and Approvals"",
      ""Tasks"": [
        ""Thoroughly review the `transferFromERC721` function to ensure correct handling of ERC721 transfers, especially for CryptoKitties and CryptoPunks. Confirm that the correct transfer functions are called based on the `assetAddr`."",
        ""In the `transferFromERC721` function, investigate if the `buyPunk` call for CryptoPunks correctly handles the ETH transfer or if there is an oversight. Verify that the contract has sufficient ETH balance before calling `buyPunk`. Consider the case where the punk price changes between the user's intention and the transaction execution."",
        ""Verify the `approveERC721` function correctly handles approvals for different ERC721 contracts, including CryptoKitties and CryptoPunks. Ensure approvals are only given when necessary and to the correct addresses."",
        ""Check that ERC1155 tokens are safely transferred and approved in `_swap1155` and `_mint1155` functions using `safeBatchTransferFrom` and `setApprovalForAll`. Verify correct ownership and approval handling."",
        ""Confirm proper error handling in the `transferFromERC721` and `approveERC721` functions, particularly ensuring that the returned `resultData` from the `call` function is correctly parsed for error messages and propagated to the user.""
      ]
    },
    {
      ""Area"": ""Vault Interaction and Fee Handling"",
      ""Tasks"": [
        ""Analyze the `_mint721`, `_swap721`, `_swap1155`, `_redeem`, and `_mint1155` functions to ensure correct interaction with the NFTX vaults. Verify that the correct vault addresses are retrieved from the `nftxFactory`."",
        ""Validate the calculation of minting fees in `_mint721` and `_mint1155`. Ensure that the calculated balance matches the expected balance after minting."",
        ""Verify the calculation of `redeemFees` in `buyAndSwap721`, `buyAndSwap721WETH`, `buyAndSwap1155`, and `buyAndSwap1155WETH`. Ensure that the fees are correctly applied based on the number of specific and random IDs."",
        ""Ensure that the `totalFee` calculation in the `buyAndRedeem` and `buyAndRedeemWETH` functions is correct, considering both `targetRedeemFee` and `randomRedeemFee`."",
        ""Check for potential integer overflows or underflows in the fee calculations.""
      ]
    },
    {
      ""Area"": ""WETH Handling and ETH Transfers"",
      ""Tasks"": [
        ""Verify that WETH deposits (`WETH.deposit{value: msg.value}()`) are handled correctly in `buyAndSwap721`, `buyAndSwap1155` and `buyAndRedeem`. Confirm the deposited ETH amount matches the `msg.value`."",
        ""Analyze the WETH withdrawal and transfer logic in `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, `buyAndSwap721WETH`, `buyAndSwap1155WETH` and `buyAndRedeemWETH` functions to ensure that the correct amount of WETH is transferred to the intended recipient. Verify that the contract's WETH balance is handled as expected."",
        ""Assess the security implications of transferring the remaining WETH to the `to` address using `payable(to).call{value: remaining}("""")` in `buyAndSwap721`, `buyAndSwap1155`, and `buyAndRedeem`. Consider the case where `to` is a contract that does not implement a receive function, or a malicious contract. Implement a safer transfer mechanism (e.g. transfer/transferFrom).""
        ,""Ensure that WETH is properly approved for spending by the sushiRouter using `IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);`""
      ]
    },
    {
      ""Area"": ""Ownership and Access Control"",
      ""Tasks"": [
        ""Verify that the `Ownable` contract is correctly implemented and that only the owner can perform administrative tasks."",
        ""Ensure that there are no missing `onlyOwner` modifiers on sensitive functions that should be restricted to the owner.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Review the code for potential gas inefficiencies, such as redundant calculations or unnecessary storage writes."",
        ""Consider using more gas-efficient data structures or algorithms where appropriate."",
        ""Analyze loop structures (e.g., in `_mint721`, `_swap721`, `_mint1155`) for potential gas optimizations.""
      ]
    },
    {
      ""Area"": ""Event Emission and Logging"",
      ""Tasks"": [
        ""Ensure that all relevant state changes are logged using events."",
        ""Verify that the events `Buy`, `Sell`, and `Swap` emit all necessary information, including the vault token amount in addition to the `ethSpent`/`ethReceived` amounts. This provides a more complete audit trail."",
         ""Consider indexing event parameters for more efficient querying of historical data.""
      ]
    },
    {
      ""Area"": ""Unused Imports"",
      ""Tasks"": [
        ""Remove the unused import `ITimelockRewardDistributionToken` to reduce contract size and deployment costs.""
      ]
    },
    {
      ""Area"": ""Input Validation"",
      ""Tasks"": [
        ""Review all public and internal functions for sufficient input validation, including checks for zero addresses, empty arrays, and valid ranges."",
        ""In the `buyAndSwap` and `buyAndRedeem` functions, verify that `msg.value` is sufficient for buying the specified amounts of vault tokens and covering fees. Otherwise the transaction will revert in the `_buyVaultToken` function."",
        ""In the `buyAndSwapWETH` and `buyAndRedeemWETH` functions, ensure that `maxWethIn` is sufficient for the intended purchase, but not excessively large to avoid potential griefing attacks.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `NFTXMarketplaceZap` is designed to facilitate swaps and purchases within the NFTX ecosystem. It allows users to mint and sell, buy and swap, and buy and redeem NFTs in conjunction with vault tokens, often utilizing WETH. The contract leverages external contracts like NFTXVaultFactory, INFTXLPStaking, and IUniswapV2Router01 (SushiSwap) to perform these actions. It implements reentrancy protection and ownership control."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXMarketplaceZap"",
    ""Purpose"": ""Facilitates NFTX vault token swaps and redemptions using ETH/WETH."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ReentrancyGuard"", ""ERC721HolderUpgradeable"", ""ERC1155HolderUpgradeable""],
      ""Imports"": [
        ""./interface/INFTXVault.sol"",
        ""./interface/INFTXVaultFactory.sol"",
        ""./interface/INFTXFeeDistributor.sol"",
        ""./interface/INFTXLPStaking.sol"",
        ""./interface/ITimelockRewardDistributionToken.sol"",
        ""./interface/IUniswapV2Router01.sol"",
        ""./testing/IERC721.sol"",
        ""./token/IERC1155Upgradeable.sol"",
        ""./token/IERC20Upgradeable.sol"",
        ""./token/ERC721HolderUpgradeable.sol"",
        ""./token/ERC1155HolderUpgradeable.sol"",
        ""./util/OwnableUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""WETH"",
        ""Type"": ""IWETH"",
        ""Purpose"": ""Address of the Wrapped Ether contract.""
      },
      {
        ""Name"": ""lpStaking"",
        ""Type"": ""INFTXLPStaking"",
        ""Purpose"": ""Address of the NFTX LP Staking contract, retrieved from the fee distributor.""
      },
      {
        ""Name"": ""nftxFactory"",
        ""Type"": ""INFTXVaultFactory"",
        ""Purpose"": ""Address of the NFTX Vault Factory contract.""
      },
      {
        ""Name"": ""sushiRouter"",
        ""Type"": ""IUniswapV2Router01"",
        ""Purpose"": ""Address of the SushiSwap Router contract.""
      },
      {
        ""Name"": ""BASE"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Represents 10**18, likely used for calculations involving token amounts.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the NFTX Factory and SushiSwap Router addresses. Approves the SushiRouter to spend the WETH."",
        ""Parameters"": [""address _nftxFactory"", ""address _sushiRouter""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintAndSell721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mints ERC721 tokens into a vault and sells the resulting vault tokens for ETH."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethOut"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintAndSell721WETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mints ERC721 tokens into a vault and sells the resulting vault tokens for WETH."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethOut"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndSwap721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buys vault tokens with ETH and swaps them for specific ERC721 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory idsIn"", ""uint256[] memory specificIds"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndSwap721WETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buys vault tokens with WETH and swaps them for specific ERC721 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory idsIn"", ""uint256[] memory specificIds"", ""uint256 maxWethIn"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndSwap1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buys vault tokens with ETH and swaps them for specific ERC1155 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory idsIn"", ""uint256[] memory amounts"", ""uint256[] memory specificIds"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndSwap1155WETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buys vault tokens with WETH and swaps them for specific ERC1155 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory idsIn"", ""uint256[] memory amounts"", ""uint256[] memory specificIds"", ""uint256 maxWethIn"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndRedeem"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buys vault tokens with ETH and redeems them for specific ERC721 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256 amount"", ""uint256[] memory specificIds"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""buyAndRedeemWETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Buys vault tokens with WETH and redeems them for specific ERC721 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256 amount"", ""uint256[] memory specificIds"", ""uint256 maxWethIn"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintAndSell1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mints ERC1155 tokens into a vault and sells the resulting vault tokens for ETH."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minWethOut"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""mintAndSell1155WETH"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Mints ERC1155 tokens into a vault and sells the resulting vault tokens for WETH."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minWethOut"", ""address[] calldata path"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""_mint721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers ERC721 tokens to the vault and mints vault tokens."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids""],
        ""Returns"": [""address"", ""uint256""]
      },
      {
        ""Name"": ""_swap721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swaps vault tokens for ERC721 tokens."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory idsIn"", ""uint256[] memory idsOut"", ""address to""],
        ""Returns"": [""address""]
      },
       {
        ""Name"": ""_swap1155"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swaps vault tokens for ERC1155 tokens."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory idsIn"", ""uint256[] memory amounts"", ""uint256[] memory idsOut"", ""address to""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""_redeem"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Redeems vault tokens for specific ERC721 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256 amount"", ""uint256[] memory specificIds"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""_mint1155"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers ERC1155 tokens to the vault and mints vault tokens."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts""],
        ""Returns"": [""address"", ""uint256""]
      },
      {
        ""Name"": ""_buyVaultToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swaps ETH/WETH for vault tokens using the SushiSwap router."",
        ""Parameters"": [""address vault"", ""uint256 minTokenOut"", ""uint256 maxWethIn"", ""address[] calldata path""],
        ""Returns"": [""uint256[] memory""]
      },
      {
        ""Name"": ""_sellVaultTokenWETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swaps vault tokens for WETH using the SushiSwap router."",
        ""Parameters"": [""address vault"", ""uint256 minWethOut"", ""uint256 maxTokenIn"", ""address[] calldata path"", ""address to""],
        ""Returns"": [""uint256[] memory""]
      },
       {
        ""Name"": ""_sellVaultTokenETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Swaps vault tokens for ETH using the SushiSwap router."",
        ""Parameters"": [""address vault"", ""uint256 minWethOut"", ""uint256 maxTokenIn"", ""address[] calldata path"", ""address to""],
        ""Returns"": [""uint256[] memory""]
      },
      {
        ""Name"": ""transferFromERC721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Transfers ERC721 tokens, handling CryptoKitties and CryptoPunks special cases."",
        ""Parameters"": [""address assetAddr"", ""uint256 tokenId"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveERC721"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Approves ERC721 tokens, handling CryptoKitties and CryptoPunks special cases."",
        ""Parameters"": [""address assetAddr"", ""address to"", ""uint256 tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""pairFor"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Calculates the pair address for two tokens on Uniswap V2."",
        ""Parameters"": [""address tokenA"", ""address tokenB""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""sortTokens"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sorts two token addresses to determine token0 and token1 for Uniswap V2 pair calculation."",
        ""Parameters"": [""address tokenA"", ""address tokenB""],
        ""Returns"": [""address"", ""address""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the contract to receive ETH."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""nonReentrant"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Prevents reentrant calls."",
        ""Parameters"": [],
        ""Returns"": []
      },
       {
        ""Name"": ""onlyOwner"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to the owner of the contract."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IWETH (Wrapped Ether Contract)"",
    ""INFTXVaultFactory (NFTX Vault Factory)"",
    ""INFTXFeeDistributor (NFTX Fee Distributor)"",
    ""INFTXLPStaking (NFTX LP Staking)"",
    ""IUniswapV2Router01 (SushiSwap Router)"",
    ""IERC721 (ERC721 Interface)"",
    ""IERC1155Upgradeable (ERC1155 Interface)"",
    ""IERC20Upgradeable (ERC20 Interface)"",
    ""Calls to specific NFT contracts (CryptoKitties, CryptoPunks)""
  ],
  ""SpecialMechanisms"": [
    ""Reentrancy Guard Pattern: Prevents reentrant calls to the contract."",
    ""Ownable Pattern: Restricts certain functions to the owner."",
    ""Special handling for CryptoKitties and CryptoPunks ERC721 transfers and approvals."",
    ""Uses SushiSwap (IUniswapV2Router01) for swapping tokens."",
    ""Vault token redemption and swapping for NFTs""
  ],
  ""Questions"": [
    ""Why is `ITimelockRewardDistributionToken` imported but not used?"",
    ""In the `transferFromERC721` function, the `buyPunk` call for CryptoPunks doesn't seem to handle the ETH transfer. Is the assumption that the contract already holds enough ETH for the purchase, or is there an oversight?"",
    ""Should there be slippage protection in the swap functions (e.g., `_sellVaultTokenETH`, `_buyVaultToken`) beyond the `minWethOut` parameter? What happens if the actual output is less than `minWethOut`?"",
    ""How are the `path` parameters validated to prevent front-running or malicious token swaps?"",
    ""The events `Buy`, `Sell`, and `Swap` only emit the `ethSpent`/`ethReceived` amounts. Is it necessary to also emit the vault token amount to have complete information about trades?"",
    ""In the `buyAndSwap` functions, is the transfer of the remaining WETH to the `to` address vulnerable if `to` is a contract that does not implement a receive function?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `buyAndSwap721`, `buyAndSwap1155` and `buyAndRedeem`"",
      ""Severity"": ""High"",
      ""Description"": ""The functions `buyAndSwap721`, `buyAndSwap1155`, and `buyAndRedeem` withdraw WETH and send it to the recipient `to` using a `call` with value. A malicious recipient could potentially re-enter the contract, exploiting the state after the WETH withdrawal but before the intended logic completes, leading to unexpected behavior or theft of funds. This vulnerability exists because the `nonReentrant` modifier's scope ends before the external call, or because of missing checks on transfer success. The `_status` is reset after the internal logic completes, which makes the reentry possible in the external call where WETH is transferred."",
      ""Impact"": ""The contract's state can be manipulated by a malicious recipient during the WETH transfer, potentially leading to incorrect accounting, theft of funds, or denial of service."",
      ""Location"": ""NFTXMarketplaceZap.sol: buyAndSwap721, NFTXMarketplaceZap.sol: buyAndSwap1155, NFTXMarketplaceZap.sol: buyAndRedeem""
    },
    {
      ""Issue"": ""Missing Approval Check for ERC1155 Transfers in `_swap1155`"",
      ""Severity"": ""High"",
      ""Description"": ""The `_swap1155` function relies on `safeBatchTransferFrom` without verifying if the `msg.sender` has approved the marketplace to transfer their ERC1155 tokens. This can lead to transaction failures and potential loss of funds if the user hasn't approved the marketplace.  It is best to ensure users have approved the marketplace before transferring any tokens."",
      ""Impact"": ""Transaction failures and potential loss of funds if user has not approved marketplace."",
      ""Location"": ""_swap1155""
    },
    {
      ""Issue"": ""Unprotected `transferFromERC721` and `approveERC721` Functions"",
      ""Severity"": ""High"",
      ""Description"": ""The `transferFromERC721` and `approveERC721` functions contain hardcoded addresses and handle specific ERC721 contracts (CryptoKitties and CryptoPunks) differently without proper checks. There's no check to ensure `msg.sender` is actually the owner of the NFT before calling the `transferFrom` or approval functions, which allows potential abuse. The code relies on hardcoded addresses for identifying these contracts and uses `call` with raw bytes, which could be bypassed if the target contract’s interface changes."",
      ""Impact"": ""Unauthorized transfer or approval of NFTs, potentially leading to loss of assets."",
      ""Location"": ""NFTXMarketplaceZap.sol:transferFromERC721, NFTXMarketplaceZap.sol:approveERC721""
    },
    {
      ""Issue"": ""Lack of slippage protection on token swaps"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_sellVaultTokenWETH`, `_sellVaultTokenETH` and `_buyVaultToken` functions use `sushiRouter.swapExactTokensForTokens`, `sushiRouter.swapExactTokensForETH` and `sushiRouter.swapTokensForExactTokens` without incorporating sufficient slippage protection. This means the user might receive significantly fewer tokens than expected due to price fluctuations during the transaction. While `swapTokensForExactTokens` take `maxWethIn` as input, other functions take `minWethOut` as input and don't have an option to specify maximum token in or minimum tokens out that the user is willing to accept, potentially resulting in unexpected high slippage and loss of funds for the user."",
      ""Impact"": ""Users may experience significant losses due to unfavorable price slippage when executing swaps, potentially leading to loss of funds."",
      ""Location"": ""Functions `_sellVaultTokenWETH`, `_sellVaultTokenETH` and `_buyVaultToken`.""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `buyAndRedeem` and Related Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `buyAndRedeem`, `buyAndSwap721` and related functions that receive ether, use `WETH.deposit{value: msg.value}()` and then perform several operations based on the current state of the NFTX vaults and the AMM pools. A front-runner could observe the transaction and manipulate the price of the underlying assets or the vault tokens before the original transaction is executed, causing the user to either pay more than expected or have the transaction revert."",
      ""Impact"": ""Users may pay more than expected for the NFTs or have their transaction revert due to price manipulation by front-runners."",
      ""Location"": ""Functions `buyAndRedeem`, `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, `buyAndSwap721WETH`, `buyAndSwap1155WETH`, `buyAndRedeemWETH`""
    },
    {
      ""Issue"": ""Missing Input Validation in `buyAndSwap1155WETH` and `buyAndSwap1155` functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `buyAndSwap1155WETH` and `buyAndSwap1155` accept an array of `amounts` and `idsIn`. There are no checks for length consistency between `amounts` and `idsIn`, or to ensure that `msg.value` or `maxWethIn` is sufficient to cover the cost of the tokens based on the `amounts` and the current token price. An attacker could craft an array `amounts` such that the fees are calculated, but the actual value passed is not sufficient to purchase the required tokens, potentially causing the swap to revert after token transfers have occurred."",
      ""Impact"": ""Possible denial of service (reverted transactions) or unexpected behavior if the value provided doesn't cover the calculated fees. Incorrect token transfers or transaction failures if input array lengths do not match. It may result in tokens being stuck in the contract or incorrect swap amounts."",
      ""Location"": ""`buyAndSwap1155WETH` function, `buyAndSwap1155` function""
    },
    {
      ""Issue"": ""Inconsistent handling of `msg.value` in buy functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `buyAndRedeem`, `buyAndSwap721` and `buyAndSwap1155` functions all use `msg.value` to deposit WETH but do not always check if the `msg.value` is sufficient for the intended purchase. This can cause the transaction to revert if the value is insufficient, leading to a poor user experience. It is not clear that the user understands that the `msg.value` is being used to buy WETH that will then be used in a swap."",
      ""Impact"": ""Transaction failures and a frustrating user experience."",
      ""Location"": ""buyAndRedeem, buyAndSwap721, buyAndSwap1155""
    },
    {
      ""Issue"": ""Incorrect Calculation of Redeem Fees"",
      ""Severity"": ""Medium"",
      ""Description"": ""The redeem fees calculation in `buyAndRedeem` and `buyAndRedeemWETH` is flawed. The code calculates `(vault.targetRedeemFee() * specificIds.length) + (vault.randomRedeemFee() * (amount - specificIds.length))`. This only considers the *number* of `specificIds`, but not the *amount* for each ID when redeeming 1155 tokens. This could cause discrepancies with the expected calculation."",
      ""Impact"": ""Potentially incorrect fee calculation, leading to unexpected costs or refunds."",
      ""Location"": ""`buyAndRedeem`, `buyAndRedeemWETH`.""
    },
    {
      ""Issue"": ""Missing Input Validation for Array Lengths in `buyAndSwap721` and Related Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, `buyAndSwap721WETH`, `buyAndSwap1155WETH`, `buyAndRedeemWETH` functions do not validate that the lengths of the `idsIn`, `amounts`, `specificIds` arrays are consistent and appropriate for the operations being performed. Specifically, the `specificIds` array should be shorter or equal in length to `idsIn`, and `amounts` needs to match `idsIn` in `_swap1155` functions."",
      ""Impact"": ""Potential for denial of service (DoS) if array lengths are inconsistent, or unexpected behavior in token transfers, potentially leading to loss of funds or incorrect NFT ownership."",
      ""Location"": ""Functions `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, `buyAndSwap721WETH`, `buyAndSwap1155WETH`, `buyAndRedeemWETH`. The core issue arises in how these functions pass parameters to `_swap721`, `_swap1155`, and `_redeem` without proper length validation.""
    },
    {
      ""Issue"": ""Incorrect Calculation of Balance After Minting in `_mint721` and `_mint1155`"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_mint721` and `_mint1155` functions, the contract calculates the expected balance of Vault tokens received after minting. However, the calculation uses `(count * BASE) - (count * INFTXVault(vault).mintFee())` which can potentially lead to front running if the `mintFee` is changed during the transaction.  The Vault's mintFee may have changed between when the function was called and when the balance is checked."",
      ""Impact"": ""The minting process could fail due to unexpected balance checks if the Vault's mintFee is modified."",
      ""Location"": ""NFTXMarketplaceZap.sol:_mint721, NFTXMarketplaceZap.sol:_mint1155""
    },
    {
      ""Issue"": ""Hardcoded Addresses for CryptoKitties and CryptoPunks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferFromERC721` and `approveERC721` functions contain hardcoded addresses for CryptoKitties and CryptoPunks. This makes the contract inflexible and difficult to update if these addresses change. These addresses should be configurable, perhaps through constructor arguments or setter functions."",
      ""Impact"": ""Reduced flexibility and maintainability."",
      ""Location"": ""transferFromERC721, approveERC721""
    },
        {
      ""Issue"": ""Missing Access Control for `transferFromERC721` and `approveERC721` when dealing with standard ERC721 tokens."",
      ""Severity"": ""Medium"",
      ""Description"": ""For standard ERC721 tokens, `transferFromERC721` executes `safeTransferFrom(address,address,uint256)` using the caller's address (`msg.sender`). Similarly, `approveERC721` does not have any access control when dealing with standard ERC721 tokens, since the function simply returns. There is no check to confirm that the `msg.sender` owns the NFT being transferred."",
      ""Impact"": ""Unauthorized transfer of ERC721 tokens and non-functional minting of NFTs if the user doesn't call `setApprovalForAll` beforehand."",
      ""Location"": ""`transferFromERC721`, `approveERC721` functions""
    },
    {
      ""Issue"": ""Lack of Input Validation for `vaultId` leading to potential denial of service or unexpected behavior"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `vaultId` without proper validation to fetch the vault address from `nftxFactory.vault(vaultId)`. If a large or invalid `vaultId` is provided, it could cause the factory to revert, leading to a denial of service, or return address(0), leading to calls to zero address, and unexpected behaviors, or potentially even exploits. It depends on how `nftxFactory.vault` is implemented."",
      ""Impact"": ""A malicious user could cause a denial of service by providing a large `vaultId`, or unexpected behavior by providing an invalid ID."",
      ""Location"": ""NFTXMarketplaceZap.sol: mintAndSell721, NFTXMarketplaceZap.sol: mintAndSell721WETH, NFTXMarketplaceZap.sol: buyAndSwap721, NFTXMarketplaceZap.sol: buyAndSwap721WETH, NFTXMarketplaceZap.sol: buyAndSwap1155, NFTXMarketplaceZap.sol: buyAndSwap1155WETH, NFTXMarketplaceZap.sol: buyAndRedeem, NFTXMarketplaceZap.sol: buyAndRedeemWETH, NFTXMarketplaceZap.sol: mintAndSell1155, NFTXMarketplaceZap.sol: mintAndSell1155WETH, _mint721, _swap721, _swap1155, _redeem, _mint1155""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In functions `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, the redeem fees are calculated involving multiplication of fee percentages with `specificIds.length` or `idsIn.length` or similar variations. Also in `buyAndRedeemWETH` and `buyAndRedeem` the calculation `(amount*BASE) + totalFee` could potentially lead to an integer overflow if `amount` is sufficiently large. If `specificIds.length` or `idsIn.length` are sufficiently large, and `vault.targetSwapFee()` or `vault.randomSwapFee()` are also large, the multiplication can result in an integer overflow. It is good practice to explicitly check for potential overflows, especially when dealing with user-provided inputs."",
      ""Impact"": ""Incorrect fee calculation which can lead to loss of funds or the contract reverting due to insufficient payment. Unexpected behavior, potential loss of funds due to incorrect swap execution."",
      ""Location"": ""Functions `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`, `buyAndSwap721WETH`, `buyAndSwap1155WETH`, `buyAndRedeemWETH`""
    },
    {
      ""Issue"": ""Inconsistent WETH handling"",
      ""Severity"": ""Low"",
      ""Description"": ""Several functions first deposit ETH to WETH and then withdraw the remaining WETH to transfer to a user. Instead of depositing, performing operations and then withdrawing the remaining WETH, the transaction could simply check to see if the `msg.value` is enough, then transfer that to the user without depositing it into WETH. In `buyAndSwap721` and `buyAndSwap1155`, the remaining WETH is withdrawn and then directly transferred to the `to` address using `call`. This works well for ETH. However, the corresponding `buyAndSwap721WETH` and `buyAndSwap1155WETH` withdraw the remaining WETH and then transfer it directly using `WETH.transfer`. This discrepancy could introduce subtle differences in how the contract interacts with different recipients."",
      ""Impact"": ""The transaction will fail more often, as the user needs to pay the additional gas fees of depositing, withdrawing and the additional transfers"",
      ""Location"": ""Functions `buyAndSwap721`, `buyAndSwap1155`, `buyAndRedeem`""
    },
    {
      ""Issue"": ""Missing input validation for `path` array lengths"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions accept a `path` array as input for the SushiSwap router. The contract contains no checks on the length or content of this `path` array, meaning users can pass empty paths or very large paths. This would probably revert in the `sushiRouter` contract, a length check could be added to fail fast."",
      ""Impact"": ""The contract execution might fail in the `sushiRouter` due to an invalid path, potentially wasting gas. If the `sushiRouter` is exploited to allow arbitrary paths, this could result in loss of funds"",
      ""Location"": ""NFTXMarketplaceZap.sol: Lines 60, 71, 83, 99, 117, 134, 159, 190, 206""
    },
    {
      ""Issue"": ""Unnecessary `approve` Calls in `_mint721` and `_mint1155`"",
      ""Severity"": ""Low"",
      ""Description"": ""In both `_mint721` and `_mint1155` after transferring the assets to the vault, the contract calls `approveERC721(assetAddress, vault, ids[i])` and `IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true)`. It seems like these calls are unnecessary. After the `transferFrom` operation, the contract already owns the assets, and approval for the vault is not required for minting, potentially wasting gas."",
      ""Impact"": ""Unnecessary gas consumption due to redundant `approve` calls."",
      ""Location"": ""_mint721, _mint1155 functions""
    },
    {
      ""Issue"": ""Approve to router for max amount"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract approves the `sushiRouter` for `type(uint256).max` for WETH. This is acceptable, but could potentially lead to issues if the router is compromised at some future point."",
      ""Impact"": ""A compromised router could potentially drain the contract's WETH balance."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Missing input validation in `mintAndSell1155` and `mintAndSell1155WETH`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the functions `mintAndSell1155` and `mintAndSell1155WETH`, the count of items sold is calculated after the `_sellVaultTokenETH` or `_sellVaultTokenWETH` function is called. If the sell function reverts due to an error in the token swap (e.g., insufficient liquidity, slippage tolerance exceeded), the `count` variable will not be updated."",
      ""Impact"": ""Inaccurate event logs."",
      ""Location"": ""mintAndSell1155, mintAndSell1155WETH""
    },
    {
      ""Issue"": ""Missing Check for Zero Address in Constructor"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor takes `_nftxFactory` and `_sushiRouter` as input, but it doesn't validate that these addresses are not zero addresses. If a zero address is passed, the contract might behave unexpectedly and become unusable since most of the operations depend on these addresses."",
      ""Impact"": ""Contract can be initialized with invalid addresses, making it unusable or causing unexpected behavior."",
      ""Location"": ""Constructor""
    }
  ],
  ""IssueNumber"": 63,
  ""OutputList"": 16
}",222.4667570590973,5156.0,32.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] buyAndSwap1155WETH() function may cause loss of user assets**

**Report Description**:  
The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap.sol` uses the WETH provided by the user to exchange VaultToken. However, when executing the `_buyVaultToken` method, `msg.value` is used instead of `maxWethIn`. Since `msg.value` is 0, the call will fail, potentially causing loss of user assets.

**Match in Response List**:  
Matches with the issue titled **""Inconsistent handling of `msg.value` in buy functions""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with inconsistent handling of `msg.value` in the `buyAndSwap1155WETH` function. It correctly explains the risks associated with using `msg.value` instead of `maxWethIn`, which aligns with the issue report.

---

#### **[H-03] A vault can be locked from MarketplaceZap and StakingZap**

**Report Description**:  
Any user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone. This is due to a balance check that requires `balance == IERC20Upgradeable(vault).balanceOf(address(this))`. A malicious user could transfer any amount > 0 of a vault’s vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability described in the issue report is significant and should have been covered, as it allows a malicious user to lock the functionality of the marketplace and staking contracts.

---

#### **[M-01] Missing non reentrancy modifier**

**Report Description**:  
Several functions are missing the `nonReentrant` modifier, although other public/external functions use it. While no direct exploit was found, the absence of the modifier in these functions could potentially lead to reentrancy attacks.

**Match in Response List**:  
Matches with the issue titled **""Potential Reentrancy Vulnerability in `buyAndSwap721`, `buyAndSwap1155` and `buyAndRedeem`""**.

**Validation**:  
**Partially Correct**. The response identifies the reentrancy issue but focuses on specific functions (`buyAndSwap721`, `buyAndSwap1155`, and `buyAndRedeem`). The issue report is broader, mentioning that several functions are missing the `nonReentrant` modifier, not just the ones listed in the response.

---

#### **[M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to**

**Report Description**:  
The `buyAndSwap721WETH` function should return unused WETH/ETH back to `msg.sender` instead of `to`. This could lead to confusion or loss of funds if the `to` address is not the same as `msg.sender`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The issue report highlights a potential user experience problem and a risk of funds being sent to the wrong address, which should have been covered.

---

#### **[M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address**

**Report Description**:  
The `transferFromERC721` function should transfer Cryptokitties from `msg.sender` to `to`. However, it transfers them to `address(this)` instead, leading to incorrect NFT accounting and potential loss of assets.

**Match in Response List**:  
Matches with the issue titled **""Unprotected `transferFromERC721` and `approveERC721` Functions""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `transferFromERC721` function, specifically mentioning the incorrect handling of Cryptokitties. This aligns with the issue report.

---

#### **[M-12] buyAndSwap1155WETH Does Not Work As Intended**

**Report Description**:  
The `buyAndSwap1155WETH` function expects to transfer WETH tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` uses `msg.value` instead of `maxWethIn`, causing the function to fail unless the user supplies both WETH and native ETH.

**Match in Response List**:  
Matches with the issue titled **""Missing Input Validation in `buyAndSwap1155WETH` and `buyAndSwap1155` functions""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with `buyAndSwap1155WETH` but focuses on input validation rather than the core problem of using `msg.value` instead of `maxWethIn`. The issue report is more specific about the root cause.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] buyAndSwap1155WETH() function may cause loss of user assets**
- **[M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address**

**Partially Correct Matches**:

- **[M-01] Missing non reentrancy modifier**
- **[M-12] buyAndSwap1155WETH Does Not Work As Intended**

**Missed Issues from Issue Report**:

- **[H-03] A vault can be locked from MarketplaceZap and StakingZap**
- **[M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to**

--- 

The response list covers some issues accurately but misses critical vulnerabilities like the vault locking issue and the incorrect handling of unused WETH/ETH. Additionally, some responses are partially correct, identifying the issue but missing key details or focusing on different aspects of the problem.","```
1. Inconsistent handling of `msg.value` in buy functions
2. Unprotected `transferFromERC721` and `approveERC721` Functions
```","To calculate the **Average Precision (AP)**, we follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Inconsistent handling of `msg.value` in buy functions"" appears at rank 7.
   - ""Unprotected `transferFromERC721` and `approveERC721` Functions"" appears at rank 3.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)
   - For rank 7: \( P@7 = \frac{2}{7} \approx 0.286 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.333 + 0.286}{2} \approx 0.3095
   \]

**Average Precision (AP)**: 0.3095"
NFTXSimpleFeeDistributor.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  // Total allocation points per vault. 
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      // If the receive is not properly processed, send it to the treasury instead.
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      // If the allowance has not been spent, it means we can pass it forward to next.
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
} 
",1672,172,"[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees

Submitted by cccz, also found by WatchPug
In the NFTXSimpleFeeDistributor.sol contract, the `distribute` function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.
function distribute(uint256 vaultId) external override virtual nonReentrant {
  require(nftxVaultFactory != address(0));
  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

  if (distributionPaused || allocTotal == 0) {
    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
    return;
  }

  uint256 length = feeReceivers.length;
  uint256 leftover;
  for (uint256 i = 0; i <length; i++) {
    FeeReceiver memory _feeReceiver = feeReceivers[i];
    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
    amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;
    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
    if (!complete) {
      leftover = amountToSend;
    } else {
      leftover = 0;
    }
  }

In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.
  [M-01] Missing non reentrancy modifier

Submitted by robee
The following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..

[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver

Submitted by GreyArt
The addReceiver() function fails to check if the _receiver already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.
The receiver would receive more than expected (until the duplicate entry has been removed).
   [M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract

Submitted by hyh
Double spending of fees being distributed will happen in favor of the first fee receivers in the feeReceivers list at the expense of the last ones. As _sendForReceiver doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.
  [M-14] Return variable can remain unassigned in _sendForReceiver

Submitted by sirhashalot, also found by pauliax
The _sendForReceiver() function only sets a return function in the ""if"" code block, not the ""else"" case. If the ""else"" case is true, no value is returned. The result of this oversight is that the _sendForReceiver() function called from the distribute() function could sucessfully enter its else block if a receiver has isContract set to False and successfully transfer the amountToSend value. The ditribute() function will then have leftover > 0 and send currentTokenBalance to the treasury. This issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.
This problem currently occurs for any receiver with isContract set to False. The _addReceiver function allows for isContract to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.
   [M-16] Malicious receiver can make `distribute` function denial of service
`distribute` function 
In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee
",6,,"pragma solidity ^0.8.0;

import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./util/SafeERC20Upgradeable.sol"";
import ""./util/SafeMathUpgradeable.sol"";
import ""./util/PausableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";

contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable {
  using SafeERC20Upgradeable for IERC20Upgradeable;

  bool public distributionPaused;

  address public override nftxVaultFactory;
  address public override lpStaking;
  address public override treasury;

  
  uint256 public override allocTotal;
  FeeReceiver[] public feeReceivers;

  address public override inventoryStaking;

  event UpdateTreasuryAddress(address newTreasury);
  event UpdateLPStakingAddress(address newLPStaking);
  event UpdateInventoryStakingAddress(address newInventoryStaking);
  event UpdateNFTXVaultFactory(address factory);
  event PauseDistribution(bool paused); 

  event AddFeeReceiver(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAlloc(address receiver, uint256 allocPoint);
  event UpdateFeeReceiverAddress(address oldReceiver, address newReceiver);
  event RemoveFeeReceiver(address receiver);
  
  function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

  function distribute(uint256 vaultId) external override virtual nonReentrant {
    require(nftxVaultFactory != address(0));
    address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);

    uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));

    if (distributionPaused || allocTotal == 0) {
      IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);
      return;
    } 

    uint256 length = feeReceivers.length;
    uint256 leftover;
    for (uint256 i = 0; i < length; i++) {
      FeeReceiver memory _feeReceiver = feeReceivers[i];
      uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      amountToSend = amountToSend > currentTokenBalance ? currentTokenBalance : amountToSend;
      bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);
      if (!complete) {
        leftover = amountToSend;
      } else {
        leftover = 0;
      }
    }

    if (leftover > 0) {
      uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));
      IERC20Upgradeable(_vault).safeTransfer(treasury, currentTokenBalance);
    }
  }

  function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

  function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

  function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

  function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

  function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

  function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

  function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

  function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

  function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

  function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

  function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }

  function _addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) internal virtual {
    FeeReceiver memory _feeReceiver = FeeReceiver(_allocPoint, _receiver, _isContract);
    feeReceivers.push(_feeReceiver);
    allocTotal += _allocPoint;
    emit AddFeeReceiver(_receiver, _allocPoint);
  }

  function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {
    if (_receiver.isContract) {
      IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);
      
       
      bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);
      (bool success, ) = address(_receiver.receiver).call(payload);

      
      return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;
    } else {
      IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);
    }
  }
}",1605,1,5,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the contract owner can call the following functions: `addReceiver`, `changeReceiverAlloc`, `changeReceiverAddress`, `removeReceiver`, `setTreasuryAddress`, `setLPStakingAddress`, `setInventoryStakingAddress`, `setNFTXVaultFactory`, `pauseFeeDistribution`, and `rescueTokens`."",
        ""Confirm that the `onlyOwner` modifier is correctly implemented and inherited from the `OwnableUpgradeable` contract."",
        ""Verify that `initializeVaultReceivers` can only be called by `nftxVaultFactory`."",
        ""Ensure that there are no unintended ways to modify the state variables related to access control (owner address).""
      ]
    },
    {
      ""Area"": ""Fee Distribution Logic"",
      ""Tasks"": [
        ""Analyze the `distribute` function to ensure accurate fee distribution based on `allocPoint` values and `allocTotal`."",
        ""Verify that the `allocTotal` is correctly updated when adding, removing, or changing receiver allocations."",
        ""Investigate potential rounding errors in the fee distribution calculation within the `distribute` function. Does the `leftover` handling sufficiently address this, and does the treasury receive all dust?"",
        ""Check for potential integer overflow/underflow issues in the allocation calculations, especially when dealing with large numbers."",
        ""Simulate scenarios with different `allocPoint` configurations and token balances to confirm correct distribution behavior."",
        ""Verify that distribution pauses when `distributionPaused` is true and the remaining balance is transferred to `treasury`."",
        ""Confirm that `distribute` function will transfer all available balances to treasury, if `allocTotal` is zero.""
      ]
    },
    {
      ""Area"": ""External Interactions"",
      ""Tasks"": [
        ""Scrutinize the `_sendForReceiver` function to ensure secure interaction with external contracts, paying close attention to the `isContract` flag."",
        ""Analyze the approval and transfer logic in `_sendForReceiver` for potential vulnerabilities (e.g., race conditions, incorrect allowance management)."",
        ""Investigate why `IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0` is checked in the `_sendForReceiver` function and what implications this has for external contracts."",
        ""Ensure the hardcoded selector `INFTXLPStaking.receiveRewards.selector` is correct and that changes to the interface will be caught and updated."",
        ""Verify that `INFTXLPStaking(lpStaking).addPoolForVault(_vaultId)` and `INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId)` are functioning as expected when called from `initializeVaultReceivers`."",
        ""Check the implementation of the external calls performed in `_sendForReceiver` and `initializeVaultReceivers` for potential reentrancy issues despite the `nonReentrant` modifier on `distribute`.  The external call is to a separate contract, so it bypasses the modifier on `distribute`.""
      ]
    },
    {
      ""Area"": ""Array Management in `removeReceiver`"",
      ""Tasks"": [
        ""Analyze the `removeReceiver` function to ensure the array element replacement logic doesn't introduce unexpected behavior or vulnerabilities (e.g., double payouts, denial-of-service)."",
        ""Verify that the `removeReceiver` function correctly handles edge cases, such as removing the last element in the `feeReceivers` array."",
        ""Assess the gas cost implications of the array element replacement strategy, especially for large arrays."",
        ""Consider the potential for front-running attacks in the `removeReceiver` function, where an attacker could manipulate the order of receivers before removal.""
      ]
    },
    {
      ""Area"": ""Pausability and Emergency Stop"",
      ""Tasks"": [
        ""Verify that the `pauseFeeDistribution` function correctly pauses and unpauses the fee distribution mechanism."",
        ""Ensure that all critical state changes are halted when the contract is paused."",
        ""Assess the impact of pausing the contract on other dependent contracts and the overall system."",
        ""Check for any potential bypasses to the pausing mechanism.""
      ]
    },
    {
      ""Area"": ""Token Rescue Mechanism"",
      ""Tasks"": [
        ""Verify that the `rescueTokens` function correctly transfers ERC20 tokens from the contract to the owner."",
        ""Ensure that the `rescueTokens` function cannot be used to drain tokens that are intended to be distributed as fees."",
        ""Check for potential vulnerabilities related to token rescue, such as rescuing tokens that should not be rescued.""
      ]
    },
    {
      ""Area"": ""Initialization Logic"",
      ""Tasks"": [
        ""Ensure that the `__SimpleFeeDistributor__init__` function can only be called once using the initializer pattern."",
        ""Verify that the initial configuration (treasury address, LP staking address, initial fee receiver) is correctly set during initialization."",
        ""Confirm that the initial allocation point for the LP staking contract is reasonable and aligned with the intended distribution strategy.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of the `distribute`, `addReceiver`, `removeReceiver`, and `changeReceiverAlloc` functions."",
        ""Identify potential areas for gas optimization, such as reducing storage reads/writes, using more efficient data structures, or optimizing loop iterations."",
        ""Consider using calldata instead of memory for function arguments where appropriate."",
        ""Evaluate the gas impact of using SafeERC20 and SafeMath libraries.""
      ]
    },
    {
      ""Area"": ""Data Validation"",
      ""Tasks"": [
        ""Ensure that all input parameters are validated to prevent unexpected behavior or vulnerabilities."",
        ""Check for zero-address checks in functions that set addresses (e.g., `setTreasuryAddress`, `setLPStakingAddress`, `setNFTXVaultFactory`)."",
        ""Verify that allocation points are within reasonable bounds and do not cause overflow issues."",
        ""Confirm that the receiver index is within the bounds of the `feeReceivers` array in functions like `changeReceiverAlloc`, `changeReceiverAddress`, and `removeReceiver`.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines a `NFTXSimpleFeeDistributor` contract responsible for distributing fees (likely ERC20 tokens) from a vault to different receivers, including an LP staking contract, a treasury, and potentially other fee receivers. It inherits from `ReentrancyGuardUpgradeable` and `PausableUpgradeable` for security. The contract allows the owner to manage fee receivers, their allocation points, and the addresses for the treasury, LP staking, and inventory staking contracts. A key function is `distribute`, which distributes tokens based on the allocated percentages to each receiver. The `_sendForReceiver` function handles sending tokens to receivers, distinguishing between contracts and external addresses."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXSimpleFeeDistributor"",
    ""Purpose"": ""Distributes fees (ERC20 tokens) from a vault to various receivers based on allocation points."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""INFTXSimpleFeeDistributor"",
        ""ReentrancyGuardUpgradeable"",
        ""PausableUpgradeable""
      ],
      ""Imports"": [
        ""./interface/INFTXLPStaking.sol"",
        ""./interface/INFTXSimpleFeeDistributor.sol"",
        ""./interface/INFTXInventoryStaking.sol"",
        ""./interface/INFTXVaultFactory.sol"",
        ""./token/IERC20Upgradeable.sol"",
        ""./util/SafeERC20Upgradeable.sol"",
        ""./util/SafeMathUpgradeable.sol"",
        ""./util/PausableUpgradeable.sol"",
        ""./util/ReentrancyGuardUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""distributionPaused"",
        ""Type"": ""bool"",
        ""Purpose"": ""A flag to pause fee distribution.""
      },
      {
        ""Name"": ""nftxVaultFactory"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the NFTX Vault Factory contract.""
      },
      {
        ""Name"": ""lpStaking"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the LP staking contract.""
      },
      {
        ""Name"": ""treasury"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the treasury.""
      },
      {
        ""Name"": ""allocTotal"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total allocation points for all receivers.""
      },
      {
        ""Name"": ""feeReceivers"",
        ""Type"": ""FeeReceiver[]"",
        ""Purpose"": ""Array of FeeReceiver structs containing receiver address and allocation point.""
      },
      {
        ""Name"": ""inventoryStaking"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the inventory staking contract.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""__SimpleFeeDistributor__init__"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract. Sets the treasury and LP staking addresses and adds the LP staking contract as the initial fee receiver."",
        ""Parameters"": [
          ""_lpStaking (address)"",
          ""_treasury (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""distribute"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Distributes fees from a vault to the fee receivers based on their allocation points."",
        ""Parameters"": [
          ""vaultId (uint256)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""addReceiver"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Adds a new fee receiver."",
        ""Parameters"": [
          ""_allocPoint (uint256)"",
          ""_receiver (address)"",
          ""_isContract (bool)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""initializeVaultReceivers"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initializes LP Staking pool and deploys xToken for vault if inventory staking address is set."",
        ""Parameters"": [
          ""_vaultId (uint256)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""changeReceiverAlloc"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Changes the allocation point of a fee receiver."",
        ""Parameters"": [
          ""_receiverIdx (uint256)"",
          ""_allocPoint (uint256)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""changeReceiverAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Changes the address of a fee receiver."",
        ""Parameters"": [
          ""_receiverIdx (uint256)"",
          ""_address (address)"",
          ""_isContract (bool)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""removeReceiver"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Removes a fee receiver."",
        ""Parameters"": [
          ""_receiverIdx (uint256)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setTreasuryAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the treasury address."",
        ""Parameters"": [
          ""_treasury (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setLPStakingAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the LP staking address."",
        ""Parameters"": [
          ""_lpStaking (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setInventoryStakingAddress"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the inventory staking address."",
        ""Parameters"": [
          ""_inventoryStaking (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setNFTXVaultFactory"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the NFTX vault factory address."",
        ""Parameters"": [
          ""_factory (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""pauseFeeDistribution"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Pauses or unpauses fee distribution."",
        ""Parameters"": [
          ""pause (bool)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""rescueTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Rescues tokens stuck in the contract."",
        ""Parameters"": [
          ""_address (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_addReceiver"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Adds a fee receiver. Used internally."",
        ""Parameters"": [
          ""_allocPoint (uint256)"",
          ""_receiver (address)"",
          ""_isContract (bool)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""_sendForReceiver"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sends tokens to a fee receiver. Handles contract calls vs. direct transfers."",
        ""Parameters"": [
          ""_receiver (FeeReceiver memory)"",
          ""_vaultId (uint256)"",
          ""_vault (address)"",
          ""amountToSend (uint256)""
        ],
        ""Returns"": [
          ""bool""
        ]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IERC20Upgradeable (for token transfers and balance checks)"",
    ""INFTXVaultFactory (to get the vault address by ID)"",
    ""INFTXLPStaking (to add pool for a vault)"",
    ""INFTXInventoryStaking (to deploy XToken for vault)""
  ],
  ""SpecialMechanisms"": [
    ""Uses `SafeERC20Upgradeable` for safe token transfers."",
    ""Implements a fee distribution mechanism based on allocation points."",
    ""Uses `ReentrancyGuardUpgradeable` to prevent reentrancy attacks."",
    ""Uses `PausableUpgradeable` to allow pausing of the contract."",
    ""Distinguishes between sending tokens to external addresses and calling a function on a contract using `_isContract` flag and performs approval before the call.""
  ],
  ""Questions"": [
    ""Why is `IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0` checked in the `_sendForReceiver` function after making the call to the receiver?"",
    ""Is there any risk of front-running in the `removeReceiver` function, given the array element replacement logic?"",
    ""Could the use of `leftover` value in the `distribute` function create a potential issue for dust values? Is the treasury always able to take dust values to prevent tokens being locked in this contract forever?"",
    ""Why is the `INFTXLPStaking.receiveRewards` selector hardcoded, and what are the implications if the interface changes?"",
    ""What is the intended functionality and security consideration related to approving `amountToSend` to the receiver and then checking that allowance has gone back to 0. Is the receiver contract expected to revoke approval immediately? ""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Reentrancy Vulnerability in `_sendForReceiver` Function"",
      ""Severity"": ""High"",
      ""Description"": ""The `_sendForReceiver` function is vulnerable to reentrancy. When the receiver is a contract, the function approves the receiver to spend tokens, and then makes an external call to the receiver's `receiveRewards` function using `.call()`. A malicious receiver contract could call back into the `distribute` function before the allowance is reset or other critical state updates are completed, potentially draining the contract's funds or causing unexpected state changes. The allowance check after the call doesn't prevent re-entrancy as a malicious contract can manipulate the allowance during the callback."",
      ""Impact"": ""Potential for theft of funds due to uncontrolled calling of distribute function within the receiveRewards.  A malicious receiver contract could re-enter the `distribute` function and potentially manipulate the state, drain funds, or cause other unintended consequences."",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:_sendForReceiver""
    },
    {
      ""Issue"": ""Missing Initialization of ReentrancyGuardUpgradeable and PausableUpgradeable"",
      ""Severity"": ""High"",
      ""Description"": ""The contract inherits `ReentrancyGuardUpgradeable` and `PausableUpgradeable`, but the `initializer` functions for these contracts are not called in `NFTXSimpleFeeDistributor.__SimpleFeeDistributor__init__`. This can lead to unexpected behavior and potential vulnerabilities as the state variables of these contracts will not be properly initialized."",
      ""Impact"": ""Contract may be vulnerable to reentrancy attacks, and the pausable functionality may not work as expected. Lack of initialization can cause storage collisions if parent contract uses same storage slots."",
      ""Location"": ""NFTXSimpleFeeDistributor.__SimpleFeeDistributor__init__""
    },
    {
      ""Issue"": ""Lack of Access Control on `initializeVaultReceivers` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `initializeVaultReceivers` function, intended for use only by the `nftxVaultFactory`, is inadequately protected. It only checks if `msg.sender == nftxVaultFactory`, without verifying that `nftxVaultFactory` is a valid contract or validating `_vaultId`. If the `nftxVaultFactory` is compromised, accidentally set to `address(this)`, or an attacker-controlled address, anyone could call this function and manipulate the LP staking and inventory staking contracts, potentially leading to unexpected state changes and denial of service in those contracts."",
      ""Impact"": ""Potential for unauthorized manipulation of LP staking and inventory staking contracts, leading to loss of funds or incorrect reward distribution. Multiple initializations can lead to unexpected results in staking contracts. Can create duplicate pools and xTokens, or overwrite existing configurations"",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:initializeVaultReceivers, initializeVaultReceivers function""
    },
    {
      ""Issue"": ""Allowance manipulation vulnerability and Incorrect Allowance Check in `_sendForReceiver`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The intention of the check `IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0` in `_sendForReceiver` is to confirm that the receiver contract has reset the allowance after receiving the funds. However, the check is made *after* the funds are sent and the receiver contract can manipulate the allowance. Furthermore, the code does not handle the allowance as expected, as an approve is done before the call and no transfer is done by this contract, therefore allowance will remain unchanged during the call. The receiving contract can also set this contract as spender."",
      ""Impact"": ""Malicious contracts can bypass the allowance check, leading to unexpected behavior and potentially bypassing reentrancy protections. Distribution may stop when it shouldn't."",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:_sendForReceiver""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `amountToSend` Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `distribute` function, the `amountToSend` is calculated as `leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal)`. If `tokenBalance * _feeReceiver.allocPoint` is very large, it can overflow, resulting in an incorrect `amountToSend`. This can also happen to `allocTotal` when `_allocPoint` is added. An overflow in `allocTotal` could cause unexpected behavior in the `distribute` function."",
      ""Impact"": ""Incorrect reward distribution, potentially leading to some receivers not receiving their allocated share. Integer overflow can lead to incorrect allocation of rewards. A very large allocation to a single receiver can deny rewards to other receivers. Can starve receivers if tokenBalance and allocPoint product exceeds uint256 max."",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:distribute, changeReceiverAlloc function""
    },
    {
      ""Issue"": ""Missing Input Validation for Receiver Addresses"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `addReceiver` and `changeReceiverAddress` do not check if the `_receiver` or `_address` is the zero address. Additionally, the functions `changeReceiverAlloc`, `changeReceiverAddress` and `removeReceiver` accept an index `_receiverIdx` without validating that it is within the bounds of the `feeReceivers` array's length."",
      ""Impact"": ""Accidental or malicious setting of a receiver address to the zero address can result in a loss of funds if rewards are sent to the zero address. Transaction will revert if an invalid index is provided."",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:_addReceiver, NFTXSimpleFeeDistributor.sol:changeReceiverAddress, NFTXSimpleFeeDistributor.sol:changeReceiverAlloc, NFTXSimpleFeeDistributor.sol:changeReceiverAddress, NFTXSimpleFeeDistributor.sol:removeReceiver""
    },
    {
      ""Issue"": ""Potential Denial of Service and Order Change in `removeReceiver`"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `removeReceiver` function, after emitting the `RemoveFeeReceiver` event and subtracting `allocTotal`, the code swaps the element to be removed with the last element of the array and then pops the array. While this reduces gas costs compared to shifting all elements, it changes the order of elements in the `feeReceivers` array. If external systems rely on a specific order of receivers, this change in order could cause unexpected issues or require adjustments to their logic."",
      ""Impact"": ""Changing of the order of `feeReceivers` may break integration with other contracts"",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:removeReceiver""
    },
    {
      ""Issue"": ""Potential Integer Division Rounding Errors"",
      ""Severity"": ""Low"",
      ""Description"": ""The `amountToSend` is calculated using integer division: `(tokenBalance * _feeReceiver.allocPoint) / allocTotal`. Integer division truncates the decimal part, resulting in rounding errors. These rounding errors can accumulate and lead to an unfair distribution of fees, especially when dealing with small allocation points or large token balances."",
      ""Impact"": ""Slightly unfair distribution of fees due to rounding errors. The treasury receives the leftover tokens, but the intended distribution might be skewed."",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:53""
    },
    {
      ""Issue"": ""Potential division by zero error"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `distribute` function, if `allocTotal` is zero (which can happen if all receivers are removed), the calculation `(tokenBalance * _feeReceiver.allocPoint) / allocTotal` will result in a division by zero error, reverting the transaction. While there is an `if (distributionPaused || allocTotal == 0)` check, it only redirects all tokens to `treasury`, it does not prevent the error during allocation if distribution is not paused, but `allocTotal` is 0."",
      ""Impact"": ""The `distribute` function will revert if `allocTotal` is zero and distribution is not paused, preventing the distribution of tokens to the treasury."",
      ""Location"": ""distribute function""
    },
    {
      ""Issue"": ""Unprotected `rescueTokens` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `rescueTokens` function allows the owner to transfer any ERC20 tokens held by the contract to the message sender. While this function is onlyOwner protected, there is no restriction of rescuing only tokens not relevant to function of the contract, so funds required for functioning contract can be drained accidentally by owner."",
      ""Impact"": ""Potential for accidental or malicious draining of funds required for the functioning of the contract by owner."",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:rescueTokens""
    },
    {
      ""Issue"": ""Missing event emission for critical state changes in changeReceiverAlloc and changeReceiverAddress"",
      ""Severity"": ""Informational"",
      ""Description"": ""While the code emits events `UpdateFeeReceiverAlloc` and `UpdateFeeReceiverAddress`, there's no event emitted when `allocTotal` is changed in `changeReceiverAlloc`. Emitting an event when `allocTotal` is updated would improve the off-chain monitoring capabilities and make it easier to track changes to the overall allocation scheme. Similarly, it can be useful to log the `isContract` flag in the `UpdateFeeReceiverAddress` event. "",
      ""Impact"": ""Reduced visibility into state changes."",
      ""Location"": ""NFTXSimpleFeeDistributor.sol:changeReceiverAlloc, NFTXSimpleFeeDistributor.sol:changeReceiverAddress""
    }
  ],
  ""IssueNumber"": 41,
  ""OutputList"": 11
}",181.37789225578308,3927.0,32.0,"### **[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees**

**Report Description**:
In the `NFTXSimpleFeeDistributor.sol` contract, the `distribute` function uses the `_sendForReceiver` function to distribute fees. The `_sendForReceiver` function does not return a value when the receiver is not a contract, which defaults to `false`. This causes the `distribute` function to incorrectly assume that the fee transfer failed, leading to the same fee being sent again in the next iteration. This issue results in double payments to receivers, especially when the receiver is an externally owned account (EOA), and can deplete funds intended for other receivers.

**Match in Response List**:
No direct match found. However, the issue is partially related to the **""Allowance manipulation vulnerability and Incorrect Allowance Check in `_sendForReceiver`""** and **""Potential Denial of Service and Order Change in `removeReceiver`""** findings in the response list, as they also discuss vulnerabilities in the `_sendForReceiver` function.

**Validation**:
**Partially Correct**. The response list does not explicitly address the issue of the `_sendForReceiver` function not returning a value for non-contract receivers. However, it does highlight other vulnerabilities in the same function, such as allowance manipulation and reentrancy risks. While these findings are relevant, they do not fully cover the specific issue of incorrect return values leading to double payments.

---

### **[M-01] Missing non reentrancy modifier**

**Report Description**:
Several functions in the contract are missing the `nonReentrant` modifier, even though other public/external functions use it. Although no direct exploit was identified, the absence of this modifier could potentially lead to reentrancy vulnerabilities, especially in functions that interact with external contracts or handle funds.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Vulnerability in `_sendForReceiver` Function""**.

**Validation**:
**Correct**. The response accurately identifies the reentrancy risk in the `_sendForReceiver` function, which aligns with the issue of missing `nonReentrant` modifiers in other functions. The response explains the potential for reentrancy attacks and the impact on the contract's state, which is consistent with the reported issue.

---

### **[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver**

**Report Description**:
The `addReceiver` function does not check if the `_receiver` already exists in the `feeReceivers` array. This oversight could lead to the same receiver being added multiple times, resulting in erroneous fee distributions. Receivers added multiple times would receive more fees than intended, potentially depleting funds meant for other receivers.

**Match in Response List**:
No direct match found.

**Validation**:
**Incorrect**. The response list does not address this issue. The absence of a check for existing receivers is a significant oversight that could lead to incorrect fee distributions, but it is not covered in the provided responses.

---

### **[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract**

**Report Description**:
The `_sendForReceiver` function does not return a success value when the receiver is not a contract, which defaults to `false`. This causes the `distribute` function to incorrectly assume that the fee transfer failed, leading to double payments to receivers. This issue particularly affects externally owned accounts (EOAs), as they are not contracts, and can result in unfair distribution of fees.

**Match in Response List**:
No direct match found.

**Validation**:
**Incorrect**. The response list does not address this specific issue. The failure to return a success value for non-contract receivers is a critical flaw that leads to double payments, but it is not covered in the provided responses.

---

### **[M-14] Return variable can remain unassigned in _sendForReceiver**

**Report Description**:
The `_sendForReceiver` function only sets a return value in the `if` block but not in the `else` block. If the `else` block is executed (e.g., when the receiver is not a contract), no value is returned, which defaults to `false`. This causes the `distribute` function to incorrectly assume that the fee transfer failed, leading to double payments and potential loss of funds.

**Match in Response List**:
No direct match found.

**Validation**:
**Incorrect**. The response list does not address this issue. The failure to return a value in the `else` block is a significant oversight that leads to incorrect fee distributions, but it is not covered in the provided responses.

---

### **[M-16] Malicious receiver can make `distribute` function denial of service**

**Report Description**:
A malicious receiver can exploit the `distribute` function by causing it to revert, leading to a denial of service (DoS) attack. This can occur if the receiver contract manipulates the state or causes the transaction to fail, preventing the distribution of fees to other receivers.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Vulnerability in `_sendForReceiver` Function""**.

**Validation**:
**Correct**. The response accurately identifies the reentrancy risk in the `_sendForReceiver` function, which could be exploited by a malicious receiver to cause a denial of service. The response explains the potential impact of such an attack, which aligns with the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Missing non reentrancy modifier**
- **[M-16] Malicious receiver can make `distribute` function denial of service**

**Partially Correct Matches**:

- **[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees**

**Missed Issues from Issue Report**:

- **[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver**
- **[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract**
- **[M-14] Return variable can remain unassigned in _sendForReceiver**

---

The response list covers some critical issues, such as reentrancy and denial of service, but misses several important vulnerabilities related to the `_sendForReceiver` function and the `addReceiver` function. These gaps highlight the need for a more comprehensive review of the contract's logic and return value handling.","```
1. Reentrancy Vulnerability in `_sendForReceiver` Function
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Reentrancy Vulnerability in `_sendForReceiver` Function"".
   - In the ranked list of predictions, this issue appears at **rank 1**.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to that rank divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
NFTXVaultUpgradeable.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";

// Authors: @0xKiwi_ and @alexgausman.

contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    // Added in v1.0.3.
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.
    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow 
    // a similar interface.
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    // // This function allows for the manager to set their own arbitrary eligibility contract.
    // // Once eligiblity is set, it cannot be unset or changed.
    // Disabled for launch.
    // function setEligibilityStorage(address _newEligibility) public virtual {
    //     onlyPrivileged();
    //     require(
    //         address(eligibilityStorage) == address(0),
    //         ""NFTXVault: eligibility already set""
    //     );
    //     eligibilityStorage = INFTXEligibility(_newEligibility);
    //     // Toggle this to let the contract know to check eligibility now.
    //     allowAllItems = false;
    //     emit CustomEligibilityDeployed(address(_newEligibility));
    // }

    // The manager has control over options like fees and features
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        // Take the NFTs.
        uint256 count = receiveNFTs(tokenIds, amounts);

        // Mint to the user.
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        // We burn all from sender and mint to fee receiver to reduce costs.
        _burn(msg.sender, base * amount);

        // Pay the tokens + toll.
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        // Withdraw from vault.
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, /* ignored for ERC721 vaults */
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        // Give the NFTs first, so the user wont get the same thing back, just to be nice. 
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    // Added in v1.0.3.
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    // Added in v1.0.3.
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    // Added in v1.0.3.
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    // We set a hook to the eligibility module (if it exists) after redeems in case anything needs to be modified.
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            // This is technically a check, so placing it before the effect.
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                // We may already own the NFT here so we check in order:
                // Does the vault own it?
                //   - If so, check if its in holdings list
                //      - If so, we reject. This means the NFT has already been claimed for.
                //      - If not, it means we have not yet accounted for this NFT, so we continue.
                //   -If not, we ""pull"" it from the msg.sender and add to holdings.
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            // This will always be fine considering the validations made above. 
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        // Do not charge fees if the zap contract is calling
        // Added in v1.0.3. Changed to mapping in v1.0.5.
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        // Mint fees directly to the distributor and distribute.
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            // Changed to a _transfer() in v1.0.3.
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Changed in v1.0.4.
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            // Default.
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            // Cryptokitties.
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            // CryptoPunks.
            // Fix here for frontrun attack. Added in v1.0.2.
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            // Default.
            // Allow other contracts to ""push"" into the vault, safely.
            // If we already have the token requested, make sure we don't have it in the list to prevent duplicate minting.
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4750,561,"[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users

Submitted by pedroais
Pool Manager can front-run entry fee to 100% and users could lose all their deposits.
Proof of Concept

Considering: The pool manager is the creator of the pool. Anyone can create a pool. Manager is not a trusted actor.
Anyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10**18 (100% as this is a per token fee).
  [M-09] Bypass zap timelock

Submitted by gzeon
The default value of inventoryLockTime in NFTXStakingZap is 7 days while DEFAULT_LOCKTIME in NFTXInventoryStaking is 2 ms. These timelock value are used in NFTXInventoryStaking to eventually call _timelockMint in XTokenUpgradeable.
https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74
function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {
  uint256 timelockFinish = block.timestamp + timelockLength;
  timelock[account] = timelockFinish;
  emit Timelocked(account, timelockFinish);
  _mint(account, amount);
}

The applicable timelock is calculated by block.timestamp + timelockLength, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling deposit in NFTXInventoryStaking
",2,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXEligibility.sol"";
import ""./interface/INFTXEligibilityManager.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXFeeDistributor.sol"";
import ""./interface/IERC165Upgradeable.sol"";
import ""./token/ERC20FlashMintUpgradeable.sol"";
import ""./token/ERC721SafeHolderUpgradeable.sol"";
import ""./token/ERC1155SafeHolderUpgradeable.sol"";
import ""./token/IERC721Upgradeable.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";
import ""./util/ReentrancyGuardUpgradeable.sol"";
import ""./util/EnumerableSetUpgradeable.sol"";



contract NFTXVaultUpgradeable is
    OwnableUpgradeable,
    ERC20FlashMintUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721SafeHolderUpgradeable,
    ERC1155SafeHolderUpgradeable,
    INFTXVault
{
    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;

    uint256 constant base = 10**18;

    uint256 public override vaultId;
    address public override manager;
    address public override assetAddress;
    INFTXVaultFactory public override vaultFactory;
    INFTXEligibility public override eligibilityStorage;

    uint256 randNonce;
    uint256 private UNUSED_FEE1;
    uint256 private UNUSED_FEE2;
    uint256 private UNUSED_FEE3;

    bool public override is1155;
    bool public override allowAllItems;
    bool public override enableMint;
    bool public override enableRandomRedeem;
    bool public override enableTargetRedeem;

    EnumerableSetUpgradeable.UintSet holdings;
    mapping(uint256 => uint256) quantity1155;

    bool public override enableRandomSwap;
    bool public override enableTargetSwap;

    function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true , true , true , true , true );
    }

    function finalizeVault() external override virtual {
        setManager(address(0));
    }

    
    function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

    function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

    function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

    function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

    function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

    
    
    
    function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

    function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts 
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

    function mintTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        address to
    ) public override virtual nonReentrant returns (uint256) {
        onlyOwnerIfPaused(1);
        require(enableMint, ""Minting not enabled"");
        
        uint256 count = receiveNFTs(tokenIds, amounts);

        
        _mint(to, base * count);
        uint256 totalFee = mintFee() * count;
        _chargeAndDistributeFees(to, totalFee);

        emit Minted(tokenIds, amounts, to);
        return count;
    }

    function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

    function redeemTo(uint256 amount, uint256[] memory specificIds, address to)
        public
        override
        virtual
        nonReentrant
        returns (uint256[] memory)
    {
        onlyOwnerIfPaused(2);
        require(
            amount == specificIds.length || enableRandomRedeem,
            ""NFTXVault: Random redeem not enabled""
        );
        require(
            specificIds.length == 0 || enableTargetRedeem,
            ""NFTXVault: Target redeem not enabled""
        );
        
        
        _burn(msg.sender, base * amount);

        
        uint256 totalFee = (targetRedeemFee() * specificIds.length) + (
            randomRedeemFee() * (amount - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);

        
        uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);
        emit Redeemed(redeemedIds, specificIds, to);
        return redeemedIds;
    }
    
    function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, 
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

    function swapTo(
        uint256[] memory tokenIds,
        uint256[] memory amounts, 
        uint256[] memory specificIds,
        address to
    ) public override virtual nonReentrant returns (uint256[] memory) {
        onlyOwnerIfPaused(3);
        uint256 count;
        if (is1155) {
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                count += amount;
            }
        } else {
            count = tokenIds.length;
        }

        require(
            count == specificIds.length || enableRandomSwap,
            ""NFTXVault: Random swap disabled""
        );
        require(
            specificIds.length == 0 || enableTargetSwap,
            ""NFTXVault: Target swap disabled""
        );

        uint256 totalFee = (targetSwapFee() * specificIds.length) + (
            randomSwapFee() * (count - specificIds.length)
        );
        _chargeAndDistributeFees(msg.sender, totalFee);
        
        
        uint256[] memory ids = withdrawNFTsTo(count, specificIds, to);

        receiveNFTs(tokenIds, amounts);

        emit Swapped(tokenIds, amounts, specificIds, ids, to);
        return ids;
    }

    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }

    function mintFee() public view override virtual returns (uint256) {
        (uint256 _mintFee, , , ,) = vaultFactory.vaultFees(vaultId);
        return _mintFee;
    }

    function randomRedeemFee() public view override virtual returns (uint256) {
        (, uint256 _randomRedeemFee, , ,) = vaultFactory.vaultFees(vaultId);
        return _randomRedeemFee;
    }

    function targetRedeemFee() public view override virtual returns (uint256) {
        (, , uint256 _targetRedeemFee, ,) = vaultFactory.vaultFees(vaultId);
        return _targetRedeemFee;
    }

    function randomSwapFee() public view override virtual returns (uint256) {
        (, , , uint256 _randomSwapFee, ) = vaultFactory.vaultFees(vaultId);
        return _randomSwapFee;
    }

    function targetSwapFee() public view override virtual returns (uint256) {
        (, , , ,uint256 _targetSwapFee) = vaultFactory.vaultFees(vaultId);
        return _targetSwapFee;
    }

    function vaultFees() public view override virtual returns (uint256, uint256, uint256, uint256, uint256) {
        return vaultFactory.vaultFees(vaultId);
    }

    function allValidNFTs(uint256[] memory tokenIds)
        public
        view
        override
        virtual
        returns (bool)
    {
        if (allowAllItems) {
            return true;
        }

        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return false;
        }
        return _eligibilityStorage.checkAllEligible(tokenIds);
    }

    function nftIdAt(uint256 holdingsIndex) external view override virtual returns (uint256) {
        return holdings.at(holdingsIndex);
    }

    
    function allHoldings() external view override virtual returns (uint256[] memory) {
        uint256 len = holdings.length();
        uint256[] memory idArray = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            idArray[i] = holdings.at(i);
        }
        return idArray;
    }

    
    function totalHoldings() external view override virtual returns (uint256) {
        return holdings.length();
    }

    
    function version() external pure returns (string memory) {
        return ""v1.0.5"";
    } 

    
    function afterRedeemHook(uint256[] memory tokenIds) internal virtual {
        INFTXEligibility _eligibilityStorage = eligibilityStorage;
        if (address(_eligibilityStorage) == address(0)) {
            return;
        }
        _eligibilityStorage.afterRedeemHook(tokenIds);
    }

    function receiveNFTs(uint256[] memory tokenIds, uint256[] memory amounts)
        internal
        virtual
        returns (uint256)
    {
        require(allValidNFTs(tokenIds), ""NFTXVault: not eligible"");
        if (is1155) {
            
            IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(
                msg.sender,
                address(this),
                tokenIds,
                amounts,
                """"
            );

            uint256 count;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                uint256 amount = amounts[i];
                require(amount > 0, ""NFTXVault: transferring < 1"");
                if (quantity1155[tokenId] == 0) {
                    holdings.add(tokenId);
                }
                quantity1155[tokenId] += amount;
                count += amount;
            }
            return count;
        } else {
            address _assetAddress = assetAddress;
            for (uint256 i = 0; i < tokenIds.length; i++) {
                uint256 tokenId = tokenIds[i];
                
                
                
                
                
                
                transferFromERC721(_assetAddress, tokenId);
                holdings.add(tokenId);
            }
            return tokenIds.length;
        }
    }

    function withdrawNFTsTo(
        uint256 amount,
        uint256[] memory specificIds,
        address to
    ) internal virtual returns (uint256[] memory) {
        bool _is1155 = is1155;
        address _assetAddress = assetAddress;
        uint256[] memory redeemedIds = new uint256[](amount);
        for (uint256 i = 0; i < amount; i++) {
            
            uint256 tokenId = i < specificIds.length ? 
                specificIds[i] : getRandomTokenIdFromVault();
            redeemedIds[i] = tokenId;

            if (_is1155) {
                quantity1155[tokenId] -= 1;
                if (quantity1155[tokenId] == 0) {
                    holdings.remove(tokenId);
                }

                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    to,
                    tokenId,
                    1,
                    """"
                );
            } else {
                holdings.remove(tokenId);
                transferERC721(_assetAddress, to, tokenId);
            }
        }
        afterRedeemHook(redeemedIds);
        return redeemedIds;
    }

    function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {
        
        
        if (vaultFactory.excludedFromFees(msg.sender)) {
            return;
        }
        
        
        if (amount > 0) {
            address feeDistributor = vaultFactory.feeDistributor();
            
            _transfer(user, feeDistributor, amount);
            INFTXFeeDistributor(feeDistributor).distribute(vaultId);
        }
    }

    function transferERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transfer(address,uint256)"", to, tokenId);
        } else if (assetAddr == punks) {
            
            data = abi.encodeWithSignature(""transferPunk(address,uint256)"", to, tokenId);
        } else {
            
            data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", address(this), to, tokenId);
        }
        (bool success,) = address(assetAddr).call(data);
        require(success);
    }

    function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {
        address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
        address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
        bytes memory data;
        if (assetAddr == kitties) {
            
            data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
        } else if (assetAddr == punks) {
            
            
            bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
            (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
            (address owner) = abi.decode(result, (address));
            require(checkSuccess && owner == msg.sender, ""Not the owner"");
            data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
        } else {
            
            
            
            if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) {
                require(!holdings.contains(tokenId), ""Trying to use an owned NFT"");
                return;
            } else {
                data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
            }
        }
        (bool success, bytes memory resultData) = address(assetAddr).call(data);
        require(success, string(resultData));
    }

    function getRandomTokenIdFromVault() internal virtual returns (uint256) {
        uint256 randomIndex = uint256(
            keccak256(
                abi.encodePacked(
                    blockhash(block.number - 1), 
                    randNonce,
                    block.coinbase,
                    block.difficulty,
                    block.timestamp
                )
            )
        ) % holdings.length();
        randNonce += 1;
        return holdings.at(randomIndex);
    }

    function onlyPrivileged() internal view {
        if (manager == address(0)) {
            require(msg.sender == owner(), ""Not owner"");
        } else {
            require(msg.sender == manager, ""Not manager"");
        }
    }

    function onlyOwnerIfPaused(uint256 lockId) internal view {
        require(!vaultFactory.isLocked(lockId) || msg.sender == owner(), ""Paused"");
    }
}",4033,0,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Privilege Management"",
      ""Tasks"": [
        ""Verify that only the owner or manager can call functions protected by the `onlyPrivileged` modifier."",
        ""Confirm that the `finalizeVault` function correctly sets the manager to address(0), effectively disabling privileged access through the manager role."",
        ""Investigate the implications of setting `manager` to address(0) and the subsequent reliance on `owner()` for privileged operations."",
        ""Analyze the `onlyOwnerIfPaused` modifier and its interaction with the `vaultFactory.isLocked(lockId)` function to understand the pausing mechanism."",
        ""Review the `assignDefaultFeatures` function and determine the rationale behind restricting its access to a specific hardcoded address. Assess potential risks associated with this approach."",
        ""Verify the functionality of the `setManager` function and confirm that only a privileged user can change the manager address. Ensure that the `ManagerSet` event is emitted correctly."",
        ""In `_chargeAndDistributeFees` check if `vaultFactory.excludedFromFees(user)` is being checked instead of `msg.sender` since the funds are being transferred from the user and not the `msg.sender`""
      ]
    },
    {
      ""Area"": ""NFT Eligibility and Asset Handling"",
      ""Tasks"": [
        ""Analyze the `allValidNFTs` function to ensure that it correctly checks NFT eligibility based on `allowAllItems` and the `eligibilityStorage` contract."",
        ""If eligibilityStorage exists, confirm it's a valid contract address and implements the `INFTXEligibility` interface."",
        ""Verify that the `deployEligibilityStorage` function correctly deploys and initializes the eligibility storage contract."",
        ""Check the logic within `receiveNFTs` to confirm correct handling of both ERC721 and ERC1155 tokens."",
        ""Investigate the edge case in `transferFromERC721` where `ownerOf(tokenId) == address(this)` and the token is *not* added to holdings, and determine what scenario triggers this and if this behavior is actually intended or should be fixed."",
        ""Scrutinize the transferERC721 and transferFromERC721 functions for correctness, particularly the handling of CryptoKitties and CryptoPunks. Ensure that the correct function signatures and parameters are used."",
         ""Check that the punkIndexToAddress call success is properly validated after calling the function. If it isn't verified, then it can lead to inconsistent states in the contract""
      ]
    },
    {
      ""Area"": ""Minting, Redeeming, and Swapping Logic"",
      ""Tasks"": [
        ""Verify that the `mint` and `mintTo` functions correctly handle NFT deposits and ERC20 token minting, including fee calculations and distribution."",
        ""Analyze the `redeem` and `redeemTo` functions to ensure that they correctly handle ERC20 token burning and NFT withdrawals, including fee calculations and distribution."",
        ""Verify that the `swap` and `swapTo` functions correctly handle NFT swaps, including fee calculations and distribution. Ensure that the logic for ERC721 and ERC1155 tokens is correctly differentiated."",
        ""Confirm that the fee calculations in `mintTo`, `redeemTo`, and `swapTo` are accurate and that the fees are correctly charged and distributed using the `_chargeAndDistributeFees` function."",
        ""Check that the `afterRedeemHook` is called and that it behaves as expected when redeeming."",
         ""Verify that _chargeAndDistributeFees is using `msg.sender` instead of `user`.""
      ]
    },
    {
      ""Area"": ""Randomness and Security Considerations"",
      ""Tasks"": [
        ""Assess the security of the `getRandomTokenIdFromVault` function. Determine if the randomness source is sufficiently resistant to manipulation by malicious actors."",
        ""Evaluate the potential impact of predictable random numbers on the redeem and swap functionalities."",
         ""Assess the safety of `blockhash(block.number - 1)` usage, since miners have influence over the previous blockhash""
      ]
    },
    {
      ""Area"": ""Fee Management and Distribution"",
      ""Tasks"": [
        ""Verify that the `setFees` and `disableVaultFees` functions correctly interact with the `vaultFactory` to manage vault fees."",
        ""Analyze the `_chargeAndDistributeFees` function to ensure that it correctly charges fees and distributes them to the `feeDistributor` contract."",
        ""Confirm that the `excludedFromFees` function in the `vaultFactory` is correctly used to exclude certain addresses from paying fees."",
         ""Verify that `vaultFactory.excludedFromFees(msg.sender)` is being checked instead of `vaultFactory.excludedFromFees(user)`.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Ensure that the contract follows the upgradeable proxy pattern correctly, including proper initialization and storage slot management."",
        ""Verify that the initializer function `__NFTXVault_init` can only be called once."",
        ""Confirm that all state variables are properly initialized and used consistently across upgrades.""
      ]
    },
    {
      ""Area"": ""Reentrancy Protection"",
      ""Tasks"": [
        ""Verify that the `nonReentrant` modifier is correctly applied to all functions that modify state variables and interact with external contracts."",
        ""Analyze the contract for potential reentrancy vulnerabilities, particularly in the mint, redeem, and swap functionalities.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify potential gas optimization opportunities in the contract, such as reducing storage reads and writes, using more efficient data structures, and minimizing external calls."",
        ""Analyze the gas costs of key functions (mint, redeem, swap) and identify areas for improvement.""
      ]
    },
    {
      ""Area"": ""Error Handling and Input Validation"",
      ""Tasks"": [
        ""Review all require statements to ensure that they provide informative error messages."",
        ""Verify that all function inputs are properly validated to prevent unexpected behavior or security vulnerabilities."",
        ""Confirm that the contract handles edge cases and invalid inputs gracefully.""
      ]
    },
    {
      ""Area"": ""External Interactions and Dependencies"",
      ""Tasks"": [
        ""Review all external contract interactions to ensure that they are secure and reliable."",
        ""Verify that the contract correctly handles potential errors or reverts from external calls."",
        ""Assess the risks associated with relying on external contracts and consider implementing fallback mechanisms if necessary.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code represents an upgradeable NFTXVault contract that allows users to mint, redeem, and swap NFTs for ERC20 tokens. It interacts with several external contracts like NFTXVaultFactory, NFTXEligibility, and NFTXFeeDistributor. The contract uses OwnableUpgradeable for access control and ReentrancyGuardUpgradeable to prevent reentrancy attacks. The contract's behavior is highly configurable, with features like minting, redeeming, and swapping being enabled or disabled by a privileged user (either the owner or manager)."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXVaultUpgradeable"",
    ""Purpose"": ""Provides functionality for minting ERC20 tokens by depositing NFTs, redeeming ERC20 tokens for NFTs, and swapping NFTs, all within a vault managed by a specific manager or owner."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""OwnableUpgradeable"",
        ""ERC20FlashMintUpgradeable"",
        ""ReentrancyGuardUpgradeable"",
        ""ERC721SafeHolderUpgradeable"",
        ""ERC1155SafeHolderUpgradeable"",
        ""INFTXVault""
      ],
      ""Imports"": [
        ""./interface/INFTXVault.sol"",
        ""./interface/INFTXVaultFactory.sol"",
        ""./interface/INFTXEligibility.sol"",
        ""./interface/INFTXEligibilityManager.sol"",
        ""./interface/INFTXLPStaking.sol"",
        ""./interface/INFTXFeeDistributor.sol"",
        ""./interface/IERC165Upgradeable.sol"",
        ""./token/ERC20FlashMintUpgradeable.sol"",
        ""./token/ERC721SafeHolderUpgradeable.sol"",
        ""./token/ERC1155SafeHolderUpgradeable.sol"",
        ""./token/IERC721Upgradeable.sol"",
        ""./token/IERC1155Upgradeable.sol"",
        ""./util/OwnableUpgradeable.sol"",
        ""./util/ReentrancyGuardUpgradeable.sol"",
        ""./util/EnumerableSetUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""vaultId"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Unique identifier for the vault.""
      },
      {
        ""Name"": ""manager"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the manager, who has privileged access.""
      },
      {
        ""Name"": ""assetAddress"",
        ""Type"": ""address"",
        ""Purpose"": ""Address of the NFT (ERC721 or ERC1155) contract.""
      },
      {
        ""Name"": ""vaultFactory"",
        ""Type"": ""INFTXVaultFactory"",
        ""Purpose"": ""Address of the NFTXVaultFactory contract.""
      },
      {
        ""Name"": ""eligibilityStorage"",
        ""Type"": ""INFTXEligibility"",
        ""Purpose"": ""Address of the NFTXEligibility contract, used to check NFT eligibility.""
      },
      {
        ""Name"": ""is1155"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether the asset is an ERC1155 token.""
      },
      {
        ""Name"": ""allowAllItems"",
        ""Type"": ""bool"",
        ""Purpose"": ""If true, any NFT can be used; otherwise, eligibilityStorage is used.""
      },
      {
        ""Name"": ""enableMint"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether minting is enabled.""
      },
      {
        ""Name"": ""enableRandomRedeem"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether random redeem is enabled.""
      },
      {
        ""Name"": ""enableTargetRedeem"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether target redeem is enabled.""
      },
      {
        ""Name"": ""enableRandomSwap"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether random swap is enabled.""
      },
      {
        ""Name"": ""enableTargetSwap"",
        ""Type"": ""bool"",
        ""Purpose"": ""Indicates whether target swap is enabled.""
      },
      {
        ""Name"": ""holdings"",
        ""Type"": ""EnumerableSetUpgradeable.UintSet"",
        ""Purpose"": ""Set of token IDs held in the vault.""
      },
      {
        ""Name"": ""quantity1155"",
        ""Type"": ""mapping(uint256 => uint256)"",
        ""Purpose"": ""Mapping from token ID to quantity for ERC1155 tokens.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""__NFTXVault_init"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract."",
        ""Parameters"": [
          ""_name"",
          ""_symbol"",
          ""_assetAddress"",
          ""_is1155"",
          ""_allowAllItems""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""finalizeVault"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets the manager to address(0)."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""setVaultMetadata"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the vault's name and symbol."",
        ""Parameters"": [
          ""name_"",
          ""symbol_""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setVaultFeatures"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Enables or disables vault features (mint, redeem, swap)."",
        ""Parameters"": [
          ""_enableMint"",
          ""_enableRandomRedeem"",
          ""_enableTargetRedeem"",
          ""_enableRandomSwap"",
          ""_enableTargetSwap""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the fees for different actions through the vaultFactory."",
        ""Parameters"": [
          ""_mintFee"",
          ""_randomRedeemFee"",
          ""_targetRedeemFee"",
          ""_randomSwapFee"",
          ""_targetSwapFee""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""disableVaultFees"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Disables vault fees through the vaultFactory."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""deployEligibilityStorage"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Deploys an eligibility storage contract."",
        ""Parameters"": [
          ""moduleIndex"",
          ""initData""
        ],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""setManager"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Sets the manager address."",
        ""Parameters"": [""_manager""],
        ""Returns"": []
      },
      {
        ""Name"": ""mint"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Mints ERC20 tokens by depositing NFTs."",
        ""Parameters"": [
          ""tokenIds"",
          ""amounts""
        ],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""redeem"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Redeems ERC20 tokens for NFTs."",
        ""Parameters"": [
          ""amount"",
          ""specificIds""
        ],
        ""Returns"": [""uint256[] memory""]
      },
      {
        ""Name"": ""swap"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Swaps NFTs for NFTs."",
        ""Parameters"": [
          ""tokenIds"",
          ""amounts"",
          ""specificIds""
        ],
        ""Returns"": [""uint256[] memory""]
      },
      {
        ""Name"": ""flashLoan"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Implements the flash loan functionality."",
        ""Parameters"": [
          ""receiver"",
          ""token"",
          ""amount"",
          ""data""
        ],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""onlyPrivileged"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Modifier that restricts access to the owner or manager."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOwnerIfPaused"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Modifier that restricts access to the owner when vaultFactory is paused."",
        ""Parameters"": [""lockId""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""INFTXVaultFactory"",
    ""INFTXEligibility"",
    ""INFTXEligibilityManager"",
    ""INFTXFeeDistributor"",
    ""IERC721Upgradeable"",
    ""IERC1155Upgradeable"",
    ""IERC3156FlashBorrowerUpgradeable""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable contract pattern using OpenZeppelin's upgradeable contracts."",
    ""Reentrancy guard to prevent reentrancy attacks."",
    ""EnumerableSetUpgradeable for managing token holdings."",
    ""Vault fees are managed and distributed through the NFTXFeeDistributor contract."",
    ""Eligibility checks for NFTs via the INFTXEligibility contract."",
    ""Use of modifiers `onlyPrivileged` and `onlyOwnerIfPaused` for access control."",
    ""Fallback mechanism for ERC721 transfers to support CryptoKitties and CryptoPunks contracts."",
    ""The contract random selects NFTs using a `keccak256` hash to prevent manipulation.""
  ],
  ""Questions"": [
    ""What are the specific use cases for the UNUSED_FEE variables, and why are they present?"",
    ""The `assignDefaultFeatures` function is only callable by a specific address `0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a`. What is the purpose of this function and why is it restricted in this way?"",
    ""The punkIndexToAddress call doesn't check success, leading to a potentially silent failure."",
    ""Is blockhash(block.number - 1) safe to use for randomness, considering miners can influence the previous block's hash?"",
    ""The `transferFromERC721` function includes a check `if (IERC721Upgradeable(assetAddress).ownerOf(tokenId) == address(this)) { require(!holdings.contains(tokenId), 'Trying to use an owned NFT'); return; }`. Why does the code return early if the contract already owns the token? Is this intentional, and what scenario does this cover? It seems like the token should still be added to the holdings in this scenario?"",
     ""Why is `_chargeAndDistributeFees` using `msg.sender` instead of `user`?"",
     ""Why is vaultFactory being checked for `excludedFromFees(msg.sender)` instead of `excludedFromFees(user)` in `_chargeAndDistributeFees`? It should use the user address""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unprotected `assignDefaultFeatures` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `assignDefaultFeatures` function, intended to set default swap features, is protected only by a hardcoded address check. If this address is compromised, an attacker could manipulate the `enableRandomSwap` and `enableTargetSwap` features, potentially leading to financial loss for users. This function should not be in production and should be removed."",
      ""Impact"": ""Compromise of the hardcoded address would allow an attacker to arbitrarily enable or disable `enableRandomSwap` and `enableTargetSwap` features, leading to unexpected behavior and potential financial loss."",
      ""Location"": ""NFTXVaultUpgradeable: lines 79-83, NFTXVaultUpgradeable.sol:100-104, NFTXVaultUpgradeable.sol:105, NFTXVaultUpgradeable.sol:94""
    },
    {
      ""Issue"": ""Potential Reentrancy Vulnerability in `transferERC721` and `transferFromERC721`"",
      ""Severity"": ""High"",
      ""Description"": ""The `transferERC721` and `transferFromERC721` functions use `address(assetAddr).call(data)` to transfer ERC721 tokens, creating a reentrancy vulnerability. A malicious NFT contract could call back into the vault during the transfer, potentially manipulating the vault's state, draining funds, or minting/redeeming more tokens than intended. Even CryptoPunks and CryptoKitties logic, which interacts via `call`, should be reviewed."",
      ""Impact"": ""Reentrancy attack leading to potential loss of NFTs, manipulation of vault state, draining of funds, or unexpected state changes."",
      ""Location"": ""NFTXVaultUpgradeable: lines 451-483 and 485-532, NFTXVaultUpgradeable.sol: transferERC721 and transferFromERC721 functions, NFTXVaultUpgradeable.transferERC721, NFTXVaultUpgradeable.transferFromERC721, NFTXVaultUpgradeable.sol:453-461, NFTXVaultUpgradeable.sol:473-495, NFTXVaultUpgradeable.sol:395-446, NFTXVaultUpgradeable.sol:492, NFTXVaultUpgradeable.sol:489, NFTXVaultUpgradeable.sol:506""
    },
    {
      ""Issue"": ""Vault can be bricked if `vaultFactory.eligibilityManager()` returns a bad address"",
      ""Severity"": ""High"",
      ""Description"": ""If the vaultFactory.eligibilityManager() returns an address that is not a contract, or one which does not implement INFTXEligibilityManager, then the call to `INFTXEligibilityManager(vaultFactory.eligibilityManager())` in `deployEligibilityStorage` will succeed, but the subsequent `eligManager.deployEligibility` call will fail, causing the vault to be bricked. Once the eligibility storage is set, `allowAllItems` is set to false, and the eligibility storage cannot be reset."",
      ""Impact"": ""Vault can be bricked, no assets can be deposited."",
      ""Location"": ""NFTXVaultUpgradeable.sol:120-134""
    },
    {
      ""Issue"": ""Centralized Control with Privileged Roles"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies heavily on privileged roles (owner and manager) to control critical functionalities like setting vault features, fees, and the eligibility storage. If the `manager` address is compromised, an attacker could arbitrarily modify vault parameters, including fees and enabled features, potentially leading to financial loss for users."",
      ""Impact"": ""High risk if owner or manager account is compromised; potential for malicious actions and financial loss if the `manager` address is compromised."",
      ""Location"": ""Multiple functions with `onlyPrivileged` modifier, NFTXVaultUpgradeable.sol: Functions protected by `onlyPrivileged` modifier, NFTXVaultUpgradeable.sol:147-151, NFTXVaultUpgradeable.sol:528-533""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `getRandomTokenIdFromVault`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `getRandomTokenIdFromVault` function relies on `blockhash(block.number - 1)`, `randNonce`, `block.coinbase`, `block.difficulty`, and `block.timestamp` to generate randomness. This is susceptible to front-running or manipulation by miners. An attacker could potentially predict the outcome or influence the redemption process to their advantage, or manipulate the redeem process to their advantage."",
      ""Impact"": ""Slight possibility of manipulating redeem process to the attacker's advantage or unfair redemption of valuable NFTs, with low level probability and limited impact."",
      ""Location"": ""NFTXVaultUpgradeable.sol: getRandomTokenIdFromVault function, NFTXVaultUpgradeable.getRandomTokenIdFromVault, NFTXVaultUpgradeable.sol:509-523, NFTXVaultUpgradeable.sol:450-462, NFTXVaultUpgradeable.sol:549, NFTXVaultUpgradeable.sol:506""
    },
    {
      ""Issue"": ""Missing Input Validation in `mintTo` and `redeemTo` Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `mintTo` and `redeemTo` functions lack adequate input validation for array lengths and amounts. Mismatched lengths in `tokenIds`, `amounts`, and `specificIds` arrays, or excessively large `amount` values, could lead to unexpected behavior, errors, integer overflows, or a denial-of-service (DoS)."",
      ""Impact"": ""Potential for logic errors, DoS due to out-of-bounds array access, integer overflow in fee calculation, or incorrect fee distribution."",
      ""Location"": ""NFTXVaultUpgradeable: lines 155-162 and 179-188, NFTXVaultUpgradeable.sol: mintTo and swapTo functions, NFTXVaultUpgradeable.sol:161-170, NFTXVaultUpgradeable.sol:194-204, NFTXVaultUpgradeable.mintTo, NFTXVaultUpgradeable.redeemTo""
    },
    {
      ""Issue"": ""Inconsistent Access Control and Potential Loss of CryptoPunks in `transferFromERC721`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferFromERC721` function includes specific logic for CryptoPunks, but it inconsistently uses `buyPunk` for transfers without ensuring the punk is free, potentially causing transfers to fail. Also, a user can be tricked into giving away their punk for free. If a user is tricked into calling this function, they could effectively give away their Punk for free if the `buyPunk` function has no price set for it (or some mechanism is used such as front-running to remove the price)."",
      ""Impact"": ""Punk transfers might fail unexpectedly or cause user to lose ownership if the punk is not free. Inconsistent logic or errors."",
      ""Location"": ""NFTXVaultUpgradeable.transferFromERC721, NFTXVaultUpgradeable.sol:531, NFTXVaultUpgradeable.sol:533""
    },
    {
      ""Issue"": ""Lack of input validation in `mintTo` and other functions using `vaultFactory.setVaultFees`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `mintTo`, `redeemTo`, and `swapTo` functions call internal functions that rely on the fee values set in `vaultFactory` which ultimately makes a call to `vaultFactory.setVaultFees`. If the fees are incorrectly set to extremely high values in `vaultFactory`, it can effectively block `mint`, `redeem` and `swap` functionality because it will make a `_transfer` to the `feeDistributor` that exceeds the caller's balance."",
      ""Impact"": ""Denial of Service by setting extremely high fee values, causing minting, redeeming and swapping to fail due to insufficient funds."",
      ""Location"": ""NFTXVaultUpgradeable.mintTo, NFTXVaultUpgradeable.redeemTo, NFTXVaultUpgradeable.swapTo, NFTXVaultUpgradeable._chargeAndDistributeFees""
    },
    {
      ""Issue"": ""Inconsistent state update in `withdrawNFTsTo` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `withdrawNFTsTo` function, the `afterRedeemHook` is called *after* the NFTs have been transferred to the recipient. If `afterRedeemHook` relies on the vault still owning the NFTs, it may encounter unexpected or incorrect state."",
      ""Impact"": ""The `afterRedeemHook` function may operate on incorrect data, which could have unintended consequences depending on its logic. It can cause issues on eligibility check and potential exploits."",
      ""Location"": ""NFTXVaultUpgradeable.sol:458""
    },
    {
        ""Issue"": ""Incorrect Calculation of Mint Fee"",
        ""Severity"": ""Medium"",
        ""Description"": ""In the `mintTo` function, `uint256 totalFee = mintFee() * count;` is used to calculate the total fee. Since mintFee() returns a value relative to 1e18, this means that fees are likely to be way to large, and users minting nfts will be charged more than expected."",
        ""Impact"": ""Vaults are overcharging for minting."",
        ""Location"": ""NFTXVaultUpgradeable.sol:195""
    },
    {
      ""Issue"": ""Lack of Slippage Control in Swapping"",
      ""Severity"": ""Low"",
      ""Description"": ""The `swapTo` function allows users to swap NFTs in and out of the vault. However, there is no slippage control mechanism. If the vault's underlying NFT prices fluctuate significantly between the time the user initiates the swap and the time the transaction is mined, the user might receive fewer NFTs than expected or the transaction could fail. A slippage tolerance parameter should be included to mitigate this risk. Also, `swap` and `swapTo` functions lack slippage control, exposing users to front-running attacks."",
      ""Impact"": ""Potential for unfavorable swap rates and transaction failures due to price fluctuations, potentially leading to financial loss."",
      ""Location"": ""NFTXVaultUpgradeable: lines 206-237, NFTXVaultUpgradeable.sol:198-233""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The multiplication of fee rates with `count`, `amount`, or `specificIds.length` in `mintTo` and `redeemTo` could lead to unexpected results if these values are very large and the fees are set high enough. While Solidity 0.8.0+ provides overflow/underflow protection, additional checks or SafeMath are recommended for enhanced safety."",
      ""Impact"": ""Incorrect fee calculation and distribution, potentially leading to incorrect fee distribution or denial of service."",
      ""Location"": ""NFTXVaultUpgradeable: lines 160, 191-193, 224-226, NFTXVaultUpgradeable.sol:165, NFTXVaultUpgradeable.sol:200-202, NFTXVaultUpgradeable.sol:227, NFTXVaultUpgradeable.sol:277""
    },
    {
      ""Issue"": ""Missing check for zero address in `setVaultMetadata`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `setVaultMetadata` function does not check for zero-length strings for `name_` and `symbol_`. Setting these to empty strings might cause issues in downstream applications."",
      ""Impact"": ""Setting name and symbol to empty strings can cause issues and should be prevented."",
      ""Location"": ""NFTXVaultUpgradeable.sol:70-73""
    },
    {
      ""Issue"": ""Unused State Variables"",
      ""Severity"": ""Low"",
      ""Description"": ""The state variables `UNUSED_FEE1`, `UNUSED_FEE2`, and `UNUSED_FEE3` are declared but never used within the contract. This can lead to confusion and unnecessary storage costs."",
      ""Impact"": ""Minor increase in deployment costs and potential for developer confusion."",
      ""Location"": ""NFTXVaultUpgradeable: lines 30-32""
    },
    {
      ""Issue"": ""Potential denial of service in `transferFromERC721` when using owned NFT"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferFromERC721` function has a specific check for when the NFT is owned by the contract already, this will cause the function to return without transferring the NFT and not revert. This may cause a state issue in the mint function which calls this function."",
      ""Impact"": ""NFT being locked or bricked into the contract."",
      ""Location"": ""NFTXVaultUpgradeable.sol:519""
    },
    {
      ""Issue"": ""Lack of access control on `finalizeVault` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `finalizeVault` function which sets the manager to `address(0)` should have access controls to ensure that it can only be called once, or by a privileged address. Once this is set, the ability for the previous manager or owner to set certain settings is lost, and this action cannot be undone."",
      ""Impact"": ""The action cannot be undone, potentially freezing the functionality of the vault.  Without proper access controls, an incorrect call to `finalizeVault` can brick the smart contract."",
      ""Location"": ""NFTXVaultUpgradeable.sol:52""
    },
    {
        ""Issue"": ""Missing Zero-Address Check for `feeDistributor` in `_chargeAndDistributeFees`"",
        ""Severity"": ""Low"",
        ""Description"": ""The `_chargeAndDistributeFees` function retrieves the `feeDistributor` address from `vaultFactory` and then calls `INFTXFeeDistributor(feeDistributor).distribute(vaultId)`. It does not check if the `feeDistributor` address is the zero address. If the `feeDistributor` address is accidentally set to the zero address, the call to `INFTXFeeDistributor(address(0)).distribute(vaultId)` will likely fail silently or revert, causing fees to be burned or the transaction to revert."",
        ""Impact"": ""Fees may be burned or transactions may revert if the `feeDistributor` is incorrectly set to the zero address."",
        ""Location"": ""NFTXVaultUpgradeable.sol:474""
    },
    {
      ""Issue"": ""Redundant check in `transferFromERC721`"",
      ""Severity"": ""Info"",
      ""Description"": ""In the `transferFromERC721` function, there's a check to prevent using an already owned NFT but will return without executing the transfer. If this logic is intended, consider renaming and documenting it properly. Otherwise, the function may be able to remove this check"",
      ""Impact"": ""Potentially unexpected behavior or logic error."",
      ""Location"": ""NFTXVaultUpgradeable.sol:435-437""
    }
  ],
  ""IssueNumber"": 72,
  ""OutputList"": 18
}",241.80755281448364,4240.0,35.0,"### **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Report Description**:  
The pool manager can front-run the entry fee to 100%, causing users to lose all their deposits. This is possible because the pool manager is the creator of the pool, and anyone can create a pool. If a large deposit is made, the manager can front-run the transaction and set the fee to the maximum value (`uint(1 ether) = 10**18`), which is equivalent to 100% of the deposit. This allows the manager to steal the value from users.

**Match in Response List**:  
Matches with the issue titled **""Centralized Control with Privileged Roles""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of centralized control with privileged roles, which is relevant to the issue. However, it does not specifically address the front-running aspect or the ability to set fees to 100%, which is the core of the reported vulnerability. The response focuses on the general risk of compromised privileged roles but misses the specific exploit described in the issue.

---

### **[M-09] Bypass zap timelock**

**Report Description**:  
The default value of `inventoryLockTime` in `NFTXStakingZap` is 7 days, while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock values are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in `XTokenUpgradeable`. The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. This allows a user to reduce their long (e.g., 7 days) timelock to 2 ms by calling `deposit` in `NFTXInventoryStaking`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The issue describes a specific vulnerability related to timelock bypass, but no corresponding issue in the response list addresses this. The response list does not cover this vulnerability, making it a missed issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users**

**Missed Issues from Issue Report**:  
- **[M-09] Bypass zap timelock**

--- 

The response list partially addresses one issue but misses another entirely. The **""Centralized Control with Privileged Roles""** response is relevant but lacks specificity regarding the front-running exploit. The **""Bypass zap timelock""** issue is completely unaddressed, indicating a gap in the response list.","```
None.
```",0.0
NFTXStakingZap.sol,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";

// Authors: @0xKiwi_.

interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(msg.sender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    // Finish this.
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    // Return extras.
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    // Return extras.
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    // Transfer tokens to zap and mint to NFTX.
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); // We should not be experiencing fees.
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    // Provide liquidity.
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    // Stake in LP rewards contract 
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        // Fix here for frontrun attack. Added in v1.0.2.
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        // Default.
        // We push to the vault to avoid an unneeded transfer.
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        // Cryptokitties.
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        // CryptoPunks.
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      // No longer needed to approve with pushing.
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  // calculates the CREATE2 address for a pair without making any external calls
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash
    )))));
  }

  // returns sorted token addresses, used to handle return values from pairs sorted in this order
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}

",4828,479,"[M-08] Low-level call return value not checked

Submitted by cmichel
The NFTXStakingZap.addLiquidity721ETHTo function performs a low-level .call in payable(to).call{value: msg.value-amountEth} but does not check the return value if the call succeeded.
",1,,"pragma solidity ^0.8.0;

import ""./interface/INFTXVault.sol"";
import ""./interface/INFTXVaultFactory.sol"";
import ""./interface/INFTXSimpleFeeDistributor.sol"";
import ""./interface/INFTXLPStaking.sol"";
import ""./interface/INFTXInventoryStaking.sol"";
import ""./interface/ITimelockRewardDistributionToken.sol"";
import ""./interface/IUniswapV2Router01.sol"";
import ""./testing/IERC721.sol"";
import ""./token/IERC1155Upgradeable.sol"";
import ""./token/IERC20Upgradeable.sol"";
import ""./token/ERC721HolderUpgradeable.sol"";
import ""./token/ERC1155HolderUpgradeable.sol"";
import ""./util/OwnableUpgradeable.sol"";



interface IWETH {
  function deposit() external payable;
  function transfer(address to, uint value) external returns (bool);
  function withdraw(uint) external;
}


abstract contract ReentrancyGuard {
    
    
    
    
    

    
    
    
    
    
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    
    modifier nonReentrant() {
        
        require(_status != _ENTERED, ""ReentrancyGuard: reentrant call"");

        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}


abstract contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor() {
        _setOwner(msg.sender);
    }

    
    function owner() public view virtual returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(owner() == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    
    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

contract NFTXStakingZap is Ownable, ReentrancyGuard, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {
  IWETH public immutable WETH; 
  INFTXLPStaking public immutable lpStaking;
  INFTXInventoryStaking public immutable inventoryStaking;
  INFTXVaultFactory public immutable nftxFactory;
  IUniswapV2Router01 public immutable sushiRouter;

  uint256 public lpLockTime = 48 hours; 
  uint256 public inventoryLockTime = 7 days; 
  uint256 constant BASE = 10**18;

  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil, address sender);

  constructor(address _nftxFactory, address _sushiRouter) Ownable() ReentrancyGuard() {
    nftxFactory = INFTXVaultFactory(_nftxFactory);
    lpStaking = INFTXLPStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());
    inventoryStaking = INFTXInventoryStaking(INFTXSimpleFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).inventoryStaking());
    sushiRouter = IUniswapV2Router01(_sushiRouter);
    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());
    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);
  }

  function setLPLockTime(uint256 newLPLockTime) external onlyOwner {
    require(newLPLockTime <= 7 days, ""Lock too long"");
    lpLockTime = newLPLockTime;
  } 

  function setInventoryLockTime(uint256 newInventoryLockTime) external onlyOwner {
    require(newInventoryLockTime <= 14 days, ""Lock too long"");
    inventoryLockTime = newInventoryLockTime;
  }

  function provideInventory721(uint256 vaultId, uint256[] memory tokenIds) public {
    uint256 count = tokenIds.length;
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(xToken);
    uint256[] memory amounts = new uint256[](0);
    address assetAddress = vault.assetAddress();
    for (uint256 i = 0; i < tokenIds.length; i++) {
      transferFromERC721(assetAddress, tokenIds[i], address(vault));
      approveERC721(assetAddress, address(vault), tokenIds[i]);
    }
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(xToken);
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function provideInventory1155(uint256 vaultId, uint256[] memory tokenIds, uint256[] memory amounts) public {
    uint256 count;
    for (uint256 i = 0; i < tokenIds.length; i++) {
      count += amounts[i];
    }
    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));
    uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime);
    address xToken = inventoryStaking.vaultXToken(vaultId);
    uint256 oldBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    IERC1155Upgradeable nft = IERC1155Upgradeable(vault.assetAddress());
    nft.safeBatchTransferFrom(msg.sender, address(this), tokenIds, amounts, """");
    nft.setApprovalForAll(address(vault), true);
    vault.mintTo(tokenIds, amounts, address(xToken));
    uint256 newBal = IERC20Upgradeable(vault).balanceOf(address(xToken));
    require(newBal == oldBal + count*BASE, ""Incorrect vtokens minted"");
  }

  function addLiquidity721ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn
  ) public payable returns (uint256) {
    return addLiquidity721ETHTo(vaultId, ids, minWethIn, msg.sender);
  }

  function addLiquidity721ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity1155ETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn
  ) public payable returns (uint256) {
    return addLiquidity1155ETHTo(vaultId, ids, amounts, minEthIn, msg.sender);
  }

  function addLiquidity1155ETHTo(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256[] memory amounts,
    uint256 minEthIn,
    address to
  ) public payable nonReentrant returns (uint256) {
    WETH.deposit{value: msg.value}();
    
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value, to);

    
    if (amountEth < msg.value) {
      WETH.withdraw(msg.value-amountEth);
      payable(to).call{value: msg.value-amountEth};
    }

    return liquidity;
  }

  function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity721To(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

  function addLiquidity1155To(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) public nonReentrant returns (uint256) {
    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), wethIn);
    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn, to);

    
    if (amountEth < wethIn) {
      WETH.transfer(to, wethIn-amountEth);
    }

    return liquidity;
  }

  function _addLiquidity721WETH(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    for (uint256 i = 0; i < ids.length; i++) {
      transferFromERC721(assetAddress, ids[i], vault);
      approveERC721(assetAddress, vault, ids[i]);
    }
    uint256[] memory emptyIds;
    uint256 count = INFTXVault(vault).mint(ids, emptyIds);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidity1155WETH(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    address vault = nftxFactory.vault(vaultId);
    require(vault != address(0), ""NFTXZap: Vault does not exist"");

    
    address assetAddress = INFTXVault(vault).assetAddress();
    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, """");
    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);
    uint256 count = INFTXVault(vault).mint(ids, amounts);
    uint256 balance = (count * BASE); 
    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), ""Did not receive expected balance"");
    
    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn, to);
  }

  function _addLiquidityAndLock(
    uint256 vaultId, 
    address vault, 
    uint256 minTokenIn, 
    uint256 minWethIn, 
    uint256 wethIn,
    address to
  ) internal returns (uint256, uint256, uint256) {
    
    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);
    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(
      address(vault), 
      sushiRouter.WETH(),
      minTokenIn, 
      wethIn, 
      minTokenIn,
      minWethIn,
      address(this), 
      block.timestamp
    );

    
    address lpToken = pairFor(vault, address(WETH));
    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);
    lpStaking.timelockDepositFor(vaultId, to, liquidity, lpLockTime);
    
    if (amountToken < minTokenIn) {
      IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);
    }

    uint256 lockEndTime = block.timestamp + lpLockTime;
    emit UserStaked(vaultId, minTokenIn, liquidity, lockEndTime, to);
    return (amountToken, amountEth, liquidity);
  }

  function transferFromERC721(address assetAddr, uint256 tokenId, address to) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""transferFrom(address,address,uint256)"", msg.sender, address(this), tokenId);
    } else if (assetAddr == punks) {
        
        
        bytes memory punkIndexToAddress = abi.encodeWithSignature(""punkIndexToAddress(uint256)"", tokenId);
        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);
        (address owner) = abi.decode(result, (address));
        require(checkSuccess && owner == msg.sender, ""Not the owner"");
        data = abi.encodeWithSignature(""buyPunk(uint256)"", tokenId);
    } else {
        
        
        data = abi.encodeWithSignature(""safeTransferFrom(address,address,uint256)"", msg.sender, to, tokenId);
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {
    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;
    bytes memory data;
    if (assetAddr == kitties) {
        
        data = abi.encodeWithSignature(""approve(address,uint256)"", to, tokenId);
    } else if (assetAddr == punks) {
        
        data = abi.encodeWithSignature(""offerPunkForSaleToAddress(uint256,uint256,address)"", tokenId, 0, to);
    } else {
      
      return;
    }
    (bool success, bytes memory resultData) = address(assetAddr).call(data);
    require(success, string(resultData));
  }

  
  function pairFor(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = sortTokens(tokenA, tokenB);
    pair = address(uint160(uint256(keccak256(abi.encodePacked(
      hex'ff',
      sushiRouter.factory(),
      keccak256(abi.encodePacked(token0, token1)),
      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' 
    )))));
  }

  
  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
  }

  receive() external payable {

  }

  function rescue(address token) external onlyOwner {
    IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));
  }
}",3888,0,1,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call `setLPLockTime` and `setInventoryLockTime` functions."",
        ""Confirm that the `rescue` function can only be called by the owner."",
        ""Check that the `Ownable` contract is correctly initialized and that the owner is properly set during deployment."",
        ""Analyze the impact of renouncing ownership using `renounceOwnership` and ensure the contract's functionality remains secure and as intended after such action.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerabilities"",
      ""Tasks"": [
        ""Analyze all external calls within the `addLiquidity721ETHTo`, `addLiquidity1155ETHTo`, `addLiquidity721To`, and `addLiquidity1155To` functions to ensure that the `nonReentrant` modifier effectively prevents reentrancy attacks."",
        ""Specifically, examine the calls to `WETH.deposit`, `WETH.withdraw`, `payable(to).call{value: msg.value-amountEth}`, `IERC20Upgradeable(address(WETH)).transferFrom`, `WETH.transfer`, `sushiRouter.addLiquidity`, `lpStaking.timelockDepositFor`, and the token transfers in `transferFromERC721` for potential reentrancy issues."",
        ""Verify that no state variables are modified after the `_status = _ENTERED` line and before the `_status = _NOT_ENTERED` line in the `nonReentrant` modifier.""
      ]
    },
    {
      ""Area"": ""ERC721/ERC1155 Transfers and Approvals"",
      ""Tasks"": [
        ""Scrutinize the `transferFromERC721` function for correctness, especially the custom logic for CryptoPunks and CryptoKitties. Verify that the checks and transfers are performed securely and according to each project's specifications."",
        ""Analyze the `approveERC721` function and the custom logic for CryptoPunks and CryptoKitties. Confirm that approvals are handled correctly for each specific NFT contract."",
        ""Verify that ERC721 and ERC1155 tokens are safely transferred and approved to the correct contracts (Vault, this contract) using `safeTransferFrom` and `safeBatchTransferFrom` to prevent loss of tokens."",
        ""Ensure the `safeBatchTransferFrom` function is correctly used in `provideInventory1155` and `_addLiquidity1155WETH`."",
        ""Check if there is a potential issue if user does not approve the contract before calling `provideInventory721` and `provideInventory1155`.""
      ]
    },
    {
      ""Area"": ""Liquidity Provision and Staking"",
      ""Tasks"": [
        ""Examine the `_addLiquidityAndLock` function to ensure that the correct amount of liquidity is added to SushiSwap and that the resulting LP tokens are staked correctly in the `lpStaking` contract. Verify the approval and transfer of LP tokens."",
        ""Verify that the `minWethIn` and `minTokenIn` parameters in `_addLiquidityAndLock` are properly used to protect the user from excessive slippage."",
        ""Check the calculation of `liquidity` returned by `sushiRouter.addLiquidity` to ensure it's accurate and protects against manipulation."",
        ""Ensure that the `lpStaking.timelockDepositFor` function is called with the correct parameters and that the `lpLockTime` is respected."",
        ""Review the `provideInventory721` and `provideInventory1155` functions to verify the correct minting of xTokens and the staking process in the `inventoryStaking` contract."",
        ""Verify the calculation of `xTokensMinted` and the require statement checking `newBal` against `oldBal + count*BASE` in `provideInventory721` and `provideInventory1155`.""
      ]
    },
    {
      ""Area"": ""WETH Handling"",
      ""Tasks"": [
        ""Verify that the `WETH.deposit` and `WETH.withdraw` functions are used correctly to handle ETH deposits and withdrawals."",
        ""Ensure that any excess ETH sent to the contract is correctly returned to the user through `WETH.withdraw` and `payable(to).call{value: msg.value-amountEth}`. Investigate the usage of `call` instead of `transfer` and assess the associated risks."",
        ""Confirm that the `WETH` address is correctly initialized in the constructor and that the contract has sufficient allowance to spend WETH on SushiSwap."",
        ""Check for potential issues if the `to` address in the ETH refund is a contract that reverts the transaction. What happens to the excess ETH in this case?""
      ]
    },
    {
      ""Area"": ""Arithmetic Overflow/Underflow"",
      ""Tasks"": [
        ""Review all arithmetic operations for potential overflow or underflow issues, especially in calculations involving `count`, `BASE`, `amounts`, and `minWethIn`. Although Solidity 0.8.0+ has built-in overflow/underflow protection, it's still good practice to review."",
        ""Specifically, analyze the calculation of `balance = (count * BASE)` in `_addLiquidity721WETH` and `_addLiquidity1155WETH`."",
        ""Check that `lpLockTime` and `inventoryLockTime` values set using `setLPLockTime` and `setInventoryLockTime` don't lead to unintended consequences due to overflow in downstream calculations.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the code for potential gas optimizations, such as reducing the number of storage reads and writes, using more efficient data structures, and optimizing loop iterations."",
        ""Consider caching frequently accessed values in memory."",
        ""Explore ways to reduce the gas cost of the `transferFromERC721` and `approveERC721` functions, especially the custom logic for CryptoPunks and CryptoKitties."",
        ""Evaluate the gas cost of the `pairFor` and `sortTokens` functions and determine if they can be optimized.""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Verify that all external contract interactions (INFTXVault, INFTXVaultFactory, INFTXSimpleFeeDistributor, INFTXLPStaking, INFTXInventoryStaking, IUniswapV2Router01, IERC721, IERC1155Upgradeable, IERC20Upgradeable, IWETH) are secure and that the contract handles potential errors or unexpected responses from these contracts gracefully."",
        ""Check the return values of all external calls and ensure that they are properly validated."",
        ""Analyze the potential impact of changes or upgrades to the external contracts on the functionality of this contract."",
        ""Specifically, analyze the impact of changes to the fee structure in `INFTXSimpleFeeDistributor` on the LP staking and inventory staking processes."",
        ""Consider the security implications of relying on the SushiSwap router and factory contracts. Research known vulnerabilities and security best practices for interacting with AMMs.""
      ]
    },
    {
      ""Area"": ""Denial of Service (DoS)"",
      ""Tasks"": [
        ""Analyze the potential for DoS attacks, such as sending a large number of NFTs to the contract to exhaust its gas limit or manipulate its state."",
        ""Consider implementing safeguards to prevent users from sending excessive amounts of NFTs or calling functions with extremely large arrays."",
        ""Evaluate the gas cost of functions that iterate over arrays (`provideInventory721`, `provideInventory1155`, `_addLiquidity721WETH`, `_addLiquidity1155WETH`) and ensure they are within reasonable limits to prevent out-of-gas errors."",
        ""Investigate the impact of extremely large `ids` or `amounts` arrays on the gas consumption and execution time of these functions, and consider implementing limits or pagination to mitigate potential DoS attacks."",
        ""Evaluate the usage of `transferFromERC721` with CryptoPunks and CryptoKitties. A malicious actor could cause griefing by preventing transfers.""
      ]
    },
    {
      ""Area"": ""Logic Errors and Inconsistencies"",
      ""Tasks"": [
        ""Carefully review all functions for logic errors and inconsistencies, paying close attention to the flow of execution and the handling of different input parameters."",
        ""Ensure that the contract's state is updated correctly after each function call and that all invariants are maintained."",
        ""Verify the calculation of the LP token pair address using `pairFor` and ensure it matches the address calculated by the SushiSwap factory."",
        ""Double-check the logic for handling excess ETH and WETH refunds to users, ensuring that the correct amounts are withdrawn and transferred."",
        ""Review the event `UserStaked` emitted in `_addLiquidityAndLock` to ensure it accurately reflects the user's staking activity.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code implements a staking zap contract that allows users to provide liquidity to NFTX vaults and stake the resulting LP tokens. It supports both ERC721 and ERC1155 NFTs and handles the necessary approvals and transfers. The contract also features timelocked staking for both LP and inventory tokens and includes logic to handle CryptoPunks and CryptoKitties transfers."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""NFTXStakingZap"",
    ""Purpose"": ""The purpose of this contract is to simplify the process of providing liquidity to NFTX vaults and staking the resulting LP tokens. It supports both ERC721 and ERC1155 NFTs and includes mechanisms for timelocked staking rewards."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [""Ownable"", ""ReentrancyGuard"", ""ERC721HolderUpgradeable"", ""ERC1155HolderUpgradeable""],
      ""Imports"": [
        ""./interface/INFTXVault.sol"",
        ""./interface/INFTXVaultFactory.sol"",
        ""./interface/INFTXSimpleFeeDistributor.sol"",
        ""./interface/INFTXLPStaking.sol"",
        ""./interface/INFTXInventoryStaking.sol"",
        ""./interface/ITimelockRewardDistributionToken.sol"",
        ""./interface/IUniswapV2Router01.sol"",
        ""./testing/IERC721.sol"",
        ""./token/IERC1155Upgradeable.sol"",
        ""./token/IERC20Upgradeable.sol"",
        ""./token/ERC721HolderUpgradeable.sol"",
        ""./token/ERC1155HolderUpgradeable.sol"",
        ""./util/OwnableUpgradeable.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""WETH"",
        ""Type"": ""IWETH"",
        ""Purpose"": ""Address of the WETH contract.""
      },
      {
        ""Name"": ""lpStaking"",
        ""Type"": ""INFTXLPStaking"",
        ""Purpose"": ""Address of the NFTX LP staking contract.""
      },
      {
        ""Name"": ""inventoryStaking"",
        ""Type"": ""INFTXInventoryStaking"",
        ""Purpose"": ""Address of the NFTX Inventory staking contract.""
      },
      {
        ""Name"": ""nftxFactory"",
        ""Type"": ""INFTXVaultFactory"",
        ""Purpose"": ""Address of the NFTX Vault Factory contract.""
      },
      {
        ""Name"": ""sushiRouter"",
        ""Type"": ""IUniswapV2Router01"",
        ""Purpose"": ""Address of the SushiSwap Router contract.""
      },
      {
        ""Name"": ""lpLockTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The duration for which LP tokens are locked when staked. Defaults to 48 hours.""
      },
      {
        ""Name"": ""inventoryLockTime"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The duration for which inventory tokens are locked when staked. Defaults to 7 days.""
      },
      {
        ""Name"": ""BASE"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant value representing 10**18, used for calculations.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract with the addresses of the NFTX Factory and SushiSwap Router."",
        ""Parameters"": [""address _nftxFactory"", ""address _sushiRouter""],
        ""Returns"": []
      },
      {
        ""Name"": ""setLPLockTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set the LP lock time."",
        ""Parameters"": [""uint256 newLPLockTime""],
        ""Returns"": [],
        ""Modifier"": ""onlyOwner""
      },
      {
        ""Name"": ""setInventoryLockTime"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to set the inventory lock time."",
        ""Parameters"": [""uint256 newInventoryLockTime""],
        ""Returns"": [],
        ""Modifier"": ""onlyOwner""
      },
      {
        ""Name"": ""provideInventory721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Provides ERC721 inventory to the vault and stakes the resulting xTokens."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory tokenIds""],
        ""Returns"": []
      },
      {
        ""Name"": ""provideInventory1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Provides ERC1155 inventory to the vault and stakes the resulting xTokens."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory tokenIds"", ""uint256[] memory amounts""],
        ""Returns"": []
      },
      {
        ""Name"": ""addLiquidity721ETH"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds liquidity to the vault's ETH pool with ERC721 NFTs, sending any excess ETH back to msg.sender."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethIn""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity721ETHTo"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds liquidity to the vault's ETH pool with ERC721 NFTs, sending any excess ETH back to a specified address."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethIn"", ""address to""],
        ""Returns"": [""uint256 liquidity""],
        ""Modifier"": ""nonReentrant""
      },
      {
        ""Name"": ""addLiquidity1155ETH"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds liquidity to the vault's ETH pool with ERC1155 NFTs, sending any excess ETH back to msg.sender."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minEthIn""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155ETHTo"",
        ""Visibility"": ""public payable"",
        ""Purpose"": ""Adds liquidity to the vault's ETH pool with ERC1155 NFTs, sending any excess ETH back to a specified address."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minEthIn"", ""address to""],
        ""Returns"": [""uint256 liquidity""],
        ""Modifier"": ""nonReentrant""
      },
      {
        ""Name"": ""addLiquidity721"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to the vault's WETH pool with ERC721 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethIn"", ""uint256 wethIn""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity721To"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to the vault's WETH pool with ERC721 NFTs, sending any excess WETH back to a specified address."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethIn"", ""uint256 wethIn"", ""address to""],
        ""Returns"": [""uint256 liquidity""],
        ""Modifier"": ""nonReentrant""
      },
      {
        ""Name"": ""addLiquidity1155"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to the vault's WETH pool with ERC1155 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minWethIn"", ""uint256 wethIn""],
        ""Returns"": [""uint256 liquidity""]
      },
      {
        ""Name"": ""addLiquidity1155To"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Adds liquidity to the vault's WETH pool with ERC1155 NFTs, sending any excess WETH back to a specified address."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minWethIn"", ""uint256 wethIn"", ""address to""],
        ""Returns"": [""uint256 liquidity""],
        ""Modifier"": ""nonReentrant""
      },
      {
        ""Name"": ""_addLiquidity721WETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle adding liquidity with ERC721 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256 minWethIn"", ""uint256 wethIn"", ""address to""],
        ""Returns"": [""uint256"", ""uint256"", ""uint256""]
      },
      {
        ""Name"": ""_addLiquidity1155WETH"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to handle adding liquidity with ERC1155 NFTs."",
        ""Parameters"": [""uint256 vaultId"", ""uint256[] memory ids"", ""uint256[] memory amounts"", ""uint256 minWethIn"", ""uint256 wethIn"", ""address to""],
        ""Returns"": [""uint256"", ""uint256"", ""uint256""]
      },
      {
        ""Name"": ""_addLiquidityAndLock"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal function to add liquidity to SushiSwap and then stake the resulting LP tokens."",
        ""Parameters"": [""uint256 vaultId"", ""address vault"", ""uint256 minTokenIn"", ""uint256 minWethIn"", ""uint256 wethIn"", ""address to""],
        ""Returns"": [""uint256"", ""uint256"", ""uint256""]
      },
      {
        ""Name"": ""transferFromERC721"",
        ""Visibility"": ""internal virtual"",
        ""Purpose"": ""Handles the transfer of ERC721 tokens, with special logic for CryptoPunks and CryptoKitties."",
        ""Parameters"": [""address assetAddr"", ""uint256 tokenId"", ""address to""],
        ""Returns"": []
      },
      {
        ""Name"": ""approveERC721"",
        ""Visibility"": ""internal virtual"",
        ""Purpose"": ""Handles the approval of ERC721 tokens, with special logic for CryptoPunks and CryptoKitties."",
        ""Parameters"": [""address assetAddr"", ""address to"", ""uint256 tokenId""],
        ""Returns"": []
      },
      {
        ""Name"": ""pairFor"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Calculates the address of the LP token pair."",
        ""Parameters"": [""address tokenA"", ""address tokenB""],
        ""Returns"": [""address pair""]
      },
      {
        ""Name"": ""sortTokens"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Sorts two token addresses to ensure consistent pair address calculation."",
        ""Parameters"": [""address tokenA"", ""address tokenB""],
        ""Returns"": [""address token0"", ""address token1""]
      },
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows the contract to receive ETH."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""rescue"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to withdraw any accidentally sent tokens from the contract."",
        ""Parameters"": [""address token""],
        ""Returns"": [],
        ""Modifier"": ""onlyOwner""
      }
    ]
  },
  ""ExternalInteractions"": [
    ""INFTXVault"",
    ""INFTXVaultFactory"",
    ""INFTXSimpleFeeDistributor"",
    ""INFTXLPStaking"",
    ""INFTXInventoryStaking"",
    ""ITimelockRewardDistributionToken"",
    ""IUniswapV2Router01 (SushiSwap)"",
    ""IERC721"",
    ""IERC1155Upgradeable"",
    ""IERC20Upgradeable"",
    ""IWETH""
  ],
  ""SpecialMechanisms"": [
    ""ReentrancyGuard modifier to prevent reentrancy attacks."",
    ""Ownable contract to manage ownership and administrative privileges."",
    ""Custom logic for handling CryptoPunks and CryptoKitties ERC721 transfers and approvals."",
    ""Timelocked LP and inventory staking."",
    ""The contract uses the `call` function to send excess ETH back to the user. This is generally less safe than `transfer`, but is needed in case the receiving address is a contract without a receive function.""
  ],
  ""Questions"": [
    ""Why does `approveERC721` have a `return;` statement within the `else` block rather than calling the standard ERC721 `approve` function?"",
    ""The contract interacts with SushiSwap V2. Is there a plan to update it to more recent versions of the protocol?"",
    ""Is there a mechanism to handle potential griefing attacks where someone sends NFTs to the contract to prevent it from operating normally?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy in `transferFromERC721` and `approveERC721` due to external calls to ERC721 contracts."",
      ""Severity"": ""High"",
      ""Description"": ""The `transferFromERC721` and `approveERC721` functions perform external calls to ERC721 contracts using `address(assetAddr).call(data)`. While the primary functions are protected by `nonReentrant`, malicious ERC721 contracts (or CryptoPunks/Kitties) with callbacks could re-enter, bypassing the guard and causing unexpected state changes, loss of funds, or theft of funds. Handling of CryptoPunks via `buyPunk` and CryptoKitties via non-standard `transferFrom` increases the risk."",
      ""Impact"": ""A reentrancy attack could lead to unexpected state changes, loss of funds, or other security breaches."",
      ""Location"": ""NFTXStakingZap.sol:transferFromERC721 and NFTXStakingZap.sol:approveERC721, `transferFromERC721` function, `approveERC721` function""
    },
    {
      ""Issue"": ""Unprotected `transferFromERC721` function for CryptoPunks and CryptoKitties"",
      ""Severity"": ""High"",
      ""Description"": ""The `transferFromERC721` function has specific logic for CryptoPunks and CryptoKitties, using `buyPunk` (without transferring ownership or accounting for the punk's value) and `transferFrom(address,address,uint256)` with `address(this)` respectively. This bypasses intended ownership transfer processes, potentially allowing unauthorized transfers and malfunctioning logic."",
      ""Impact"": ""Potential for unauthorized transfer of CryptoPunks, potentially leading to a loss of funds for the NFT owner. Malfunctioning CryptoKitties logic."",
      ""Location"": ""Function `transferFromERC721`""
    },
    {
      ""Issue"": ""Incorrect transfer of ERC721 tokens in `transferFromERC721`"",
      ""Severity"": ""High"",
      ""Description"": ""In `transferFromERC721`, the `transferFrom` function of the NFT contract is called using `address(assetAddr).call(data)`. This approach is vulnerable to issues due to different ERC721 implementations. Consider using the IERC721 interface and calling `safeTransferFrom`. The code assumes that the caller has approved the NFTXStakingZap contract to spend the tokens. If the spender is not approved the transferFrom will fail. There should be a check for approval prior to token transfer."",
      ""Impact"": ""NFT tokens might be lost if the transfer fails or the contract assumes ownership without proper authorization."",
      ""Location"": ""NFTXStakingZap.transferFromERC721""
    },
    {
      ""Issue"": ""Directly Calling `payable(to).call{value: msg.value-amountEth}`"",
      ""Severity"": ""High"",
      ""Description"": ""In functions `addLiquidity721ETHTo` and `addLiquidity1155ETHTo`, any remaining ETH (msg.value - amountEth) after adding liquidity is sent directly to the user-supplied `to` address using `payable(to).call{value: msg.value-amountEth}()`. This is extremely dangerous because it gives the recipient contract the opportunity to execute arbitrary code within the context of the `NFTXStakingZap` contract."",
      ""Impact"": ""Critical security vulnerability that could allow an attacker to drain all funds from the contract or take control of its state."",
      ""Location"": ""NFTXStakingZap.sol: `addLiquidity721ETHTo` and `addLiquidity1155ETHTo` functions""
    },
    {
      ""Issue"": ""Missing slippage protection on addLiquidity functions can lead to loss of funds"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addLiquidity*` functions rely on `sushiRouter.addLiquidity` but lack sufficient slippage protection. Only `minWethIn` and `minTokenIn` are specified, without checks on LP tokens received. Price changes between transaction submission and execution can lead to users receiving fewer LP tokens than expected, resulting in losses."",
      ""Impact"": ""Loss of funds for users providing liquidity due to slippage."",
      ""Location"": ""_addLiquidityAndLock function, calls to sushiRouter.addLiquidity in functions `addLiquidity721ETHTo`, `addLiquidity1155ETHTo`, `addLiquidity721To`, and `addLiquidity1155To`, Functions: `addLiquidity721ETH`, `addLiquidity1155ETH`, `addLiquidity721`, `addLiquidity1155`, `_addLiquidityAndLock`, NFTXStakingZap._addLiquidity721WETH, NFTXStakingZap._addLiquidity1155WETH, NFTXStakingZap._addLiquidityAndLock, Functions: `addLiquidity721ETH`, `addLiquidity721ETHTo`, `addLiquidity1155ETH`, `addLiquidity1155ETHTo`, `addLiquidity721`, `addLiquidity721To`, `addLiquidity1155`, `addLiquidity1155To`""
    },
    {
      ""Issue"": ""Missing check success in approveERC721"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `approveERC721` calls the `assetAddr` contract to approve the NFT to a given address. The `success` variable is checked. However, there is no validation of the `resultData`. This means that if the call fails, and returns some data, the transaction will proceed even though the approval may not have been set."",
      ""Impact"": ""The approval may not be set on the NFT, but the transaction will proceed. The user can lose assets."",
      ""Location"": ""approveERC721 function""
    },
    {
      ""Issue"": ""Potential vulnerability due to ERC1155 `setApprovalForAll`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `provideInventory1155` and `_addLiquidity1155WETH` functions call `nft.setApprovalForAll(address(vault), true)`. While intention is to approve the vault to transfer the user's assets, calling setApprovalForAll can potentially open up unexpected attack vectors if vault address is compromised or has any vulnerability that can be exploited. Also, after the operation, the contract is still approved to use the users assets. There should be a function which removes the approval to transfer the user's ERC1155 tokens after some time period or after tokens have been transferred."",
      ""Impact"": ""If `vault` contract is compromised, it can drain user's assets."",
      ""Location"": ""`provideInventory1155` and `_addLiquidity1155WETH` functions""
    },
    {
      ""Issue"": ""Unprotected `approveERC721` for Cryptopunks and Cryptokitties."",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `approveERC721` has specific logic for CryptoPunks and CryptoKitties. For CryptoPunks, it calls `offerPunkForSaleToAddress` with the price set to zero, effectively transferring ownership to the vault. This function doesn't check that contract owns the cryptoKitty or punk before calling approve, allowing anyone to set approval through functions."",
      ""Impact"": ""Potential loss of CryptoPunks/CryptoKitties assets due to unintended transfer of ownership by setting the price to 0."",
      ""Location"": ""Function: `approveERC721`""
    },
    {
      ""Issue"": ""Missing input validation in `provideInventory1155`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The function `provideInventory1155` lacks validation of the `tokenIds` and `amounts` array lengths. Different lengths can cause out-of-bounds access or reverts. Also, missing to check msg.sender approval can cause batch transfer failures."",
      ""Impact"": ""Unexpected behavior or failure if tokenIds and amounts arrays have mismatched lengths. The contract might try to transfer more tokens than specified or mint an incorrect amount of vTokens."",
      ""Location"": ""Function `provideInventory1155`, Function: `provideInventory1155`, NFTXStakingZap.sol: `provideInventory1155` and `_addLiquidity1155WETH`""
    },
    {
      ""Issue"": ""Missing zero address check in constructor for _nftxFactory and _sushiRouter"",
      ""Severity"": ""Medium"",
      ""Description"": ""The constructor of `NFTXStakingZap` does not check if `_nftxFactory` and `_sushiRouter` are non-zero addresses. If either of these addresses is the zero address, the contract will be unusable and potentially bricked as core functionality will fail."",
      ""Impact"": ""Contract can be rendered unusable if deployed with invalid factory or router address. Dependent functionalities like providing inventory and adding liquidity will fail."",
      ""Location"": ""NFTXStakingZap.constructor, NFTXStakingZap.sol:47""
    },
    {
      ""Issue"": ""Missing validation for `vaultId` across multiple functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""Several functions rely on `vaultId` to fetch the vault address from `nftxFactory`, without verifying its validity. Using an invalid `vaultId` can lead to unexpected behavior and potential reverts after tokens have been transferred to the contract."",
      ""Impact"": ""Potential for wasted gas and unexpected reverts if an invalid vaultId is used."",
      ""Location"": ""NFTXStakingZap.provideInventory721, NFTXStakingZap.provideInventory1155, NFTXStakingZap.addLiquidity721ETHTo, NFTXStakingZap.addLiquidity1155ETHTo, NFTXStakingZap.addLiquidity721To, NFTXStakingZap.addLiquidity1155To, Functions: `provideInventory721`, `provideInventory1155`, `addLiquidity721ETH`, `addLiquidity721ETHTo`, `addLiquidity1155ETH`, `addLiquidity1155ETHTo`, `addLiquidity721`, `addLiquidity721To`, `addLiquidity1155`, `addLiquidity1155To`""
    },
    {
      ""Issue"": ""Incorrect ERC721 Transfer Handling for CryptoPunks"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferFromERC721` function contains specific logic for CryptoPunks, attempting to determine ownership using `punkIndexToAddress` via `staticcall`. This assumes that the call will always succeed and return the correct owner. However, there are situations where `staticcall` might fail (e.g., due to contract upgrades or unforeseen issues in the CryptoPunks contract), or the returned address might not be the actual owner due to internal contract logic changes. Also, the logic for buying a punk using `buyPunk` does not account for the value of the punk. The function assumes that the user will always buy the punk at zero ETH. It is possible the user needs to send value along with the transaction."",
      ""Impact"": ""Potential for failed transactions or incorrect ownership verification when interacting with CryptoPunks, potential for theft of punk asset."",
      ""Location"": ""transferFromERC721 function, CryptoPunks handling""
    },
    {
      ""Issue"": ""Missing Approval Check for ERC1155 Tokens"",
      ""Severity"": ""Medium"",
      ""Description"": ""In `provideInventory1155`, after transferring ERC1155 tokens, the code calls `nft.setApprovalForAll(address(vault), true)` without verifying if the user already approved the contract. This will block user from providing Inventory and vtokens won't be minted."",
      ""Impact"": ""Providing inventory for ERC1155 tokens might fail if the vault wasn't already approved."",
      ""Location"": ""NFTXStakingZap.provideInventory1155, Function: `provideInventory1155`""
    },
    {
      ""Issue"": ""Unchecked Call Return Value in `transferFromERC721` and `approveERC721`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferFromERC721` and `approveERC721` functions use `address(assetAddr).call(data)` to interact with ERC721 contracts. The return value of `.call()` is a boolean indicating success or failure, but the code only checks `success` and then uses `string(resultData)` in the `require` statement. This is problematic because a malicious or faulty ERC721 contract can return `success = true` but also return error data in `resultData`, causing the `require` statement to revert with unexpected or misleading error messages. More importantly, it does not properly handle the case where `success = false`, which can lead to unexpected behavior and potential vulnerabilities."",
      ""Impact"": ""Unexpected reverts with unclear error messages. Potential for incorrect state updates if the external call fails without being properly handled. A malicious NFT contract could exploit this by returning incorrect data or by causing the `call` to fail in unexpected ways."",
      ""Location"": ""NFTXStakingZap.sol: `transferFromERC721` function and `approveERC721` function""
    },
    {
      ""Issue"": ""Potential loss of funds due to incorrect WETH handling in addLiquidity functions."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `addLiquidity...ETH` functions first deposit msg.value into WETH, then call the internal `_addLiquidity...WETH` functions. Afterwards, they withdraw any unused ETH (msg.value - amountEth).  Then they make a direct payable call to the receiver to refund ETH. If the receiver is a smart contract, there is a risk that this contract could revert the transaction."",
      ""Impact"": ""Users could lose ETH due to failed transactions when the payable receiver reverts the send."",
      ""Location"": ""NFTXStakingZap.sol:addLiquidity721ETHTo and NFTXStakingZap.sol:addLiquidity1155ETHTo""
    },
    {
      ""Issue"": ""Lack of slippage control in `transferFromERC721` for CryptoPunks buyPunk function."",
      ""Severity"": ""Medium"",
      ""Description"": ""When handling CryptoPunks in `transferFromERC721`, the contract calls `buyPunk(tokenId)` after verifying the msg.sender owns the punk. However, there\'s no price check or slippage control in the `buyPunk` call. A malicious actor could manipulate the Punk\'s price and cause the contract to buy the punk at an inflated price, effectively draining the contract\'s ETH balance."",
      ""Impact"": ""The contract could potentially overpay for a CryptoPunk, resulting in a loss of funds."",
      ""Location"": ""NFTXStakingZap.sol:transferFromERC721""
    },
    {
      ""Issue"": ""Potential Reentrancy Risk in `transferFromERC721` and `approveERC721` with ERC721 contracts lacking standard behavior."",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `transferFromERC721` and `approveERC721` make external calls to ERC721 contracts using `address(assetAddr).call(data)`.  While `ReentrancyGuard` is used on the main liquidity providing functions, this low-level call bypasses the guard, opening the possibility for reentrancy if the ERC721 contract maliciously calls back into the `NFTXStakingZap` contract."",
      ""Impact"": ""A malicious or vulnerable ERC721 contract could re-enter the `NFTXStakingZap` during a transfer or approval, leading to unexpected state changes, denial of service, or theft of funds."",
      ""Location"": ""`transferFromERC721` function, `approveERC721` function""
    },
     {
      ""Issue"": ""Missing Input Validation in `provideInventory721`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `provideInventory721` function does not validate if the caller actually owns the ERC721 tokens they are providing to the vault. A malicious user could potentially grief the vault by providing NFTs that they do not own."",
      ""Impact"": ""Potential griefing of vault functionality. Although the `transferFromERC721` function is called, the vulnerability lies in the lack of an explicit ownership check prior to the transfer attempt. This could be exploited if `transferFromERC721` is bypassed or doesn't function as expected."",
      ""Location"": ""NFTXStakingZap.sol:104""
    },
    {
      ""Issue"": ""Missing Input Validation in `provideInventory1155`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `provideInventory1155` function does not validate if the caller actually owns the ERC1155 tokens they are providing to the vault. A malicious user could potentially grief the vault by attempting to provide NFTs that they do not own."",
      ""Impact"": ""Potential griefing of vault functionality. Similar to ERC721, the lack of pre-transfer ownership checks allows potential exploitation if `safeBatchTransferFrom` is circumvented or doesn't behave as intended."",
      ""Location"": ""NFTXStakingZap.sol:118""
    },
    {
      ""Issue"": ""Lack of Access Control on critical parameters"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract allows setting the `lpLockTime` and `inventoryLockTime`. While these are restricted to the `onlyOwner` modifier, excessively long lock times could negatively impact users who stake their LP or Inventory tokens. If these parameters are set to the maximum values (7 days for LP and 14 days for Inventory) without users being aware, it could cause a bad user experience as their funds will be locked for an extended period."",
      ""Impact"": ""Potentially poor user experience if lock times are configured inappropriately."",
      ""Location"": ""setLPLockTime and setInventoryLockTime functions""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `provideInventory721` and `provideInventory1155`"",
      ""Severity"": ""Low"",
      ""Description"": ""In `provideInventory721` and `provideInventory1155`, the calculation `count * BASE` (where BASE = 10**18) could potentially lead to an integer overflow if `count` is sufficiently large, despite using solidity version 0.8.0 and higher which defaults to checked arithmetic."",
      ""Impact"": ""Incorrect calculation of `xTokensMinted` potentially affecting the amount of rewards received and leading to unexpected behavior."",
      ""Location"": ""NFTXStakingZap.sol: provideInventory721 and provideInventory1155 functions""
    },
    {
      ""Issue"": ""Lack of WETH approval check before deposit"",
      ""Severity"": ""Low"",
      ""Description"": ""While the constructor approves the `sushiRouter` for spending the `WETH` token, there's no check to ensure that the user has approved the `NFTXStakingZap` contract to transfer the `WETH` tokens they want to use for adding liquidity in `addLiquidity721` and `addLiquidity1155` functions."",
      ""Impact"": ""Users will need to approve the `NFTXStakingZap` contract to spend their WETH tokens before calling `addLiquidity721` or `addLiquidity1155`, resulting in a slightly worse user experience."",
      ""Location"": ""Functions: `addLiquidity721`, `addLiquidity1155`""
    },
     {
      ""Issue"": ""Unsafe usage of `call` with ETH transfer"",
      ""Severity"": ""Low"",
      ""Description"": ""In `addLiquidity721ETHTo` and `addLiquidity1155ETHTo`, the contract attempts to return excess ETH using `payable(to).call{value: msg.value-amountEth}`. This method does not check the return value of `call`, potentially leading to silent failures if the recipient is a contract that rejects ETH transfers."",
      ""Impact"": ""ETH may be burned if the recipient contract reverts, resulting in loss of funds for the user. Error conditions would not be properly handled."",
      ""Location"": ""NFTXStakingZap.addLiquidity721ETHTo, NFTXStakingZap.addLiquidity1155ETHTo""
    },
    {
      ""Issue"": ""Hardcoded Addresses for Cryptopunks and Cryptokitties"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract relies on hardcoded addresses for CryptoPunks and CryptoKitties in `transferFromERC721` and `approveERC721`. This makes the contract inflexible and difficult to update if these addresses change or if support for other NFT collections is desired.  There's also no validation that the asset address actually *is* an ERC721 contract or that the `data` calls will work."",
      ""Impact"": ""Limited support for different types of NFTs, potential for issues if hardcoded addresses become invalid."",
      ""Location"": ""NFTXStakingZap.transferFromERC721, NFTXStakingZap.approveERC721, NFTXStakingZap.sol:286, NFTXStakingZap.sol:314""
    },
    {
      ""Issue"": ""Lack of control over WETH approval amount for SushiRouter"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor approves the `sushiRouter` for `type(uint256).max` amount of WETH. While this is convenient, it grants the router unlimited access to the contract\'s WETH balance, which might be a security risk if the router contract is compromised."",
      ""Impact"": ""Potential risk of WETH being drained from the contract if `sushiRouter` is compromised."",
      ""Location"": ""NFTXStakingZap.constructor""
    },
     {
      ""Issue"": ""Missing check for success when calling WETH.deposit()"",
      ""Severity"": ""Low"",
      ""Description"": ""The `addLiquidity721ETHTo` and `addLiquidity1155ETHTo` functions call `WETH.deposit{value: msg.value}()`. This could potentially fail. It would be much safer to check that the call to `WETH.deposit{value: msg.value}()` succeeded."",
      ""Impact"": ""Transaction could revert if the WETH deposit fails."",
      ""Location"": ""Functions: `addLiquidity721ETHTo`, `addLiquidity1155ETHTo`""
    },
    {
      ""Issue"": ""approveERC721 only handles kitties and punks"",
      ""Severity"": ""Low"",
      ""Description"": ""The `approveERC721` function contains special logic for kitties and punks. However, the `else` condition is empty and returns if it is not kitties or punks. It should have logic like `IERC721(assetAddr).approve(to, tokenId)` or `IERC721(assetAddr).setApprovalForAll(to, true)`."",
      ""Impact"": ""Token approval will not work for ERC721s other than kitties and punks"",
      ""Location"": ""Functions: `approveERC721`""
    },
    {
      ""Issue"": ""Unprotected Rescue Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `rescue` function allows the owner to transfer any ERC20 tokens held by the contract to the owner\'s address. While this provides a mechanism for recovering accidentally sent tokens, it could be misused by a malicious owner to drain funds from the contract, especially if the contract interacts with other protocols or holds significant token balances besides the intended WETH/vToken."",
      ""Impact"": ""Potential for owner to drain tokens sent to the contract by mistake or design."",
      ""Location"": ""rescue function""
    },
     {
      ""Issue"": ""ERC1155 setApprovalForAll is called without checking if it's already approved"",
      ""Severity"": ""Low"",
      ""Description"": ""The code unconditionally calls `nft.setApprovalForAll(address(vault), true);` in the `provideInventory1155` and `_addLiquidity1155WETH` function. This may lead to unnecessary gas consumption if the approval is already set."",
      ""Impact"": ""Slight increase in gas cost. Not a major security concern."",
      ""Location"": ""Functions `provideInventory1155` and `_addLiquidity1155WETH`""
    },
    {
      ""Issue"": ""Missing check for zero amounts in `provideInventory1155` and `addLiquidity1155*` Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `provideInventory1155`, `addLiquidity1155ETH` and `addLiquidity1155` receive arrays of `ids` and `amounts`. If all values in `amounts` are zeros, `count` will be zero, the vault will mint `0` vTokens. However, the functions proceed to call `timelockMintFor` on `inventoryStaking` and `_addLiquidityAndLock`, which might lead to unexpected behavior or gas wastage."",
      ""Impact"": ""Possible gas wastage, unexpected behaviour, and the potential to bypass certain checks due to zero values."",
      ""Location"": ""NFTXStakingZap.sol: `provideInventory1155`, `addLiquidity1155ETH`, `addLiquidity1155` functions""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `provideInventory721` and `provideInventory1155` functions when computing `count*BASE`"",
      ""Severity"": ""Low"",
      ""Description"": ""In `provideInventory721` and `provideInventory1155`, `count*BASE` is used to determine the amount of tokens to mint. If `count` is sufficiently large, the multiplication with `BASE` (10**18) could potentially lead to an integer overflow, resulting in a smaller-than-expected value."",
      ""Impact"": ""Incorrect calculation of vToken minting amount. The check `require(newBal == oldBal + count*BASE, \\\""Incorrect vtokens minted\\\"")` could pass even if the expected amount of vTokens wasn't minted."",
      ""Location"": ""NFTXStakingZap.sol: `provideInventory721`, `provideInventory1155`""
    },
    {
      ""Issue"": ""Potential precision loss with `count*BASE` calculation in `provideInventory` functions"",
      ""Severity"": ""Low"",
      ""Description"": ""In `provideInventory721` and `provideInventory1155`, `count*BASE` is used in the call to `inventoryStaking.timelockMintFor`. If `count` is very large, this could potentially lead to an overflow or precision loss. "",
      ""Impact"": ""Slightly lower `xTokensMinted` values, resulting in the user receiving less rewards. High `count` values may result in unexpected behavior."",
      ""Location"": ""Functions: `provideInventory721`, `provideInventory1155`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `provideInventory1155` Count Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The `count` calculation in `provideInventory1155` iterates and adds `amounts[i]` to the `count` variable. While Solidity 0.8.0 and later have built-in overflow/underflow protection, it's good practice to explicitly check the total count does not exceed a safe maximum, as large counts can lead to unexpected reverts elsewhere in the transaction due to exceeding gas limits."",
      ""Impact"": ""Potential for denial of service if the total count is excessively large."",
      ""Location"": ""Function: `provideInventory1155`""
    },
    {
      ""Issue"": ""Inconsistent Approval Handling in `transferFromERC721` and `approveERC721` for CryptoPunks"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferFromERC721` function uses `buyPunk(uint256)` for CryptoPunks, which transfers ownership. The `approveERC721` function uses `offerPunkForSaleToAddress(uint256,uint256,address)`, but sets the price to 0. This means that `approveERC721` does not work as intended for CryptoPunks, as the CryptoPunk is being offered for free sale."",
      ""Impact"": ""Unexpected behavior when handling CryptoPunks, potentially leading to incorrect token transfers or stuck tokens."",
      ""Location"": ""Functions: `transferFromERC721`, `approveERC721`""
    },
    {
      ""Issue"": ""Potential Front-Running Risk in Liquidity Addition Functions."",
      ""Severity"": ""Low"",
      ""Description"": ""The `addLiquidity...` functions accept `minWethIn` as an argument but do not have sufficient checks to prevent front-running. A malicious actor could observe a transaction and increase the price of the LP tokens, causing the transaction to fail the `minWethIn` check, wasting the user\'s gas."",
      ""Impact"": ""Users may experience failed transactions and wasted gas due to front-running attacks."",
      ""Location"": ""All `addLiquidity...` functions""
    },
    {
      ""Issue"": ""Missing Input Validation in `provideInventory1155` Function."",
      ""Severity"": ""Low"",
      ""Description"": ""The `provideInventory1155` function does not adequately validate the lengths of the `tokenIds` and `amounts` arrays."",
      ""Impact"": ""A user could unintentionally or maliciously trigger an out-of-bounds read, potentially leading to unexpected behavior or contract failure. "",
      ""Location"": ""`provideInventory1155` function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow Risk."",
      ""Severity"": ""Low"",
      ""Description"": ""Although the contract uses Solidity 0.8.0 which has built-in overflow/underflow protection, there are a few spots where unchecked arithmetic may improve gas efficiency at the risk of introducing errors with future Solidity compilers."",
      ""Impact"": ""Incorrect calculation of WETH to withdraw or transfer, potentially leading to loss of funds or unexpected behavior."",
      ""Location"": ""`addLiquidity721ETHTo`, `addLiquidity1155ETHTo`, `addLiquidity721To`, and `addLiquidity1155To` functions.""
    },
    {
      ""Issue"": ""Insufficient Error Handling in External Calls"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `.call` for external calls in `transferFromERC721` and `approveERC721`. While it checks `success`, the `resultData` from the call, which contains error messages, is only used in the `require` statement."",
      ""Impact"": ""Difficult to debug failed transactions due to lack of informative error messages."",
      ""Location"": ""`transferFromERC721`, `approveERC721` functions""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `addLiquidity*ETH` Functions"",
      ""Severity"": ""Low"",
      ""Description"": ""In functions `addLiquidity721ETH(To)` and `addLiquidity1155ETH(To)`, `minWethIn` is an argument controlled by the user. If a malicious user sees a transaction to add liquidity, they can front-run that transaction with a slightly lower `wethIn` value to cause the original transaction to fail the `sushiRouter.addLiquidity` check (`minWethIn` check)."",
      ""Impact"": ""Denial of service or griefing for users attempting to add liquidity."",
      ""Location"": ""Functions: `addLiquidity721ETH`, `addLiquidity721ETHTo`, `addLiquidity1155ETH`, `addLiquidity1155ETHTo`""
    },
    {
      ""Issue"": ""Missing check for zero address in constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor takes the addresses of `_nftxFactory` and `_sushiRouter` as arguments. There is no check to ensure that these addresses are not the zero address. If either of these addresses is the zero address, the contract will likely function incorrectly and may be vulnerable to attacks."",
      ""Impact"": ""Contract may not function as intended, leading to loss of funds or other unexpected behavior."",
      ""Location"": ""NFTXStakingZap.sol:47""
    },
    {
      ""Issue"": ""Approval of WETH to SushiRouter without allowance check"",
      ""Severity"": ""Info"",
      ""Description"": ""The constructor approves WETH to the SushiRouter for `type(uint256).max`. This is generally safe but could be slightly more gas efficient if the code first checked if the approval was already set. If it already is set, the transaction would cost less gas."",
      ""Impact"": ""Minor gas inefficiency."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Incorrect comment in `transferFromERC721`"",
      ""Severity"": ""Info"",
      ""Description"": ""For CryptoPunks, there is a comment `// Check that you own the punk`.  The implemented logic checks the punkIndexToAddress to see if the msg.sender is the owner.  If not, the require statement will throw an error.  If the check is successful, the `buyPunk` function is called. However, `buyPunk` is deprecated. You should use `transferPunk` instead. The `transferPunk` function requires you to be the owner of the punk."",
      ""Impact"": ""The `transferFromERC721` function will always revert for CryptoPunks because the `buyPunk` function is deprecated and `transferPunk` should be used instead."",
      ""Location"": ""Function: `transferFromERC721`""
    },
    {
      ""Issue"": ""Incorrect Approval in constructor to Sushi Router"",
      ""Severity"": ""Informational"",
      ""Description"": ""In the constructor, the WETH token is approved for the Sushi Router with `IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);`. This is fine. However, the Vault also approves the router to take the underlying tokens for minting LP tokens, but it does so for each vault every time there is a transaction. Since this already happened in the previous transactions, it\'s probably unnecessary."",
      ""Impact"": ""No real impact. However, gas cost can be reduced by removing the approval in `_addLiquidityAndLock`"",
      ""Location"": ""NFTXStakingZap.sol: constructor and _addLiquidityAndLock function""
    },
    {
      ""Issue"": ""Lack of slippage protection on WETH withdrawals after adding liquidity."",
      ""Severity"": ""Informational"",
      ""Description"": ""In functions like `addLiquidity721ETHTo`, the contract withdraws any remaining WETH after adding liquidity by calling `WETH.withdraw(msg.value-amountEth);`. Although the amount of WETH being withdrawn should be minimal, some protocols may introduce slippage or fees when withdrawing WETH."",
      ""Impact"": ""Users may experience minor slippage issues."",
      ""Location"": ""`addLiquidity721ETHTo`, `addLiquidity1155ETHTo`""
    },
     {
      ""Issue"": ""Unnecessary `setApprovalForAll` in `provideInventory1155`"",
      ""Severity"": ""Informational"",
      ""Description"": ""In the `provideInventory1155` function, the line `nft.setApprovalForAll(address(vault), true);` is present. Since the contract already takes custody of the NFTs via `safeBatchTransferFrom`, setting approval to",274.0676190853119,5270.0,38.0,"**[M-08] Low-level call return value not checked**

**Report Description**:  
The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value to determine if the call succeeded. This could lead to silent failures if the recipient contract reverts or if the call fails for any other reason, potentially resulting in the loss of ETH.

**Match in Response List**:  
Matches with the issue titled **""Unsafe usage of `call` with ETH transfer""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the unchecked low-level `.call` in the `addLiquidity721ETHTo` function. It correctly explains the risks associated with not validating the return value of the `.call`, which could lead to silent failures and loss of ETH. This aligns with Solidity best practices, which recommend checking the return value of low-level calls to ensure they succeed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-08] Low-level call return value not checked**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- *None*

--- 

The response list effectively covers the issue reported, providing a correct and accurate match. No gaps or partially correct matches were identified in this case.","```
1. Unsafe usage of `call` with ETH transfer
```","To calculate the **Average Precision (AP)** for the given query, we follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unsafe usage of `call` with ETH transfer"".
   - This issue appears at rank **23** in the ranked list of predictions.

2. **Calculate the precision at rank 23**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 23, \( P@23 = \frac{1}{23} \approx 0.0435 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.0435 \).

**Output**:
```
0.0435
```"
