nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
AxelarGateway.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './interfaces/IAxelarGateway.sol';
import { IERC20 } from './interfaces/IERC20.sol';
import { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';

import { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';
import { DepositHandler } from './DepositHandler.sol';
import { AdminMultisigBase } from './AdminMultisigBase.sol';
import { TokenDeployer } from './TokenDeployer.sol';

abstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {
    error NotSelf();
    error InvalidCodeHash();
    error SetupFailed();
    error InvalidAmount();
    error TokenDoesNotExist(string symbol);
    error TokenAlreadyExists(string symbol);
    error TokenDeployFailed(string symbol);
    error TokenContractDoesNotExist(address token);
    error BurnFailed(string symbol);
    error MintFailed(string symbol);
    error TokenIsFrozen(string symbol);

    enum Role {
        Admin,
        Owner,
        Operator
    }

    enum TokenType {
        InternalBurnable,
        InternalBurnableFrom,
        External
    }

    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    // AUDIT: slot names should be prefixed with some standard string
    // AUDIT: constants should be literal and their derivation should be in comments
    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');

    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');
    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');
    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');
    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');

    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');
    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');
    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');
    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');
    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');

    uint8 internal constant OLD_KEY_RETENTION = 16;

    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;

    constructor(address tokenDeployerImplementation) {
        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;
    }

    modifier onlySelf() {
        if (msg.sender != address(this)) revert NotSelf();

        _;
    }

    /******************\
    |* Public Methods *|
    \******************/

    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);
    }

    function callContract(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload
    ) external {
        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);
    }

    function callContractWithToken(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit ContractCallWithToken(
            msg.sender,
            destinationChain,
            destinationContractAddress,
            keccak256(payload),
            payload,
            symbol,
            amount
        );
    }

    function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view override returns (bool) {
        return
            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));
    }

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view override returns (bool) {
        return
            getBool(
                _getIsContractCallApprovedWithMintKey(
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);
        valid = getBool(key);
        if (valid) _setBool(key, false);
    }

    function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedWithMintKey(
            commandId,
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            symbol,
            amount
        );
        valid = getBool(key);
        if (valid) {
            _setBool(key, false);
            _mintToken(symbol, msg.sender, amount);
        }
    }

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() public view override returns (bool) {
        return getBool(KEY_ALL_TOKENS_FROZEN);
    }

    function implementation() public view override returns (address) {
        return getAddress(KEY_IMPLEMENTATION);
    }

    function tokenAddresses(string memory symbol) public view override returns (address) {
        return getAddress(_getTokenAddressKey(symbol));
    }

    function tokenFrozen(string memory symbol) public view override returns (bool) {
        return getBool(_getFreezeTokenKey(symbol));
    }

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return getBool(_getIsCommandExecutedKey(commandId));
    }

    /// @dev Returns the current `adminEpoch`.
    function adminEpoch() external view override returns (uint256) {
        return _adminEpoch();
    }

    /// @dev Returns the admin threshold for a given `adminEpoch`.
    function adminThreshold(uint256 epoch) external view override returns (uint256) {
        return _getAdminThreshold(epoch);
    }

    /// @dev Returns the array of admins within a given `adminEpoch`.
    function admins(uint256 epoch) external view override returns (address[] memory results) {
        uint256 adminCount = _getAdminCount(epoch);
        results = new address[](adminCount);

        for (uint256 i; i < adminCount; i++) {
            results[i] = _getAdmin(epoch, i);
        }
    }

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), true);

        emit TokenFrozen(symbol);
    }

    function unfreezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), false);

        emit TokenUnfrozen(symbol);
    }

    function freezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, true);

        emit AllTokensFrozen();
    }

    function unfreezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, false);

        emit AllTokensUnfrozen();
    }

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external override onlyAdmin {
        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();

        emit Upgraded(newImplementation);

        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)
        //        if `upgrade` is entered within the context of _this_ implementation itself.
        if (setupParams.length > 0) {
            (bool success, ) = newImplementation.delegatecall(
                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)
            );

            if (!success) revert SetupFailed();
        }

        _setImplementation(newImplementation);
    }

    /**********************\
    |* Internal Functions *|
    \**********************/

    function _burnTokenFrom(
        address sender,
        string memory symbol,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);
        if (amount == 0) revert InvalidAmount();

        TokenType tokenType = _getTokenType(symbol);
        bool burnSuccess;

        if (tokenType == TokenType.External) {
            _checkTokenStatus(symbol);

            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        if (tokenType == TokenType.InternalBurnableFrom) {
            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        burnSuccess = _callERC20Token(
            tokenAddress,
            abi.encodeWithSelector(
                IERC20.transferFrom.selector,
                sender,
                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),
                amount
            )
        );

        if (!burnSuccess) revert BurnFailed(symbol);

        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));
    }

    function _deployToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        address tokenAddress
    ) internal {
        // Ensure that this symbol has not been taken.
        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);

        if (tokenAddress == address(0)) {
            // If token address is no specified, it indicates a request to deploy one.
            bytes32 salt = keccak256(abi.encodePacked(symbol));

            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(
                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)
            );

            if (!success) revert TokenDeployFailed(symbol);

            tokenAddress = abi.decode(data, (address));

            _setTokenType(symbol, TokenType.InternalBurnableFrom);
        } else {
            // If token address is specified, ensure that there is a contact at the specified addressed.
            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);

            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.
            _setTokenType(symbol, TokenType.External);
        }

        _setTokenAddress(symbol, tokenAddress);

        emit TokenDeployed(symbol, tokenAddress);
    }

    function _mintToken(
        string memory symbol,
        address account,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            bool success = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)
            );

            if (!success) revert MintFailed(symbol);
        } else {
            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);
        }
    }

    function _burnToken(string memory symbol, bytes32 salt) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            DepositHandler depositHandler = new DepositHandler{ salt: salt }();

            (bool success, bytes memory returnData) = depositHandler.execute(
                tokenAddress,
                abi.encodeWithSelector(
                    IERC20.transfer.selector,
                    address(this),
                    IERC20(tokenAddress).balanceOf(address(depositHandler))
                )
            );

            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))
                revert BurnFailed(symbol);

            depositHandler.destroy(address(this));
        } else {
            BurnableMintableCappedERC20(tokenAddress).burn(salt);
        }
    }

    function _approveContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
        emit ContractCallApproved(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function _approveContractCallWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount
        );
        emit ContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));
    }

    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));
    }

    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));
    }

    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));
    }

    function _getIsContractCallApprovedKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash
                )
            );
    }

    function _getIsContractCallApprovedWithMintKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    /********************\
    |* Internal Methods *|
    \********************/

    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {
        (bool success, bytes memory returnData) = tokenAddress.call(callData);
        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));
    }

    /********************\
    |* Internal Getters *|
    \********************/

    function _getTokenType(string memory symbol) internal view returns (TokenType) {
        return TokenType(getUint(_getTokenTypeKey(symbol)));
    }

    function _checkTokenStatus(string memory symbol) internal view {
        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);
    }

    /********************\
    |* Internal Setters *|
    \********************/

    function _setTokenType(string memory symbol, TokenType tokenType) internal {
        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));
    }

    function _setTokenAddress(string memory symbol, address tokenAddress) internal {
        _setAddress(_getTokenAddressKey(symbol), tokenAddress);
    }

    function _setCommandExecuted(bytes32 commandId, bool executed) internal {
        _setBool(_getIsCommandExecutedKey(commandId), executed);
    }

    function _setContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal {
        _setBool(
            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),
            true
        );
    }

    function _setContractCallApprovedWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal {
        _setBool(
            _getIsContractCallApprovedWithMintKey(
                commandId,
                sourceChain,
                sourceAddress,
                contractAddress,
                payloadHash,
                symbol,
                amount
            ),
            true
        );
    }

    function _setImplementation(address newImplementation) internal {
        _setAddress(KEY_IMPLEMENTATION, newImplementation);
    }
}",4083,617,"[H-01] Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded
Smart contract calls often revert. In such cases any ether sent along with the transaction is returned and sometimes the remaining gas
For contracts involving ERC20 tokens it is also expected that, should a contract call fail, one's tokens are not lost/transferred elsewhere.
The `callContractWithToken` function does not appear to take contract call failure on the destination chain into account, even though this could be quite a common occurrence.
  [M-01] Low level call returns true if the address doesn't exist
As written in the solidity documentation, the low-level functions `call`, `delegatecall` and `staticcall` return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.
  [M-02] User's funds can get lost when transferring to other chain
When transferring tokens to other chain, the tokens in the source chain are burned - if they are external they will be transferred to the AxelarGateway, otherwise they will be burned. In the target chain the same amount of tokens will be minted for the user - if it is external it will be transferred to him from the AxelarGateway, otherwise it will be minted to him. But there is a problem - if the AxelarGateway doesn't have the needed amount of token for some reason, the `_callERC20Token` with the `transfer` function selector will fail and return false, which will make the `_mintToken` function revert. Because it reverted, the user won't get his funds on the destination chain, although he payed the needed amount in the source chain.
  [M-04] Unsupported fee-on-transfer tokens
When tokenAddress is fee-on-transfer tokens, in the `_burnTokenFrom` function, the actual amount of tokens received by the contract will be less than the amount.
",4,,"pragma solidity 0.8.9;

import { IAxelarGateway } from './interfaces/IAxelarGateway.sol';
import { IERC20 } from './interfaces/IERC20.sol';
import { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';

import { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';
import { DepositHandler } from './DepositHandler.sol';
import { AdminMultisigBase } from './AdminMultisigBase.sol';
import { TokenDeployer } from './TokenDeployer.sol';

abstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {
    error NotSelf();
    error InvalidCodeHash();
    error SetupFailed();
    error InvalidAmount();
    error TokenDoesNotExist(string symbol);
    error TokenAlreadyExists(string symbol);
    error TokenDeployFailed(string symbol);
    error TokenContractDoesNotExist(address token);
    error BurnFailed(string symbol);
    error MintFailed(string symbol);
    error TokenIsFrozen(string symbol);

    enum Role {
        Admin,
        Owner,
        Operator
    }

    enum TokenType {
        InternalBurnable,
        InternalBurnableFrom,
        External
    }

    
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    
    
    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');

    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');
    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');
    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');
    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');

    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');
    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');
    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');
    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');
    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');

    uint8 internal constant OLD_KEY_RETENTION = 16;

    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;

    constructor(address tokenDeployerImplementation) {
        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;
    }

    modifier onlySelf() {
        if (msg.sender != address(this)) revert NotSelf();

        _;
    }

    

    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);
    }

    function callContract(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload
    ) external {
        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);
    }

    function callContractWithToken(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit ContractCallWithToken(
            msg.sender,
            destinationChain,
            destinationContractAddress,
            keccak256(payload),
            payload,
            symbol,
            amount
        );
    }

    function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view override returns (bool) {
        return
            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));
    }

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view override returns (bool) {
        return
            getBool(
                _getIsContractCallApprovedWithMintKey(
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);
        valid = getBool(key);
        if (valid) _setBool(key, false);
    }

    function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedWithMintKey(
            commandId,
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            symbol,
            amount
        );
        valid = getBool(key);
        if (valid) {
            _setBool(key, false);
            _mintToken(symbol, msg.sender, amount);
        }
    }

    

    function allTokensFrozen() public view override returns (bool) {
        return getBool(KEY_ALL_TOKENS_FROZEN);
    }

    function implementation() public view override returns (address) {
        return getAddress(KEY_IMPLEMENTATION);
    }

    function tokenAddresses(string memory symbol) public view override returns (address) {
        return getAddress(_getTokenAddressKey(symbol));
    }

    function tokenFrozen(string memory symbol) public view override returns (bool) {
        return getBool(_getFreezeTokenKey(symbol));
    }

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return getBool(_getIsCommandExecutedKey(commandId));
    }

    
    function adminEpoch() external view override returns (uint256) {
        return _adminEpoch();
    }

    
    function adminThreshold(uint256 epoch) external view override returns (uint256) {
        return _getAdminThreshold(epoch);
    }

    
    function admins(uint256 epoch) external view override returns (address[] memory results) {
        uint256 adminCount = _getAdminCount(epoch);
        results = new address[](adminCount);

        for (uint256 i; i < adminCount; i++) {
            results[i] = _getAdmin(epoch, i);
        }
    }

    

    function freezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), true);

        emit TokenFrozen(symbol);
    }

    function unfreezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), false);

        emit TokenUnfrozen(symbol);
    }

    function freezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, true);

        emit AllTokensFrozen();
    }

    function unfreezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, false);

        emit AllTokensUnfrozen();
    }

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external override onlyAdmin {
        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();

        emit Upgraded(newImplementation);

        
        
        if (setupParams.length > 0) {
            (bool success, ) = newImplementation.delegatecall(
                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)
            );

            if (!success) revert SetupFailed();
        }

        _setImplementation(newImplementation);
    }

    

    function _burnTokenFrom(
        address sender,
        string memory symbol,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);
        if (amount == 0) revert InvalidAmount();

        TokenType tokenType = _getTokenType(symbol);
        bool burnSuccess;

        if (tokenType == TokenType.External) {
            _checkTokenStatus(symbol);

            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        if (tokenType == TokenType.InternalBurnableFrom) {
            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        burnSuccess = _callERC20Token(
            tokenAddress,
            abi.encodeWithSelector(
                IERC20.transferFrom.selector,
                sender,
                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),
                amount
            )
        );

        if (!burnSuccess) revert BurnFailed(symbol);

        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));
    }

    function _deployToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        address tokenAddress
    ) internal {
        
        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);

        if (tokenAddress == address(0)) {
            
            bytes32 salt = keccak256(abi.encodePacked(symbol));

            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(
                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)
            );

            if (!success) revert TokenDeployFailed(symbol);

            tokenAddress = abi.decode(data, (address));

            _setTokenType(symbol, TokenType.InternalBurnableFrom);
        } else {
            
            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);

            
            _setTokenType(symbol, TokenType.External);
        }

        _setTokenAddress(symbol, tokenAddress);

        emit TokenDeployed(symbol, tokenAddress);
    }

    function _mintToken(
        string memory symbol,
        address account,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            bool success = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)
            );

            if (!success) revert MintFailed(symbol);
        } else {
            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);
        }
    }

    function _burnToken(string memory symbol, bytes32 salt) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            DepositHandler depositHandler = new DepositHandler{ salt: salt }();

            (bool success, bytes memory returnData) = depositHandler.execute(
                tokenAddress,
                abi.encodeWithSelector(
                    IERC20.transfer.selector,
                    address(this),
                    IERC20(tokenAddress).balanceOf(address(depositHandler))
                )
            );

            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))
                revert BurnFailed(symbol);

            depositHandler.destroy(address(this));
        } else {
            BurnableMintableCappedERC20(tokenAddress).burn(salt);
        }
    }

    function _approveContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
        emit ContractCallApproved(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function _approveContractCallWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount
        );
        emit ContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    

    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));
    }

    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));
    }

    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));
    }

    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));
    }

    function _getIsContractCallApprovedKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash
                )
            );
    }

    function _getIsContractCallApprovedWithMintKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    

    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {
        (bool success, bytes memory returnData) = tokenAddress.call(callData);
        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));
    }

    

    function _getTokenType(string memory symbol) internal view returns (TokenType) {
        return TokenType(getUint(_getTokenTypeKey(symbol)));
    }

    function _checkTokenStatus(string memory symbol) internal view {
        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);
    }

    

    function _setTokenType(string memory symbol, TokenType tokenType) internal {
        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));
    }

    function _setTokenAddress(string memory symbol, address tokenAddress) internal {
        _setAddress(_getTokenAddressKey(symbol), tokenAddress);
    }

    function _setCommandExecuted(bytes32 commandId, bool executed) internal {
        _setBool(_getIsCommandExecutedKey(commandId), executed);
    }

    function _setContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal {
        _setBool(
            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),
            true
        );
    }

    function _setContractCallApprovedWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal {
        _setBool(
            _getIsContractCallApprovedWithMintKey(
                commandId,
                sourceChain,
                sourceAddress,
                contractAddress,
                payloadHash,
                symbol,
                amount
            ),
            true
        );
    }

    function _setImplementation(address newImplementation) internal {
        _setAddress(KEY_IMPLEMENTATION, newImplementation);
    }
}",3738,1,3,"{
  ""task_list"": [
    {
      ""Area"": ""Admin Multisig Base & Access Control"",
      ""Tasks"": [
        ""Review the `AdminMultisigBase` contract implementation to understand the precise signature validation logic used to authorize admin actions. Pay close attention to replay protection mechanisms and potential vulnerabilities in the multisig scheme."",
        ""Verify that the `onlyAdmin` modifier in `AxelarGateway` correctly utilizes the admin role management functions in `AdminMultisigBase`."",
        ""Investigate the admin key rotation process within `AdminMultisigBase` and ensure it is secure against compromise and DoS attacks."",
        ""Examine the storage layout of `AdminMultisigBase` and its interaction with the storage of `AxelarGateway` to ensure there are no storage collision vulnerabilities that could lead to unauthorized access or data corruption."",
        ""Assess the impact of potential admin key compromise and ensure the contract has sufficient mechanisms for recovery and mitigation."",
        ""Analyze the `OLD_KEY_RETENTION` parameter and its impact on security and gas costs. Determine if the retention period is sufficient to detect and respond to compromised keys.""
      ]
    },
    {
      ""Area"": ""Token Management & Security"",
      ""Tasks"": [
        ""Analyze the `_burnTokenFrom` function to ensure that the correct ERC-20 functions (`transferFrom`, `burnFrom`, `transfer` to deposit address) are being called based on the `TokenType` and that the calls are successful."",
        ""Review the implementation of `BurnableMintableCappedERC20` and the `depositAddress()` function to understand how it prevents unauthorized burning or minting of tokens, especially related to the seemingly different handling of `InternalBurnable` tokens."",
        ""Verify that the `_mintToken` function can only be called by authorized entities (either internally within `validateContractCallAndMint` or by some other controlled mechanism)."",
        ""Investigate the potential for token freezing to be bypassed or circumvented. Ensure that `_checkTokenStatus` is called consistently before sensitive operations like minting or burning."",
        ""Analyze the gas costs associated with different token types and burning/minting mechanisms. Optimize where possible without compromising security."",
        ""Examine the external token handling logic in `_burnToken`, specifically the use of `DepositHandler`. Ensure the temporary contract's destruction and token transfer are atomic and free from race conditions or reentrancy vulnerabilities."",
        ""Confirm that the `TOKEN_DEPLOYER_IMPLEMENTATION` address is properly validated and secured against malicious code injection. Consider the risks associated with delegatecall to an external contract."",
        ""Investigate the potential for malicious token contracts to exploit vulnerabilities in the `_callERC20Token` function or other areas where external contracts are called.""
      ]
    },
    {
      ""Area"": ""Cross-Chain Communication & Command Handling"",
      ""Tasks"": [
        ""Trace the flow of execution for cross-chain calls, starting from the `ContractCall` and `ContractCallWithToken` events, through the approval process (`_approveContractCall`, `_approveContractCallWithMint`), and finally to the validation and execution in `validateContractCall` and `validateContractCallAndMint`."",
        ""Verify the integrity of the command IDs used for tracking cross-chain calls. Ensure that they are generated in a secure and unpredictable manner to prevent manipulation or forgery."",
        ""Analyze the storage keys used for tracking approved contract calls (`PREFIX_CONTRACT_CALL_APPROVED`, `PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT`) to ensure they are unique and resistant to collisions that could lead to unauthorized execution."",
        ""Investigate the potential for replay attacks on cross-chain calls. Verify that the `isCommandExecuted` function and associated storage mechanisms are sufficient to prevent duplicate execution of commands."",
        ""Assess the security implications of using `keccak256(payload)` as the payload hash. Consider potential collision vulnerabilities and whether a more robust hashing algorithm is necessary."",
        ""Examine the logic within `validateContractCall` and `validateContractCallAndMint` to ensure that the approval flag is cleared immediately after validation to prevent double-spending or unauthorized access."",
        ""Identify the mechanism by which the Axelar network communicates approved commands to the gateway (the missing `execute` function). Analyze this mechanism for potential vulnerabilities, such as unauthorized command injection or denial-of-service attacks.""
      ]
    },
    {
      ""Area"": ""Upgradeability & Proxy Pattern"",
      ""Tasks"": [
        ""Verify that the `upgrade` function can only be called by authorized admins and that the `newImplementationCodeHash` is correctly validated against the code hash of the `newImplementation` address."",
        ""Analyze the setup process invoked via `delegatecall` in the `upgrade` function. Ensure that the `setupParams` are properly validated and that the setup function in the new implementation is secure against malicious input."",
        ""Assess the risk of storage collisions between different implementations of the `AxelarGateway` contract. Verify that the storage layout is compatible across upgrades and that data is not corrupted during the upgrade process."",
        ""Examine the impact of upgrading the contract on existing cross-chain calls and token balances. Ensure that the upgrade process does not disrupt ongoing operations or lead to loss of funds."",
        ""Analyze the potential for a malicious upgrade to compromise the security of the gateway or drain funds from users. Ensure that the upgrade process includes sufficient safeguards against such attacks.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze the gas costs of the `sendToken`, `callContract`, and `callContractWithToken` functions. Identify areas where gas costs can be reduced without compromising security."",
        ""Optimize the storage key generation functions (`_getTokenTypeKey`, `_getFreezeTokenKey`, etc.) to minimize gas costs."",
        ""Evaluate the use of `string` for token symbols and destination chains. Consider using more gas-efficient data types where possible."",
        ""Assess the gas costs associated with the multisig validation in `AdminMultisigBase` and identify opportunities for optimization."",
        ""Examine the gas costs of the `_callERC20Token` function and consider using assembly to further optimize the low-level calls to ERC-20 contracts."",
        ""Analyze the gas costs of the `validateContractCall` and `validateContractCallAndMint` functions. Look for ways to reduce the gas costs of clearing the approval flag and minting tokens."",
         ""Profile gas usage of the `_deployToken` function, in both the direct deploy and external token registration paths. Identify potential bottlenecks related to the delegatecall and state updates.""
      ]
    },
     {
      ""Area"": ""Error Handling & Edge Cases"",
      ""Tasks"": [
        ""Thoroughly review all error messages and ensure they provide sufficient context for debugging and troubleshooting."",
        ""Identify potential edge cases in the token burning and minting logic, such as handling zero-amount transfers or tokens with unusual decimal values."",
        ""Analyze the behavior of the contract in the event of reverts in external calls, such as calls to ERC-20 contracts or the `TOKEN_DEPLOYER_IMPLEMENTATION`."",
        ""Assess the resilience of the contract to denial-of-service attacks, such as attempts to flood the contract with invalid commands or freeze all tokens."",
        ""Examine the handling of invalid input parameters in the `upgrade` function, such as an invalid `newImplementationCodeHash` or malicious `setupParams`."",
        ""Verify that the contract correctly handles situations where a token is frozen during a cross-chain call or upgrade process.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The code defines an abstract contract `AxelarGateway` which serves as a core component for the Axelar network's interaction with a specific blockchain. It handles cross-chain token transfers (sending/receiving), generic message passing, token deployment (both native Axelar-minted and external tokens), and administrative functions like freezing tokens and upgrading the gateway logic. It relies heavily on an admin multisig mechanism (inherited from `AdminMultisigBase`) for security and uses a proxy pattern for upgradeability. Storage is managed using specific keys to likely work with the proxy storage layout."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""AxelarGateway (abstract)"",
    ""Purpose"": ""To act as the primary interface for a blockchain to interact with the Axelar network. It facilitates sending tokens and messages to other chains, receiving tokens and messages from other chains (validating them), deploying and managing token representations on the current chain, and providing administrative controls."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""IAxelarGateway"",
        ""AdminMultisigBase""
      ],
      ""Imports"": [
        ""./interfaces/IAxelarGateway.sol"",
        ""./interfaces/IERC20.sol"",
        ""./interfaces/IERC20BurnFrom.sol"",
        ""./BurnableMintableCappedERC20.sol"",
        ""./DepositHandler.sol"",
        ""./AdminMultisigBase.sol"",
        ""./TokenDeployer.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""KEY_IMPLEMENTATION"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Storage slot key for the proxy's implementation address.""
      },
      {
        ""Name"": ""KEY_ALL_TOKENS_FROZEN"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Storage slot key for the global token freeze flag.""
      },
      {
        ""Name"": ""PREFIX_COMMAND_EXECUTED"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Prefix for storage keys tracking executed command IDs.""
      },
      {
        ""Name"": ""PREFIX_TOKEN_ADDRESS"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Prefix for storage keys mapping token symbols to addresses.""
      },
      {
        ""Name"": ""PREFIX_TOKEN_TYPE"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Prefix for storage keys mapping token symbols to their TokenType.""
      },
      {
        ""Name"": ""PREFIX_TOKEN_FROZEN"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Prefix for storage keys tracking individual token freeze status.""
      },
      {
        ""Name"": ""PREFIX_CONTRACT_CALL_APPROVED"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Prefix for storage keys tracking approved cross-chain contract calls.""
      },
      {
        ""Name"": ""PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Prefix for storage keys tracking approved cross-chain contract calls that include token minting.""
      },
      {
        ""Name"": ""SELECTOR_*"",
        ""Type"": ""bytes32 internal constant"",
        ""Purpose"": ""Constants representing keccak256 hashes of function signatures, likely used to identify command types received from Axelar network.""
      },
      {
        ""Name"": ""OLD_KEY_RETENTION"",
        ""Type"": ""uint8 internal constant"",
        ""Purpose"": ""Likely related to how many previous admin sets are stored/tracked by `AdminMultisigBase`.""
      },
      {
        ""Name"": ""TOKEN_DEPLOYER_IMPLEMENTATION"",
        ""Type"": ""address internal immutable"",
        ""Purpose"": ""Address of the logic contract used via delegatecall to deploy new Axelar-native tokens.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Initializes the immutable `TOKEN_DEPLOYER_IMPLEMENTATION` address."",
        ""Parameters"": [""address tokenDeployerImplementation""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlySelf"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to calls originating from the contract itself (address(this))."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""sendToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Burns tokens locally and emits an event to signal sending tokens to another chain via Axelar."",
        ""Parameters"": [""string memory destinationChain"", ""string memory destinationAddress"", ""string memory symbol"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""callContract"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Emits an event to signal sending a generic message (payload) to a contract on another chain via Axelar."",
        ""Parameters"": [""string memory destinationChain"", ""string memory destinationContractAddress"", ""bytes memory payload""],
        ""Returns"": []
      },
      {
        ""Name"": ""callContractWithToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Burns tokens locally and emits an event to signal sending a message (payload) along with tokens to a contract on another chain."",
        ""Parameters"": [""string memory destinationChain"", ""string memory destinationContractAddress"", ""bytes memory payload"", ""string memory symbol"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""isContractCallApproved"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Checks if a specific cross-chain contract call (without minting) has been approved by Axelar."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""address contractAddress"", ""bytes32 payloadHash""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""isContractCallAndMintApproved"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Checks if a specific cross-chain contract call (with minting) has been approved by Axelar."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""address contractAddress"", ""bytes32 payloadHash"", ""string memory symbol"", ""uint256 amount""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""validateContractCall"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by the target contract to verify and consume the approval for a cross-chain call."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""bytes32 payloadHash""],
        ""Returns"": [""bool valid""]
      },
      {
        ""Name"": ""validateContractCallAndMint"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Called by the target contract to verify/consume approval for a cross-chain call and mint associated tokens."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""bytes32 payloadHash"", ""string memory symbol"", ""uint256 amount""],
        ""Returns"": [""bool valid""]
      },
      {
        ""Name"": ""allTokensFrozen"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns true if all tokens are globally frozen."",
        ""Parameters"": [],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""implementation"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the current logic implementation (for proxy pattern)."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""tokenAddresses"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the address of the token contract for a given symbol."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""tokenFrozen"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns true if a specific token symbol is frozen."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""isCommandExecuted"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns true if a specific Axelar command ID has already been executed."",
        ""Parameters"": [""bytes32 commandId""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""adminEpoch"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the current admin epoch number (from AdminMultisigBase)."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""adminThreshold"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the required admin signature threshold for a given epoch (from AdminMultisigBase)."",
        ""Parameters"": [""uint256 epoch""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""admins"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the list of admin addresses for a given epoch (from AdminMultisigBase)."",
        ""Parameters"": [""uint256 epoch""],
        ""Returns"": [""address[] memory results""]
      },
      {
        ""Name"": ""freezeToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to freeze a specific token."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": []
      },
      {
        ""Name"": ""unfreezeToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to unfreeze a specific token."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": []
      },
      {
        ""Name"": ""freezeAllTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to globally freeze all tokens."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""unfreezeAllTokens"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to globally unfreeze all tokens."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""upgrade"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Admin function to upgrade the gateway's implementation logic contract."",
        ""Parameters"": [""address newImplementation"", ""bytes32 newImplementationCodeHash"", ""bytes calldata setupParams""],
        ""Returns"": []
      },
      {
        ""Name"": ""_burnTokenFrom"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to handle burning/locking tokens initiated by a user (`sendToken`, `callContractWithToken`). Differentiates between External, InternalBurnableFrom, and InternalBurnable token types."",
        ""Parameters"": [""address sender"", ""string memory symbol"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_deployToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to deploy a new Axelar-native token or register an existing external token."",
        ""Parameters"": [""string memory name"", ""string memory symbol"", ""uint8 decimals"", ""uint256 cap"", ""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""_mintToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to mint Axelar-native tokens or transfer gateway-held external tokens to a user, typically upon receiving from another chain."",
        ""Parameters"": [""string memory symbol"", ""address account"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_burnToken"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic to burn Axelar-native tokens or take ownership of external tokens received via a temporary DepositHandler, typically upon receiving from another chain."",
        ""Parameters"": [""string memory symbol"", ""bytes32 salt""],
        ""Returns"": []
      },
      {
        ""Name"": ""_approveContractCall"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Marks a cross-chain contract call as approved in storage and emits an event."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""address contractAddress"", ""bytes32 payloadHash"", ""bytes32 sourceTxHash"", ""uint256 sourceEventIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""_approveContractCallWithMint"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Marks a cross-chain contract call with minting as approved in storage and emits an event."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""address contractAddress"", ""bytes32 payloadHash"", ""string memory symbol"", ""uint256 amount"", ""bytes32 sourceTxHash"", ""uint256 sourceEventIndex""],
        ""Returns"": []
      },
      {
        ""Name"": ""_getTokenTypeKey"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the storage key for a token's type."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""_getFreezeTokenKey"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the storage key for a token's frozen status."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""_getTokenAddressKey"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the storage key for a token's address."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""_getIsCommandExecutedKey"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the storage key for a command's execution status."",
        ""Parameters"": [""bytes32 commandId""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""_getIsContractCallApprovedKey"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the storage key for a contract call approval."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""address contractAddress"", ""bytes32 payloadHash""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""_getIsContractCallApprovedWithMintKey"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Calculates the storage key for a contract call with mint approval."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""address contractAddress"", ""bytes32 payloadHash"", ""string memory symbol"", ""uint256 amount""],
        ""Returns"": [""bytes32""]
      },
      {
        ""Name"": ""_callERC20Token"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Helper function to make low-level calls to ERC20 contracts and check success."",
        ""Parameters"": [""address tokenAddress"", ""bytes memory callData""],
        ""Returns"": [""bool""]
      },
      {
        ""Name"": ""_getTokenType"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Retrieves the TokenType for a symbol from storage."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": [""TokenType""]
      },
      {
        ""Name"": ""_checkTokenStatus"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Reverts if a token is frozen individually or globally."",
        ""Parameters"": [""string memory symbol""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setTokenType"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sets the TokenType for a symbol in storage (likely calls AdminMultisigBase._setUint)."",
        ""Parameters"": [""string memory symbol"", ""TokenType tokenType""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setTokenAddress"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sets the token address for a symbol in storage (likely calls AdminMultisigBase._setAddress)."",
        ""Parameters"": [""string memory symbol"", ""address tokenAddress""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setCommandExecuted"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Marks a command as executed in storage (likely calls AdminMultisigBase._setBool)."",
        ""Parameters"": [""bytes32 commandId"", ""bool executed""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setContractCallApproved"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sets the approval flag for a contract call (likely calls AdminMultisigBase._setBool)."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""address contractAddress"", ""bytes32 payloadHash""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setContractCallApprovedWithMint"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sets the approval flag for a contract call with mint (likely calls AdminMultisigBase._setBool)."",
        ""Parameters"": [""bytes32 commandId"", ""string memory sourceChain"", ""string memory sourceAddress"", ""address contractAddress"", ""bytes32 payloadHash"", ""string memory symbol"", ""uint256 amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_setImplementation"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Sets the implementation address in storage (likely calls AdminMultisigBase._setAddress)."",
        ""Parameters"": [""address newImplementation""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Inherits from `AdminMultisigBase`, implying interaction with its state and functions (admin checks, storage access via `_set*`/`get*`)."",
    ""Implements `IAxelarGateway` interface."",
    ""Interacts with `IERC20`, `IERC20BurnFrom`, and `BurnableMintableCappedERC20` token contracts (transferFrom, burnFrom, mint, burn, transfer, balanceOf)."",
    ""Uses `delegatecall` to `TOKEN_DEPLOYER_IMPLEMENTATION` (an instance of `TokenDeployer`) to deploy new tokens."",
    ""Deploys and interacts with temporary `DepositHandler` contracts for receiving external tokens."",
    ""Uses `delegatecall` to the `newImplementation` address during `upgrade`."",
    ""Makes low-level `.call` to ERC20 token addresses via `_callERC20Token`."",
    ""Target contracts on the local chain will call `validateContractCall` and `validateContractCallAndMint`.""
  ],
  ""SpecialMechanisms"": [
    ""Proxy Pattern: Indicated by `KEY_IMPLEMENTATION`, `implementation()`, `upgrade()`, and the use of specific storage slot keys (`PREFIX_*`, `KEY_*`) suggesting that this is the logic contract intended to be used behind a proxy."",
    ""Storage Management: Uses `keccak256`-based keys for accessing storage, likely via low-level `sstore`/`sload` operations encapsulated in helper functions (`_set*`, `get*`) inherited from `AdminMultisigBase` or similar, to maintain storage layout compatibility with the proxy."",
    ""Admin Control: Uses a multisig mechanism inherited from `AdminMultisigBase` (indicated by `onlyAdmin` modifier, `admin*` view functions)."",
    ""Token Handling Abstraction: Manages three types of tokens (`TokenType` enum) with different logic for minting/burning/locking (InternalBurnable, InternalBurnableFrom, External)."",
    ""Token Deployment Factory: Uses `TokenDeployer` via `delegatecall` to create standardized `InternalBurnableFrom` tokens."",
    ""Cross-Chain Command Handling: Uses `commandId` and approval flags (`is*Approved`, `validate*`, `isCommandExecuted`) to manage the lifecycle of commands originating from the Axelar network."",
    ""Temporary Contract Deployment (`DepositHandler`): Used in `_burnToken` for handling external tokens without requiring prior approvals to the main gateway.""
  ],
  ""Questions"": [
    ""Where are the storage access functions (`_setBool`, `_setAddress`, `_setUint`, `getBool`, `getAddress`, `getUint`) defined? Presumably in `AdminMultisigBase`?"",
    ""How is the `execute` function (or equivalent that processes signed commands from Axelar) implemented? This function seems essential for triggering `_approve*`, `_mintToken`, `_deployToken`, `_burnToken`, etc., based on validated Axelar messages, but is not present in the snippet."",
    ""What is the exact signature validation logic within `AdminMultisigBase`?"",
    ""What is the precise implementation of `BurnableMintableCappedERC20`, especially `depositAddress()` and its interaction with `burn()`?"",
    ""What are the `SELECTOR_*` constants used for? Are they keys for a dispatch mechanism within the missing `execute` function?"",
    ""Why does `_burnTokenFrom` for `TokenType.InternalBurnable` (not `InternalBurnableFrom`) transfer to a `depositAddress` before burning, instead of using a direct `burnFrom` mechanism? Is `InternalBurnable` fundamentally different?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unprotected Delegatecall to TokenDeployer Implementation"",
      ""Severity"": ""High"",
      ""Description"": ""The `_deployToken` function uses `TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall` to deploy new tokens, but there's no validation on its code hash or access control on the constructor. This allows for malicious token deployment and system compromise. Additionally, the `TOKEN_DEPLOYER_IMPLEMENTATION` address lacks input validation and zero-address checks in the constructor and has missing access control on its initialization, potentially freezing the contract or allowing griefing during deployment."",
      ""Impact"": ""Malicious token deployment, system compromise, financial loss, inability to deploy new tokens, contract freezing, potential denial of service."",
      ""Location"": ""`AxelarGateway.sol:_deployToken`, `AxelarGateway.sol:constructor`""
    },
    {
      ""Issue"": ""Unvalidated `newImplementationCodeHash` in `upgrade` function, Unprotected Upgrade Function, Reliance on delegatecall success in upgrade"",
      ""Severity"": ""High"",
      ""Description"": ""The `upgrade` function's code hash check can be bypassed, allowing upgrades to malicious implementations and arbitrary code execution. The function also uses `delegatecall` without validating `setupParams` and doesn't check if `newImplementation` address is a contract leading to broken contract state and denial of service if the setup function fails. Additionally, there is no input validation in the `upgrade` function and the Admin can perform any action on the contract."",
      ""Impact"": ""Complete contract takeover, arbitrary state manipulation, theft of funds, broken contract state, potential denial of service, unauthorized state changes."",
      ""Location"": ""`AxelarGateway.sol:upgrade`""
    },
    {
      ""Issue"": ""Potential Re-entrancy Vulnerability in `validateContractCallAndMint`"",
      ""Severity"": ""High"",
      ""Description"": ""The `validateContractCallAndMint` function validates a contract call and then mints tokens to the `msg.sender`, creating a re-entrancy vulnerability. A malicious contract could re-enter the function before the initial call completes, leading to double minting or state inconsistencies and potential exploitation."",
      ""Impact"": ""Potential for malicious contracts to re-enter the gateway, leading to double minting, state inconsistencies, denial of service, unauthorized token minting and inflation."",
      ""Location"": ""`AxelarGateway.sol:validateContractCallAndMint`""
    },
    {
      ""Issue"": ""Lack of CommandId replay protection in `validateContractCall` and `validateContractCallAndMint`"",
      ""Severity"": ""High"",
      ""Description"": ""The `validateContractCall` and `validateContractCallAndMint` functions invalidate approvals using `_setBool`. However, the functions do not prevent being called after the validation has been triggered, allowing an operator to obtain parameters to replay the transaction on a different contract."",
      ""Impact"": ""Transaction replay attacks, unauthorized contract calls or token minting."",
      ""Location"": ""Functions: `validateContractCall`, `validateContractCallAndMint`, `isContractCallApproved`, `isContractCallAndMintApproved`""
    },
    {
      ""Issue"": ""Missing Input Validation for `_burnTokenFrom` and Potential Re-entrancy"",
      ""Severity"": ""High"",
      ""Description"": ""The `_burnTokenFrom` function lacks re-entrancy protection when handling external tokens. A malicious ERC20 token implementation at `tokenAddress` calling back into the AxelarGateway could lead to unexpected state changes, double spending, or other vulnerabilities. Also, the function `_checkTokenStatus` can be bypassed if the token type is external and `tokenAddress` is not a valid ERC20 contract."",
      ""Impact"": ""Potential for re-entrancy attacks leading to unauthorized token burns, double-spending, or denial of service. Bypassing the `_checkTokenStatus` call allows for malicious token contracts to exist in the system."",
      ""Location"": ""AxelarGateway.sol: `_burnTokenFrom` function (lines 259-296), ERC20.transferFrom call, `_checkTokenStatus`""
    },
    {
      ""Issue"": ""Lack of Input Validation for Chain and Address Parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `sendToken`, `callContract`, and `callContractWithToken` functions lack validation on `destinationChain` and `destinationContractAddress`. Malicious users could provide arbitrary strings, leading to issues in downstream systems, misrouting messages, or unexpected behavior."",
      ""Impact"": ""Potential vulnerabilities in external systems that rely on the destinationChain and destinationAddress parameters. Information leakage or denial-of-service attacks on external systems, misrouting messages, denial of service, or unexpected behavior due to malformed chain or address strings."",
      ""Location"": ""Functions: `sendToken`, `callContract`, `callContractWithToken`""
    },
    {
      ""Issue"": ""Missing input validation for token parameters"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_deployToken` function takes inputs including `name`, `symbol`, `decimals`, and `cap` without validity checks. Large `cap` values, incorrect `decimals`, duplicate symbols, or invalid strings can cause unexpected behavior."",
      ""Impact"": ""Unexpected token behavior, potential denial of service, confusion for users, issues in other parts of the system or breaking assumptions made by other contracts interacting with the gateway."",
      ""Location"": ""`AxelarGateway.sol:_deployToken`""
    },
    {
      ""Issue"": ""Reliance on `delegatecall` for Token Deployment, Unbounded Delegatecall to TokenDeployerImplementation in `_deployToken`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_deployToken` function uses `delegatecall` to the `TOKEN_DEPLOYER_IMPLEMENTATION` contract. State changes in the `TokenDeployer` affect the `AxelarGateway`'s storage, potentially leading to vulnerabilities if the `TokenDeployer` has unintended side effects or relies on state variables in the `AxelarGateway`. If the `TokenDeployer` contains a fallback function that consumes excessive gas or returns large amounts of data, this could lead to a denial of service."",
      ""Impact"": ""Unintended state changes in AxelarGateway's storage, potential for malicious TokenDeployer to corrupt the gateway's state, potential denial of service or transaction failures due to gas exhaustion or malicious code in `TokenDeployerImplementation`."" ,
      ""Location"": ""`AxelarGateway.sol:_deployToken`""
    },
   {
      ""Issue"": ""Missing Access Control for `_burnToken` function and Token Deployment"",
      ""Severity"": ""Medium"",
      ""Description"": ""The internal `_burnToken` function lacks proper access control, potentially allowing unauthorized access. The `_deployToken` function is internal and is not directly exposed, but if a derived contract exposes this function (or a function that calls it) without proper access controls, anyone could deploy new tokens, potentially leading to malicious token creation and ecosystem manipulation."",
      ""Impact"": ""Potential for unauthorized burning of tokens if `_burnToken` is accessible through unexpected paths, unauthorized token deployments, potential for malicious token creation and ecosystem manipulation."",
      ""Location"": ""_burnToken function, AxelarGateway.sol: `_deployToken` function (lines 298-330)""
    },
    {
      ""Issue"": ""Inconsistent Handling of External Token Transfers and Error Handling"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract uses `_callERC20Token` with inconsistent checks on `returnData`, which can cause some ERC20 tokens with custom return data behavior to be incorrectly handled, possibly leading to failed or incorrect transfers. The function also checks the success of the `call` but also requires that the `returnData` is either empty or decodes to `true`. If `returnData` is not empty but cannot be decoded to a boolean, the transaction will revert."",
      ""Impact"": ""Potential for failed token transfers or incorrect behavior when interacting with ERC20 tokens that deviate from the standard return value on `transfer` or `transferFrom`."",
      ""Location"": ""Functions: `_burnTokenFrom`, `_mintToken`, `_burnToken`, AxelarGateway.sol: Line 561""
    },
    {
      ""Issue"": ""Token Inflation Risk in _mintToken with External Tokens"",
      ""Severity"": ""Medium"",
      ""Description"": ""When `_mintToken` is used with an `External` token, it calls `IERC20.transfer` to transfer tokens to the `account`.  The Gateway contract relies on the assumption that the external token correctly implements the `transfer` function and does not allow inflation during the transfer.  If the external token contract is malicious or has a vulnerability, it could potentially inflate the token supply when `transfer` is called, which can lead to unpredictable behavior and economic risks for the gateway and its users."",
      ""Impact"": ""Risk of token inflation if the external token\'s `transfer` function is malicious or vulnerable."",
      ""Location"": ""_mintToken function, External token handling""
    },
    {
      ""Issue"": ""Reliance on delegatecall in upgrade and TokenDeployer without proper access control"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `upgrade` function uses `delegatecall` to call the `setup` function on the new implementation. If a privileged role can call `_deployToken`, it creates a potential vulnerability. An attacker could manipulate the deployment process or deploy malicious contracts using the `TokenDeployer`\'s logic if the privileged roles get compromised. Additionally, the function doesn't validate the `setupParams` provided to the `setup` function of the new implementation."",
      ""Impact"": ""Potentially broken contract state if the setup function fails, potential for unauthorized token deployments, creation of malicious tokens, and compromise of the token ecosystem. Compromised contract state, potential denial of service if the setup function fails in an unrecoverable way due to malicious parameters."",
      ""Location"": ""upgrade function, AxelarGateway.sol:254-258""
    },
    {
      ""Issue"": ""Lack of Command Execution Check in `validateContractCall` and `validateContractCallAndMint`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `validateContractCall` and `validateContractCallAndMint` functions do not check if the `commandId` has already been executed. This could lead to replay attacks, where the same command is executed multiple times."",
      ""Impact"": ""Potential for replay attacks, allowing malicious actors to re-execute commands and potentially manipulate the state of the contract or related systems."",
      ""Location"": ""AxelarGateway.sol: `validateContractCall` (lines 146-150) and `validateContractCallAndMint` (lines 152-164)""
    },
    {
      ""Issue"": ""Delegatecall to `TOKEN_DEPLOYER_IMPLEMENTATION` Without Input Sanitization"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_deployToken` function uses `TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall` to deploy new tokens. It checks `success`, it doesn't validate the return value `data` before decoding it with `abi.decode`. A compromised or malicious `TOKEN_DEPLOYER_IMPLEMENTATION` could return unexpected or malicious data, potentially leading to incorrect token address assignment or other unintended consequences. Additionally, lack of gas limit can lead to out of gas revert."",
      ""Impact"": ""Potential for incorrect token address assignment, malicious code execution via unexpected data, or denial-of-service."",
      ""Location"": ""AxelarGateway.sol: Lines 314-318""
    },
    {
      ""Issue"": ""Reliance on `codehash` for Upgrade Verification"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `upgrade` function verifies the new implementation using `newImplementation.codehash`. While this provides a basic level of assurance, `codehash` collisions are theoretically possible, meaning a different contract with the same `codehash` could potentially be used as the new implementation."",
      ""Impact"": ""Potential for deploying unintended or malicious contract implementations if a `codehash` collision occurs."",
      ""Location"": ""AxelarGateway.sol: Line 280""
    },
    {
      ""Issue"": ""Potential for DoS in `_burnToken` with External Tokens"",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `_burnToken` function, when burning external tokens, a `DepositHandler` contract is created and used to transfer tokens to the gateway. This relies on the `IERC20.transfer` function of the external token. If the external token\'s `transfer` function reverts or is extremely gas intensive, this could lead to a denial-of-service (DoS) where burning tokens fails."",
      ""Impact"": ""Potential denial-of-service when burning external tokens due to issues with the external token\'s `transfer` function."",
      ""Location"": ""AxelarGateway.sol: Lines 366-379""
    },
    {
      ""Issue"": ""Unprotected admin functions can cause unexpected errors"",
      ""Severity"": ""Medium"",
      ""Description"": ""The admin functions (freezeToken, unfreezeToken, freezeAllTokens, unfreezeAllTokens, upgrade) are guarded using onlyAdmin modifier. If the admin multisig is configured incorrectly these functions may cause unexpected errors due to lack of quorum."",
      ""Impact"": ""Loss of functionality."",
      ""Location"": ""AxelarGateway.sol: Lines 242-291""
    },
    {
      ""Issue"": ""Token Deployment Logic Inconsistency: `_deployToken` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_deployToken` function has different logic depending on whether `tokenAddress` is provided. There is no explicit check to ensure the `tokenAddress` actually implements the IERC20 interface and no access control to call `_deployToken`, and they can effectively register any contract as a token."",
      ""Impact"": ""Potential for misuse of the gateway with arbitrary smart contracts impersonating tokens, leading to loss of funds or unexpected behavior."",
      ""Location"": ""AxelarGateway.sol: Lines 276-310""
    },
    {
      ""Issue"": ""Inconsistent use of delegatecall without proper gas limit"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `upgrade` function uses `delegatecall` to call the `setup` function on the new implementation and it forwards the remaining gas to the called function. If the `setup` function consumes excessive gas, the transaction might revert due to out-of-gas (OOG) errors. "",
      ""Impact"": ""Potential for transaction failures due to OOG errors, making the upgrade process unreliable and susceptible to denial-of-service attacks."",
      ""Location"": ""AxelarGateway.sol:197-201""
    },
    {
      ""Issue"": ""Lack of proper input validation in `_burnTokenFrom` for external tokens."",
      ""Severity"": ""Medium"",
      ""Description"": ""The `_burnTokenFrom` function handles burning of internal and external tokens. For external tokens, it only checks that the token exists and performs a `transferFrom` from the sender to the contract. It does *not* validate that the contract is approved to spend the tokens."",
      ""Impact"": ""Transaction might unexpectedly fail, if the user has not approved the gateway to spend their tokens. Makes UX worse."",
      ""Location"": ""AxelarGateway.sol:220-226""
    },
     {
      ""Issue"": ""Potential Denial-of-Service in Admin Functions due to unbounded iteration"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `admins` function iterates through all admins for a specific epoch using a loop. If the number of admins is sufficiently large, this iteration could consume a significant amount of gas, potentially exceeding the block gas limit and causing a denial-of-service."",
      ""Impact"": ""Inability to retrieve admin information, which could disrupt governance and critical administrative functions."",
      ""Location"": ""AxelarGateway.sol:134-140""
    },
    {
       ""Issue"": ""Missing Zero Address Check for `tokenDeployerImplementation` in Constructor and for NewImplementation in Upgrade"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor initializes `TOKEN_DEPLOYER_IMPLEMENTATION` but does not check if the provided `tokenDeployerImplementation` address is the zero address and upgrade function lacks proper validation that `newImplementation` address is actually a contract. If `TOKEN_DEPLOYER_IMPLEMENTATION` is the zero address, then the `delegatecall` to it in `_deployToken` will always fail, effectively disabling token deployment functionality"",
      ""Impact"": ""Token deployment functionality disabled if `tokenDeployerImplementation` is zero address, The gateway can be rendered unusable, disrupting cross-chain functionality."",
      ""Location"": ""AxelarGateway.sol: Line 56, AxelarGateway.sol: Lines 232-233, 237-240""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `_getIsContractCallApprovedWithMintKey`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `_getIsContractCallApprovedWithMintKey` takes `uint256 amount` as input and includes it in the `keccak256` hash. If `amount` is sufficiently large, the encoding process or subsequent hash calculation might be vulnerable to integer overflow issues, potentially leading to collisions in the generated key."",
      ""Impact"": ""Unintended contract call approval due to hash collisions."",
      ""Location"": ""`AxelarGateway.sol:_getIsContractCallApprovedWithMintKey`""
    },
    {
      ""Issue"": ""Lack of events emitted when setting implementation"",
      ""Severity"": ""Low"",
      ""Description"": ""When setting implementation using `_setImplementation`, no event is emitted to notify of the change of address."",
      ""Impact"": ""Limited observability and auditability"",
      ""Location"": ""`AxelarGateway.sol:_setImplementation`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in `_getAdminCount` Loop"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `admins` function, the loop iterates up to `_getAdminCount(epoch)`. While unlikely with reasonable admin counts, there is no explicit check within `_getAdminCount` or the loop to prevent integer overflows or underflows if the returned value is excessively large or negative."",
      ""Impact"": ""Potential for unexpected loop behavior leading to gas exhaustion or reverts (unlikely but possible)."",
      ""Location"": ""Function: `admins`""
    },
    {
      ""Issue"": ""Potential DOS in `admins` function due to unbounded loop."",
      ""Severity"": ""Low"",
      ""Description"": ""The `admins` function iterates up to `_getAdminCount(epoch)` and retrieves each admin address. If `_getAdminCount(epoch)` returns a very large number this could cause the function to run out of gas and revert."",
      ""Impact"": ""Denial of service by making the `admins` function unusable."",
      ""Location"": ""admins function, AxelarGateway.sol: `admins` function (lines 117-123)""
    },
    {
      ""Issue"": ""Lack of overflow check in _mintToken and _burnTokenFrom functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_mintToken` and `_burnTokenFrom` functions handle token amounts. Although the `amount` parameter is a `uint256`, there\'s no explicit check to prevent integer overflows when performing calculations involving the `amount` or other related state variables within the function."",
      ""Impact"": ""Potential for unexpected behavior due to integer overflow if the token contract doesn\'t use safe math operations."",
      ""Location"": ""_mintToken, _burnTokenFrom functions""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Admin Multisig Logic, adminEpoch and adminThreshold"",
      ""Severity"": ""Low"",
      ""Description"": ""The inherited `AdminMultisigBase.sol` contract might have potential vulnerabilities if the number of admins becomes extremely large or the epoch management is flawed. It is imperative to check against integer overflows/underflows since incorrect epoch values could lead to erroneous admin details or a denial-of-service."",
      ""Impact"": ""Compromised admin control, potential unauthorized actions, incorrect admin details or denial-of-service."",
      ""Location"": ""Dependent on the implementation in `AdminMultisigBase.sol`, AxelarGateway.sol: Lines 230-238""
    },
    {
      ""Issue"": ""Inconsistent Security Checks on External vs. Internal Tokens"",
      ""Severity"": ""Medium"",
      ""Description"": ""The code distinguishes between external and internal tokens, but the security checks applied to them are not consistent. The `_checkTokenStatus` function is called before `transfer` for external tokens, but not before burning internal tokens, creating an exploitable difference in how the gateway handles tokens."",
      ""Impact"": ""Potential for bypassing security checks (e.g., token freeze) for internal tokens, leading to unauthorized transactions."",
      ""Location"": ""AxelarGateway.sol: `_mintToken` (lines 335-343) and `_burnTokenFrom` (lines 259-296)""
    },
    {
      ""Issue"": ""Token freezing mechanism can be bypassed with external tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_checkTokenStatus` function is called before minting or burning tokens, but this protection only works for the `_mintToken` and `_burnTokenFrom` functions. External contracts can directly transfer tokens into the gateway contract, and the contract will not prevent them from being used."",
      ""Impact"": ""The token freezing mechanism is not a comprehensive solution for external tokens. There are still ways to bypass it."",
      ""Location"": ""AxelarGateway.sol:456""
    },
     {
      ""Issue"": ""Potential DOS via long strings in `_approveContractCall` and `_approveContractCallWithMint`"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `_approveContractCall` and `_approveContractCallWithMint` take `sourceChain` and `sourceAddress` as input and use them in the calculation of storage keys. If very long strings are passed as these parameters, they could potentially cause a denial-of-service (DOS) attack by consuming excessive gas during storage operations."",
      ""Impact"": ""Potential denial-of-service by consuming excessive gas during storage operations."",
      ""Location"": ""AxelarGateway.sol: Lines 436,468, _getIsContractCallApprovedKey(), _getIsContractCallApprovedWithMintKey()""
    },
   {
      ""Issue"": ""Potential for rounding errors with external tokens"",
      ""Severity"": ""Low"",
      ""Description"": ""When dealing with external tokens, the `decimals` value might differ from the internal representation used by the AxelarGateway. This can lead to rounding errors when converting amounts between the two representations, potentially causing minor discrepancies in token transfers"",
      ""Impact"": ""Potential discrepancies in token transfers due to rounding errors, impacting the accuracy of cross-chain transfers."",
      ""Location"": ""AxelarGateway.sol""
    }
  ],
  ""IssueNumber"": 62,
  ""OutputList"": 32
}",270.1495130062103,4314.0,32.0,"### **Comparison of Issue Report and Response List**

---

#### **[H-01] Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded**

**Report Description**:  
The `callContractWithToken` function does not account for contract call failures on the destination chain. If a contract call fails, the tokens burned on the source chain are not refunded, leading to potential loss of user funds. This is a significant risk, especially when dealing with untrusted or unreliable destination chains.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unrefunded tokens in the event of a failed cross-chain contract call. This is a critical oversight, as it directly impacts user funds and the reliability of the cross-chain system.

---

#### **[M-01] Low level call returns true if the address doesn't exist**

**Report Description**:  
The Solidity documentation states that low-level functions like `call`, `delegatecall`, and `staticcall` return `true` if the account called is non-existent. This behavior can lead to incorrect assumptions about the success of a call if the account existence is not validated beforehand.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of low-level calls returning `true` for non-existent accounts. This is a common Solidity pitfall and should be explicitly addressed in the response list.

---

#### **[M-02] User's funds can get lost when transferring to other chain**

**Report Description**:  
When transferring tokens to another chain, the tokens are burned on the source chain. If the `AxelarGateway` does not have the required amount of tokens on the destination chain, the `_callERC20Token` function will fail, causing the `_mintToken` function to revert. This results in the user losing their funds on the destination chain, even though they paid the required amount on the source chain.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of lost funds due to insufficient tokens in the `AxelarGateway` on the destination chain. This is a significant risk that should be mitigated.

---

#### **[M-04] Unsupported fee-on-transfer tokens**

**Report Description**:  
When `tokenAddress` is a fee-on-transfer token, the `_burnTokenFrom` function does not account for the reduced amount of tokens received by the contract. This discrepancy can lead to incorrect token balances and potential vulnerabilities.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens, which can lead to incorrect token balances and potential vulnerabilities. This is a common issue in token handling and should be explicitly addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded**  
- **[M-01] Low level call returns true if the address doesn't exist**  
- **[M-02] User's funds can get lost when transferring to other chain**  
- **[M-04] Unsupported fee-on-transfer tokens**

---

### **Conclusion**

The response list does not adequately address the issues raised in the issue report. Critical vulnerabilities related to cross-chain token handling, low-level calls, and fee-on-transfer tokens are entirely missed. These issues represent significant risks to the security and functionality of the smart contract system and should be addressed in the response list.","```
None.
```","The **Average Precision (AP)** for the query is **0.0**. Since there are no true positives in the ranked list of predictions, the precision at any rank is 0, and the average of these values is also 0."
