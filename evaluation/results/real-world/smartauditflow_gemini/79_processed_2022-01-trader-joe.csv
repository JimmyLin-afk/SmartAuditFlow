nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
LaunchEvent.sol,"// SPDX-License-Identifier: None
// Copyright (c) 2022 Trader Joe - All rights reserved

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./interfaces/IJoeFactory.sol"";
import ""./interfaces/IJoePair.sol"";
import ""./interfaces/IJoeRouter02.sol"";
import ""./interfaces/IRocketJoeFactory.sol"";
import ""./interfaces/IRocketJoeToken.sol"";
import ""./interfaces/IWAVAX.sol"";

/// @title Rocket Joe Launch Event
/// @author Trader Joe
/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price
contract LaunchEvent is Ownable {
    /// @notice The phases the launch event can be in
    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw
    enum Phase {
        NotStarted,
        PhaseOne,
        PhaseTwo,
        PhaseThree
    }

    struct UserInfo {
        /// @notice How much AVAX user can deposit for this launch event
        /// @dev Can be increased by burning more rJOE, but will always be
        /// smaller than `maxAllocation`
        uint256 allocation;
        /// @notice How much AVAX user has deposited for this launch event
        uint256 balance;
        /// @notice Whether user has withdrawn the LP
        bool hasWithdrawnPair;
        /// @notice Whether user has withdrawn the issuing token incentives
        bool hasWithdrawnIncentives;
    }

    /// @notice Issuer of sale tokens
    address public issuer;

    /// @notice The start time of phase 1
    uint256 public auctionStart;

    uint256 public PHASE_ONE_DURATION;
    uint256 public PHASE_ONE_NO_FEE_DURATION;
    uint256 public PHASE_TWO_DURATION;

    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,
    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.
    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,
    /// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives
    uint256 public tokenIncentivesPercent;

    /// @notice Floor price in AVAX per token (can be 0)
    /// @dev floorPrice is scaled to 1e18
    uint256 public floorPrice;

    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens
    uint256 public userTimelock;

    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens
    uint256 public issuerTimelock;

    /// @notice The max withdraw penalty during phase 1, in parts per 1e18
    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17
    uint256 public maxWithdrawPenalty;

    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18
    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`
    uint256 public fixedWithdrawPenalty;

    IRocketJoeToken public rJoe;
    uint256 public rJoePerAvax;
    IWAVAX private WAVAX;
    IERC20Metadata public token;

    IJoeRouter02 private router;
    IJoeFactory private factory;
    IRocketJoeFactory public rocketJoeFactory;

    bool private initialized;
    bool public stopped;

    uint256 public maxAllocation;

    mapping(address => UserInfo) public getUserInfo;

    /// @dev The address of the JoePair, set after createLiquidityPool is called
    IJoePair public pair;

    /// @dev The total amount of wavax that was sent to the router to create the initial liquidity pair.
    /// Used to calculate the amount of LP to send based on the user's participation in the launch event
    uint256 private wavaxAllocated;

    /// @dev The exact supply of LP minted when creating the initial liquidity pair.
    uint256 private lpSupply;

    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial
    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`
    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed
    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,
    /// tokenReserve will be equal to 0)
    uint256 private tokenReserve;

    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right
    /// amounts to issuer and users
    uint256 private tokenIncentivesBalance;
    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created
    uint256 private tokenIncentivesForUsers;
    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.
    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there
    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`
    uint256 private tokenIncentiveIssuerRefund;

    /// @dev wavaxReserve is the exact amount of WAVAX that needs to be kept inside the contract in order to send everyone's
    /// WAVAX. If there is some excess (because someone sent token directly to the contract), the
    /// penaltyCollector can collect the excess using `skim()`
    uint256 private wavaxReserve;

    event IssuingTokenDeposited(address indexed token, uint256 amount);

    event UserParticipated(
        address indexed user,
        uint256 avaxAmount,
        uint256 rJoeAmount
    );

    event UserWithdrawn(address indexed user, uint256 avaxAmount);

    event LiquidityPoolCreated(
        address indexed pair,
        address indexed token0,
        address indexed token1,
        uint256 amount0,
        uint256 amount1
    );

    event UserLiquidityWithdrawn(
        address indexed user,
        address indexed pair,
        uint256 amount
    );

    event IssuerLiquidityWithdrawn(
        address indexed issuer,
        address indexed pair,
        uint256 amount
    );

    event Stopped();

    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);

    event TokenEmergencyWithdraw(address indexed user, uint256 amount);

    /// @notice Receive AVAX from the WAVAX contract
    /// @dev Needed for withdrawing from WAVAX contract
    receive() external payable {
        require(
            msg.sender == address(WAVAX),
            ""LaunchEvent: you can't send AVAX directly to this contract""
        );
    }

    /// @notice Modifier which ensures contract is in a defined phase
    modifier atPhase(Phase _phase) {
        _atPhase(_phase);
        _;
    }

    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed
    modifier timelockElapsed() {
        uint256 phase3Start = auctionStart +
            PHASE_ONE_DURATION +
            PHASE_TWO_DURATION;
        if (msg.sender == issuer) {
            require(
                block.timestamp > phase3Start + issuerTimelock,
                ""LaunchEvent: can't withdraw before issuer's timelock""
            );
        } else {
            require(
                block.timestamp > phase3Start + userTimelock,
                ""LaunchEvent: can't withdraw before user's timelock""
            );
        }
        _;
    }

    /// @notice Ensures launch event is stopped/running
    modifier isStopped(bool _stopped) {
        if (_stopped) {
            require(stopped, ""LaunchEvent: is still running"");
        } else {
            require(!stopped, ""LaunchEvent: stopped"");
        }
        _;
    }

    /// @notice Initialise the launch event with needed paramaters
    /// @param _issuer Address of the token issuer
    /// @param _auctionStart The start time of the auction
    /// @param _token The contract address of auctioned token
    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives
    /// @param _floorPrice The minimum price the token is sold at
    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18
    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18
    /// @param _maxAllocation The maximum amount of AVAX depositable
    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity
    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity
    /// @dev This function is called by the factory immediately after it creates the contract instance
    function initialize(
        address _issuer,
        uint256 _auctionStart,
        address _token,
        uint256 _tokenIncentivesPercent,
        uint256 _floorPrice,
        uint256 _maxWithdrawPenalty,
        uint256 _fixedWithdrawPenalty,
        uint256 _maxAllocation,
        uint256 _userTimelock,
        uint256 _issuerTimelock
    ) external atPhase(Phase.NotStarted) {
        require(!initialized, ""LaunchEvent: already initialized"");

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
        WAVAX = IWAVAX(rocketJoeFactory.wavax());
        router = IJoeRouter02(rocketJoeFactory.router());
        factory = IJoeFactory(rocketJoeFactory.factory());
        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());
        rJoePerAvax = rocketJoeFactory.rJoePerAvax();

        require(
            _maxWithdrawPenalty <= 5e17,
            ""LaunchEvent: maxWithdrawPenalty too big""
        ); // 50%
        require(
            _fixedWithdrawPenalty <= 5e17,
            ""LaunchEvent: fixedWithdrawPenalty too big""
        ); // 50%
        require(
            _userTimelock <= 7 days,
            ""LaunchEvent: can't lock user LP for more than 7 days""
        );
        require(
            _issuerTimelock > _userTimelock,
            ""LaunchEvent: issuer can't withdraw before users""
        );
        require(
            _auctionStart > block.timestamp,
            ""LaunchEvent: start of phase 1 cannot be in the past""
        );

        issuer = _issuer;

        auctionStart = _auctionStart;
        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();
        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();
        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();

        token = IERC20Metadata(_token);
        uint256 balance = token.balanceOf(address(this));

        tokenIncentivesPercent = _tokenIncentivesPercent;

        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`
        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).
        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`
        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);
        tokenIncentivesForUsers = balance - tokenReserve;
        tokenIncentivesBalance = tokenIncentivesForUsers;

        floorPrice = _floorPrice;

        maxWithdrawPenalty = _maxWithdrawPenalty;
        fixedWithdrawPenalty = _fixedWithdrawPenalty;

        maxAllocation = _maxAllocation;

        userTimelock = _userTimelock;
        issuerTimelock = _issuerTimelock;
        initialized = true;
    }

    /// @notice The current phase the auction is in
    function currentPhase() public view returns (Phase) {
        if (block.timestamp < auctionStart || auctionStart == 0) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp <
            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }

    /// @notice Deposits AVAX and burns rJoe
    /// @dev Checks are done in the `_depositWAVAX` function
    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        // check if additional allocation is required.
        if (newAllocation > user.allocation) {
            // Burn tokens and update allocation.
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            // Set allocation to the current balance as it's impossible
            // to buy more allocation without sending AVAX too
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        wavaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        WAVAX.deposit{value: msg.value}();

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }

    /// @notice Withdraw AVAX, only permitted during phase 1 and 2
    /// @param _amount The amount of AVAX to withdraw
    function withdrawAVAX(uint256 _amount) public isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        wavaxReserve -= _amount;

        WAVAX.withdraw(_amount);
        _safeTransferAVAX(msg.sender, amountMinusFee);
        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
    }

    /// @notice Create the JoePair
    /// @dev Can only be called once after phase 3 has started
    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        require(
            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||
                IJoePair(
                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)
                ).totalSupply() ==
                0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(wavaxReserve > 0, ""LaunchEvent: no wavax balance"");

        uint256 tokenAllocated = tokenReserve;

        // Adjust the amount of tokens sent to the pool if floor price not met
        if (
            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated
        ) {
            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        WAVAX.approve(address(router), wavaxReserve);
        token.approve(address(router), tokenAllocated);

        /// We can't trust the output cause of reflect tokens
        (, , lpSupply) = router.addLiquidity(
            wavaxAddress, // tokenA
            tokenAddress, // tokenB
            wavaxReserve, // amountADesired
            tokenAllocated, // amountBDesired
            wavaxReserve, // amountAMin
            tokenAllocated, // amountBMin
            address(this), // to
            block.timestamp // deadline
        );

        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));
        wavaxAllocated = wavaxReserve;
        wavaxReserve = 0;

        tokenReserve -= tokenAllocated;

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            wavaxAllocated
        );
    }

    /// @notice Withdraw liquidity pool tokens
    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnPair,
            ""LaunchEvent: liquidity already withdrawn""
        );

        uint256 balance = pairBalance(msg.sender);
        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            balance = lpSupply / 2;

            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);

            if (tokenReserve > 0) {
                uint256 amount = tokenReserve;
                tokenReserve = 0;
                token.transfer(msg.sender, amount);
            }
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }

    /// @notice Withdraw incentives tokens
    function withdrawIncentives() external isStopped(false) {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnIncentives,
            ""LaunchEvent: incentives already withdrawn""
        );

        user.hasWithdrawnIncentives = true;
        uint256 amount;

        if (msg.sender == issuer) {
            amount = tokenIncentiveIssuerRefund;
        } else {
            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;
        }

        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        tokenIncentivesBalance -= amount;

        token.transfer(msg.sender, amount);
    }

    /// @notice Withdraw AVAX if launch has been cancelled
    function emergencyWithdraw() external isStopped(true) {
        if (msg.sender != issuer) {
            UserInfo storage user = getUserInfo[msg.sender];
            require(
                user.balance > 0,
                ""LaunchEvent: expected user to have non-zero balance to perform emergency withdraw""
            );

            uint256 balance = user.balance;
            user.balance = 0;
            wavaxReserve -= balance;
            WAVAX.withdraw(balance);

            _safeTransferAVAX(msg.sender, balance);

            emit AvaxEmergencyWithdraw(msg.sender, balance);
        } else {
            uint256 balance = tokenReserve + tokenIncentivesBalance;
            tokenReserve = 0;
            tokenIncentivesBalance = 0;
            token.transfer(issuer, balance);
            emit TokenEmergencyWithdraw(msg.sender, balance);
        }
    }

    /// @notice Stops the launch event and allows participants withdraw deposits
    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }

    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.
    /// Any excess tokens are sent to the penaltyCollector
    function skim() external {
        address penaltyCollector = rocketJoeFactory.penaltyCollector();

        uint256 excessToken = token.balanceOf(address(this)) -
            tokenReserve -
            tokenIncentivesBalance;
        if (excessToken > 0) {
            token.transfer(penaltyCollector, excessToken);
        }

        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;
        if (excessWavax > 0) {
            WAVAX.transfer(penaltyCollector, excessWavax);
        }

        uint256 excessAvax = address(this).balance;
        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);
    }

    /// @notice Returns the current penalty for early withdrawal
    /// @return The penalty to apply to a withdrawal amount
    function getPenalty() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - auctionStart;
        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {
            return 0;
        } else if (timeElapsed < PHASE_ONE_DURATION) {
            return
                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *
                    maxWithdrawPenalty) /
                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);
        }
        return fixedWithdrawPenalty;
    }

    /// @notice Returns the current balance of the pool
    /// @return The balances of WAVAX and issued token held by the launch contract
    function getReserves() external view returns (uint256, uint256) {
        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);
    }

    /// @notice Get the rJOE amount needed to deposit AVAX
    /// @param _avaxAmount The amount of AVAX to deposit
    /// @return The amount of rJOE needed
    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {
        return _avaxAmount * rJoePerAvax;
    }

    /// @notice The total amount of liquidity pool tokens the user can withdraw
    /// @param _user The address of the user to check
    function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        return (user.balance * lpSupply) / wavaxAllocated / 2;
    }

    /// @dev Bytecode size optimization for the `atPhase` modifier.
    /// This works becuase internal functions are not in-lined in modifiers
    function _atPhase(Phase _phase) internal view {
        if (_phase == Phase.NotStarted) {
            require(
                currentPhase() == Phase.NotStarted,
                ""LaunchEvent: not in not started""
            );
        } else if (_phase == Phase.PhaseOne) {
            require(
                currentPhase() == Phase.PhaseOne,
                ""LaunchEvent: not in phase one""
            );
        } else if (_phase == Phase.PhaseTwo) {
            require(
                currentPhase() == Phase.PhaseTwo,
                ""LaunchEvent: not in phase two""
            );
        } else if (_phase == Phase.PhaseThree) {
            require(
                currentPhase() == Phase.PhaseThree,
                ""LaunchEvent: not in phase three""
            );
        } else {
            revert(""LaunchEvent: unknown state"");
        }
    }

    /// @notice Send AVAX
    /// @param _to The receiving address
    /// @param _value The amount of AVAX to send
    /// @dev Will revert on failure
    function _safeTransferAVAX(address _to, uint256 _value) internal {
        (bool success, ) = _to.call{value: _value}(new bytes(0));
        require(success, ""LaunchEvent: avax transfer failed"");
    }
}

",5261,626,"[H-01] Users can lose value in emergency state

Submitted by cmichel, also found by static
Imagine the following sequence of events:
LaunchEvent.createPair() is called which sets wavaxReserve = 0, adds liquidity to the pair and receives lpSupply LP tokens.
LaunchEvent.allowEmergencyWithdraw() is called which enters emergency / paused mode and disallows normal withdrawals.
Users can only call LaunchEvent.emergencyWithdraw which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.
   [H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached

Submitted by cmichel
In LaunchEvent.createPair, when the floor price is not reached (floorPrice > wavaxReserve * 1e18 / tokenAllocated), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.
Note that the floorPrice is supposed to have a precision of 18:
/// @param _floorPrice Price of each token in AVAX, scaled to 1e18
The floorPrice > (wavaxReserve * 1e18) / tokenAllocated check is correct but the tokenAllocated computation involves the token decimals:
// @audit should be wavaxReserve * 1e18 / floorPrice
tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;

This computation does not work for tokens that don't have 18 decimals.
  
[M-02] Owner of LaunchEvent token has the ability to DOS attack the event

The owner of the token for which the `LaunchEvent` was created, has the ability to DOS attack the event. They can prevent the LaunchEvent from creating a JoePair which in turn limits the access to the following two functions: withdrawLiquidity() & withdrawIncentives(). Thus, stopping anybody from withdrawing their LP tokens.
The owner of the RocketJoe platform has the ability to enable the emergency withdrawal allowing the depositors to take back their AVAX. But, they lose their burned rJOE tokens and the gas fees.
The dev team might use this attack vector if they think the price of their token is too low. In that case, they can DOS attack the LaunchEvent. If the RocketJoe owner enables the emergency withdrawal, the dev team is able to take back their initial deposit. Thus, they don't lose anything but their reputation.
  [M-05] Failed transfer with low level call could be overlooked

Submitted by harleythedog, also found by sirhashalot
In LaunchEvent.sol, the function _safeTransferAVAX is as follows:
function _safeTransferAVAX(address _to, uint256 _value) internal {
    (bool success, ) = _to.call{value: _value}(new bytes(0));
    require(success, ""LaunchEvent: avax transfer failed"");
}

This function is utilized in a few different places in the contract. According to the Solidity docs), ""The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed"".
As a result, it is possible that this call will fail, but _safeTransferAVAX will not notice anything went wrong. In particular, it is possible that the address rocketJoeFactory.penaltyCollector() is a deleted contract (perhaps a security flaw was found and selfdestruct was called so that users know to use an updated smart contract), but _safeTransferAVAX will not revert. If rocketJoeFactory.penaltyCollector() is indeed a non-existent contract, it would be better for _safeTransferAVAX to revert until an admin can manually correct the penaltyCollector in the factory.
 
[M-07] withdrawAVAX() function has call to sender without reentrancy protection

Submitted by jayjonah8
In LauchEvent.sol the `withdrawAVAX()` function makes an external call to the msg.sender by way of _safeTransferAVAX. This allows the caller to reenter this and other functions in this and other protocol files. To prevent reentrancy and cross function reentrancy there should be reentrancy guard modifiers placed on the withdrawAVAX() function and any other function that makes external calls to the caller.
 
[M-08] LP Tokens May Be Locked in Contract Due to allowEmergencyWithdraw() in Stage 3

Submitted by kirk-baird
The function `allowEmergencyWithdraw()` may be called by the rocketJoeFactory.owner() at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.
Proof of Concept

If allowEmergencyWithdraw() is called stopped is set to true. As a result functions withdrawIncentives() and withdrawLiquidity() will revert due to the isStopped(false) modifier reverting.
Additionally, emergencyWithdraw() will revert since all the WAVAX and token balances have been transferred to the liquidity pool.
Thus, depositors and issuers will have no methods of removing their LP tokens or incentives.
  [M-09] createPair() expects zero slippage

The LaunchEvent.sol `createPair()` function calls router.addLiquidity() with a amountADesired == amountAMin and amountBDesired == amountBMin. Because there is no allowance for slippage, if the zero slippage requirement is not met then the addLiquidity() function will revert and prevent users from using the createPair() function. This could be caused either by frontrunning the createPair call or in a situation where the liquidity pool exists but does not allow for zero slippage with the assets it is holding.
  [M-10] Use safeTransfer/safeTransferFrom consistently instead of `transfer/transferFrom`
 It is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin’s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.
  [M-12] Pair creation can be denied

Submitted by cmichel, also found by harleythedog, UncleGrandpa925, and WatchPug
The LaunchEvent.createPair requires that no previous pool was created for the WAVAX <> _token pair.
function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
    (address wavaxAddress, address tokenAddress) = (
        address(WAVAX),
        address(token)
    );
    // @audit grief: anyone can create pair
    require(
        factory.getPair(wavaxAddress, tokenAddress) == address(0),
        ""LaunchEvent: pair already created""
    );

    // ...
}

A griefer can create a pool for the WAVAX <> _token pair by calling JoeFactory.createPair(WAVAX, _token) while the launch event phase 1 or 2 is running. No liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.
",9,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";

import ""./interfaces/IJoeFactory.sol"";
import ""./interfaces/IJoePair.sol"";
import ""./interfaces/IJoeRouter02.sol"";
import ""./interfaces/IRocketJoeFactory.sol"";
import ""./interfaces/IRocketJoeToken.sol"";
import ""./interfaces/IWAVAX.sol"";




contract LaunchEvent is Ownable {
    
    
    enum Phase {
        NotStarted,
        PhaseOne,
        PhaseTwo,
        PhaseThree
    }

    struct UserInfo {
        
        
        
        uint256 allocation;
        
        uint256 balance;
        
        bool hasWithdrawnPair;
        
        bool hasWithdrawnIncentives;
    }

    
    address public issuer;

    
    uint256 public auctionStart;

    uint256 public PHASE_ONE_DURATION;
    uint256 public PHASE_ONE_NO_FEE_DURATION;
    uint256 public PHASE_TWO_DURATION;

    
    
    
    
    uint256 public tokenIncentivesPercent;

    
    
    uint256 public floorPrice;

    
    uint256 public userTimelock;

    
    uint256 public issuerTimelock;

    
    
    uint256 public maxWithdrawPenalty;

    
    
    uint256 public fixedWithdrawPenalty;

    IRocketJoeToken public rJoe;
    uint256 public rJoePerAvax;
    IWAVAX private WAVAX;
    IERC20Metadata public token;

    IJoeRouter02 private router;
    IJoeFactory private factory;
    IRocketJoeFactory public rocketJoeFactory;

    bool private initialized;
    bool public stopped;

    uint256 public maxAllocation;

    mapping(address => UserInfo) public getUserInfo;

    
    IJoePair public pair;

    
    
    uint256 private wavaxAllocated;

    
    uint256 private lpSupply;

    
    
    
    
    
    uint256 private tokenReserve;

    
    
    uint256 private tokenIncentivesBalance;
    
    uint256 private tokenIncentivesForUsers;
    
    
    
    uint256 private tokenIncentiveIssuerRefund;

    
    
    
    uint256 private wavaxReserve;

    event IssuingTokenDeposited(address indexed token, uint256 amount);

    event UserParticipated(
        address indexed user,
        uint256 avaxAmount,
        uint256 rJoeAmount
    );

    event UserWithdrawn(address indexed user, uint256 avaxAmount);

    event LiquidityPoolCreated(
        address indexed pair,
        address indexed token0,
        address indexed token1,
        uint256 amount0,
        uint256 amount1
    );

    event UserLiquidityWithdrawn(
        address indexed user,
        address indexed pair,
        uint256 amount
    );

    event IssuerLiquidityWithdrawn(
        address indexed issuer,
        address indexed pair,
        uint256 amount
    );

    event Stopped();

    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);

    event TokenEmergencyWithdraw(address indexed user, uint256 amount);

    
    
    receive() external payable {
        require(
            msg.sender == address(WAVAX),
            ""LaunchEvent: you can't send AVAX directly to this contract""
        );
    }

    
    modifier atPhase(Phase _phase) {
        _atPhase(_phase);
        _;
    }

    
    modifier timelockElapsed() {
        uint256 phase3Start = auctionStart +
            PHASE_ONE_DURATION +
            PHASE_TWO_DURATION;
        if (msg.sender == issuer) {
            require(
                block.timestamp > phase3Start + issuerTimelock,
                ""LaunchEvent: can't withdraw before issuer's timelock""
            );
        } else {
            require(
                block.timestamp > phase3Start + userTimelock,
                ""LaunchEvent: can't withdraw before user's timelock""
            );
        }
        _;
    }

    
    modifier isStopped(bool _stopped) {
        if (_stopped) {
            require(stopped, ""LaunchEvent: is still running"");
        } else {
            require(!stopped, ""LaunchEvent: stopped"");
        }
        _;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    function initialize(
        address _issuer,
        uint256 _auctionStart,
        address _token,
        uint256 _tokenIncentivesPercent,
        uint256 _floorPrice,
        uint256 _maxWithdrawPenalty,
        uint256 _fixedWithdrawPenalty,
        uint256 _maxAllocation,
        uint256 _userTimelock,
        uint256 _issuerTimelock
    ) external atPhase(Phase.NotStarted) {
        require(!initialized, ""LaunchEvent: already initialized"");

        rocketJoeFactory = IRocketJoeFactory(msg.sender);
        WAVAX = IWAVAX(rocketJoeFactory.wavax());
        router = IJoeRouter02(rocketJoeFactory.router());
        factory = IJoeFactory(rocketJoeFactory.factory());
        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());
        rJoePerAvax = rocketJoeFactory.rJoePerAvax();

        require(
            _maxWithdrawPenalty <= 5e17,
            ""LaunchEvent: maxWithdrawPenalty too big""
        ); 
        require(
            _fixedWithdrawPenalty <= 5e17,
            ""LaunchEvent: fixedWithdrawPenalty too big""
        ); 
        require(
            _userTimelock <= 7 days,
            ""LaunchEvent: can't lock user LP for more than 7 days""
        );
        require(
            _issuerTimelock > _userTimelock,
            ""LaunchEvent: issuer can't withdraw before users""
        );
        require(
            _auctionStart > block.timestamp,
            ""LaunchEvent: start of phase 1 cannot be in the past""
        );

        issuer = _issuer;

        auctionStart = _auctionStart;
        PHASE_ONE_DURATION = rocketJoeFactory.PHASE_ONE_DURATION();
        PHASE_ONE_NO_FEE_DURATION = rocketJoeFactory.PHASE_ONE_NO_FEE_DURATION();
        PHASE_TWO_DURATION = rocketJoeFactory.PHASE_TWO_DURATION();

        token = IERC20Metadata(_token);
        uint256 balance = token.balanceOf(address(this));

        tokenIncentivesPercent = _tokenIncentivesPercent;

        
        
        
        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);
        tokenIncentivesForUsers = balance - tokenReserve;
        tokenIncentivesBalance = tokenIncentivesForUsers;

        floorPrice = _floorPrice;

        maxWithdrawPenalty = _maxWithdrawPenalty;
        fixedWithdrawPenalty = _fixedWithdrawPenalty;

        maxAllocation = _maxAllocation;

        userTimelock = _userTimelock;
        issuerTimelock = _issuerTimelock;
        initialized = true;
    }

    
    function currentPhase() public view returns (Phase) {
        if (block.timestamp < auctionStart || auctionStart == 0) {
            return Phase.NotStarted;
        } else if (block.timestamp < auctionStart + PHASE_ONE_DURATION) {
            return Phase.PhaseOne;
        } else if (
            block.timestamp <
            auctionStart + PHASE_ONE_DURATION + PHASE_TWO_DURATION
        ) {
            return Phase.PhaseTwo;
        }
        return Phase.PhaseThree;
    }

    
    
    function depositAVAX()
        external
        payable
        isStopped(false)
        atPhase(Phase.PhaseOne)
    {
        require(msg.sender != issuer, ""LaunchEvent: issuer cannot participate"");
        require(
            msg.value > 0,
            ""LaunchEvent: expected non-zero AVAX to deposit""
        );

        UserInfo storage user = getUserInfo[msg.sender];
        uint256 newAllocation = user.balance + msg.value;
        require(
            newAllocation <= maxAllocation,
            ""LaunchEvent: amount exceeds max allocation""
        );

        uint256 rJoeNeeded;
        
        if (newAllocation > user.allocation) {
            
            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);
            
            
            user.allocation = newAllocation;
        }

        user.balance = newAllocation;
        wavaxReserve += msg.value;

        if (rJoeNeeded > 0) {
            rJoe.burnFrom(msg.sender, rJoeNeeded);
        }

        WAVAX.deposit{value: msg.value}();

        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);
    }

    
    
    function withdrawAVAX(uint256 _amount) public isStopped(false) {
        Phase _currentPhase = currentPhase();
        require(
            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,
            ""LaunchEvent: unable to withdraw""
        );
        require(_amount > 0, ""LaunchEvent: invalid withdraw amount"");
        UserInfo storage user = getUserInfo[msg.sender];
        require(
            user.balance >= _amount,
            ""LaunchEvent: withdrawn amount exceeds balance""
        );
        user.balance -= _amount;

        uint256 feeAmount = (_amount * getPenalty()) / 1e18;
        uint256 amountMinusFee = _amount - feeAmount;

        wavaxReserve -= _amount;

        WAVAX.withdraw(_amount);
        _safeTransferAVAX(msg.sender, amountMinusFee);
        if (feeAmount > 0) {
            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);
        }
    }

    
    
    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {
        (address wavaxAddress, address tokenAddress) = (
            address(WAVAX),
            address(token)
        );
        require(
            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||
                IJoePair(
                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)
                ).totalSupply() ==
                0,
            ""LaunchEvent: liquid pair already exists""
        );
        require(wavaxReserve > 0, ""LaunchEvent: no wavax balance"");

        uint256 tokenAllocated = tokenReserve;

        
        if (
            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated
        ) {
            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;
            tokenIncentivesForUsers =
                (tokenIncentivesForUsers * tokenAllocated) /
                tokenReserve;
            tokenIncentiveIssuerRefund =
                tokenIncentivesBalance -
                tokenIncentivesForUsers;
        }

        WAVAX.approve(address(router), wavaxReserve);
        token.approve(address(router), tokenAllocated);

        
        (, , lpSupply) = router.addLiquidity(
            wavaxAddress, 
            tokenAddress, 
            wavaxReserve, 
            tokenAllocated, 
            wavaxReserve, 
            tokenAllocated, 
            address(this), 
            block.timestamp 
        );

        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));
        wavaxAllocated = wavaxReserve;
        wavaxReserve = 0;

        tokenReserve -= tokenAllocated;

        emit LiquidityPoolCreated(
            address(pair),
            tokenAddress,
            wavaxAddress,
            tokenAllocated,
            wavaxAllocated
        );
    }

    
    function withdrawLiquidity() external isStopped(false) timelockElapsed {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnPair,
            ""LaunchEvent: liquidity already withdrawn""
        );

        uint256 balance = pairBalance(msg.sender);
        user.hasWithdrawnPair = true;

        if (msg.sender == issuer) {
            balance = lpSupply / 2;

            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);

            if (tokenReserve > 0) {
                uint256 amount = tokenReserve;
                tokenReserve = 0;
                token.transfer(msg.sender, amount);
            }
        } else {
            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);
        }

        pair.transfer(msg.sender, balance);
    }

    
    function withdrawIncentives() external isStopped(false) {
        require(address(pair) != address(0), ""LaunchEvent: pair not created"");

        UserInfo storage user = getUserInfo[msg.sender];
        require(
            !user.hasWithdrawnIncentives,
            ""LaunchEvent: incentives already withdrawn""
        );

        user.hasWithdrawnIncentives = true;
        uint256 amount;

        if (msg.sender == issuer) {
            amount = tokenIncentiveIssuerRefund;
        } else {
            amount = (user.balance * tokenIncentivesForUsers) / wavaxAllocated;
        }

        require(amount > 0, ""LaunchEvent: caller has no incentive to claim"");

        tokenIncentivesBalance -= amount;

        token.transfer(msg.sender, amount);
    }

    
    function emergencyWithdraw() external isStopped(true) {
        if (msg.sender != issuer) {
            UserInfo storage user = getUserInfo[msg.sender];
            require(
                user.balance > 0,
                ""LaunchEvent: expected user to have non-zero balance to perform emergency withdraw""
            );

            uint256 balance = user.balance;
            user.balance = 0;
            wavaxReserve -= balance;
            WAVAX.withdraw(balance);

            _safeTransferAVAX(msg.sender, balance);

            emit AvaxEmergencyWithdraw(msg.sender, balance);
        } else {
            uint256 balance = tokenReserve + tokenIncentivesBalance;
            tokenReserve = 0;
            tokenIncentivesBalance = 0;
            token.transfer(issuer, balance);
            emit TokenEmergencyWithdraw(msg.sender, balance);
        }
    }

    
    function allowEmergencyWithdraw() external {
        require(
            msg.sender == Ownable(address(rocketJoeFactory)).owner(),
            ""LaunchEvent: caller is not RocketJoeFactory owner""
        );
        stopped = true;
        emit Stopped();
    }

    
    
    function skim() external {
        address penaltyCollector = rocketJoeFactory.penaltyCollector();

        uint256 excessToken = token.balanceOf(address(this)) -
            tokenReserve -
            tokenIncentivesBalance;
        if (excessToken > 0) {
            token.transfer(penaltyCollector, excessToken);
        }

        uint256 excessWavax = WAVAX.balanceOf(address(this)) - wavaxReserve;
        if (excessWavax > 0) {
            WAVAX.transfer(penaltyCollector, excessWavax);
        }

        uint256 excessAvax = address(this).balance;
        if (excessAvax > 0) _safeTransferAVAX(penaltyCollector, excessAvax);
    }

    
    
    function getPenalty() public view returns (uint256) {
        uint256 timeElapsed = block.timestamp - auctionStart;
        if (timeElapsed < PHASE_ONE_NO_FEE_DURATION) {
            return 0;
        } else if (timeElapsed < PHASE_ONE_DURATION) {
            return
                ((timeElapsed - PHASE_ONE_NO_FEE_DURATION) *
                    maxWithdrawPenalty) /
                uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION);
        }
        return fixedWithdrawPenalty;
    }

    
    
    function getReserves() external view returns (uint256, uint256) {
        return (wavaxReserve, tokenReserve + tokenIncentivesBalance);
    }

    
    
    
    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {
        return _avaxAmount * rJoePerAvax;
    }

    
    
    function pairBalance(address _user) public view returns (uint256) {
        UserInfo memory user = getUserInfo[_user];
        if (wavaxAllocated == 0 || user.hasWithdrawnPair) {
            return 0;
        }
        return (user.balance * lpSupply) / wavaxAllocated / 2;
    }

    
    
    function _atPhase(Phase _phase) internal view {
        if (_phase == Phase.NotStarted) {
            require(
                currentPhase() == Phase.NotStarted,
                ""LaunchEvent: not in not started""
            );
        } else if (_phase == Phase.PhaseOne) {
            require(
                currentPhase() == Phase.PhaseOne,
                ""LaunchEvent: not in phase one""
            );
        } else if (_phase == Phase.PhaseTwo) {
            require(
                currentPhase() == Phase.PhaseTwo,
                ""LaunchEvent: not in phase two""
            );
        } else if (_phase == Phase.PhaseThree) {
            require(
                currentPhase() == Phase.PhaseThree,
                ""LaunchEvent: not in phase three""
            );
        } else {
            revert(""LaunchEvent: unknown state"");
        }
    }

    
    
    
    
    function _safeTransferAVAX(address _to, uint256 _value) internal {
        (bool success, ) = _to.call{value: _value}(new bytes(0));
        require(success, ""LaunchEvent: avax transfer failed"");
    }
}",3591,2,7,"{
  ""task_list"": [
    {
      ""Area"": ""Initialization and Configuration"",
      ""Tasks"": [
        ""Verify that the `rocketJoeFactory` address is properly validated and secured to prevent malicious factory replacements."",
        ""Confirm that all parameters passed to the `initialize` function (issuer, auctionStart, token, etc.) are validated against reasonable bounds and potential exploits."",
        ""Check that the `_auctionStart` parameter is strictly greater than `block.timestamp` to prevent immediate exploitation."",
        ""Ensure that the `PHASE_ONE_DURATION`, `PHASE_ONE_NO_FEE_DURATION`, and `PHASE_TWO_DURATION` values are properly retrieved from the `rocketJoeFactory` and within expected ranges."",
        ""Analyze the logic within the `initialize` function that calculates `tokenReserve`, `tokenIncentivesForUsers`, and `tokenIncentivesBalance` to ensure accuracy and prevent unexpected token allocation."",
        ""Verify that the contract only accepts initialization once."",
        ""Confirm the owner of rocketJoeFactory cannot change critical parameters of LaunchEvent after initialization. Document which parameters, if any, can be changed and the implications of doing so.""
      ]
    },
    {
      ""Area"": ""Access Control and Authorization"",
      ""Tasks"": [
        ""Review the use of `Ownable` and its impact considering the dependency on `rocketJoeFactory` for crucial operations like emergency stop and initialization."",
        ""Analyze the `allowEmergencyWithdraw` function to ensure it can only be called by the intended authorized address (owner of `rocketJoeFactory`)."",
        ""Verify that the `issuer` cannot deposit AVAX via the `depositAVAX` function."",
        ""Confirm that the `skim` function can be called by anyone, and the consequences of this. Document the intended use and potential abuse scenarios.""
      ]
    },
    {
      ""Area"": ""Deposit and Withdrawal Mechanisms"",
      ""Tasks"": [
        ""Investigate potential reentrancy vulnerabilities in the `depositAVAX` function, considering the interaction with `rJoe.burnFrom` and `WAVAX.deposit`."",
        ""Analyze the `withdrawAVAX` function for potential vulnerabilities related to the penalty calculation and the safe transfer of AVAX."",
        ""Verify that the `getPenalty` function calculates penalties correctly across all time ranges."",
        ""Check for rounding errors in the calculation of `feeAmount` in the `withdrawAVAX` function and how they might affect the user or the penalty collector."",
        ""Assess the impact of front-running on the `depositAVAX` function, specifically how an attacker could manipulate the `rJoePerAvax` value."",
        ""Confirm that emergencyWithdraw correctly handles the balances and transfers to users and the issuer."",
        ""Review that user.balance is set to zero after an emergencyWithdraw to avoid multiple calls.""
      ]
    },
    {
      ""Area"": ""Liquidity Pool Creation and Management"",
      ""Tasks"": [
        ""Carefully examine the `createPair` function to ensure the floor price logic works as intended and protects against unfavorable LP creation."",
        ""Analyze the calculation of `tokenIncentivesForUsers` when the floor price condition is met to confirm accurate scaling of incentives."",
        ""Verify that the correct amount of tokens and WAVAX are allocated to the liquidity pool in the `createPair` function."",
        ""Check for potential issues with the `addLiquidity` function call on the `router`, including slippage concerns and deadline management."",
        ""Ensure that the `withdrawLiquidity` function correctly calculates and distributes LP tokens to users and the issuer."",
        ""Investigate potential vulnerabilities in the `withdrawLiquidity` function related to manipulating the `lpSupply` or `wavaxAllocated` values."",
        ""Verify that the `pairBalance` calculation is correct and prevents users from withdrawing more LP tokens than they are entitled to."",
        ""Address division by zero if wavaxAllocated is zero during pairBalance calculation.""
      ]
    },
    {
      ""Area"": ""Token and WAVAX Handling"",
      ""Tasks"": [
        ""Verify that the `token` and `WAVAX` contracts are properly validated and cannot be maliciously replaced."",
        ""Audit all `transfer` and `transferFrom` calls involving the `token` and `WAVAX` contracts for potential vulnerabilities."",
        ""Review the logic in the `skim` function to ensure it cannot be abused to drain funds from the contract."",
        ""Check for potential integer overflow or underflow issues in calculations involving token amounts, especially when considering different token decimal places."",
        ""Verify the contract can handle tokens with non-standard implementations (e.g. tokens that do not return a boolean on transfer).""
      ]
    },
    {
      ""Area"": ""Gas Optimization and Efficiency"",
      ""Tasks"": [
        ""Identify and address any gas inefficiencies in the contract, particularly in the `depositAVAX`, `withdrawAVAX`, and `createPair` functions."",
        ""Optimize storage variable usage to reduce gas costs."",
        ""Consider using more efficient data structures or algorithms to improve performance."",
        ""Evaluate the cost of `currentPhase` being called multiple times in the same transaction.""
      ]
    },
    {
      ""Area"": ""Denial of Service"",
      ""Tasks"": [
        ""Assess if there are any scenarios where a large number of users participating could cause a denial of service due to exceeding gas limits or other constraints."",
        ""Check if the `createPair` function could fail due to external factors, such as low liquidity or high slippage, and how the contract handles such failures."",
        ""Check that the skim function cannot be used to prevent legitimate withdrawals.""
      ]
    },
    {
      ""Area"": ""External Contract Interactions"",
      ""Tasks"": [
        ""Review all external contract interactions for potential vulnerabilities, including reentrancy, delegatecall attacks, and unexpected return values."",
        ""Specifically audit the interactions with the `IJoeRouter02`, `IJoeFactory`, `IRocketJoeToken`, and `IWAVAX` contracts."",
        ""Ensure that the contract handles potential errors or failures in external contract calls gracefully."",
        ""Assess risks related to the `penaltyCollector` address being set to a malicious or compromised address via `rocketJoeFactory`.""
      ]
    },
    {
      ""Area"": ""Event Emission and Logging"",
      ""Tasks"": [
        ""Verify that all relevant events are emitted correctly and contain the necessary information for off-chain monitoring and analysis."",
        ""Ensure that the events emitted are consistent with the state changes in the contract.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `LaunchEvent` manages a multi-phase token launch process, likely an Initial Liquidity Offering (ILO) or Initial DEX Offering (IDO), integrated with the Trader Joe ecosystem (using WAVAX, JoeRouter, JoeFactory, and rJoe). It handles AVAX deposits from users (requiring rJoe burning), creates a liquidity pool on Trader Joe, distributes LP tokens and incentive tokens to participants and the issuer after timelocks, and includes mechanisms for withdrawal penalties and emergency stops."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""LaunchEvent"",
    ""Purpose"": ""To facilitate a structured token launch event involving user participation via AVAX deposits, rJoe staking, automated liquidity pool creation on Trader Joe, and time-locked distribution of LP tokens and incentives."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""@openzeppelin/contracts/access/Ownable.sol""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts/access/Ownable.sol"",
        ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"",
        ""./interfaces/IJoeFactory.sol"",
        ""./interfaces/IJoePair.sol"",
        ""./interfaces/IJoeRouter02.sol"",
        ""./interfaces/IRocketJoeFactory.sol"",
        ""./interfaces/IRocketJoeToken.sol"",
        ""./interfaces/IWAVAX.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""Phase"",
        ""Type"": ""enum"",
        ""Purpose"": ""Defines the different stages of the launch event (NotStarted, PhaseOne, PhaseTwo, PhaseThree).""
      },
      {
        ""Name"": ""UserInfo"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores information about each participating user, including their max allocation (based on rJoe), current balance (deposited WAVAX), and withdrawal status flags.""
      },
      {
        ""Name"": ""issuer"",
        ""Type"": ""address"",
        ""Purpose"": ""The address of the entity issuing the token being launched.""
      },
      {
        ""Name"": ""auctionStart"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp marking the beginning of Phase One.""
      },
      {
        ""Name"": ""PHASE_ONE_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the first phase (deposit phase).""
      },
      {
        ""Name"": ""PHASE_ONE_NO_FEE_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Initial duration within Phase One where withdrawals incur no penalty.""
      },
      {
        ""Name"": ""PHASE_TWO_DURATION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration of the second phase (withdrawal-only phase).""
      },
      {
        ""Name"": ""tokenIncentivesPercent"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Percentage of the total deposited issuer tokens reserved for user incentives (scaled by 1e18).""
      },
      {
        ""Name"": ""floorPrice"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Minimum price (WAVAX per base unit of token) at which the LP pair will be created.""
      },
      {
        ""Name"": ""userTimelock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration (in seconds) after Phase Three starts before users can withdraw their LP tokens.""
      },
      {
        ""Name"": ""issuerTimelock"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Duration (in seconds) after Phase Three starts before the issuer can withdraw their LP tokens (must be > userTimelock).""
      },
      {
        ""Name"": ""maxWithdrawPenalty"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum penalty percentage (scaled by 1e18) for withdrawing during the fee period of Phase One.""
      },
      {
        ""Name"": ""fixedWithdrawPenalty"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Fixed penalty percentage (scaled by 1e18) for withdrawing during Phase Two.""
      },
      {
        ""Name"": ""rJoe"",
        ""Type"": ""IRocketJoeToken"",
        ""Purpose"": ""Interface for the rJoe token contract, used for staking requirement.""
      },
      {
        ""Name"": ""rJoePerAvax"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The amount of rJoe required per AVAX of allocation increase.""
      },
      {
        ""Name"": ""WAVAX"",
        ""Type"": ""IWAVAX"",
        ""Purpose"": ""Interface for the Wrapped AVAX contract.""
      },
      {
        ""Name"": ""token"",
        ""Type"": ""IERC20Metadata"",
        ""Purpose"": ""Interface for the ERC20 token being launched.""
      },
      {
        ""Name"": ""router"",
        ""Type"": ""IJoeRouter02"",
        ""Purpose"": ""Interface for the Trader Joe Router contract.""
      },
      {
        ""Name"": ""factory"",
        ""Type"": ""IJoeFactory"",
        ""Purpose"": ""Interface for the Trader Joe Factory contract.""
      },
      {
        ""Name"": ""rocketJoeFactory"",
        ""Type"": ""IRocketJoeFactory"",
        ""Purpose"": ""Interface for the factory contract that deploys and initializes this LaunchEvent.""
      },
      {
        ""Name"": ""initialized"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to ensure the initialize function is called only once.""
      },
      {
        ""Name"": ""stopped"",
        ""Type"": ""bool"",
        ""Purpose"": ""Flag to indicate if the contract has been stopped for emergency withdrawals.""
      },
      {
        ""Name"": ""maxAllocation"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Maximum amount of AVAX a single user can deposit.""
      },
      {
        ""Name"": ""getUserInfo"",
        ""Type"": ""mapping(address => UserInfo)"",
        ""Purpose"": ""Maps user addresses to their participation details.""
      },
      {
        ""Name"": ""pair"",
        ""Type"": ""IJoePair"",
        ""Purpose"": ""Interface for the Trader Joe LP pair created for the launched token and WAVAX.""
      },
      {
        ""Name"": ""wavaxAllocated"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total amount of WAVAX used to create the liquidity pool.""
      },
      {
        ""Name"": ""lpSupply"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total supply of LP tokens minted when the pair was created.""
      },
      {
        ""Name"": ""tokenReserve"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of the launched token held by the contract, initially intended for liquidity (minus incentives).""
      },
      {
        ""Name"": ""tokenIncentivesBalance"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of the launched token currently held by the contract allocated for incentives (decreases as claimed).""
      },
      {
        ""Name"": ""tokenIncentivesForUsers"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Total amount of incentive tokens allocated specifically for participating users.""
      },
      {
        ""Name"": ""tokenIncentiveIssuerRefund"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Amount of incentive tokens refundable to the issuer (e.g., due to floor price mechanism).""
      },
      {
        ""Name"": ""wavaxReserve"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Current balance of WAVAX deposited by users and held by the contract before LP creation.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""receive"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows receiving AVAX only when unwrapping WAVAX."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""atPhase"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution to a specific phase."",
        ""Parameters"": [""Phase _phase""],
        ""Returns"": []
      },
      {
        ""Name"": ""timelockElapsed"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Ensures the appropriate timelock (user or issuer) has passed before LP withdrawal."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""isStopped"",
        ""Visibility"": ""modifier"",
        ""Purpose"": ""Restricts function execution based on whether the contract is stopped or running."",
        ""Parameters"": [""bool _stopped""],
        ""Returns"": []
      },
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Sets up the contract parameters. Can only be called once by the rocketJoeFactory before the auction starts."",
        ""Parameters"": [
          ""address _issuer"",
          ""uint256 _auctionStart"",
          ""address _token"",
          ""uint256 _tokenIncentivesPercent"",
          ""uint256 _floorPrice"",
          ""uint256 _maxWithdrawPenalty"",
          ""uint256 _fixedWithdrawPenalty"",
          ""uint256 _maxAllocation"",
          ""uint256 _userTimelock"",
          ""uint256 _issuerTimelock""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""currentPhase"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Returns the current phase based on block timestamp."",
        ""Parameters"": [],
        ""Returns"": [""Phase""]
      },
      {
        ""Name"": ""depositAVAX"",
        ""Visibility"": ""external payable"",
        ""Purpose"": ""Allows users to deposit AVAX (converted to WAVAX) during Phase One, burning required rJoe."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawAVAX"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows users to withdraw deposited WAVAX (converted to AVAX) during Phase One or Two, subject to penalties."",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""createPair"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Creates the WAVAX/Token liquidity pool on Trader Joe during Phase Three using deposited funds."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawLiquidity"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users and the issuer to withdraw their share of LP tokens after their respective timelocks."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""withdrawIncentives"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users and the issuer to withdraw their share of the incentive tokens."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw AVAX and the issuer to withdraw remaining tokens if the contract is stopped."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""allowEmergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner of the rocketJoeFactory to stop the contract, enabling emergency withdrawals."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""skim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows anyone to transfer excess WAVAX, AVAX, or Tokens (beyond reserves) to the penalty collector."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""getPenalty"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the current withdrawal penalty percentage based on time elapsed."",
        ""Parameters"": [],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""getReserves"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Returns the current WAVAX and total Token reserves held by the contract."",
        ""Parameters"": [],
        ""Returns"": [""uint256"", ""uint256""]
      },
      {
        ""Name"": ""getRJoeAmount"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the amount of rJoe needed for a given AVAX deposit."",
        ""Parameters"": [""uint256 _avaxAmount""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""pairBalance"",
        ""Visibility"": ""public view"",
        ""Purpose"": ""Calculates the amount of LP tokens a user is entitled to (before withdrawal)."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""_atPhase"",
        ""Visibility"": ""internal view"",
        ""Purpose"": ""Internal helper function to check the current phase."",
        ""Parameters"": [""Phase _phase""],
        ""Returns"": []
      },
      {
        ""Name"": ""_safeTransferAVAX"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal helper function to safely transfer AVAX."",
        ""Parameters"": [""address _to"", ""uint256 _value""],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""IRocketJoeFactory: Reads configuration, gets dependent contract addresses, checks owner for emergency stop. Calls `initialize`."",
    ""IWAVAX: `deposit`, `withdraw`, `balanceOf`, `approve`, `transfer`."",
    ""IJoeRouter02: `addLiquidity`."",
    ""IJoeFactory: `getPair`."",
    ""IRocketJoeToken (rJoe): `burnFrom`."",
    ""IERC20Metadata (token): `balanceOf`, `approve`, `transfer`, `decimals`."",
    ""IJoePair (pair): `transfer`, `totalSupply`."",
    ""Penalty Collector Address (from factory): Receives withdrawal fees and skimmed funds."",
    ""User Addresses (`msg.sender`): Interact via deposit/withdraw functions."",
    ""Issuer Address: Receives LP tokens and incentives.""
  ],
  ""SpecialMechanisms"": [
    ""Phased Contract Lifecycle: Uses `enum Phase` and time checks to gate functionality."",
    ""Withdrawal Penalty System: Time-varying and fixed penalties for early withdrawal."",
    ""rJoe Staking Requirement: Users must burn rJoe to increase participation allocation."",
    ""Floor Price Enforcement: Adjusts token amount used for LP creation if calculated price is below the floor."",
    ""Time-locked LP Tokens: Separate timelocks for users and the issuer before LP withdrawal."",
    ""Factory-Controlled Initialization and Emergency Stop: Relies on `rocketJoeFactory` for setup and enabling emergency measures."",
    ""WAVAX Handling: Uses the Wrapped AVAX pattern for native currency interaction."",
    ""Incentive Distribution Mechanism: Allocates a portion of the launched token as rewards."",
    ""Skim Functionality: Recovers excess funds sent to the contract.""
  ],
  ""Questions"": [
    ""How is the `rocketJoeFactory` address secured? Is it immutable after deployment?"",
    ""Is the `Ownable` inheritance strictly necessary given the reliance on `rocketJoeFactory` owner for emergency stop and factory for initialization?"",
    ""In `createPair`, verify the calculation for `tokenIncentivesForUsers` when the floor price condition is met. Does it correctly scale incentives based on the *actually used* portion of the `tokenReserve`?"",
    ""Are there potential re-entrancy risks, especially considering interactions with `WAVAX` and the potentially arbitrary `token` contract during withdrawals or LP creation?"",
    ""What prevents the `issuer` from depositing AVAX if they are not supposed to participate?"",
    ""Are there protections against potential integer overflow/underflow in calculations (especially relevant for Solidity <0.8.0, but good practice to check)? (Solidity ^0.8.0 provides default checks)."",
    ""Gas limits: Could `depositAVAX` or `createPair` potentially exceed block gas limits under heavy load or with complex token interactions?"",
    ""How is the `penaltyCollector` address determined and can it be changed?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unprotected `allowEmergencyWithdraw` function"",
      ""Severity"": ""Critical"",
      ""Description"": ""The `allowEmergencyWithdraw` function lacks sufficient access control and relies solely on the `rocketJoeFactory` owner, without additional checks or delays. A compromised `rocketJoeFactory` owner could halt the LaunchEvent immediately, enabling the `emergencyWithdraw` function and potentially causing significant disruption and loss of funds for users."",
      ""Impact"": ""If the `rocketJoeFactory` owner is compromised, an attacker can immediately stop the launch event. Users would then be forced to use the emergency withdraw functionality, which might not be optimal."",
      ""Location"": ""Function `allowEmergencyWithdraw`""
    },
    {
      ""Issue"": ""Reentrancy Vulnerability in `withdrawAVAX` function"",
      ""Severity"": ""High"",
      ""Description"": ""The `withdrawAVAX` function transfers AVAX to the user before completing critical state updates (user balance, contract WAVAX reserve). This allows a malicious contract to re-enter `withdrawAVAX` via the transfer, potentially withdrawing more AVAX than entitled before state is fully updated. The fee payment to `rocketJoeFactory.penaltyCollector()` also happens after `WAVAX.withdraw(_amount)`, allowing reentrancy before fee payment."",
      ""Impact"": ""Loss of funds for the contract and its users. A malicious contract could repeatedly withdraw AVAX, exceeding its rightful allocation, effectively draining the contract."",
      ""Location"": ""Function `withdrawAVAX`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `createPair` function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createPair` function is susceptible to front-running due to its reliance on `block.timestamp` and the calculation of `tokenAllocated` based on `floorPrice`. A malicious actor could manipulate the block timestamp, create a pair with minimal liquidity, or manipulate the price of the token before the transaction is executed. This manipulation could lead to an unfair distribution of incentives or undesirable outcomes related to pool creation."",
      ""Impact"": ""Users might receive less liquidity tokens than expected or experience an unfair initial price and distribution of incentives. The front-runner might gain profit at the contract's expense."",
      ""Location"": ""Function `createPair`""
    },
    {
      ""Issue"": ""Centralization Risk: Reliance on RocketJoeFactory Owner"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `allowEmergencyWithdraw` function relies solely on the `rocketJoeFactory` owner, giving them significant control over the LaunchEvent contract. The initializer also controls key configuration parameters. The RocketJoeFactory owner's compromise or malicious actions could prematurely halt the event and potentially harm participants. There is a lack of community governance or parameter adjustment mechanisms after initialization."",
      ""Impact"": ""Centralized control creates a potential risk for users if the RocketJoeFactory owner acts maliciously or is compromised. This could lead to premature halting of the event and manipulation of critical parameters."",
      ""Location"": ""Function `allowEmergencyWithdraw`, `initialize`""
    },
    {
      ""Issue"": ""Lack of Slippage Control in `createPair` Function"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `createPair` function lacks slippage protection in the `addLiquidity` call. It uses the same values for desired and minimum amounts of tokens, causing transactions to revert if the price changes significantly between submission and execution. This could prevent the liquidity pool from being created or result in receiving fewer LP tokens than expected."",
      ""Impact"": ""Transactions may fail, hindering the successful creation of the liquidity pool, or the contract may lose value due to slippage."",
      ""Location"": ""Function `createPair`, call to `router.addLiquidity`""
    },
    {
      ""Issue"": ""Improper Calculation of `tokenAllocated` in `createPair` can lead to incorrect incentives distribution and griefing."",
      ""Severity"": ""Medium"",
      ""Description"": ""In the `createPair` function, the logic to calculate `tokenAllocated` based on `floorPrice` might lead to inconsistencies if `floorPrice` is significantly higher than the actual market value. This can affect the amount of `tokenIncentivesForUsers` and `tokenIncentiveIssuerRefund`, potentially leading to unfair distribution of incentives and potentially opening up griefing opportunities."",
      ""Impact"": ""Incorrect distribution of incentives to users and the issuer, and a potential for denial of service due to imbalanced LP creation."",
      ""Location"": ""Function `createPair`""
    },
    {
      ""Issue"": ""Lack of Checks-Effects-Interactions Pattern in `withdrawIncentives`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `withdrawIncentives` function updates the contract's state after transferring tokens to the user, deviating from the Checks-Effects-Interactions pattern. This can cause state inconsistency if the transfer fails. Also, the transferred tokens could be tokens that invoke a malicious contract."",
      ""Impact"": ""State inconsistency, potential loss of funds, and unexpected behavior within the contract. A failed token transfer could leave the contract in a state where it believes incentives have been withdrawn when they haven't."",
      ""Location"": ""LaunchEvent.sol: Lines 348-350""
    },
    {
      ""Issue"": ""Improper Restriction of Direct AVAX Transfer"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `receive()` function intends to prevent direct transfers of AVAX to the contract, but only checks if the sender is the WAVAX contract without depositing the AVAX as WAVAX. This means the contract can receive untracked AVAX, potentially locking it in the contract."",
      ""Impact"": ""Unexpected direct transfers of AVAX could occur, which are not tracked or managed within the LaunchEvent’s logic, potentially locking the AVAX in the contract forever. This can cause accounting discrepancies and potential fund losses."",
      ""Location"": ""LaunchEvent.sol: Lines 173-179""
    },
    {
      ""Issue"": ""Potential Division by Zero in `withdrawIncentives` function"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `withdrawIncentives` function, the amount is calculated as `(user.balance * tokenIncentivesForUsers) / wavaxAllocated`. If `wavaxAllocated` is zero, this will result in a division by zero error, causing the transaction to revert."",
      ""Impact"": ""Users may be unable to withdraw incentives if `wavaxAllocated` is zero, which will halt the withdrawal process."",
      ""Location"": ""Function `withdrawIncentives`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow Vulnerabilities"",
      ""Severity"": ""Low"",
      ""Description"": ""While Solidity 0.8.0 and later include automatic overflow/underflow checks, potential risks exist when dealing with arithmetic operations. The calculation `uint256 amountMinusFee = _amount - feeAmount` in `withdrawAVAX` *could* revert due to underflow if `feeAmount` is greater than `_amount`."",
      ""Impact"": ""Unexpected behavior, potential denial-of-service if operations revert unexpectedly."",
      ""Location"": ""LaunchEvent.sol: Line 303""
    },
    {
      ""Issue"": ""Inconsistent use of msg.value vs. WAVAX balances"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract interacts with AVAX via the WAVAX token. `depositAVAX` function wraps the `msg.value` amount into WAVAX tokens, but the contract also holds native AVAX, which is only used in edge-case scenarios, like the skim function. This may cause confusion and introduce potential edge case errors if the contract's native AVAX balance is not properly accounted for."",
      ""Impact"": ""Edge cases might lead to unexpected behavior due to the mix of native AVAX and WAVAX tokens."",
      ""Location"": ""Throughout the contract, especially in `depositAVAX` and `skim`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Penalty Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In `getPenalty`, `PHASE_ONE_DURATION` may be equal to `PHASE_ONE_NO_FEE_DURATION`, causing `uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION)` to be zero and causing division by zero and revert. In general, using safeMath or solidity version >0.8.0 prevents such issues."",
      ""Impact"": ""The penalty mechanism may become unavailable, potentially leading to fairness issues among users who withdraw at different times."",
      ""Location"": ""LaunchEvent.sol:474""
    },
    {
      ""Issue"": ""Missing Input Validation in `initialize` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `initialize` function checks `_userTimelock <= 7 days` and `_issuerTimelock > _userTimelock`, but it doesn't validate `_issuerTimelock`. If _issuerTimelock is too large, it might cause issues with contract usability or unexpected behavior. A reasonable maximum value for `_issuerTimelock` should be considered."",
      ""Impact"": ""An excessively large `_issuerTimelock` value could lock funds for an unacceptably long duration, reducing the attractiveness of the launch event."",
      ""Location"": ""LaunchEvent.sol:137-140""
    },
    {
      ""Issue"": ""Potential DoS in `skim` Function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `skim` function transfers excess tokens and AVAX to the `penaltyCollector` address. If the `penaltyCollector` address is set to a contract that reverts on receiving tokens or AVAX, the `skim` function will fail."",
      ""Impact"": ""The owner might be unable to recover excess tokens or AVAX from the contract if the `penaltyCollector` address reverts on receiving them or due to high gas usage."",
      ""Location"": ""Function `skim`""
    },
    {
      ""Issue"": ""Lack of access control on `skim` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `skim` function, which transfers excess tokens and AVAX to the `penaltyCollector`, has no access control.  While the RocketJoeFactory owner might be the intended caller, anyone could call this function, potentially causing unexpected behavior."",
      ""Impact"": ""Potentially unintended transfer of tokens and AVAX to an unauthorized address."",
      ""Location"": ""`skim` function, lines 390-405""
    },
    {
      ""Issue"": ""Potential division by zero in `pairBalance` function"",
      ""Severity"": ""Low"",
      ""Description"": ""If `wavaxAllocated` is zero, the calculation `(user.balance * lpSupply) / wavaxAllocated / 2` in the `pairBalance` function will result in a division by zero error, causing the transaction to revert. This can occur before liquidity is added or after an emergency withdraw."",
      ""Impact"": ""Users may be unable to determine their LP token balance if `wavaxAllocated` is zero."",
      ""Location"": ""`pairBalance` function, line 445""
    },
    {
      ""Issue"": ""Inconsistent Use of `isStopped` Modifier"",
      ""Severity"": ""Low"",
      ""Description"": ""The `isStopped` modifier is used with a boolean parameter. The function `allowEmergencyWithdraw` sets `stopped = true;` and emits `Stopped()`. The functions using the modifier check whether the contract is indeed stopped or not stopped, based on the parameter passed. This design, while functional, is less readable and potentially error-prone compared to directly using `require(!stopped, \""LaunchEvent: stopped\"")` or `require(stopped, \""LaunchEvent: running\"")` directly within the function."",
      ""Impact"": ""Reduced code readability and maintainability.  Increased risk of errors due to the unusual modifier usage."",
      ""Location"": ""LaunchEvent.sol: Lines 142-148, 273-277, 321-326""
    },
    {
      ""Issue"": ""Potential for Griefing due to `tokenIncentiveIssuerRefund` Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The amount of `tokenIncentiveIssuerRefund` is calculated based on the `floorPrice` in the `createPair` function. If the floor price is significantly lower than what the actual initial market price is, then a lot of the tokenIncentives can be allocated to the issuer."",
      ""Impact"": ""The issuer might be able to claim a larger amount of tokens than initially intended, at the expense of the users who participated in the launch event."",
      ""Location"": ""Function `createPair`""
    },
    {
      ""Issue"": ""Division Before Multiplication in `tokenReserve` Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `initialize` function, the `tokenReserve` is calculated as `(balance * 1e18) / (1e18 + _tokenIncentivesPercent)`. If `balance` is small compared to `(1e18 + _tokenIncentivesPercent)`, the integer division might result in a `tokenReserve` of 0, even if the balance is non-zero."",
      ""Impact"": ""The `tokenReserve` could be incorrectly calculated as 0 if the `token` balance is small, leading to incorrect calculations during the liquidity pool creation and incentive distribution."",
      ""Location"": ""LaunchEvent.sol: Line 137""
    },
    {
      ""Issue"": ""Potential Integer Overflow in `getPenalty` function"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `getPenalty` function, the calculation `uint256(PHASE_ONE_DURATION - PHASE_ONE_NO_FEE_DURATION)` could underflow if `PHASE_ONE_NO_FEE_DURATION` is greater than `PHASE_ONE_DURATION`. This could lead to unexpected penalty values."",
      ""Impact"": ""Unexpected penalty values may be applied to users withdrawing AVAX."",
      ""Location"": ""Function `getPenalty`""
    },
     {
      ""Issue"": ""Hardcoded Timelock Value"",
      ""Severity"": ""Low"",
      ""Description"": ""The initialize function sets a maximum user timelock value of 7 days, which is hardcoded in the contract. This limits the flexibility of the launch event configuration and could be problematic if a longer timelock is desired in the future."",
      ""Impact"": ""Reduced flexibility in configuring the launch event."",
      ""Location"": ""Function `initialize`""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Fee Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `withdrawAVAX` function, the fee calculation `uint256 feeAmount = (_amount * getPenalty()) / 1e18;` could potentially lead to integer overflow if `_amount * getPenalty()` is greater than the maximum value for a `uint256`."",
      ""Impact"": ""Incorrect fee calculation, leading to either less or more AVAX being transferred to the user or penalty collector than intended."",
      ""Location"": ""Function `withdrawAVAX`""
    },
     {
      ""Issue"": ""Unnecessary state variable `lpSupply`"",
      ""Severity"": ""Low"",
      ""Description"": ""The state variable `lpSupply` is assigned a value during the `createPair` function. This value is the returned third value in the return of `router.addLiquidity(...)`. The state variable is only ever read in the `pairBalance()` function. Since the `pair` is an instance of `IJoePair`, the `totalSupply()` can be called instead which would remove the need for the state variable"",
      ""Impact"": ""State variable not being used properly when the same result can be achieved by calling the `totalSupply` function on the `pair`."",
      ""Location"": ""LaunchEvent.sol: `createPair` and `pairBalance` function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `createPair` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `createPair` function is executed in Phase.PhaseThree. Before creating a pair it checks if `factory.getPair(wavaxAddress, tokenAddress) == address(0) || IJoePair(IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)).totalSupply() == 0`. However, there is a window of opportunity for a malicious actor to front-run this transaction. They can observe the transaction being submitted and create a pair with very little liquidity before the `createPair` function is executed."",
      ""Impact"": ""The user might not get a fair initial price and most of the tokens might go to the front-runner."",
      ""Location"": ""LaunchEvent.sol: `createPair` function""
    }
  ],
  ""IssueNumber"": 49,
  ""OutputList"": 24
}",292.0405852794647,4074.0,33.0,"### **[H-01] Users can lose value in emergency state**

**Report Description**:  
In the `LaunchEvent` contract, the sequence of events involving `createPair()`, `allowEmergencyWithdraw()`, and `emergencyWithdraw()` can lead to users losing their entire deposit. Specifically, `createPair()` sets `wavaxReserve = 0` and provides liquidity, receiving LP tokens. When `allowEmergencyWithdraw()` is called, it enters emergency mode, disabling normal withdrawals. However, `emergencyWithdraw()` reverts because the WAVAX reserve has already been used for liquidity, leaving users unable to recover their LP tokens or WAVAX. This results in a total loss of user funds.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While there are responses related to `allowEmergencyWithdraw()` and `emergencyWithdraw()`, none of them cover the scenario where users lose their entire deposit due to the WAVAX reserve being depleted and LP tokens being unrecoverable.

---

### **[H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached**

**Report Description**:  
In `LaunchEvent.createPair()`, the computation of `tokenAllocated` is incorrect for tokens with decimals other than 18. The formula `tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice` does not account for the precision of `floorPrice`, which is scaled to 1e18. This leads to incorrect token allocation when the floor price is not reached, especially for tokens with decimals other than 18.

**Match in Response List**:  
Matches with the issue titled **""Improper Calculation of `tokenAllocated` in `createPair` can lead to incorrect incentives distribution and griefing.""**

**Validation**:  
**Partially Correct**. The response identifies the issue with `tokenAllocated` calculation but focuses on incentives distribution and griefing rather than the specific problem of incorrect computation for tokens with decimals != 18. The core issue of precision mismatch is not fully addressed.

---

### **[M-02] Owner of LaunchEvent token has the ability to DOS attack the event**

**Report Description**:  
The owner of the token for which the `LaunchEvent` was created can prevent the creation of a `JoePair`, effectively denying access to `withdrawLiquidity()` and `withdrawIncentives()`. This can be used as a DOS attack, forcing users to rely on emergency withdrawals, which may result in the loss of burned rJOE tokens and gas fees. The RocketJoe owner can enable emergency withdrawals, but this does not fully mitigate the issue.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While there are responses related to `allowEmergencyWithdraw()` and centralization risks, none of them cover the scenario where the token owner can DOS the event by preventing pair creation.

---

### **[M-05] Failed transfer with low level call could be overlooked**

**Report Description**:  
In `LaunchEvent.sol`, the function `_safeTransferAVAX` uses a low-level call to transfer AVAX but does not check if the target address is a contract or exists. According to the Solidity docs, `call` returns `true` for non-existent accounts, which could lead to silent failures if the `penaltyCollector` address is a deleted contract.

**Match in Response List**:  
Matches with the issue titled **""Improper Restriction of Direct AVAX Transfer.""**

**Validation**:  
**Partially Correct**. The response identifies the issue with direct AVAX transfers but does not fully address the specific problem of silent failures in `_safeTransferAVAX` due to non-existent contracts. The core issue of unchecked low-level calls is not fully covered.

---

### **[M-07] withdrawAVAX() function has call to sender without reentrancy protection**

**Report Description**:  
The `withdrawAVAX()` function in `LaunchEvent.sol` makes an external call to the sender via `_safeTransferAVAX` without reentrancy protection. This allows the caller to reenter the function or other functions in the protocol, potentially leading to reentrancy attacks.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Vulnerability in `withdrawAVAX` function.""**

**Validation**:  
**Correct**. The response accurately identifies the reentrancy vulnerability in `withdrawAVAX()` and explains the risks associated with unprotected external calls. This aligns with the issue description and Solidity best practices.

---

### **[M-08] LP Tokens May Be Locked in Contract Due to `allowEmergencyWithdraw()` in Stage 3**

**Report Description**:  
If `allowEmergencyWithdraw()` is called during Stage 3 after a pair has been created, LP tokens may be locked in the contract. This is because `withdrawIncentives()` and `withdrawLiquidity()` will revert due to the `isStopped(false)` modifier, and `emergencyWithdraw()` will revert because the WAVAX and token balances have already been transferred to the liquidity pool.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While there are responses related to `allowEmergencyWithdraw()` and LP tokens, none of them cover the scenario where LP tokens are locked due to the contract being in Stage 3.

---

### **[M-09] `createPair()` expects zero slippage**

**Report Description**:  
The `createPair()` function in `LaunchEvent.sol` calls `router.addLiquidity()` with `amountADesired == amountAMin` and `amountBDesired == amountBMin`, effectively requiring zero slippage. If the zero slippage requirement is not met, the transaction will revert, potentially preventing the creation of the liquidity pool.

**Match in Response List**:  
Matches with the issue titled **""Lack of Slippage Control in `createPair` Function.""**

**Validation**:  
**Correct**. The response accurately identifies the lack of slippage control in `createPair()` and explains the risks associated with requiring zero slippage. This aligns with the issue description and Solidity best practices.

---

### **[M-10] Use safeTransfer/safeTransferFrom consistently instead of `transfer/transferFrom`**

**Report Description**:  
The contract should use `safeTransfer` or `safeTransferFrom` consistently instead of `transfer` or `transferFrom` to handle token transfers. This ensures that token transfer failures are properly checked, preventing silent failures that could affect token accounting.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While there are responses related to token transfers, none of them explicitly recommend using `safeTransfer` or `safeTransferFrom` consistently.

---

### **[M-12] Pair creation can be denied**

**Report Description**:  
The `createPair()` function in `LaunchEvent.sol` requires that no previous pool exists for the `WAVAX <> _token` pair. A griefer can create a pool for this pair during Phase 1 or 2, preventing the `LaunchEvent` from creating the pair and forcing an emergency state for users and the issuer to withdraw.

**Match in Response List**:  
Matches with the issue titled **""Potential Front-Running Vulnerability in `createPair` function.""**

**Validation**:  
**Partially Correct**. The response identifies the front-running vulnerability in `createPair()` but focuses on price manipulation rather than the specific issue of a griefer creating a pool to deny pair creation. The core issue of griefing is not fully addressed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-07] withdrawAVAX() function has call to sender without reentrancy protection**
- **[M-09] `createPair()` expects zero slippage**

**Partially Correct Matches**:

- **[H-02] Wrong token allocation computation for token decimals != 18 if floor price not reached**
- **[M-05] Failed transfer with low level call could be overlooked**
- **[M-12] Pair creation can be denied**

**Missed Issues from Issue Report**:

- **[H-01] Users can lose value in emergency state**
- **[M-02] Owner of LaunchEvent token has the ability to DOS attack the event**
- **[M-08] LP Tokens May Be Locked in Contract Due to `allowEmergencyWithdraw()` in Stage 3**
- **[M-10] Use safeTransfer/safeTransferFrom consistently instead of `transfer/transferFrom`**

---","```
1. Reentrancy Vulnerability in `withdrawAVAX` function.
2. Lack of Slippage Control in `createPair` Function.
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Reentrancy Vulnerability in `withdrawAVAX` function"" appears at rank 2.
   - ""Lack of Slippage Control in `createPair` Function"" appears at rank 5.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 5: \( P@5 = \frac{2}{5} = 0.4 \)

3. **Average the precision values to compute the Average Precision (AP)**:
   \[
   AP = \frac{0.5 + 0.4}{2} = 0.45
   \]

**Output**:
```
0.45
```"
RocketJoeStaking.sol,"// SPDX-License-Identifier: None

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./RocketJoeToken.sol"";

/// @title Rocket Joe Staking
/// @author Trader Joe
/// @notice Stake JOE to earn rJOE
contract RocketJoeStaking is Initializable, OwnableUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct UserInfo {
        uint256 amount; // How many JOE tokens the user has provided
        uint256 rewardDebt; // Reward debt. See explanation below
        //
        // We do some fancy math here. Basically, any point in time, the amount of JOEs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * accRJoePerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. `accRJoePerShare` (and `lastRewardTimestamp`) gets updated
        //   2. User receives the pending reward sent to his/her address
        //   3. User's `amount` gets updated
        //   4. User's `rewardDebt` gets updated
    }

    IERC20Upgradeable public joe;
    uint256 public lastRewardTimestamp;

    /// @dev Accumulated rJOE per share, times PRECISION. See above
    uint256 public accRJoePerShare;
    /// @notice Precision of accRJoePerShare
    uint256 private PRECISION;

    RocketJoeToken public rJoe;
    uint256 public rJoePerSec;

    /// @dev Info of each user that stakes LP tokens
    mapping(address => UserInfo) public userInfo;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);

    /// @notice Initialize with needed parameters
    /// @param _joe Address of the JOE token contract
    /// @param _rJoe Address of the rJOE token contract
    /// @param _rJoePerSec Number of rJOE tokens created per second
    /// @param _startTime Timestamp at which rJOE rewards starts
    function initialize(
        IERC20Upgradeable _joe,
        RocketJoeToken _rJoe,
        uint256 _rJoePerSec,
        uint256 _startTime
    ) public initializer {
        __Ownable_init();

        require(
            _startTime > block.timestamp,
            ""RocketJoeStaking: rJOE minting needs to start after the current timestamp""
        );

        PRECISION = 1e18;

        joe = _joe;
        rJoe = _rJoe;
        rJoePerSec = _rJoePerSec;
        lastRewardTimestamp = _startTime;
    }

    /// @notice Get pending rJoe for a given `_user`
    /// @param _user The user to lookup
    /// @return The number of pending rJOE tokens for `_user`
    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo storage user = userInfo[_user];
        uint256 joeSupply = joe.balanceOf(address(this));
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }

    /// @notice Deposit joe to RocketJoeStaking for rJoe allocation
    /// @param _amount Amount of JOE to deposit
    function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        if (user.amount > 0) {
            uint256 pending = (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
            _safeRJoeTransfer(msg.sender, pending);
        }
        user.amount = user.amount + _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        joe.safeTransferFrom(address(msg.sender), address(this), _amount);
        emit Deposit(msg.sender, _amount);
    }

    /// @notice Withdraw JOE and accumulated rJOE from RocketJoeStaking
    /// @param _amount Amount of JOE to withdraw
    function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount = user.amount - _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(address(msg.sender), _amount);
        emit Withdraw(msg.sender, _amount);
    }

    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY
    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        joe.safeTransfer(address(msg.sender), _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }

    /// @notice Update emission rate
    /// @param _rJoePerSec The new value for rJoePerSec
    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
        updatePool();
        rJoePerSec = _rJoePerSec;
        emit UpdateEmissionRate(msg.sender, _rJoePerSec);
    }

    /// @notice Update reward variables of the given pool with latest data
    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = joe.balanceOf(address(this));
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare =
            accRJoePerShare +
            (rJoeReward * PRECISION) /
            joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }

    /// @notice Safe rJoe transfer function, just in case if rounding error causes pool to not have enough JOEs
    /// @param _to Address that wil receive rJoe
    /// @param _amount The amount to send
    function _safeRJoeTransfer(address _to, uint256 _amount) internal {
        uint256 rJoeBal = rJoe.balanceOf(address(this));
        if (_amount > rJoeBal) {
            rJoe.transfer(_to, rJoeBal);
        } else {
            rJoe.transfer(_to, _amount);
        }
    }
}

",1640,191,"[M-01] Improper Upper Bound Definition on the Fee

Submitted by Jujic
The `rJoePerSec` does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions.
Proof of Concept

https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L151
``` function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
    updatePool();
    rJoePerSec = _rJoePerSec;
    emit UpdateEmissionRate(msg.sender, _rJoePerSec);
}
```  [M-03] createRJLaunchEvent() can be called by anyone with 1 Wei of _token and stop others from creating RJLaunchEvent with the same token anymore

Submitted by WatchPug, also found by p4st13r4
https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L132
 In the current implementation, RocketJoeFactory.sol#createRJLaunchEvent() can be called by anyone with at least 1 Wei of _token.
This allows a malicious user or attacker to call createRJLaunchEvent() with minimal cost and stop others, especially the platform itself or the rightful issuer of the token from creating the RJLaunchEvent.
  [M-04] Uninitialized RocketJoeStaking.lastRewardTimestamp can inflate rJoe supply

Submitted by cmichel
The `RocketJoeStaking.lastRewardTimestamp` is initialized to zero. Usually, this does not matter as updatePool is called before the first deposit and when joeSupply = joe.balanceOf(address(this)) == 0, it is set to the current time.
 However, if a user first directly transfers Joe tokens to the contract before the first updatePool call, the block.timestamp - lastRewardTimestamp = block.timestamp will be a large timestamp value and lots of rJoe will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the rJoe total supply might not be desired.   [M-06] possibility of minting rJOE tokens before ownership is changed to RocketJoeStaking

Submitted by hubble
There is a possibility of the `rJOE` tokens in RocketJoeToken.sol to be minted by original owner without staking any JOE, before the ownership is transferred to RocketJoeStaking
Proof of Concept

Contract : RocketJoeToken.sol Line : 37  ``` function mint(address _to, uint256 _amount) external onlyOwner { _mint(_to, _amount); } ```
  [M-11] Re-enterable Code When Making a Deposit to Stake

Note: this attack requires rJoe to relinquish control during tranfer() which under the current RocketJoeToken it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.
This vulnerability would allow the entire rJoe balance to be drained from the contract.
",5,,"pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./RocketJoeToken.sol"";




contract RocketJoeStaking is Initializable, OwnableUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    struct UserInfo {
        uint256 amount; 
        uint256 rewardDebt; 
        
        
        
        
        
        
        
        
        
        
        
    }

    IERC20Upgradeable public joe;
    uint256 public lastRewardTimestamp;

    
    uint256 public accRJoePerShare;
    
    uint256 private PRECISION;

    RocketJoeToken public rJoe;
    uint256 public rJoePerSec;

    
    mapping(address => UserInfo) public userInfo;

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 amount);
    event UpdateEmissionRate(address indexed user, uint256 _rJoePerSec);

    
    
    
    
    
    function initialize(
        IERC20Upgradeable _joe,
        RocketJoeToken _rJoe,
        uint256 _rJoePerSec,
        uint256 _startTime
    ) public initializer {
        __Ownable_init();

        require(
            _startTime > block.timestamp,
            ""RocketJoeStaking: rJOE minting needs to start after the current timestamp""
        );

        PRECISION = 1e18;

        joe = _joe;
        rJoe = _rJoe;
        rJoePerSec = _rJoePerSec;
        lastRewardTimestamp = _startTime;
    }

    
    
    
    function pendingRJoe(address _user) external view returns (uint256) {
        UserInfo storage user = userInfo[_user];
        uint256 joeSupply = joe.balanceOf(address(this));
        uint256 _accRJoePerShare = accRJoePerShare;

        if (block.timestamp > lastRewardTimestamp && joeSupply != 0) {
            uint256 multiplier = block.timestamp - lastRewardTimestamp;
            uint256 rJoeReward = multiplier * rJoePerSec;
            _accRJoePerShare += (rJoeReward * PRECISION) / joeSupply;
        }
        return (user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt;
    }

    
    
    function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        if (user.amount > 0) {
            uint256 pending = (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
            _safeRJoeTransfer(msg.sender, pending);
        }
        user.amount = user.amount + _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        joe.safeTransferFrom(address(msg.sender), address(this), _amount);
        emit Deposit(msg.sender, _amount);
    }

    
    
    function withdraw(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];
        require(
            user.amount >= _amount,
            ""RocketJoeStaking: withdraw amount exceeds balance""
        );

        updatePool();

        uint256 pending = (user.amount * accRJoePerShare) /
            PRECISION -
            user.rewardDebt;

        user.amount = user.amount - _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        _safeRJoeTransfer(msg.sender, pending);
        joe.safeTransfer(address(msg.sender), _amount);
        emit Withdraw(msg.sender, _amount);
    }

    
    function emergencyWithdraw() external {
        UserInfo storage user = userInfo[msg.sender];

        uint256 _amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;

        joe.safeTransfer(address(msg.sender), _amount);
        emit EmergencyWithdraw(msg.sender, _amount);
    }

    
    
    function updateEmissionRate(uint256 _rJoePerSec) external onlyOwner {
        updatePool();
        rJoePerSec = _rJoePerSec;
        emit UpdateEmissionRate(msg.sender, _rJoePerSec);
    }

    
    function updatePool() public {
        if (block.timestamp <= lastRewardTimestamp) {
            return;
        }
        uint256 joeSupply = joe.balanceOf(address(this));
        if (joeSupply == 0) {
            lastRewardTimestamp = block.timestamp;
            return;
        }
        uint256 multiplier = block.timestamp - lastRewardTimestamp;
        uint256 rJoeReward = multiplier * rJoePerSec;
        accRJoePerShare =
            accRJoePerShare +
            (rJoeReward * PRECISION) /
            joeSupply;
        lastRewardTimestamp = block.timestamp;

        rJoe.mint(address(this), rJoeReward);
    }

    
    
    
    function _safeRJoeTransfer(address _to, uint256 _amount) internal {
        uint256 rJoeBal = rJoe.balanceOf(address(this));
        if (_amount > rJoeBal) {
            rJoe.transfer(_to, rJoeBal);
        } else {
            rJoe.transfer(_to, _amount);
        }
    }
}",1130,0,5,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities - Reentrancy"",
      ""Tasks"": [
        ""Analyze the `deposit`, `withdraw`, `emergencyWithdraw` and `_safeRJoeTransfer` functions for potential reentrancy vulnerabilities, especially considering external calls to the JOE and rJOE token contracts.  Pay close attention to state updates occurring before and after external calls."",
        ""Simulate potential reentrancy attacks by crafting malicious ERC20 tokens for both `joe` and `rJoe` that execute code upon transfer to attempt re-entry into the staking contract during deposit, withdraw, or reward distribution.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities - Integer Overflow/Underflow"",
      ""Tasks"": [
        ""Examine the reward calculation in `updatePool` (`rJoeReward = multiplier * rJoePerSec`) and `pendingRJoe` (`_accRJoePerShare += (rJoeReward * PRECISION) / joeSupply`) for potential overflow issues, even with `uint256`. Specifically, evaluate the maximum possible values and if exceeding these may cause unexpected behavior."",
        ""Assess the user's rJoe reward calculation: `(user.amount * _accRJoePerShare) / PRECISION - user.rewardDebt` to ensure the calculation does not underflow in any case. If the rewardDebt is greater than the calculated reward, an underflow will occur."",
        ""Check for underflow issues in the `withdraw` function, specifically in the `user.amount = user.amount - _amount;` calculation.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities - Front Running"",
      ""Tasks"": [
        ""Analyze the potential for front-running the `updateEmissionRate` function.  An attacker could observe a transaction to reduce `rJoePerSec` and execute a transaction immediately prior to claim a larger share of rewards based on the higher rate.""
      ]
    },
    {
      ""Area"": ""Access Control"",
      ""Tasks"": [
        ""Verify that only the owner can call the `updateEmissionRate` function using the `onlyOwner` modifier."",
        ""Confirm the `OwnableUpgradeable` contract is initialized correctly and the intended owner is set during deployment.""
      ]
    },
    {
      ""Area"": ""Reward Calculation Logic"",
      ""Tasks"": [
        ""Thoroughly review the reward calculation logic in `updatePool` and `pendingRJoe` to ensure accuracy and fairness. Create unit tests with various staking scenarios to validate the correct distribution of rJOE rewards."",
        ""Investigate the scenario where `joeSupply` is very low or fluctuates significantly, and how this impacts reward distribution. Consider potential manipulation of `joeSupply` by external actors."",
        ""Analyze how the `lastRewardTimestamp` is updated and its potential impact on reward calculations, especially edge cases involving contract pauses or significant delays.""
      ]
    },
    {
      ""Area"": ""Tokenomics and Minting"",
      ""Tasks"": [
        ""Verify that the `RocketJoeStaking` contract has the necessary permissions (e.g., the `MINTER_ROLE`) on the `RocketJoeToken` contract to mint rJOE tokens. If not, minting in the `updatePool` function will fail."",
        ""Assess the potential impact of large increases in `rJoePerSec` on the overall rJOE token supply and its economic implications."",
        ""Evaluate the `rJoePerSec` update mechanism to ensure the owner cannot arbitrarily inflate the rJOE supply beyond reasonable limits.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Analyze gas costs associated with the `deposit`, `withdraw`, and `updatePool` functions. Look for opportunities to reduce gas consumption through code optimization, such as caching frequently accessed state variables or using more efficient data structures."",
        ""Consider using unchecked arithmetic where overflows are impossible or acceptable to save gas."",
        ""Evaluate the cost of emitting events and consider if certain events can be omitted or made less verbose to reduce gas costs.""
      ]
    },
    {
      ""Area"": ""SafeERC20 Usage"",
      ""Tasks"": [
        ""Verify that `SafeERC20Upgradeable` is used correctly for all ERC20 token transfers, including `joe.safeTransferFrom`, `joe.safeTransfer`, and `rJoe.transfer`. Confirm the contract handles potential errors from these transfers."",
        ""Examine how the contract handles ERC20 tokens that do not conform to the standard, such as tokens with no return values on `transfer` or `transferFrom`. Although SafeERC20 is used, a transfer to an address that is not a contract could lead to unexpected behavior or revert.""
      ]
    },
    {
      ""Area"": ""External Interactions and Dependencies"",
      ""Tasks"": [
        ""Review the documentation and code for the `RocketJoeToken` contract to understand its minting and transfer mechanisms and identify any potential vulnerabilities or unexpected behavior."",
        ""Consider the potential impact of changes to the `RocketJoeToken` or `joe` token contracts on the functionality and security of the `RocketJoeStaking` contract.""
      ]
    },
    {
      ""Area"": ""Upgradeability"",
      ""Tasks"": [
        ""Review the contract's structure to ensure it adheres to best practices for upgradeable contracts, minimizing the risk of storage collisions or other issues during upgrades."",
        ""Verify that the initializer function (`initialize`) can only be called once and cannot be re-initialized by malicious actors.""
      ]
    },
    {
      ""Area"": ""Data Validation"",
      ""Tasks"": [
        ""In the `initialize` function, add a check to ensure that `_rJoePerSec` is a reasonable value, preventing potential abuse through an excessively high reward rate."",
        ""In the `deposit` and `withdraw` functions, add checks to prevent depositing or withdrawing zero amounts. Although `safeTransferFrom` will revert when transfering 0, explicitly checking prevents unnecessary state changes.""
      ]
    },
     {
      ""Area"": ""Clarity and Code Quality"",
      ""Tasks"": [
        ""Remove the commented-out lines in the `UserInfo` struct to improve code readability and maintainability."",
        ""Consider changing the visibility of `updatePool` to `internal` if there's no explicit reason for it to be `public`. Preventing external calls to `updatePool` would prevent abuse."",
        ""Add NatSpec documentation to all public and external functions to clarify their purpose, parameters, and return values.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `RocketJoeStaking` is an upgradeable staking contract based on OpenZeppelin's upgradeable libraries. It allows users to deposit JOE tokens and earn rJOE tokens as rewards over time. The reward mechanism is similar to the MasterChef pattern, calculating rewards based on time elapsed and the user's share of the total staked JOE. The contract owner can update the reward emission rate. It includes functionalities for deposit, withdrawal, emergency withdrawal (without rewards), and viewing pending rewards. The contract itself mints the rJOE reward tokens."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""RocketJoeStaking"",
    ""Purpose"": ""To enable users to stake JOE tokens and earn rJOE rewards based on a per-second emission rate. It manages user deposits, calculates, and distributes rewards."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Initializable"",
        ""OwnableUpgradeable""
      ],
      ""Imports"": [
        ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"",
        ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"",
        ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"",
        ""./RocketJoeToken.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""joe"",
        ""Type"": ""IERC20Upgradeable"",
        ""Purpose"": ""The ERC20 token that users stake (JOE).""
      },
      {
        ""Name"": ""lastRewardTimestamp"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Timestamp of the last time rewards were calculated or updated.""
      },
      {
        ""Name"": ""accRJoePerShare"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Accumulated rJOE rewards per share (scaled by PRECISION).""
      },
      {
        ""Name"": ""PRECISION"",
        ""Type"": ""uint256"",
        ""Purpose"": ""Constant (1e18) used for fixed-point arithmetic in reward calculations.""
      },
      {
        ""Name"": ""rJoe"",
        ""Type"": ""RocketJoeToken"",
        ""Purpose"": ""The ERC20 token distributed as rewards (rJOE).""
      },
      {
        ""Name"": ""rJoePerSec"",
        ""Type"": ""uint256"",
        ""Purpose"": ""The rate at which rJOE rewards are generated per second.""
      },
      {
        ""Name"": ""userInfo"",
        ""Type"": ""mapping(address => UserInfo)"",
        ""Purpose"": ""Stores staking information for each user (amount staked and reward debt).""
      },
      {
        ""Name"": ""UserInfo (struct)"",
        ""Type"": ""struct"",
        ""Purpose"": ""Data structure holding user-specific staking data: `amount` (staked JOE) and `rewardDebt` (used to calculate pending rewards).""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""initialize"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract state (used in upgradeable contracts). Sets up JOE token, rJOE token, reward rate, and start time. Calls `__Ownable_init`."",
        ""Parameters"": [""IERC20Upgradeable _joe"", ""RocketJoeToken _rJoe"", ""uint256 _rJoePerSec"", ""uint256 _startTime""],
        ""Returns"": []
      },
      {
        ""Name"": ""pendingRJoe"",
        ""Visibility"": ""external view"",
        ""Purpose"": ""Calculates and returns the amount of pending rJOE rewards for a given user."",
        ""Parameters"": [""address _user""],
        ""Returns"": [""uint256""]
      },
      {
        ""Name"": ""deposit"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to deposit JOE tokens. Updates reward variables, claims pending rewards, transfers JOE in, and updates user info."",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""withdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw JOE tokens. Updates reward variables, claims pending rewards, transfers JOE out, and updates user info."",
        ""Parameters"": [""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw their staked JOE immediately without receiving any pending rJOE rewards. Resets user's reward tracking."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updateEmissionRate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the contract owner to change the rJOE reward emission rate per second. Updates pool before changing rate."",
        ""Parameters"": [""uint256 _rJoePerSec""],
        ""Returns"": []
      },
      {
        ""Name"": ""updatePool"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Updates the accumulated rewards per share (`accRJoePerShare`) based on elapsed time and mints new rJOE tokens to the contract."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""_safeRJoeTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Safely transfers rJOE rewards to a user, ensuring not to transfer more than the contract's current rJOE balance."",
        ""Parameters"": [""address _to"", ""uint256 _amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""onlyOwner (Modifier)"",
        ""Visibility"": ""internal (applied via OwnableUpgradeable)"",
        ""Purpose"": ""Restricts function access to the contract owner."",
        ""Parameters"": [],
        ""Returns"": []
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Calls `balanceOf`, `safeTransferFrom`, `safeTransfer` on the `joe` (IERC20Upgradeable) token contract."",
    ""Calls `mint`, `balanceOf`, `transfer` on the `rJoe` (RocketJoeToken) token contract."",
    ""Relies on OpenZeppelin Upgradeable contracts (`Initializable`, `OwnableUpgradeable`, `SafeERC20Upgradeable`) for core functionality (initialization, ownership, safe transfers).""
  ],
  ""SpecialMechanisms"": [
    ""Upgradeable Contract Pattern: Uses `Initializable` for deployment behind a proxy."",
    ""MasterChef Reward Logic: Employs the `accTokenPerShare` calculation method for distributing rewards proportionally to staked amount and time."",
    ""On-Chain Minting: The staking contract itself is responsible for minting the `rJoe` reward tokens within the `updatePool` function, requiring appropriate permissions on the `rJoe` contract."",
    ""Safe Token Transfers: Utilizes `SafeERC20Upgradeable` to handle ERC20 interactions more safely."",
    ""Emergency Withdrawal: Provides a mechanism for users to retrieve staked funds without rewards in case of issues."",
    ""Fixed-Point Arithmetic: Uses `PRECISION` (1e18) for reward calculations.""
  ],
  ""Questions"": [
    ""The `UserInfo` struct contains many commented-out lines. Are these legacy fields, placeholders for future features, or simply artifacts that should be removed for clarity?"",
    ""The `updatePool` function is `public`. Is there an intentional reason for allowing external calls, or could it be restricted to `internal`?"",
    ""Verification needed: Does the deployment process ensure that this `RocketJoeStaking` contract address is granted minting privileges/role on the `RocketJoeToken` contract?"",
    ""In `_safeRJoeTransfer`, if the calculated `_amount` exceeds `rJoeBal`, the user receives less than their calculated pending rewards. Could a scenario exist where `mint` in `updatePool` succeeds, but the contract still lacks sufficient `rJoe` balance for transfers (e.g., due to other transfers or failed mints)?"",
    ""Is the JOE token assumed to be a standard ERC20? How would the contract behave with fee-on-transfer or rebasing tokens?"",
    ""Could the reward calculation (`accRJoePerShare`) potentially overflow if `rJoePerSec` is extremely high or the contract runs for a very long time? (uint256 makes this unlikely but worth considering).""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Unprotected `rJoe.mint` call in `updatePool`"",
      ""Severity"": ""High"",
      ""Description"": ""The `updatePool` function directly calls `rJoe.mint(address(this), rJoeReward);`. If the `RocketJoeToken` contract has any vulnerabilities in its `mint` function (e.g., improper access control), this contract becomes susceptible to those vulnerabilities. An attacker could potentially exploit a vulnerability in the `RocketJoeToken` contract through the `RocketJoeStaking` contract's `updatePool` function to mint an arbitrary amount of `rJoe` tokens to the staking contract and then withdraw them. Additionally, the `mint` function implementation in RocketJoeToken is not presented. If it is not properly secured, anyone could call it."",
      ""Impact"": ""Potential for unlimited `rJoe` token creation, leading to inflation and loss of value. Complete compromise of the staking pool."",
      ""Location"": ""updatePool function""
    },
    {
      ""Issue"": ""Potential Integer Overflow/Underflow in Reward Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `rJoeReward` calculation in `updatePool()` and `pendingRJoe()` functions, using multiplication (`multiplier * rJoePerSec`), is susceptible to integer overflow if `multiplier` (time difference or block timestamp related) and `rJoePerSec` are sufficiently large. While Solidity >=0.8.0 has built-in overflow protection, intermediate calculations and unchecked arithmetic can still lead to incorrect rewards. Division operations can also result in precision loss."",
      ""Impact"": ""Incorrect reward distribution, potential loss of funds for stakers, and contract malfunction. Smaller rewards, potential for economic exploitation, and potentially making rJoePerShare arbitrarily large."",
      ""Location"": ""RocketJoeStaking.sol:updatePool(), pendingRJoe()""
    },
    {
      ""Issue"": ""Front-Running Vulnerability in Deposit and Withdraw"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `deposit` and `withdraw` functions call `updatePool` at the beginning, creating a race condition. A malicious actor can front-run these calls by manipulating `joeSupply` before the legitimate transaction is mined, potentially increasing their share of rewards or diluting rewards of other users."",
      ""Impact"": ""Unfair reward distribution, potential manipulation of reward calculations, users might get slightly lower or higher rewards than expected."",
      ""Location"": ""RocketJoeStaking.sol:deposit(), RocketJoeStaking.sol:withdraw(), pendingRJoe()""
    },
    {
      ""Issue"": ""Lack of Reentrancy Protection"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract lacks reentrancy protection. The `_safeRJoeTransfer` function transfers rJoe tokens to the user, potentially triggering a callback to the `RocketJoeStaking` contract. Reentrant calls could manipulate state variables, leading to unexpected behavior or allowing attackers to drain funds. The SafeERC20 library mitigates some reentrancy issues, but not the state updates."",
      ""Impact"": ""Potential for malicious contracts to drain funds from the RocketJoeStaking contract."",
      ""Location"": ""_safeRJoeTransfer function, withdraw function, deposit function""
    },
    {
      ""Issue"": ""Unbounded Minting in `updatePool`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `updatePool` function mints rJoe tokens directly to the contract address using `rJoe.mint(address(this), rJoeReward)`. There are no explicit limits on the maximum amount of rJoe that can be minted within a certain time period, potentially inflating the supply of rJoe tokens and devaluing the token for other holders."",
      ""Impact"": ""Token devaluation, potential economic exploitation, loss of confidence in the token and staking pool. Hyperinflation of `rJoe` token, devaluing the token and affecting the entire ecosystem."",
      ""Location"": ""RocketJoeStaking.sol:updatePool""
    },
    {
      ""Issue"": ""Reliance on `block.timestamp` for Reward Calculation and Delayed Reward Distribution"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract relies on `block.timestamp` for reward calculations in both `pendingRJoe` and `updatePool`. While generally reliable, `block.timestamp` is subject to manipulation by miners within certain bounds. Also, if `joeSupply` is zero, the reward calculation in `updatePool` is skipped, potentially leading to a large reward being minted later, disproportionately benefiting early users after a period of zero supply. Initial `lastRewardTimestamp` can also lead to discrepancies."",
      ""Impact"": ""Potential for miners to manipulate reward distribution to a small degree, loss of rewards for users if the pool is empty for a period of time, Uneven distribution of rewards."",
      ""Location"": ""pendingRJoe and updatePool functions""
    },
    {
      ""Issue"": ""Inconsistent Reward Calculation in `pendingRJoe`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `pendingRJoe` function calculates pending rewards based on a potentially outdated `lastRewardTimestamp` and `accRJoePerShare`. It updates `accRJoePerShare` within the view function. Inconsistency can arise because `pendingRJoe` is a `view` function and any state changes here won't be persistent which may lead to a user seeing different values on multiple calls before a transaction is mined."",
      ""Impact"": ""Inaccurate display of pending rewards. Users might make decisions based on incorrect reward information."",
      ""Location"": ""pendingRJoe function""
    },
    {
      ""Issue"": ""Lack of pause functionality"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract doesn't have a pause functionality in case of an emergency situation, where admin can pause certain functionality like deposit or withdraw until the issue is resolved."",
      ""Impact"": ""Inability to stop deposits or withdraws in case of an emergency"",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Potential Front-Running in `updateEmissionRate`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updateEmissionRate` function allows the owner to change the `rJoePerSec` (RJOE per second emission rate). An attacker could potentially front-run a legitimate `updateEmissionRate` transaction to deposit a large amount of JOE tokens just before the emission rate is increased, thereby maximizing their share of the increased RJOE rewards."",
      ""Impact"": ""Potential for attackers to disproportionately benefit from emission rate increases."",
      ""Location"": ""updateEmissionRate function""
    },
    {
      ""Issue"": ""Missing Input Validation in `updateEmissionRate()`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `updateEmissionRate()` function allows the owner to change the `rJoePerSec`. However, there are no checks on the new value of `_rJoePerSec`. Setting it to a very high value could lead to rapid inflation of the `rJoe` token, potentially devaluing it."",
      ""Impact"": ""Inflation of rJoe token, potential devaluation, loss of user confidence."",
      ""Location"": ""RocketJoeStaking.sol:updateEmissionRate()""
    },
    {
      ""Issue"": ""Potential Rounding Error in Reward Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The reward calculation in `pendingRJoe`, `deposit` and `withdraw` involves division. Specifically, `(rJoeReward * PRECISION) / joeSupply` and `(user.amount * accRJoePerShare) / PRECISION`. Rounding errors may occur, especially when `joeSupply` or `PRECISION` is large. These rounding errors accumulate and might lead to some users receiving slightly less rJoe."",
      ""Impact"": ""Minor inaccuracies in reward distribution, potential for small discrepancies in claimed rewards over long periods."",
      ""Location"": ""RocketJoeStaking.sol:pendingRJoe, RocketJoeStaking.sol:deposit, RocketJoeStaking.sol:withdraw, RocketJoeStaking.sol:updatePool""
    },
    {
      ""Issue"": ""Imprecise Reward Calculation"",
      ""Severity"": ""Low"",
      ""Description"": ""The reward calculation relies on integer division, which inherently leads to rounding errors. While using a `PRECISION` factor mitigates this, there's still a possibility of small discrepancies in the reward distribution, particularly for small stakers."",
      ""Impact"": ""Slight inaccuracies in reward distribution."",
      ""Location"": ""RocketJoeStaking.sol:pendingRJoe(), RocketJoeStaking.sol:deposit(), RocketJoeStaking.sol:withdraw()""
    },
    {
      ""Issue"": ""Missing Access Control on `emergencyWithdraw`"",
      ""Severity"": ""Low"",
      ""Description"": ""The `emergencyWithdraw` function allows users to withdraw their staked joe tokens without claiming any pending rJoe rewards. There are no checks or restrictions on how often a user can call this function. This could be exploited to repeatedly withdraw and redeposit, potentially manipulating reward distribution."",
      ""Impact"": ""Potential for reward manipulation or exploitation of the emergency withdrawal mechanism."",
      ""Location"": ""RocketJoeStaking.sol:emergencyWithdraw""
    },
    {
      ""Issue"": ""Potential reentrancy vulnerability in transfer functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_safeRJoeTransfer` function calls `rJoe.transfer`, which could potentially trigger a reentrancy vulnerability if the `rJoe` token contract has a malicious callback function.  Consider using `safeTransfer` if available or implementing reentrancy guards."",
      ""Impact"": ""If the `rJoe` token contract is malicious or contains vulnerabilities, it could potentially re-enter the `_safeRJoeTransfer` and `withdraw` functions."",
      ""Location"": ""RocketJoeStaking.sol:130, RocketJoeStaking.sol:94""
    },
    {
      ""Issue"": ""startTime requirement vulnerability"",
      ""Severity"": ""Low"",
      ""Description"": ""The initialization function requires that the `_startTime` be in the future (`_startTime > block.timestamp`). If the contract owner sets this time far in the future or does not set this to be greater or equal to the block timestamp, users will be unable to stake until that time."",
      ""Impact"": ""Users will be unable to stake until the startTime is reached, deployment can fail."",
      ""Location"": ""RocketJoeStaking.sol: initialize()""
    },
    {
      ""Issue"": ""Missing check for zero amount in withdraw and deposit functions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `withdraw` and `deposit` functions lack checks to ensure that the `_amount` parameter is not zero. Allowing zero-amount deposits or withdrawals can clutter the transaction history and potentially be used for spamming."",
      ""Impact"": ""Minor annoyance or potential for transaction spamming. Does not pose a significant security risk but reduces contract usability and potentially increases gas costs for other operations."",
      ""Location"": ""RocketJoeStaking.sol:77, RocketJoeStaking.sol:94""
    },
     {
      ""Issue"": ""Lack of event for `lastRewardTimestamp` update"",
      ""Severity"": ""Info"",
      ""Description"": ""The variable `lastRewardTimestamp` is updated in the `updatePool` function, however, there is no event emitted when this variable is updated. Emitting an event when the `lastRewardTimestamp` gets updated can be useful for off-chain monitoring and analysis."",
      ""Impact"": ""Makes it difficult to track changes to the rewards distribution, potentially hindering user monitoring and analysis."",
      ""Location"": ""RocketJoeStaking.sol:updatePool""
    }
  ],
  ""IssueNumber"": 43,
  ""OutputList"": 17
}",207.26200699806213,4071.0,32.0,"### **[M-01] Improper Upper Bound Definition on the Fee**

**Report Description**:  
The `rJoePerSec` parameter in the `updateEmissionRate` function does not have any upper or lower bounds. If a value that is too large is set, it could lead to reversions in several critical functions. This lack of bounds could result in unintended behavior, such as excessive token minting or contract failures.

**Match in Response List**:  
Matches with the issue titled **""Missing Input Validation in `updateEmissionRate()`""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the lack of input validation in the `updateEmissionRate` function. It correctly explains the risks associated with setting an unbounded `rJoePerSec` value, which aligns with the issue described in the report.

---

### **[M-03] `createRJLaunchEvent()` can be called by anyone with 1 Wei of `_token` and stop others from creating RJLaunchEvent with the same token anymore**

**Report Description**:  
The `createRJLaunchEvent` function in `RocketJoeFactory.sol` can be called by anyone with at least 1 Wei of `_token`. This allows a malicious user to call the function with minimal cost, preventing others (including the platform or the rightful issuer) from creating an RJLaunchEvent with the same token. This could disrupt the intended functionality of the platform.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability described in the report is not covered in the response list, leaving a significant gap in the analysis.

---

### **[M-04] Uninitialized `RocketJoeStaking.lastRewardTimestamp` can inflate `rJoe` supply**

**Report Description**:  
The `lastRewardTimestamp` variable in `RocketJoeStaking` is initialized to zero. If a user transfers `Joe` tokens to the contract before the first `updatePool` call, the `block.timestamp - lastRewardTimestamp` calculation will result in a large value, leading to excessive `rJoe` minting. Although these tokens are not distributed to users, inflating the `rJoe` supply is undesirable.

**Match in Response List**:  
Matches with the issue titled **""Reliance on `block.timestamp` for Reward Calculation and Delayed Reward Distribution""**.

**Validation**:  
**Partially Correct**. The response identifies the reliance on `block.timestamp` and the potential for delayed reward distribution, but it does not explicitly mention the risk of `lastRewardTimestamp` being uninitialized and its impact on `rJoe` supply inflation. The response partially covers the issue but misses critical details.

---

### **[M-06] Possibility of minting rJOE tokens before ownership is changed to RocketJoeStaking**

**Report Description**:  
The `mint` function in `RocketJoeToken.sol` allows the original owner to mint `rJOE` tokens without staking any `JOE` before ownership is transferred to `RocketJoeStaking`. This could lead to unauthorized token minting, undermining the intended staking mechanism.

**Match in Response List**:  
Matches with the issue titled **""Unprotected `rJoe.mint` call in `updatePool`""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of unprotected `rJoe.mint` calls, but it does not specifically address the issue of minting before ownership transfer. The response partially covers the issue but misses the context of ownership transfer.

---

### **[M-11] Re-enterable Code When Making a Deposit to Stake**

**Report Description**:  
The deposit function in `RocketJoeStaking` is potentially reentrant if `rJoe` relinquishes control during `transfer()`. Although the current `RocketJoeToken` implementation does not allow this, the code pattern is highly risky and should be avoided. If exploited, it could allow the entire `rJoe` balance to be drained from the contract.

**Match in Response List**:  
Matches with the issue titled **""Lack of Reentrancy Protection""**.

**Validation**:  
**Correct**. The response accurately identifies the lack of reentrancy protection in the contract. It correctly explains the risks associated with reentrant calls, which aligns with the issue described in the report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Improper Upper Bound Definition on the Fee**
- **[M-11] Re-enterable Code When Making a Deposit to Stake**

**Partially Correct Matches**:

- **[M-04] Uninitialized `RocketJoeStaking.lastRewardTimestamp` can inflate `rJoe` supply**
- **[M-06] Possibility of minting rJOE tokens before ownership is changed to RocketJoeStaking**

**Missed Issues from Issue Report**:

- **[M-03] `createRJLaunchEvent()` can be called by anyone with 1 Wei of `_token` and stop others from creating RJLaunchEvent with the same token anymore**

--- 

The response list covers most of the issues but misses critical details in some cases and entirely overlooks one significant vulnerability.","```
1. Missing Input Validation in `updateEmissionRate()`
2. Lack of Reentrancy Protection
```","To calculate the **Average Precision (AP)**, we follow these steps:

1. **Identify the ranks of the true positives**:
   - ""Missing Input Validation in `updateEmissionRate()`"" appears at rank 10.
   - ""Lack of Reentrancy Protection"" appears at rank 4.

2. **Calculate precision at each rank**:
   - For rank 4: \( P@4 = \frac{1}{4} = 0.25 \)
   - For rank 10: \( P@10 = \frac{2}{10} = 0.2 \)

3. **Average the precision values**:
   - \( AP = \frac{0.25 + 0.2}{2} = 0.225 \)

**Average Precision (AP)**: 0.225"
