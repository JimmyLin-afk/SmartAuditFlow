nameid,code,tokens,loc,issue,vulnumber,Unnamed: 6,code_snippet,processtokens,high_severity_count,medium_severity_count,audit_plan,initial_analysis,Findings,execution_time,total_tokens,total_steps,Comparison,matchList,MAP
HolyPaladinToken.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import ""./open-zeppelin/ERC20.sol"";
import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";
import ""./open-zeppelin/utils/Math.sol"";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20(""Holy Paladin Token"", ""hPAL""), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, ""hPAL: No balance"");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, ""hPAL: cannot kick yourself"");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, ""hPAL: incorrect amount"");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), ""hPAL: Insufficient cooldown"");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, ""hPAL: unstake period expired"");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, ""hPAL: Null amount"");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, ""hPAL: Amount over balance"");
        require(duration >= MIN_LOCK_DURATION, ""hPAL: Lock duration under min"");
        require(duration <= MAX_LOCK_DURATION, ""hPAL: Lock duration over max"");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,""hPAL: smaller amount"");
                require(duration >=  currentUserLock.duration,""hPAL: smaller duration"");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), ""hPAL: Address Zero"");
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, ""hPAL: Not kickable"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, ""hPAL: Not emergency"");

        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}",12522,1437,"[H-01] DropPerSecond is not updated homogeneously, the rewards emission can be much higher than expected in some cases
In the function `_updateDropPerSecond()`, when current time is `lastDropUpdate + (2*MONTH-1)`:
`nbMonthEllapsed` will be round down to 1, while it's actually 1.99 months passed, but because of precision loss, the smart contract will believe it's only 1 month elapsed, as a result, `DropPerSecond` will only decrease by 1 * `dropDecreasePerMonth`.
In another word, due to the precision loss in calculating the number of months elapsed, for each `_updateDropPerSecond()` there can be a short of up to 1 * `dropDecreasePerMonth` for the decrease of emission rate.
At the very edge case, if all the updates happened just like the scenario above. by the end of the dropDecreaseDuration, it will drop only 12 * dropDecreasePerMonth in total, while it's expected to be 24 * dropDecreasePerMonth.
So only half of (startDropPerSecond - endDropPerSecond) is actually decreased. And the last time updateDropPerSecond is called, DropPerSecond will suddenly drop to endDropPerSecond.   [H-02] System could be wrapped and made useless without contract whitelisting
Anyone could create a contract or a contract factory ""PAL Locker"" with a fonction to deposit PAL tokens through a contract, lock them and delegate the voting power to the contract owner. Then, the ownership of this contract could be sold. By doing so, locked hPAL would be made liquid and transferrable again. This would eventually break the overall system of hPAL, where the idea is that you have to lock them to make them non liquid to get a boosted voting power and reward rate.
  [M-01] HolyPaladinToken.sol uses ERC20 token with a highly unsafe pattern
In HolyPaladinToken.sol it imports ERC20.sol with some changes from the original Open Zeppelin standard. One change is that the `transferFrom()` function does not follow the Checks Effect and Interactions safety pattern to safely make external calls to other contracts. All checks should be handled first, then any effects/state updates, followed by the external call to prevent reentrancy attacks. Currently the `transferFrom()` function in ERC20.sol used by HolyPaladinToken.sol calls _transfer() first and then updates the sender allowance which is highly unsafe. The openZeppelin ER20.sol contract which is the industry standard first updates the sender allowance before calling _transfer. The external call should always be done last to avoid any double spending bugs or reentrancy attacks.
  [M-02] Incorrect number of seconds in `ONE_YEAR` variable
In HolyPaladinToken.sol the ONE_YEAR variable claims that there are 31557600 seconds in a year when this is incorrect. The ONE_YEAR variable is used in the `getCurrentVotes()` function as well as the getPastVotes() function so it is vital that the correct time in seconds be used as it can effect users negatively.
  [M-03] Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens.
In the `_getNewReceiverCooldown` function, `_senderCooldown` is Day 15 and receiverCooldown is Day 0, so the latest cooldown of user A is (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5.   [M-04] cooldown is set to 0 when the user sends all tokens to himself
In the `_beforeTokenTransfer` function, cooldowns will be set to 0 when the user transfers all tokens to himself.   [M-05] Past state query results are susceptible to manipulation due to multiple states with same block number   [M-09] Function `cooldown()` is not protected when protocol in emergency mode Its behavior is not consistent with the other major functions defined.
  [M-13] Users Can Bypass Emergency Restrictions on `updateUserRewardState()`

[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards
Paladin protocol allows users to increase the amount or duration of their lock while it is stil active. Increasing the amount of an active lock should only increase the total locked amount and it shouldn't make any changes to the associated bonus ratios as the duration remains unchanged.",10,,"pragma solidity ^0.8.10;

import ""./open-zeppelin/ERC20.sol"";
import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";
import ""./open-zeppelin/utils/Math.sol"";



contract HolyPaladinToken is ERC20(""Holy Paladin Token"", ""hPAL""), Ownable {
    using SafeERC20 for IERC20;


    
    uint256 public constant WEEK = 604800;
    
    uint256 public constant MONTH = 2629800;
    
    uint256 public constant UNIT = 1e18;
    
    uint256 public constant MAX_BPS = 10000;
    
    uint256 public constant ONE_YEAR = 31557600;

    
    uint256 public constant COOLDOWN_PERIOD = 864000; 
    
    uint256 public constant UNSTAKE_PERIOD = 432000; 

    
    uint256 public constant UNLOCK_DELAY = 1209600; 

    
    uint256 public constant MIN_LOCK_DURATION = 7889400; 
    
    uint256 public constant MAX_LOCK_DURATION = 63115200; 

    
    IERC20 public immutable pal;

    
    struct UserLock {
        
        uint128 amount; 
        
        uint48 startTimestamp;
        
        uint48 duration;
        
        uint32 fromBlock; 
    }

    
    mapping(address => UserLock[]) public userLocks;

    
    struct TotalLock {
        
        uint224 total;
        
        uint32 fromBlock;
    }

    
    uint256 public currentTotalLocked;
    
    TotalLock[] public totalLocks;

    
    mapping(address => uint256) public cooldowns;

    
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    
    mapping(address => address) public delegates;

    
    mapping(address => Checkpoint[]) public checkpoints;

    
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    
    uint256 public kickRatioPerWeek = 1000;

    
    uint256 public bonusLockVoteRatio = 0.5e18;

    
    bool public emergency = false;

    
    address public immutable rewardsVault;

    
    uint256 public rewardIndex;
    
    uint256 public lastRewardUpdate;

    
    uint256 public immutable startDropPerSecond;
    
    uint256 public endDropPerSecond;
    
    uint256 public currentDropPerSecond;
    
    uint256 public lastDropUpdate;
    
    uint256 public immutable dropDecreaseDuration;
    
    uint256 public immutable startDropTimestamp;

    
    mapping(address => uint256) public userRewardIndex;
    
    mapping(address => uint256) public claimableRewards;
    
    mapping(address => uint256) public rewardsLastUpdate;

    
    uint256 public immutable baseLockBonusRatio;
    
    uint256 public immutable minLockBonusRatio;
    
    uint256 public immutable maxLockBonusRatio;

    
    mapping(address => uint256) public userCurrentBonusRatio;
    
    mapping(address => uint256) public userBonusRatioDecrease;

    
    error EmergencyBlock(); 

    

    
    event Stake(address indexed user, uint256 amount);
    
    event Unstake(address indexed user, uint256 amount);
    
    event Cooldown(address indexed user);
    
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    
    event ClaimRewards(address indexed user, uint256 amount);
    
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        
        startDropTimestamp = block.timestamp;
    }


    
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, ""hPAL: No balance"");

        
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        
        _updateUserRewards(msg.sender);
        
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        
        _updateUserRewards(msg.sender);
        
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, ""hPAL: cannot kick yourself"");
        
        
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        
        uint256 stakedAmount = _stake(msg.sender, amount);
        
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        
        uint256 stakedAmount = _stake(msg.sender, amount);
        
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        
        _updateUserRewards(msg.sender);

        require(amount > 0, ""hPAL: incorrect amount"");

        
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        
        
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    

    
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    
    function getUserLock(address user) external view returns(UserLock memory) {
        
        
        
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); 
        return totalLocks[totalLocks.length - 1];
    }

    
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        
        
        
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        
        
        
        
        
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    
    function estimateClaimableRewards(address user) external view returns(uint256) {
        
        
        if(emergency || user == address(0)) return 0;
        
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        
        uint256 estimatedClaimableRewards = claimableRewards[user];
        
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; 

        uint256 nbCheckpoints = checkpoints[user].length;
        
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        
        uint256 votes = _getPastVotes(user, blockNumber);


        
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    

    
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    
    function _updateDropPerSecond() internal returns (uint256){
        
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            
            
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; 

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        
        
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        
        uint256 currentTotalSupply = totalSupply();
        
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        
        
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; 

        
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                
                
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            
                            
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                
                                
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                
                                
                                
                            }

                            
                            
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    
    function _updateUserRewards(address user) internal {
        
        uint256 newIndex = _updateRewardState();

        
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; 

        
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        
        userCurrentBonusRatio[user] = newBonusRatio;
        
        
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { 
            
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; 

        if(from != to) {
            
            _updateUserRewards(to);
            
            

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, ""hPAL: invalid blockNumber"");

        
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, ""hPAL: invalid blockNumber"");

        
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");

        
        

        _mint(user, amount); 

        
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), ""hPAL: Insufficient cooldown"");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, ""hPAL: unstake period expired"");

        

        
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        
        _burn(user, burnAmount);

        

        
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    
    
    
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        
        if(receiverCooldown < minValidCooldown) return 0;

        
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); 
        require(amount != 0, ""hPAL: Null amount"");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, ""hPAL: Amount over balance"");
        require(duration >= MIN_LOCK_DURATION, ""hPAL: Lock duration under min"");
        require(duration <= MAX_LOCK_DURATION, ""hPAL: Lock duration over max"");

        if(userLocks[user].length == 0){
            

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                
                

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                
                
                require(amount >=  currentUserLock.amount,""hPAL: smaller amount"");
                require(duration >=  currentUserLock.duration,""hPAL: smaller duration"");

                

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            
            if(action != LockAction.INCREASE_AMOUNT){
                
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); 
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        
        
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), ""hPAL: Address Zero"");
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        
        
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, ""hPAL: Not kickable"");

        
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, ""hPAL: Not emergency"");

        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        if(userLocks[msg.sender].length != 0){
            
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}",8463,2,8,"{
  ""task_list"": [
    {
      ""Area"": ""Security Vulnerabilities - Reentrancy"",
      ""Tasks"": [
        ""Analyze `_beforeTokenTransfer`, `_afterTokenTransfer`, `_updateUserRewards`, `claim`, `unstake`, `lock`, `unlock`, and `kick` functions for potential reentrancy vulnerabilities, particularly when interacting with external `pal` token contract. Focus on call sequences that could allow malicious contracts to re-enter and manipulate state."",
        ""Verify that the Checks-Effects-Interactions pattern is strictly followed in all state-modifying functions, especially those interacting with external contracts or performing complex calculations."",
        ""Specifically analyze `_beforeTokenTransfer` which calls `_updateUserRewards` and `_getNewReceiverCooldown`, as these introduce complexity that could create a reentrancy attack surface."",
        ""Check if `emergencyWithdraw` is vulnerable to reentrancy if `pal.safeTransfer` fails after state is modified, or if it can be front-run.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities - Integer Overflows/Underflows"",
      ""Tasks"": [
        ""Review all arithmetic operations, especially those involving user-supplied inputs (amount, duration), for potential overflows or underflows. Although Solidity 0.8.0+ has built-in overflow protection, ensure that custom logic (e.g., reward calculations) doesn't introduce vulnerabilities."",
        ""Examine reward calculations in `_getUserAccruedRewards`, `_updateUserRewards`, and `_getNewIndex` to ensure intermediate results don't exceed `uint256` limits before being divided by `UNIT` or other large numbers."",
        ""Review the `safe32`, `safe48`, `safe128`, and `safe224` functions. Confirm that there are no scenarios where values exceeding these bit lengths can bypass these checks, either due to incorrect logic or pre-existing constraints not being adequately verified.""
      ]
    },
    {
      ""Area"": ""Security Vulnerabilities - Front-running & Transaction Ordering"",
      ""Tasks"": [
        ""Analyze the `stake`, `unstake`, `lock`, `unlock`, and `kick` functions for potential front-running vulnerabilities, where malicious actors could exploit knowledge of pending transactions to their advantage."",
        ""Investigate if a malicious user can manipulate the `cooldown` mechanism or the reward index by front-running legitimate user transactions."",
        ""Assess the impact of transaction ordering on the bonus ratio calculation. Can a user manipulate the bonus ratio by carefully ordering `stake`, `lock` and `delegate` transactions?"",
        ""Examine the vulnerability surface of `emergencyWithdraw` to front-running, since the available balance is immediately burned upon call.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms - Reward Calculation and Distribution"",
      ""Tasks"": [
        ""Verify the accuracy of the reward calculation logic in `_getUserAccruedRewards`, `_updateUserRewards`, and `_getNewIndex`, paying close attention to the handling of bonus ratios, lock durations, and reward decay. Create test cases with various scenarios to ensure rewards are distributed fairly and as expected."",
        ""Analyze the impact of rounding errors and precision loss on the reward distribution, especially in calculations involving `UNIT` and large numbers. Use fuzzing to explore edge cases."",
        ""Confirm that the linear decrease in `currentDropPerSecond` is implemented correctly and that the `startDropTimestamp` and `dropDecreaseDuration` parameters are used as intended."",
        ""Evaluate how frequently `updateRewardState` and `updateUserRewardState` need to be called to maintain accurate reward calculations, and whether gas costs associated with these calls could become prohibitive."",
        ""Analyze the logic in `_getUserAccruedRewards` regarding the `bonusRatioDecrease` and `periodBonusRatio`. Verify correctness and potential edge cases.""
      ]
    },
    {
      ""Area"": ""Complex Logic/Algorithms - Locking and Unlocking Mechanics"",
      ""Tasks"": [
        ""Scrutinize the `_lock` and `_unlock` functions to ensure that the locking and unlocking mechanics work as intended and that there are no unintended side effects or vulnerabilities. Pay attention to how existing locks are handled when increasing amounts or durations."",
        ""Verify that the `MIN_LOCK_DURATION` and `MAX_LOCK_DURATION` parameters are enforced correctly and that there are no ways to bypass these limits."",
        ""Analyze edge cases related to lock expiry and the interaction with the `kick` function. Confirm that the penalty amount is calculated correctly and that the `UNLOCK_DELAY` is enforced as intended."",
        ""Review how the `_lock` function handles the current total locked amount. Make sure the stored value of `currentTotalLocked` is correct and correctly reflects all locks and unlocks."",
        ""Confirm that the logic in `stakeAndIncreaseLock` is sound and correctly handles the case where duration is the same or different from the current lock."",
        ""Verify the interaction between `increaseLock`, `increaseLockDuration` and the reward bonus ratios.""
      ]
    },
    {
      ""Area"": ""Access Control and Emergency Mechanism"",
      ""Tasks"": [
        ""Verify that the `Ownable` contract is used correctly and that only the owner can call the `setKickRatio`, `triggerEmergencyWithdraw`, and `setEndDropPerSecond` functions."",
        ""Evaluate the security implications of the `emergency` flag and the `emergencyWithdraw` function. Assess the risks associated with enabling emergency mode and ensure that it cannot be abused."",
        ""Confirm that `emergencyWithdraw` properly burns the tokens and transfers the underlying `pal` tokens to the receiver, and that any state updates are performed correctly in the emergency scenario."",
        ""Evaluate the potential denial of service attacks that can occur via `triggerEmergencyWithdraw`.""
      ]
    },
    {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Identify opportunities to reduce gas costs in frequently called functions such as `stake`, `unstake`, `lock`, `unlock`, `claim`, `updateUserRewardState` and `updateRewardState`."",
        ""Review the usage of storage variables and mappings for potential gas savings. Consider using immutable or constant variables where appropriate."",
        ""Analyze the gas costs associated with the checkpointing mechanism and evaluate whether alternative data structures or techniques could be used to reduce gas consumption."",
        ""Assess the efficiency of the reward calculation logic and identify areas where gas costs could be reduced without sacrificing accuracy."",
        ""Review loops and iterations within functions for potential gas inefficiencies. For instance, loops in `_moveDelegates` or within the checkpointing functions.""
      ]
    },
    {
      ""Area"": ""Voting Delegation Security"",
      ""Tasks"": [
        ""Verify that the delegation mechanism (delegate, getPastVotes, getCurrentVotes) works correctly, and that voting power is accurately transferred between delegators and delegatees."",
        ""Analyze the checkpointing mechanism for voting power and delegation history to ensure data integrity and prevent manipulation. Confirm that past votes are correctly calculated for any given block number."",
        ""Assess whether a malicious user can manipulate the delegation history to gain undue voting power or disrupt governance processes."",
        ""Check the impact of `bonusLockVoteRatio` on the overall voting power distribution.""
      ]
    },
    {
      ""Area"": ""Data Type Size and Packing"",
      ""Tasks"": [
        ""Review the use of `uint32`, `uint48`, `uint128`, and `uint224` types within structs and mappings. Verify that these types are appropriately sized to prevent overflows and that data is packed efficiently to minimize storage costs."",
        ""Analyze the impact of changing data types on gas consumption and storage costs. Confirm that the `safe32`, `safe48`, `safe128`, and `safe224` functions are implemented correctly and that they prevent overflows."",
        ""Confirm that the correct data type size is used, especially for timestamp values where `uint48` is used.""
      ]
    },
    {
      ""Area"": ""External Interactions and Dependencies"",
      ""Tasks"": [
        ""Verify the integrity and security of the `pal` token contract and the `rewardsVault` address. Ensure that these external entities are trustworthy and not susceptible to attacks."",
        ""Review the usage of `SafeERC20` to prevent common ERC20 transfer errors. Confirm that all token transfers use `safeTransfer` or `safeTransferFrom`."",
        ""Assess the risks associated with relying on external libraries such as OpenZeppelin's `ERC20`, `Ownable`, `SafeERC20`, and `Math`. Ensure that these libraries are up-to-date and not vulnerable to known exploits."",
        ""Verify that the contract correctly handles scenarios where the `pal` token contract or the `rewardsVault` address are malicious or compromised.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The contract `HolyPaladinToken` is an ERC20 token (`hPAL`) that represents shares in a staking pool for an underlying token (`pal`). Users stake `pal` to mint `hPAL`. The contract implements complex features including time-locked staking with bonus rewards and voting power based on lock duration, a cooldown mechanism for unstaking, delegation of voting power using a checkpoint system similar to ERC20Votes, a mechanism to 'kick' users who fail to unlock their expired locks, a linearly decreasing reward emission rate over time, and an emergency withdrawal feature controlled by the owner."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""HolyPaladinToken"",
    ""Purpose"": ""To create a staking and locking system for an underlying token (`pal`), where users receive an ERC20 token (`hPAL`) representing their stake. It incentivizes long-term locking through reward bonuses and potential voting power, manages reward distribution, and includes delegation and unstaking mechanisms."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""ERC20"",
        ""Ownable""
      ],
      ""Imports"": [
        ""./open-zeppelin/ERC20.sol"",
        ""./open-zeppelin/utils/Ownable.sol"",
        ""./open-zeppelin/interfaces/IERC20.sol"",
        ""./open-zeppelin/libraries/SafeERC20.sol"",
        ""./open-zeppelin/utils/Math.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""WEEK, MONTH, UNIT, MAX_BPS, ONE_YEAR, COOLDOWN_PERIOD, UNSTAKE_PERIOD, UNLOCK_DELAY, MIN_LOCK_DURATION, MAX_LOCK_DURATION"",
        ""Type"": ""uint256 public constant"",
        ""Purpose"": ""Time constants, unit definitions, and period durations governing contract mechanics.""
      },
      {
        ""Name"": ""pal"",
        ""Type"": ""IERC20 public immutable"",
        ""Purpose"": ""The underlying token that is staked.""
      },
      {
        ""Name"": ""UserLock"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores details of a user's token lock (amount, start time, duration, block number).""
      },
      {
        ""Name"": ""userLocks"",
        ""Type"": ""mapping(address => UserLock[]) public"",
        ""Purpose"": ""Stores the history of locks for each user.""
      },
      {
        ""Name"": ""TotalLock"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores the total amount of locked tokens at a specific block number.""
      },
      {
        ""Name"": ""currentTotalLocked"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""The current total amount of hPAL tokens locked in the contract.""
      },
      {
        ""Name"": ""totalLocks"",
        ""Type"": ""TotalLock[] public"",
        ""Purpose"": ""Stores the history of total locked amounts for point-in-time queries.""
      },
      {
        ""Name"": ""cooldowns"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Stores the timestamp when a user initiated the cooldown period for unstaking.""
      },
      {
        ""Name"": ""Checkpoint"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores voting power (votes) at a specific block number for delegation.""
      },
      {
        ""Name"": ""DelegateCheckpoint"",
        ""Type"": ""struct"",
        ""Purpose"": ""Stores the delegate address at a specific block number.""
      },
      {
        ""Name"": ""delegates"",
        ""Type"": ""mapping(address => address) public"",
        ""Purpose"": ""Stores the current delegate for each user.""
      },
      {
        ""Name"": ""checkpoints"",
        ""Type"": ""mapping(address => Checkpoint[]) public"",
        ""Purpose"": ""Stores the historical voting power checkpoints for each delegatee.""
      },
      {
        ""Name"": ""delegateCheckpoints"",
        ""Type"": ""mapping(address => DelegateCheckpoint[]) public"",
        ""Purpose"": ""Stores the historical delegation checkpoints for each delegator.""
      },
      {
        ""Name"": ""kickRatioPerWeek"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""The penalty percentage (in BPS, basis points) applied per week when kicking an expired lock.""
      },
      {
        ""Name"": ""bonusLockVoteRatio"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""Additional voting power ratio applied to self-delegated locks meeting minimum duration.""
      },
      {
        ""Name"": ""emergency"",
        ""Type"": ""bool public"",
        ""Purpose"": ""Flag to indicate if the contract is in emergency mode, enabling emergency withdrawals.""
      },
      {
        ""Name"": ""rewardsVault"",
        ""Type"": ""address public immutable"",
        ""Purpose"": ""The address from which `pal` token rewards are distributed.""
      },
      {
        ""Name"": ""rewardIndex"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""Global reward index used to calculate rewards per token.""
      },
      {
        ""Name"": ""lastRewardUpdate"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""Timestamp of the last global reward index update.""
      },
      {
        ""Name"": ""startDropPerSecond, endDropPerSecond, currentDropPerSecond"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""Parameters defining the reward emission rate (pal tokens per second).""
      },
      {
        ""Name"": ""lastDropUpdate"",
        ""Type"": ""uint256 public"",
        ""Purpose"": ""Timestamp of the last update to `currentDropPerSecond`.""
      },
      {
        ""Name"": ""dropDecreaseDuration, startDropTimestamp"",
        ""Type"": ""uint256 public immutable"",
        ""Purpose"": ""Parameters defining the period over which the reward drop rate decreases.""
      },
      {
        ""Name"": ""userRewardIndex"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Stores the last reward index recorded for each user.""
      },
      {
        ""Name"": ""claimableRewards"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Stores the amount of `pal` rewards claimable by each user.""
      },
      {
        ""Name"": ""rewardsLastUpdate"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Timestamp of the last reward calculation for each user.""
      },
      {
        ""Name"": ""baseLockBonusRatio, minLockBonusRatio, maxLockBonusRatio"",
        ""Type"": ""uint256 public immutable"",
        ""Purpose"": ""Parameters defining the reward bonus ratio based on lock duration.""
      },
      {
        ""Name"": ""userCurrentBonusRatio"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Stores the current reward bonus ratio for each user's lock.""
      },
      {
        ""Name"": ""userBonusRatioDecrease"",
        ""Type"": ""mapping(address => uint256) public"",
        ""Purpose"": ""Stores the rate at which a user's lock bonus ratio decreases over time.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract, setting immutable parameters, owner, and initial state."",
        ""Parameters"": [""palToken"", ""_admin"", ""_rewardsVault"", ""_startDropPerSecond"", ""_endDropPerSecond"", ""_dropDecreaseDuration"", ""_baseLockBonusRatio"", ""_minLockBonusRatio"", ""_maxLockBonusRatio""],
        ""Returns"": []
      },
      {
        ""Name"": ""stake"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to stake `pal` tokens and mint `hPAL` tokens."",
        ""Parameters"": [""amount""],
        ""Returns"": [""uint256 (stakedAmount)""]
      },
      {
        ""Name"": ""cooldown"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Initiates the cooldown period required before unstaking."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""unstake"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows a user to unstake `hPAL` (burn) and receive `pal` after the cooldown and unstake periods."",
        ""Parameters"": [""amount"", ""receiver""],
        ""Returns"": [""uint256 (unstakedAmount)""]
      },
      {
        ""Name"": ""lock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Locks a specified amount of `hPAL` for a given duration."",
        ""Parameters"": [""amount"", ""duration""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseLockDuration"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases the duration of the user's current lock."",
        ""Parameters"": [""duration""],
        ""Returns"": []
      },
      {
        ""Name"": ""increaseLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Increases the amount of `hPAL` in the user's current lock."",
        ""Parameters"": [""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""unlock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Unlocks the user's `hPAL` after the lock duration has expired."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""kick"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows any user to force unlock another user's expired lock after a delay, receiving a penalty."",
        ""Parameters"": [""user""],
        ""Returns"": []
      },
      {
        ""Name"": ""stakeAndLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Atomically stakes `pal` and locks the resulting `hPAL`."",
        ""Parameters"": [""amount"", ""duration""],
        ""Returns"": [""uint256 (stakedAmount)""]
      },
      {
        ""Name"": ""stakeAndIncreaseLock"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Atomically stakes `pal` and adds it to the user's existing lock, potentially extending duration."",
        ""Parameters"": [""amount"", ""duration""],
        ""Returns"": [""uint256 (stakedAmount)""]
      },
      {
        ""Name"": ""delegate"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Delegates the user's voting power to another address."",
        ""Parameters"": [""delegatee""],
        ""Returns"": []
      },
      {
        ""Name"": ""claim"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Claims accrued `pal` rewards."",
        ""Parameters"": [""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""updateRewardState"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the global reward index and drop rate."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""updateUserRewardState"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Updates the reward state for a specific user."",
        ""Parameters"": [""user""],
        ""Returns"": []
      },
      {
        ""Name"": ""emergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows users to withdraw their staked `pal` if the emergency flag is set, bypassing normal unstake/unlock rules."",
        ""Parameters"": [""amount"", ""receiver""],
        ""Returns"": [""uint256 (withdrawnAmount)""]
      },
      {
        ""Name"": ""setKickRatio"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to set the penalty ratio for kicking."",
        ""Parameters"": [""newKickRatioPerWeek""],
        ""Returns"": []
      },
      {
        ""Name"": ""triggerEmergencyWithdraw"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to enable or disable the emergency mode."",
        ""Parameters"": [""trigger""],
        ""Returns"": []
      },
      {
        ""Name"": ""setEndDropPerSecond"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Owner function to set a new final reward drop rate after the initial decrease duration."",
        ""Parameters"": [""newEndDropPerSecond""],
        ""Returns"": []
      },
      {
        ""Name"": ""_beforeTokenTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Hook called before ERC20 transfers. Updates rewards, checks available balance, and manages cooldown state propagation."",
        ""Parameters"": [""from"", ""to"", ""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_afterTokenTransfer"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Hook called after ERC20 transfers. Updates delegate voting power."",
        ""Parameters"": [""from"", ""to"", ""amount""],
        ""Returns"": []
      },
      {
        ""Name"": ""_stake, _unstake, _lock, _unlock, _kick, _delegate"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal logic implementations for the corresponding external functions."",
        ""Parameters"": [""various""],
        ""Returns"": [""various""]
      },
      {
        ""Name"": ""_updateUserRewards, _updateRewardState, _updateDropPerSecond, _getUserAccruedRewards, _getNewIndex"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal functions managing reward calculation logic, index updates, and drop rate adjustments."",
        ""Parameters"": [""various""],
        ""Returns"": [""various""]
      },
      {
        ""Name"": ""_getPastLock, _getPastVotes, _getPastDelegate, _getPastTotalLock"",
        ""Visibility"": ""internal/public view"",
        ""Purpose"": ""Functions to retrieve historical state (locks, votes, delegates, total locked) at a specific block number using checkpoints."",
        ""Parameters"": [""account/user"", ""blockNumber""],
        ""Returns"": [""UserLock/uint256/address/TotalLock""]
      },
      {
        ""Name"": ""_moveDelegates, _writeCheckpoint"",
        ""Visibility"": ""internal"",
        ""Purpose"": ""Internal functions managing the update and storage of vote delegation checkpoints."",
        ""Parameters"": [""various""],
        ""Returns"": []
      },
      {
        ""Name"": ""safe32, safe48, safe128, safe224"",
        ""Visibility"": ""internal pure"",
        ""Purpose"": ""Utility functions to safely cast uint256 to smaller uint types, reverting on overflow."",
        ""Parameters"": [""n""],
        ""Returns"": [""uint32/uint48/uint128/uint224""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""Interacts with the `pal` IERC20 token contract via `SafeERC20` for `safeTransferFrom` (staking, claiming) and `safeTransfer` (unstaking, emergency withdrawal)."",
    ""Transfers `pal` rewards *from* the `rewardsVault` address during `claim`."",
    ""Inherits from OpenZeppelin's `ERC20` and `Ownable` contracts."",
    ""Uses OpenZeppelin's `SafeERC20` library for safe token transfers."",
    ""Uses OpenZeppelin's `Math` library for `average` calculation (likely in binary searches).""
  ],
  ""SpecialMechanisms"": [
    ""**Staking & Locking:** Users stake `pal` for `hPAL`, which can then be locked for durations."",
    ""**Time-Varying Rewards:** Reward emission (`dropPerSecond`) decreases linearly over `dropDecreaseDuration`."",
    ""**Lock Bonus Multiplier:** Locking provides a reward bonus (`userCurrentBonusRatio`) that scales with duration (between `minLockBonusRatio` and `maxLockBonusRatio`) and decays towards `baseLockBonusRatio` over the lock period."",
    ""**Checkpointing:** Records historical data for user locks (`userLocks`), total locks (`totalLocks`), votes (`checkpoints`), and delegations (`delegateCheckpoints`) allowing point-in-time queries."",
    ""**Delegation:** Implements an ERC20Votes-style delegation mechanism."",
    ""**Bonus Voting Power:** Self-delegated locks >= `ONE_YEAR` get extra voting power (`bonusLockVoteRatio`)."",
    ""**Cooldown Unstaking:** Requires users to call `cooldown` and wait (`COOLDOWN_PERIOD`) before being able to `unstake` within a specific window (`UNSTAKE_PERIOD`)."",
    ""**Kicking Mechanism:** Allows forced unlocking of expired locks after a delay (`UNLOCK_DELAY`), with a penalty (`kickRatioPerWeek`) paid to the kicker."",
    ""**Emergency Mode:** Owner-controlled flag (`emergency`) to halt normal operations and enable `emergencyWithdraw`."",
    ""**Safe Type Casting:** Uses internal functions (`safe32`, `safe48`, etc.) to prevent overflow when storing data in smaller struct fields."",
    ""**Cooldown Propagation:** Cooldown status is averaged and transferred when `hPAL` tokens are transferred (`_getNewReceiverCooldown`, `_beforeTokenTransfer`).""
  ],
  ""Questions"": [
    ""How is the `rewardsVault` funded with `pal` tokens? (Assumed external process)"",
    ""Are there potential gas limit issues with the checkpoint arrays (`userLocks`, `totalLocks`, `checkpoints`, `delegateCheckpoints`) growing indefinitely?"",
    ""Could the complexity of reward calculations (`_getUserAccruedRewards`, `_updateUserRewards`) lead to precision issues or vulnerabilities, especially around bonus ratio decay?"",
    ""Is the logic in `_getNewReceiverCooldown` robust against manipulation attempts to dilute or reset cooldowns unfairly?"",
    ""The `_lock` function always pushes a new `UserLock` entry even when increasing amount/duration for an existing conceptual lock. Is storing this full history intended and performant?"",
    ""While Checks-Effects-Interactions seems generally followed, are there any subtle reentrancy risks, particularly given the complexity of hooks like `_beforeTokenTransfer` which call reward updates?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Potential Reentrancy Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The `claim` function utilizes `pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount)` and/or `pal.safeTransfer(address recipient, uint256 amount)` which opens the contract to a potential reentrancy attack if the `pal` token is malicious. A malicious token could call back into the contract before the state is updated, potentially draining the `rewardsVault` or manipulating user balances. This is relevant in the `stake`, `unstake`, `emergencyWithdraw` functions."",
      ""Impact"": ""Draining of the `rewardsVault`, manipulation of user balances, potential disruption of the protocol, or unexpected state changes."",
      ""Location"": ""claim function, stake function, unstake function, emergencyWithdraw function""
    },
    {
      ""Issue"": ""Unbounded Loop Vulnerability"",
      ""Severity"": ""High"",
      ""Description"": ""The functions `getPastTotalLock`, `getPastVotes` and `getPastDelegate` employ a binary search algorithm to find the appropriate checkpoint based on the provided `blockNumber`. However, the loop condition `low < high` does not guarantee termination if the target `blockNumber` is never found within the `totalLocks` array or `checkpoints` or `delegateCheckpoints`, respectively. If the condition for `high = mid;` or `low = mid + 1;` never leads to `low` and `high` converging, this could potentially result in an infinite loop, consuming excessive gas and causing the transaction to revert."",
      ""Impact"": ""Denial of service due to excessive gas consumption."",
      ""Location"": ""Functions: `getPastTotalLock`, `getPastVotes`, `getPastDelegate`""
    },
    {
      ""Issue"": ""Incorrect Logic in increaseLock"",
      ""Severity"": ""High"",
      ""Description"": ""The `increaseLock` function pushes a new UserLock object onto the `userLocks` array. A more appropriate implementation would modify the latest userLock object in `userLocks` to reflect the new lock, as opposed to pushing a new one. This current implementation will cause issues when calling `availableBalanceOf` due to the function referencing the latest object in the array, when this object should have been included in a single object. This will also mean that if the `duration` has changed between Lock actions, there is no way to retrieve past lock end times since they will have been overwritten."",
      ""Impact"": ""Incorrect calculation of user\'s locked amount, potentially affecting their ability to unstake or claim rewards. The contract may also not function as intended."",
      ""Location"": ""increaseLock and _lock functions""
    },
    {
      ""Issue"": ""Integer Overflow/Underflow in Reward Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The reward calculation within the `_getUserAccruedRewards` and `_getNewIndex` functions involves several multiplications and divisions that could potentially lead to integer overflow or underflow, especially with large balances, large reward indexes, or extreme bonus ratios/time differences. This can lead to incorrect reward distribution, potentially benefiting or disadvantaging users. Also, potential integer overflows/underflows exist in other calculations."",
      ""Impact"": ""Incorrect reward distribution, potentially leading to financial losses for users or the protocol. Exploitation through manipulation of balances and lock durations. In extreme cases, could halt reward distribution or lead to unexpected token balances."",
      ""Location"": ""_getUserAccruedRewards function, `_getNewIndex`, specifically calculations involving `indexDiff`, `userStakedBalance`, `userLockedBalance`, `currentTotalSupply`, `_currentDropPerSecond`, `baseDropPerSecond` and `ellapsedTime`""
    },
    {
      ""Issue"": ""Unbounded Array Length in `userLocks` and `totalLocks`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `userLocks` mapping (address => UserLock[]) and the `totalLocks` array (TotalLock[]) grow without any size limitations.  Over time, these arrays could grow significantly large, leading to high gas costs for iterating through them and potentially causing out-of-gas errors. This also occurs with delegateCheckpoints and checkpoints."",
      ""Impact"": ""Increased gas costs, potential denial of service, and scalability issues."",
      ""Location"": ""lock function, unlock function, kick function, delegate function""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `stakeAndLock` and `stakeAndIncreaseLock` first stake tokens and then lock them. An attacker could front-run the `_lock` transaction or stake transaction, potentially diluting the value of hPAL minted for the original staker or transferring tokens out of the user's account before the `_lock` function is called or benefitting from updated reward indexes. The `setEndDropPerSecond` function can also be front-run."",
      ""Impact"": ""Dilution of hPAL value for the original staker, reducing the overall yield/rewards. User may not be able to lock the full intended amount, or the lock transaction might fail. An attacker may be able to claim rewards under the old, possibly more favorable, distribution parameters before the intended update takes effect."",
      ""Location"": ""stakeAndLock and stakeAndIncreaseLock functions, `updateRewardState()`, setEndDropPerSecond function, delegate""
    },
    {
      ""Issue"": ""Improper Input Validation and Logic"",
      ""Severity"": ""Medium"",
      ""Description"": ""The logic in the `_lock` function regarding `userLock` parameters is flawed, preventing users from creating locks with smaller amounts and durations and possibly interfering with bonus ratio.  The contract also lacks sanity checks on constructor parameters. In the `_kick()` function, the kick penalty is not burned. This also applies to `setEndDropPerSecond` where the function can be called before the duration is over. The `emergencyWithdraw` function does not check to see if there\'s a current lock. Inconsistent logic can create confusion and could lead to unexpected behavior or prevent legitimate operations under certain circumstances."",
      ""Impact"": ""Lock logic will have unexpected behaviors, Incorrect lock penalty, potential for more token in circulation, Contract initialization with invalid or nonsensical parameters, potential denial-of-service conditions. Burn active locks"",
      ""Location"": ""Function `_lock()`, Function `_kick()`, Constructor, `emergencyWithdraw`""
    },
    {
      ""Issue"": ""Lack of Access Control on Reward Distribution Parameters and Functions"",
      ""Severity"": ""Medium"",
      ""Description"": ""The contract does not provide granular access control over the reward distribution parameters. A compromised owner account could significantly alter these parameters, impacting reward distribution and user incentives. There is also a lack of Access Control on `updateUserRewardState` and `updateRewardState`"",
      ""Impact"": ""Unexpected or unfair reward distribution, potential loss of user trust, and vulnerability to malicious manipulation of the rewards system."",
      ""Location"": ""setEndDropPerSecond and setKickRatio functions, and the parameters used in reward calculations, `updateUserRewardState`, `updateRewardState`""
    },
    {
      ""Issue"": ""Inconsistent reward distribution and Potential for Errors in Bonus Ratio Decrease Calculation"",
      ""Severity"": ""Medium"",
      ""Description"": ""The accrued rewards calculation in `_getUserAccruedRewards` and the logic for decrease the bonusRatio have some flaws. The bonus ratio decrease is calculated based on the time elapsed since the last reward update and then capped to avoid underflowing to zero.  This process introduces several variables, making the logic harder to reason about and potentially introducing errors. This system needs to be reviewed."",
      ""Impact"": ""LockingRewards may not reflect correctly the actual rewards and decrease reward amount, Incorrect bonus ratio calculations, leading to inaccurate reward distribution for users with locked tokens. Increased gas costs due to the complexity of the calculations. Difficulty in maintaining and auditing the code."" ,
      ""Location"": ""_getUserAccruedRewards function""
    },
    {
      ""Issue"": ""Potential DoS in `emergencyWithdraw` due to `currentTotalLocked` update"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `emergencyWithdraw` function, if a user has a lock, the `currentTotalLocked` is decreased. If the lock amount is very large, a malicious actor could intentionally cause an integer underflow in `currentTotalLocked`, which could then cause issues with other function that use `currentTotalLocked` for calculation."",
      ""Impact"": ""Integer underflow"",
      ""Location"": ""`emergencyWithdraw` function""
    },
    {
      ""Issue"": ""Imprecise Time Calculations and Rounding Errors"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract uses `block.timestamp` for various time-sensitive operations. `block.timestamp` is known to be miner-modifiable within certain bounds. Reward calculations and division operations also introduce rounding errors."",
      ""Impact"": ""Slight manipulation of cooldown periods, lock durations, and reward distributions. Inaccurate reward distribution, potential for unfairness, minor incentive issues"",
      ""Location"": ""cooldown function, lock function, unlock function, kick function, _updateDropPerSecond function, and other functions relying on block.timestamp, `_getNewIndex()`, `_getUserAccruedRewards()`""
    },
    {
      ""Issue"": ""Unnecessary Code Complexity and Potential for Errors in Lock Actions"",
      ""Severity"": ""Low"",
      ""Description"": ""The `_lock` function handles different lock actions using the `LockAction` enum. However, the logic for `LockAction.INCREASE_AMOUNT` and `LockAction.INCREASE_DURATION` could be simplified by refactoring to reduce redundancy and improve code readability."",
      ""Impact"": ""Increased code complexity, making it harder to understand and maintain. Potential for introducing bugs due to complex logic."",
      ""Location"": ""_lock function""
    },
        {
            ""Issue"": ""Potential Division by Zero"",
            ""Severity"": ""Low"",
            ""Description"": ""In the function `_getNewIndex`, the code calculates `ratio` as `(accruedBaseAmount * UNIT) / currentTotalSupply`. If `currentTotalSupply` is zero, this will result in a division by zero error, halting the contract\'s execution."",
            ""Impact"": ""Denial of service, preventing users from claiming or receiving rewards."",
            ""Location"": ""Function: `_getNewIndex`""
        },
        {
          ""Issue"": ""Inconsistent use of availableBalanceOf vs. balanceOf in Emergency Withdraw"",
          ""Severity"": ""Low"",
          ""Description"": ""The emergencyWithdraw function calculates the maximum burn amount using `balanceOf(msg.sender)`, which returns the total balance of the user, including locked and available amounts. During an emergency withdrawl, you should only burn available balances. This function needs to be using `_availableBalanceOf` instead."",
          ""Impact"": ""Potential to burn locked balance during an emergency withdrawl."",
          ""Location"": ""Function: `emergencyWithdraw`""
        },
        {
            ""Issue"": ""Potential DoS with Many Delegates"",
            ""Severity"": ""Low"",
            ""Description"": ""The functions `_moveDelegates` and `_delegate` will iterate through all delegates and checkpoints. If there are many users delegating, the gas cost of these functions could become very high, potentially leading to denial-of-service (DoS) attacks."",
            ""Impact"": ""Users may be unable to delegate or undelegate their voting power if the gas cost exceeds the block gas limit."",
            ""Location"": ""_moveDelegates and _delegate functions""
        },
        {
            ""Issue"": ""Incorrect kick function logic with regards to already expired locks"",
            ""Severity"": ""Low"",
            ""Description"": ""In the kick function, the calculation of the penalty percent is determined by `nbWeeksOverLockTime`. If a user forgets that their lock has expired and does not unlock it for a very long time, this number can increase dramatically, resulting in large penalty amounts. This may be undesirable behavior."",
            ""Impact"": ""Users who forget about their locks will be penalised substantially for not unlocking sooner"",
            ""Location"": ""_kick function""
        }
  ],
  ""IssueNumber"": 52,
  ""OutputList"": 16
}",246.11193227767944,5128.0,32.0,"### **Comparison and Evaluation**

---

#### **[H-01] DropPerSecond is not updated homogeneously, the rewards emission can be much higher than expected in some cases**

**Report Description**:  
The function `_updateDropPerSecond()` suffers from precision loss when calculating the number of months elapsed. Specifically, when the current time is `lastDropUpdate + (2*MONTH-1)`, `nbMonthEllapsed` is rounded down to 1, even though 1.99 months have passed. This results in `DropPerSecond` decreasing by only 1 * `dropDecreasePerMonth`, instead of the expected 2 * `dropDecreasePerMonth`. Over time, this discrepancy can lead to a significant shortfall in the total decrease of emission rate, potentially causing the system to emit up to twice the expected rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the precision loss issue in `_updateDropPerSecond()` or its impact on reward emissions. This is a critical oversight, as the issue directly affects the protocol's reward distribution mechanism.

---

#### **[H-02] System could be wrapped and made useless without contract whitelisting**

**Report Description**:  
The system lacks contract whitelisting, allowing anyone to create a contract or contract factory (e.g., ""PAL Locker"") to deposit PAL tokens, lock them, and delegate voting power to the contract owner. This ownership can then be sold, effectively making locked hPAL liquid and transferable again. This undermines the core design of hPAL, which relies on locking tokens to gain non-liquid, boosted voting power and rewards.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the lack of contract whitelisting or the potential for wrapping the system to make locked hPAL liquid. This is a significant security concern that could render the protocol's core functionality ineffective.

---

#### **[M-01] HolyPaladinToken.sol uses ERC20 token with a highly unsafe pattern**

**Report Description**:  
The `transferFrom()` function in `HolyPaladinToken.sol` does not follow the Checks-Effects-Interactions (CEI) pattern. Specifically, it calls `_transfer()` before updating the sender's allowance, which is highly unsafe and opens the contract to reentrancy attacks. The OpenZeppelin standard, which is the industry norm, updates the allowance before calling `_transfer()` to prevent double-spending and reentrancy vulnerabilities.

**Match in Response List**:  
**Potential Reentrancy Vulnerability**.

**Validation**:  
**Partially Correct**. The response identifies the reentrancy risk but does not specifically address the unsafe pattern in `transferFrom()` or the deviation from the OpenZeppelin standard. The issue is broader than just reentrancy, as it also involves incorrect state updates.

---

#### **[M-02] Incorrect number of seconds in `ONE_YEAR` variable**

**Report Description**:  
The `ONE_YEAR` variable in `HolyPaladinToken.sol` is incorrectly set to `31557600` seconds, which is not the accurate number of seconds in a year. This variable is used in critical functions like `getCurrentVotes()` and `getPastVotes()`, and the inaccuracy could negatively impact users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the incorrect value of the `ONE_YEAR` variable or its potential impact on time-sensitive calculations.

---

#### **[M-03] Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens**

**Report Description**:  
In the `_getNewReceiverCooldown` function, if `_senderCooldown` is Day 15 and `receiverCooldown` is Day 0, the latest cooldown for user A is calculated as `(100 * Day 15 + 200 * Day 0)/(100+200) = Day 5`. This allows users at `UNSTAKE_PERIOD` to assist others in unstaking tokens, potentially bypassing intended restrictions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of users assisting others in unstaking tokens or the potential bypass of cooldown restrictions.

---

#### **[M-04] `cooldown` is set to 0 when the user sends all tokens to himself**

**Report Description**:  
In the `_beforeTokenTransfer` function, the `cooldown` is set to 0 when a user transfers all tokens to himself. This behavior is inconsistent with the protocol's intended design and could lead to unintended consequences.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `cooldown` being reset to 0 during self-transfers or its potential impact on the protocol's functionality.

---

#### **[M-05] Past state query results are susceptible to manipulation due to multiple states with same block number**

**Report Description**:  
Past state query results can be manipulated because multiple states can exist with the same block number. This could allow malicious actors to exploit the system by submitting conflicting data for the same block.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of past state query manipulation or its potential impact on the protocol's integrity.

---

#### **[M-09] Function `cooldown()` is not protected when protocol in emergency mode**

**Report Description**:  
The `cooldown()` function is not protected when the protocol is in emergency mode, making its behavior inconsistent with other major functions. This could lead to unintended actions during emergencies.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the lack of protection for the `cooldown()` function during emergency mode or its potential impact on the protocol's security.

---

#### **[M-13] Users Can Bypass Emergency Restrictions on `updateUserRewardState()`**

**Report Description**:  
Users can bypass emergency restrictions when calling `updateUserRewardState()`, potentially allowing them to manipulate reward distributions during emergencies.

**Match in Response List**:  
**Lack of Access Control on Reward Distribution Parameters and Functions**.

**Validation**:  
**Partially Correct**. The response identifies the lack of access control but does not specifically address the bypass of emergency restrictions in `updateUserRewardState()`.

---

#### **[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards**

**Report Description**:  
Increasing the lock amount on an expired lock can cause users to miss out on rewards. The protocol should only increase the total locked amount without modifying the associated bonus ratios, as the duration remains unchanged.

**Match in Response List**:  
**Incorrect Logic in increaseLock**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `increaseLock` function and its impact on reward calculations. It correctly explains the risks associated with modifying expired locks.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards**

**Partially Correct Matches**:

- **[M-01] HolyPaladinToken.sol uses ERC20 token with a highly unsafe pattern**
- **[M-13] Users Can Bypass Emergency Restrictions on `updateUserRewardState()`**

**Missed Issues from Issue Report**:

- **[H-01] DropPerSecond is not updated homogeneously, the rewards emission can be much higher than expected in some cases**
- **[H-02] System could be wrapped and made useless without contract whitelisting**
- **[M-02] Incorrect number of seconds in `ONE_YEAR` variable**
- **[M-03] Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens**
- **[M-04] `cooldown` is set to 0 when the user sends all tokens to himself**
- **[M-05] Past state query results are susceptible to manipulation due to multiple states with same block number**
- **[M-09] Function `cooldown()` is not protected when protocol in emergency mode**

--- 

**Conclusion**:  
The response list covers some issues but misses several critical vulnerabilities, particularly those related to precision loss, contract whitelisting, and time-sensitive calculations. Additionally, some matches are only partially correct, as they fail to address the full scope of the reported issues.","```
1. Incorrect Logic in increaseLock
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Logic in increaseLock"".
   - In the ranked list of predictions, ""Incorrect Logic in increaseLock"" appears at **rank 3**.

2. **Calculate the precision at rank 3**:
   - Precision at rank 3 (\( P@3 \)) is the number of true positives up to rank 3 divided by 3.
   - Since there is only one true positive up to rank 3, \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.333 \).

**Output**:
```
0.333
```"
PaladinRewardReserve.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/utils/ReentrancyGuard.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";

/** @title Paladin Reward Reserve contract  */
/// @author Paladin
contract PaladinRewardReserve is Ownable, ReentrancyGuard{
    using SafeERC20 for IERC20;

    /** @notice Addresses allowed to transfer tokens from this contract */
    mapping(address => bool) public approvedSpenders;

    /** @notice Emitted when a new spender is approved*/
    event NewSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when the allowance of a spander is updated */
    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when a spender allowance is removed */
    event RemovedSpender(address indexed token, address indexed spender);

    constructor(address _admin) {
        transferOwnership(_admin);
    }

    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

    function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }

}",494,56,"[M-06] PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards
  [M-08] Add a timelock to PaladinRewardReserve functions
The owner of PaladinRewardReserve can approve and transfer any amount of tokens with no limits on any account. This is not good for investors. To give more trust to users: these functions should be put behind a timelock.
",2,,"pragma solidity ^0.8.4;

import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/utils/ReentrancyGuard.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";



contract PaladinRewardReserve is Ownable, ReentrancyGuard{
    using SafeERC20 for IERC20;

    
    mapping(address => bool) public approvedSpenders;

    
    event NewSpender(address indexed token, address indexed spender, uint256 amount);
    
    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);
    
    event RemovedSpender(address indexed token, address indexed spender);

    constructor(address _admin) {
        transferOwnership(_admin);
    }

    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

    function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }

}",423,0,2,"{
  ""task_list"": [
    {
      ""Area"": ""Access Control and Ownership"",
      ""Tasks"": [
        ""Verify that the `onlyOwner` modifier is correctly applied to all functions intended to be restricted to the owner."",
        ""Analyze the constructor to confirm that the owner is initialized correctly."",
        ""Examine the `transferOwnership` function in `Ownable.sol` to ensure it functions as intended and can't be abused (e.g., transferring to a zero address)."",
        ""Verify that the contract does not have any hidden owner-only functions that could be exploited."",
        ""Evaluate the impact of renouncing ownership via `renounceOwnership` and the consequences for contract functionality.""
      ]
    },
    {
      ""Area"": ""ERC20 Allowance Management and External Interactions"",
      ""Tasks"": [
        ""Verify that the `safeApprove` function is used correctly in `setNewSpender`, `updateSpenderAllowance`, and `removeSpender` to prevent potential issues with non-standard ERC20 tokens."",
        ""Investigate the potential for denial-of-service attacks by repeatedly calling `setNewSpender` with different spenders to exhaust gas limits."",
        ""Analyze the impact of setting the allowance to 0 before updating it in `updateSpenderAllowance`. Are there any potential vulnerabilities with this approach?"",
        ""Determine if the contract handles ERC20 tokens with different decimal places correctly. Consider tokens with less than 18 decimals."",
        ""Check the behavior when a spender tries to use allowance from the contract and the ERC20 token doesn't implement the expected `transferFrom` function."",
        ""Verify the `safeTransfer` function in `transferToken` correctly handles ERC20 tokens with transfer fees or deflationary mechanisms.""
      ]
    },
    {
      ""Area"": ""Reentrancy Vulnerability"",
      ""Tasks"": [
        ""Although `transferToken` uses `nonReentrant`, analyze if the `owner` or `receiver` is a contract. If so, verify that these contracts are also reentrancy-protected or trusted."",
        ""Consider potential reentrancy scenarios within the `safeTransfer` function of `transferToken` if the receiver is a contract that triggers a callback to the contract during the transfer."",
        ""Confirm that there are no other functions (even indirectly through ERC20 calls or other external interactions initiated by the owner) that could introduce reentrancy vulnerabilities.""
      ]
    },
     {
      ""Area"": ""Gas Optimization"",
      ""Tasks"": [
        ""Evaluate the gas costs of the `setNewSpender`, `updateSpenderAllowance`, and `removeSpender` functions and explore potential optimizations."",
        ""Analyze the storage patterns for `approvedSpenders` and assess if there are more gas-efficient ways to manage the spender approvals."",
        ""Consider the use of immutable or constant variables where appropriate to reduce gas costs."",
        ""Check for opportunities to reduce redundant operations or unnecessary data storage.""
      ]
    },
    {
      ""Area"": ""Logic and Functionality"",
      ""Tasks"": [
        ""Clarify the intended purpose of preventing the re-adding of spenders in the `setNewSpender` function and assess whether this restriction is necessary or could be removed."",
        ""Analyze the use case for `approvedSpenders` and confirm that it adequately serves its intended purpose in managing spender allowances. Are there alternative approaches that might be more efficient or secure?"",
        ""Document how funds are expected to enter the contract and whether any checks or validations are performed on incoming tokens."",
        ""Verify that there is a way to query the current allowance given to a spender. If not, consider adding a function to provide this information."",
         ""If `renounceOwnership` is called, ensure that the contract can still function or is intentionally bricked."",
         ""Consider adding events for key state changes and actions, such as when the owner transfers ownership.""
      ]
    },
    {
      ""Area"": ""Denial of Service (DoS)"",
      ""Tasks"": [
        ""Analyze potential DoS attack vectors where an attacker can prevent the contract from functioning correctly. For example, could a large number of approved spenders impact gas costs significantly?"",
        ""Examine the gas limits associated with each function to ensure they are sufficient for expected usage scenarios and cannot be easily exhausted by malicious actors."",
        ""Assess the impact of external contract calls (e.g., ERC20 `approve` and `transfer`) on the contract's availability, particularly in the event of external contract failures or delays.""
      ]
    }
  ]
}","{
  ""ReviewingTheCode"": ""The initial code review indicates a contract designed to hold ERC20 tokens and manage permissions for other addresses ('spenders') to withdraw these tokens, controlled entirely by a single owner. It utilizes standard OpenZeppelin contracts for ownership, reentrancy protection, and safe ERC20 interactions. The contract allows the owner to add, update, and remove spender approvals, as well as directly transfer tokens held by the contract."",
  ""IdentifyingKeyComponents"": {
    ""ContractName"": ""PaladinRewardReserve"",
    ""Purpose"": ""To act as a reserve or vault for ERC20 tokens, allowing the owner to manage ERC20 allowances for specific spender addresses and to directly transfer tokens held by the contract."",
    ""InheritanceAndImports"": {
      ""InheritsFrom"": [
        ""Ownable"",
        ""ReentrancyGuard""
      ],
      ""Imports"": [
        ""./open-zeppelin/utils/Ownable.sol"",
        ""./open-zeppelin/utils/ReentrancyGuard.sol"",
        ""./open-zeppelin/interfaces/IERC20.sol"",
        ""./open-zeppelin/libraries/SafeERC20.sol""
      ]
    },
    ""StateVariables"": [
      {
        ""Name"": ""approvedSpenders"",
        ""Type"": ""mapping(address => bool)"",
        ""Purpose"": ""Tracks addresses designated as 'spenders' managed by this contract. Public visibility implies an automatic getter function.""
      },
      {
        ""Name"": ""_owner (inherited from Ownable)"",
        ""Type"": ""address"",
        ""Purpose"": ""Stores the address of the contract owner.""
      }
    ],
    ""FunctionsAndModifiers"": [
      {
        ""Name"": ""constructor"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Initializes the contract by setting the initial owner."",
        ""Parameters"": [
          ""_admin (address)""
        ],
        ""Returns"": []
      },
      {
        ""Name"": ""setNewSpender"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to designate a new address as a spender and grant it an initial allowance for a specific ERC20 token held by this contract."",
        ""Parameters"": [
          ""token (address)"",
          ""spender (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner""]
      },
      {
        ""Name"": ""updateSpenderAllowance"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to update the ERC20 allowance for an already approved spender."",
        ""Parameters"": [
          ""token (address)"",
          ""spender (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner""]
      },
      {
        ""Name"": ""removeSpender"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to revoke spender status and reset the spender's allowance to zero."",
        ""Parameters"": [
          ""token (address)"",
          ""spender (address)""
        ],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner""]
      },
      {
        ""Name"": ""transferToken"",
        ""Visibility"": ""external"",
        ""Purpose"": ""Allows the owner to directly transfer any amount of a specific ERC20 token held by this contract to a designated receiver."",
        ""Parameters"": [
          ""token (address)"",
          ""receiver (address)"",
          ""amount (uint256)""
        ],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner"", ""nonReentrant""]
      },
      {
        ""Name"": ""onlyOwner (modifier from Ownable)"",
        ""Visibility"": ""-"",
        ""Purpose"": ""Restricts function access to the contract owner."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""nonReentrant (modifier from ReentrancyGuard)"",
        ""Visibility"": ""-"",
        ""Purpose"": ""Protects a function from reentrancy attacks."",
        ""Parameters"": [],
        ""Returns"": []
      },
      {
        ""Name"": ""owner (from Ownable)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Returns the current owner's address."",
        ""Parameters"": [],
        ""Returns"": [""address""]
      },
      {
        ""Name"": ""renounceOwnership (from Ownable)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the current owner to relinquish ownership."",
        ""Parameters"": [],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner""]
      },
      {
        ""Name"": ""transferOwnership (from Ownable)"",
        ""Visibility"": ""public"",
        ""Purpose"": ""Allows the current owner to transfer ownership to a new address."",
        ""Parameters"": [
          ""newOwner (address)""
        ],
        ""Returns"": [],
        ""Modifiers"": [""onlyOwner""]
      }
    ]
  },
  ""ExternalInteractions"": [
    ""The contract interacts with external ERC20 token contracts specified by the `token` address parameter in its functions."",
    ""It calls `safeApprove` on ERC20 contracts in `setNewSpender`, `updateSpenderAllowance`, and `removeSpender`."",
    ""It calls `safeTransfer` on ERC20 contracts in `transferToken`.""
  ],
  ""SpecialMechanisms"": [
    ""Ownable Pattern: Uses OpenZeppelin's `Ownable` for access control."",
    ""Reentrancy Guard: Uses OpenZeppelin's `ReentrancyGuard` to protect the `transferToken` function."",
    ""SafeERC20 Library: Uses OpenZeppelin's `SafeERC20` for robust interactions with potentially non-standard ERC20 tokens."",
    ""Allowance Management: Manages ERC20 allowances granted *by* this contract *to* external spender addresses."",
    ""Centralized Token Transfer: Provides an `onlyOwner` function (`transferToken`) to directly move tokens held by the contract.""
  ],
  ""Questions"": [
    ""The `setNewSpender` function requires `!approvedSpenders[spender]`. Why prevent re-adding a spender who might have been previously removed? This seems overly restrictive if the goal is just to manage active spenders."",
    ""What is the exact purpose of the `approvedSpenders` mapping? It primarily gates the `update` and `remove` functions. Does it serve any other on-chain or off-chain purpose beyond acting as a flag for whether the contract *currently* manages an allowance for that spender?"",
    ""How are funds expected to enter this reserve contract? (Presumably via direct ERC20 transfers to the contract's address)."",
    ""Given `transferToken` is `onlyOwner`, is the `nonReentrant` modifier strictly necessary, or more of a defense-in-depth measure against unlikely scenarios (e.g., owner being a malicious contract)?"",
    ""Is there a mechanism to query the current allowance granted to a spender, other than checking the target ERC20 contract directly?""
  ]
}","{
  ""Findings"": [
    {
      ""Issue"": ""Lack of Allowance Checks Before `transferToken`"",
      ""Severity"": ""High"",
      ""Description"": ""The `transferToken` function lacks a check to ensure the contract has sufficient allowance to transfer tokens. This can lead to transaction failures and potential denial of service."",
      ""Impact"": ""Transaction failures and potential denial of service."",
      ""Location"": ""Function `transferToken`""
    },
    {
      ""Issue"": ""Unbounded Approval in `setNewSpender` and `updateSpenderAllowance`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The functions `setNewSpender` and `updateSpenderAllowance` allow setting unbounded approval amounts for spenders. A compromised spender can drain approved tokens. Potential front-running vulnerability exists during allowance updates in `updateSpenderAllowance` where allowance is set to 0 before the intended amount. The functions also lack validation for `token`, `spender`, and `receiver` addresses (zero address check). Additionally, the `setNewSpender` function does not account for the potential vulnerability of ERC20 token implementations not handling `approve` calls correctly."",
      ""Impact"": ""Potential loss of funds if a spender is compromised. Risk of unexpected behavior or DOS. Risk of denial of service."",
      ""Location"": ""`setNewSpender` function, `updateSpenderAllowance` function""
    },
    {
      ""Issue"": ""Missing Access Control for `transferToken`"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `transferToken` function, while `onlyOwner`, lacks granular access control, posing a risk if the owner's account is compromised."",
      ""Impact"": ""Potential for unauthorized token transfers if the owner's account is compromised."",
      ""Location"": ""Function `transferToken`""
    },
    {
      ""Issue"": ""Potential Front-Running Vulnerability in `setNewSpender` and `updateSpenderAllowance`"",
      ""Severity"": ""Medium"",
      ""Description"": ""Attackers can front-run `setNewSpender` and `updateSpenderAllowance`, gaining temporary approval or exploiting the brief window where the allowance is zero during updates."",
      ""Impact"": ""Potential for unauthorized token usage or unexpected behavior."",
      ""Location"": ""Functions `setNewSpender` and `updateSpenderAllowance`""
    },
    {
      ""Issue"": ""Lack of access control on `token` address"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `setNewSpender`, `updateSpenderAllowance`, `removeSpender`, and `transferToken` functions all take a `token` address as input. There is no check to ensure that the provided address is actually a valid ERC20 token contract."",
      ""Impact"": ""Potential for contract to interact with non-ERC20 contracts leading to reverts or unexpected state changes. Possibility of DoS if arbitrary address doesn't implement the expected ERC20 methods."",
      ""Location"": ""Functions `setNewSpender`, `updateSpenderAllowance`, `removeSpender`, and `transferToken`""
    },
    {
      ""Issue"": ""Spender can be a contract, consider potential reentrancy"",
      ""Severity"": ""Medium"",
      ""Description"": ""The approved spender, defined via `setNewSpender`, could be a malicious contract and cause reentrancy issue."",
      ""Impact"": ""Possible unexpected behavior or denial of service if a malicious spender interacts with the contract."",
      ""Location"": ""Function `setNewSpender` and `updateSpenderAllowance`""
    },
    {
      ""Issue"": ""Potential Denial of Service: Unbounded Approval Updates"",
      ""Severity"": ""Medium"",
      ""Description"": ""The `updateSpenderAllowance` function first sets the allowance to 0 and then to the new `amount`. If the `amount` is very large and the token has a high decimal precision, this could potentially cause a denial of service if the underlying `safeApprove` operations consume excessive gas."",
      ""Impact"": ""Potential denial of service by exhausting gas limits."",
      ""Location"": ""PaladinRewardReserve.sol: updateSpenderAllowance function""
    },
    {
      ""Issue"": ""Lack of Rate Limiting or Spending Limits"",
      ""Severity"": ""Low"",
      ""Description"": ""There's no mechanism to limit how frequently a spender can withdraw funds or a maximum total spending limit."",
      ""Impact"": ""Potential for rapid depletion of reward reserve."",
      ""Location"": ""Entire contract""
    },
    {
      ""Issue"": ""Missing Event for Ownership Transfer"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor should emit an event when ownership is transferred to improve auditing and traceability."",
      ""Impact"": ""Reduced transparency and auditability of ownership changes."",
      ""Location"": ""Constructor""
    },
    {
      ""Issue"": ""Unnecessary Approval Reset in `updateSpenderAllowance`"",
      ""Severity"": ""Low"",
      ""Description"": ""The function `updateSpenderAllowance` calls `IERC20(token).safeApprove(spender, 0)` before setting the new allowance. Resetting to zero might not always be necessary and could waste gas."",
      ""Impact"": ""Minor gas inefficiency."",
      ""Location"": ""Function `updateSpenderAllowance`""
    },
    {
      ""Issue"": ""Potential Front-Running on `removeSpender`"",
      ""Severity"": ""Low"",
      ""Description"": ""A front-running attack is theoretically possible if the owner intends to remove a spender."",
      ""Impact"": ""Low risk, but theoretically possible exploitation window before removal."",
      ""Location"": ""`removeSpender` function""
    },
    {
      ""Issue"": ""Missing Zero-Address Check for Token and Spender Addresses"",
      ""Severity"": ""Low"",
      ""Description"": ""The functions `setNewSpender`, `updateSpenderAllowance`, `removeSpender`, and `transferToken` do not check if the `token`, `spender` or `receiver` addresses are the zero address (0x0)."",
      ""Impact"": ""Potential for accidental token burning or unexpected behavior if zero address is used."",
      ""Location"": ""PaladinRewardReserve.sol: setNewSpender, updateSpenderAllowance, removeSpender, and transferToken functions""
    },
    {
      ""Issue"": ""Missing Event for `transferToken` function"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferToken` function doesn't emit an event, making it harder to track token movements and debug issues."",
      ""Impact"": ""Reduced auditability."",
      ""Location"": ""Function `transferToken`""
    },
    {
      ""Issue"": ""Missing Role-Based Access Control for Spender Management"",
      ""Severity"": ""Low"",
      ""Description"": ""The contract only uses `Ownable` for managing approved spenders. Consider using a role-based access control system to delegate spender management to specific accounts without granting full ownership."",
      ""Impact"": ""Lack of granular access control could concentrate too much power in the owner's hands, increasing the risk of accidental or malicious misconfiguration."",
      ""Location"": ""PaladinRewardReserve.sol:26, PaladinRewardReserve.sol:35, PaladinRewardReserve.sol:42""
    },
    {
      ""Issue"": ""Approval of Zero Amount in removeSpender"",
      ""Severity"": ""Low"",
      ""Description"": ""In the `removeSpender` function, the contract executes `IERC20(token).safeApprove(spender, 0)`. If a token doesn\'t properly handle approval of 0 amount, the functionality could break."",
      ""Impact"": ""Potential unexpected behavior based on the specific token\'s implementation."",
      ""Location"": ""removeSpender""
    },
    {
      ""Issue"": ""Missing Zero Address Check for `_admin` in Constructor"",
      ""Severity"": ""Low"",
      ""Description"": ""The constructor accepts an `_admin` address but doesn't check if it's the zero address."",
      ""Impact"": ""Contract can be rendered unusable if the zero address is passed as the owner during deployment."",
      ""Location"": ""Constructor, line 21""
    },
    {
      ""Issue"": ""Reentrancy Risk mitigated by ReentrancyGuard but Worth Noting"",
      ""Severity"": ""Low"",
      ""Description"": ""The `transferToken` function uses `safeTransfer` which helps prevent direct ERC20 reentrancy. However, the contract also inherits `ReentrancyGuard`. Although `ReentrancyGuard` mitigates reentrancy issues, it's still important to be aware of potential reentrancy attack vectors."",
      ""Impact"": ""Low, mitigated by ReentrancyGuard and SafeERC20, but worth keeping in mind for complex token implementations."",
      ""Location"": ""PaladinRewardReserve.sol: transferToken function""
    },
    {
      ""Issue"": ""Approved Spenders Map Not Used for Transfer Function"",
      ""Severity"": ""Informational"",
      ""Description"": ""The `transferToken` function allows the owner to transfer any amount of tokens out of the contract. This function doesn\'t interact with the `approvedSpenders` mapping, meaning that an approved spender has no bearing on this function."",
      ""Impact"": ""Owner can transfer all tokens regardless of spender allowance."",
      ""Location"": ""PaladinRewardReserve.sol: transferToken function""
    }
  ],
  ""IssueNumber"": 42,
  ""OutputList"": 18
}",189.42704224586487,3206.0,32.0,"### **[M-06] PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards**

**Report Description**:
The issue highlights that `PaladinRewardReserve.sol` may encounter bugs when using new tokens as rewards. This could lead to unexpected behavior or vulnerabilities if the contract interacts with tokens that do not adhere to standard ERC20 implementations or have unique behaviors.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific concern of potential bugs arising from the use of new or non-standard tokens as rewards. This issue is unique and not covered by any of the findings in the response list.

---

### **[M-08] Add a timelock to PaladinRewardReserve functions**

**Report Description**:
The owner of `PaladinRewardReserve` can approve and transfer any amount of tokens without limits, which is not ideal for investor trust. The report suggests implementing a timelock on these functions to enhance security and trust by preventing immediate, unrestricted actions by the owner.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the need for a timelock mechanism to restrict the owner's ability to approve and transfer tokens. This is a specific security enhancement that is not covered in the provided findings.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[M-06] PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards**
- **[M-08] Add a timelock to PaladinRewardReserve functions**

---

### **Analysis of Gaps**:
The response list does not address the two issues raised in the `issue` report. Specifically:
1. The potential bugs arising from the use of new or non-standard tokens as rewards are not covered.
2. The suggestion to implement a timelock on owner-controlled functions is also missing.

These gaps indicate that the response list does not fully address the security concerns and recommendations outlined in the `issue` report. Additional findings or recommendations should be added to cover these specific vulnerabilities and improvements.","```
None.
```",0.0
